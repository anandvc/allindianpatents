<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/229512-intrusion-detection-accelerator by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:12:41 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 229512:INTRUSION DETECTION ACCELERATOR</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">INTRUSION DETECTION ACCELERATOR</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>As shown in FIG. 2B, signatures of character strings in a document which may indicate a possible intrusion into or attack on a networked computer system or node thereof or other security breach are detected at high speed using a hardware accelerator (100) within the environment of a hardware parser accelerator. An interrupt or exception can thus be issued to a host CPU (230) before a command which may constitute such a security breach, intrusion or attack can be made executable by parsing of a document. The CPU (230) can initiate network control measures to prevent or limit the intrusion.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>DESCRIPTION<br>
BACKGROUND OF THE INVENTION<br>
Field of the Invention<br>
The present invention generally relates to<br>
parsing of documents such as an XML™ document and,<br>
more particularly to parsing a document or other<br>
logical sequence of network data packets for<br>
detecting potential intrusion or an attack on a node<br>
of a network.<br>
Description of the Prior Art<br>
The field of digital communications between<br>
computers and the linking of computers into networks<br>
has developed rapidly in recent years, similar, in<br>
many ways to the proliferation of personal computers<br>
of a few years earlier. This increase in<br>
interconnectivity and the possibility of remote<br>
processing has greatly increased the effective<br>
capability and functionality of individual computers<br>
in such networked systems. Nevertheless, the<br>
variety of uses of individual computers and systems,<br>
preferences of their users and the state of the art<br>
when computers are placed into service has resulted<br>
in a substantial degree of variety of capabilities<br>
and configurations of individual machines and their<br>
operating systems, collectively referred to as<br>
"platforms" which are generally incompatible with<br>
each other to some degree particularly at the level<br><br>
of operating system and programming language.<br>
This incompatibility of platform<br>
characteristics and the simultaneous requirement for<br>
the capability of communication and remote<br>
processing and a sufficient degree of compatibility<br>
to support it has resulted in the development of<br>
object oriented programming (which accommodates the<br>
concept of assembling an application as well as data<br>
as a group of more or less generalized modules<br>
through a referencing system of entities, attributes<br>
and relationships) and a number of programming<br>
languages to embody it. Extensible Markup Language™<br>
(XMLTM) is such a language which has come into<br>
widespread use and can be transmitted as a document<br>
over a network of arbitrary construction and<br>
architecture.<br>
In such a language, certain character strings<br>
correspond to certain commands or identifications,<br>
including special characters and other important<br>
data (collectively referred to as control words)<br>
which allow data or operations to, in effect,<br>
identify themselves so that they may be, thereafter<br>
treated as "objects" such that associated data and<br>
commands can be translated into the appropriate<br>
formats and commands of different applications in<br>
different languages in order to engender a degree of<br>
compatibility of respective connected platforms<br>
sufficient to support the desired processing at a<br>
given machine. The detection of these character<br>
Strings' is performed by an operation known as<br>
parsing, similar to the more conventional usage of<br>
resolving the syntax of an expression, such as a<br>
sentence, into its component parts and describing<br>
them grammatically.<br><br>
When parsing an XML™ document, a large portion<br>
and possibly a majority of the central processor<br>
unit (CPU) execution time is spent traversing the<br>
document searching for control words, special<br>
characters and other important data as defined for<br>
the particular XML™ standard being processed. This<br>
is typically done by software which queries each<br>
character and determines if it belongs to the<br>
predefined set of strings of interest, for example,<br>
a set of character strings comprising the following<br>
w<command>", "<data dataword>", "<endcommand>",<br>
etc. If any of the target strings are detected, a<br>
token is saved with a pointer to the location in the<br>
document for the start of the token and the length<br>
of the token. These tokens are accumulated until<br>
the entire document has been parsed.<br>
"The conventional approach is to implement a<br>
table-based finite state machine (FSM) to search for<br>
these strings of interest. The state table resides<br>
in memory and is designed to search for the specific<br>
patterns in the document. The current state is used<br>
as the base address into the state table and the<br>
ASCII representation of the input character is an<br>
index into the table. For example, assume the state<br>
machine is in state 0 (zero) and the first input<br>
character is ASCII value 02, the absolute address<br>
for the state entry would be the sum/concatenation<br>
of the base address (state 0) and the index/ASCII<br>
character (02). The FSM begins with the CPU<br>
fetching the first character of the input document<br>
from memory. The CPU then constructs the absolute<br>
address in the state table in memory corresponding<br>
to the initialized/current state and the input<br>
character and then fetches the state data from the<br><br>
state table. Based on the state data that is<br>
returned, the CPU updates the current state to the<br>
new value, if different (indicating that the<br>
character corresponds to the first character of a<br>
string of interest) and performs any other action<br>
indicated in the state data (e.g. issuing a token or<br>
an interrupt if the single character is a special<br>
character or if the current character is found, upon<br>
a further repetition of the foregoing, to be the<br>
last character of a string of interest).<br>
The above process is repeated and the state is<br>
changed as successive characters of a string of<br>
interest are found. That is, if the initial<br>
character is of interest as being the initial<br>
character of a string of interest, the state of the<br>
FSM can be advanced to a new state (e.g. from<br>
initial state 0 to state 1). If the character is<br>
not of interest, the state machine would (generally)<br>
remain the same by specifying the same state (e.g.<br>
state 0) or not commanding a state update) in the<br>
state table entry that is returned from the state<br>
table address. Possible actions include, but are<br>
not limited to, setting interrupts, storing tokens<br>
and updating pointers. The process is then repeated<br>
with the following character. It should be noted<br>
that while a string of interest is being followed<br>
and the FSM is in a state other than state 0 (or<br>
other state indicating that a string of interest has<br>
not yet been found of currently being followed) a<br>
character may be found which is not consistent with<br>
a current string but is an initial character of<br>
another string of interest. In such a case, state<br>
table entries would indicate appropriate action to<br>
indicate and identify the string fragment or portion<br><br>
previously being followed and to follow the possible<br>
new string of interest until the new string is<br>
completely identified or" found not to be a string of<br>
interest. In other words, strings of interest may<br>
be nested and the state machine must be able to<br>
detect a string of interest within another string of<br>
interest, and so on. This may require the CPU to<br>
traverse portions of the XML™ document numerous<br>
times to completely parse the XML™ document.<br>
The entire XML™ or other language document is<br>
parsed character-by-character in the above-described<br>
manner. As potential target strings are recognized,<br>
the FSM steps through various state character-by-<br>
character until a string of interest is fully<br>
identified or a character inconsistent with a<br>
possible string of interest is encountered (e.g.<br>
when the string is completed/fully matched or a<br>
character deviates from a target string). In the<br>
latter case, no action is generally taken other than<br>
returning to the initial state or a state<br>
corresponding to the detection of an initial<br>
character of another target string. In the former<br>
case, the token is stored into memory along with the<br>
starting address in the input document and the<br>
length of the token. When the parsing is completed,<br>
all objects will have been identified and processing<br>
in accordance with the local or given platform can<br>
be started.<br>
Since the search is generally conducted for<br>
multiple strings of interest, the state table can<br>
provide multiple transitions from any given state.<br>
This approach allows the current character to be<br>
analyzed for multiple target strings at the same<br>
time while conveniently accommodating nested<br><br>
strings.<br>
It can be seen from the foregoing that the<br>
parsing of a document such as an XML™ document<br>
requires many repetitions and many memory accesses<br>
for each repetition. Therefore, processing time on<br>
a general purpose CPU is necessarily substantial. A<br>
further major complexity of handling the multiple<br>
strings lies in the generation of the large state<br>
tables and is handled off-line from the real-time<br>
packet processing. However, this requires a large<br>
number of CPU cycles to fetch the input character<br>
data, fetch the state data and update the various<br>
pointers and state addresses for each character in<br>
the document. Thus, it is relatively common for the<br>
parsing of a document such as an XML™ document to<br>
fully pre-empt other processing on the CPU or<br>
platform and to substantially delay the processing<br>
requested.<br>
It has been recognized in the art that, through<br>
programming, general-purpose hardware can be made to<br>
emulate the function of special purpose hardware and<br>
that special purpose data processing hardware will<br>
often function more rapidly than programmed general<br>
purpose hardware even if the structure and program<br>
precisely correspond to each other since there is<br>
less overhead involved in managing and controlling<br>
special purpose hardware. Nevertheless, the<br>
hardware resources required for certain processing<br>
may be prohibitively large for special purpose<br>
hardware, particularly where the processing speed<br>
gain may be marginal. Further, special purpose<br>
hardware necessarily has functional limitations and<br>
providing sufficient flexibility for certain<br>
applications such as providing the capability of<br><br>
searching for an arbitrary number of arbitrary<br>
combinations of characters may also be prohibitive.<br>
Thus, to be feasible, special purpose hardware must<br>
provide a large gain in processing speed while<br>
providing very substantial hardware economy;<br>
requirements which are increasingly difficult to<br>
accommodate simultaneously as increasing amounts of<br>
functional flexibility or programmability are needed<br>
in the processing function required.<br>
In this regard, the issue of system security is<br>
also raised by both interconnect ability and the<br>
amount of processing time required for parsing a<br>
document such as an XML™ document. On the one hand,<br>
any process which requires an extreme amount of<br>
processing time at relatively high priority is, in<br>
some ways, similar to some characteristics of a<br>
denial-of-service (DOS) attack on the system or a<br>
node thereof or can be a tool that can be used in<br>
such an attack.<br>
DOS attacks frequently present frivolous or<br>
malformed requests for service to a system for the<br>
purpose of maliciously consuming and eventually<br>
overloading available resources. Proper<br>
configuration of hardware accelerators can greatly<br>
reduce or eliminate the potential to overload<br>
available resources. In addition, systems often<br>
fail or expose security weaknesses when overloaded.<br>
Thus, eliminating overloads is an important security<br>
consideration.<br>
Further, it is possible for some processing to<br>
begin and some commands to be executed before<br>
parsing is completed since the state table must be<br>
able to contain CPU commands at basic levels which<br>
are difficult or impossible to secure without severe<br><br>
compromise of system performance. In short, the<br>
potential for compromise of security would be<br>
necessarily reduced by reduction of processing time<br>
for processes such as XML™ parsing but no technique<br>
for significantly reducing the processing time for<br>
such parsing has been available.<br>
Many security systems rely on the ability to<br>
detect an attempted security breach at a very early<br>
stage and a security breach may be difficult or<br>
impossible to interrupt quickly or through<br>
programmed intervention, once begun. For example, a<br>
highly secure system has been proposed and is<br>
disclosed in U. S. Patent Applications 09/973,769<br>
and 09/973,776, both assigned to the assignee of the<br>
present application. These applications disclose a<br>
system having two levels of internodal<br>
communications, one at very high speed, by which a<br>
node at which a possible attack or intrusion is<br>
detected can be compartmentalized and then<br>
automatically repaired, if necessary, before<br>
reconnection to the network. Acceleration of<br>
parsing therefore supports early response to a<br>
potential attack and is particularly advantageous in<br>
a system such as that disclosed in the system<br>
described in the above-incorporated patent<br>
applications since an appropriate control of the<br>
network can be initiated as an incident of parsing<br>
and can thus be initiated at an earlier time if<br>
parsing can be significantly accelerated. Proper<br>
network control, initiated in a timely fashion in<br>
response to a detection alert can effect intrusion<br>
prevention in addition to intrusion detection.<br><br>
SUMMARY OF THE INVENTION<br>
The present invention provides a hardware<br>
parser accelerator which provides extreme<br>
-acceleration of parsing of documents for detection<br>
of signatures of a possible intrusion, attack or<br>
other security breach in a networked computer system<br>
at speeds Which accommodate network transmission<br>
packet speeds for potentially real-time intrusion<br>
detection and prevention actions.<br>
In order to accomplish this and other objects<br>
of the invention, an intrusion detection system,<br>
possibly implemented within a document parser is<br>
provided, comprising a character buffer for a<br>
plurality of bytes of a document, a state table<br>
addressable in accordance with a byte of a document<br>
and a state to access at least one of an interrupt<br>
or exception and next state data from the state<br>
table, a register for storing next state data, an<br>
adder for combining contents of the register with a<br>
subsequent byte of a document to form a further<br>
address into the state memory, and a bus for<br>
communicating the interrupt or exception to a host<br>
CPU.<br><br>
BRIEF DESCRIPTION OF THE ACCOMPANYING DRAWINGS<br>
The foregoing and other objects, aspects and<br>
advantages will be better understood from the<br>
following detailed description of a preferred<br>
embodiment of the invention with reference to the<br>
drawings, in which:<br>
Figure 1 is a representation of a portion of a<br>
state table used in parsing a document,<br>
Figure 2A is a high level schematic diagram of<br>
the parser accelerator in accordance with a<br>
concurrently filed related provisional patent<br>
application,<br>
Figure 2B is a high-level schematic diagram of<br>
the parser accelerator in accordance with the<br>
present invention,<br>
Figure 2C illustrates an implementation of the<br>
invention with a host processor and main memory,<br>
Figure 3 illustrates a preferred character<br>
palette format as depicted in Figure 2A,<br>
Figures 4A and 4B illustrate a state table<br>
format and a state table control register used in<br>
conjunction therewith in a preferred form of the<br>
invention as depicted in Figure 2A,<br>
Figure 5A illustrates a preferred next state<br>
palette format as depicted in Figure 2A,<br>
Figure 5B illustrates a preferred state table<br>
entry format for use with the invention as depicted<br>
in Figure 2B, and<br>
Figure 6 is a preferred token format as<br>
depicted in Figure 5.<br><br>
DETAILED DESCRIPTION OF A PREFERRED<br>
EMBODIMENT OF THE INVENTION<br>
Referring now to the drawings, and more<br>
particularly to Figure 1, there is shown a<br>
representation of a portion of a state table useful<br>
in understanding the invention. It should be<br>
understood that the state table shown in Figure 1 is<br>
potentially only a very small portion of a state<br>
table useful for parsing an XML™ document and is<br>
intended to be exemplary in nature. While the full<br>
state table does not physically exist, at least in<br>
the form shown, in the invention and Figure 1 can<br>
also be used in facilitating an understanding of the<br>
operation of known software parsers, no portion of<br>
Figure 1 is admitted to be prior art in regard to<br>
the present invention.<br>
It should be noted that an XML™ document is<br>
used herein as an example of one type of logical<br>
data sequence which can be processed using an<br>
accelerator in accordance with the invention. Other<br>
logical data sequences can also be constructed from<br>
network data packet contents such as user terminal<br>
command strings intended for execution by shared<br>
server computers. Such command strings are<br>
frequently generated by malicious users and sent to<br>
shatred server computers as part of a longer term<br>
intrusion attempt. The accelerator in accordance<br>
with the invention is suitable for processing many<br>
such logical data sequences.<br>
It will also be helpful observe that many<br>
entries in the portion of the state table<br>
illustrated in Figure 1 are duplicative and it is<br>
important to an appreciation of the invention that<br><br>
hardware to accommodate the entirety of the state<br>
table represented by Figure 1 is not required.<br>
Conversely, while the invention can be implemented<br>
in software, possibly using a dedicated processor,<br>
that the hardware requirements in accordance with<br>
the invention are sufficiently limited that the<br>
penalty in increased processing time for parsing by<br>
software is not justified by any possible economy in<br>
hardware.<br>
It should be appreciated, however, that the<br>
intrusion detection system is intended to be<br>
applicable to any type of digital file and is not<br>
limited to text files or particular languages which<br>
may be used to represent particular applications or<br>
data structures at or exceeding packet transmission<br>
speeds which can accommodate real-time digital<br>
transmissions over networks through which security<br>
attacks are generally perpetrated. Thus, the<br>
invention may be implemented as an arrangement for<br>
providing only intrusion detection; in which case<br>
substantially optimum performance at lowest cost<br>
would be expected. However, the goal of performing<br>
intrusion detection at signal transmission speeds<br>
can also be achieved as a special mode of operation<br>
of a parser accelerator in which some operations are<br>
omitted to provide further acceleration, possibly<br>
augmented by alternative state table memory<br>
arrangements as will be described below and which is<br>
presently considered to be preferred. Therefore,<br>
the invention will be described in the context of a<br>
parser accelerator in the interest of completeness<br>
and to convey a more thorough understanding of the<br>
scope of advantages provided by the invention even<br>
though that context is more complex than necessary<br><br>
for the invention to function as intended for real-<br>
time, high-speed intrusion detection.<br>
In Figure 1 the state table is divided into an<br>
arbitrary number of rows, each having a base address<br>
corresponding to a state. The rows of the base<br>
address are divided into a number of columns<br>
corresponding to the number of codes which may be<br>
used to represent characters in the document to be<br>
parsed; in this example, two hundred fifty-six (256)<br>
columns corresponding to a basic eight bit byte for<br>
a character which is used as an index into the state<br>
table.<br>
It will be helpful to note several aspects of<br>
the state table entries shown, particularly in<br>
conveying an understanding of how even the small<br>
portion of the exemplary state table illustrated in<br>
Figure 1 supports the detection of many words:<br>
1. In the state table shown, only two entries<br>
in the row for state 0 include an entry other than<br>
"stay in state 0" which maintains the initial state<br>
when the character being tested does not match the<br>
initial character of any string of interest. The<br>
single entry which provides for progress to state 1<br>
corresponds to a special case where all strings of<br>
interest begin with the same character. Any other<br>
character that would provide progress to another<br>
state would generally but not necessary progress to<br>
a state other than state 1 but a further reference<br>
to the same state that could be reached through<br>
another character may be useful to, for example,<br>
detect nested strings. The inclusion of a command<br>
(e.g. "special interrupt") with "stay in state 0"<br>
illustrated at {state 0, FD} would be used to detect<br>
and operate on special single characters.<br><br>
2.	In states above state 0, an entry of "stay-<br>
in state n" provides for the state to be maintained<br>
through potentially long runs of one or more<br>
characters such as might be encountered, for<br>
example, in numerical arguments of commands, as is<br>
commonly encountered. The invention provides<br>
special handling of this type of character string to<br>
provide enhanced acceleration, as will be discussed<br>
in detail below.<br>
3.	In states above state 0, an entry of "go to<br>
state 0" signifies detection of a character which<br>
distinguishes the string from any string of<br>
interest, regardless of how many matching characters<br>
have previously been detected and returns the<br>
parsing process to the initial/default state to<br>
begin searching for another string of interest.<br>
(For this reason, the "go to state 0" entry will<br>
generally be, by far, the most frequent or numerous<br>
entry in the state table.) Returning to state 0 may<br>
require the parsing operation to return to a<br>
character in the document subsequent to the<br>
character which began the string being followed at<br>
the time the distinguishing character was detected.<br>
4.	An entry including a command with "go to<br>
state 0 indicates completion of detection of a<br>
complete string of interest. In general, the<br>
command will be to store a token (with an address<br>
and length of the token) which thereafter allows the<br>
string to be treated as an object. However, a<br>
command with "go to state n" provides for launching<br>
of an operation at an intermediate point while<br>
continuing to follow a string which could<br>
potentially match a string of interest.<br>
5.	To avoid ambiguity at any point where the<br><br>
search branches between two strings of interest<br>
(e.g. strings having n-1 identical initial<br>
characters but different n-th characters, or<br>
different initial characters), it is generally<br>
necessary to proceed to different (e.g. non-<br>
consecutive) states, as illustrated at {state 1, 01}<br>
and {statel, FD}. Complete identification of a<br>
string of arbitrary length n will require n-1 states<br>
except for the special circumstances of included<br>
strings of special characters and strings of<br>
interest which have common initial characters. For<br>
these reason, the number of states and rows of the<br>
state table must usually be extremely large, even<br>
for relatively modest numbers of strings of<br>
interest.<br>
7. Conversely to the previous paragraph, most<br>
states can be fully characterized by one or two<br>
unique entries and a default "go to state 0". This<br>
feature of the state table of Figure 1 is exploited<br>
in the invention to produce a high degree of<br>
hardware economy and substantial acceleration of the<br>
parsing process for the general case of strings of<br>
interest.<br>
As alluded to above, in the parsing operation,<br>
as conventionally performed, begins with the system<br>
in a given default/initial state, depicted in Figure<br>
1 as state 0, and then progresses to higher numbered<br>
states as matching characters are found upon<br>
repetitions of the process. When a string of<br>
interest has been completely identified or when a<br>
special operation is specified at an intermediate<br>
location in a string which is potentially a match,<br>
the operation such as storing a token or issuing an<br>
interrupt is performed. At each repetition for each<br><br>
character of the document, however, the character<br>
must be fetched from CPU memory, the state table<br>
entry must be fetched (again from CPU memory) and<br>
various pointers (e.g. to a character of the<br>
document and base address in the state table) and<br>
registers (e.g. to the initial matched character<br>
address and an accumulated length of the string)<br>
must be updated in sequential operations.<br>
Therefore, it can be readily appreciated that the<br>
parsing operation can consume large amounts of<br>
processing time.<br>
A high-level schematic block diagram of the<br>
parser accelerator 100 in accordance with the<br>
invention is illustrated in Figure 2A. As will be<br>
appreciated by those skilled in the art, Figure 2A<br>
can also be understood as a flow diagram<br>
illustrating the steps performed in accordance with<br>
the invention to perform parsing. As will be<br>
discussed in greater detail below in connection with<br>
Figures 3, 4A, 4B, 5A and 6, the invention exploits<br>
some hardware economies in representing the state<br>
table such that a plurality of hardware pipelines<br>
are developed which operate essentially in parallel<br>
although slightly skewed in time. Thus, the<br>
updating of pointers and registers can be performed<br>
substantially in parallel and concurrently with<br>
other operations while the time required for memory<br>
accesses is much reduced through both faster access<br>
hardware operated in parallel and prefetching from<br>
CPU memory in regard to the state table and the<br>
document.<br>
As a general overview, the document such as an<br>
XML™ document is stored externally in DRAM 120 which<br>
is indexed by registers 112, 114 and transferred by,<br><br>
preferably, thirty-two bit words to and input buffer<br>
130 which serves as a multiplexer for the pipelines.<br>
Each pipeline includes a copy of a character palette<br>
140, state table 160 and a next state palette 170;<br>
each accommodating a compressed form of part of the<br>
state table. The output of the next state palette<br>
170 contains both the next state address portion of<br>
the address into entries in the state table 160 and<br>
the token value to be stored, if any. Operations in<br>
the character palette 140 and the next state palette<br>
170 are simple memory accesses into high speed<br>
internal SRAM which may be performed in parallel<br>
with each other as well as in parallel with simple<br>
memory accesses into the high speed external DRAM<br>
forming the state table 160 (which may also be<br>
implemented as a cache). Therefore, only a<br>
relatively few clock cycles of the CPU initially<br>
controlling these hardware elements (but which, once<br>
started, can function autonomously with only<br>
occasional CPU memory operation calls to refresh the<br>
document data and to store tokens) are required for<br>
an evaluation of each character in the document.<br>
The basic acceleration gain is the reduction of the<br>
sum of all memory operation durations per character<br>
in the CPU plus the CPU overhead to the duration of<br>
a single autonomously performed memory operation in<br>
high-speed SRAM or DRAM.<br>
It should be understood that memory structures<br>
referred to herein as "external" is intended to<br>
connote a configuration of memories 120, 140, which<br>
is preferred by the inventors at the present time in<br>
view of the amount of storage required and access<br>
from the hardware parser accelerator and/or the host<br>
CPU. In other words, it may be advantageous for<br><br>
handling of tokens and some other operations to<br>
provide an architecture of the parser accelerator in<br>
accordance with the invention to facilitate sharing<br>
of the memory or at least access to the memory by<br>
the host CPU as well as the hardware accelerator.<br>
No other connotation intended and a wide variety of<br>
hardware alternatives such as synchronous DRAM<br>
(SDRAM) will be recognized as suitable by those<br>
skilled in the art in view of this discussion.<br>
Referring now to Figures 3-6, the formats of<br>
the character palette 14 0, the state table 160, next<br>
state palette 170 and next state and token will be<br>
discussed as exemplary of the hardware economies<br>
which support the preferred implementation of Figure<br>
2A. Other techniques/formats can be employed, as<br>
well, and the illustrated formats should be<br>
understood as exemplary although currently<br>
preferred.<br>
Figure 3 illustrates the preferred form of a<br>
character palette which corresponds to the<br>
characters which are or may be included in the<br>
strings of interest. This format preferably<br>
provides entries numbered 0 - 255, corresponding to<br>
the number of columns in the state table of Figure<br>
1. (The term "palette" is used in much the same<br>
sense as in the term "color palette" containing data<br>
for each color supported and collectively referred<br>
to as a gamut. Use of a pallette reduces<br>
entries/columns in the state table.) For example, a<br>
character referred to as a "null character" which<br>
does not result in a change of state can be<br>
expressed in one column of the state table rather<br>
than many such columns. It is desirable to test for<br>
a null character output at 144 which can<br><br>
substantially accelerate processing for parsing<br>
since it allows immediate processing of the next<br>
character without a further memory operation for<br>
state table access. The format can be accommodated<br>
by a single register or memory locations configured<br>
as such by, for example, data in base address<br>
register 142 which points to a particular character<br>
palette (schematically illustrated by overlapping<br>
memory planes in Figure 2). The current eight bit<br>
character from the document (e.g. XML™ document),<br>
one of four provided from the input buffer 130 as<br>
received as a four byte word from the external DRAM<br>
120, addresses an entry in the character palette<br>
which then outputs an address as an index or partial<br>
pointer into the state memory. Thus by providing a<br>
palette in such a format a portion of the<br>
functionality of Figure 1 can be provided in the<br>
form of a single register of relatively limited<br>
capacity; thus allowing a plurality thereof to be<br>
formed and operated in parallel while maintaining<br>
substantial hardware economy and supporting others<br>
in the state table 160.<br>
Figure 4A shows the preferred state table<br>
format which is constituted or configured similarly<br>
to the character palette (e.g. substantially as a<br>
register). The principal difference from the<br>
character palette of Figure 3 is that the length of<br>
the register is dependent on the number of responses<br>
to characters desired and the number and length of<br>
strings of interest. Therefore, it is considered<br>
desirable to provide for the possibility of<br>
implementing this memory in CPU or other external<br>
DRAM (possibly with an internal or external cache)<br>
if the amount of internal memory which can be<br><br>
economically provided is insufficient in particular<br>
instances. Nevertheless, it is clear that a<br>
substantial hardware economy is provided since<br>
highly duplicative entries in the state table of<br>
Figure 1 can be reduced to a single entry; the<br>
address of which is accommodated by the data<br>
provided as described above in accordance with the<br>
character palette of Figure 3. The output of the<br>
state table 160 is preferably one, two or four bits<br>
but provision for as much as thirty-two bits may<br>
provide increased flexibility, as will be discussed<br>
below in connection with Figure 4B. In any case,<br>
the output of the state table provides an address or<br>
pointer into the next state palette 170.<br>
Referring now to Figure 4B, as a perfecting<br>
feature of the invention in this latter regard, a<br>
preferred implementation feature of the invention<br>
includes a state table control register 162 which<br>
allows a further substantial hardware economy,<br>
particularly if a thirty-two bit output of state<br>
table 160 is to be provided. Essentially, the state<br>
table control register provides for compression of<br>
the state table information by allowing a variable<br>
length word to be stored in and read out of the<br>
state table.<br>
More specifically, the state table control<br>
register 162 stores and provides the length of each<br>
entry in the state table 160 of Figure 4A. Since<br>
some state table entries in Figure 1 are highly<br>
duplicative (e.g. "go to state 0", "stay in state<br>
n"), these entries not only can be represented by a<br>
single entry in state table 160 or at least much<br>
fewer than in Figure 1 but may also be represented<br>
by fewer bits, possibly as few as one which will<br><br>
yield substantial hardware economies even if most or<br>
all duplicative entries are included in the state<br>
table, as may be found convenient in some state<br>
tables. The principle of this reduction will be<br>
recognized by those skilled in the art as similar to<br>
so-called entropy coding.<br>
Referring now to Figure 5A, the preferred<br>
format of the next state palette 170 will now be<br>
discussed. The next state pallette 170 is<br>
prefexably implemented in much the same manner as<br>
the character palette 140 discussed above. However,<br>
as with the state memory 160, the number of entries<br>
that may be required is not, a priori, known and the<br>
length of individual entries is preferably much<br>
longer (e.g. two thirty-two bit words). On the<br>
other hand, the next state palette 170 can be<br>
operated as a cache (e.g. using next state palette<br>
base address register 172) since only relatively<br>
small and predictable ranges of addresses need be<br>
contained at any given time. Further, if thirty-two<br>
bit outputs of the state table 160 is provided, some<br>
of that data can be used to supplement the data in<br>
entries of the next state palette 170, possibly<br>
allowing shorter entries in the latter or possibly<br>
bypassing the next state pallette altogether, as<br>
indicated by dashed line 175.<br>
As shown in Figure 5A, the lower address<br>
thirty-two bit word output from the next state<br>
palette 170 is the token to be saved. This token<br>
preferably is formed as a token value of sixteen<br>
bits, eight bits of token flags, both of which are<br>
stored in token buffer 190 at an address provided by<br>
pointer 192 to the beginning of the string and<br>
together with the length accumulated by counting<br><br>
successful character comparisons, and eight bits of<br>
control flags. The control flags set interrupts to<br>
the host CPU or control processing in the parser<br>
accelerator. One of these latter control flags is<br>
preferably used to set a skip enable function for<br>
characters which do not cause a change of state at a<br>
state other than state 0 such as a string of the<br>
same or related characters of arbitrary length which<br>
may occur in a string of interest, as alluded to<br>
above. In such a case, the next state table entry<br>
can be reused without fetching it from SRAM/SDRAM.<br>
The input buffer address 112 is incremented without<br>
additional processing; allowing substantial addition<br>
acceleration of parsing for certain strings of<br>
characters. The second thirty-two bit word is an<br>
address offset fed back to register 180 and adder<br>
150 to be concatenated with the index output from<br>
the character palette to form a pointer into the<br>
state table for the next character. The initial<br>
address corresponding to state 0 is supplied by<br>
register 182.<br>
Thus, it is seen that the use of a character<br>
palette, a state memory in an abbreviated form and a<br>
next state memory articulate the function of the<br>
conventional state memory operations into separate<br>
stages; each of which can be performed extremely<br>
rapidly with relatively little high speed memory<br>
which can thus be duplicated to form parallel<br>
pipelines operating on respective characters of a<br>
document in turn and in parallel with other<br>
operations and storage of tokens. Therefore, the<br>
parsing process can be greatly accelerated relative<br>
to even a dedicated processor which must perform all<br>
of these functions in sequence before processing of<br><br>
another character can be started.<br>
In summary, the accelerator has access to the<br>
program memory of the host CPU where the character<br>
data (sometimes referred to as packet data connoting<br>
transmission of a network) and state table are<br>
located. The accelerator 100 is under control of<br>
the main CPU via memory-mapped registers. The<br>
accelerator can interrupt the main CPU to indicate<br>
exceptions, alarms and terminations, which, in the<br>
context of intrusion detection may be referred to<br>
generically as a pattern matching alert, an<br>
intrusion event alert or the like. When parsing is<br>
to be started, pointers (112, 114) are set to the<br>
beginning and end of the input buffer 13 0 data to be<br>
analyzed, the state table to be used (as indicated<br>
by base address 182 and other control information<br>
(e.g. 142) is set up within the accelerator.<br>
To initiate operation of the accelerator, the<br>
CPU issues a command to the accelerator which, in<br>
response, fetches a first thirty-two bit word of<br>
data from the CPU program memory (e.g. 120 or a<br>
cache) and places it into the input buffer 130 from<br>
which the first byte/ASCII character is selected.<br>
The accelerator fetches the state information<br>
corresponding to the input character (i.e. Figure 4A<br>
corresponds to a single character or a single column<br>
of the full state table of Figure 1) and the current<br>
state. The state information includes the next<br>
state address and any special actions to be<br>
performed such as interrupting the CPU or<br>
terminating the processing.<br>
The accelerator next selects the next byte to<br>
be analyzed from input buffer 130 and repeats the<br>
process with the new state information which will<br><br>
already be available to adder 150. The operation or<br>
token information storage can be performed<br>
concurrently. This continues until all four<br>
characters of the input word have been analyzed.<br>
Then (or concurrently with the analysis of the<br>
fourth character by prefetching) buffers 112, 114<br>
are compared to determine if the end of the document<br>
buffer 120 is reached and, if so, an interrupt is<br>
sent back to the CPU. If not, a new word is<br>
fetched, the buffer 112 is updated and the<br>
processing is repeated.<br>
Since the pointers and counters are implemented<br>
in dedicated hardware they can be updated in<br>
parallel rather than serially as would be required<br>
if implemented in software. This reduces the time<br>
to analyze a byte of data to the time required to<br>
fetch the character from a local input buffer,<br>
generate the state table address from high speed<br>
local character palette memory, fetch the<br>
corresponding state table entry from memory and to<br>
fetch the next state information, again from local<br>
high speed memory. Some of these operations can be<br>
performed concurrently in separate parallel<br>
pipelines and other operations specified in the<br>
state table information (partially or entirely<br>
provided through the next state palette) may be<br>
carried out while analysis of further characters<br>
continues.<br>
Thus, it is clearly seen that the invention<br>
provides substantial acceleration of the parsing<br>
process through a small and economical amount of<br>
dedicated hardware. While the parser accelerator<br>
can interrupt the CPU, the processing operation is<br>
entirely removed therefrom after the initial command<br><br>
to the parser accelerator. However, since<br>
substantial time is required for processing of<br>
tokens even when performed concurrently with other<br>
parsing operations, the acceleration provided as<br>
described above is not optimal for detection of a<br>
possible intrusion or security breach, particularly<br>
in view of the fact that operations which are<br>
difficult or impossible to secure can be initiated<br>
by the issuance of commands in the course of the<br>
parsing process.<br>
Referring now to Figure 2B, an arrangement is<br>
shown for a hardware parsing accelerator which<br>
greatly enhances processing speed of parsing beyond<br>
that of the arrangement of Figure 2A as described<br>
above but for the limited purpose of detection of a<br>
signature of a possible intrusion or security breach<br>
but which is fully compatible therewith. By<br>
comparing Figure 2B with Figure 2A it will be<br>
recognized by those skilled in the art that the<br>
arrangement of Figure 2B is principally a sub-set of<br>
the arrangement of Figure 2A and provides the same<br>
advantage of being able to search for all strings<br>
which may be a signature of an intrusion (e.g. a<br>
match to one or more expressions or portions thereof<br>
whereby a pattern matching alert can be issued to<br>
the CPU prior to matching a complete expression<br>
encoded in the state table; thus increasing response<br>
speed) simultaneously but provides further<br>
acceleration through omission of token processing<br>
since only the issuance of an interrupt or exception<br>
to protect the system need be issued as a result of<br>
the processing. The processing as described above<br>
for full parsing of the document can be performed<br>
after the document is screened for the inclusion of<br><br>
a possible security breach signature is completed.<br>
Since token processing is omitted during this<br>
screening process, memory accesses are much reduced<br>
in number. That is, for the intrusion detection<br>
accelerator in accordance with the invention (and in<br>
comparison with the hardware parser accelerator<br>
described above), the token processing, and the use<br>
of a character palette are omitted, resulting in<br>
lower memory resource requirements and some<br>
reduction in processing time. However, since much<br>
of this processing is done in parallel, the increase<br>
of processing speed is generally about 25% or<br>
somewhat less; depending, in part, on the particular<br>
devices used for the various resources in terms of<br>
memory speed, logic speed and the like. perhaps<br>
more importantly than speed, however, is the fact<br>
that any signature of a possible security breach<br>
will be detected and a remedial interrupt or<br>
exception issued before a corresponding command can<br>
be executed by the CPU as part of the attack.<br>
All functional elements of the arrangement of<br>
Figure 2B are present in Figure 2A and the same<br>
reference numerals are used for corresponding<br>
elements. Therefore it is evident that the<br>
intrusion detection parser accelerator 200 in<br>
accordance with the invention is entirely compatible<br>
with the parser accelerator described above and the<br>
change of the arrangement can be largely<br>
accomplished through programming such that the<br>
intrusion detection processing is essentially a<br>
special mode of operation of the parser accelerator<br>
of Figure 2A.<br>
Specifically, the input buffer 12 0 and the<br>
input word buffer 130, together with the address<br><br>
registers 112, 114, adder 150 and state table base<br>
address register 182 are identical to the<br>
corresponding elements described above and function<br>
in an identical manner to access state table 160.<br>
The difference resides principally in the omission<br>
of the character palette and the next state pallette<br>
memories and the data in the state table and<br>
internal format thereof. The state table is<br>
essentially of the same width, 256 characters as in<br>
the embodiment of Figure 2A. It should be<br>
understood that the signatures for which the search<br>
is conducted may be more complex than a simple<br>
character string of an arbitrary number of<br>
characters. The signatures are more generally<br>
described as regular expressions" which may be more<br>
complex than character strings, as discussed in wSo<br>
What's a $#!%% Regular Expression Anyway?!" by<br>
Vikram Vaswani et al. (Developer Shed), Copyright<br>
Melonfire 2000 - 2002, which is hereby fully<br>
incorporated by reference. The state table<br>
corresponding to a regular expression can thus be<br>
much larger than for a simple character string.<br>
Additionally, multiple regular expressions can be<br>
searched for concurrently using the same state table<br>
which could lead to very large state tables.<br>
However, in practice, sixty-four states are<br>
generally sufficient. If not, however, expansion of<br>
the state table entry to beyond eight bits would be<br>
necessary. Therefore, the extreme compression<br>
provided as described above is not generally<br>
necessary and the hardware of the state table 160 as<br>
described above can provide a substantial portion is<br>
not the entirety of the state table required for<br>
detection of attack signatures in order to reduce<br><br>
the number of memory accesses required.<br>
As in the embodiment of Figure 2A, the format<br>
of the data in the state table preferably includes n<br>
= 256 entries to accommodate the number of<br>
characters which can be expressed by a byte. In the<br>
case of the embodiment of Figure 2B, however, access<br>
into the state table is performed directly from the<br>
character bits buffered in word buffer 130. The<br>
contents of respective entries in the state table<br>
need only comprise a next state or row of the state<br>
table to be loaded, which defines character strings<br>
of interest and allows character strings to be<br>
followed, and/or a flag or other code for the<br>
interrupt or exception that is to be issued for the<br>
character of a string which supports recognition of<br>
the string as a signature (which is not necessarily<br>
the last character of a string which may constitute<br>
such a signature), as illustrated in Figure 5B. The<br>
next state can usually be expressed in less that<br>
eight bits and the interrupt of exception to be<br>
produced upon detection of a string of interest may<br>
be expressed as a single bit.<br>
Thus, the characters are tested in sequence and<br>
no updating of any registers other than registers<br>
112, 114 is required until a character is<br>
encountered which is the first character of a string<br>
of interest. That is, until such a detection, even<br>
the state is unchanged and the next state is not<br>
updated in register 180. Therefore, the document<br>
can be screened for initial characters with extreme<br>
speed. When an initial character of a string of<br>
interest is encountered the next state data is read<br>
from the state table, register 180 is updated, new<br>
state table data is loaded into the state memory if<br><br>
not already present and the next character is<br>
processed in the same manner. The state table<br>
memory is much smaller than for the XMLTM parser<br>
described above. This allows for the state table<br>
memory to be implemented on board the chip with<br>
other logic and elements of Figure 2A or 2B;<br>
decreasing the processing cycle time to possibly as<br>
little as 25% of the time required for a design<br>
using external memory. However, if the accelerator<br>
is designed as simply a special mode of operation of<br>
the XMLTM parser, the state table would be<br>
implemented in external memory and such a speed-up<br>
would not be provided. Therefore, it may be cost-<br>
effective in such a case to provide both on board<br>
and external memories to be used alternatively<br>
depending on state table size. Thus, only a<br>
relatively few clock cycles are required for each<br>
character to screen a document for attack<br>
signatures. When a sufficient number of characters<br>
have been processed to identify a string of<br>
interest, the data read from the state table will<br>
include an interrupt or an exception that is issued<br>
to the host CPU as a command for protection of the<br>
system.<br>
While the architecture of the system including<br>
the invention as embodied as shown in either Figure<br>
2A. or 2B is not critical to the practice of the<br>
invention, the architecture shown in Figure 2C is<br>
preferred in connection with the intusion detection<br>
accelerator of Figure 2B. Specifically, the host<br>
CPU 230 and its main memory 210 are connected by a<br>
bus 220 through which the hardware parser<br>
accelerator of the invention communicates with the<br>
main memory 210 and the host CPU 230. While the CPU<br><br>
23 0 could monitor communications between main memory<br>
210 and accelerator 100/200 the tokens have not yet<br>
been defined or established and execution of code<br>
for performing an attack is not possible.<br>
Therefore, the invention provides for issuance of a<br>
remedial interrupt or exception before performance<br>
of any operations which may be included in an<br>
attack.<br>
In view of the foregoing, it is seen that the<br>
invention provides for extremely rapid screening of<br>
a document for signatures which may indicate the<br>
possibility of an attempted attack within the<br>
context and environment of a hardware parser<br>
accelerator which significantly reduces time for<br>
parsing of a document such as an XML™ document to a<br>
fraction of the time which has been required prior<br>
to the present invention. The intrusion detection<br>
parser of the present invention requires no<br>
additional elements or hardware beyond that of the<br>
parser accelerator in accordance with the invention<br>
and can issue interrupts and/or exceptions prior to<br>
any intrusion process becoming executable.<br>
While the invention has been described in terms<br>
of a single preferred embodiment, those skilled in<br>
the art will recognize that the invention can be<br>
practiced with modification within the spirit and<br>
scope of the appended claims.<br><br>
WE CLAIM :<br>
1.	An intrusion detection system comprising:<br>
a character buffer to store a plurality of bytes of a document;<br>
a state table addressable in accordance with a byte of the document and<br>
a state to access at least one of an interrupt, an exception, or a command to<br>
store a token and next state data from said state table, wherein the command to<br>
store the token is accessed when a state in the state table is reached that<br>
indicates a valid token has been parsed;<br>
a register to store said next state data;<br>
means for combining contents of said register with a subsequent byte of<br>
the document to form a further address into said state table;<br>
a token buffer to store a plurality of tokens, wherein said plurality of tokens<br>
are available for further processing by a host processor; and<br>
a bus to communicate said interrupt or said exception to said host<br>
processor,<br>
wherein the state table, means for combining, and the token buffer are each<br>
operable simultaneously in parallel.<br>
2.	The intrusion detection system as claimed in claim 1, wherein said<br>
intrusion detection system is implemented within a parser.<br>
3.	The intrusion detection system as claimed in claim 1, wherein said state<br>
table is implemented in memory on the same chip as at least one of said<br>
register and said means for combining.<br>
4.	The intrusion detection system as claimed in claim 2, wherein said state<br>
table is implemented in an external memory.<br><br>
5.	The intrusion detection system as claimed in claim 4, comprising a<br>
memory on the same chip as at least one of said register and said means for<br>
combining for storing said state table when said state table does not require<br>
implementation in said external memory.<br>
6.	The intrusion detection system as claimed in claim 1, wherein said state<br>
table is accessed at a rate greater than a network packet transmission rate.<br>
7.	The intrusion detection system as claimed in claim 1, comprising means<br>
for presenting a pattern matching alert to be presented to said host processor in<br>
response to detection of an occurrence of an input sequence which matches a<br>
signature of one or more sequences encoded in said state table, to increase<br>
response speed.<br>
8.	The intrusion detection system as claimed in claim 7, wherein an intrusion<br>
alert corresponding to said interrupt or said exception is communicated to said<br>
host processor to initiate an intrusion prevention action to prevent or limit an<br>
intrusion attempt.<br>
9.	The intrusion detection system as claimed in claim 1, wherein said state<br>
table is accessed at a rate substantially equal to a network data packet<br>
transmission rate.<br>
10.	An intrusion detection method comprising:<br>
accessing a state table addressable in accordance with a byte of a<br>
document and a current state;<br>
retrieving at least one of an interrupt or an exception from said state table,<br>
if said interrupt or said exception is available;<br><br>
retrieving a token-storing command from said state table in response to<br>
determining that no interrupt or exception is available and that a valid token has<br>
been parsed;<br>
storing a token in a token buffer in response to said token-storing<br>
command;<br>
retrieving next state data from said state table;<br>
storing said next state data; and<br>
combining said stored next state data with a subsequent byte of said<br>
document to form a further address into said state table.<br>
11.	The intrusion detection method as claimed in claim 10, wherein said<br>
intrusion detection method is implemented within a parser.<br>
12.	The intrusion detection method as claimed in claim 11, wherein said state<br>
table is implemented in an external memory.<br>
13.	The intrusion detection method as claimed in claim 10, wherein said state<br>
table is accessed at a rate greater than a network packet transmission rate.<br>
14.	The intrusion detection method as claimed in claim 10, comprising:<br>
presenting a pattern matching alert to be presented to said host processor<br>
in response to detection of an occurrence of an input sequence, which matches<br>
a signature of one or more sequences encoded in said state table, to increase<br>
response speed.<br>
15.	The intrusion detection method as claimed in claim 14, wherein an<br>
intrusion alert corresponding to said interrupt or said exception is communicated<br>
to said host processor to initiate an intrusion prevention action to prevent or limit<br>
an intrusion attempt.<br><br>
16.	The intrusion detection method as claimed in claim 10, wherein said state<br>
table is accessed at a rate substantially equal to a network data packet<br>
transmission rate.<br>
17.	An intrusion detection system comprising:<br>
means for accessing a state table addressable in accordance with a first<br>
portion of a document and a current state;<br>
means for retrieving at least one of an interrupt or an exception from said<br>
state table, if said interrupt or said exception is available;<br>
means for retrieving a command from said state table, if said command is<br>
available, and storing a token in response to a command to store a token;<br>
means for retrieving next state data from said state table;<br>
means for storing said next state data;<br>
means for combining said stored next state data with a second portion of<br>
said document to form a further address into said state table;<br>
means for simultaneously performing the functions of accessing said state<br>
table, storing said token, and combining said stored next state data with said<br>
second portion of said document in parallel; and<br>
means for communicating said interrupt or said exception to a host<br>
processor.<br>
18. The intrusion detection system as claimed in claim 17, wherein said<br>
intrusion detection system is implemented within a parser.<br>
19. The intrusion detection system as claimed in claim 17, comprising means<br>
for presenting a pattern matching alert to be presented to said host processor in<br>
response to detection of an occurrence of an input sequence which matches a<br>
signature of one or more sequences encoded in said state table to increase<br>
response speed.<br><br>
20 The intrusion detection system as claimed in claim 17, wherein an<br>
intrusion alert corresponding to said interrupt or exception is communicated to<br>
said host processor to initiate an intrusion prevention action to prevent or limit an<br>
intrusion attempt.<br>
21. The intrusion detection system as claimed in claim 17, wherein said first<br>
portion and said second portion represent a character.<br><br>
As shown in FIG. 2B, signatures of character strings in a document which<br>
may indicate a possible intrusion into or attack on a networked computer system<br>
or node thereof or other security breach are detected at high speed using a<br>
hardware accelerator (100) within the environment of a hardware parser<br>
accelerator. An interrupt or exception can thus be issued to a host CPU (230)<br>
before a command which may constitute such a security breach, intrusion or<br>
attack can be made executable by parsing of a document. The CPU (230) can<br>
initiate network control measures to prevent or limit the intrusion.</endcommand></data></command></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LUtPTE5QLTIwMDUtQU1FTkRFRCBQQUdFUy5wZGY=" target="_blank" style="word-wrap:break-word;">817-KOLNP-2005-AMENDED PAGES.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LUtPTE5QLTIwMDUtQ09SUkVTUE9OREVOQ0UtMS4xLnBkZg==" target="_blank" style="word-wrap:break-word;">817-KOLNP-2005-CORRESPONDENCE-1.1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1hc3NpZ25tZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1jb3JyZXNwb25kZW5jZS5wZGY=" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1leGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1mb3JtIDEucGRm" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1mb3JtIDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-form 13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1mb3JtIDE4LnBkZg==" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1mb3JtIDMucGRm" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1mb3JtIDUucGRm" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1ncGEucGRm" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1yZXBseSB0byBleGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LWtvbG5wLTIwMDUtZ3JhbnRlZC1zcGVjaWZpY2F0aW9uLnBkZg==" target="_blank" style="word-wrap:break-word;">817-kolnp-2005-granted-specification.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LUtPTE5QLTIwMDUtTEVUVEVSIFBBVEVOVC5wZGY=" target="_blank" style="word-wrap:break-word;">817-KOLNP-2005-LETTER PATENT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODE3LUtPTE5QLTIwMDUtUkVQTFkgVE8gRVhBTUlOQVRJT04gUkVQT1JULTEuMS5wZGY=" target="_blank" style="word-wrap:break-word;">817-KOLNP-2005-REPLY TO EXAMINATION REPORT-1.1.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="229511-process-for-preparing-aripirazole.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="229513-apparatus-for-determination-of-a-measure-of-a-glycation-end-product-or-disease-state-using-tissue-fluorescence.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>229512</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>817/KOLNP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>08/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>20-Feb-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>18-Feb-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>04-May-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>LOCKHEED MARTIN CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>6801 ROCKLEDGE DRIVE, BETHESDA, MD 20817</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>LETT ERIC C.</td>
											<td>2723, CAMELOT ROAD, ENDWELL, NY 13760</td>
										</tr>
										<tr>
											<td>2</td>
											<td>DAPP MICHAEL C.</td>
											<td>1130 IVON AVENUE, ENDWELL, NY 13760</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 1/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2003/031313</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2003-10-03</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/421,773</td>
									<td>2002-10-29</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/421,775</td>
									<td>2002-10-29</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>3</td>
									<td>60/421,774</td>
									<td>2002-10-29</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>4</td>
									<td>10/331,879</td>
									<td>2002-12-31</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/229512-intrusion-detection-accelerator by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:12:42 GMT -->
</html>
