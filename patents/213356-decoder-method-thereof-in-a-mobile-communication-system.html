<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/213356-decoder-method-thereof-in-a-mobile-communication-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:21:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 213356:&quot;DECODER &amp; METHOD THEREOF IN A MOBILE COMMUNICATION SYSTEM&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;DECODER &amp; METHOD THEREOF IN A MOBILE COMMUNICATION SYSTEM&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>There is provided a decoder and a decoding method for decoding data modulate with a recursive systematic convolutional code (RSC) in a mobile communication system. In the decoder, a branch metric calculating circuit (BMC) calculates branch metrics (BMs) associated with a plurality of input symbols. An add-compare-select circuit (ACS) receives the BMs and previous path metrics (PMs) and generates a plurality of path selectors and LLR (Log Likelihood Ratio) data including the plurality of path selectors and reliability information at a first time instant. A maximum likelihood (ML) state searcher has a plurality of cells in an array with rows and columns, connected to one another according to an encoder trellis, cells in each row having a process time, Ds, for outputting the same value of the cells in the last column as an $IL state value representing an ML path in response to the path selectors. A delay ays the LLR data received from the ACS by the time Ds. An LLR update circuit has a plurality of processing elements (PEs) in an array with rows and columns, connected according to the encoder trellis, PE s in each row having a process time, DL, for generating update LLR values from the PEs at a time instant (first time instant-approximately DS+DL ) in response to the delayed LLR data received from the delay. A selector selects one of the update LLR values based on the ML state value.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>COMPONENT DECODER AND METHOD THEREOF IN MOBILE COMMUNICATION SYSTEM<br>
BACKGROUND OF THE INVENTION<br>
1.	Field of the Invention<br>
The present invention relates generally to a decoder and a decoding method in a mobile communication system, and in particular, to a component decoder and a method thereof for decoding data modulated with a turbo code that uses recursive systematic convolutional codes (RSCs).<br>
2.	Description of the Related Art<br>
Channel codes are widely used for reliable data communication in mobile communication systems such as satellite systems, W-CDMA (Wideband-CDMA), and CDMA 2000. The channel codes include convolutional codes and turbo codes. In general a convolutional coded signal is decoded using a Viterbi algorithm based on maximum-likelihood (ML) decoding. The Viterbi algorithm accepts a soft value at its input and produces a hard decision value. In many cases, however, soft-output decoders are required in order to improve performance through concatenated decoding. In this context, many schemes have been suggested to achieve soft output or the reliability of decided symbols. There are two well-known soft-input/soft-output (SISO) decoding methods, namely, a MAP (Maximum A-posteriori Probability) decoding algorithm, and a SOVA (Soft-Output Viterbi Algorithm). The MAP algorithm is considered the best in terms of bit error rate (BER) since it produces a hard decision value in conjunction with an a-posteriori probability, but at the cost of implementation complexity. J. Hagenauer suggested in 1989 the SOVA scheme to which the Viterbi algorithm is generalized. The SOVA outputs a hard decision value and reliability information that is soft output associated with the hard decision value, as well. Hagenauer, however, did not provide the real configuration and operation of the SOVA scheme.<br>
As compared to conventional Viterbi algorithms, SOVA generates a hard decision value and reliability information about the hard decision. That is, the soft output provides the reliability of a decoded symbol as well as the polarity of the decoded<br>
symbol, -1 or +1, for subsequent decoding. To achieve such reliability information, SOVA calculates path metrics (PMs) for a survivor path (SP) and a competition path (CP) and produces the absolute value of the difference between the PM of the SP and the PM of the CP as the reliability information. The reliability information 6 is given by<br>
δ = a*|PMs-PMc|, a&gt;0         	(1)<br>
PMs are calculated in the same manner as in a general Viterbi algorithm.<br>
To describe SOVA in detail, a trellis is assumed in which there are S=2k-l (k is a<br>
constraint length) states and two branches enter each state.<br>
Given a sufficient delay W, all survivor paths merge into one path in the general<br>
Viterbi algorithm. W is also used as the size of a state cell window. In other words,<br>
with the state cell window size W set to be sufficient, all survivor paths merge<br>
into one path. This is called a maximum likelihood (ML) path. The Viterbi<br>
algorithm selects the minimum of m PMs calculated by Eq. (2) to choose a state<br>
SK on the path at a given time k.<br><br>
(Equation Removed) <br>
where Xjn(m) is an nth bit of an N-bit code symbol at a branch on an m* path at time j, yjn(m) is a received code symbol at the position of the code symbol Xjn(m) and ES/NO is a signal-to-noise ratio. The probability of selecting the m* path using Pm, that is, the probability of selecting path 1 or path 2 in Eq. (2) is given by<br>
Pr= {path = m} ≈e-pm form= 1, 2       	(3)<br>
If a path with a smaller PM is 1 in Eq. (3), the Viterbi algorithm selects path 1. Here, the probability of selecting a wrong path is calculated bywhere A = P2-P1 &gt; 0. Let information bits on path 1 and path 2 at time j be Uj(1)<br>
and Uj(2), respectively. Then the Viterbi algorithm generates h errors at all the positions (e0, e,, e2,..., en_,) with Uj(1) * Uj(2). If the two paths meet after length 5m (8m 
Pj←Pj(l-Psh) + (1-Pj)Psk	..... (5)<br>
on the assumption that path 1 has been selected.<br>
In Eq. (5), Pj(l-Psk) is the probability of selecting a right path and (l-Pj)Psk is the probability of selecting a wrong path. Eq. (5) represents probability update by adding the right path selecting probability to the wrong path selecting probability. Such an iterative update operation is implemented with a log likelihood ratio (LLR) expressed as<br>
(Equation Removed)<br>
where A is P2-P1 and a is a constant.<br>
In conclusion, in the case that estimated information bits are different on the<br>
survivor path (path 1) and the competition path (path 2), namely, Uj(1) * Uj(2) the<br>
SOVA update operation applies only when the LLR at time j is less than the<br>
previous LLR.<br>
FIG. 1 illustrates example LLR update on a trellis with four states. To be more<br>
specific, going from time tl to time t2, information bits are identical on the<br>
survivor path (path 1) and the competition path (path 2). The LLR update does not<br>
apply to this state transition. On the other hand, information bits for the two paths<br>
are different going from t2 to t3 and from t3 to t4, for which the LLR is updated.<br>
For t3 and t4, the LLR is compared with the previous LLR and updated if the LLR<br>
is less than the previous LLR.<br>
The above SOVA scheme can be implemented by a trace-back or chain-back<br>
SOVA (hereinafter referred to as TBSOVA). An ML path is traced back for the<br>
window size W at each decoding in TBSOVA. The resulting decoding delay<br>
brings about implementation problems in the case of high speed applications, for example, a mobile terminal.<br>
SUMMARY OF THE INVENTION<br>
It is, therefore, an object of the present invention to provide an apparatus and method for decoding turbo-coded data by RESOVA (Register Exchange SOVA) in a mobile communication system.<br>
It is another object of the present invention to provide a RESOVA decoding apparatus and method for decoding turbo-coded data and convolutional coded data in a mobile communication system.<br>
It is a further object of the present invention to provide a RESOVA decoding apparatus and method which reduce decoding delay and memory size requirements at a receiver for receiving turbo-coded or convolutional coded data in a mobile communication system.<br>
It is still another object of the present invention to provide a RESOVA decoding apparatus and method in a mobile communication system, in which an ML state search window (ML state cell window) outputs an ML state value at time (k-Ds) with respect to an arbitrary time k, and LLR update window outputs an LLR selected based on the ML state value at approximately time (k-Ds-DL) at a component decoder.<br>
It is yet another object of the present invention to provide a decoding apparatus and method in a mobile communication system, in which a component decoder having an ML state search window and an LLR update window receives a virtual code to increase the accuracy of the ML state search at the boundary of a frame and further performs the ML state search on the frame boundary by the size of the ML state search window. The above objects can be achieved by providing a decoder and a decoding method for decoding data received form a transmitter. The data is encoded with an RSC in a mobile communication system. In the decoder, a branch metric calculating circuit (BMC) calculates branch metric values (BMs) associated with a plurality of input symbols. An add-compare-select circuit (ACS) receives the BMs and previous path metric values (PMs) and generates an plurality of path selection bits and LLR (Log Likelihood Ratio) data including the plurality of path selection bits and reliability information at a first time instant. A maximum likelihood (ML)<br>
state searcher has a plurality of cells in an array with rows and columns, connected to one another according to an encoder trellis, cells in each row having a process time, Ds, for outputting the same value of the cells in the last column as an ML state value representing an ML path in response to the path selectors. A delay delays the LLR data received from the ACS by the time Ds. An LLR update circuit has a plurality of processing elements (PEs) in an array with rows and columns, connected according to the encoder trellis, PEs in each row having a process time, DL, for generating updated LLR values from the PEs at a time instant (first time instant - approximately Ds+DL) in response to the delayed LLR data received from the delay. A selector selects one of the updated LLR values based on the ML state value.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
The above and other objects, features and advantages of the present invention will<br>
become more apparent from the following detailed description when taken in<br>
conjunction with the accompanying drawings in which:<br>
FIG. 1 is a trellis diagram to be referred to for describing an LLR update method<br>
that is applied to the present invention;<br>
FIG. 2 is a block diagram of a RESOVA decoder according to an embodiment of<br>
the present invention;<br>
FIG. 3 illustrates a method of synchronizing an LLR cell to a state cell in the<br>
RESOVA decoder shown in FIG. 2;<br>
FIG. 4 is a trellis diagram illustrating a decoding process at a state cell window<br>
and at an LLR cell window in the RESOVA decoder shown in FIG. 2;<br>
FIG. 5 is a flowchart illustrating the whole operation of the RESOVA decoder<br>
shown in FIG. 2;<br>
FIG. 6 illustrates the structure of a BMC shown in FIG. 2;<br>
FIG. 7 is a block diagram of an ACS shown in FIG. 2;<br>
FIG. 8 is a block diagram of a component ACS shown in FIG. 7;<br>
FIG. 9 illustrates the structure of a PM memory (PMM) shown in FIG. 2 in the<br>
case where there are eight states in the trellis according to the present invention;<br>
FIG. 10A illustrates the structure of an ML state searcher shown in FIG. 2;<br>
FIG. 10B illustrates the structure of a memory cell shown in FIG. 10A;<br>
FIG. 11A illustrates an LLR updater shown in FIG. 2;<br>
FIG. 1 IB illustrates the structure of a processing element (PE) shown in FIG.<br>
11 A;<br>
FIG. 12 A illustrates the structure of a delay shown in FIG. 2;<br>
FIG. 12B illustrates the structure of a memory cell shown in FIG 12A;<br>
FIG. 13 is a trellis diagram illustrating a decoding process at an ML state search<br>
window and an LLR update window in the case where virtual symbols are<br>
received in a RESOVA decoder according to another embodiment of the present<br>
invention; and<br>
FIG. 14 is a block diagram of the RESOVA decoder with input of virtual code<br>
symbols according to the second embodiment of the present invention.<br>
DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS<br>
Preferred embodiments of the present invention will be described herein below with reference to the accompanying drawings. In the following description, well-known functions or constructions are not described in detail since they would obscure the invention in unnecessary detail.<br>
There will be given a detailed description of the configuration and operation of a decoder based on RESOVA that exhibits the best performance among decoding schemes suggested up to now.<br>
FIG. 2 is a block diagram of a RESOVA decoder according to an embodiment of the present invention. Referring to FIG. 2, a RESOVA decoder 100 operates under the control of a controller 117 and is activated by a clock signal received from a clock generator 118. The clock generator 118 generates the clock signal under the control of the controller 117 and provides it to the RESOVA decoder 100 according to the present invention. It is to be understood that the RESOVA decoder 100 will not be described in conjunction with the control operation of the controller 117 and the clock signal generated from the clock generator 118. We assume an 1/3 turbo encoder have 3 memory (ie, k=4) in this invention. Upon receipt of demodulated code symbols rO(k), rl(k), and r2(k), a branch metric calculator BMC 101 calculates branch metrics (BMs) for all possible paths between the states at the current time instant(k) and the states at the previous time instant. In real implementation, once the current state is known, the previous states are easily detected on a trellis. In the case of a convolutional code or a turbo code, two BMs are produced for each state to which previous states are<br><br>
transitioned. With eight states given, two branches enter each state at any time instant and 16 BMs are calculated for all the possible paths. The BMs are a set of correlation measurements, that is, the correlations of all possible codewords s cO, cl, and c2 stored in the BMC to the received code symbols rO, rl, and r2. The codewords that are already been stored in the BMC are all possible codewords generated from an encoder generator polynomial g(x) on the trellis. For example, for code rate R=l/3, one BM for each state can be expressed as Eq. (7) with respect to eight combinations of cO, cl, c2 e (0, 1}. While two BMs can be generated for each state, eight codewords can be generated by combining cO, cl, and c2. Consequently, eight BMCs 101 are virtually required. Eight BMs are provided to an ACS 103 concurrently.<br>
BM=(l-2xcO)xrO+(l-2xcl)xrl+(l-2xc2)x r2<br>
= £{(l-2xc,.)x/;.}   »= 0,1,2		(7)<br>
i-O<br>
where the upper line represents BM calculation with the use of the code symbols cO, cl, and c2 and the received code symbols rO, rl, and r2, and the lower line represents a generalized equation of the upper equation. The code symbols cO, cl, and c2 are those that the receiver knows and each has 0 or 1 values. The received code symbols rO, rl, and r2 are those that the receiver received from a transmitter. The received code symbols(r0, rl, r2) have a soft value. In the case of a turbo code, rO is eight bits and each of rl and r2 is six bits according to the present invention. The rO is 8 bits because extrinsic information generated during decoding is added to a systematic code symbol. At an initial decoding, the extrinsic information is 0 bit and hence the 6-bit systematic code is received as rO. FIG. 6 illustrates the BMC 101 that implements Eq. (7) for one state. Multipliers 121 multiply the received code symbols rO, rl, and r2 by the code symbols cO, cl, and c2 that the BMC stores, and output MO, Ml, and M2 to an adder 123. Thus the output of the adder 123 is also eight bits except that rO is six bits at an initial decoding.<br>
When the structure of the BMC 101 shown FIG. 6 is actually implemented in hardware, multiplications are omitted and MO, Ml and M2 are obtained by inverting input symbol bits depending on the codeword(cO, cl, c2). Table 1 shows a BMC operation in a 6-bit binary system. Referring to Table 1, if the codeword is<br>
0, there is no change in the input symbol bits during the BMC operation. If the codeword is 1, each input symbol bit is inverted and then 000001 is added.<br>
(Table 1)<br>
(Table Removed)The ACS 103 will be described in detail referring to FIGs. 7 and 8. FIG. 7 is a block diagram of the ACS 103 in the case of a trellis with eight states according to the embodiment of the present invention. In FIG. 7, the ACS 103 has eight component ACSs 125. This implies that addition, comparison, and selection are occurred simultaneously for the eight states. The ACS 103 receives the eight BMs (BMO to BM7), each BM being b bits, from the BMC 101 and the previous ACS-operated path metrics (FMs) PMO to PM7 from a path metric memory(PMM) 105. According to the state relationship on the trellis, the component ACSs(#0 to #7) receive two ones among the BMs (BMO to BM7) for each state respectively. The metric for the upper branch that comes down to the corresponding state is called BMy and the metric for the lower branch that comes down to the corresponding state is called BML. The component ACSs(#0 to #7) also receive PMU and PML corresponding to BMU and BML according to the connection state on the trellis respectively. Connection between each component<br>
ACS 125 and BMu and BML, PMy and PML is determined by the state relationship on the trellis, as stated above.<br>
To calculate PMs for all the possible states at the current time instant, one of two hypotheses (survivor path and competition path) set for each state is selected. A next path metric (NPM) is computed using the given BMu and BML and PMU and PML of the two states at the previous time instant that may transition to the specific state, by<br>
ADD<br>
NPMu: = PMu + BMu<br>
NPML: = PML + BML<br>
COMPARE AND SELECT<br>
IF (PMU 
FIG. 8 is a detailed block diagram of the component ACS 125. Referring to FIG. 8, the component ACS 125 has two adders 126 and 127, a comparator 129, a selector 121, and a reliability information calculator 122. The first adder 126 adds BMu and PMu and the second adder 127 adds BML and PML. The comparator 129 compares the outputs of the first and second adders 126 and 127 and outputs a path selection bit indicating up or down path to the reliability information calculator 122 and the selector 121. The reliability information calculator 122 calculates reliability information 5 from the outputs of the first and second alders 126 and 127. The reliability information calculator 122 outputs an LLR by adding the reliability information 8 to the path selection bit received from the comparator 129. The reliability information 8 is given by<br>
8 = a * |PMu - PMJ, a &gt; 0       ..... (9)<br>
where a is a constant, 1/2. According to the present invention, the reliability information 8 is calculated not with the survivor path and the competition path but with the upper and lower PMs, PMU and PML<br>
As described above, the reliability information calculator 122 outputs reliability data (LLR) including the path selection bit plus 8. The reliability data (LLR) is comprised of the 1 path selection bit at the MSB (Most Significant Bit) and (n-1)-bit 8 starting from the LSB (Least Significant Bit). The path selection bit<br>
representing a sign bit at the MSB of the LLR or an estimated information bit can be used only when an encoder uses the RSC. This is because in the case of a typical convolutional code, input information on two paths that reach one state has an equal value. For example, if the input information on one of the paths is 0, the input information on the other path is also 0. In contrast, in the case of the recursive iterative convolutional code, an information bit 0 leads to state transition to a specific state by one of two paths that enter the state and an information bit 1 leads to state transition to the state by the other path. Here, up/down(low) path selection should be defined. For example, the path selection bit 1 or 0 can be defined as upper bifurcation and lower bifurcation, or vice versa. The selector 121 receives the PMs from the first and second adders 126 and 127 and the path selection bit from the comparator 129, and selects one of the PMs as a state value. In conclusion, the ACS 103 outputs eight LLRs and eight state values for the next time instant<br>
The PMM 105 stores the PM values received from the ACS 103. FIG. 9 illustrates the structure of a PMM with eight states, each state expressed in 8 bits. The PMM 105 stores 8-bit PM values associated with the eight states, which are calculated at the current time instant, and provides the stored PM values as the previous PM values at the next time instant to the ACS 103. More specifically, each of component PMMs PMMO to PMM7 is an 8-bit register. The component PMM PMO stores the eight bits of the PM value PMO received from the ACS 103. In this manner, the component PMMs PM1 to PM7 store the 8-bit PM values PM1 to PM7 received from the ACS 103, respectively.<br>
An ML state searcher 107 has state values labeling the given states, receives series of path selection bits in parallel from the ACS 103, and searches for an ML state value among the state values by a register exchange method, FIG. 10A is a block diagram of the ML state searcher 107 according to the embodiment of the present invention. The configuration and operation of the ML state searcher based on the register exchange scheme is disclosed in Korea Application No. 1998-62713, it can be a reference of this invention. The ML state searcher 107 includes a plurality of cells in an array of rows and columns and a plurality of path selection lines. Each selection line is connected to a corresponding row cell, for receiving the path selection bit. The plurality of cells in the array are connected such that each cell receives two state values from<br>
previous cell according to the trellis predetermined by a encoder's generation polynomial except for the first column of cells. Cells in the first column receive two input values, upper input value and lower input value, as shown in FIG. l0a. A cell in each column stores one of the two input state values based on the received corresponding path selection bit and feeds the stored state value to two cells in corresponding rows in the next column at the next time instant according to the state relationship of the trellis. By sequential performing of the above procedure for a predetermined time, the state values in a particular column cells converge to the same value at a certain time point The converged value is an ML state value. At the end column of the ML searcher 107 output the converged value as ML state. The ML searcher 107 takes Ds clock time (for example, 4*k, where k = number of encoder memory +1) for search the ML state. For example, with eight states, the ML state searcher 107 receives 0 and 1 at the cell in the first row and the first column, 2 and 3 at the cell in the second row and the first column, 4 and 5 at the cell in the third row and the first column, and 6 and 7 at me cell in the fourth row and the first column. The inputs of the cells at the fifth to eighth rows and the first columnare the same as first to fourth row and the first column. Each cell in the first column selects one of the state values based on a path selection bit received according to a clock signal from a corresponding selection line and feeds the selected state value to cells in the next column according to the state relationship of the trellis. Iterative performing of the procedure for a predetermined time (Ds), the state values of the last column cells output the same converged value, one of the state values 0 to 7. For example, if a converged value is 5, the cells in the last column have the same state value, 5. Here, 5 is determined as an ML state value. The ML state searcher 107 has a time delay Ds to receive initial state values in the first column, converge them to one state value, and output the converged value from the rightmost column. FIG. 10B illustrates the structure of a cell in the ML state searcher 107. The cell has a selector and a register memory. The selector has two input ports for receiving state values from previous cells or initial inputs and one select port for receiving a path selection bit. That is, the cell selects one of the two input state values based on the path selection bit and stores the selected state value in the register memory. The memory outputs the state value by an input clock.<br>
Referring back to FIG. 2, a delay 109 receives the n-bits LLRs, path<br><br>
1-bit selection bit and a n-1 bits reliability information 5 for each state from the ACS 103 and delays the inputs by the delay involved in the ML state searcher 107, Ds. FIG. 12A illustrates the structure of the delay 109 having memory cells which form eight rows, the same number of states. The delay 109 delays the received LLR with time delay Ds for outputting the received LLR. FIG. 12B illustrates the structure of a component memory cell acting as a buffer. The memory cells receive LLR and store for a predetermined time delay and output the LLR to the next memory cell by a clock signal. An LLR updater 111 receives Ds-delayed LLRs from the delay 109, compares the LLRs with the previous LLRs, and updates LLRs if they are less than their previous LLRs.<br>
FIG. 11A illustrates the structure of the LLR updater 111 having processing elements (PEs), which form predetermined columns and rows being the same number of states , and having plurality of initial input values, O.d_max or l.d_max. The d_max is determined by a maximum quantization level(for example 127, Tbit). Therefore, the initial input values are expressed by 8 bit, which the MSB is 0 or 1 and the other bits are all 1). The LLR updater 111 takes DL clock period(for example, 16*k, where k = number of encoder memory (3)+l=:4'). Referring to FIG.,11 A, the LLR updater 111, being a modification of RESOVA cells, has PEs in an array with rows and columns and a plurality of selection lines. The selection lines receive path selection bits and 8 and are connected in parallel to PEs in corresponding rows. The LLR updater 111 updates not a one-bit hard decision value but an (n)-bit soft value, LLR. Therefore, an inner data communication line within the LLR updater 111 is (n) bits. Here, n-1 bits represent 8 and the other one bit represents a path selection bit. Also, each PE includes logic for updating the previous LLR. The LLR updater 111 receives Ds (or Ds-1) clock delayed LLR values from the delay 109 upon generation of every clock-signal from the clock generator 118. These LLRs have already been computed through the ACS operation for the eight states before Ds or (Ds-1) clock elapsed. Each PE has two input ports except for the selection line. Each PE in the first column receives information bit 0 through upper (or lower) input port and information bit 1 , through the other lower (or upper) input port as shown in FIG. 1 la. Each of PEs in the other columns is connected to two PEs in the previous column according to the trellis structure, for receiving the values of the previous PEs. The configuration and operation of the PE will be described in detail referring to<br>
  FIG. 1 IB. It is first to be noted that an LLR is defined as an n-1 bits 8 and a one-bit path selector. Referring to FIG. 11B, one PE receives two (n)-bit LLRs through upper input port and lower input port from the previous PEs . The exception is that each PE in the first column receives (n) the initial input value. A first multiplexer 141 receives two path selection bits (first and second selection bit, respectively) of the two LLRs from PEs in the previous column connected to the PE according to the trellis and selects one of the path selection bits based on a path selection bit (referred to as a third path selection bit) received from the corresponding select line. A second multiplexer 143 receives two n-1 -bits 8 values of the two LLRs through its two input ports and selects one of the 8 values based on the third path selection bit A comparator 147 compares the n-1 bist 8 values received from the second multiplexer 143 with a 8 value of an LLR currently received through the corresponding selection line. Let the 8 value received from the second multiplexer 143 be "a" and the 8 value currently received at the PE through the selection line be "b". If a is greater than b, the comparator 147 outputs a high signal 1 (or low signal) and if b is greater than a, it outputs a low signal 0 (or high signal). An XOR gate 145 performs exclusive oring the two path selection bits received from the previous PEs. The outputs of the comparator 147 and the XOR gate 145 each are one bit. An AND gate 149 performs AND-gating the outputs of the adder 145 and the comparator 147. A third multiplexer 151 receives the n-1 bits 8 value from the second multiplexer 143 and the n-1 bits 8 value from the selection line and selects one of the 8 values based on the output of the AND gate 149 as a select signal. The memory 146 and 148  store  output of the first multiplexer  141   and third multiplexer   151 respectively. The path selection bit output from the memory 148 and the 8 value output from the memory 146 form an updated (n)-bit LLR. Referring back to FIG. 2, a LLR selector 113 receives eight updated LLRs from the LLR updater 111 and selects one of the LLRs based on the ML state value received from the ML state searcher 107. For example, the LLR selector 113 receives converged value 5 from the state searcher 107, outputs the 5th updated LLR. An output buffer 115 buffers sequentially LLRs selected by the selector 113. In the present invention, two sliding windows sre used to efficiently use a memory and reduce decoding time delay. One of them is an ML state search window Ds operated by the ML state searcher 107 to search for an ML state value and the other is an LLR update window DL operated by the LLR updater 111 to<br>
output an optimum LLR. The ML state search window searches for the ML state<br>
value after a time delay, approximately Ds and the LLR update window selects an<br>
updated LLR corresponding to the ML state value among a plurality of updated<br>
LLRs and outputs the selected LLR after a time delay, approximately Ds+DL.<br>
FIG. 3 illustrates the operation relationship between the ML state search window<br>
and the LLR update window in time, and FIG. 4 illustrates time points when an<br>
ML state value and an LLR value are output in the operations of the ML state<br>
search window and the LLR update window. Let the ACS operation occur at time<br>
K. Then, the ML state value is output after a (K-Ds+1) time delay, as shown in<br>
FIG. 3. An optimum LLR is selected at the time point when the ML state value is<br>
output and updated and output after a time delay of (DL+1) from time (K-Ds+1).<br>
Since the updated LLR is output after a time delay (DL+Ds-2) from time K, a<br>
final LLR is output after a time delay (K-DL-Ds+2) from time KL	FIG.    5<br>
is a flowchart illustrating the operation of the RESOVA decoder according to the present invention. Referring to FIG. 5, in the absence of a clock signal from the system, the delay 109, the PMM 105, the ML state searcher 107, and the LLR updater 111 initialize their cells or PEs by resetting them in step 501. Upon receipt of the clock signal, the BMC 101 receives input data from an input buffer (not shown) in step 503. In step 505, the BMC 101 calculates BMs for the paths between the states at the previous time instant and the states at the current time instant using the input data and codewords that the decoder knows and feeds the BMs to the ACS 103. The ACS 103 obtains the up (upper input port) and down (lower input port) PMs associated with each state from the BMs and calculates reliability information by Eq. (9) and LLRs in step 510.<br>
To describe step 510 more specifically, the ACS 103 calculates LLRs and path selection bits in step 506, calculates PMs using the BMs in step 507, normalizes the PMs in step 508. The PM normalization is the process of subtracting a predetermined value from a PM if the PM is greater than a predetermined value to prevent overflow of PM values. For details, see Korea Application No. 1998-062724. The ACS 103 feeds the LLRs to the delay 109 in step 511 and the path selection bits to the ML state searcher 107 in step 513. The path selection bits are information estimated by hard decision for the respective states. The delay 109 delays the LLRs by Ds (Delay for search ML state) and feeds the delayed LLRs to the LLR updater 111 and the ML state searcher 107 searches for an ML state value based on the path selection bits. In step 515, the LLR updater 111 receives<br>
the delayed LLRs and updates LLRs as similar method shown in the trellis of FIG.<br>
1. The LLR selector 113 receives the updated LLRs, selects one of the LLRs<br>
based on the ML state value received from the ML state searcher 107, and buffers<br>
the selected LLR in the output buffer 115 in step 517.<br>
The controller 117 increases the number of CLK by 1 in step 519 and determines<br>
whether the CLK is greater than frame length in step 521. If the CLK is greater<br>
than the frame length, the controller 117 ends the decoding operation and if it is<br>
less than the frame length, the controller 117 iteratively perform steps 503 through<br>
519.<br>
In the above embodiment of the present invention, when the ML state search<br>
window reaches a frame boundary, a frame-based operation is over by zero-<br>
termination. In this case, only an ML state at the output side of the ML state<br>
search window is output, not the other ML states within me ML state search<br>
window.<br>
Therefore, a RESOVA decoder according to another embodiment of the present<br>
invention is so configured that all ML states within the ML state search window<br>
can be output.<br>
FIG. 13 illustrates decoding in the ML state search window and the LLR update<br>
window in the RESOVA decoder with virtual symbol inputs and FIG. 14 is a<br>
block diagram of the RESOVA decoder for decoding in the case of virtual code<br>
inputs according to the second embodiment of the present invention.<br>
Referring to FIG. 13, when the ML state search window reaches a frame boundary,<br>
virtual zero symbols are inserted for the time period Ds starting from the time<br>
instant following the time instant when the ML state search window reaches the<br>
frame boundary. Thus, the output side of the ML state search window and the<br>
LLR update window reach the frame boundary.<br>
The operation of FIG. 13 is implemented in the RESOVA decoder shown in FIG.<br>
14 and the same components as shown in FIG. 2 will not be described.<br>
In FIG. 14, the controller 117 detects a frame boundary and outputs a frame<br>
boundary signal indicating whether the frame boundary is reached or not.'A<br>
selector 1401 receives an input code symbol and a virtual zero symbol and selects<br>
one of them based on the frame boundary signal received from the controller 117.<br>
Specifically, the selector 1401 selects the input code symbol at a location other<br>
than the frame boundary and the virtual zero symbol at the frame boundary for Ds<br>
clock time.  A  demultiplexer (DEMUX)   1403   demultiplexes  a  sequence  of<br>
symbols received from the selector 1401 to r0, rl, and r2 and feeds them to the BMC 100 for the frame boundary. Virtual zero symbols are provided to the decoder 100 for the time period Ds to make the output side of the ML state search window reach up to the frame boundary after the frame boundary. With the use of the ML state search window and the LLR update window based on the RESOVA, the RESOVA decoder according to the present invention reduces decoding delay by searching for an ML state without time delay as compared to a TBSOVA and decreases memory size by obviating the need for a memory in searching for the ML state. Moreover, an ML state search operation is further performed by the size of the ML state search window at a frame boundary, without zero termination at the frame boundary. Therefore, more accurate decoding can be achieved.<br>
While the invention has been shown and described with reference to certain preferred embodiments thereof, it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined by the appended claims.<br><br><br><br><br><br>
WHAT IS CLAIMED IS:<br>
1.	A decoder comprising:<br>
a branch metric calculating circuit (BMC) for calculating 2k branch metrics (BMs)<br>
upon response to k input values at a time, where k is the same number of a<br>
encoder memory;<br>
an add-compare-select circuit (ACS) for receiving the BMs and previous path<br>
metrics (PMs) and generating 2k LLRs (Log Likelihood Ratio), each LLR<br>
including corresponding path selection bit and reliability information;<br>
a maximum likelihood (ML) state searcher for sequentially receiving series of<br>
path selection bits from the ACS, searching a ML state according to the path<br>
selection bits with a predetermined initial values for Ds clock period, and<br>
outputting one of the initial value as the ML state;<br>
a delay for receiving the LLRs from the ACS at a clock period, delaying the LLRs<br>
for the Ds clock period;<br>
a LLR updater for receiving the LLRs from the delay period and updating the<br>
LLRs by using sequentially being received corresponding path selection bits and<br>
reliability information for DL clock period; and<br>
a selector for selecting one of the updated LLR values according to the ML state<br>
value.<br>
2.	The decoder of claim 1, wherein a current path metric is obtained by<br>
adding the branch metric and the previous path metric.<br>
3.	The decoder of claim 1, wherein the ACS comprises:<br>
a first adder for receiving a first BM and a first PM according to a trellis, which is<br>
determined by a encoder generation polynomial, adding the received first BM and<br>
PM, and outputting the first added value;<br>
a second adder for receiving a second BM and a second PM according to the<br>
trellis, adding the received second BM and PM, and outputting the second added<br>
value;<br>
a comparator for receiving the the first and second added values, comparing the<br>
received values, and generating the path selection bit based on the comparison;<br>
a reliability information calculator for receiving the first and second added values<br>
and the path selection bit and calculating the reliability information; and<br>
a selector for receiving the first and second added values and the path selection bit<br>
and selecting one of the added values as a next path metric (NPM).<br>
4.	The decoder of claim 3, wherein the reliability information (5) is obtained<br>
by based on subtracting the first added value from the second added value<br>
5.	The decoder of claim 4, wherein the reliability information (8) is<br>
calculated by<br>
8 = a * |PMu-PMJ .<br>
6.	The decoder of claim 5, wherein PMu is the first added value and PML is<br>
second added value.<br>
7.	A decoding method at a receiver in a mobile communication system,<br>
comprising the steps of:<br>
calculating a plurality of BMs by binary computation a plurality of input symbols<br>
with all possible codewords;<br>
generating next PMs, reliability information, and a path selection bit at a time<br>
instant K by performing an add-compare-select operation on the BMs and<br>
previous PMs;<br>
outputtmg an ML state after a time period Ds from the time instant K based on a<br>
path selection bits, which is generated by the add-compare-select operation for the<br>
Ds period;<br>
delaying a LLRs, each LLR including reliability information and a corresponding<br>
path selection bit by the time Ds from the time instant K;<br>
updating Ds-delayed LLRsusing plurality of reliability information and path<br>
selection bits for DL period; and<br>
selecting an updated LLR value based on the ML state among the updated LLRs.<br>
8.	The decoding method of claim 7, wherein the generating step comprises<br>
the steps of:<br>
calculating current PM by adding a previous PM and a BM received according to<br>
a trellis which is determined by encoder generation polynomial;<br>
generating the path selection bit using the PMs;<br>
calculating the reliability information using the PMs; and<br>
generating LLR values by adding the path selectors to the reliability information.<br>
9.	A decoding method at a receiver in a mobile communication system,<br>
comprising the steps of:<br>
calculating a plurality of BMs by using a plurality of input symbols with all<br>
possible codewords;<br>
generating next PMs, LLRs, each LLR including reliability information and a path<br>
selection bit at a time instant K by performing an add-compare-select operation on<br>
the BMs and previous PMs;<br>
receiving Ds number of path selection bits for a time period Ds from the time<br>
instant K and outputting an ML state value for the time instant Ds ; and<br>
updating the LLRsusing plurality of reliability information and path selection bits,<br>
which is generated for a time instant DL; and<br>
outputting an updated LLR selected based on the ML state value.<br>
10.	A turbo code decoder comprising:<br>
a BMC for calculating BMs by using a plurality of input symbols with all possible<br>
codewords;<br>
an ACS for receiving the BMs and previous PMs, which is generated at just<br>
previous ACS operation, and generating a plurality of path selection bits and<br>
plurality of reliability information at a first time instant;<br>
an ML state searcher for searching an ML state value representing an ML path<br>
using series of path selection bits, which is received from the ACS for a first time<br>
period;<br>
a LLR updater for updating a reliability information by using a series of path<br>
selection bits and plurality of reliability information for a second time period; and<br>
selector for selecting an updated reliability value by using the ML state value.<br>
11.	A turbo code decoding method comprising the steps of:<br>
calculating BMs by  using a plurality of input symbols with all  possible<br>
codewords;<br>
receiving the BMs and previous PMs, which is generated at just previous ACS<br>
operation;<br>
generating plurality of path selection bits and plurality of reliability information at a first time instant; searching an ML state value representing an ML path using series of path<br>
selection bits for a first time period;<br>
updating the reliability infonnation by using a series of path selection bits and<br>
plurality of reliability information for a second time period; and<br>
selector for selecting an updated reliability value by using the ML state value.<br><br>
12.	A  decoder substantially as  herein  described with reference to the<br>
foregoing description, table and the accompanying drawings.<br>
13.	A decoding method at a receiver in a mobile communication system<br>
substantially   as   herein   described  with  reference  to  the  foregoing<br>
description, table and the accompanying drawings.<br>
14.	A turbo code decoder substantially as herein described with reference to<br>
the foregoing description, table and the accompanying drawings.<br>
15.	A turbo code decoding method substantially as herein described with<br>
reference to the foregoing description, table and the accompanying<br>
drawings.<br><br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDQ2Ni1kZWwtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-0466-del-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDQ2Ni1kZWwtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0466-del-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDQ2Ni1kZWwtY29ycmVzcG9uZGVuY2Utb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0466-del-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDQ2Ni1kZWwtY29ycmVzcG9uZGVuY2UtcG8ucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-0466-del-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDQ2Ni1kZWwtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-0466-del-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDQ2Ni1ERUwtRHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-0466-DEL-Drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDQ2Ni1ERUwtRm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-0466-DEL-Form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDQ2Ni1kZWwtZm9ybS0xOS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-0466-del-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDQ2Ni1ERUwtRm9ybS0yLnBkZg==" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-0466-DEL-Form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDQ2Ni1kZWwtZm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0466-del-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDQ2Ni1kZWwtZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0466-del-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDQ2Ni1kZWwtZ3BhLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0466-del-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDQ2Ni1kZWwtcGN0LTIxMC5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-0466-del-pct-210.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDQ2Ni1kZWwtcGV0aXRpb24tMTM3LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0466-del-petition-137.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="213355-apparatus-and-method-for-transmitting-control-information-in-a-mobile-communication-system.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="213357-squaraine-based-dyes.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>213356</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2001/00466/DEL</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>02/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>11-Jan-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>27-Dec-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>01-Jun-2001</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SAMSUNG ELECTRONICS CO., LTD.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>416, MAETAN-DONG, PALDAL-GU, SUWON-SHI, 442-370 KYUNGKI-DO REPUBLIC OF KOREA.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>KIM, MIN-GOO</td>
											<td>973-3, YONGTONG-DONG, PALTAL-GU, SUWON-SHI, KYONGGI-DO 442-470 REPUBLIC OF KOREA.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>KIM, BEONG-JO</td>
											<td>MOOJIGAEMAEUL #201, KUMI-DONG, PUNTANG-GU, SONGNAM-SHI, KYONGGI-DO 463-500 REPUBLIC OF KOREA.</td>
										</tr>
										<tr>
											<td>3</td>
											<td>LEE, YOUNG-HWAN</td>
											<td>237-7, JONGJA-DONG, PUNTANG-GU, SONGNAM-SHI, KYUONGGI-DO 463-010 REPUBLIC OF KOREA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04B 15/02</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/KR00/01109</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-10-05</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>1999-42924</td>
									<td>1999-10-05</td>
								    <td>Republic of Korea</td>
								</tr>
								<tr>
									<td>2</td>
									<td>1999-43118</td>
									<td>1999-10-06</td>
								    <td>Republic of Korea</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/213356-decoder-method-thereof-in-a-mobile-communication-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:21:31 GMT -->
</html>
