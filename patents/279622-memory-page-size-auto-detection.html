<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/279622-memory-page-size-auto-detection by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:04:27 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 279622:“MEMORY PAGE SIZE AUTO DETECTION”</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">“MEMORY PAGE SIZE AUTO DETECTION”</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Methods and apparatuses are presented for memory page size auto detection. A method for automatically determining a page size of a memory device includes receiving page size extents of the memory device, determining a bus width of the memory device, detecting a number of pages having an automatic detection marker, and determining the page size of the memory device based upon the detected number of pages and the received page size extents. An apparatus for automatically determining page size detection includes logic for performing the above presented method.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT, 1970<br>
(39 of 1970)<br>
&amp;<br>
THE PATENTS RULES, 2003<br>
COMPLETE SPECIFICATION (See section 10, rule 13)<br>
“MEMORY PAGE SIZE AUTO DETECTION”<br>
QUALCOMM INCORPORATED, a Company<br>
incorporated in the State of Delaware, United States<br>
of America of 5775 Morehouse Drive, San Diego,<br>
California 92121-1714, United States of America<br>
The following specification particularly describes the invention and the manner in which it is to be performed.<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
MEMORY PAGE SIZE AUTO DETECTION<br>
Claim of Priority under 35 U.S.C. §119<br>
[0001]	The present Application for Patent claims priority to Provisional Application<br>
No. 60/917,901 entitled "Flash device page size auto-detection" filed May 14, 2007, and Provisional Application No. 60/976,543 entitled "Memory Page Size Auto Detection" filed October 1, 2007, both of which are assigned to the assignee hereof and are hereby expressly incorporated by reference herein.<br>
Field of Disclosure<br>
[0002]	The embodiments of the disclosure relate generally to the configuration of<br>
memory devices, and more specifically, to automatically determining the page size of a non-volatile memory device during an information processing device's boot sequence for enabling support of memory devices independent of density (e.g., memory capacity size).<br>
Background<br>
[0003]	When an Information Processing Device (IPD) is powered on, it may first<br>
undergo a boot sequence to initialize its various hardware and/or software components. The boot sequence may be performed by software having a multi-image boot architecture that can include many code images which may be separately compiled and maintained. The boot sequence may start out by first executing a primary boot code. In general, the primary boot code may be stored in an on-chip non-volatile memory and may be fixed at the time of the IPD's manufacturing. In some cases, the primary boot code can be stored in off-chip non-volatile memory.<br>
[0004]	After a power cycle (fully off-state to on-state or semi off-state to on-state), the<br>
IPD may start executing the primary boot code. As part of primary boot code execution, the IPD may download the secondary boot code or image which may be the next step in the boot-up process of the IPD. The secondary boot code may reside in an off-chip non-volatile memory, and may vary with product and also with product configuration. Different types of memory devices may be used to store secondary boot code, for example, NAND flash, oneNAND flash, m-system flash, NOR flash, EEPROM, ROM, etc.  To download the secondary boot code image, the IPD should know the details of<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
2<br>
the device in which secondary boot code resides (device type) and how to download it (protocol to access the device, how to access the device, how the data stored in the device, etc). As the secondary boot code download occurs during the primary boot code execution, the IPD should have the information (regarding the device in which secondary code is stored and how to download the secondary boot code) in the primary boot code itself. Alternatively, the IPD may be able to derive this information during the primary boot code execution.<br>
[0005]	Once the IPD finishes primary boot code execution, it may complete the<br>
detection of the device that has secondary code, the location of the secondary code in the device (e.g., the address), and how to access the secondary code. In some cases the IPD may download the secondary code form the device to an on-chip memory or off-chip memory, and in some other cases it may only identify the secondary code location and how to access it. After completing the primary boot code execution, the IPD starts executing the secondary code. During the secondary code image execution, the IPD may identify/learn more details of the hardware configuration of the system (what type of system, devices connected, features of the system, system memory size, width, location, protocol to access the system memory, etc.) and also some level SW configuration.<br>
(0006]	As described above, to download the secondary code, the IPD should determine<br>
the device type and its method of access. As there may be different types of devices which need to be accessed during the primary boot, the IPD may perform three general steps to realize access to a memory device: (i) device type detection; (ii) bus interface width detection; and (iii) page/sector size determining of the device (when the device is page/sector oriented). The IPD should complete these steps before it can access the secondary code in the device.<br>
[0007]	Accordingly for proper operation, an IPD may identify the page/sector size of a<br>
non-volatile flash memory device to which it may be connected. Assuming the IPD identified the device type in which a secondary boot code is stored, it can then detect the format in which data is stored. Certain types of flash devices store data in page format (e.g.: NAND, oneNAND, m-system, superAND, etc.). The page size of the device may vary with its density and type of the device. Page size of a given flash device can as low as, for example, 128 bytes and as high as 8 Kbyte, or higher.<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
3<br>
[0008]	With  increasing flash device densities, the page sizes are correspondingly<br>
increasing. Different techniques may be used to detect the page size and interface bus width of the device by the IPD. One conventional technique may encode the page size and/or bus width by having dedicated external pins to the IPD and the value driven to these pins can indicate the page size of the device and/or the bus width. This approach may be very simple; however, the number of dedicated pins required to support all different page sizes can become large.<br>
[0009]	Another possible solution may store page size and bus width information in the<br>
first page of the flash device, and hardware logic may read the first page from the flash device during the primary boot execution (either the IPD forces the hardware to perform this functionality, or the hardware logic automatically detects and reads the first page). The solution may have no protection against random errors that can occur during the first page read. Flash devices may be prone to random errors, and if the data in the first page gets corrupted either in the flash memory or while the IPD is reading the data from flash memory, there is a possibility the IPD can incorrectly detect the page size which may result in catastrophic failure. Error protection can not conventionally be added at this stage as the page and data format is not known to the IPD at the boot-up time.<br>
[0010]	To improve the protection against read failures, the page size and bus width may<br>
be encoded using unique numbers, known as a magic numbers, which provide protection against random errors. Page size and bus width may be encoded into a unique magic number and put in the first page of the device. The IPD may detect the page size based on the magic numbers stored in the first page and then accesses the secondary boot code based on the page size. This implies the secondary boot code/image must be compiled and maintained for each flash device (page and bus width sizes). As the number of different types of flash memory devices continues to grow, it may become costly to develop, manage, and maintain separate software builds which correspond to different flash devices.<br>
[0011]	Accordingly, there is a need for a new automatic page size detection approach<br>
which may support flash device configuration utilizing common software in order to reduce development and maintenance costs.<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
4<br>
SUMMARY<br>
[0012]	Exemplary   embodiments   of the   disclosure   are   directed  to   methods   and<br>
apparatuses for memory page size auto detection.<br>
[0013]	An  embodiment of the  invention can  include a method for automatically<br>
determining a page size of a memory device, comprising: receiving page size extents of the memory device; determining a bus width of the memory device; detecting a number of pages having an automatic detection marker; and determining the page size of the memory device based upon the detected number of pages with the automatic detection marker and the received page size extents.<br>
[0014]	Another embodiment can include an apparatus for automatically determining a<br>
page size of a memory device, comprising: logic configured to receive page size extents of the memory device; logic configured to determine a bus width of the memory device; logic configured to detect a number of pages having an automatic detection marker; and logic configured to determine the page size of the memory device based upon the detected number of pages with the automatic detection marker and the received page size extents.<br>
[0015]	Another embodiment can include an apparatus for automatically determining a<br>
page size of a memory device, comprising: means for receiving page size extents of the memory device; means for determining a bus width of the memory device; means for detecting a number of pages having an automatic detection marker; and means for determining the page size of the memory device based upon the detected number of pages with the automatic detection marker and the received page size extents<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0016]	The   accompanying  drawings  are   presented  to   aid   in  the   description  of<br>
embodiments  of the  disclosure   and   are  provided   solely   for   illustration   of the<br>
embodiments and not limitation thereof.<br>
[0017]	FIG. 1  is a block diagram of an Information Processing Device which may<br>
include a processor, a memory controller, and various different types of memory<br>
devices.<br>
[0018]	FIG. 2A is a diagram of an exemplary first page residing within a memory<br>
device which can be used to determine the bus width of the memory device.<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
5<br>
[0019]	Fig. 2B is a diagram showing how data in the exemplary first page is read from<br>
memory devices having an 8 bit bus width and a 16 bit bus width.<br>
[0020]	Fig. 3 is a diagram of an exemplary data structure which may be used to<br>
determine both the bus width and page size of a memory device.<br>
[0021]	Fig. 4 is a diagram showing how the exemplary data structure shown in Fig. 3<br>
which is contained within memory devices having different page sizes.<br>
[0022]	Fig. 5 is a flow chart depicting an exemplary process for detecting the page size<br>
of a flash device.<br>
[0023]	Fig. 6 is a diagram showing another exemplary process counting the number of<br>
automatic detection markers.<br>
[0024]	Fig. 7 is a flow chart depicting an exemplary process for determining parameters<br>
associated with a memory device.<br>
[0025]	Fig. 8 is a diagram depicting data structure organization in the a flash memory<br>
device<br>
DETAILED DESCRIPTION<br>
[0026]	Aspects of the invention are disclosed in the following description and related<br>
drawings directed to specific embodiments of the invention. Alternate embodiments may be devised without departing from the scope of the invention. Additionally, well-known elements of the invention will not be described in detail or will be omitted so as not to obscure the relevant details of the invention.<br>
[0027]	The word "exemplary" is used herein to mean "serving as an example, instance,<br>
or illustration." Any embodiment described herein as "exemplary" is not necessarily to be construed as preferred or advantageous over other embodiments. Likewise, the term "embodiments of the invention" does not require that all embodiments of the invention include the discussed feature, advantage or mode of operation. The term "magic numbers" is used herein to define numbers which are determined based upon a minimum weight algorithm, and are used in various embodiments so that memory read errors may not be correlative. The word "external memory" is used herein to mean a memory device which is not located within the confines of a processing unit, which in turn may mean that the memory device is not formed on the same die as the processing unit. The word "internal memory" is used herein to mean a memory device is formed on the same die as the processing unit<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
6<br>
[0028]	Further, many embodiments are described in terms of sequences of actions to be<br>
performed by, for example, elements of a computing device. It will be recognized that various actions described herein can be performed by specific circuits (e.g., application specific integrated circuits (ASICs)), by program instructions being executed by one or more processors, or by a combination of both. Additionally, these sequence of actions described herein can be considered to be embodied entirely within any form of computer readable storage medium having stored therein a corresponding set of computer instructions that upon execution would cause an associated processor to perform the functionality described herein. Thus, the various aspects of the invention may be embodied in a number of different forms, all of which have been contemplated to be within the scope of the claimed subject matter. In addition, for each of the embodiments described herein, the corresponding form of any such embodiments may be described herein as, for example, "logic configured to" perform the described action.<br>
[0029]	FIG. 1 is a block diagram of an Information Processing Device (IPD) 100 which<br>
may include a processor unit 110, a memory controller 120, and an external memory device 130. The external memory device 130 may include various different types of external memory devices, which may include NAND flash memory 132, OneNAND flash memory 134, and/or any other known types of memory device 136 (such as, for example, m-system flash, NOR flash memory, EEPROM, ROM, SDRAM, etc.). The memory controller 120 may be a combination of multiple controllers to interface with different type of memory devices mentioned above. During normal operation after the boot sequence is completed, the processor unit 110 may read and/or write data from and/or to the external memory device 130 through memory controller 120. Such communications occurring after the boot sequence has finished may take place in a conventional manner.<br>
[0030]	The IPD 100 may further include other devices not shown in Fig. 1, for example,<br>
graphics, video, audio, CDMA, and/or GSM/GPRS processors; I/O interfaces; etc. The IPD 100 may be part of any type of computer based system, including portable and/or embedded systems which may be used in laptop computers, personal digital assistants (PDAs), and/or mobile communication devices. For example, the mobile communications device may be a handset for use in mobile communications systems, and the IPD 100 may be a Mobile Station Modem (MSM™) chipset for use within the<br>
 <br>
WO 2008/143950<br>
 <br>
PCT/US2008/006256<br>
 <br>
7<br>
handset. The processor may be any type of microprocessor and/or microcontroller, such as, for example, a processor from the ARM9 family. The memory controller may include a one or more bus interfaces and/or multiple memory controllers for a variety of different memory types. For example, the memory controller 120 may have a single memory controller to interface all types of memory devices or multiple memory controllers to access the memory devices. In the embodiment shown in Fig. 1, the IPD 100 may interface with NAND 132, OneNAND flash memory 134, and/or other types of memory 136 (e.g., m-system flash, NOR Flash memory, etc.).<br>
[0031]	When the IPD 100 is either turned-on or power cycled, the processor unit 110<br>
may execute a cold boot sequence to initialize its various hardware and/or software components. The software/firmware which executes the boot sequence may include a plurality of separately compiled routines, wherein each routine performs a different functionality in the boot sequence. The initial routine in the boot sequence may be a primary boot loader (PBL), which sets up the IPD 100 to access and/or download code from a non-volatile external memory device 130. Setting up the IPD 100 may include identifying the type of non-volatile memory connected, reading the configuration data from this memory, processing the data and identify the memory configuration of the system, configuring the memory devices in the system as needed, and copying the code from non-volatile memory to the main memory. The PBL may reside in the on-chip boot ROM for various chipsets in the MSM™ chipset family. The PBL may be vectored to when the processor unit 110 is release from reset. When executed by the processor unit 110 during the cold boot, the PBL may initialize IPD 100 hardware, initialize internal RAM within the processor unit 110 or external RAM, detect nonvolatile external memory device 130, load and process the configuration data from nonvolatile external memory, load subsequent boot routines,.<br>
[0032]	In one embodiment, the PBL 100 may configure the memory interfaces using<br>
the configuration information in the non-volatile external memory device 130 which includes NAND flash memory 132, OneNAND flash memory 134, and/or NOR flash memory (not shown). The memory controller 120 may be capable of supporting different interface data with a variety of memory devices, including NAND devices and OneNAND devices.<br>
[0033]	In order to address any data in the external memory device 130, the memory<br>
controller 120 should identify the external memory device's type and how to access it.<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
8<br>
The IPD 100 may find the type of non-volatile memory device used and its protocol to<br>
access the data in the device, and device's interface bus width. For example, if the<br>
external non-volatile memory is a NOR flash memory, the IPD 100 should to know the<br>
size of the NOR flash memory (to detect the number of address bits required to access<br>
the NOR flash memory), interface data bus width, and how to access the data in the<br>
device. For a NAND, oneNAND, m-system, and superAND flash devices, the IPD 100<br>
should know page/sector size, block size, interface data width, and protocol to access<br>
the data. Page/sector size and block size indicates the size of the device. This may be<br>
accomplished by detecting the page size and bus width of the external memory device<br>
130. Once this is done, the memory controller 120 may be suitably configured, thus<br>
enabling the processor 110 to address any page of the external memory device 130.<br>
Various embodiments of the disclosure may perform page/sector size detection of<br>
page/sector based flash devices so that the IPD can configure the memory controller 120<br>
suitably to access the flash device connected 130. This may be performed in a manner<br>
independent of the connected flash size (e.g., page size, block size, and interface width).<br>
[0034]	The access protocol may be different for NAND and superAND devices with<br>
page size less than or equal 512 Bytes and greater than 512 Bytes. To access the NAND flash device, the IPD 100 should know whether device page size is greater than 512 Bytes so that it can use the correct protocol to access the device. This step can be skipped if the IPD 100 needs to support NAND/superAND flash devices page size greater than 512 Byte only. Similarly detecting the interface data bus width (8-bit/l 6-bit, or greater) may be performed so that the IPD 100 can access the data correctly. If the IPD 100 needs to support only fixed interface width flash device, this step may also be skipped. An exemplary approach for determining whether a NAND flash device size is greater than 512 Bytes, and detecting the interface data bus width, is described in U.S. Patent Application No. 11/231,389, filed on Sept. 20, 2005, which has published as U.S. Patent Publication No. 2007/0067529, which is incorporated herein by reference in its entirety. The details of which are briefly described below.<br>
Hardware Page Size Detection<br>
[0035]	Various embodiments of the invention may include a process for estimating the<br>
page size of the external memory 130 based upon a hardware approach. This approach may be able to determine whether the page size is a smaller page size (512 Bytes or<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
9<br>
less), or greater than or equal to a larger page size (higher than 512 Bytes). The hardware page size detection may be performed by the memory controller 120, which may first perform a read initialization command (details of the command described in the subsequent paragraphs) on the external memory 130. The memory controller 120 may then wait for a specified period of time (typically on the order of 100s of nanoseconds). Then, the memory controller 120 may determine whether the memory device 130 is performing the read command by checking a busy (BSY) signal. If the memory device 130 is busy, the memory device has a smaller page size. On the other hand, if the device is not busy, the memory device has a larger page size. This behavior occurs because the memory device having the smaller page device can react to read command with single command or opcode (read initialization command) where as large page size device requires two read commands (read initialization command and read start command) for the read operation. Large page device waits for the read start command and until the read start command is issued, it will not move to busy state. The memory controller 120 may detect this difference and identify if the NAND/superAND flash device connected is larger page size or not.<br>
[0036]	An example of the hardware page size detection is presented below in the<br>
context of NAND type memory devices. When the external memory device 130 is a NAND type flash memory 132, the smaller page size may be 512 bytes or less , and the larger page size may be greater than 512 Bytes (e.g., 2 Kbytes or greater).<br>
|0037]	NAND memories having 512 byte page devices may use the following read<br>
command sequence:<br>
[0038]	•    Read initialization command (1 cycle command); and<br>
[0039]	•    Data/page address command (3 or 4 or 5 or more cycles) (If more address<br>
cycles are issued than required by the device, the device will accept the required addresses at the beginning and ignore the last address cycles).<br>
[0040]	Within certain time but no later than few micro seconds after issuing the address<br>
cycle, the device will move to BUSY state by asserting the BSY signal to indicate it is executing the read command. If the device responds with BSY signal it is a smaller page (512 byte or less) device.<br>
[0041]	NAND memories having greater than 512 bytes (e.g. 2 Kbyte page sizes or<br>
larger) will not move to BUSY state after the address cycles. These devices require a<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
10<br>
second read start command or opcode to move to BUSY state. And the read command<br>
sequence for these devices is:<br>
[0042]	•    Read initialization command (1 cycle command);<br>
[0043)	• Data/page address command (3 or 4 or 5 or more cycles) (If more address<br>
cycles are issued, the NAND device may accept the required addresses from the<br>
beginning and ignore the last address cycles); and<br>
[0044)	•    Read start command (1 cycle command).<br>
[0045]	Within a certain time, but no later than few micro seconds after issuing the read<br>
start command, the device will move to BUSY state by asserting the BSY signal to indicate it is executing the read command.<br>
[0046]	The memory controller  120 may use the above mechanisms to detect the<br>
NAND/superAND device page sizes. The controller may execute a process within a state machine that performs the following: 1) resets the device; 2) issues a read command; 3) issues address cycles; 4) waits for some time but no later than few micro seconds; and 5) checks to determine if device moved to busy state or not, and if moved to busy state, the device has 512 byte or less page size; 6) if not moved to busy state, issues read start command; 7) waits for some time but no later than few micro seconds; and 8) checks to determine if device moved to busy state or not, and if moved to busy state, the device has a greater than 512 Bytes (e.g. 2 Kbyte or larger) page size.<br>
[0047]	After   detecting   the   device   page   size,   the   memory   controller   120   may<br>
concurrently or thereafter perform a read data transfer in 8-bit mode (even if the connected device is 16-bit or more, the controller only uses the lower 8-bit data from the device). The data read from the flash device can be used to detect the bus size and any other parameters of the flash. Bus width detection will be explained in more detail below. As mentioned above, the data in the first page stored in unique number format (e.g., a magic number) to reduce the probability of random errors. The magic numbers are picked such that, even in the case of error the resulted number will not be another magic number. The IPD will detect such random errors as it knows the magic numbers expected and if the data in the first page (data transferred with the page size detection) is not correct, the PBL can read another page from the device (redundant page in a different location of the device). Without detecting the page size, the PBL can not proceed further and may report that an error condition has occurred.<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
11<br>
[0048]	The hardware page size detection method may be limited in the respect that it<br>
may only be able to detect whether the page size of the external memory device 130 is smaller (e.g., 512 bytes or less) or greater or equal to a lager page size (e.g., 2 Kbytes or more). Embodiments presented herein may utilize software page size detection techniques, which can be used in conjunction with the hardware based approach, to overcome this limitation.<br>
Bus Width Detection<br>
[0049]	FIG. 2A is a diagram of an exemplary data structure residing within a memory<br>
device which can be used to determine the bus width. Because different types of external memory devices utilize different data word sizes, the bus width should be determined during the boot sequence by the PBL. The bus width may be determined using configuration data stored in a data structure on the memory device 130. This determination may be performed by checking the code word after it is read using a given bus width. When reading using a narrow bus width, the first code word may be returned unaltered. However, when a wider bus width is used, the code word may be changed (for example, as shown in the description of Fig. 2B below, the first code word may be interleaved with the second code word). By checking what number the read command produces, the bus width of the memory device 130 may be determined.<br>
[0050]	Further referring to Fig. 2A, the configuration data may include one or more<br>
code words 210, 220. The code words may be written in the first eight bytes of the first page 200, within the first block of the external memory device 130. Code word 210 is referred as 8_BIT_MagicNumber and 220 is referred as Config Magic Number. The rest of the page may contain all ones (OxFF). Because Error Correction Coding (ECC) may not be enabled during this process, the code words may be specially selected numbers in order to minimize read errors. One class of numbers which may be used are those which are generated using a minimum weight algorithm. These numbers may be known as "magic numbers," and can reduce correlated read errors. Other numbers having the ability to avoid read errors may also be used.<br>
[0051]	In an embodiment of the invention where external memory device 130 includes<br>
NAND and/or OneNAND devices, the following example is presented. Current OneNAND flash devices may only be available in 16 bits, an memory controller 120 may be set to  16 bits by default when  interfacing with oneNAND device. The<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
12<br>
techniques described in this embodiment can be applied to detect the page size of oneNAND device if required. However, a memory controller may be set to 8 bits during initialization. In order to detect if the bus width of the flash device is 8 or 16 bits or even more, 8 bytes of unique numbers also referred as magic numbers are placed at the start of the page containing the configuration data. The first 4 bytes data structure 210 (8_BIT_Magicnumber) may hold the magic number 0x83838383, the next 4 bytes data structure 220 (Config Magic Number) may hold the magic number 0x73D71034, while the rest of the page may hold the data 0XFF, as shown in Fig. 2A. During the hardware page size detection method (as explained above), the software may request the memory controller 120 to read 4 bytes of data from page 0 of block 0 of configuration data. When the 4 bytes of data is read, the ECC engine is disabled. The magic numbers (using the minimum weight algorithm) are chosen such that when the data is read, the errors are not correlative.<br>
[0052]	Fig. 2B is a diagram showing how data in the data structure 200 is read from<br>
memory devices having an 8 bit bus width and a 16 bit bus width. Because the 4 bytes of data read will be different for devices of different bus width, the data received after the read operation is performed can be used to determine the bus width of the memory device 130. When the device reads the first 4 bytes using an 8-bit bus width, the first code word is read without being altered. However, when a device has a 16 bit bus width, the read command will return a value which interleaves the least significant bits of the first code word and the second code word.<br>
[0053]	More specifically, for an 8-bit flash device, the original 8_BIT_magic number<br>
value 0x83838383 should be returned. For a 16-bit flash device, the flash memory should return 16 bits of data during the read operation. This interleaving occurs in the 16-bit device because the memory controller 130 is still configured as having an 8-bit wide bus, so it will only read the 8 least significant bits and disregard the 8 most significant bits. Therefore, the controller will read the interleaved value of 0xD7348383. Based on the returned data the IPD detects the bus interface width. Though the examples given in this embodiment describes only for 8-bit and 16-bit, the same techniques can be applied for interfaces having higher bit widths.<br>
Software Page Size Detection<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
13<br>
[0054]	Fig. 3 is a diagram of an exemplary data structure 300 within a memory device<br>
130 which may be used to determine both the bus width and page size of the memory device 130. In order to perform the automatic page size detection algorithm, the memory device 130 may have sections of "dummy data" added for determining the page size of the memory device 130. Each section 305 may include three code words 310-330, with the remainder of the section containing dummy data. This dummy data may be data of all "l's" or loaded with default data that comes with flash device after manufacturing. The only condition is the data stored after the three magic numbers (8_BIT_MagicNumber, Config Magic Number, Auto Detection Magic Number) should be a known value so that error correction can be done on the data. The code words 310 and 320 may be used to determine the bus width as described above. The third code word may be an automatic detection marker which may be used by an algorithm to determine the page size of the memory device 130. While Fig. 3 indicates an exemplary size of the code words as being 4 bytes, other sizes may of course be used. In various embodiments, each of the code words may be magic numbers in order to minimize read errors. The details of the algorithm will be presented below in the description of Fig. 5.<br>
[0055]	The extents of the page sizes which may be encountered by the PBL 100 would<br>
be known as they would represent the maximum (MAX) and minimum (MIN) allowable page sizes which may be supported, which may be predefined. In some cases the MAX and MIN page sizes are fixed at the time of manufacturing of the IPD, and in some other cases these numbers are programmable after the manufacturing of the IPD but fixed before being sent it to a customer. The size of each section 305 may be equal to the MIN page size. The MAX and MIN page size supported will determine the number of sections that need to be added. The number of sections are expressed by the following ratio:<br>
Number of sections = (MAX PAGE SIZE / MIN PAGE SIZE)<br>
[0056]	In an embodiment of the invention, the first 12 bytes of each section 305 may be<br>
marked with magic numbers, as shown in Fig. 3. The first 8 bytes of each section 305 may hold the 8_Bit_Magic number 310 and the Config Magic Number 320, similar to the bus width detection approach described above. Another 4 bytes of a magic number,<br>
 <br>
WO 2008/143950<br>
 <br>
PCT/US2008/006256<br>
 <br>
14<br>
an Auto Detect Magic Number, may be placed after the first 8 bytes. The software page<br>
size detection method will check the Auto Detect Magic Number to derive the page size<br>
using an algorithm explained below.<br>
[0057]	Fig. 4 is a diagram showing how the exemplary data structure shown in Fig. 3 is<br>
contained within memory devices having different page sizes. As the page size of the memory device 130 changes, the number of sections which may be stored in each page will also change. The number of pages which may be needed to fit all the sections can be determined by the Page size of the attached device using the following equation:<br>
Number of pages = (Number of sections') * (MIN Page Size)<br>
(Device Page Size)<br>
[0058]	A number of examples are presented below for different page sizes.    Each<br>
example is pictorially represented in Fig. 4, which shows the data structures associated with three different page sizes, 512 Kbytes (410), 2 Kbytes (420) and 4 Kbytes (430). The numerical examples are as follows.<br>
[0059]	Given a MAX page size = 4K bytes and a MIN page size = 512 bytes, the<br>
number of sections will be 8. This implies that the number of pages to fit all 8 sections will be:<br>
-	8 pages for 512 byte page size device (since the page size of the device<br>
is 512 Bytes, requires 8 pages to fit 8 sections of 512 bytes of data);<br>
-	2 pages for a 2 Kbyte page size device (since the page size of the device is 2 Kbytes, requires 2 pages to fit 8 sections of 512 bytes of data (4 512-bytes per page)); and<br>
-	1 page for a 4 Kbyte page size memory device (8 sections of 512 bytes of data will fit in single page for a 4 Kbyte page device).<br>
[0060]	As will be explained in the description of Fig. 5 below, the number of page sizes<br>
may be determined directly by the processor unit 110 by counting the automatic detection marker (exemplified as the "Auto Detect Magic #" shown in Fig. 4).<br>
[0061]	Fig. 5 is a flow chart depicting an exemplary process 500 for determining page<br>
size of the flash memory device. The process will start by determining the extents of the page sizes for supported memory devices 130 (i.e., determine the MIN and MAX<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
15<br>
values). The MIN and MAX values may be preset values. The number of sections which are marked may then be determined by taking the ratio of the MAX to MIN page size values (block 510). Hardware page size detection may then be performed by the memory controller 120 to determine if the memory device 130 has a page size greater than 512 bytes or not (block 520). The bus width of the memory device 130 may then be detected by the processor unit 110 (block 530). The processor unit 110 may then detect the number of pages having an automatic detection marking (block 540). The processor unit 110 will perform a sequence of read operations to detect the number of pages having an automatic detection marking (block 540). The processor unit 110 may then compute the page size of the memory device 130 based upon the number of pages read having an automatic detection marking (block 550). Note that when the IPD 100 is accessing NAND flash device, it may use the Hardware page size detection to detect whether the device connected page size greater than 512 Bytes or not and uses this information to issue read command to the device.<br>
[0062]	Because data in the memory device 130 may be stored in pages, access from the<br>
memory controller 120 to the memory device 130 may result in accessing an entire page. Accordingly, a write or read associated with the memory device 130 will be page oriented. Since a memory device 130 with a larger page size is able to store more number of sections 305, the memory controller 120 reading data from the memory device 130 will read fewer pages containing the magic numbers. If the first two pages in the memory device 130 are marked with the correct automatic detection markings (e.g. magic numbers), then the processor unit 110 can conclude that the attached device has a 2 Kbyte page size using the formula shown below (512*8/2 = 2 K). If the automatic detection marker is present only in the first page but not the second, then it can be concluded that the attached device is greater than 4 Kbyte page size again based on the formula shown below (512*8/1= 4K).<br>
[0063]	The page size of the device can be found using the formula below:<br>
Device Page Size = fMin Page Size) * (No of Sections Marked)<br>
No of Pages Read<br>
[0064]	Once the page size and bus width of the memory device is determined, the<br>
memory controller 120 may now be configured to the correct settings.<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
16<br>
[0065]	Fig.  6   is  a  flow  chart  of depicting  another exemplary  process  600  for<br>
determining parameters associated with a memory device. Initially, the MAX page size and MIN page size may be obtained as these are typically predefined values (block 615). The number of sections marked with an automatic page detection marker may be computed (block 620). A hardware page size detection may then be performed to determine if the page size is greater than 512 bytes (block 625), if required. If not required, this step can be skipped.<br>
[0066]	Block 630 may perform the following actions: set max pages marked with magic<br>
number to MAX pages marked; set Byte location for magic number to 8; and set pointer location to store data from the device. Next, a function call (details of which are presented below in Fig. 7 and in the associated description) detect the number of pages marked with a magic number may be called (Block 635). The function call may return the Number of Pages Read with Auto Detect Magic Number. A conditional may then be performed to check if the number of pages returned by the function call is zero (Block 640). If so, the page number to read configuration data from is set to 0 (Block 645), and the process returns. If the number of pages marked is not zero in Block 640, the device page size is computed (Block 650) and the process then returns.<br>
[0067]	Fig. 7 is a flow chart depicting an exemplary process for counting the number of<br>
automatic detection markers. Initially the following parameters may be obtained: MAX pages marked with a magic number, the byte location for the magic number (set "x" as this value (as an example, the location is shown as 8), and the pointer location to store data may be read from the device (Block 715). The number of pages read may then be initialized to 0 (Block 720). A conditional may be performed to determine if the number of pages read is less than or equal to the max pages marked with a magic number (Block 725). If so, the page may be read (Block 730), and another conditional may then be performed to check if byte "x" of read page is marked with code word (Block 735). If so, the page counter is incremented (Block 755), and the process returns to Block 725. If condition in Block 735 fails, another conditional check may be performed to determine if the number of pages read is less than or equal to the max number of pages marked with a magic number (Block 740). If the conditional performed in Block 740 is true, the process 700 returns the number of pages read (Block 750); and if the conditional in Block 740 is false, an error control handler is called<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
17<br>
(Block 745). Also, the error handler is called (Block 745), if the conditional performed in Bock 725 is false.<br>
[0068]	The memory controller 120 may perform error correction on the read data in<br>
block 730 before checking byte x for a magic number in block 735. The memory controller 120 may check the data integrity during the error correction checking. The result of this error correction checking may include the following. The controller may detect that the data read from the device is intact and no errors are detected. In this case case, processing will proceed accordingly. Alternatively, the controller 120 may detect errors wherein number of errors detected is less than the maximum number of correctable errors (based on the ECC algorithm used). In this case, the controller 120 may correct the errors and then proceed accordingly. Alternatively, the controller 120 may detect errors which cannot be corrected. In this case, the controller 120 may return processing control to an error handler. Error correction will provide extra protection for the magic numbers stored in the device against random errors.<br>
[0069)	Various embodiments of the disclosure may enable ECC operations so that the<br>
integrity of the page detection process may be protected by magic numbers as well as conventional ECC algorithms. This combination of approaches can provide a more robust way to determine the page size of flash devices.<br>
[0070]	Fig. 8 is a diagram showing another exemplary data structure 800 having a<br>
section of dummy data. Based on the system requirements, config data can be stored in the page next the last page that has Auto Detect Magic Number or multiple pages of dummy data may be added between the last page with Auto Detect Magic Number and config data as shown in Fig. 8. The number of pages with dummy data may also be predefined for the IPD so that after detecting the device page size, the IPD can skip the dummy data pages and read the config data. In the Fig. 8, the IPD detected only first 2 pages (Page 0 and Page 1) has the Auto Detect Magic Number. As the example given above, if the MIN page size = 512 Bytes, Number of Sections with Auto Detect Magic Number = 8, device page size = 2 Kbytes (512 * 8/2) based on the formula above. It also has 2 pages of dummy data and hence the IPD will jump to page number 4 to read secondary boot code. It is possible the IPD inserts no dummy data pages after the last page with Auto Detect Magic Number and in which case, the IPD will start reading the secondary code from Page 2 as shown in Fig. 8.<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
18<br>
[0071]	Those of skill in the art will appreciate that information and signals may be<br>
represented using any of a variety of different technologies and techniques. For example, data, instructions, commands, information, signals, bits, symbols, and chips that may be referenced throughout the above description may be represented by voltages, currents, electromagnetic waves, magnetic fields or particles, optical fields or particles, or any combination thereof.<br>
[0072]	Further, those of skill in the art will appreciate that the various illustrative<br>
logical blocks, modules, circuits, and algorithm steps described in connection with the embodiments disclosed herein may be implemented as electronic hardware, computer software, or combinations of both. To clearly illustrate this interchangeability of hardware and software, various illustrative components, blocks, modules, circuits, and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application, but such implementation decisions should not be interpreted as causing a departure from the scope of the present invention.<br>
[0073]	The methods, sequences and/or algorithms described in connection with the<br>
embodiments disclosed herein may be embodied directly in hardware, in a software module executed by a processor, or in a combination of the two. A software module may reside in RAM memory, flash memory, ROM memory, EPROM memory, EEPROM memory, registers, or any other form of storage medium known in the art. An exemplary storage medium is coupled to the processor such that the processor can read information from, and write information to, the storage medium. In the alternative, the storage medium may be integral to the processor.<br>
[0074]	Accordingly, an embodiment of the invention can include a computer readable<br>
media embodying a method for memory page size auto detection. Accordingly, the invention is not limited to illustrated examples and any means for performing the functionality described herein are included in embodiments of the invention.<br>
[0075]	While the foregoing disclosure shows illustrative embodiments of the invention,<br>
it should be noted that various changes and modifications could be made herein without departing from the scope of the invention as defined by the appended claims. The functions,   steps   and/or  actions   of the   method   claims   in   accordance   with   the<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
19<br>
embodiments of the invention described herein need not be performed in any particular order. Furthermore, although elements of the invention may be described or claimed in the singular, the plural is contemplated unless limitation to the singular is explicitly stated.<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
20<br>
CLAIMS WHAT IS CLAIMED IS:<br>
1.	A method for automatically determining a page size of a memory device,<br>
comprising:<br>
receiving page size extents of the memory device; determining a bus width of the memory device;<br>
detecting a number of pages having an automatic detection marker; and determining the page size of the memory device based upon the detected number of pages with the automatic detection marker and the received page size extents.<br>
2.	The method according to claim 1, wherein the page size extents include a<br>
maximum possible page size and a minimum possible page size for the memory device,<br>
and further comprising:<br>
determining a number of sections marked by computing a ratio of the maximum possible page size and the minimum possible page size.<br>
3.	The method according to claim 1, wherein the determining the bus width<br>
further comprises:<br>
providing, adjacently in the memory device, a first four byte word and a second four byte word;<br>
reading a first four bytes from the memory device when a memory controller is configured in an eight bit mode; and<br>
determining whether the read bytes correspond to an interleaving of the first four byte word and the second four byte word, wherein the interleaving corresponds to the memory device having a 16-bit bus width.<br>
4.	The method according to claim 3, wherein the first four byte word<br>
corresponds to a first magic number, and the second four byte word corresponds to a<br>
second magic number.<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
5.	The method according to claim 1, wherein the detecting the number of<br>
pages further comprises:<br>
reading sequentially a series of pages from the memory device; and counting the number of pages which contain the automatic detection marker.<br>
6.	The method according to claim 5, further comprising:<br>
reading a page of data from the memory device; and<br>
testing whether the data contains the automatic detection marker.<br>
7.	The method according to claim 6, wherein when it is determined the data<br>
contains the automatic detection marker, further comprising:<br>
incrementing a counter corresponding to the number of pages read; and repeating the reading the page and the testing until the data fails to contain the automatic detection marker.<br>
8.	The method according to claim 7, wherein when it is determined the data<br>
does not contain the automatic detection marker, further comprising:<br>
determining whether the counter exceeds a maximum number of pages marked with the automatic detection marker, and, if so, signaling an error condition.<br>
9.	The method according to claim 1, wherein the automatic detection marker is a magic number.<br>
10.	The method according to claim 2, further comprising:<br>
computing the page size of the memory device by determining a product of the number of sections marked and the minimum possible page size, and dividing the product by the number of pages having the automatic detection marker.<br>
11.	The method according to claim 1, further comprising:<br>
determining in hardware whether the memory device utilizes a smaller page size or a larger page size.<br>
12.       The method according to claim 1, further comprising:<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
22<br>
performing a read initialization command; and<br>
checking to determine whether the memory device is busy after a predetermined period of time.<br>
13.	The method according to claim 2, further comprising:<br>
providing data on the memory device which is divided into the number of sections, each section containing at least one code word, the automatic detection marker, and dummy data.<br>
14.	The method according to claim 13, wherein the at least one code word includes a NAND8BIT codeword and a configuration number.<br>
15.	The method according to claim 14, wherein the at least one code word and the automatic detection marker are magic numbers.<br>
16.	The method according to claim 1, wherein the memory device includes a NAND flash memory, an m-system flash memory, or a OneNAND flash memory.<br>
17.	An apparatus for automatically determining a page size of a memory device, comprising:<br>
logic configured to receive page size extents of the memory device;<br>
logic configured to determine a bus width of the memory device;<br>
logic configured to detect a number of pages having an automatic detection marker; and<br>
logic configured to determine the page size of the memory device based upon the detected number of pages with the automatic detection marker and the received page size extents.<br>
18.	The apparatus according to claim 17, wherein the page size extents<br>
include a maximum possible page size and a minimum possible page size for the<br>
memory device, and further comprising:<br>
logic configured to determine a number of sections marked by computing a ratio of the maximum possible page size and the minimum possible page size.<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
23<br>
19.	The apparatus according to claim 17, wherein the logic for determining<br>
the bus width further comprises:<br>
logic configured to provide, adjacently in the memory device, a first four byte word and a second four byte word;<br>
logic configured to read a first four bytes from the memory device when a memory controller is configured in an eight bit mode; and<br>
logic configured to determine whether the read bytes correspond to an interleaving of the first four byte word and the second four byte word, wherein the interleaving corresponds to the memory device having a 16-bit bus width, wherein.<br>
the first four byte word corresponds to a first magic number, and the second four byte word corresponds to a second magic number, and the automatic detection marker is a magic number.<br>
20.	The apparatus according to claim 17, wherein the logic for detecting the<br>
number of pages further comprises:<br>
logic configured to read sequentially a series of pages from the memory device;<br>
logic configured to count the number of pages which contain the automatic detection marker;<br>
logic configured to read a page of data from the memory device; and<br>
logic configured to test whether the data contains the automatic detection marker.<br>
21.	The apparatus according to claim 20, wherein when it is determined the<br>
data contains the automatic detection marker, further comprising:<br>
logic configured to increment a counter corresponding to the number of pages read; and<br>
logic configured to repeat the reading the page and the testing until the data fails to contain the automatic detection marker, and<br>
wherein when it is determined the data does not contain the automatic detection marker, further comprising<br>
 <br>
WO 2008/143950<br>
 <br>
PCT7US2008/006256<br>
 <br>
24<br>
logic configured to determine whether the counter exceeds a maximum number of pages marked with the automatic detection marker, and, if so, signaling an error condition.<br>
22.	The apparatus according to claim 18, further comprising:<br>
computing the page size of the memory device by determining a product of the number of sections marked and the minimum possible page size, and dividing the product by the number of pages having the automatic detection marker.<br>
23.	An apparatus for automatically determining a page size of a memory<br>
device, comprising:<br>
means for receiving page size extents of the memory device;<br>
means for determining a bus width of the memory device;<br>
means for detecting a number of pages having an automatic detection marker; and<br>
means for determining the page size of the memory device based upon the detected number of pages with the automatic detection marker and the received page size extents.<br>
24.	The apparatus according to claim 23, wherein the page size extents<br>
include a maximum possible page size and a minimum possible page size for the<br>
memory device, and further comprising:<br>
means for determining a number of sections marked by computing a ratio of the maximum possible page size and the minimum possible page size.<br>
25.	The apparatus according to claim 23, further comprising:<br>
means for reading sequentially a series of pages from the memory device; and means for counting the number of pages which contain the automatic detection marker.<br>
</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=kCKnsxkxWj/OPazLdzyxoA==&amp;amp;loc=vsnutRQWHdTHa1EUofPtPQ==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=kCKnsxkxWj/OPazLdzyxoA==&amp;amp;loc=vsnutRQWHdTHa1EUofPtPQ==</a></p>
		<br>
		<div class="pull-left">
			<a href="279621-method-for-preparing-trifluoromethanesulphinic-acid.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="279623-method-for-the-preparation-of-aqueous-dispersions-of-tio2-in-the-form-of-nanoparticles-and-dispersions-obtainable-with-this-method.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>279622</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1983/MUMNP/2009</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>05/2017</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>03-Feb-2017</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>27-Jan-2017</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>23-Oct-2009</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 Morehouse Drive  San Diego  California 92121-1714  United States of America</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>MADDALI  Srinivas</td>
											<td>5775 Morehouse Drive  San Diego  California 92121-1714  United States of America</td>
										</tr>
										<tr>
											<td>2</td>
											<td>BEBAL  Arshad</td>
											<td>5775 Morehouse Drive  San Diego  California 92121-1714  United States of America</td>
										</tr>
										<tr>
											<td>3</td>
											<td>KUO  Tom TsoWei</td>
											<td>5775 Morehouse Drive  San Diego  California 92121-1714  United States of America</td>
										</tr>
										<tr>
											<td>4</td>
											<td>YANG  Tun</td>
											<td>5775 Morehouse Drive  San Diego  California 92121-1714  United States of America</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 12/04,G06F13/38,G06F 9/445</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2008/006256</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2008-05-14</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/976,543</td>
									<td>2007-10-01</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/917,901</td>
									<td>2007-05-14</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>3</td>
									<td>12/119,587</td>
									<td>2008-05-13</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/279622-memory-page-size-auto-detection by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:04:28 GMT -->
</html>
