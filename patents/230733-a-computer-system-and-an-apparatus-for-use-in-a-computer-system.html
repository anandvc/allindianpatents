<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/230733-a-computer-system-and-an-apparatus-for-use-in-a-computer-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 11:32:17 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 230733:A COMPUTER SYSTEM AND AN APPARATUS FOR USE IN A COMPUTER SYSTEM</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A COMPUTER SYSTEM AND AN APPARATUS FOR USE IN A COMPUTER SYSTEM</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>\»7 ABSTRACT A computer system and an apparatus for use in a computer system A computer system for identifying a specific individual relative to said system using a biometric characteristic of said specific individual, comprising at least one apparatus. The apparatus includes a housing, a biometric sensor means for generating a first code and being mounted in said housing, and a controller means including a memory for storing the first code and a dynamic binary code conversion algorithm. The computer system includes a first database containing the dynamic binary code conversion algorithm. The controller means performs, when receiving a code from the biometric sensor means a comparison of the code with the first code stored in the memory and provided the comparison verifies the identity between the code and the first code, a generation of a first binary code by means of the dynamic binary code conversion algorithm and outputting the first binary code from said apparatus to the computer system, and the computer system generates, when receiving the first binary code, a second binary code by means of the dynamic binary code conversion algorithm and verifies the identity of the specific individual provided the second binary code matches the first binary code.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
The present invention relates to an apparatus for providing safe identification of an individual using biometric data. The apparatus may be used for secure and anonymous finandahransacHons^and may also function as digital signatures or password for secure IT systems.<br>
High security data cards are known in the art and have been described in publications, such as WO 02/41236, US 6,592,044, while authentication of users using an electronic transaction system has been described in a publication such as US 6,594,759.<br>
Within the technical field of the present invention, systems combining finger print and passwords for accessing or logging into IT systems are known. However, these systems are in some way dependant on external installations for performing its operation. For example storing a finger print on a smart card and inserting the smart card into a smart card reader connected to a computer further connected to a finger print sensor for verifying that the finger print stored on the smart card matches the finger print sensed by the finger print sensor.<br>
Systems wherein the smart card has been replaced by a device such as a USB key or memory unit whereon a statistical code and a finger print is stored are known. By inserting the USB device into a computer further connected to a finger print sensor, a match between the finger print stored on the USB device and finger print registered by the finger print sensor enables the stored code to be displayed in a display included on the USB device.<br>
Both of the above-mentioned examples includes splitting the authentication process Into two systems depending on each other in able to function, i.e. the smart card and the USB key are partly dependent on current from the external source and identical finger print recognition algorithms on the devices and the external computers. Disadvantages of these methods are that they are not mobile and accessible as the application is limited to rely on external installations having built-in<br><br>
sensors and that the finger print recognition algorithm or at least the finger print algorithm used while digitising the fingerprints included in the smart card and the USB key is the same as the finger print recognition algorithm included in the external system. Furthermore, the code is stored on the device enabling hackers or thieves to obtain access to the code stored on the device, thereby exposing the user to theft or misuse of the identity of the individual owning the card.<br>
Devices for identifying individuals using biometric input devices have been described in publications such as WO 2004/010372 and US 2003/0046228. All of the above-mentioned patent publications are hereby incorporated in the present specification by reference in their entirety and for all purposes.<br>
An object of the present invention is to provide a safe and reliable verification of an individual by means of biometric data of said individual and in doing so to any substantial extent eliminating the disadvantages of the prior art techniques and methods.<br>
The above object together with numerous advantages and features and further objects which will be evident from the beiow detailed description of the present invention are in accordance with a first aspect of the present invention obtained by means of a computer description for identifying a specific individual relative to said system using a biometric characteristic of said specific individual, comprising: i) at least one apparatus including:<br>
-	a housing defining an outer surface,<br>
-	a biometric sensor means for generating a first code in response to the detection of said biometric characteristic of said specific individual, said biometric sensor being mounted in said housing and being exposed at said outer surface,<br>
-	a controller means mounted in said housing and including a memory for storing said first code and a dynamic binary code conversion algorithm, said controller means being electrically connected to said biometric sensor means,<br>
-	a first communication means mounted in said housing and electrically connected to and controlled by said controller means for establishing communication between said apparatus and said computer system,<br><br>
-	a power supply means electrically connected to said biometric sensor<br>
means, said controller means, and said first communication means for the supply of<br>
electric power thereto,<br>
ii) said computer system including a first database containing said dynamic binary code conversion algorithm, and a second communication means for establishing communication between said computer system and said apparatus, iii) said controller means performing, when receiving a code from said biometric sensor means a comparison of said code with said first code stored in said memory and provided said comparison verifies the identity between said code and said first code a generation of a first binary code by means of said dynamic binary code conversion algorithm and outputting said first binary code from said apparatus by means of said first communication means to said computer system, and said computer system generating, when receiving said first binary code from said apparatus by means of said second communication means, a second binary code by means of said dynamic binary code conversion algorithm and verifying the identity of said specific individual provided said second binary code matches said first binary code.<br>
Alternatively, the above object together with numerous advantages and features and<br>
further objects which will be evident from the below detailed description of the<br>
present invention are in accordance with a second aspect of the present invention is<br>
obtained by means of a computer system for identifying a specific individual relative<br>
to said system using a biometric characteristic of said specific individual,<br>
comprising:<br>
i) at least one apparatus including:<br>
-	a housing defining an outer surface,<br>
-	a biometric sensor means for generating a first code in response to the detection of said biometric characteristic of said specific individual, said biometric sensor being mounted in said housing and being exposed at said outer surface,<br>
-	a controller means mounted in said housing and including a memory for storing said first code and a dynamic binary code conversion algorithm, said controller means being electrically connected to said biometric sensor means,<br><br>
-	a display means mounted in said housing and being exposed at said outer surface, said display means being electrically connected to and being controlled by said controller means,<br>
-	a power supply means electrically connected to said biometric sensor means, said controller means, and said display means for the supply of electric power thereto,<br>
said computer system including a first database containing said dynamic binary code conversion algorithm, and a code input means,<br>
said controller means performing, when receiving a code from said biometric sensor means a comparison of said code with said first code stored in said memory and provided said comparison verifies the identity between said code and said first code a generation of a first binary code by means of said dynamic binary code conversion algorithm and displaying said first binary code converted into an alphanumeric number, preferably a decimal number constituting a Pin code on said display means, and<br>
said computer system generating, when receiving said Pin code input by means of said code input means, a second binary code by means of said dynamic binary code conversion algorithm and verifying the identity of said specific individual provided said second binary code matches said first binary code reconverted from said Pin code.<br>
According to the basic teachings of the present invention, it has been realised that a safe and reliable recognition or identification of an individual based on a biometric characteristic of the individual is obtained provided the verification apparatus which may constitute a portable device such as a smart card or any other mobile or stationary apparatus and the computer system relative to which the identity of the individual is to be verified for verifying the authenticity of the individual in question, utilise one and the same dynamic binary code conversion algorithm for generating a code in the apparatus for transmission or input to the computer system and within the computer system for verifying the correct code and in doing so, verifying the identity or authenticity of the individual in question.<br><br>
In the present context, the expression dynamic binary code conversion algorithm is a term defining any conversion algorithm which in the conversion of an input code into an output code provides a reproducible and unique conversion, which conversion, however, is altered each and every time the algorithm is used, however altered in a predictable manner as the algorithm itself includes the predictable and reproducible determination of the dynamic alteration or change. Below, examples of dynamic binary code conversion algorithms are described, however, the below examples are by no means to be considered complete and therefore, any conversion algorithm fulfilling the above requirements and definition is to be considered in the present context a dynamic binary code conversion algorithm.<br>
In accordance with a first aspect of the present invention, the communication between the apparatus and the computer system may be established in accordance with any hardwire or wireless communication technique well known in the art per se, such a conventional parallel or serial unit and/or in a radio link, an infrared link, a capacitive coupling link, an induction loop link or any other contactless or wireless communication technique.<br>
Similar to the communication means which may be implemented in accordance with any hardwire or wireless communication technique known in the art per se, the code input means may be constituted by any manually operated or automatized code input means such as a keyboard for the input of an alphanumeric number, a voice recognition based code input means aliowing the individual to input the alphanumeric number into which the first binary code has been converted by simply spelling the alphanumeric number to a microphone. A video detector for the detection of the digits presented on the display in visible presentation or in e.g. IR displaying may alternatively be used as the code input means.<br>
In accordance with the presently preferred embodiment of the computer system according to a first aspect of the present invention, the apparatus further comprises a display means mounted in said housing and being exposed at said outer surface, said display means being electrically connected to said power supply means and said controller means and being controlled by said controller means, and being<br><br>
powered by said power supply means, said display means displaying said first binary code converted into an alphanumeric number, preferably a decimal number constituting a Pin code after verification of identity between said code and said first code. Equivalent^, In accordance with the presently preferred embodiment of the computer system according to the second aspect of the present invention, the apparatus further includes a first communication means mounted in said housing and electrically connected to and controlled by said controller means for establishing communication between said apparatus and said computer system, and said computer system including a second communication means for establishing communication between said computer system and said apparatus.<br>
As will be understood, the above described preferred embodiments of the computer system according to the first and the second aspect of the present invention are literally one and the same.<br>
It is to be understood that the computer system according to the first and the second aspect of the present invention may be implemented for performing additional functions such as the transfer of information for the transfer of amounts from one bank account to another for the allowance of access to a specific area for allowing access to a particular computer database etc.<br>
A particular application of the present invention relates to the unique and reproducible, yet dynamic generation of a verification Pin code or any other alphanumeric number, which number or Pin code is verifiable in the computer system.<br>
The apparatus constituting an essential part of the invention, preferably in a plurality as the computer system serves to verify the identity of more than one individual such as the employees of an organisation or the customers of a bank, a credit organisation etc. may, as mentioned above, be implemented as a stand alone apparatus, preferably implemented as a credit card, having the dimensions of a credit card conforming to the ISO standards (International Organisation of Standardisation).<br><br>
It is, however, to be understood that apart from a full size credit card conforming to the ISO standard, a double size or a half size or quarter size credit card may further be implemented or according to a specific requirement of the relevant, organisation such as the company issuing the card and running the computer system, the apparatus basically constituting a credit card or any other configurated apparatus may be shaped as a box, a shallow plate having a basically circular, rectangular, square, triangular or any other geometrical configuration.<br>
Alternatively, the apparatus may be implemented as a terminal of a bank organisation, a personal computer connected to a biometric sensor module or any other stationary or portable apparatus. Provided the apparatus is implemented as a credit card, the credit card is advantageously, as will be described below, implemented having a total height of no more 1 mm as the technique verified by the production of the prototype embodiment described below as the presently preferred embodiment verifies the ability of miniaturising the apparatus into a bendable plastics body having the outer dimensions and the thickness of a conventional ISO standard credit card.<br>
In the ISO standard card embodiment of the apparatus according to the present invention, power supply means may be implemented as a battery power supply unit, alternatively a solar cell, a mechanical or piezo cheramic based power generator. The biometric sensor means may be positioned at the same outer surface as the display means, which may be constituted as a plastics foil based multi-digit display or on the opposite side or surface of the credit card embodiment of the apparatus.<br>
It is to be understood that the technique according to the present invention as defined in the above-described first and second aspects of the present invention is by no means based to a single biometric characteristic detection as more than one biometric characteristic may be detected and evaluated. In this contexts, it is to be understood that the term biometric characteristic is to be construed a generic term including and comprising any individual specific characterisitic based on the individuality of the individual such as a characteristic originally created by the unique<br><br>
DNA of the individual. Examples of biometric sensor means are an iris scanner, a blood scanner, a DNA scanner, a voice identification scanner, a face recognition scanner and an array scanner for scanning the palm of the individual or according to the presently preferred embodiment of the computer system according to the first and the second aspect of the present invention implemented as an array scanner for scanning one whole finger or preferably a finger print of the individual.<br>
The utilisation of the dynamic binary code conversion algorithm necessitates that the apparatus and the computer system are synchronised in the verification, else, the first binary code generated by the apparatus and transmitted or input by means of a code input means may not be verified by the computer system. An example of lack of synchronism between the apparatus and the computer system may occur in case the individual Intentionally or unintentionally causes the biometrical sensor means to generate said first code inevitably causing the controller means of the apparatus to generate the first binary code and in case no transmission or input of the first binary code to the computer system is established, the apparatus and the computer system are no longer in synchronism, as next time the apparatus performs a verification of the identity of the individual by the generation of the first binary code by means of the dynamic binary code conversion algorithm, the computer system at its end generates the second binary code conforming to and matching the first binary code previously generated by the apparatus as the individual intentionally or unintentionally caused the biometric sensor means to generate the first code.<br>
In order to ensure that the apparatus and the computer system are always operated in synchronism, the computer system further includes, according to the presently preferred embodiment of the computer system according to the first and the second aspect of the present invention, a second database including a sequence of binary codes generated sequentially by means of said dynamic binary code conversion algorithm, and said computer system comparing said first binary code with said sequence of binary codes contained in said second database for verifying the identity of said specific individual provided said first binary code Is not matching said second binary code.<br><br>
The transmission between the apparatus and the computer system may, due to the inherent tamper proof and copying safe verification due to the dynamic binary code conversion algorithm, be carried out without using any encryption and decryption. Furthermore, provided e.g. a wireless link, such as a GSM or satellite based communication link be used, the multiplicity of the information transmitted through the system inherently ensures safety and security. However, according to one embodiment of the computer system according to the first and the second aspect of the present invention, the system further comprises encryption and decryption means controlled by said controller means for performing said communication from said controller means to and from said external computer system in encrypted state according to e.g. DES encryption or other public or non-public encryption keys.<br>
As mentioned above, the communication between the apparatus and the computer system may be carried out in accordance with any communication protocol and consequently, the first and the second communication means of the apparatus and the computer system, respectively, may be implemented as a parallel communication interface, a serial communication interface, an SPI, an I2C, an USB, a wireless communication interface such as blue tooth, an infra red or RF communication.<br>
The above object together with together with numerous advantages and features and further objects which will be evident from the below detailed description of the present invention are in accordance with a third aspect of the present invention obtained by means of an apparatus for use in a computer system for identifying a specific individual relative to said system using a biometric characteristic of said specific individual, comprising:<br>
-	a housing defining an outer surface,<br>
-	a biometric sensor means for generating a first code in response to the detection of said biometric characteristic of said specific individual, said biometric sensor being mounted in said housing and being exposed at said outer surface,<br>
-	a controller means mounted in said housing and including a memory for storing said first code and a dynamic binary code conversion algorithm, said controller means being electrically connected to said biometric sensor means,<br><br>
-	a first communication means mounted in said housing and electrically connected to and controlled by said controller means for establishing communication between said apparatus and said computer system,<br>
-	a power supply means electrically connected to said biometric sensor means, said controller means, and said first communication means for the supply of electric power thereto, and<br>
-	said controller means performing, when receiving a code from said biometric sensor means a comparison of said code with said first code stored in said memory and provided said comparison verifies the Identity between said code and said first code a generation of said first code into a first binary code by means of said dynamic binary code conversion algorithm and outputting said first binary code from said apparatus by means of said first communication means to said computer system.<br>
Equivalent^, the above object together with together with numerous advantages and features and further objects which will be evident from the below detailed description of the present invention are in accordance with a fourth aspect of the present invention obtained by means of an apparatus for use in a computer system for identifying a specific individual relative to said system using a biometric characteristic of said specific individual, comprising:<br>
-	a housing defining an outer surface,<br>
-	a biometric sensor means for generating a first code in response to the detection of said biometric characteristic of said specific individual, said biometric sensor being mounted in said housing and being exposed at said outer surface,<br>
-	a controller means mounted in said housing and including a memory for storing said first code and a dynamic binary code conversion algorithm, said controller means being electrically connected to said biometric sensor means,<br>
-	a display means mounted in said housing and being exposed at said outer surface, said display means being electrically connected to and being controlled by said controller means,<br>
-	a power supply means electrically connected to said biometric sensor means, said controller means, and said display means for the supply of electric power thereto, and<br><br>
- said controller means performing, when receiving a code from said biometric sensor means a comparison of said code with said first code stored in said memory and provided said comparison verifies the identity between said code and said first code a generating a first binary code by means of said dynamic binary code conversion algorithm and displaying said first binary code converted into an alphanumeric number, preferably a decimal number constituting a Pin code on said display means.<br>
The apparatuses according to the third and the fourth aspects of the present invention basically constitute a portable or stationary apparatus as discussed above constituting an element of the above described computer system according to the first and the second aspect of the present invention and therefore, no further discussion of the apparatuses according to the third and fourth aspects of the present invention are given.<br>
The above object together with numerous advantages and features and further objects which will be evident from the below detailed description of the present invention are in accordance with a fifth aspect of the present invention obtained by a method of identifying a specific individual relative to a system using a biometric characteristic of said specific individual, comprising1, i) providing at least one apparatus including:<br>
-	a biometric sensor means for generating a first code in response to the detection of said biometric characteristic of said specific individual,<br>
-	a controller means including a memory for storing said first code and a dynamic binary code conversion algorithm, said controller means being electrically connected to said biometric sensor means,<br>
-	a first communication means and electrically connected to and controlled by said controller means for establishing communication between said apparatus and said computer system,<br>
-	a power supply means electrically connected to said biometric sensor means, said controller means, and said first communication means for the supply of electric power thereto,<br><br>
ii) said computer system including a first database containing said dynamic binary code conversion algorithm, and a second communication means for establishing communication between said computer system and said apparatus, iii) the method comprising:<br>
-	when receiving a code from said biometric sensor means performing a comparison of said code with said first code stored in said memory and provided said comparison verifies the identity between said code and said first code generating a first binary code by means of said dynamic binary code conversion algorithm and outputting said first binary code from said apparatus by means of said first communication means to said computer system, and<br>
-	said computer system, when receiving said first binary code from said apparatus by means of said second communication means, generating a second binary code by means of said dynamic binary code conversion algorithm and verifying the identity of said specific individual provided said second binary code matches said first binary code.<br>
The above object together with numerous advantages and features and further objects which will be evident from the below detailed description of the present invention are in accordance with a sixth aspect of the present invention obtained by a method of identifying a specific individual relative to said system using a biometric characteristic of said specific individual, comprising: i) providing at least one apparatus including:<br>
-	a biometric sensor means for generating a first code in response to the detection of said biometric characteristic of said specific individual,<br>
-	a controller means and including a memory for storing said first code and a dynamic binary code conversion algorithm, said controller means being electrically connected to said biometric sensor means,<br>
-	a display means being electrically connected to and being controlled by said controller means,<br>
-	a power supply means electrically connected to said biometric sensor means, said controller means, and said first communication means for the supply of electric power thereto,<br><br>
ii) said computer system including a first database containing said dynamic binary code conversion algorithm, and a code input means, iii) the method comprising'.<br>
- when receiving a code from said biometric sensor means performing a comparison of said code with said first code stored in said memory and provided said comparison verifies the identity between said code and said first code generating a first binary code by means of said dynamic binary code conversion algorithm and displaying said first binary code converted into an alphanumeric number, preferably a decimal number constituting a Pin code on said display means, and<br>
- when receiving said first Pin code input by means of said code input means, generating a second binary code by means of said binary code conversion algorithm and verifying the identity of said specific individual provided said second binary code matches said first binary code reconverted from said Pin code.<br>
The present invention is now to be described in greater detail with reference to the<br>
drawings, in which:<br>
Fig. 1 illustrates a smart card according to the present invention,<br>
Fig. 2 is a schematic view of the components on the smart card in Fig. 1,<br>
Fig. 3 - 6 is schematic views of the four layers of the printed circuits on the smart<br>
card in Fig. 1,<br>
Fig. 7 is an illustration of the communication between the card, the authentication<br>
server and the application server,<br>
Fig. 8 illustrates the initialisation and synchronisation process,<br>
Fig. 9 illustrates a lay out of a card, and<br>
Fig. 10 illustrates the card in block diagrammatic form.<br>
Fig. 1 illustrates a smart card constituting the presently preferred embodiment of the apparatus according to the invention and embodied as a prototype embodiment. The smart card is designated the reference numeral 10. The smart card is based on IEC7810, card type 10-1 and IEC 10 436-1 defining the physical dimensions of the card. (ISO 7810:75(e)). In the presently preferred embodiment of the present invention, the card has a thickness of approximately 5mm. The overall dimensions<br><br>
of the card is 85mm x 55mm x 4mm and is, as shown in Fig. 1 the card has a rectangular configuration.<br>
However, embodiments, wherein the overall geometrical configuration being circular, elliptical, square, triangular, hexagonal, pentagonal or spherical, may be envisioned.<br>
The card 10 includes a fingerprint sensor 12 for registering an individual's identity by means of fingerprint information. However, the sensor 12 may be replaced by any sensor for sensing biometric data for the verification of an individual's identity. Sensors of this type have been described in publications such as WO 02/074168 and WO 01/150660, both publications hereby incorporated in the present specification by reference in their entirety.<br>
Also included in the card is a display designated the reference numeral 14. The display 14 is used for inputting information to the user, such as status information or Pin codes as will be described later.<br>
The card 10 further includes a smart card interface 16 for interfacing to other systems.<br>
When the card is first used, the card must be initialised, i.e. the card must be supplied with the reference fingerprint or other biometric data for correct identification of the card holder.<br>
The initialisation process comprises the following steps:<br>
1)	Turning on the card.<br>
2)	The display 14 displays the message 'ready1.<br>
3)	The user moves a specific finger across the biometric sensor 12,<br>
4)	Depending on the success of the sensing of the fingerprint, the display 14 displays either 'good' or 'error'.<br><br>
5)	The user again moves the same specific finger across the biometric sensor 12 to verify the finger print.<br>
6)	The display 14 then displays either the message 'good-1' or 'error1, provided the message is 'error", the user must repeat the steps 3-5.<br>
7)	The user again verifies the fingerprint by moving the specific finger across the finger print sensor 12.<br>
8)	Provided the fingerprint is verified, the display 14 displays the message 'good-2'.<br>
9)	An 8-figure number is now shown in the display, which number is transferred via the internet function to the security system of Pi-Card.<br>
Fig. 2 is a schematic view of the components comprised within the card 10 and Figs. 3-6 illustrates the four-layer print for the establishment of the electrical connections between the components illustrated in Fig. 2.<br>
Example<br>
The prototype embodiment of the apparatus described above with reference to Figs. 1-6 was made from the following components:<br>
Component dev.       art.        description<br><br>
C1	0805	100nF	capacitor<br>
C2	1206	1uF	capacitor<br>
C3	0805	470nF	capacitor<br>
C4	0805	470nF	capacitor<br>
C5	0805	470nF	capacitor<br>
06	0805	470nF	capacitor<br>
C7	0805	470nF	capacitor<br>
C8	0805	470nF	capacitor<br>
C9	0805	470nF	capacitor<br>
C10	0805	470nF	capacitor<br>
C11	0805	470nF	capacitor<br>
C12	0805	470nF	capacitor<br>
C13	0805	470nF	capacitor<br><br>
o	o	o	o	o	o	o	O	o	o	o<br>
		■*-*	
o	o	o	o	o	o	o	O	O	o	o<br>
CO	to	CD	CD	CD	CD	CO	co	CO	CO	CD<br>
Q.	a.	Q.	a.	a.	£2.	CL	a.	n.	a.	Q.<br>
to o	s	CO O	CO<br>
o	CO<br>
o	CO<br>
o	CD<br>
o	CO<br>
o	s	CD<br>
o	CD O<br>
LL.	u.	U-	U-	u_	Li.				u_	<br>
c	c	c	rz	c	c	u_	u_	Li.	c	LL<br>
o	o	o	o	o	o	3	=1	C	o	3<br>
r-	r-	r*-	I"-	t"-.	r-	O	o	o	o	O<br>
^=r	■<t t></t>
to	in	m	m	ID	10	CO	CO	lO	in	CD<br>
o	o	o	o	o	o	o	o	o	o	O<br>
to	CO	CO	oo	00	CO	CN	CM	ao	CO	CN<br>
o	o	o	o	o	o			o	o	<br><br><br>
O	n	o	n<br>
4-1	-i-»	-*-»	*J<br>
UJ	f/&gt;	tn	to<br>
(/&gt;	r/&gt;	w	to<br>
m	CI)	ai	fli<br>
OH	OH	o:	a:<br>
	^	V	V<br>
O)	o	CO	CD<br>
id	N-	CM	co<br>
CO	-*		m<br>
lO	lO	in	LO<br>
O	C3	o	o<br>
CO	CO	CO	GO<br>
o	o	o	o<br><br><br>
o	o	o	o	o	o	o	o	o	O	3	o	o<br>
-4~f		«•—1	•*—»	4-&gt;	4—1	■4-1	J-*	
co	"en	co	CO	co	CO	CO	CO	to	co	"to	co	to<br>
'to	'ca	"«	tn	~«J	ta	"to	'to	to	"to	'ca	"«	"to<br>
CD	CD	CD	CD	CD	CD	CD	CD	CD	CD	CD	CD	0)<br>
ca	OH	a:	CH	D:	OH	OH	ce	cc	a:	a	OH	a:<br>
it:					i£					:*;		<br>
cO	i^	it;	^		o					o		;*:<br>
CO	o	o	o	DC	o	OH	a:	OH	CE	o	^	o<br>
CO	T—	T—	T—	o	*~	o	o	o	o	,—	T_	,—<br>
lO	lO	lO	lO	lO	lO	lO	lO	m	lO	lO	LO	to<br>
o	o	o	o	o	o	o	o	CD	o	o	o	o<br>
CO	CO	CO	CO	CO	CO	CO	CO	CO	CO	CO	CO	CO<br>
o	o	o	o	o	o	o	o	O	o	o	o	o<br><br>
c?	1<br>
&gt;	a&gt;	co<br>
CO	CD	V<br>
co	a:	x<br><br><br><br>
TTlOCOr-OOOlOT-CNCO'a-<br>
ooooooooooo<br><br>
■*-    CN    oo    -*r<br>
OH   OH   OH   OH<br><br>
oi-CMco-tj-mcor-mcor--cocnT-T-T-T-T-T-T-T-DHOHOHDHOHOHOHOHOHOHOHCHCH<br><br>
CO<br><br>
ca<br>
Q. J<br>
X<br>
CM CO<br><br>
ke 74LVC1G32<br>
B1 Display<br>
FDN306P<br>
FPC2010<br>
HMS39C70<br>
92<br>
LTC1998<br>
LTC4054L4.<br>
2<br>
LTC4412<br>
Mem S1<br>
S2<br>
S3<br>
SW1<br>
ZHCS750 IC1<br><br>
2-Input or gate<br>
terminals for the battery<br>
display 7 segment, 8<br>
cifre<br>
Mosfet<br>
Finger print controller<br>
CPU ARM7<br>
core<br>
battery monitor<br>
battery charger<br>
power<br>
controller<br>
RAM<br>
connector to program the<br>
CPU<br>
connector to connect an external<br>
power<br>
connector to connect the swipe sensor,<br>
is not present on the diagram<br>
contact to turn on the<br>
card<br>
Schottky diode<br>
display driver<br><br>
A memory chip module 18 is included in the circuit for storing the data related to the finger print as recorded by the finger print sensor 12. In the presently preferred embodiment of the present invention, a controller 20, specifically FPC 2010 for controlling the finger print sensor 12, in the presently preferred embodiment of the present invention constituted by a sensor from the company named finger print cards. The controller 20 is the only unit or module connected to the sensor 12.<br><br>
A processor 22 is also located on the card 10 for communicating with the controller 20. In the presently preferred embodiment of the present invention, the processor 22 is a processor including an ARM7 processor core supplied from the company HYNIX, with the part named HMS39C7092. The processor includes 92-kb flash memory.<br>
An algorithm for calculating a secure and anonymous Pin code has been implemented and delivered to the processor 22. In the present context, the processor is construed to be a generic term covering everything from the smallest micro controller and up,<br>
The finger print sensor 12 is of the swipe sensor type chosen due to its compactness, low cost and power down ability, the sensor has a resolution of 152 X 32 pixels defining an active area of 10,64 X 2,24 mm with a resolution of 363 DPI. Each pixel having a resolution of 8 bits. The power consumption of the swipe sensor in the active state is approximately 45 mA and in the non-active state approximately 5uA.<br>
The display 14 includes an indication area for indicating the remaining battery capacity, as known from e.g. cellular or mobile phones. The display 14 may display a warning when the battery voltage drops below a specific level indicating that the battery needs to be recharged. In case the battery is not recharged within a specific time limit and the card 10 is not turned off, the card 10 will be powered down by the processor 22. The card is placed in an adapter for recharging the battery. The adapter may be constructed so as to be able to plug in to AC mains in any country, i.e. the adapter may be plugged into a 110 V AC 60 Hz or 230 V AC 50 Hz AC mains. The battery may be recharged by the mains supply. Alternatively the battery may be recharged by kinetic energy, for instance when the individual carrying the smart card 10 walks, kinetic energy may be converted to electrical energy used for recharging the battery. Further alternatively the smart card 10 may include solar cells for converting solar energy to electrical energy for recharging the battery.<br><br>
The battery may be of a lithium iron polymer for enabling recharging of the battery while minimising the memory effect of the battery. In the presently preferred embodiment of the present invention, the battery has a capacity of approximately 80-100 mAH.<br>
An individual using the smart card 10 according to the present invention may use the PIN-code generated on the smart card 10 for gaining access to secure systems, such as financial transactions or secure areas, provided of cause the individual is properly authorised.<br>
A software implementation of an algorithm for calculating a code comprising numbers is included in the internal memory of the processor 22 in accordance with the present invention. The algorithm calculates a valid code based on three number series, one provided by a random number generator in the processor 22 on the smart card, one generated by an external computer and one chosen by the company insuring the card or determined by e.g. an account number, a social security number, or any other specific individual identifying integer or number. Generally, the algorithm is based on at least two constants and one variable.<br>
The aigorithm calculates a PIN-code based on the two constant and one variable for the external system to correctly identify the individual and grant access.<br>
In use, the individual owning the card 10, and having initialised the card with his or her fingerprint, powers up the card, either by activating a switch or simply by touching the fingerprint sensor 12. The smart card then requires the individual to provide a fingerprint to the fingerprint sensor 12. The controller 20 then compares the newly sensed fingerprint with the fingerprint stored in the memory 18.<br>
Provided the comparison results in a match, a valid PIN-code is calculated and<br>
provided to the individual, preferably by displaying the PIN-code on or in the display 14.<br><br>
Provided the comparison does not result in a match, an error message is displayed in the display 14. The software provided in the smart card may include a limitation of how many times an individual may attempt to obtain a valid PIN-code without providing a valid fingerprint.<br>
The smart card 10 according to the present invention is no limited to being able to generate PIN-codes for a single system. Each smart card 10 may be used for granting access to any number of systems. An individual may use the smart card 10 for gaining access to e.g. a private online banking system and an IT-system at work. A selection may be possible, e.g. via at least one key, for selecting a specific system to generate a PIN-code for.<br>
In the presently preferred embodiment of the present invention the display 14 may display up to 8 characters in one row and may include background light for enabling the smart card 10 to be used in low-light conditions.<br>
Embodiments wherein PIN-codes having a variable length or a length different from 8 characters may be envisioned, and is considered a part of the present invention.<br>
As the fingerprint is not transmitted from the card, or read in a device separate from the card, the actual identity of the individual is therefor not compromised.<br>
The card 10 may include a module for transmitting the generated PIN-code. The module may be constituted by a wireless module, alternatively a module for wire<br>
connection to an external system.<br>
The algorithm comprises a number of mathematical functions combined with bit manipulation, e.g. number reflection, for combining specific sequences of codes used individually and in a specific order. The smart card according to the present invention may be used with two types of bit manipulation, the first being time dependent and the other being constant, both methods having a high security.<br><br>
The software application implemented according to the present invention is built up around three independent databases.<br>
The first database designated A comprises information relating to persons to each of the smart cards operated by the vendor or company. The records in the database A are designated accounts.<br>
The second database designated B comprises data relating to the individual cards such as the last used code as well as the two constants determined at the initialisation process. The database further comprises codes for security level, e.g. how many codes to accept before the card is perceived as out of synchronisation. The database is refreshed at each approved access by the user.<br>
The third database designated C comprises the sequence of codes to be approved at plug-in. The sequence of codes reduces in case of failing to authenticate the user. In case the number of available codes are reduced to zero, the card and the server is brought out of synchronisation meaning that the smart card will be blocked and a resynchronisation process is required.<br>
Dividing this information into three databases provides a high level of security at the administration, enabling more than one individual to administrate the system, each individual having different rights for the individual databases. Also, the personal information may be excluded thereby providing anonymous access to systems where it is appropriate that the individual may not be identified, e.g. medical journals for research.<br>
There is no need for the card and the authentication system to be in physical contact since the card includes a power source constituted by a battery, and comprises the same algorithm as the server for calculating the sequence of codes provided that the card and the server does not loose synchronisation due to e.g. too many erroneous log ins. Currently, credit cards and debit cards only allow three erroneous Pin codes before the card is blocked, however, in case the biometric smart card according to the present invention, the number of erroneous codes<br><br>
supplied by the user may be higher due to the added security of the biometric sensor included in the card.<br>
In Annex 1, the software used for operating the prototype embodiment described above with reference to Figs. 1-6 and described in the above example is listed.<br>
Fig. 7 illustrates the communication between a smart card and an authentication server 100 and an application server 102. Before the card is used for the first time, the card must be initialised by a sequence as described previously. The authentication server 100 sends a first random number and one constant to the card 10 illustrated by the error 104, The transfer of the first random number and the one constant may be performed using a smart card interface, a USB interface, a wireless interface, such as blue tooth, IR or RF, the mentioned communication methods may be substituted by other methods of communication as is obvious to a person skilled in the art.<br>
Fig. 8 illustrates the initialisation and synchronisation of a card 10 with the authentication server 100. The illustration is divided in two fields, one grey and one white. The lower white field illustrates the initialisation that may only be performed once for each card. The upper grey field illustrates the synchronisation performed repeatedly with each card.<br>
When initialising the authentication server 100 indicated by the error A, at least one constant is provided to the authentication server, e.g. an account number, area number or other identification number. The information is supplied by the application server that may be the propriety of a bank, passport control or other public authority.<br>
The initialisation process is started and information regarding a specific card is established in the authentication server at the point B in Fig. 8.<br>
The card is placed in a smart card reader and using the smart card interface receives the constant from the application server along with a randomised number from the authentication server. The card generates the third number required for<br><br>
calculating the codes or tokens. In the presently preferred embodiment, the third number is a randomised number, however, the number may also be extracted from the finger print sensor. Having the three required numbers, where at least one may be a variable, the sequence of tokens or codes may be calculated. The sequence of tokens or codes will be specific for each card, After the initialisation process, the card will be locked meaning that it will no longer be possible to perform right operations to the internal memory.<br>
The authentication server must be provided with a token or code from the card for calculating the sequence of tokens or codes that the card will supply. It is possible to pre-initialise a larger number of cards without randomisation, preferably used in situations where a lower level of security is sufficient.<br>
In the box designated D during the initialisation, the finger print sensor must recognise the fingerprint three times, whereafter the software will load the fingerprint into the internal memory. This will lock the internal memory as described above. Due to security considerations, the authentication server may not activate the account relating to the card before the card has been synchronised, This process is ensured as the third number that may be a variable is transferred from the card to the authentication server at the initial synchronisation.<br>
When the finger print sensor is activated and the authenticity of the finger print supplied to the finger print sensor has been approved, the algorithm generates the next token in the sequence based on the previous token or code stored in the cards memory.<br>
The card may be provided with a variety of output media for outputting the tokens or codes. In the presently preferred embodiment a display Is used for displaying the Pin codes or tokens to the user, however, embodiments involving sound, radio signals or light may be included on the card. Whatever the output means may be, none of the information outputted from the card relates directly to the biometric characteristics but to a code or token, which is further altered dynamically thereby providing anonymity to the user owning the card.<br><br>
For the card to access the application server, the card needs to be synchronised with the authentication server. This is performed in each instance after a procedure adapted for the card suppliers security needs. The server algorithm is identical to the algorithm implemented on the card. The server is provided with a token or code from the card, which is then used as the first step in the calculation of the sequence of codes or tokens produced also by the card.<br>
Provided the token or code supplied from the card is validated by the authentication server, a hand shake is supplied from the authentication server to the application server and the card owner or the card is then logged in.<br>
If the card and the authentication server is brought out of synchronisation, e.g. by supplying more than ten erroneous codes or tokens, the procedure of transferring the next token from the card to the authentication is repeated. Since both the card and the authentication server have the same sequence of codes or tokens, the authentication server may be supplied with a token from the card and then be able to calculate where in the sequence the card is. Subsequently, the authentication server will be in synchronisation with the card.<br>
In the presently preferred embodiment of the present invention, the preferred method of using the card is to hold a respective thumb and index finger on each side of the card where the thumb is placed over a marked side, then pulling the card with the opposite hand so that the pressure and placement of the finger onto the sensor is substantially identical each time, also the speed of the finger being moved across the swipe sensor is substantially identical each time. Provided an array sensor is used, a marking or guidelines will be sufficient.<br>
The algorithm for calculating the Pin codes or tokens is as follows:<br>
1:	for (my $i=0;$i
2:	$g=0;$v=100000000000; $d=0;<br>
3:	$x=($a*$x)+$c;<br>
4:	while($x&gt;=1000){$d=$x-(10*floor($x/10));<br><br>
5: if($x
6: $g=(10*$g)+$d;$v=$v/10;<br>
7: }$x=($x-$d)/10;<br>
8: }$x=$g;<br>
9: }<br>
The algorithm is also included in the annex 1, vide page 46 of the annex 1,<br>
The variable $ sekvens designates the number of tokens calculated by the server. The variable $a designates a constant, such as a bank account or birthday. $b designates a randomly chosen constant. The algorithm implemented on the card is similar to the one implemented on the server, however, the variable $sekvens is limited to the value 1, meaning that only one Pin code is calculated one at a time.<br>
For improving the security of the sequence of the algorithm, permutation on the variable $d may be applied, meaning the after calculating a sequence of codes, a random or psedo-random choosing of a new order of codes may be performed. If a third person then obtains knowlegde of the sequence of codes this knowledge is still useless unless the permutation of the variable $d is also known,<br>
At each use of the card 10, a code is supplied to the authentication server 100 Illustrated by the arrow 106. The authentication server and the application server 102 are constantly in communication illustrated by the double arrow 108.<br>
The card 10 may be used in a variety of situations, not only in situations requiring high level of security. The procedure of synchronisation is a part of the security of the card and also provides flexibility in the level of security. If a high level of security is required, the resynchronisation may be monitored, e.g. by requiring the user to personally appear before a security administrator and use the card for supplying a new code manually entered by a third person to the authentication server, in cases where a lower fevel of security is accepted, the resynchronisation may be performed using a telephone or the Internet.<br><br>
In the presently preferred embodiment of the present invention, the smart card 10 includes an ARM 7TDMI32 bit RISC processor for performing the calculations according to the algorithm as described earlier. Also memory is included on the card, either of flash type or EEPROM, RAM or ROM type memory. The display included on the card 10 is 7 segment, 8 digits display having the dimension 35mm x 15mm.<br>
The finger print sensor is a capacitive swipe sensor having ESD protection of &gt; 15 kV. The battery is a lithium iron polymer rechargeable battery with a capacity of 10-100 mAH also including a battery recharging circuit.<br>
The card must, in the presently preferred embodiment of the present invention comply with the International Standard Organisation's standard ISO 7810/7816/10536/14443.<br>
The card may include RF communication means for communicating with an external system.<br>
The micro controller may include an operating system COS, which may be LINUX or JAVA based. Having an operating system allows for software applications to be developed independent of the hardware platform. New software applications may be developed and downloaded to the card's memory using the smart card reader/writer or other data transferring medium.<br>
The card may include an on/off function for being connected with the swipe sensor such that activating the sensor by applying e.g. a finger to the sensor activates the processor. The sensor may measure heat or electrical conductance from the finger. The second time a finger touches the sensor, the finger print sensor will sense the finger print from the individual. This will ensure that the card is not activated when stored in e.g. a wallet. Also, anybody can activate the card, but only the rightful owner may have his or her finger print recognised and thereby accessing the Pin codes on the card.<br><br>
The card may power down after a specific period of time such as 30 seconds after the last active operation.<br>
The display may display other than numerals, e.g. the display may be of a type capable of displaying images, such as black and white images or colour images enabling the user to display photographs, such as those found in passports. The display may further be pressure sensitive enabling the user to interact with e.g. a menu system for configurating the card. In the presently preferred embodiment of the present invention, the display uses 3.3 V and is turned off 30 seconds after the last operation.<br>
In the presently preferred embodiment of the present invention, two batteries from the company Worliy Energy Cells, each having a capacity of 45 mAmpH giving a total capacity of 90 mAmpH. These batteries are rechargeable and have a dimension of 43mm x 40mm x 1 mm. Studies have shown that several hundred Pin codes or tokens may be generated on a single charging of the batteries. In order to supply the components with a current of 3.3 V, a voltage regulator for regulating the battery current of 3.7 V down to 3.3 V with a maximum current capacity of 500 mAmp.<br>
A sliding switch for powering up or turning off the card may be included on the card. The switch may substitute the finger print sensor sensing a contact with a finger for powering up the card.<br>
A central server authenticates the Pin code as provided by the smart card and inputted by a user or individual owning the smart card. The server and the smart card both comprise an algorithm for generating a sequence of random numbers based on the two constants for calculating these sequences. When the card is initialised the two constants and the one variable are loaded or read into the memory on the smart card and also stored on the server. The issuer of the card may choose one of the two constants, e.g. the constant may be an account number or other personal identification, while the other constant and the one variable are generated by randomisers present in the server and the smart card, respectively.<br><br>
Obviously, the number of constants and variables used in the dynamic binary code conversion algorithm may be altered for providing a unique dynamic binary code conversion algorithm. Examples of alternative dynamic binary code conversion algorithms are listed below.<br>
One constant is formed by the server and the other is formed by the smart card. The constants are read into the respective other device for allowing each of the systems to obtain the two constants. The step of exchanging the random numbers generated in the smart card and server, respectively, is a way of the server to initialise the smart card and for the smart card to initialise the server.<br>
The server may accept only a limited number of Pin codes, such as 10 meaning that the next 10 codes generated in the smart card may be used as Pin codes for logging in or validating the identity of the user in the system. When the smart card is activated and the identity of the user has been established by using the built in biometric sensor, a Pin code is generated and displayed on the display 14. The number of available Pin codes is decremented one meaning that nine remaining codes may be used for logging in. When using a Pin code for logging in, the server resets and accepts the next 10 Pin codes in the sequence.<br>
However, if 10 Pin codes are generated without using any for logging into the system, the smart card and the server will loose the synchronisation and the eleventh generated Pin code will be refused by the server.<br>
For re-establishing the synchronisation, the owner of the smart card may contact a system administrator or other authority and provide the next generated Pin code for bringing the server up to the point in the sequence of Pin codes. This establishes a synchronisation between the server and the smart card. Since only the rightful owner of the smart card may generate a valid Pin code, the synchronisation will only be possible by the owner himself or herself. As the smart card comprises a processor and internal memory, the smart card may include severs! constants and/or algorithms for different and independent systems, e.g. the card may be used<br><br>
by an employee in a company for gaining access to the company or the company's internal IT system as well as the employee's personal bank account. The employee or owner of the card may be able to choose which system to generate a valid Pin code for either via the display or other selection means such as buttons included on the surface of the smart card.<br>
The card in a further preferred embodiment has a thickness of approximately 1 mm and may be bent requiring the biometric sensor to be placed as close to the edge of the card as possible in order to avoid braking the sensor. The stiffness of the card near the edge provides stability to the sensor.<br>
All biometric sensors require a certain amount of sensitivity and the signals to be similar to the previously supplied signals. By supplying the card with a graphical indication of where the finger should be placed on the finger print sensor ensures that the user may perform a movement of the finger substantially identical each time the card is used.<br>
The above described presently preferred embodiment of the apparatus according to the present invention was implemented as a prototype having the outer dimensions of an ISO standard credit card, however, having a total thickness of approximately 4mm - 5mm. It is contemplated that the thickness of the prototype embodiment may be reduced to no more than 1mm as will be described below and at the same time, the credit card be configurated as a flexible and bendable credit card which is not subjected to being deteriorated by e.g. bending in a wallet or the pocket of the individual carrying the credit card or smart card apparatus.<br>
Since the card is suppose to be in a wallet, the next generation of the Pin code generator card is going to include 2 major demands.<br>
•	The card must not be a stiff card, it must be able to be bent, so much that the user is not going to break the card, when it is in the users wallet.<br>
•	Secondly the card must not exceed the thickness of 1 mm.<br><br>
To fulfil those demands, the technique that was used in the prototype can not be used.<br>
In the prototype Pin code card standard components were used, such as a common glass display, standard battery, and other common standard electrical components.<br>
Display<br>
The display is to be a rather large component on the card, and will probably, be over the middle of the card, which means that when the card is being bended the display is also being bended.<br>
The Display could have any size, and any number of digits.<br>
There a several technologies, that is using what is known as, flex and plastic display. The essence of those displays is, that they are looking like a piece of thin plastic, and are very thin, down to 0.3mm, and are very flexible, meaning that they can be bent, without being broken.<br>
Electronic<br>
The problems using standard components on the card are:<br>
•	The components can not be bent.<br>
•	They are very thick, since they are in a house of black plastic.<br>
•	The security is very low, since the fingerprint controller and microcontroller is in 2 different components. It is possible to strip the card, and hacked it.<br>
•	Many components - high cost<br>
The way to eliminate these problems is to make an ASIC (Application Specific<br>
Integrated Circuit).<br>
An ASIC is a user specific component that can be digital, analog or a mix.<br>
The biometric sensor (fingerprint sensor) generates an analog signal, when the user swipes his/her finger. Preferably, the ASIC includes as a front end and ND connector.<br><br>
Furthermore, the ASIC showed include the Controller, the micro processor, the Memory and the display driver.<br>
The advantage of an ASIC is that the security level is very high since its. it is not possible to break into the circuit.<br>
Furthermore the physical size of such an ASIC is about 4*4 mm as a naked die. Since it is made out of silicium it can not be bent, so the ASIC will be placed in one of the sides of the card. The power use of an ASIC instead of the 4 standard components is also an important factor. The ASIC, depending on what process it is madein{e.g HYNIX0.18u), uses much less power.<br>
The power supply circuit can be made as an analog chip, or together with the ASIC.<br>
The thickness of the ASIC is very small and below 1 mm (as a naked die), however, it is the wafer that decides the thickness of the ASIC, but if that is too thick, it is possible to back grind the ASIC, since the functionality of the ASIC is made with some mask, that is only a few micron thick.<br>
Other electrically components<br>
On the card there will be an X-tall and perhaps also addition components such as capacitors and/or resistors.<br>
Fingerprint sensor<br>
It is made out of silicium that can not be bent, so the sensor must also be placed at the one side of the card and preferably at the edge thereof. Like the ASIC it is also possible to back grind the sensor, if it's to thick.<br>
Battery<br>
The thickness may be from 0.2mm but of course the capacity of the battery depends on the size and thickness of the battery.<br>
Flexprint<br><br>
In order to connect the different parts electrically a flexprint technology is preferably used.<br>
Alternatively, wire bonding may be used for connecting teh pad on the ASIC to<br>
another pad.<br>
Encapsulate<br>
To make the card nice and protect the electronic parts it needs to be encapsulated.<br>
Sensor Types<br>
Relevant sensor types are:<br>
■	Swipe sensor - The user must swipe a finger over the sensor<br>
that scans the user's fingerprint.<br>
■	Area sensor - The user plants the finger in the sensor array area,<br>
which then scans the fingerprint or entire finger.<br>
■	Iris sensor - The user looks in an eye sensor that then scans the<br>
user's iris.<br>
■	Blood sensor-The characteristics of the user's blood is<br>
scanned.<br>
■	DNA scanner - The DNA of the user is scanned.<br>
■	Microphone - The characteristics of the user's voice is scanned.<br>
■	Air - The characteristics of the user's breath is scanned or a<br>
certain smell Is detected..<br>
■	Keyboard - The user types in the password on the card.<br>
Types of Power Sources<br>
Relevant power sources are:<br><br>
■	Battery<br>
■	Capacity<br>
Types of Charger<br>
For recharging the power source in order to make the card work for a longer period. The following types of rechargers may be used:<br>
■	Charger - Connect the charger to the connectors on the card (e.g.<br>
Smart Card connectors); the implication of this is that the user of the Sensor Card must have a charger as well<br>
■	Solar Cell - A Solar Cell could be on the card to recharge the power<br>
source or may be the power source itself.<br>
■	Wireless - E.g. capacity or induction coupling.<br>
■	Kinetic energy - When the user walks with the card, those vibrations<br>
will recharge the power device.<br>
Types of Storing Devices<br>
Relevant storing devices are:<br>
■	Flash - The program is burned into flash memory.<br>
■	EEPROM - is another technology that can contain storing data.<br>
■	OTP - One Time Programmable memory. » ROM - Read Only Memory.<br>
In the future other types of memories might be used:<br>
■	Blologicaf memory.<br>
■	Chemical memory.<br>
&gt; Optical memory.<br><br>
Types of Application<br>
■	Key generator - provides the user with a unique password to e.g. a<br>
database or a restricted area. The output key is e.g. listed on a<br>
display.<br>
■	Health care - The sensor card measures the user's health, and if there<br>
is a problem, it shows e.g. the telephone number of the doctor.<br>
■	Personal data - all personal data e.g. date of birth, social security<br>
number etc. could be viewed on the display.<br>
Types of Outputs<br>
■	Wire plug in. - Plug in a wire, to receive the output data.<br>
■	Wireless using radio frequencies (e.g. Blue Tooth) - The card can communicate wireless with e.g. an external computer.<br>
■	Loudspeaker (sound) - The card sends out an audio signal (e.g.<br>
human speech), that the third part user may receive (hear).<br>
■	Light (infrared, Higher-lower freq.) - E.g. communication via a Iaseror<br>
IrDA.<br>
■	Holographic - The card makes a hologram.<br>
■	Smart Card connectors - A Smart Card reader receives the output<br>
data.<br>
■	Display - the data is shown.on a display.<br>
Thickness of the sensor card<br>
Multiple sensors<br>
It is possible to have more then one sensor on the card, it could for example be 3 sensors, 2 finger sensor and a voice sensor, that verify the identity of the person.<br><br>
A second sensor could also be a sensor to detect the sunlight, air pollution, rain, temperature and so on.<br>
The sensor card could also be used as a combination of the Pin code generator and<br>
a sensor card.<br><br>
ANNEX 1<br>
UTILITY.H<br>
I* Miscellaneous library functions */<br>
#ifndef_UTILITY_H #define_UTILITY_H<br>
extern void delay{int);<br>
extern void message(char * s);<br>
extern unsigned int battery_check(void);<br>
#endif<br>
UART.H<br>
I** ******** ****lrtr********* *************************************************** **<br>
**	**<br>
** Copyright (c) 2000 ARM Limited<br>
** All rights reserved	**<br>
•*	**<br>
******************************************************************** **********/<br>
/**** i*************************************************************************<br>
*	*<br>
*	The following are for the Integrator UART system. These are bits to enable *<br>
*	the functions in the Command Registers 'and the individual masks for the    *<br>
*	returned Status registers	*<br>
*	Register Bits - these require to be set to enable the defined functions    *<br>
******************************************************************************<br><br>
#ifndef_UARTDEF #define __UARTDEF<br>
^******************************************** ***** *************** ************* /<br>
I* UART Structure maps to register offsets	7<br>
!* Structure is instantiated in UART.c and placed by scatter file	V<br>
/*** *********************************************************************** tt*i<br>
struct uart<br>
{volatile unsigned dr;  // @0x0<br>
volatile unsigned ecr; // @0x4<br>
volatile unsigned Icrh; // @0x8<br>
volatile unsigned Icmv, // @0xOc<br>
volatile unsigned Icrl; // @0x10<br>
volatile unsigned cr;  // @0x14<br>
volatile unsigned fr;  //@0x18<br>
volatile unsigned iir; //@0x1C<br>
};<br>
;*** ***************** ************************************************* *********/<br>
r Received Status Register - RSR	V<br>
i************* ***************************•*****#********************** ********/<br>
#define RSR_Overrun_Error  0x08 #deffne RSR_Break_Error    0x04 #define RSR_Parity_Error   0x02<br>
#define RSR_Framing_Error 0x01<br>
i**« ************************************************************ **************/<br>
/* Line Control High Byte Register - LCRH	*/<br>
J*****************************************************************************/<br>
#define LCRHJVord_Length_6 0x60<br>
#define LCRH_Word J.ength_7 0x40 #define LCRH_Word_Length_6 0x20<br><br>
#define LCRH_Word_Length_5 0x00 #define LCRH_Fifo_Enabled 0x10 #defme LCRH_2_Stop_B'rts 0x08 #define LCRH_Even_Parity 0x04 #define LCRHJ&gt;arity_Enable 0x02 #define LCRH_Send_Break    0x01<br>
;******************** ********* **************************************** ******** i<br>
/* Line Control Medium Byte Register - LCRM	*}<br>
I* This register specifies the high byte of the Baud rate divisor	V<br>
If ************************************ t ******************************* t******* ;<br>
tfdeftne LCRM_Baud_460&amp;00 0x00 #define LCRM__Baud_230400 0x00 #define LCRM__Baud_115200 0x00 #deftne LCRM_Baud_76800 0x00 #define LCRM_Baud_57600  0x00 #define LCRM_Baud_38400  0x00 #defineLCRM__Baud_19200  0x00 define LCRM_Baud_14400  0x00 #define LCRM__Baud_9600   0x00 #define LCRM__Baud_2400   0x01 #define LCRM__Baud_1200    0x02<br>
;****** *********************************************************************** /<br>
/* Line Control Low Byte Register - LCRL	7<br>
/* This register specifies the low byte of the Baud rate divisor	*/<br>
/*****************************************************************************/<br>
#defineLCRL__Baud_460800 OxOT	■   -	-   -■<br>
#define LCRL_Baud_230400 0x03<br>
#defina LCRL_BaudJ15200 0x07<br>
#define LCRL_Baud_76800   OxOB<br>
#define LCRL_Baud_57600   OxOF<br>
#defme LCRL_Baud_38400  0x17<br><br>
#deflr»LCRL_Baud_1B200   Ox2F #defineLCRL_Baud_14400   0x3F #define LCRL_Baud_9600   0x5F #define LCRL_Baud_2400   0x7F #define LCRL_BaucM200    OxFF<br>
J******************************************************************* *********•/<br>
/* Control Register - CR	V<br>
it******************* ************************************************* ********!<br>
#define CR_Loop_Back_En 0x80 #define CR_TimeoutJnt_En 0x40 #define CR_TXJnt_Enable 0x20 #define CR_RX_lnt_,Enable 0x10 #define CR_ModStatJnt_En 0x08 #define CR_UART_Enable   0x01<br>
&gt;******************** ***** ************************************************** **1<br>
r Flag Register -FR	7<br>
J*****************************************************************************/<br>
#define FR_TX_Fifo_Empty 0x80<br>
#define FR_RXJ=ifoJ=ull  0x40<br>
#define FR_TX_Fifo_Fu!l   0x20<br>
#define FR_RX_Fifo_Empty 0x10<br>
#define FR_Busy	0x08<br>
#define FR_Carrier_Detect 0x04 #define FR_Set_Ready 0x02 #define FR_Clear_To_Send 0x01<br>
J*************************************************************************/<br>
/'Interrupt Identification Register - HR	*/<br>
i************************************************************************ */<br>
#define IIR_RX_Time_Out   0x08<br>
#definellRTX	0x04<br><br>
#define IIR_RX	0x02<br>
#defins IlRJtodem        0x01<br>
#endif<br>
TYPEDEFS.H<br>
#ifndef_DELTATYPEDEFS_H #deflne _DELTATYPEDEFS„H<br>
r<br>
' FPC2010 type definitions<br>
7<br>
typedef unsigned char u_char; typedef unsigned char bool; typedef unsigned char * addrB;<br>
#endif r    DELTATYPEDEFS    H '/<br>
T1MER.H<br>
/* Timer library functions V<br>
#tfndef_TIMER_H #define_TIMER_H<br>
define START_TIMERO *TSTARTR = *TSTARTR | TIMERO_MASK; // Start timer 0 ■ -#define STOPJ1MERQ "TSTARTR = *TSTARTR &amp; ~T!MERO_MASK; // Stop timer 0<br>
extern void timerQ_init(void);<br>
#endif<br><br>
RANDOM.H<br>
/* Random library functions 7<br>
#imdef_RANDOM_H #defme _RANDOM_H<br>
// token<br>
#define tempa 9102    // Offentlig nogle 1<br>
#define tempo 12345678 // Offentlig negle 2<br>
extern double token(double x);<br>
I* linear congruential generator. Generator x[n+1] = a * x[n] mod m V<br>
#define RAND_INT(l,h) (((int}(random() * ((double)(h)-(l)+1))) + (I)) extern double random (void); extern void rand^seed (unsigned int); #endif<br>
PORT.H<br>
I* Display library functions */<br>
#ifndef_PORT_H<br>
#define_PORr.H       	<br>
extern void portjnit(void); #endlf<br><br>
FPC2010REGISTERS.H<br><br>
//	<br>
//     Copyright (C) 2003 Fingerprint Cards AB. Ait Rights Reserved<br>
//.	<br>
//<br>
// The information contained herein is confidential property of<br>
// Fingerprint Cards AB. The use, copying, transfer or disclosure of such<br>
// information is prohibited exceptby express written agreement with<br>
// Fingerprint Cards AB.<br>
//<br>
//.	<br>
// File: fpc2010registers.h<br>
//<br>
// Description:	These registers are the software interface to the FPC2010<br>
// hardware.<br>
//<br>
// Hardware platform: FPC6430<br>
//<br>
//	<br>
#ifndef_FPC2010REGISTERS__H #define _FPC2010REGISTERS__H<br>
r*<br>
* interrupt/Reset interface registers<br>
((volatile addr8)FPC_BASE)<br>
((volatile addr8)(FPC_BASE +1))<br>
((volatile addr8)(FPC_BASE + 3))<br>
V<br>
#defirie InterruptMask #define Interrupt #define SwReset<br>
r<br>
* Sensor interface registers<br><br>
*/<br><br>
#define SensorCommand #define SensorParameter. #define SensorParameter_ #define WaitCycles #define StartCycles #define CloseCycles #define SensorReset #define FingerDetect #define ClockDevisor<br><br>
{(volatile addr8)(FPC_BASE + 33))<br>
LSB	{{volatile addr8)(FPC_BASE + 34))<br>
MSB	((volatile addr8)(FPC_BASE + 35))<br>
({volatile addr8)(FPC_BASE + 36))<br>
((volatile addr8)(FPC_BASE + 37))<br>
{(volatile addr8)(FPC_BASE + 38))<br>
((volatile addr8)(FPC_BASE + 39))<br>
((volatile addr8)(FPC_BASE + 41))<br>
((volatile addr8)(FPC_BASE + 42))<br><br><br><br>
r<br>
* Work RAM interface registers<br>
#define WorkRAMAddrPointer #define WorkRAMWriteData #define WorkRAMReadData<br><br>
((volatile addr8)(FPC_BASE + 64)) ((volatile addr8)(FPC_BASE + 65)) ((volatile addr8)(FPC_BASE + 66))<br><br>
r<br>
* Verification result RAM interace registers<br>
V<br>
#define VerResuItAddrPointer	((volatile addr8)(FPC_BASE + 67))<br>
#define VerResuKWriteData	{{volatile addr8)(FPC_BASE + 68))<br>
#define VerResultReadData .	{(volatile addr8)(FPC_BASE + 69))<br><br>
* FPRAM control registers<br>
*/<br>
#define FP_RAM_Cmd #define FP_RAM_Range #define FP_RAM_Read #define FP RAM Write<br><br>
((volatile addr8)(FPC_BASE +128)) ((volatile addr8)(FPC_BASE +130)) {(volatile addr8)(FPC_BASE +131)) ((volatile addr8)(FPC_BASE +132))<br><br>
/'<br><br>
* Parameter file registers<br>
*;<br>
#define ParameterFilePointer #define ParameterFileWrite #define ParameterFileRead<br><br>
((volatile addr8)(FPC_BASE + 192)) ((volatile addr8)(FPC_BASE + 193)) ((volatile addr8)(FPC_BASE + 195))<br><br><br><br>
r<br>
* Algorithm Calculating Hardware (ACH) registers V<br>
#define ACHCmd #define AccLlneOffset #define AccPointOffset #deflne TopLineLSB #define TopLineMSB<br><br>
((volatile addr8)(FPC_BASE + 196)) ((volatile addr8)(FPC_BASE + 199)) ((volatile addr8)(FPC_BASE + 200)) ((volatile addr8)(FPC_BASE + 201)) ((volatile addr8)(FPC_BASE + 202))<br><br>
r<br>
* Flags for the interrupt register<br>
V<br>
#define IRQ_SENSOR_FINGER_DETECT	(1«0)<br>
#definelRQ_FPRAM_DATA_AVA!LABLE	(1«1)<br>
#define IRQ_FPRAM_ERROR	(1«2)<br>
#define IRCLSENSOR_COMPLETE	(1«3)<br>
#define IRQ_MANUAL_CAPTURE        (1 «4)<br>
#define !RG_ACH_COMPLETE	(1«6)<br>
r<br>
* Sensor command register (ACHCmd)<br>
*/<br>
#define ACHCmd_ENROL	0x3B<br>
#define ACHCmd VERIFY	0x5B<br><br>
#define ACHCmd_ENROL_TEST	0x3F<br>
#define ACHCmd_VERIFY_TEST	Ox5F<br>
#define ACHCmd DELTA XY	0x5B<br>
r<br>
* Commands for the sensor command register (SensorCommand)<br><br>
7 #define READ_ALL_COL_BY_COL	(0x88)	<br>
#define WRITE_DETECT	(0x2E)	<br>
#define WRITE_DRIVE_C	(OxAE)	<br>
#define WRITE__ADC_REF		(0x6E)<br>
#define READJNT_REGS		(OxOA)<br>
r<br>
* Parameters for setting up the sensor.<br>
V<br>
#define WAIT_REG_VALUE	172<br>
#define START_CYCLE_VALUE	80<br>
#define CLOSE_CYCLE_VALUE	2<br>
#define CLOCK DEVISOR	0<br>
r<br>
* Values for the FP RAM register (FP_RAM_Cmd)<br>
V<br>
#define PREPARE_MEM_LOW_HALF   0x01 #define PREPARE_MEM_HIGH_HALF 0x02 #define WRITE__MEM_LOW_HALF    0x04 #define WRITEJCMJHIGHJHALF   0x08 #define READ_MEM_LOWJHALF     0x10 #define READ MEM HIGH HALF     0x20<br><br>
t<br>
*	Used as parameters to functions that deals with the FP_RAM in fpc2010. LOW_HALF means<br>
*	low memory half and HIGH_HALF means high memory half. 7<br>
#define LOW_HALF 0 #define HIGH_HALF 1<br>
/"<br>
*	Startup values for sensors registers.<br>
7<br>
#define DETECT_STARTUP_VAL 0xe8 //=0x17 on senson   07/4      //Startup value for the detect<br>
register.<br>
#defirte DRlVC_STARTUP_VAL 255 //Startup value for the drive register.<br>
#define ADCREF__STARTUP_VAL 192 //Startup value for the adcref register.<br>
r<br>
*	Definitions for memory area sizes and offsets.<br>
V<br>
#define NO_OFJ"OP_UNES_REMOVED       30 #define FPC2010_WORK_RAM_SIZE      2048 #define FPC2010_VER_RESULT_RAM_SIZE 1024<br>
/**<br>
* The size of a template<br>
7 #define TEMPLATE_SIZE 676<br>
#endif /*    FPC201OREGISTERS   H 7<br><br>
FPC2010INTERFACE.H<br>
//	<br>
//     Copyright (C) 2003 Fingerprint Cards AB. All Rights Reserved<br>
//	<br>
//<br>
// The information contained herein is confidential property of<br>
// Fingerprint Cards AB. The use, copying, transfer or disclosure of such<br>
// information is prohibited exceptby express written agreement with<br>
// Fingerprint Cards AB.<br>
//<br>
//.	<br>
// File: fpc2010interface.h<br>
//<br>
// Description:	interface driver for the FPC2010 ASIC.<br>
//<br>
// Hardware platform: FPC6430<br>
//<br>
//	<br>
#ifndef _FPC2010INTERFACE__H #define     FPC2010INTERFACE    H<br>
r<br>
* Functions */<br>
void UploadVerResultRAMContent{u_char 'buffer); void UploadEnrolResult(u_char *enrolResult); void DownloadVerData(u_char 'templateBuffer);<br><br>
void Clear! RQReg(void);<br>
void SetlRQMask(void);<br>
void SWResetfvoid);<br>
void SetUpLineSensorStartUp(int detect, int drive, int adcref);<br>
void SetUpLineSensor(void);<br>
void ResetLineSensor(void);<br>
void SetUpLineSensorDETECT(int value);<br>
void SetUpLineSensorDRiVC(int value);<br>
void SetUpLineSensorADCREF(lnt value);<br>
void PolllRQReg(unsigned charirq);<br>
#endif<br>
FPC2010BIOMAIN.H<br>
//	<br>
//     Copyright (C) 2003 Fingerprint Cards AB. All Rights Reserved<br>
//.	<br>
//<br>
II The information contained herein is confidential property of<br>
// Fingerprint Cards AB. The use, copying, transfer or disclosure of such<br>
// information is prohibited exceptby express written agreement with<br>
// Fingerprint Cards AB.<br>
//<br>
//	.	:	<br>
//File:fpc201D.h<br>
II	-<br>
// Description:	Biometric functions for the FPC2010 ASIC<br>
//<br>
// Hardware platform:<br>
//<br><br>
#tfndef	FPC2010	H<br>
#define_FPC2010_H<br>
r<br>
* Functions<br>
7<br>
voidfpc2010On(void); voidfpc2010Off(void); voidfpc2010ln!t{vold); bool fpc2010Enrol(u_char *templateBijffer); bool fpc2010Verify(u_char *templateBuffer); void fpc2010LoadParameterFile(unsigned char 'parameters);<br>
#endif/*FPC2010V<br>
ENCAPSULATED_ALG.H<br>
,/.	<br>
//     Copyright (C) 2003 Fingerprint Cards AB. All Rights Reserved<br>
//	<br>
//<br>
// The information contained herein is confidential property of<br>
// Fingerprint Cards AB. Trie use, copying, transfer or disclosure of such<br>
// information is prohibited exceptby express written agreement with<br>
// Fingerprint Cards AB.<br>
//   ■     ■        ■	■	- - -    ■   ■  -<br>
//	<br>
// File: encapsu1ated_alg.h<br>
//<br>
// Description:	Encapsulated algorithm interface.<br>
//<br><br>
// Hardware: Swipe sensor.<br>
//<br>
//.	<br>
#ifndef _FPC2010HOST_ALG_H #define    FPC2010HOST ALG    H<br>
#define PARAMETER_FILE_LENGTH 72 // Length of the fpc2010 parameters in bytes. II These defines are used as arguments to the function get_fpc2010parameters(). #define ENROL_PARAMETERS       0 // Get enrol parameters. #define VERIFY_PARAMETERS      1 // Get verify parameters.<br>
//Typedefs used for fpc2010host_alg<br>
typedef short int	XHostJnt16;<br>
typedef int	XHost_lnt32;<br>
typedef unsigned char      XHost_UChar8;<br>
typedef signed char	XHosLChar8;<br>
typedef unsigned char      XHost_Bool;<br>
XHosLBool Create_Template(XHost_UChar8 "InputArray, XHost_UChar8 *TemplateBuffer, XHost_UChar8 PointOffset, XHostJnt16  SwipeLength);<br>
XHost_Boo! Match_Data(XHost_UChar8 *VerResultArray, XHost_UChar8 TemplateBuffer, XHost_lnt16  PointOffset,<br>
XHost_lnt16  SwipeLength);<br>
XHost_Bool PreVerify(XHost_UChar8 *template__buffer, XHost_UChar8 *FPC2010_ver_data);<br><br>
XHost_JJChar8 *getJpc2010_pararneters(XHost_UChar8 parameters_to_get);<br>
#endif<br>
DISPLAY.H<br>
/* Display library functions 7<br>
#ifndef_D!SPLAY_H #define_DlSPLAY_H<br>
extern void itoa{int, char Q); extern void write(char *); extern void display_init(void); extern void display_test(void);<br>
#define WRITE_DELAY 25000<br>
#endif<br>
BPG.H<br>
r<br>
* include/hardware, h<br>
*/<br>
#ifndef_BPG_H<br>
#define_BPG_H<br>
include "7092.hH<br><br>
/* These must be defined through the compiler V /*#define_EVALUALTION_BOARD 1 V I* #define _RUN_WITH_EMULATOR 1 7 r #define __PICARD_BOARD_TEST 0 7<br>
r<br>
*	Bus Controller setup for Hynlx HMS39C7092 Microcontroller<br>
7<br>
#define BCR0_PATTERN     0x102 // 8 bit bus width, 3 wait states #define BCR1_PATTERN     0x100 // 8 bit bus width, 1 wait state<br>
/*<br>
*	Port map for Hynix HMS39C7092 Microcontroller<br>
7<br>
// Pin Mux settings<br>
#define PAMR_PATTERN    0x3fff // PAO: GPIO - PowerJMBATTLO // PA1: GPIO - Power_STAT // PA2: GPIO - PowerJMCHAG // PA3: GPIO - not used<br>
// PA4: GPIO - not used (DISP_DATASEG - eval) // PA5: GPIO - not used (DISP_NWRSEG    - eval) // PA6: GPIO - not used (DlSP_NRDSEG     - eval) // PA7: GPIO - not used (D1SP_NCSSEG - eval)<br>
#define PBMR^PATTERN    OxOff // PBO: GPIO - not used //PB1: GPIO -not used // PB2; GPIO - not used // PB3: GPIO - not used // PB4: TMS // PB5: TDO // PB6: TDI<br><br>
// PB7: TCK<br>
#define P1MR_PATTERN 0x00 // P10: address bit 0 //P11: address bit 1 //P12: address bit 2 //P13: address bit 3 //P14: address bit 4 //P15: address bit 5 //P16: address bit 6 //P17; address bit 7<br>
#defme P2MR_PATTERN     0x00  // P20: address bit 8<br>
// P21: address bit 9<br>
//P22: address bit 10<br>
//P23: address bit 11<br>
0	IIP24: address bit 12<br>
//P25: address bit 13 // P26: address bit 14 // P27: address bit 15 - not used<br>
#define P3MRJ=ATTERN Oxff IIP30: GPIO - not used //P31:GPI0- not used // P32: GPIO - not used // P33: GPIO - not used //P34: GPIO-not used // P35: GPIO - not used // P36: GPIO - not used //P37: GPIO - not used r    #define P4MR_PATTERN    0x00 // databus[7:0]<br>
#ifdef _EVALUALTION_BOARD<br>
#define P5MR_PATTERN     0x00  // P50: address bit 16 //P51: address bit 17 //P52: address bit 18 //P53: address bit 19<br>
#eise<br><br>
#define P5MR_PATTERN     OxOf  // P50: GPIO - DISP_DATASEG // P51: GPIO - DISPJWVRSEG // P52: GPIO - DiSP_NRDSEG // P53: GPIO - DlSP_NCSSEG<br>
#endif<br>
#define P6MR_PATTERN     0x01b // P60: GPIO - not used //P61: GPIO-not used // P62: GPIO - not used // P63: nAS - bus interface address strobe // P64: nRD - bus interface read //P65:nHWR-not used // P66: nLWR - bus interface write lower // P67: BCLK - bus interface clock - default io-pin<br>
#defineFPC2010_CLOCK_MUX_MASK 0x20<br>
#define P7MR__PATTERN     Oxlff // P70: GPIO - not used<br>
//P71: GPIO-not used<br>
//P72: GPIO-not used<br>
// P73; GPIO - not used<br>
// P74: GPIO - not used<br>
// P75: GPIO - not used<br>
//P76: GPIO-not used<br>
// P77: GPIO - not used #define P8MR_PATTERN     0x0b  // P80: IRQ0 - SIRQ<br>
//P81:IRQ1-NIRQ<br>
//P82:IRQ2-NIRQSEG<br>
//P83: nCS1 - Exteranl ram chip select<br>
// P84: nCSO - FPC2010 chip select via OR-gate #define P9MR_PATTERN     0x154 //P90:TxD0,<br>
//P91:RxD0<br>
// P92: GPIO - FPC2010JFSEL<br>
//P93:GPIO-FPC2010 RESET<br><br>
// P94: GPIO - not used // P95: GPIO - not used // P96: Does not exist // P97: nTRST - JTAG reset<br>
// Port A<br>
#ifdef _EVALUALT!ON_BOARD<br>
#define PADDR_PATTERN	0x00 // all outputs if enabled by pin mux<br>
#define PADR_PATTERN     OxOf // set PA0-PA3 to 0 and PA4-PA7 to 1 #else<br>
#define PADDR_PATTERN	0x07 // bit 0, 1 and 2 are inputs, all others are outputs if<br>
r     enabled by pin mux<br>
#define PADR_PATTERN    0x00 // all set to 0 #endif<br>
#define POWERJJBATTLOJWASK 0x01 #define POWER_STAT_MASK     0x02 #define POWER_NCHAG_MASK   0x04<br>
#ifdef _EVALUALTION_BOARD #define DISP_NCSSEG_MASK 0x10 #define DISP_NRDSEG_MASK 0x20 #define DISP_NWRSEG_MASK 0x40 f #define DISP_DATASEG_MASK 0x80 #endif<br>
// Port B<br>
#define PBDDR_PATTERN	0x00 // all outputs if enabled by pin mux<br>
#defme PBDR PATTERN     0x00 // all set to 0<br>
// Port 1<br><br>
#defme P1 DDR_PATTERN	0x00 // all inputs if enabled by pin mux<br>
#define P1 DR_PATTERN     0x00 // ail set to 0<br>
// Port 2<br>
#define P2DDR_PATTERN	0x00 // all outputs if enabled by pin mux<br>
#define P2DR_PATTERN     0x00 // all set to 0<br>
// Port 3<br>
#define P3DDR_PATTERN	0x00 // all outputs if enabled by pin mux<br>
#define P3DR_PATTERN     0x00 // all set to 0<br>
// Port 4<br>
#define P4DDR_PATTERN	0X00 // all outputs if enabled by pin mux<br>
-     #define P4DR_PATT£RN     0X00 // ail set to 0<br>
// Port 5<br>
#define P5DDR_PATTERN	0x0 // all outputs if enabled by pin mux<br>
#defme P5DR_PATT£RN     Oxf // all set to 1<br>
#ifndef _EVALUALTlON_BOARD #define DISP_DATASEG_MASK  0x01 #define DISP_NWRSEG_MASK   0x02 #define DISP_NRDSEG_MASK   0x04 #define DISP_NCSS£G_MASK   0x08 #endif<br>
f<br>
II Port 6<br>
#define P6DDR_PATTERN	■ - -   0x00 // all outputs if enabled by pin mux<br>
#define P6DR_PATT£RN     0X00 // all set to 0 #defineFPC2010 CLOCK_MASK 0x80 //<br>
// Port 7<br>
#defme P7DDR_PATTERN	0x00 // ail outputs<br><br>
#define P7DR_PATTERN     0x00 //all set to 0<br>
#define EVAL_LED_MASK      0x20 // evaluation board : P75 controls LED D1<br>
// Port 8<br>
#define P8DDR_PATTERN	0x07   II bit 3 and 4 are outputs, all other are inputs if<br>
enabled by pin mux<br>
#define P8DR_PATTERN     0x00 // all set to 0<br>
#defineFPC1030_SIRQ_MASK   0x01<br>
#defineFPC2010_NIRQ_MASK   0x02<br>
#define DISP_NIRQSEG_MASK  0x04<br>
// Port 9<br>
#define P9DDR_PATTERN	0x00 // all outputs<br>
#define P9DR_PATTERN     0x00 // all outputs set to 0<br>
#define P90JV1ASK	0x01<br>
#define P91 JvlASK	0x02<br>
#defineFPC2010JFSEL_MASK 0x04 //0: EBI, 1: Uart<br>
#defineFPC2010_RESET_MASK 0x08<br>
//Display<br>
#define DISP_RAM_SIZE 8    // Size of display register bank to use<br>
#ifdef_EVALUALTION_BOARD<br>
#defme DISP_DR PADR<br>
#e!se<br>
#define DISP_DR P5DR<br>
#endif<br>
//Display Commands<br>
#define DISP_SYS_DIS 0x001 // 0b100000000000 inverted to 0b000000000001 #define DISP_SYS_EN   0x401 // 0b100000000010 inverted to 0b010000000001 #define DISP_LCD_OFF 0x201 // 0b100000000100 inverted to ObOOIOOOOOOOOl #defineDISP LCD ON   0x601 //0b100000000110 inverted to0b011000000001<br><br>
#define DISP_B1 AS_.COM 0x4a1 //0b100001010010 inverted to Ob010010100001<br>
//Timers<br>
#define TIMER0_CONTROL    0x98  // default value<br>
#define TIMER0JO_CONTROL 0x88   //default value<br>
#define TIMER0JNT_CONTROL 0xf8  // default value, ail interrupts disabled<br>
#define TIMER0_COUNTER     0x0000 // default vaiue, inital counter register value<br>
#define TIMER0_MASK       0x01   // Used to start and stop timerO<br>
//Finger print base address<br>
#define FPC_BASE (CSO_base+0x300O0) // The flash Is remap to address 0 - 0x2ffff<br>
#endif<br>
7092.H<br>
#ifndef__7092JH define _7092_H<br>
#define        SYSTEM CLOCK	33000000<br>
constants<br><br>
#define	"    Mode_Bits<br>
#define	Mode_FlQ<br>
#define	ModeJRQ<br>
#defne	Mode_SVC<br>
#defina	Mode_USR<br><br>
0x1 F 0x11 0x12<br>
0x13 0x10<br><br>
#define	!_Bit	0x80<br>
#define	F_Bit	0x40<br>
#define	SM	0<br>
//	<br>
// MCU Base Address Map<br>
//.	<br>
// 0x09001000 - Ox09001FFF Peripherals (APB bridge)<br>
// 0x09001800 - 0x09001FFF Reserved<br>
// 0x09001900 - 0X090019FF ADC register<br>
// 0x09001800 - 0x090018FF ADC register<br>
// 0x09001600 - 0x090017FF PIO register<br>
// 0x09001600 - 0x090016FF SSI register<br>
// 0x09001500 - 0x090015FF UART1 register<br>
// 0x09001400 - 0x090014FF UARTO register<br>
// 0x09001300 - 0x090013FF TIMER register<br>
// 0x09001200 - 0x090012FF INTC register<br>
// 0x09001100 - 0x090011FF WDT register<br>
// 0x09001000 - Ox090010FF PMU register<br>
// 0x09000000 - Ox09000FFF ASB Register<br>
//0x09000400 - 0x09000FFF Reserved<br>
// 0x09000300 - Ox090003FF ARM7TDMI Test register<br>
// 0x09000200 - 0x090002FF FMI register<br>
// 0x09000100 - 0x090001 FF SMI register<br>
// 0x09000000 - 0xO9OO0OFF MCUC register<br>
// 0x08050000 - Ox08FFFFFF Reserved<br>
// 0x08040000 - OX0804FFFF On-Chip Boot ROM<br>
// 0x08030000 - Ox0803FFFF On-Chip SRAM(4KB)<br>
// 0x08000000 - 0XO802FFFF FLASH(192KB)<br>
// 0x00000000 - 0x07FFFFFF Static Memory Area<br>
//<br>
//MODE0,1,2,3(SM=0)<br><br>
// 0x07000000 - 0X07FFFFFF nCS7<br>
// 0x06000000 - 0XO6FFFFFF nCS6<br>
// 0x05000000 - OX05FFFFFF nCS5<br>
// 0x04000000 - 0X04FFFFFF nCS4<br>
// 0x03000000 - 0x03FFFFFF nCS3<br>
// 0x02000000 - 0x02FFFFFF nCS2<br>
// 0x01000000 - 0x01 FFFFFF nCS1<br>
// 0x00000000 - OxOOFFFFFF nCSO (Remap=0)<br>
// 0x00000000 - OxOOOOOFFF On-Chip SRAM(4KB) (Remap=1)<br>
//<br>
//MODE0,1,2,3(SM=1)<br>
// 0x00700000 - 0X007FFFFF nCS7<br>
// 0x00600000 - Ox006FFFFF nCS6<br>
// 0x00500000 - 0x005FFFFF nCS5<br>
// 0x00400000 - 0x004FFFFF nCS4<br>
// 0x00300000 - 0xO03FFFFF nCS3<br>
// 0x00200000 - Ox002FFFFF nCS2<br>
// 0x00100000 - OxOOIFFFFF nCS1<br>
// 0x00000000 - OxOOOFFFFF nCSO (Remap=0)<br>
// 0x00000000 - OxOOOOOFFF On Chip SRAM(4KB) (Remap=1)<br>
//<br>
//MODE4,5{SM=0)<br>
// 0x07000000 - 0x07FFFFFF nCS7<br>
Si 0x06000000 - 0X06FFFFFF nCS6<br>
// 0X05000000 - 0X05FFFFFF nCS5<br>
// 0x04000000 - Ox04FFFFFF nCS4<br>
// 0x03000000 - 0X03FFFFFF nCS3<br>
// 0X02000000 - 0x02FFFFFF nCS2	-   -    .   -<br>
// 0x01000000 - 0x01 FFFFFF nCS1<br>
// 0x00000000 - OxOOFFFFFF nCSO {Remap=0)<br>
// 0x00000000 - OxOO02FFFF FLASH(192KB)<br>
// 0x00000000 - OxOOOOOFFF On Chip SRAM(4KB) (Remap=1)<br>
//<br><br>
//MODE4,5(SM=1)<br>
// 0x00700000 - 0X007FFFFF nCS7<br>
// 0x00600000 - 0x006FFFFF nCS6<br>
// 0x00500000 - 0x005FFFFF nCS5<br>
// 0x00400000 - OX004FFFFF nCS4<br>
// 0x00300000 - 0X003FFFFF nCS3<br>
// 0x00200000 - 0X002FFFFF nCS2<br>
// 0x00100000 - OxOOIFFFFF nCS1<br>
// 0x00000000 - OxOOOFFFFF nCSO (Remap=0)<br>
// 0x00000000 - OX0002FFFF FLAH{192KB)<br>
// 0x00000000 - OxOOOOOFFF On-Chip SRAM(4KB) (Remap=1)<br>
//<br>
// MODE6.7 (SM=0)<br>
// 0x07000000 - Ox07FFFFFF nCS7<br>
I! 0X06000000 - OX06FFFFFF nCS6<br>
// 0x05000000 - 0X05FFFFFF nCS5<br>
// 0x04000000 - 0xD4FFFFFF nCS4<br>
// 0x03000000 - 0x03FFFFFF nCS3<br>
// 0x02000000 - 0x02FFFFFF nCS2<br>
// 0x01000000 - 0X01FFFFFF nCS1<br>
// 0x00000000 - OxOOFFFFFF nCSO (Remap=0)<br>
// OxOOOOOOOO - OxOOOOOOFF On-Chip Boot ROM(256Byte) (default)<br>
// 0x00000000 - 0x0002FFFF FLASH
// 0x00000000 - OxOOOOOFFF On-Chip SRAM(4KB) (Remap=1)<br>
//<br>
//MODE6,7(SM=1)<br>
// 0x00700000 - 0x007FFFFF nCS7<br>
// 0x00600000 - 0X006FFFFF nCS6 ■-<br>
// 0x00500000 - Ox005FFFFF nCS5<br>
// 0x00400000 - OX004FFFFF nCS4<br>
// 0x00300000 - Ox003FFFFF nCS3<br>
// 0x00200000 - Ox002FFFFF nCS2<br>
//0x00100000 - OxOOIFFFFF nCS1<br><br>
// 0x00000000 - OXOOOFFFFF nCSO (Remap=0)<br>
// 0x00000000 - OxOOOOOOFF On-Chip Boot ROM(256Byte) (default)<br>
// 0x00001000 - OX0002FFFF FLAH(192KB) (FLASH=1)<br>
// OxOOOOOOOO - OxOOOOOFFF On-Chip SRAM(4KB) (Remap=1)<br>
//<br>
#define	ADC_base   0x09001700<br>
#defme	GPlO_base 0x09001600<br>
#define	UART1_base	0x09001500<br>
^define	UARTO_base	0x09001400<br>
#defme	TIMER_base0x09001300<br>
#define	INTC_base      0x09001200<br>
#define	WDT_base       0x09001100<br>
#define	PMU_base       0x09001000<br>
#define	PERI_base      0x09001000<br>
#define	ARM Jest       0x09000300<br>
#define	FMI_ctrl       0x09000200<br>
#define	BUS_ctrl       0x09000100<br>
#define	MCU_ctr!       0x09000000<br>
#define	BOOTROM_base    0x08040000<br>
#define	ISRAM„base	0x08030000<br>
#define	FLASH.base	0x08000000<br>
#define	EXCS__base 0x00000000<br>
#ifSM==0<br>
II—	<br>
// Static Memory Interface Map(16M)        (OxOOOOOOOO - 0x07FFFFFF)<br>
//  SM=0		<br>
//.	<br>
#denne	CS7J&gt;ase	0x07000000<br>
#defme	CS6_base	0x06000000<br>
define	CS5_base	0x05000000<br>
#define	CS4_base	0x04000000<br><br>
#define	CS3_base	0x03000000<br>
#define	CS2_base	0x02000000<br>
#define	CSIjbase	0x01000000<br>
#derlne	CSO_base	0x00000000<br>
#else		<br>
//.			<br><br>
// Static Memory interface Map(1M) // SM=1<br><br>
(0x00000000 - 0x007FFFFF)<br><br>
//-<br><br>
#define	CS7_base	0x00700000<br>
#define	CS6_base	0x00600000<br>
#define	CS5_base	0x00500000<br>
#define	CS4_base	0x00400000<br>
#define	CS3_base	0x00300000<br>
#define	CS2_base	0x00200000<br>
#define	CS1_base	0x00100000<br>
#define	CSO_base	0x00000000<br>
#endif		<br>
ti-<br>
ll ASB Register Memory Map   (0x09000000 - 0x09000FFF)<br>
ti¬ll-<br><br>
IIMCU control Map<br>
//	<br><br>
(0x09000000 - OX090000FF)<br><br><br><br><br>
#define	PAMR<br>
#define	PBMR<br>
#define	P1MR-<br>
#define	P2MR<br>
#define	P3MR<br>
#define	P4MR<br>
#define	P5MR<br>
#define	P6MR<br><br>
((volatile unsigned int*)(MCU_ctrl+0x00)) ((volatile unsigned int*)(MCU_ctrl+0x04)) ((volatile unsigned int*)(MCU__ctrl+0x08}) ((volatile unsigned int*)(MCLLctrl+OxOC)) ((volatile unsigned lnt*)(MCU_ctrl+0x10)) ((volatile unsigned int")(MCU_ctrl+0x14)) ((volatile unsigned int")(MCU__ctrl+0x18)) ((volatile unsigned int*)(MCU__ctrH-0x1C))<br><br>
#deflne	P7MR	((volatile unsigned int*)(MCU_ctri+0x20))<br>
#defme	P9MR	((volatile unsigned int*)(MCU_ctri+0x24))<br>
#define	P9MR	((volatile unsigned int*)(MCU_ctrl+0x28))<br>
#define	DCR	((volatile unsigned int*)(MCU_ctrl+0x2C))<br>
fi-<br><br>
ll SMI Register Map          (0x09000100 - 0x090001FF)<br>
//.	<br>
//31   30  29   28    27   26       24   23     22-20    19-16 //15   14   13   12     11     10        8      7       6-4      3-0 //        RDON CSCNTL Falsh ExpCLK MemWidth BurstEn BurstWait NorWait<br>
// led CSON	<br>
//    CSON	<br>
#define	BCR0<br>
#define	BCR1<br>
#defme	BCR2<br>
#define	BCR3<br>
#define	BCR4<br>
#define	BCR5<br>
#define	BCR6<br>
#define	BCR7<br>
LCD Wait (21-16)<br>
((volatile unsigned int*)(BUS_ctrl+0x00)) ({volatile unsigned int*)(BUS„ctri+0x04)) ((volatile unsigned int*)(BUS„ctri+0x08)) ((volatile unsigned int*)(BUS_ctrl+0x0C)) ((volatile unsigned int*)(BUS_ctrl+0x10)) ((volatile unsigned int*)(BUS_ctrl+0x14)) ((volatile unsigned int*)(BUS_ctrl+0x18)) ((volatile unsigned int*)(BUS_ctrl+0x1C))<br><br>
ti-<br>
ll FMI Register Map         (0x09000200 - Ox090002FF)<br>
//__	<br>
II FSTATPWRR {HVEEI, LVEEI, LVCC_RST, VEEIOPT[1:0], VPPDOPT[1:0], VPPIOPT[1:0]}<br>
//	S      S      S	P	P	P<br>
II S: status(Read only); P ■: Power option register(Read/Write)<br>
#define        FMWR	((volatile unsigned int*XFMI_ctrl+0x00))   // RAV    : Bus wait<br>
control register<br>
#define        FMAR	((volatile unsigned int*)(FMt_ctrl+0x04))   // WRITE : ADDRR,<br>
DATAR address, READ : ADDRR<br><br>
#define	FMDR<br>
DATAR(read only register)<br>
#define	FMCR<br>
control register<br>
#define        FEBR<br>
block register<br>
#define        FMPR<br>
status power option register.<br>
#define	FMTR<br>
register<br><br>
{{volatile   unsigned   int*)(FMI_ctrl+0x08))	//   READ<br>
((volatile unsigned int*){FMI_ctrl+0x0C))     // R/W     : flash<br>
((volatile unsigned int*)(FMI_ctrl+OxlO))  // R/W   : flash erase<br>
((volatile  unsigned  inf)(FMI_ctri+0x14))       //<br>
((volatile unsigned int*)(FMI_ctrl+0x18))   // R/W   : flash test<br><br>
li-<br><br>
lt Peripherals (APB bridge) Map  (0x09001000 - 0x09001 FFF)<br>
ti¬ll-<br>
//PMU Map<br>
//-	<br>
(0x09001000 -0X090010FF)<br>
#define        PMUST	((volatile unsigned int*)<pmuj>ase+0x00))<br>
// PMU operation mode control register<br>
#define        PMUCR	((volatile unsigned int*}(PMU_base+0x00))<br>
// PMU operation mode control register<br>
#define        MEMCR	((volatile unsigned int*)(PMU_base+0x10))<br>
// Remap Control Register<br>
#define        RSTCR	((volatile unsigned int*)(PMU_base+0x30))<br>
// Soft Reset Control Register<br>
#define        PCKCR	((volatile unsigned int*)(PMU_base+0x08))<br>
// PCLK control register<br>
ti-<br><br>
ll Watch-Dog Timer (WDT) Map<br>
//.	<br>
#define        WTCR<br>
// Timer/Reset Control Register(R/W)<br><br>
(0x09001100-0x090011FF)<br>
((volatile unsigned int*)(WDT_base+0x00))<br><br>
#define        WTSR<br>
// Reset Status Register(R) tfdefine        WTCNT<br>
// Timer Counter Register(R/W)<br><br>
((volatile unsigned int*)(WDT_base+0x04)) ((volatile unsigned int')(WDT_base+0xQ8))<br><br>
ti-<br>
ll Intmipt Controller (INTC) Map<br>
//	<br>
(0x09001200 - 0x090012FF)<br>
#define	GMR<br>
// Global Mask Register	<br>
#define	TMR<br>
// Trigger Mode Register	<br>
#define	TPR	<br>
	II Trigger Polarity Register<br>
#define	IDR	<br>
	// Interrupt Direction Register<br>
#define	FSR<br>
// FIQ Status Register	<br>
#define	ISR<br>
//IRQ Status Register	<br>
#define	FMR<br>
// FIQ Mask Register	<br>
#define	(MR<br>
// IRQ Mask Register	<br>
#def?ne	1SCR<br>
// Status Clear Register	<br>
#define	1BJRQ0	0x00001<br>
#define	IBJRQ1	0x00002<br>
#deflne	IBJRQ2	0x00004<br>
#define	IBJRQ3	0x00008<br>
#define	IBJRQ4	0x00010<br>
#define	IB IRQ5	0x00020<br>
((volatile unsigned int*)(lNTCJ&gt;ase+0x00)) ((volatile unsigned int*)(INTC_base+0x04» ((volatile unsigned int*)(INTC_base+0x08)) ((volatile unsigned int*)(INTC_base+0x0C)) ((volatile unsigned int*)(!NTC_base+Ox10)) ((volatile unsigned lnt*)(lNTCJ&gt;ase+0x14)) ((volatile unsigned int*)(INTC_base+0x18)) ((volatile unsigned int*)(INTCJjase+0x1C)) ((volatile unsigned int*}(INTC_base+0x20)}<br><br>
#define	IBJRQ6		0x00040<br>
#define	IBJRQ7		0x00080<br>
#deffne	IB_COMTX	0x00100	<br>
#define	IB_COMRX	0x00200	<br>
#define	IB_WDT		0x00400<br>
#defme	IB_UARTO	0x00800	<br>
#define	IB_UART1	0x01000	<br>
#define	IB_ADC		0x02000<br>
#define	IB_TIMERO	0x04000	<br>
#define	IB_T1MER1	0x08000	<br>
#define	IB_TIMER2	0x10000	<br>
#define	IB_TIMER3	0x20000	<br>
#define	!B_TIMER4	0x40000	<br>
#define	IB_TIMER5	0x80000	<br>
#defins	1B_SWI		0x100000<br>
#define	IB_EXIRQ	OxOOOOff	<br>
#defme	)B_TtMERjVLL	OxOfcO<br>
#define	IDJRQO		0x00<br>
#define	IDJRQ1		0x01<br>
#define	IDJRQ2		0x02<br>
#defme	IDJRQ3		0x03<br>
#define	IDJRQ4		0x04<br>
#define	IDJRQ5		0x05<br>
#define	IDJRQ6		0x06<br>
#deflne	IDJRQ7		0x07<br>
#deftne	ID_COMTX	0x08	<br>
#deflne	ID_COMRX	0x09	<br>
#define	ID_WDT		OxOA<br>
#define	ID_UART0		OxOB<br>
#define	IDJJART1		OxOC<br>
#defme	ID ADC		OxOD<br><br>
#define	ID_TIMERO	OxOE<br>
#define	IDJIMER1	OxOF<br>
#define	ID_TIMER2	0x10<br>
#define	ID_TIMER3	0x11<br>
#define	ID_TIMER4	0x12<br>
#define	ID_TIMER5	0x13<br>
#define	ID SWI	<br><br>
0x14<br><br>
//-<br>
II TIMER Register Map	(OxFFFFFOOO - OxFFFFFFFF)<br>
II	<br>
//«<br>
// [ Timer register description ]<br>
It TSTARTR: Timer start register<br>
//TSYNCR : Timer sync register<br>
// TPWMR  : Timer PWM register<br>
//	<br>
// Timer control register<br>
// TCRx	: [7],[4:3]: reserved (init vaule all 1)<br>
//	[6:5]    : 00 -&gt;free running<br>
//	01 -&gt;clear by GRA commatJPA input capture<br>
//	10 -&gt;clear by GRB commatJPB input capture<br>
/;	11 -&gt;cleared by other sync timer<br>
II	[2:0]     : 000-&gt;intclk1 (BCLK/2),001-&gt;int_cl)
//	010-&gt;int_c1k3(/8),   011-&gt;int_clk4(/16)<br>
//	100-&gt;ext_clk1,       101 -&gt;ext_clk2<br>
//	■       110-&gt;ext_clk3,       111-&gt;ext_clk4 -<br>
//-<br>
II I/O control register<br>
//TIOCRx -.[71,131  -.reserved (init vaule all 1)<br>
//	[6:4]    : 000-&gt;pin output disable at commat<br>
//	001-&gt;0 GRB match,01O-&gt;1 GRB match<br><br>
// // // // // //-■<br><br>
[2:0]<br><br>
011-&gt;toggleGRB match 100-&gt;GRB capture at rising 101-&gt;GRB capture at failing 110-&gt;GRB capture at both egde : Same as [6:4], for GRA<br><br>
// Timer interrupt enable register<br>
// //<br>
//<br>
12} [1] 10]<br>
// TIERx   ; [7:3]     ; reserved (init vaule all 1)<br>
interrupt from OVFI{V.enable,0:disable) interrupt from MCIB(1 :enable,0:disable),GRB interrupt from MCIA(1 ;enabte,D:disable),GRA<br><br>
//TSRx:[7:3]<br>
//            [2]<br>
//            [1]<br>
//            [0]<br>
//	<br>
//Timer status register<br>
reserved (init vaule all 1) OVFI status MCIB status MCIA status<br>
//TCOUNTx : Timer count (16bit) // GRAx,GRBx: General register (16bit)<br><br>
//-<br>
#define	TSTARTR<br>
//Timer Start Register #define        TSYNCR<br>
// Timer Synch Register #deftne        TPWMR<br>
// Timer PWM mode Register<br>
#define        TCRO<br>
// Timer Control Register<br>
#define	TIOCRO<br>
// Timer I/O Control Register<br><br>
((volatile unsigned int*)(TIMER_base+0x00)) ((volatile unsigned int*)(TlMER_base+0x04)) ((volatile unsigned lnt*)(TlMER_base+0x08)}<br>
((volatile unsigned int*)(TIMER_base+Ox20)) ((volatile unsigned int*)(TIMER_base+0x24))<br><br>
#define	TIERO<br>
// Timer Interrupt Enable Register<br>
#define	TSRO<br>
// Timer Status Register<br>
#define	TCNTO<br>
// Timer Counter #define        GRAO<br>
// General Register A #define        GRBO<br>
// General Register B<br>
#define        TCR1<br>
// Timer Control Register #define        TIOCR1<br>
// Timer I/O Control Register #define        TIER1<br>
// Timer Interrupt Enable Register #define        TSR1<br>
// Timer Status Register #define        TCNT1<br>
// Timer Counter #define        GRA1<br>
// General Register A #define        GRB1<br>
// General Register B<br>
#define        TCR2<br>
// Timer Control Register<br>
#define	TIOCR2<br>
// Timer I/O Control Register<br>
#define	TIER2<br>
// Timer Interrupt Enable Register<br><br>
((volatile unsigned int*)(TlMER_base+0x28)) ((volatile unsigned int*){TIMER_base+0x2C)) ((volatile unsigned int*}(TIMER_base+0x30)) ((volatile unsigned int*)(TIMER_base+0x34)) ((volatile unsigned int")(TlMER_base+0x38))<br>
((volatile unsigned int*)(TIMER_base+0x40)) ((volatile unsigned int*}(TIMER_base+0x44)) ((volatile unsigned int*)(TlMER_base+0x48)) ((volatile unsigned int*)(TIMER_base+0x4C)) ((volatile unsigned int*)(TIMER_base+0x50)) ((volatile unsigned int*)(TIMER_base+0x54)) ((volatile unsigned int*)(TIMER_base+0x58))<br>
((volatile unsigned int*)(TIMER_base+0x60)) ((volatile unsigned int*)(TIMER_base+0x64)) ((volatile unsigned int*)(TIMER_base+0x68))<br><br>
#define	TSR2<br>
	// Timer Status Register<br>
#deftne	TCNT2<br>
	// Timer Counter<br>
#define	GRA2<br>
	// General Register A<br>
#define	GRB2<br>
	// General Register B<br>
#define	TCR3<br>
	// Timer Control Register<br>
#define	TIOCR3<br>
	// Timer I/O Control Register<br>
#define	TIER3<br>
	// Timer Interrupt Enable Register<br>
#define	TSR3<br>
	// Timer Status Register<br>
#define	TCNT3<br>
	// Timer Counter<br>
^define	GRA3<br>
	//General Register A<br>
#define	GRB3<br>
	// General Register B<br>
#define	TCR4<br>
	// Timer Control Register<br>
#define	TIOCR4<br>
	//Timer I/O Control Register<br>
#define	TIER4<br>
	//Timer Interrupt Enable Register<br>
#defins	TSR4<br>
	// Timer Status Register<br><br>
{(volatile unsigned int*)(TIMER_base+0x6C))<br>
((volatile unsigned int*)(TIMER_base+0x70))<br>
((volatile unsigned int*)(TIMER_base+0x74))<br>
((volatile unsigned int*)(TIMERJ)ase+0x78))<br>
((volatile unsigned int*)(TlMER_base+0x8u))<br>
((volatile unsigned int*)(TlMER_base+0x84))<br>
((volatile unsigned int*)(TIMER_base+0x88))<br>
{(volatile unsigned int*)(TIMERJ&gt;ase+0x8C))<br>
((volatile unsigned int*)(TIMER_base+0x90))<br>
((volatile unsigned int*)(TIMER_base+0x94))<br>
((volatile unsigned int*)(TIMER_base+0x98)J<br>
((volatile unsigned int*)(TIMER_base+OxAO))<br>
((volatile unsigned int*)(TIMER_base+0xA4))<br>
((volatile unsigned int*)(TIMER_base+0xA8))<br>
((volatile unsigned int*)(TiMER_base+OxAC))<br><br>
#define	TCNT4<br>
	//Timer Counter<br>
#define	GRA4<br>
	// General Register A<br>
#define	GRB4<br>
	//General RegisterB<br>
#define	TCR5<br>
	// Timer Control Register<br>
#define	TIOCR5<br>
	// Timer I/O Control Register<br>
#define	TIER5<br>
	// Timer Interrupt Enable Register<br>
#define	TSR5<br>
	II Timer Status Register<br>
#define	TCNT5<br>
	// Timer Counter<br>
#define	GRA5<br>
	// General Register A<br>
#define	GRB5<br>
	// General Register B<br><br>
({volatile unsigned int*)(TIMER_base+OxBO))<br>
((volatile unsigned int*)(TIMER_base+0xB4))<br>
((volatile unsigned int*)(TIMER_base+0xB8))<br>
((volatile unsigned int*)(T!MER_base+OxDO))<br>
((volatile unsigned int*)(TlMER_base+0xD4))<br>
((volatile unsigned int*)(TlMER_base+0xD8))<br>
((volatile unsigned int*)(TlMER_base+OxDC))<br>
((volatile unsigned int*)(TIMER_base+OxEO))<br>
((volatile unsigned int*)(TIMER_base+0xE4))<br>
((volatile unsigned int*)(TIMER_base+0xE8))<br><br>
//-<br><br>
// UART Register Map<br><br>
(0x09001400 - 0X090015FF)<br><br><br><br>
//-<br>
#define	RBR<br>
#define	THR<br>
#define	DLL<br>
0)<br><br><br>
0X00 0x00 0X00<br>
// Receiver Buffer Reg. (R DLAB =<br>
// Transmitter Holding Reg. (W DLAB = 0) // Divisor Latch LS (R/W DLAB = 1)<br><br>
#define	IER			0X04<br>
#define	DLM			0x04             //   Interrupt   Enable<br>
DLAB = 0)				<br>
			// Divisor Latch MS (R/W DLAB - 1)<br>
#define	IIR			0x08<br>
#define	FCR		0x08	// Interrupt Ident Reg. (R)<br>
// Divisor Latch MS (R/W DLAB = 1)<br>
#define	LCR		0x0c	// Line Control Reg. (R/W)<br>
#define	LSR		0x14	// Line Status Reg. (R/W)<br>
#define	SCR		0x1 C	// Scratch Reg.<br>
#define	CLKCR		0x20	// CLK generation Control Reg.<br>
#define	CLKDR		0x24	// CLK divisor Reg.<br>
#define	LSR_DR		0x01	<br>
tfdefine	LSR_THRE	0x20		<br>
#define	LSR_TEMPT0x40		<br>
#define	1ER_TIE		0x02	<br>
#define	IER RIE		0x01	<br>
//-<br><br>
//UARTO Register Map<br>
//.	<br><br>
(0x09001400 - Ox090014FF)<br><br><br><br><br>
#define	UORBR<br>
#define	U0THR<br>
#define	U0DLL<br>
#define	UOIER<br>
#define	UODLM<br>
#define	UOIIR<br>
#define	UOFCR<br>
#define	UOLCR<br>
#define	UOMCR<br>
#define	UOLSR<br>
#define	UOMSR<br><br>
((volatile unsigned ((volati)e unsigned ((volatile unsigned ((volatile unsigned ((volatile unsigned -((volatile unsigned ((volatile unsigned ((volatile unsigned ((volatile unsigned ((volatile unsigned ((volatile unsigned<br><br>
int*)(UART0. int*)(UARTO. inrXUARTO. int*)(UART0. int*}(UART0. lnt*)(UART0. int*)(UART0. int*)(UART0. int*)(UART0_ int*)(UART0. int*)(UART0.<br><br>
,base+RBR)) _base+THR)) _bas©+DLL)) .base+lER))<br>
.base+DLM))<br>
.base+IIR))<br>
.base+FCR))<br>
,base+LCR))<br>
_base+MCR))<br>
.base+LSR))<br>
.base+MSR))<br><br><br><br>
#define        P1DR<br>
// P1 Data Register<br>
#define	P1DDR<br>
//P1 Data Direction Register<br>
#define	P2DR<br>
// P2 Data Register<br>
#define	P2DDR<br>
// P2 Data Direction Register #define        P3DR<br>
// P3 Data Register #define        P3DDR<br>
// P3 Data Direction Register<br>
#define	P4DR<br>
IIP4 Data Register<br>
#define	P4DDR<br>
// P4 Data Direction Register #define        P5DR<br>
// P5 Data Register #define        P5DDR<br>
// P5 Data Direction Register #define        P6DR<br>
// P6 Data Register #define        P6DDR<br>
// P6 Data Direction Register<br>
#define	P7DR<br>
// P7 Data Register #defme        P7DDR<br>
// P7 Data Direction Register<br>
#define	P8DR<br>
// P8 Data Register<br>
#define	P8DDR<br>
// P8 Data Direction Register<br><br>
((volatile unsigned irrt*)(GPlO_base+0x1G)) ((volatile unsigned inr)(GPIO_base+0x14)) ((volatile unsigned int*)(GPIO_base+0x18)) ((volatile unsigned int*)(GPIO_base+0x1C)) ((volatile unsigned int*)(GPIOJ)3se+0x20)) ((volatile unsigned int*)(GPIOJ)ase+0x24)) ((volatile unsigned int*)(GP!O_base+0x28)) ((volatile unsigned int*)(GPIO_base+0x2c)) ((volatile unsigned int*)(GPIO_base+0x30)} ((volatile unsigned int*)(GPIO_base+0x34)) ((volatile unsigned lnt*)(GPiO_base+0x38)) ((volatile unsigned int*)(GP!O_base+0x3C)) ((volatile unsigned int*)(GP!O_base+0x40)) {(volatile unsigned int*)(GPIO_base+0x44)) ((volatile unsigned int*)(GPlO_base+0x48)) ((volatile unsigned int*)(GPIO_base+0x4c})<br><br>
#define        P9DR<br>
// P9 Data Register<br>
#define	P9DDR<br>
It P9 Data Direction Register<br>
//	<br>
// ADC Register Map<br>
//.	<br>
#deflne        ADCSR<br>
//ADC Control &amp; Status Register #define        ADCCR<br>
// ADC Control Register #define        ADDRO<br>
//ADC Data Register0 #define        ADDR1<br>
11 ADC Data Register 1 #define        ADDR2<br>
// ADC Data Register 2 #define        ADDR3<br>
//ADC Data Register3 #define        ADDR4<br>
//ADC Data Register4<br>
#endif UTILITY.C<br>
/*' Miscellaneous utilities */<br>
include "bpg.h" #include "display, h"<br><br>
((volatile unsigned int*)(GPiO_base+0x50)) {{volatile unsigned int*)(GPIO_base+0x54))<br>
(00x09001700 - 0x090017FF) ((volatile unsigned int*)(ADC_base+0x00)) ((volatile unsigned int*)(ADC_base+0x04» {(volatile unsigned int*)(ADC_base+0x08)) ((volatile unsigned int*)(ADC_base+0x0c)) ((volatile unsigned int*)(ADC_base+0x1O)) {{volatile unsigned int*)(ADC_base+0x14)) ((volatile unsigned int*)(ADCJ&gt;ase+0x18))<br><br>
void delay(int count)<br><br>
{<br>
I* loop;        	asm {V<br>
I*	subs r0,r0,#1 V<br>
/*	bgt loop V<br>
I*	}7<br>
while(count) { count = count -1;<br>
/*   count-; This constaiction does not work ? */ } &gt;<br>
void message(char * s)<br>
{ writers);<br>
delay(2*WRITEJ)El_AY); writef       "); delay(WRlTE_DELAY); write(s);<br>
delay(2*WRITE_DELAY); write(n       "); delay[WRiTE_DELAY); write("reAdy"); delay(2*WRITE_DELAY);<br>
}<br>
unsigned int battery_check(void) {<br>
unsigned int battery_status; unsigned int power__status;<br>
power_status = *PADR &amp; POWER_NCHAG_MASK; battery_status = *PADR &amp; POWER_NBATTLO_MASK;<br><br>
if (power_status) { if (battery_status) { return 0;<br>
} else{<br>
messageCBAtt Lo"); return 1;<br>
&gt;<br>
&gt;<br>
return 0;<br>
} TIMER.C<br>
/* Timer utilities 7<br>
#include "7092.h" #include "bpg,h" #include "timer.h"<br>
void timerO_init{void) {<br>
*TCR0 = TIMER0_CONTROL;     // free running mode "TIOCR0 =TIMER0_IO_CONTROL; // dont care in free running mode *TIER0 = TIMER0JNT_CONTROL; //disable all interrupts *TCNT0 = TIMER0_COUNTER;    // clear counter register<br>
y    -   -  -<br>
RETARGET.C<br>
r<br>
** Copyright (C) ARM Limited, 2001. All rights reserved.<br><br>
7<br>
r<br>
** This implements a 'retarget' layer for low-level 10. Typically, this ** would contain your own target-dependent implementations of fputcQ,<br>
** ferror(), etc.<br>
**<br>
** This example provides implementations of	userjnittal_stackheap().<br>
**<br>
*/<br>
include <stdio.h> #include <rt__misc.h><br>
extern unsigned int bottom__of_heap;<br>
	valuejnjegs struct	initial_stackheap	USer_jnttial_stackheap(<br>
unsigned RO, unsigned SP, unsigned R2, unsigned SL)<br>
{<br>
struct	initial_stackheap config;<br>
config.heap_base = (unsigned int)&amp;bottom_pf_heap; // defined in heap.s<br>
// placed by scatterfile config.stack_base = SP;  // inherit SP from the execution environment<br>
return config; }<br>
r<br>
Below is an equivalent example assembler version of	userjnitiat_stackheap.<br>
it will be entered with the value of the stackpointer in r1 (as set in inits),<br>
this does not need to be changed and so can be passed unmodified out of the<br><br>
function.<br>
IMPORT bottom_ofJieap<br>
EXPORT	userJnttia(_stacKheap<br>
	user_initia!_stackheap<br>
LDR  rO,=bottom_of_heap MOV  pejr<br>
V<br>
RANDOM.C<br>
/* linear congruential generator. Generator x[n+1] ~ a * x[n] mod m 7<br>
include "random.h" include "math.h"<br>
static unsigned Int SEED = 93186752;<br>
double random (void)<br>
{<br>
I* The following parameters are recommended settings based on research<br>
uncomment the one you want. 7<br>
static unsigned int a = 1588635695, m = 4294967291U, q - 2, r = 1117695901; r static unsigned int a = 1223106847, m = 4294967291U, q = 3, r = 625646750;*/ r static unsigned int a = 279470273, m = 4294967291U, q = 15, r - 102913196;*/ r static unsigned int a ~ 1583458089, m = 2-147483647, q = 1, r = 564025558; 7 r static unsigned int a = 784588716, m = 2147483647, q = 2, r = 578306215; 7 r static unsigned int a = 16807, m = 2147483647, q = 127773, r = 2836;      7 r static unsigned int a = 950706376, m - 2147483647, q - 2, r = 246070895; 7<br>
SEED = a*{SEED % q) - r*{SEED / q);<br><br>
return {(double)SEED / (doub]e)m); }<br>
void rand_seed (unsigned int init)  {if (init != 0) SEED = init;}<br>
// token<br>
double token(double x) {<br>
double v = 100000000000LL; double d = 0; double g = 0;<br>
x - (tempa*x) + tempo;<br>
while(x&gt;=1Q00){ d = x-(10*floor(x/10)); if(x<v></v>
g-(10*g)+d;<br>
v=v/10;<br>
} x=(x-d)/10;<br>
}<br>
return g; }<br>
PORT.C<br>
/* Display utilities */<br>
#indudeN?092.h' include "bpg.h"<br><br>
void port_init() {<br>
//Port control<br>
*PADR = PADR_PATTERN; *PADDR = PADDR__PATTERN; -PBDR = PBDR_PATTERN; *PBDDR = PBDDR_PATTERN; *P1DR = P1DR_PATTERN; *P1DDR = P1DDR_PATTERN; *P2DR = P2DR_PATTERN; *P2DDR = P2DDRJ=&gt;ATTERN; *P3DR = P3DR_PATTERN; *P3DDR - P3DDR_PATTERN; *P4DR ~ P4DR_PATTERN; •P40DR= P4DDR_PATTERN; *P5DR = P5DR_PATTERN; *P5DDR = P5DDR_PATTERN; *P6DR » P6DR_PATTERN; *P6DDR = P6DDR_PATTERN; *P7DR = P7DR_PATTERN; *P7DDR = P7DDR_PATTERN; *P8DR = P8DR_PATTERN; *P8DDR = P8DDR_PATTERN; *P9DR = P9DR_PATTERN; *P9DDR = P9DDR_PATTERN;<br>
//Mux control<br>
*PAMR = PAMR.PATTERN; *PBMR = PBMR_PATTERN; *P1MR = P1MR_PATTERN; *P2MR = P2MR_PATTERN; *P3MR = P3MR_PATTERN; *P4MR ~ P4MR_PATTERN;<br><br>
•P5MR = P5MR_PATTERN<br>
*P6MR = P6MR_PATTERN; *P7MR = P7MRJ&gt;ATTERN; *P8MR = P8MR_PATTERN; *P9MR = P9MR_PATTERN;<br>
}<br>
MAJN.C<br>
/*<br>
*	Smart Card pin code generator with finger print access control<br>
*	Copyright (C) 2001 DELTA IC Design, All Rights Reserved.<br>
*	$Author: Ibm $ :<br>
*	$ld: print.asm,v 1.12 2002/11/21 14:29:14 Ibm Exp $ :<br>
it<br>
7<br>
#include "typdefs.h" include "bpg.h" include "utffity.h" include "port.h" ffinclude "display.h" #include "timer.h" include "random.h" include "fpc2010biomain.h" #include "fpc2010interface.h' include "encapsulated^alg.h" include "fpc2010registers.h"<br><br>
unsigned char disp_ram[DISP_RAM_SlZE]; unsigned char template[TEMPLATE_SIZEJ;<br>
void waitJor_flnger_detected() {<br>
while{!(*P8DR &amp; FPC1030_SIRQ_MASK)) { } }<br>
void test() {<br>
char str[9];<br>
unsigned int tok = 2674834;<br>
unsigned int rand;<br>
bool result;<br>
port_init();<br>
timerOJnitQ; START_TIMERO;<br>
displayjnit();<br>
writefreAdy");<br>
deiay(2*WR)TE_DELAY);<br>
#ifndef DEBUG<br>
#ifndef_EVALUALTION_BOARD<br>
battery_check(); #endif<br>
STOP_TIMER0;<br><br>
rand_seed(*TCNTO);<br>
rand = RAND JNT(10000000,99999999);<br>
tok = rand;<br>
fpc2010lnit();<br>
wait_for_finger_detected(); result = fpc2010Enrol(template);<br>
If ((result) {<br>
write("Errar"); }else{<br>
write("Good");<br>
} delay(2*WRITE_DELAY);<br>
write("yyyyyyyy"); de!ay(2*WRITE_DELAY);<br>
while{1){<br>
tok = (unsigned int)token((double)tok);<br>
itoa(tok, str);<br>
write(str);<br>
delay(2*WRITE_DELAY);<br>
write("12345678");<br>
delay{WRITE_DEiAY);<br>
writeC'reAdy");<br>
delay(2*WRITE_DELAY);<br>
write("Good");<br>
delay(2*WRITE_DELAY);<br>
write("Good-1");<br>
delay(2*WRITE_DELAY);<br><br>
writeCGood-2");<br>
delay(2*WRITE_DELAY);<br>
writefError");<br>
delay(2*WRITE_DELAY);<br>
write{nrejectedM);<br>
delay(3*WRITE_DELAY);<br>
write("BAtt Lon);<br>
delay(3*WRITE_DELAY);<br>
wait_for_finger_detectedO; result = tpc2DlOVerify( template); if ((result) { write("reiected"); }<br>
display_test();<br>
#ifdef _EVALUALTION_BOARD *P7DR = *P7DR A EVALJ_ED_MASK; // Toggle evaluation board led<br>
#endif<br>
} #endif<br>
}<br>
void picard_app)ication() {<br>
char str[9]; -<br>
unsigned int tok = 2674834;<br>
unsigned int rand;<br>
bool result;<br>
portjnitQ;<br><br>
timerOJnitQ;<br>
SrARTJTIMERO;<br>
display_init(}; fpc2010lnit{);<br>
if (!battery__checkO) {<br>
write("reAd/'); de1ay(2*WRITE_DELAY); }<br>
error:<br>
// 1st step; create template<br>
battery_check();<br>
wait_for_finger_detected{);<br>
result = fpc2010Enrol(template);<br>
if ('result) { message("Error"); goto error;<br>
}<br>
wrftefGood");<br>
delay(2*WRITE_DELAY);<br>
// 2nd step: verify template the 1st time battery_check(); wait_for_finger_detected(); result = fpc2010Verify(template);<br>
if (iresult) {<br>
message("Error"); goto error;<br><br>
&gt;<br>
write{nGood-1"); delay(2*WRITE_DELAY);<br>
// 3nd step: verify template the 2nd time battery_check(); wa/t_for_finger_def.ected(); result = fpc2010Verify(template);<br>
if ('result) {<br>
message("Error"}; goto error;<br>
}<br>
writefGood-2");<br>
delay(2*WRITE_DELAY);<br>
// Now we have a useable template<br>
// The first time a finger print can be verrfied successfully<br>
// a random number is generated.<br>
error_verify:<br>
battery_check();<br>
waitJwJingevjdetectedO; result = fpc2010Verify(template); if ((result) {<br>
message("rejectedH);<br>
goto errorj/erify;<br>
&gt;■<br>
// Generate random number using seed from timer<br>
STOP_TIMER0;<br>
rand_seed(*TCNTO);<br>
rand = RANDJNT(10000000,99999999);<br><br>
tok = rand; itoaftok, str); write(str);<br>
// Generate random numbers using SMI algorithms // each time a finger print is recognized while(1) {<br>
battery_check();<br>
waitJor_finger_detected ();<br>
result = fpc2010Verify(temp)ate);<br>
if ('result) { messagefrejected");<br>
}<br>
else{<br>
tok = (unsigned int)token((double)tok); itoa(tok, str); write(str); } } }<br>
int mafn(void)<br>
{ *BCR0 = BCRO_PATTERNr'<br>
// test(); picard_applic'ation();<br>
}<br>
INT HANDLER.C<br><br>
/********»** it* ************************************ **********!*(<br>
/*    File: int_handler.c	*/<br>
/* Purpose: IRQ interrupt handler code	7<br>
/***** ********************** ****************************** *****/<br>
include "7092.hn        r to use with the Hynix HMS39C7092 7<br>
extern intlntCTI; extern int lntCT2;<br>
/* *t ********** * *« **** *********** *** ***** ** * ** **■** ** * ** ft****** *#* * * ** *** ***** **#<br>
*	IRQHandler<br>
*	*<br>
*	This function handles IRQ interrupts. In this example, these may come from *<br>
*	Timer 1 or Timer 2.<br>
*	*<br>
*	This handler simply clears the interrupt and sets corresponding flags.     *<br>
*	These flags are then checked by the main application.	*<br>
*	*<br>
*******************************************************************************/<br>
void	irq IRQ_Handler(void)<br>
{ unsigned status;<br>
status = *1SR;<br>
/* Deal with source of interrupt */<br>
if (status &amp;IB_TIMER1)<br>
{ *ISCR = IB_TIMER1; /* clear the interrupt 7<br>
}<br>
else if (status &amp;IB_TIMER2)<br>
{<br><br>
*1SCR = IB_TIMER2; /* clear the interrupt V } }<br>
FPC2010INTERFACE.C<br>
//.	<br>
//     Copyright (C) 2003 Fingerprint Cards AB. Ail Rights Reserved<br>
//	<br>
//<br>
// The information contained herein is confidential property of<br>
// Fingerprint Cards AB. The use, copying, transfer or disclosure of such<br>
// information is prohibited exceptby express written agreement with<br>
// Fingerprint Cards AB.<br>
//<br>
//.	<br>
II File: fpc2010interface.c<br>
//<br>
// Description:	interface driver for the FPC2010 ASIC.<br>
//<br>
// Hardware platform: FPC6430<br>
//<br>
//.	<br>
include "bpg.h" include "typdefs.h" ffinciude "utility.h"<br>
include "fpc201ubiomain.h" include nfpc2010interface.h" include "fpc2010registers.h" ffinciude "encapsulated_alg.h"<br><br>
/************* ************************ ****************,,»********** »*<br>
*	Retrieves the content of the Result RAM in FPC2010.<br>
*<br>
*	@param buffer - Memory area to fill with the Result RAM content<br>
******** ************************************************ *************/<br>
void UploadVerResultRAMContent(u_char 'buffer)<br>
{<br>
int current_byte;<br>
*VerResultAddrPointer = 0;<br>
for (currenLbyte = 0; current_byte 
{ buffeitcurrent_byte] = 'VerResultReadData;<br>
} } /* UploadVerResultRAMContent */<br>
/************* *** * *** ***** ** ********* * ** *** ***** ** ******** * ***** *** *<br>
*<br>
*	Loads FPC2010 with data to work with during verification.<br>
*	@param *tempiateBuffer - Memory area for the template data<br>
*<br>
*********************************************************** **********/ void DownloadVerData(u_char *templateBuffer)<br>
{<br>
u_charFPC2010_ver_dataEFPC2010_WORK_RAM_SIZE];<br>
int   currentjayte;<br>
PreVerify(templateBuffer, FPC2010_ver_data);<br><br>
*WorkRAMAddrPointer = 0;<br>
for (current_byte = 0; current_byte 
•WorkRAMWriteData = FPC2010_ver_data[currenr_byte];<br>
}<br>
} I* DownloadVerData */<br>
lie**** ****** *** *** *** ** ******** **.** * ** *** *** * ****** * ** *** ******** ** *<br>
*<br>
*	Uploads the result from an enrolment from FPC2010.<br>
*<br>
*	@param "enrolResult - Memory area to store the enrolment data.<br>
*<br>
♦MM*******************************************-*********************;<br>
void UploadEnrolResult(u_char *enrolResult)<br>
{<br>
Int currentjjyte;<br>
*WorkRAMAddrPointer = 0;<br>
for (current_byte = 0; current_byte 
{<br>
*enrolResult = *WorkRAMReadData;-<br>
enrol Result++; }<br>
} /* UploadEnrolResult V<br><br>
i*** ************************* *********** ****************************<br>
*<br>
*	Clears FPC2010 interrupt register.<br>
********************************************************************** i<br>
void ClearlRQReg(void)<br>
{<br>
int irq_reg_tmp = 0;<br>
irq_reg_tmp = *(volatile addr8) Interrupt;   //Read IRQ_REG in order to clear it irq_reg_tmp = '(volatile addr8) Interrupt;<br>
}/*Clear1RQReg*/<br>
/I*******************************************************************<br>
*<br>
*	Enables all the interrupts in FPC2010.<br>
*<br>
***** * ** ** **** ** *** *** *** ** ****** **** **** *** * *** ** ****** * ** *** * *******/<br>
void SetlRQMask{void)<br>
{<br>
int lrq_read;<br>
'InterruptMask = OxFE;	//Write IRQ mask FE = enable all<br>
irqj-ead      - *lnterruptMask; //Read back IRQ mask in order to verify.<br>
JTSetlRQMask*/<br>
J******* ****** **** ****** ** ******* ********* *** ** **** * * ** ******** *** ***<br>
*<br><br>
*	Perform a software reset for FPC2010.<br>
*<br>
**** *# * *** ****** # ***** *** ** **** **** ******** * *■*** ******* * * *** ********** i<br>
void SWResetfvoid)<br>
{ int irqmask = 0;<br>
irqmask     = '(volatile addr8) InterruptMask;<br>
*SwReset»1;<br>
irqmask     = '(volatile addr8) InterruptMask;<br>
} r SWReset 7<br>
(in* ***************** ****************************************** ****** *<br>
*	Sets up parameters for the line line sensor.<br>
*<br>
*	@param detect - Value for the line sensors DETECT register.<br>
*	@param drive - Value for the line sensors DRIVC register.<br>
' @param adcref - Value for the line sensors ADCREF register.<br>
********************************************************************* I void SetUpLi'neSensorStartUp(int detect,int drivc,int adcref) {<br>
ResetLineSensorQ; SetUpLineSensor{);   ■ SetUpLineSensorDETECT(detect);<br>
SetUpLineSensorDRIVC(drivc); SetUpLineSensorADCREF(adcref);<br>
} r SetUpLineSensorStartUp 7<br><br>
** **«*****«fc ****************** ************ **** ******* *************<br>
*	Sets up the parameters for the line sensor interface.<br>
*<br>
*********************************************************************<br>
void SetUpLineSensor{void) {<br>
•WaitCycles    - WAIT_REG_VALUE; *StartCyc!es = START_CYCLE_VALUE; XloseCycies   = CLOSE_CYCLE_VALUE; XlockDevisor= CLOCKJDEVISOR;<br>
}/*SetUpLineSensor*/<br>
J*****************************'************************************** *<br>
*	Reset the line sensor by writing to the Reset register.<br>
it*******************************************************************/ void ResetLineSensor(void)<br>
{<br>
*SensorReset = 1;<br>
// uncaLdelay(50); //Wait for reset to finish. delay(50); //Wait for reset to finish. } I* ResetLineSensor */<br>
)**** ************* ********************* **********■**+* *******+* ******<br><br>
*	Sets up the line sensor detect value.<br>
*	@param value - The value for the detect register.<br>
*<br>
*** * ** * ****** ***** * ************ *** *** *+** * ** * A-**-** ****** ********* ****<br>
void SetUpLineSensorDETECT(int value) {<br>
*SensorParameterJ-SB = (unsigned char)value; *SensorCommand      = WRITEJ3ETECT; PolllRQReg(IRQ_SENSOR_COMPLETE);<br>
} /* SetUpLineSensorDETECT 7<br>
*	Sets up the line sensor drive_c value.<br>
*	@param value - The value for the drivjc register.<br>
*<br>
*********************************************************************** void SetUpLlneSensorDRIVC(int value) {<br>
*SensorParameter_LSB = (unsigned char)value; *SensorCommand      = WRITE_DRIVE_C; PolllRQReg(lRQ_SENSOR_COMPLETE);<br>
} r SetUpLineSensorDRIVC 7<br>
I*******************************************************************<br><br>
*	Sets up the line sensor adc_ref value.<br>
it<br>
*	@param value - The value for the adc__ref register.<br>
**** * * * **** ft* * ** ****** ***** ** ***** *** ** *** *** ** *** *** **** *********** *i<br>
void SetUpLineSensorADCREFfint value) t<br>
*SensorParameterJ-SB = (unsigned char)value; *SensorCommand      = WR!TE_ADC__REF; Po!IIRQReg(IRQ_SENSOR_COMPLETE);<br>
} I* SetUpLineSensorADCREF 7<br>
*	Polls the Interrupt flags for the FPC2010 and returns after the flag<br>
*	has been set.<br>
*<br>
*	@param irq - One or more interrupt flags to poll (interrupt mask).<br>
*<br>
it*-************************************************************************/ void PolllRQReg(unsigned char irq)<br>
{<br>
unsigned char irq_regjmp;<br>
irq_reg_imp = (unsigned char)( irq &amp; *(volatile addrS) Interrupt);<br>
//Wait for IRQ flag to be set while (irq_reg Jmp =- 0)<br>
{<br><br>
ircL-re3__tmp = (unsigned char){ irq &amp; '(volatile addr8) Interrupt); i<br>
irq_reg_tmp = '(volatile addr8) interrupt; } r PolllRQReg V FPC2010BIOMAIN.C<br>
/*<br>
*	Smart Card pin code generator with finger print access control<br>
*	Control function for hardware FPC2010 with sensor FPC1030<br>
*	Copyright (C) 2001 DELTA IC Design, All Rights Reserved.<br>
*	SAuthor: Ibm $ :<br>
*<br>
*	$ld: prlntasm.v 1.12 2002/11/21 14:29:14 Ibm Exp $ :<br>
+<br>
7<br>
#inciude "bpg.h" #inciude "typdefs.h" include "utility.h"<br>
#include "fpc2010biomain.h" #include "fpc2010interface.h" #include "encapsu!ated_alg.h" ffinclude "fpc2Q10registers.h"<br>
*<br>
*	Turn on the MCK out dock. Starts the FPC2010.<br><br>
********************************** **********************!***** **(<br>
voidfpc2010On(void)<br>
{ *P9DR = *P9DR | FPC2010_RESET_MASK;     // De-assert reset pin *P6MR = *P6MR &amp; -FPC2010_CLOCK_MUX_MASK; // Set pin as clock output<br>
}/*fpc2010On*/<br>
/**** **** ********** ***** ** ** ** **** ******** ** **** * ********** ***** *<br>
*<br>
*	Turn off the MCK out clock. Stops the FPC2010.<br>
****** **************************** ******************** ***********<br>
voidfpc2010Off(void) {<br>
*P6MR = *P6MR | FPC2010_CLOCK_MUX_MASK; // Set pin as io pin *P6DDR = *P6DDR &amp; ~FPC2010_CLOCK_MASK; // Set io pin as output *P6DR = *P6DR &amp; ~FPC2010_CLOCKJ/IASK;   // Set data low<br>
*P9DR = *P9DR &amp; ~FPC2010_RESETJVIASK;   // Assert reset pin<br>
// This is done in order to set the LVDS IO in // FPC2010 in power down mode. The RESET_PIN // only resets FPC2010 if the clock is active.<br>
&gt;/*fpc2010OffV<br>
t**± * * ** ****** ** * *** ************ **** ** **** * ** * ************ *******<br>
*<br>
*	Initializes the FPC2010. Sets up the swipe sensor and<br>
*	uploads a register file necessary for the device's execution.<br><br>
voidfpc2010lnit(void)<br>
{<br>
unsigned char mem_cmd=0;<br>
fpc2010On();<br>
ClearlRQRegO;<br>
SWReset(); SetlRQMask();<br>
SetUpLineSensorStartUp(DETECT_STARTUP_VAL,	DRIVC_STARTUP_VAL,<br>
ADCREF_STARTUP_VAL);<br>
ClearlRQRegO; fpc2010LoadParameterFile(getJpc2010jDarameters(VERIFY_PARAMETERS));<br>
// dummy write to FPC2010 *FP_RAM_Cmd = mem_cmd;<br>
fpc20iooff();<br>
}/*fpc2010lnitV<br>
*<br>
*	Enrol a template into RAM.     "	■   -<br>
*<br>
*	@param templateBuffer - Memory area for the downloaded template data.<br>
*	@retum - TRUE: If enrolment succeeded.<br>
FALSE: Otherwise.<br><br>
**************** ************** *********** tit ******* ************ ********(<br>
bool fpc2010Enrol(u_char "templateBuffer)<br>
{<br>
unsigned int swipeLength;<br>
signed char pointOffset;<br>
u_char	enrolResult[FPC2010_WORK_RAM_SIZE];<br>
boo!        success;<br>
fpc2010On();<br>
CiearlRQReg();<br>
fpc2010LoadParameterFile(get_fpc2010j3arameters(ENROL_PARAMETERS));<br>
*ACHCmd = ACHCmd^ENROL;	// enrol command to FPC2010<br>
PolllRQReg(IRQ_ACH_COMPLETE);   // wait until user has finished swiping finger<br>
UploadEnro[Result(enrolResult);	// get enrolment result from FPC2010<br>
pointOffset = *AccPointOffset;	// get x-translation<br>
swipeLength = (TopLineLSB) + (TopLineMSB) * 256;	// get swipe length<br>
// create template from result data<br>
success    =    Create_Jemplate(enrolResult,    templateBuffer,    pointOffset     (short int)swipeLength);<br>
fpc2010Off();<br>
return success;<br>
f/*fpc2010EnrolV<br><br>
f**** **** ************************************************ ********** *********<br>
*	Verify a fingerprint against a template.<br>
*<br>
*	@param templateBuffer - Pointer to the template memory.<br>
*	@return - TRUE: If verification succeeded.<br>
FALSE: Otherwise.<br>
*<br>
it **** *** ***** * * ** **■* ***** *** ********* ** *** ****** ******* *** **** ******** *****{<br>
bool fpc2010Verify{u_char *templateBuffer)<br>
{<br>
unsigned int swipeLength;<br>
signed char pointOffset;<br>
u_char	verResult[FPC2010_VER_RESULT_RAM_SIZE];<br>
bool        success;<br>
fpc2010On();<br>
CleariRQRegO; fpc20lOLoadParameterFlle(geLfpc2010j3arameters(VERIFY_PARAMETERS));<br>
DownloadVerData(templateBuffer);       // download verification data to FPC2010<br>
•ACHCrhd = ACHCmd_VERlFY;-	// verify command to FPC2010<br>
//	enableFpcCounter();bysip<br>
PolitRQReg(IRQ_ACH_COMPLETE);	//  wait   until   user  has  finished<br>
swiping finger<br>
//	disableFpcCounterQ; by sip<br><br>
upioaaverKesultKAMContentfverResult);	// get result data from FPC2010<br>
pointOffset = (signed char) *AccPointOffset;	// get x-translation<br>
swipeLength = (*TopLineLSB) + (TopLlneMSB) * 256;	// get swipe length<br>
// match template against result data<br>
success = Match_Data(verResult, templateBuffer, pointOffset, {short int)swipeLength);<br>
fpc2010Off();<br>
return success;<br>
}/*fpc2010VerlfyV<br>
* Load register (parameter) file to FPC2010.<br>
*<br>
***** 4* ***** **4 *4 ************** **4* *********************** f<br>
void fpc2010LoadParameterFile(unsigned char 'parameters)<br>
{<br>
intcurrent__byte;<br>
'	*ParameterFilePointer = 0;<br>
for (current_byte = 0; currentlbyte 
{<br>
*ParameterFileWrite = "(parameters + currentjayte);<br>
&gt;<br>
} I* fpc2010LoadParameterFiie V<br><br>
D1SPLAY.C<br>
/* Display utilities 7<br>
#indude "string.h" #include "7092.h" include "bpg.h"<br>
#define DISP_DELAY 200<br>
//define macroes<br>
#define ENABLE_DISP_COM *DISP_DR = *DISP_DR &amp; ~DISP_NCSSEG_MASK; // Enable display<br>
com.<br>
#define DISABLE_D1SP_C0M *DISP_DR = *DISP_DR | DISP_NCSSEG_MASK; // Disable display<br>
com.<br>
extern void delay(int count); extern unsigned char disp_ram[8];<br>
static const char asciiQ = {<br>
0x00, 0x00, OxOO, 0x00, 0x00, 0x00, 0x00, 0x00,	// 0 - 7<br>
0x00, 0x00, 0x00, 0x00, OxOO, 0x00, 0x00, 0x00,	// 8 -15<br>
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	//16 - 23<br>
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, OxOO, 0x00,	//24 - 31<br>
0x00, 0x00, 0x00, 0x00, 0x00, OxOO, 0x00, 0x00,	// 32 - 39<br>
0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,	// 40 - 47<br>
0x7d, 0x60, Ox3e, 0x7a, 0x63, 0x5b, 0x4f, 0x70,	// 48 - 55<br>
0x7f, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// 56 - 63<br>
0x00, 0x77, 0x7f, 0x1d, 0x7d, 0x1f, 0x17, 0x5f,   // 64 - 71<br>
0x67, 0x60, 0x78, 0x00, OxOd, 0x00, 0x00, 0x7d,	// 72 - 79<br>
0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// 80 - 87<br>
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	// 88 - 95<br><br>
0x00, 0x00, 0x00, OxOe, Ox6e, Ox3f, 0x00, 0x00,	// 96 -103<br>
0x00, 0x00, 0x68, 0x00, 0x00, 0x00, 0x00, 0x4e,	//104 -111<br>
0x00, 0x00, 0x06, 0x00, OxOf, 0x00, 0x00, 0x00.	//112 -119<br>
0x00, 0x6b, 0x00, 0x00. 0x00, 0x00, 0x00, 0x00	//120 -127<br>
};<br>
I* reverse: reverse string s in place */ void reverse(char sQ) {<br>
char c; int i, j;<br>
for (i = 0, j = strlen(s)-1; i 
s[i] = s03; s[j] = c; } }<br>
/* itoa: convert n to characters in s */ void itoa(int n, char sQ) { int i, sign;<br>
if ((sign = n) 
n = -n;<br>
1 = 0;<br>
do {	// Generate digits in recverse order<br>
s[i++l = (char)(n % 10 + '0'); // Get next digit } while ((n /= 10) &gt; 0); // Delete it<br><br>
if (sign 
void atodispfchar sQ, unsigned char * data_ptr) {<br>
unsigned int i,j;<br>
j = strlen(s);<br>
for(K);l<j dataj ascii></j>
void Send_Disp(unsigned int data; unsigned int length) {<br>
unsigned int i; unsigned int bit;<br>
for (i=0; i<length i></length>
bit = data &amp; 0x01;	// mask out bit 0<br>
if (bit) {<br>
*DISP_DR = *DISPJ3R | DISP_DATASEG_MASK; // Setup data 1 } else { *DISPJ3R = *DISP_DR &amp; ~DISP_DATASEG_MASK; // Setup data 0<br>
}<br>
delay(DISP_DELAY);<br><br>
// write pulse<br>
*DISP_DR = *DISP_DR &amp; ~DISPJMWRSEG_MASK; // Neg. write edge delay(DISPJDELAY);<br>
*DISP_DR - *DISP_DR | DISP_NWRSEG_MASK; // Pos. write edge data - data » 1; } }<br>
void Disp_Write_Ram(unsigned char * data_ptr) {<br>
unsigned Int i;<br>
unsigned char data, temp;<br>
ENABLE_DlSP_COM; // Enable display com.<br>
data = 0x5;<br>
Send_Disp(data, 3); // send 3 bit command<br>
data = 0x0;<br>
Send_Disp(data, 6); // send 6 bit address<br>
for (i=0; i
}<br>
for (i=0; i
temp = (unsigned char)data_ptr[7-i];<br>
data = (unsigned char)(temp &amp; OxfO);<br>
data = (unsigned char)(data » 4);<br>
temp = (unsigned char)(temp « 4);<br>
data = (unsigned char)(data | (temp &amp; OxfO));<br>
Send_Disp((unsigned int)data, 8); // send 8 bit of display ram data<br><br>
}<br>
DISABLE_D1SP_C0M; // Disable display com. }<br>
void Disp_Send_Command(unsigned int data) {<br>
ENABLE_plSP_COM;    // Enable display com Send_Disp(data, 12); // Send commando DISABLEJ)ISP_COM;    // Disable display com }<br>
void write(char * s) {<br>
unsigned int i;<br>
for (i - 0; i 
atodisp(s, disp_ram);	// convert ascii to display symbols<br>
Disp_Write_Ram(disp_ram);	// write symbols to display ram<br>
}<br>
void displayjnit() {<br>
disp__ram[0] = 0x00; disp_ram[1] = 0x00; disp_ram[2] - 0x00; disp_ram[3] = 0x00; dispj-am[4] = 0x00; disp_ram[5] = 0x00;<br><br>
disp_/am[6] = 0x00; disp_ram[7] = OxOO;<br>
Disp_Send_Command(DISP_SYSJ=N);<br>
Disp_Send_Command(DISP_BIAS_COM); Disp_Send_Command(DISP_LCD__ON); }<br>
void display_test() {<br>
unsigned intj;<br>
unsigned long long * disp_ram_ptr;<br>
disp_ram_ptr = (unsigned long long *)&amp;disp_ram;<br>
disp_ram[0] = 0x01; disp_ram[1] = 0xO0; disp_ram[2]« 0x00; disp_ram[3] = 0x00; disp_ram[4] = 0x00; disp_ram[5] = 0x00; disp_ram[6] = 0x00; disp_ram[7] = 0x00;<br>
j = 64; do{<br>
Drsp_Wrte_Ram(disp_ram);<br>
*disp_ram_ptr - *disp_ram_ptr«1;<br>
} while 0-); }<br><br>
VECTORS.S<br>
;;; Copyright ARM Ltd 2001. All rights reserved.<br>
AREA Vect, CODE, READONLY<br>
; These are example exception vectors and exception handlers<br>
; Where there is ROM fixed at 0x0 (build_b), these are hard-coded at 0x0.<br>
; Where ROM/RAM remapping occurs (build_c), these are copied from ROM to RAM.<br>
; The copying is done automatically by the C library code inside __main.<br>
; This version puts a branch to an Interrupt Handler (IRQ_Handler in int_handler.c) ; in its exception vector table.<br>
, ***************** ; Exception Vectors<br>
; Note; LDR PC instructions are used here, though branch (B) instructions ; could also be used, unless the ROM is at an address &gt;32MB.<br>
ENTRY<br>
LDR	PC, Reset_Addr<br>
LDR	PC, Undefined_Addr<br>
LDR	PC, SWI_Addr	"<br>
LDR	PC, PrefetchJWdr<br>
LDR	PC, AborLAddr<br>
NOP	; Reserved vector<br>
LDR	PC, IRQ_Addr<br>
LDR	PC, FIQ_Addr<br><br><br><br>
END<br>
STACK.S<br>
;;; Copyright ARM Ltd 2001. All rights reserved.<br>
AREA   Stacks, DATA, NOINIT<br>
EXPORT top_of_stacks ; Create dummy variable used to locals stacks in memory top_of_stacks    SPACE   1<br>
END<br>
INIT.S<br>
;; Copyright ARM Ltd 2001. Ail rights reserved.<br>
This module performs ROM/RAM remapping (if required), initializes stack<br>
pointers and interrupts for each mode, and finally branches to	main in<br>
the C library (which eventually calls main()).<br>
On reset, the ARM core starts up in Supervisor (SVC) mode, in ARM state, with IRQ and FIQ disabled.<br>
AREA   Init, CODE, READONLY<br>
; — Set up if ROM/RAM remapping required<br><br>
GBLL ROM_RAM_REMAP ;ROM_RAM_REMAP   SETL {TRUE}; change to {FALSE} if remapping not required<br>
; — ensure no functions that use semihosting SWIs are linked in from the C library<br>
;;	IMPORT	use_no_semihosting_swi<br>
; — Standard definitions of mode bits and interrupt (I &amp; F) flags in PSRs<br>
ModeJJSR	EQU	0x10<br>
Mode_FIQ	EQU	0x11<br>
ModeJRQ	EQU	0x12<br>
Mode_SVC	EQU	0x13<br>
Mode_ABT	EQU	0x17<br>
ModeJJND	EQU	0x1B<br>
Mode_SYS	EQU	0x1 F; available on ARM Arch 4 and later<br>
l_Bit	EQU    0x80 ; when I bit is set, IRQ is disabled<br>
F_Bit	EQU     0x40 ; when F bit is set, FIQ is disabled<br>
; — System memory locations<br>
MEMCR                         EQU	0x09001010        ; Address of Core Module Control Register (write<br>
only)<br>
MEMSR                          EQU	0x0900100c         ; Address of Core Module Control Register (read<br>
only)<br>
Remap_bit   EQU     0x01	; Bit 0 is remap bit of CM_ctl<br>
BCR1          EQU    0x09000104	; Address of Bus Controller register for CS1<br>
MEMWlDTH_bit   EQU    0x100	; Bit 8 is external bus width<br>
WAITSTATES bit EQU     0x2	; Number of wait states is WAITSTATES bit+1<br><br>
; — Amount of memory (in bytes) allocated for stacks<br>
;Len_FIQ_Stack	EQU	8192<br>
;LenJRQ_Stack	EQU	8192<br>
;Len_ABT_Stack	EQU	8192<br>
;Len_UND_Stack	EQU	8192<br>
;Len_SVC_Stack	EQU	8192<br>
;Len_USR_Stack	EQU	8192<br>
Len_FIQ_Stack    EQU	0<br>
Len_IRQ_Stack   EQU	256<br>
Len_ABT_Stack   EQU	0<br>
Len_UND_Stack   EQU    0<br>
Len_SVC_Stack   EQU	256<br>
Len_USR_Stack    EQU	256<br>
Add lengths &gt;0 for FlQ_Stack, ABT_Stack, UND_Stack if you need them. Offsets will be loaded as immediate values. Offsets must be 8 byte aligned.<br><br><br>
Offset_FiQ_Stack	EQU<br>
Offset_IRQ_Stack	EQU<br>
Offset_ABT_Stack	EQU<br>
Offset_UND_Stack	EQU<br>
Offset_SVC_Stack	EQU<br>
Offset USR Stack	EQU<br><br>
0<br>
Offset_FlQ_Stack + Len_FIQ_Stack 0ffs6t_lRQ_Stack + LenJRG_Stack Offset_ABT_Stack + Len_ABT_Stack Offeet_UND_Stack + Len_UND_Stack Offset SVC Stack + Len SVC Stack<br><br>
ENTRY<br><br>
; — Perform ROM/RAM remapping, if required IF :DEF: ROM_RAM_REMAP<br>
; On reset, an aliased copy of ROM is at 0x0. ; Continue execution from 'real' ROM rather than aliased copy LDR    pc, =lnstruct_2<br>
Instruct^<br>
; Remap by setting Remap bit of the MEMCR/MEMSR register<br>
;       LDR    r1,=MEMSR<br>
;       LDR    rO, [ri]<br>
;      ORR    rO, rO, #Remap_bit<br>
;       LDR    r1,=MEMCR<br>
;       STR    rO, [r1]<br>
; RAM is now at OxO.<br>
; The exception vectors (in vectors.s) must be copied from ROM to the RAM<br>
; The copying is done later by the C library code inside	main<br>
; Set external bus width for CS1 to 8-bit LDR    r1,=BCR1 LDR    rO, [r1]<br>
ORR    rO, rO, #MEMWIDTH_bit ORR    rO, rO, #WAITSTATES_bit STR    rO, [r1]<br>
ENDIF   *	""     "<br>
EXPORT ResetJHandler<br>
Reset Handler<br><br>
Initialize stack pointer registers<br>
; Enter each mode in turn and set up the stack pointer<br>
IMPORT top_of_stacks      ; defined in stack.s and located by scatter file LDR    rO, =top_of_stacks<br>
;      MSR    CPSR_c, #Mode_FIQ:OR:l_Bit:OR:F_Bit; No interrupts ;      SUB    sp, rO, #Offset_FIQ_Stack<br>
MSR    CPSR_c, #Mode_IRQ:OR:l_Bit;OR:F_Bit; No interrupts SUB    sp, rO, #OffsetJRQ_Stack<br>
;      MSR    CPSR_c, #Mode_,ABT:OR:l_Bit:OR:F_Bit; No interrupts SUB    sp, rO, #Offset,ABT_Stack<br>
;      MSR    CPSR_c, #Mode_UND:OR:LBit:OR:F_Bit; No interrupts ;      SUB    sp, rO, #OffseLUND_Stack<br>
MSR    CPSR_c, #Mode_SVC:OR:l_Bit:OR:F_Bit; No interrupts SUB    sp, rO, #Offset_SVC_Stack<br>
; — Initialize critical 10 devices<br>
; — Now change to User mode and set up User mode stack, if needed<br>
MSR    CPSR_c, #Mode_USR:OR:F_Bit	; IRQs now enabled<br>
SUB    sp, rO, #Offset_USR_Stack  '<br>
IMPORT     main<br>
; — Now enter the C code<br>
B      	main   ; note use B not BL, because an application will never return this way<br><br><br><br>
WE CLAIM   :<br>
1.        A computer system for identifying a specific individual relative to said system using a biometric characteristic of said specific individual, comprising: i) at least one apparatus comprising :<br>
-	a housing defining an outer surface,<br>
-	a biometric sensor means for generating a first code in response to the detection of said biometric characteristic of said specific individual, said biometric sensor being mounted in said housing and being exposed at said outer surface,<br>
-	a controller means mounted in said housing and comprising a memory for storing said first code and a dynamic binary code conversion algorithm, said controller means being electrically connected to said biometric sensor means,<br>
-	a first communication means mounted in said housing and electrically connected to and controlled by said controller means for establishing communication between said apparatus and said computer system,<br>
-	a power supply means electrically connected to said biometric sensor means, said controller means, and said first communication means for the supply of electric power thereto,<br>
ii) said computer system comprising a first database containing said dynamic binary code conversion algorithm, and a second communication means for establishing communication between said computer system and said apparatus,<br>
2. The computer system as claimed in claim 1, said apparatus comprising a display means mounted in said housing and being exposed at said outer surface, said display means being electrically connected to said power supply means and said controller means and being controlled by said controller means, and being powered by said power supply means, said display means displaying said first binary code converted into an alphanumeric number, preferably a decimal number constituting a Pin code after verification of identity between said code and said first code.<br><br>
3.	A computer system for identifying a specific individual relative to said system<br>
using a biometric characteristic of said specific individual, comprising:<br>
i)        at least one apparatus comprising :<br>
-	a housing defining an outer surface,<br>
-	a biometric sensor means for generating a first code in response to the detection of said biometric characteristic of said specific individual, said biometric sensor being mounted in said housing and being exposed at said outer surface,<br>
-	a controller means mounted in said housing and comprising a memory for storing said first code and a dynamic binary code conversion algorithm, said controller means being electrically connected to said biometric sensor means,<br>
-	a display means mounted in said housing and being exposed at said outer surface, said display means being electrically connected to and being controlled by said controller means,<br>
-	a power supply means electrically connected to said biometric sensor means, said controller means, and said display means for the supply of electric power thereto,<br>
said computer system comprising a first database containing said dynamic binary code conversion algorithm, and a code input means, said controller means performing,<br>
4.	The computer system as claimed in claim 3, said apparatus comprising a first<br>
communication means mounted in said housing and electrically connected to and<br>
controlled by said controller means for establishing communication between said<br>
apparatus and said computer system, and said computer system comprising a second<br>
communication means for establishing communication between said computer system<br>
and said apparatus.<br><br>
5.	The computer system as claimed in any of the claims 1-4, said computer system comprising a second database comprising a sequence of binary codes generated sequentially by means of said dynamic binary code conversion algorithm, and said computer system comparing said first binary code with said sequence of binary codes contained in said second database for verifying the identity of said specific individual provided said first binary code is not matching said second binary code.<br>
6.	The computer system as claimed in any of the claims 1-5, said biometric sensor means being an iris scanner, a blood scanner, a DNA scanner, a voice identification scanner, a face recognition scanner, an array scanner for scanning the palm of said individual, an array scanner for scanning one hole finger or preferably a finger print scanner.<br>
7.	The computer system as claimed in any of the claims 1-6, said apparatus being a stand alone apparatus implemented as a credit card having the dimensions of a credit card conforming to the ISO standard (International Organisation of Standardisation), and said code being a Pin code.<br>
8.	The computer system as claimed in any of the claims 1-7, comprising encryption and decryption means controlled by said controller means for performing said communication from said controller means to and from said external computer system in encrypted state according to e. g. DES encryption or other public or non¬public encryption keys.<br>
9.	The computer system as claimed in any of the claims 1-8, said first and second communication means being a parallel communication interface, a serial communication interface, an SPI, an 12C, an USB, a wireless communication interface such as blue tooth, an infra red or RF communication.<br><br>
10.	A method of identifying a specific individual relative to a system using a<br>
biometric characteristic of said specific individual, the method comprising:<br>
- receiving a code from said biometric sensor means<br>
performing a comparison of said code with said first code stored in said memory and provided said comparison verifies the identity between said code and said first code,<br>
generating a first binary code by means of said dynamic binary code conversion algorithm;<br>
outputting said first binary code from said apparatus by means of said first communication means to said computer system,<br>
in the said computer system,<br>
receiving said first binary code from said apparatus by means of said second communication means;<br>
generating a second binary code by means of said dynamic binary code conversion algorithm and<br>
verifying the identity of said specific individual provided said second binary code matches said first binary code.<br>
11.	A method of identifying a specific individual relative to said system using a<br>
biometric characteristic of said specific individual, the method comprising; -<br>
receiving a code from said biometric sensor means;<br>
performing a comparison of said code with said first code stored in said memory;<br>
provided said comparison verifies the identity between said code and said first code generating a first binary code by means of said dynamic binary code conversion algorithm;<br>
displaying said first binary code converted into a an alphanumeric number, preferably a decimal number constituting a Pin code on said display means;<br>
when receiving said first Pin code input by means of said code input means, generating a second binary code by means of said binary code conversion algorithm and<br><br>
verifying the identity of said specific individual provided said second binary code matches said first binary code reconverted from said Pin code.<br>
12.	The method according to any of the claims 14 or 15, said biometric<br>
characteristic being detached by means of an iris scanner, a blood scanner, a DNA<br>
scanner, a voice identification scanner, and array scanner for scanning the palm of<br>
said individual, an array scanner for scanning one hole finger or preferably a finger<br>
print scanner.<br>
13.	The method according to any of the claims 14-16, comprising encrypting said<br>
communication between said controller means and said external computer system<br>
according to e. g. DES encryption or other public or non-public encryption keys.<br><br><br></rt__misc.h></stdio.h></pmuj></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGFic3RyYWN0LWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 abstract-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGNsYWltcy1kdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 claims-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGNvcnJlc3BvbmRlbmNlcyBvdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 correspondences others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGNvcnJlc3BvbmRlbmNlcyBwby5wZGY=" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 correspondences po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGRlc2NyaXBpdGlvbihjb21wbGV0ZWQpLWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 descripition(completed)-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGRlc2NyaXBpdGlvbihjb21wbGV0ZWQpLnBkZg==" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 descripition(completed).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGRyYXdpbmdzLWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 drawings-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGZvcm0tMjYucGRm" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IGZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjIwMy1jaGVucC0yMDA1IHBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">2203-chenp-2005 pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="230732-a-system-and-a-method-for-secured-data-communication-in-computer-networks-by-phantom-connectivity.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="230734-a-method-and-apparatus-for-reliable-reception-of-broadcast-multicast-content.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>230733</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2243/CHENP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>27-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>27-Feb-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>13-Sep-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUARD TECHNOLOGY ApS</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>ALGADE 44, DK-4000 ROSKILDE,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>CLEMMENSEN, UFFE</td>
											<td>BROVEJ 4E, DK-4000 ROSKILDE,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>JENSEN, SOREN, HALD</td>
											<td>VODSKOV BYVEJ 15, DK-9310 VODSKOV,</td>
										</tr>
										<tr>
											<td>3</td>
											<td>SERUP, LEIF</td>
											<td>MJELS BROVEJ 11, DK-9230 SVENSTRUP,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F1/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/DK04/00171</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-03-15</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>PA2003 00384</td>
									<td>2003-03-13</td>
								    <td>Denmark</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/230733-a-computer-system-and-an-apparatus-for-use-in-a-computer-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 11:32:18 GMT -->
</html>
