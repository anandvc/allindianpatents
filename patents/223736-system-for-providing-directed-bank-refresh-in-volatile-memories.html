<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/223736-system-for-providing-directed-bank-refresh-in-volatile-memories by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 04:52:43 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 223736:SYSTEM FOR PROVIDING DIRECTED BANK REFRESH IN VOLATILE MEMORIES</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">SYSTEM FOR PROVIDING DIRECTED BANK REFRESH IN VOLATILE MEMORIES</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A memory system is provided. The memory system includes a volatile memory having a number of banks and a memory controller configured to control the volatile memory to engage in an auto-refresh mode or a self-refresh mode. The memory controller is further configured to direct the volatile memory to perform an auto-refresh operation on a target bank. The remaining banks are available for access while the auto-refresh operation is being performed on the target bank.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT, 1970<br>
(39 of 1970)<br>
&amp;<br>
THE PATENTS RULES, 2003<br>
COMPLETE SPECIFICATION<br>
(See section 10, rule 13)<br>
"METHOD AND SYSTEM FOR PROVIDING DIRECTED BANK REFRESH IN VOLATILE MEMORIES"<br>
QUALCOMM INCORPORATED,<br>
an American company of 5775 Morehouse Drive , San Diego, California 92121-1714, United States of America<br>
The following specification particularly describes the invention and the manner in which it is to be performed.<br><br>
WO 2005/119691<br><br>
PCTAJS2005/018903<br><br>
METHOD AND SYSTEM FOR PROVIDING DIRECTED BANK REFRESH<br>
FOR VOLATILE MEMORIES<br>
BACKGROUND<br>
Related Applications<br>
[0000]	This application claims priority to U.S. Provisional Application No.<br>
60/575,334, filed May 27,2004.<br>
Field<br>
[0001]	The present disclosure relates generally to memory devices, and more<br>
specifically, to methods and systems for providing directed bank refresh for volatile<br>
memories.<br>
Background<br>
[0002]	Volatile memory is a storage medium that is generally structured as a<br>
number of arrays (or banks). Each bank is further arranged as a matrix of "memory cells" in rows and columns, with each column being further divided by the input/output (I/O) width of the memory. Locations within the memory are uniquely specified by bank, row and column. A memory controller may be used to retrieve data from the memory by indicating the data's bank, row and column location. For example, for a quad-bank 128Mb memory with a 16-bit external data bus, a possible logical address mapping includes a 9-bit column address, a 2-bit bank address and a 12-bit row address.<br>
[0003]	Prior to reading or writing, a memory location, the corresponding row<br>
must first be opened. The process of opening a row requires a minimum number of clock cycles, tRCD, which represents the row-to-column delay. Once a row is open, column addresses within that row can be read or written as desired. For some dynamic random access memories (DRAMs), such as synchronous DRAMs (SDRAMs), only one row per bank can be kept open at any one time; a subsequent memory access to be performed within the same bank but at a different row requires closing the current row and opening the new one.<br>
[0004]	In the case of dynamic volatile memories, each cell must be refreshed, or<br>
re-energized, periodically at an average interval, tREFI, in order to maintain data integrity. The cells have to be refreshed because they are designed around capacitors that store electrical charges, which may discharge over time. Refresh is the process of<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br>
recharging the cells in memory. Cells are generally refreshed one row at a time. A number of methods currently exist that are designed to refresh volatile memories. Some, if not all, of these methods incur high cost in performance and/or power. For example, there are two common methods or techniques that are generally used to control the refresh of volatile memories in modem digital systems. One method relies on the memory to keep track of the row and bank(s) that need to be refreshed using built-in refresh mechanisms that are available on the memory; the other method relies on the memory controller to keep track of the row and bank that need to be refreshed.<br>
[0005]	The first commonly used method is utilized by the auto-refresh and self-<br>
refresh functions of the volatile memories. These functions use the built-in refresh address of the memory. During active use of the memory, when a refresh cycle is required, the memory controller precharges all the banks, and then uses the auto-refresh command to tell the memory to issue an internal refresh cycle. Upon receiving the auto-refresh command, the memory increments the internal refresh address counter and executes the internal refresh cycle. In auto-refresh mode, the memory uses the refresh address in its internal refresh address counter to determine which rows/banks to perform the refresh cycle and cycle through the relevant rows. In one implementation, the internal refresh address counter includes a row address register and a bank address register. The bank address register is incremented to cycle through each of the memory banks with the carry-out of the bank address register causing the row address register to increment. Other implementations do not have a bank address register as all banks are simultaneously refreshed.<br>
[0006]	A   disadvantage   of   present   non-simultaneous   bank   auto-refresh<br>
implementations is that because the memory controller does not know which internal bank will be refreshed, the memory controller is required to close all open rows in each bank prior to issuing an auto-refresh command. As a result, the memory data bus availability during an auto-refresh sequence is zero. At best, this sequence requires tRp+tRfc+tRCD cycles, where tRP represents a row-precharge delay, tRFC represents the refresh cycle time and tRCD represents the row-to-column delay. For a 133 MHz memory, this could be 16 clock cycles (120 ns). These cycles are sometimes referred to as dead cycles since the memory data bus is not available during this period.<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br>
 [0007]	During periods of non-use, the memory controller may place the memory<br>
in the self-refresh mode. In the self-refresh mode, the memory uses its own internal clock and refresh address counter to generate refreshes to refresh the row(s) of the memory. This method is good for saving power during idle states since the self-refresh mode can be used. The self-refresh state uses a small amount of power and maintains the contents of the memory by refreshing the memory. Due to the small amount of power needed, this method is typically used for low power applications.<br>
[0008]	A second method is sometimes used to avoid the dead cycles on the<br>
memory data bus mentioned above. According to this second method, control of the refresh is effected via the memory controller. This method does not use any of the built-in refresh mechanisms that are available on the memory. Under this method, at regularly given intervals (tREFI), the memory controller explicitly generates refreshes by opening and closing rows in a sequential manner using bank/row address combinations. The refresh clock, which determines the refresh rate, and the bank/row address combinations are internal to the memory controller. This method is best for high speed/high performance applications. This method allows the memory controller to refresh a particular memory bank while permitting other memory banks to remain open for access, resulting in higher performance; reads and writes to other banks can generally continue in parallel and uninterrupted. The downside to this method is that during system power down or long idle states, when the memory controller is not refreshing the memory, the memory cannot be kept in a self-refresh state. As mentioned above, the self-refresh state is a built-in function of most volatile memories., Since the self-refresh function of the memory increments a refresh address (i.e., the row/bank address) stored in a refresh address counter in the memory, independent of the memory controller, the refresh address maintained by the memory is not consistent or synchronized with the memory controller.<br>
[0009]	Refresh operations can reduce performance of memory because each<br>
refresh cycle forces the memory into an idle state, during which data access is not available. For example, if a refresh cycle is required for a particular memory bank while such bank is in an active state, the bank has to be shut down to allow the refresh operation to take place. Shutting down the bank means that whatever data operations that were to be performed have to be delayed, hence, affecting system performance.<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br>
[0010]	Some existing schemes are available to reduce the performance impact of<br>
refresh operations. Such schemes typically involve using a higher than required refresh rate, so that more memory banks can be refreshed within a predetermined refresh period. By having more memory banks refreshed, the chances of having to shut down an active memory bank for refresh are reduced. Using a higher refresh rate, however, has its drawbacks. For example, an increase in refresh rate means memory becomes unavailable for access more often which, in turn, results in lower performance. Also, merely using a higher refresh rate does not always obviate the need to shut down an active memory bank when refresh is required; in some situations, an active memory bank has to be shut down regardless, thus, negating any benefits from using a higher refresh rate.<br>
[0011]	Hence, it would be desirable to provide more efficient methods and<br>
systems for providing directed bank refresh for volatile memories.<br>
SUMMARY<br>
[0012]	In one aspect of the present invention, a memory system includes a<br>
volatile memory having a plurality of banks, and a memory controller configured, to control the volatile memory to engage in an auto-refresh mode or a self-refresh mode, the memory controller further configured to direct the volatile memory to perform an auto-refresh operation on a target bank in the plurality of banks, wherein remaining banks in the plurality of banks are available for access while the auto-refresh operation is being performed on the target bank.<br>
[0013]	In another aspect of the present invention, a memory system includes a<br>
volatile memory having a plurality of banks, a bank address latch, a refresh clock and a refresh counter, the refresh counter further having a row address counter and a row increment counter, wherein the refresh clock is configured to control the refresh counter and the bank address latch, wherein the row increment counter is configured to increment the row address counter, and a memory controller configured to control the volatile memory to engage in an auto-refresh mode or a self-refresh mode, the memory controller further configured to direct the volatile memory to perform an auto-refresh operation on a target bank in the plurality of banks, the memory controller is further configured to load a bank address for the target bank into the bank address latch,<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br>
wherein the bank address stored in the bank address latch is usable by the volatile memory to identify the target bank for the auto-refresh operation, and wherein remaining banks in the plurality of banks are available for access while the auto-refresh operation is being performed on the target bank.<br>
[0014]	In yet another aspect of the present invention, a memory system includes<br>
a volatile memory having a plurality of banks and a bank address latch, means for controlling the volatile memory to engage in an auto-refresh mode or a self-refresh mode and directing the volatile memory to perform an auto-refresh operation on a target bank in the plurality of banks, means for loading a bank address for the target bank into the bank address latch, wherein the bank address stored in the bank address latch is usable by the volatile memory to identify the target bank for the auto-refresh operation, and wherein remaining banks in the plurality of banks are available for access while the auto-refresh operation is being performed on the target bank.<br>
[0015]	In a further aspect of the present invention, a method for effecting<br>
memory refresh for a volatile memory having a bank address latch and a plurality of banks, includes loading a bank address for a target bank into the bank address latch, and directing the volatile memory to perform an auto-refresh operation on a target bank in the plurality of banks using the bank address stored in the bank address latch, wherein remaining banks in the plurality of banks are available for access while the auto-refresh operation is being performed on the target bank.<br>
[0016]	It is understood that other embodiments of the present invention will<br>
become readily apparent to those skilled in the art from the following detailed description, wherein various embodiments of the invention are shown and described by way of illustration.- As will be realized, the invention is capable of other and different embodiments and its several details are capable of modification in various other respects, all without departing from the spirit and scope of the present invention. Accordingly, the drawings and detailed description are to be regarded as illustrative in nature and not as restrictive.<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0017]	Aspects of the present invention are illustrated by way of example, and<br>
not by way of limitation, in the accompanying drawings, wherein:<br>
[0018]	FIG. 1 is a simplified block diagram illustrating an arrangement that can<br>
be used to practice the directed refresh method according to the present disclosure; and<br>
[0019]	FIG. 2 is a simplified block diagram illustrating a volatile memory that<br>
can be used to practice the directed refresh method according to the present disclosure.<br>
DETAILED DESCRIPTION<br>
[0020]	The detailed description set forth below in connection with the appended<br>
drawings is intended as a description of various embodiments of the present invention and is not intended to represent the only embodiments in which the present invention may be practiced. The detailed description includes specific details for the purpose of providing a thorough understanding of the present invention. However, it will be apparent to those skilled in the art that the present invention may be practiced without these specific details. In some instances, well-known structures and components are shown in block diagram form in order to avoid obscuring the concepts of the present invention.<br>
[0021]	Various embodiments of a memory system will now be described.   In<br>
one embodiment, a directed refresh method is provided which improves data availability in a memory during refresh operations. FIG. 1 shows an arrangement 100 that can be used to practice the directed refresh method. As shown in FIG. 1, the directed refresh method may be practiced with a volatile memory 110 and a controller 120 configured to control the volatile memory 110. The volatile memory 110 can be, for example, a DRAM (dynamic random access memory), a SDRAM (synchronous DRAM), and various other types of DRAM, etc. Based on the disclosure and teachings provided herein, a person of ordinary skill in the art will appreciate how to practice the concepts associated with the present disclosure with other types of memories which require refresh operations. The directed refresh method may be effected via control logic or a processor (not shown) which controls the memory controller 120 and the volatile memory 110.   It should be understood that the control logic or processor may be<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br><br>
implemented as an independent module or integrated as part of another component, such as, the memory controller 120.<br>
[0022]	FIG. 2 further shows one embodiment of the volatile memory 110 that<br>
can be used to practice the directed refresh method. The volatile memory 110 may further include a refresh counter 200 having a row address counter 250 and a row increment counter 220, a refresh trigger 240, a bank address latch 230 and a number of banks 210.<br>
[0023]	The refresh trigger 240 may be used to control both the refresh counter<br>
200 and the bank address latch 230. The refresh trigger 240 is used by the volatile memory 110 to initiate a refresh operation either in the auto-refresh mode or self-refresh mode. For example, upon receiving an auto-refresh command from the memory controller 120 (see FIG. 1), the volatile memory 110 may direct the refresh trigger 240 to initiate the auto-refresh operation. The refresh trigger 240 can be, for example, a clock or other timing mechanisms.<br>
[0024]	The row address counter 250 may be used to store the target row address<br>
for the row that is to be refreshed. The bank address latch 230 may be used to store the target bank address for the specific bank containing the row that is to be refreshed.<br>
[0025]	The memory controller 120 may direct the volatile memory 110 to auto-<br>
refresh a specific memory bank within the volatile memory 110 while other memory banks remain available for access. For each auto-refresh cycle initiated by the memory controller 120, the bank address 270 may be loaded by the memory controller 120 (see FIG. 1) into the bank address latch 230. The bank address 270 is used to select one of the banks 210 for refresh. Because the memory controller 120 (see FIG.l) is aware of the specific bank to be refreshed, access to the other internal banks may continue without interruption. This tends to maximize the memory data bus utilization, reduces power consumption by avoiding unnecessary row close/open sequences, and serves to minimize transfer latency.<br>
[0026]	The row increment counter 220 may be initialized upon power-up or<br>
reset. The initialized value for the row increment counter 220 can be arbitrary. The row increment counter 220 causes the row address counter 250 to be incremented after a<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br>
predetermined number of auto-refresh operations have been performed. The row address counter 250 contains the target row address for a row that is to be refreshed. The row address counter 250 points to the same row in all the banks 210.<br>
[0027]	The memory controller 120 initiates each auto-refresh cycle by issuing<br>
an auto-refresh command to the volatile memory 110 and loading the bank address 270 for the bank to be refreshed into the bank address latch 230. Upon receiving the auto-refresh command, the volatile memory 110 uses the refresh trigger 240 to initiate each auto-refresh operation. The refresh trigger 240 causes the row increment counter 220 to increment. Cyclically, the row address counter 250 is incremented by a carry-out signal 260 from the row increment counter 220. For example, the row increment counter 220 may be a 2-bit counter, which means the row increment counter 220 repeats itself every four (4) refresh clock cycles; conversely, the row address counter 250 is incremented after every 4th auto-refresh operation. The target row address stored in the row address counter 250 and the bank address 270 stored in the bank address latch 230 are then used to refresh a specific row in the identified bank.<br>
[0028]	Since  the  target  row  address  changes periodically based  on  the<br>
predetermined number of auto-refresh operations and the memory controller 120 does not know when the row address counter 250 will be incremented, the memory controller 120 (see FIG. 1) issues auto-refresh commands in a consistent, sequential order with respect to the banks 210; in other words, the memory controller 120 loads the bank addresses of the banks 210 into the bank address latch 230 one at a time in a sequential manner during each auto-refresh cycle. As a result, the banks 210 are refreshed sequentially in successive auto-refresh cycles. For example, for the four (4) banks shown in FIG. 2, the refresh bank order could be either "3-2-1-0-3-2-1-0" or "0-1-2-3-0-1-2-3". One order does not have an advantage over the other. Therefore, either one can be used. In one implementation, the sequence "0-1 -2-3-0-1 -2-3-..." may be used. As will be further described below, choosing this sequence simplifies the transition into self-refresh mode.<br>
[0029]	The operation of the volatile memory 110 as shown in FIG. 2 is further<br>
illustrated in an example as follows. In this example, the initial value in the row increment counter 220 is assumed to be zero (0) and the carry-out signal 260 of the row<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br>
increment counter 220 is activated after every 4th auto-refresh operation. The memory controller 120 (see FIG. 1) issues an auto-refresh command to the volatile memory 110 and loads the bank address 270 for the bank 210a into the bank address latch 230 to initiate a first auto-refresh cycle. Upon receiving the auto-refresh command, the volatile memory 110 directs the refresh trigger 240 to initiate an auto-refresh operation. During the auto-refresh operation, the row increment counter 220 is incremented to a value of one (1). In this instance, the carry-out signal 260 is not activated and the row address counter 250 is not incremented. The target row address and the bank address currently stored in the row address counter 250 and the bank address latch 230 respectively are then used to refresh a specific row in the bank 210a.<br>
[0030]	Subsequently, the memory controller 120 (see FIG. 1) issues another<br>
auto-refresh command to the volatile memory 110 and loads the bank address 270 for the bank 210b into the bank address latch 230 to initiate a second auto-refresh cycle. Similarly, upon receiving the second auto-refresh command, the volatile memory 110 directs the refresh trigger 240 to initiate another auto-refresh operation. During this auto-refresh operation, the row increment counter 220 is incremented to a value of two (2). Again, the carry-out signal 260 is not activated and the row address counter 250 is not incremented. The target row address and the bank address currently stored in the row address counter 250 and the bank address latch 230 respectively are then used to refresh a specific row in the bank 210b. It should be noted that since the row address counter 250 is not incremented, the target row address used in this auto-refresh operation is the same as the one used in the last auto-refresh operation. However, for this auto-refresh operation, the bank address stored in the bank address latch 230 is different in that a different bank 210b is identified. As a result, the same row in a different bank 210b (as opposed to bank 210a) is refreshed.<br>
[0031]	Similarly, it will be appreciated that for the 3d and 4th auto-refresh<br>
cycles, the row address counter 250 is not incremented (since the carry-out signal 260 of the row increment counter 220 is not activated). Consequently, the same row in different banks 210c and 210d are refreshed during the 3d and 4th auto-refresh cycles.<br>
[0032]	For the 5th auto-refresh cycle, the bank address 270 loaded by the<br>
memory controller 120 (see FIG. 1) into the bank address latch 230 points back to the<br><br>
WO 2005/119691<br><br>
PCT/TJS2005/018903<br><br>
11<br>
bank 210a. Furthermore, the carry-out signal 260 of the row increment counter 220 is now activated since four (4) auto-refresh operations have already been performed. The carry-out signal 260, in turn, increments the row address counter 250 thereby moving the target row address to a new row for refresh. This same new row is then refreshed for all four (4) banks 210 during successive auto-refresh cycles.<br>
[0033]	When the volatile memory 110 is commanded into self-refresh mode, the<br>
volatile memory 110 begins to generate refreshes internally using the bank address currently stored in the bank address latch 230 from the point where the memory controller 120 left off issuing the last auto-refresh command to the volatile memory 110. This is rendered possible because, as previously mentioned, the memory controller 120 issues auto-refresh commands in a sequential manner.<br>
[0034]	Subsequently, following each refresh in self-refresh mode, the output of<br>
the bank address latch 230 is incremented. In effect, the bank address latch 230 becomes a counter. Hence, when in the self-refresh mode, the bank address latch 230 is incremented periodically and used to. cycle through the banks 210; and the row increment counter 220 is also incremented periodically which, in turn, increments the row address counter 250 containing the target row address for a row to be refreshed, thereby allowing rows to be cycled through in the banks 210.<br>
[0035]	When exiting the self-refresh mode, the volatile memory 110 internally<br>
resets or clears the row increment counter 220. This resynchronizes the volatile memory 110 and the memory controller 120 and ensures that the row represented by the current target row address will be refreshed in all the banks 210. By resetting the row increment counter 220, the volatile memory 110 ensures that the row address counter 250 is only incremented after the predetermined number of auto-refresh operations have been performed, which means that the row represented by the current target row address is refreshed in all the banks 210.<br>
[0036]	Also, the memory controller 120 issues a number of auto-refresh<br>
commands within one (1) average refresh period (tREFI)after the volatile memory 110 exits the self-refresh mode. Since the memory controller 120 does not know which bank was last refreshed by the volatile memory 110 prior to exiting the self-refresh<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br><br>
mode, these auto-refresh commands are used to ensure that all the banks 210 are refreshed within one (1) average refresh period tREFI), which conversely ensures that data integrity is maintained and no data is lost. The number of auto-refresh commands that are to be issued within one (1) average refresh period (tREFI)depends on the number of banks 210 in the volatile memory 110. For example, the number of auto-refresh commands to be issued subsequent to the self-refresh mode exit is four (4) for the volatile memory 110 shown in FIG. 2. The average refresh period (tREFI)may vary depending on a particular volatile memory. Based on the disclosure and teachings provided herein, a person of ordinary skill in the art will appreciate how to implement the row increment counter 220 and determine the appropriate number of auto-refresh commands to be issued after exit from self-refresh mode in accordance with the present disclosure.<br>
[0037]	It should be noted that issuing the auto-refresh commands within one (1)<br>
average refresh period (tREFI)after exit from the self-refresh mode is optional, if the memory controller 120 implements a refresh-ahead scheme and is at least a number of refreshes ahead prior to entering the self-refresh mode. For example, with the volatile memory 110 as shown in FIG. 2, there is no need to issue the auto-refresh commands within one (1) average refresh period (tREFI)after exit from the self-refresh mode if at least four (4) refreshes have been performed ahead prior to entering the self-refresh mode. A number of refresh-ahead schemes are known in the art. Based on the disclosure and teachings provided herein, a person of ordinary skill in the art will appreciate how to incorporate a refresh-ahead scheme for use in connection with the present disclosure.<br>
[0038]	The   methods   or   algorithms   described   in   connection   with   the<br>
embodiments disclosed herein may be embodied directly in hardware, in a software module executable by a processor, or in a combination of both, in the form of control logic, programming instructions, or other directions. A software module may reside in RAM memory, flash memory, ROM memory, EPROM memory, EEPROM memory, registers, hard disk, a removable disk, a CD-ROM, or any other form of storage medium known in the art. A storage medium may be coupled to the processor such that the processor can read information from, and write information to, the storage medium. In the alternative, the storage medium may be integral to the processor.<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br><br>
[0039]	The previous description of the disclosed embodiments is provided to<br>
enable any person skilled in the art to make or use the present invention. Various modifications to these embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments without departing from the spirit of scope of the invention. Thus, the present invention is not intended to be limited to the embodiments shown herein, but is to be accorded the full scope consistent with the claims, wherein reference to an element in the singular is not intended to mean "one and only one" unless specifically so stated, but rather "one or more". All structural and functional equivalents to the elements of the various embodiments described throughout this disclosure that are known or later come to be known to those of ordinary skill in the art are expressly incorporated herein by reference and are intended to be encompassed by the claims. Moreover, nothing disclosed herein is intended to be dedicated to the public regardless of whether such disclosure is explicitly recited in the claims. No claim element is to be construed under the provisions of 35 U.S.C. §112, sixth paragraph, unless the element is expressly recited using the phrase "means for" or, in the case of a method claim, the element is recited using the phrase "step for".<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br>
WHAT IS CLAIMED IS:<br>
1.	A memory system comprising:<br>
a volatile memory having a plurality of banks; and<br>
a memory controller configured to control the volatile memory to engage in an auto-refresh mode or a self-refresh mode, the memory controller further configured to direct the volatile memory to perform an auto-refresh operation on a target bank in the plurality of banks;<br>
wherein remaining banks in the plurality of banks are available for access while the auto-refresh operation is being performed on the target bank.<br>
2.	The system of claim 1 wherein the volatile memory further includes a<br>
bank address latch, a refresh trigger and a refresh counter, the refresh counter further<br>
having a row address counter and a row increment counter;<br>
wherein the refresh trigger is configured to control the refresh counter and the bank address latch;<br>
wherein the row increment counter is configured to increment the row address counter;<br>
wherein the memory controller is further configured to load a bank address for the target bank into the bank address latch; and<br>
wherein the bank address stored in the bank address latch is used by the volatile memory to identify the target bank for the auto-refresh operation.<br>
3.	The system of claim 2 wherein the row increment counter is configured to be incremented each time an auto-refresh operation is performed.<br>
4.	The system of claim 3 wherein the row increment counter is further configured to increment the row address counter after a predetermined number of auto-refresh operations have been performed; and<br>
wherein the row address counter includes a row address that is usable to identify a row in the target bank for the auto-refresh operation.<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br>
15<br>
5.	The system of claim 4 wherein the memory controller is further configured to direct the volatile memory to perform auto-refresh operations on the plurality of banks in a sequential manner.<br>
6.	The system of claim 5 wherein upon the volatile memory entering into the self-refresh mode, the volatile memory is further configured to generate one or more self-refreshes using a bank address stored in the bank address latch; and<br>
wherein the bank address stored in the bank address latch is previously provided by the memory controller to direct the volatile memory to perform the auto-refresh operation on the target bank.<br>
7.	The system of claim 6 wherein the volatile memory is further configured to increment the bank address latch after each self-refresh.<br>
8.	The system of claim 7 wherein upon exiting the self-refresh mode, the volatile memory is further configured to reset the row increment counter thereby resynchronizing the volatile memory and the memory controller.<br>
9.	The system of claim 8 wherein the memory controller is further configured to issue a predetermined number of refreshes within one average refresh period upon the volatile memory exiting from the self-refresh mode.<br><br>
10.	The system of claim 9 wherein the memory controller is further configured to avoid issuing the predetermined number of refreshes within one average refresh period upon the volatile memory exiting from the self-refresh mode if a number of advanced refreshes have already been performed prior to the volatile memory entering the self-refresh mode.<br>
11.	The system of claim 1 wherein the volatile memory is one of a dynamic random access memory (DRAM) or a synchronous DRAM.<br><br>
WO 2005/119691<br><br>
PCT7US2005/018903<br><br>
12.	A memory system comprising:<br>
a volatile memory having a plurality of banks, a bank address latch, a refresh clock and a refresh counter, the refresh counter further having a row address counter and a row increment counter, wherein the refresh clock is configured to control the refresh counter and the bank address latch, wherein the row increment counter is configured to increment the row address counter; and<br>
a memory controller configured to control the volatile memory to engage in an auto-refresh mode or a self-refresh mode, the memory controller further configured to direct the volatile memory to perform an auto-refresh operation on a target bank in the plurality of banks, the memory controller further configured to load a bank address for the target bank into the bank address latch;<br>
wherein the bank address stored in the bank address latch is usable by the volatile memory to identify the target bank for the auto-refresh operation; and<br>
wherein remaining banks in the plurality of banks are available for access while the auto-refresh operation is being performed on the target bank.<br>
13.	The system of claim 12 wherein the row increment counter is configured<br>
to be incremented each time an auto-refresh operation is performed;<br>
wherein the row increment counter is further configured to increment the row address counter after a predetermined number of auto-refresh operations have been performed; and<br>
wherein the row address counter includes a row address that is usable to identify a row in the target bank for the auto-refresh operation.<br>
14.	The system of claim 13 wherein the memory controller is further configured to direct the volatile memory to perform auto-refresh operations on the plurality of banks in a sequential manner.<br>
15.	The system of claim 14 wherein upon the volatile memory entering into the self-refresh mode, the volatile memory is further configured to perform one or more self-refresh operations using the bank address stored in the bank address latch; and<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br>
wherein the bank address stored in the bank address latch is previously provided by the memory controller to direct the volatile memory to perform the auto-refresh operation on the target bank.<br>
16.	The system of claim 15 wherein the volatile memory is further configured to increment the bank address latch after each self-refresh operation.<br>
17.	The system of claim 16 wherein upon exiting the self-refresh mode, the volatile memory is further configured to reset the row increment counter thereby resynchronizing the volatile memory and the memory controller.<br>
18.	The system of claim 17 wherein the memory controller is further configured to issue a predetermined number of refreshes within one average refresh period upon the volatile memory exiting from the self-refresh mode.<br>
19.	The system of claim 18 wherein the memory controller is further configured to avoid issuing the predetermined number of refreshes within one average refresh period upon the volatile memory exiting from the self-refresh mode if a number of advanced refreshes have already been performed prior to the volatile memory entering the self-refresh mode.<br>
20.	The system of claim 12 wherein the volatile memory is one of a dynamic random access memory (DRAM) or a synchronous DRAM.<br>
21.	A memory system comprising:<br>
a volatile memory having a plurality of banks and a bank address latch;<br>
means for controlling the volatile memory to engage in an auto-refresh mode or a self-refresh mode and directing the volatile memory to perform an auto-refresh operation on a target bank in the plurality of banks;<br>
means for loading a bank address for the target bank into the bank address latch;<br>
wherein the bank address stored in the bank address latch is usable by the volatile memory to identify the target bank for the auto-refresh operation; and<br><br>
WO 2005/119691<br><br>
PCT/US2005/018903<br><br>
wherein remaining banks in the plurality of banks are available for access while the auto-refresh operation is being performed on the target bank.<br>
22.	The system of claim 21 wherein the volatile memory further comprises a<br>
row increment counter and a row address counter; and the system further comprising:<br>
means for incrementing the row increment counter each time an auto-refresh operation is performed; and<br>
wherein the row increment counter is further configured to increment the row address counter after a predetermined number of auto-refresh operations have been performed; and<br>
wherein the row address counter includes a row address that is usable to identify a row in the target bank for the auto-refresh operation.<br>
23.	The system of claim 22 further comprising:<br>
means for directing the volatile memory to perform auto-refresh operations on the plurality of banks in a sequential manner.<br>
24.	The system of claim 23 wherein upon the volatile memory entering into<br>
the self-refresh mode, the volatile memory is further configured to perform one or more<br>
self-refresh operations using the bank address stored in the bank address latch; and<br>
wherein the bank address stored in the bank address latch is previously provided by the means for loading the bank address to direct the volatile memory to perform the auto-refresh operation on the target bank.<br>
25.	The system of claim 24 wherein the volatile memory is further<br>
configured to increment the bank address latch after each self-refresh operation.<br>
26.	The system of claim 25 wherein upon exiting the self-refresh mode, the volatile memory is further configured to reset the row increment counter thereby resynchronizing the volatile memory and the means for controlling the volatile memory.<br>
27.	A method for effecting memory refresh for a volatile memory having a bank address latch and a plurality of banks, comprising:<br><br>
WO 2005/119691<br>
loading a bank address for a target bank into the bank address latch; and directing the volatile memory to perform an auto-refresh operation on a<br>
target bank in the plurality of banks using the bank address stored in the bank address<br>
latch;<br>
wherein remaining banks in the plurality of banks are available for access<br>
while the auto-refresh operation is being performed on the target bank.<br>
28.	The method of claim 27 further comprising:<br>
incrementing a row increment value each time an auto-refresh operation is performed; and<br>
incrementing a row address value after the row increment value has been incremented to a predetermined value, the predetermined value being dependent on a predetermined number of auto-refresh operations that have been performed.<br>
29.	The method of claim 28 further comprising:<br>
directing the volatile memory to perform auto-refresh operations on the plurality of banks in a sequential manner.<br>
30.	The method of claim 29 further comprising:<br>
directing the volatile memory to engage in a self-refresh mode and perform one or more self-refresh operations using the bank address stored in the bank address latch;<br>
wherein the bank address is previously used by the volatile memory to perform the auto-refresh operation on the target bank.<br>
31.	The method of claim 30 further comprising:<br>
incrementing the bank address latch after each self-refresh operation.<br>
32.	The method of claim 31 further comprising:<br>
resetting the row increment value upon the volatile memory exiting the self-refresh mode.<br><br>
WO 2005/1 J96i)I<br><br>
PC17US2005/018903<br><br>
33.      The method of claim 32 further comprising:<br>
issuing a predetermined number of refreshes within one average refresh period upon the volatile memory exiting the self-refresh mode.<br><br><br>
Dated this 6th day of December, 2006<br><br>
RSAR<br>
OFK&amp;S PARTNERS AGENT FOR THE APPLICANTS<br><br>
21<br>
ABSTRACT<br>
"METHOD AND SYSTEM FOR PROVIDING DIRECTED BANK REFRESH FOR VOLATILE<br>
MEMORIES"<br>
A memory system is provided. The memory system includes a volatile memory having a number of banks and a memory controller configured to control the volatile memory to engage in an auto-refresh mode or a self-refresh mode. The memory controller is further configured to direct the volatile memory to perform an auto-refresh operation on a target bank. The remaining banks are available for access while the auto-refresh operation is being performed on the target bank.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWFic3RyYWN0KDEzLTA1LTIwMDgpLmRvYw==" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-abstract(13-05-2008).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWFic3RyYWN0LSgxMy0wNS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-abstract-(13-05-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWFic3RyYWN0LmRvYw==" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-abstract.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWNhbmNlbGxlZCBwYWdlcygxMy0wNS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-cancelled pages(13-05-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWNsYWltKGdyYW50ZWQpLSgxMy0wNS0yMDA4KS5kb2M=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-claim(granted)-(13-05-2008).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWNsYWltKGdyYW50ZWQpLSgxMy0wNS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-claim(granted)-(13-05-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWNsYWltcy5kb2M=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-claims.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWNvcnJlc3BvbmRhbmNlLXJlY2VpdmVkLnBkZg==" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-correspondance-received.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWNvcnJlc3BvbmRlbmNlKDEzLTA1LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-correspondence(13-05-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWNvcnJlc3BvbmRlbmNlKGlwbyktKDE1LTA5LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-correspondence(ipo)-(15-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWRyYXdpbmctKDEzLTA1LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-drawing-(13-05-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0gMSgxMy0wNS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form 1(13-05-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1NVU1OUC0yMDA2LUZPUk0gMTYoMjQtOS0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">1503-MUMNP-2006-FORM 16(24-9-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0gMTgoMDctMTItMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form 18(07-12-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0gMihncmFudGVkKS0oMTMtMDUtMjAwOCkuZG9j" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form 2(granted)-(13-05-2008).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0gMihncmFudGVkKS0oMTMtMDUtMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form 2(granted)-(13-05-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0gMjYoMDYtMDMtMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form 26(06-03-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0gMygwNi0xMi0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form 3(06-12-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0gMygxMS01LTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form 3(11-5-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0gMygxMy0wNS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form 3(13-05-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0tMi5kb2M=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form-2.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0tMjYucGRm" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0tcGN0LWliLTMwNC5wZGY=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form-pct-ib-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0tcGN0LWliLTMxMS5wZGY=" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form-pct-ib-311.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0tcGN0LWlzYS0yMjAucGRm" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form-pct-isa-220.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LWZvcm0tcGN0LWlzYS0yMzcucGRm" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-form-pct-isa-237.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LXBjdC1zZWFyY2ggcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-pct-search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMy1tdW1ucC0yMDA2LXBldGl0aW9uIHVuZGVyIHJ1bGUgMTM3KDEzLTA1LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">1503-mumnp-2006-petition under rule 137(13-05-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="223735-a-method-to-rejuvenate-a-consumed-tantalum-sputtering-target.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="223737-active-compound-composition-comprising-trifloxystrobin-compound.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>223736</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1503/MUMNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>06/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>06-Feb-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>22-Sep-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>07-Dec-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 Morehouse Drive, San Diego, California 92121-1714,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>REMAKLUS, Perry, Willmann Jr.</td>
											<td>American citizen of 5313 Inglewood Lane, Raleigh, NC 27609</td>
										</tr>
										<tr>
											<td>2</td>
											<td>WALKER, Robert, Michael</td>
											<td>American citizen of 9000 Deerland Grove Drive, Raliegh, NC 27615</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G11C11/406</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2005/018903</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-05-26</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/575,334</td>
									<td>2004-05-27</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>10/982,038</td>
									<td>2004-11-05</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/223736-system-for-providing-directed-bank-refresh-in-volatile-memories by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 04:52:44 GMT -->
</html>
