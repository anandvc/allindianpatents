<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/215085-a-data-processing-apparatus-and-a-method-of-operating-the-same by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:09:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 215085:&quot;A DATA PROCESSING APPARATUS AND A METHOD OF OPERATING THE SAME&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;A DATA PROCESSING APPARATUS AND A METHOD OF OPERATING THE SAME&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The present invention provides a data processing apparatus comprising: a plurality of registers for storing data items to be processed; a processor for processing instructions to be applied to data items stored in said plurality of registers; and register remapping logic for converting a logical register reference within a preselected set of instructions to a physical register reference identifying the register containing the data item required for processing by the processor. By this approach, a remapping instruction need only be executed once in order for the remapping to be applied to a desired number of instructions.&amp;nbsp;This is in contrast to prior art techniques, where subsequent to a remapping instruction being executed, the remapping is applied to all subsequent instructions, ie. a desired number of instructions cannot be selected. The invention is particularly advantageously employed in apparatus arranged to repeat an instruction loop, the instruction loop including said preselected set of instructions. In such cases, loop hardware used to manage the repeat instruction can be arranged to update the register remapping logic each time the instruction loop is repeated, and hence the remapping instruction used to configure the register remapping logic is only executed once prior to the repeat instruction being executed.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>The present invention relates to a data processing apparatus and a method of operating the same.<br>
The present invention relates to register addressing in a data processing apparatus, and is particularly relevant to the field of digital signal processing, although its use is not restricted to digital signal processing.<br>
Typically, a data processing apparatus, such as a microprocessor, is arranged to apply instructions received to data items read from memory, A processor core is provided within the microprocessor to process the instructions, and generally the microprocessor will have a plurality of registers in which data items are preloaded prior to them being required by the processor core. As the instructions are received by the microprocessor, they will typically pass through an instruction decoder before being passed on to the processor core for processing. The processor core with then apply the decoded instruction to the relevant data item read from its registers. The result of the processed instruction can then be written back to one of the registers, or provided directly to a memory such as a cache memory.<br>
It is often the case in data processing apparatus that a specific data item is required for a number of instructions. Hence, that data item must be retained in one of the registers until all such instructions have been processed, and the instructions must all refer to the particular register in which that data item is located. Additionally, it is common for a range of instructions (hereafter referred to as an instruction loop) to be repeated a number of times, and for certain data items to be reused by different instructions within the instruction loop. This is particularly commonplace in digital signal processing apparatus, where algorithms such as a block filter algorithm contain an instruction loop which needs to be repeated a number of times in order to be applied to a set of data items. Any particular data item may be used a number of times by different instructions within the instruction loop.<br>
Instruction loops are used extensively in the relatively complex arithmetic and logical operations that digital signal processing apparatus are required to perform on often high volumes of data in order to produce a real time output data stream. Typical applications of digital signal processing techniques include mobile telephones required to perform real time transformation between analogue audio signals and<br>
coded digital data for transmission.<br>
An instruction will typically include one or more operands identifying registers containing the data items required by the instruction. For example, a typical instruction may include two source operands and one destination operand, identifying two data items required by the instruction, and a register in to which the result of the instruction should be placed. In situations where the instruction forms part of an instruction loop to be applied repetitively to a set of data items as discussed above, it is necessary for each instruction's operand to refer to the correct register every time the instruction is executed. This requirement often means that the same instruction has to be reproduced a number of times in the instruction loop code to refer to different registers each time. For example, if four data items are loaded in to the registers and, as part of an instruction loop, an instruction has to be applied to each of these"four data items, then the instruction has to be reproduced four times within the instruction loop, the operand of the instruction referring to a different register each time. This clearly has a detrimental effect on code density.<br>
In microprocessor design, it has been known in certain situations to use the concept of logical register references, and to then map these to actual physical register references. For example, superscalar processors often implement register renaming to allow speculative and out of order execution of instructions. The processor has more registers than the programmer's model provides, and a mapping table is employed to map the logical registers to their current physical equivalents. When the processor speculatively executes instructions it assigns physical register numbers to hold the results. Other instructions may also speculatively read these results. Several possible instruction 'flows' may thus execute in parallel. At some point, the processor will determine which one of the multiple streams is the correct one, generally based on the outcome of a conditional branch. At that point the mapping table is permanently updated and the incorrect versions of any registers are discarded. The purpose of this register renaming is to increase instruction throughput whilst being completely transparent to the programmer. It will be apparent that it does not help with the above problem of code density.<br>
As another example of the use of logical and physical register references, the<br>
Advanced Micro Devices (AMD's) Am29200 microprocessor incorporates 192 general purpose registers. 128 of these registers are designated as local registers, and an additional register is designated as a local register stack pointer, the stack pointer register providing an offset into the 128 local registers. Hence, whenever any instruction references a local register, it uses the value of the stack pointer register to calculate an absolute register number. Thus, for example, if an instruction wishes to access local register 1 (the local register sequence starting with local register 0), and the stack pointer points to absolute register number 131 (this actually being the 4th register in the sequence of 128 local registers according to the Am29200 design), the instruction will actually access the register identified by absolute register number 132.<br>
An instruction can be executed on the Am29200 microprocessor to change the value in the stack pointer register, after which the revised value in the stack pointer register will be used for any instructions referencing the local registers. This mapping of the register requested by the instruction to the absolute register number within the 128 local registers will be employed for every subsequent instruction until another instruction is executed to alter the stack pointer register.<br>
Hence it can be seen that the above AMD design allows a certain degree of remapping in instances where an instruction needs to be repeated for a number of different data items in different registers. However, it requires that a separate instruction be issued to change the value in the stack pointer register each time the register identified in the operand of an instruction is to be mapped to a different local register. This causes significant overhead in certain situations, for example where an instruction loop is to be repeated a number of times upon a shifted set of data items, such as is typical in digital signal processing apparatus. The overhead becomes particularly unacceptable when the instruction loop only contains a small number of instructions, since prior to the loop being repeated, a separate instruction is required to change the value in the stack pointer register. Hence, for example, if a single instruction is to be repeated ten times so as to be applied to data items 1 to 10, then prior to each execution of the instruction, a separate instruction would be required to change the value in the stack pointer register. Hence, an instruction loop containing<br>
a single instruction effectively becomes an instruction loop having two instructions, this clearly adding a large overhead to the execution of the instruction loop.<br>
According to the present invention, there is provided a data processing apparatus comprising: a plurality of registers for storing data items to be processed; a processor for processing instructions to be applied to data items stored in said plurality of registers; and register remapping logic for converting a logical register reference within a preselected set of instructions to a physical register reference identifying the register containing the data item required for processing by said processor.<br>
According to the present invention, register remapping logic is provided to perform register remapping for a preselected set of instructions. Preferably, the remapping logic is configurable by a remapping instruction that is executed prior to said preselected set of instructions. It can be envisaged that the remapping instruction could identify directly the preselected set of instructions for which register remapping should be performed. However, in preferred embodiments, the register remapping logic configured by the remapping instruction could be triggered at some later point by a specific situation, such as the beginning of an instruction loop. In such cases, the preselected set of instructions to which register remapping should be performed would be determined from the specific situation, for example the preselected set may be all instructions within the instruction loop.<br>
By this approach, the remapping instruction need only be executed once in order for the remapping to be applied to a desired set of instructions. This should be contrasted with the design of the AMD microprocessor, where subsequent to the instruction changing the value in the stack pointer register, the same remapping will be applied to all subsequent instructions referencing the local registers, and another instruction needs to be executed if the stack pointer value, and hence the remapping, is to be changed again.<br>
In preferred embodiments the data processing apparatus further comprises: a repeat instruction for defining a range of instructions to be repeated, said range of instructions comprising said preselected set of instructions; and loop hardware for managing the repeat instruction and arranged to periodically update the register<br>
remapping logic. The loop hardware may typically be arranged to update the register remapping logic each time the range of instructions are repeated, such that a different remapping from logical to physical register reference is performed each time the range of instructions are repeated.<br>
In preferred embodiments, the repeat instruction includes one or more remapping parameters used to configure the register remapping logic. Preferably, these remapping parameters are such as to cause the remapping from logical register reference to physical register reference to be dependent on the particular iteration of the range of instructions defined by the repeat instruction. In this way, the remapping performed by the register remapping logic will be changed each time the range of instructions are repeated without the requirement to issue a separate remapping instruction. For small instruction loops, this can yield dramatic performance improvements, since, taking the earlier example of an instruction loop comprising a single instruction, each iteration of the loop only requires a single instruction rather than the two instructions that would have been required using the prior art approach according to the AMD microprocessor.<br>
When the repeat instruction includes one or more remapping parameters as discussed above, then a remapping instruction can be arranged to be performed prior to execution of the repeat instruction to configure the register remapping logic using said one or more remapping parameters, said remapping instruction not being included within said range of instructions defined by the repeat instruction. By this approach, the remapping instruction is only required to be executed once prior to the repeat instruction being executed. The register remapping logic defined by the remapping instruction will then be invoked by the loop hardware as the repeat instruction is executed.<br>
The data processing apparatus may be provided with a storage means for storing at least one set of predefined remapping parameters, each set defining a remapping configuration for said register remapping logic. In such cases, if said one or more remapping parameters included in said repeat instruction correspond to one of said sets of predefined remapping parameters, then in preferred embodiments, the corresponding remapping configuration for the register remapping logic is used<br>
without requiring a remapping instruction to be executed.<br>
In preferred embodiments, the first remapping parameter identifies a number of said plurality of registers to be subject to remapping by the register remapping logic, since it is often the case that the remapping function will be desired to be limited to a certain subset of the registers available to the microprocessor. By use of this first remapping parameter within the repeat instruction, the register remapping logic can be restricted to the desired subset of registers.<br>
Preferably, a base pointer is used by the register remapping logic as an offset value to be added to the logical register reference, and the repeat instruction includes a second remapping parameter identifying a value by which the base pointer is incremented at predetermined intervals, for example each time the range of instructions are repeated. Hence, this second remapping parameter within the Repeat instruction can be used to automatically change at predetermined intervals, such as upon each iteration of the instruction loop, the manner in which logical register references are mapped to physical register references by the register remapping logic. Preferably, the repeat instruction also includes a third remapping parameter providing a first wrapping value, and if during the incrementing of the base pointer, the base pointer becomes equal to or exceeds the first wrapping value, the incrementing of the base pointer wraps round to a new offset value. This enables a periodic pattern of base pointers to be generated.<br>
Further, the repeat instruction may include a fourth remapping parameter providing a second wrapping value, and if the register reference formed by the addition of the base pointer and the logical register reference equals or exceeds the second wrapping value, then that register reference is wrapped round to a new register reference. This second wrapping value may actually be chosen to be equal to the first remapping parameter identifying the number of registers to be subject to remapping, but can be chosen to have a different value. This second wrapping value can be used to ensure that the register remapping logic is constrained to the desired number of registers.<br>
The plurality of registers may be organised in any appropriate way, but in preferred embodiments, the plurality of registers contains banks of registers, the<br>
register remapping logic being arranged to perform remapping on a number of registers within a particular bank. Hence data items may be stored in one bank of registers, whilst for example coefficients may be stored in another bank of registers. With this approach, the remapping logic can be arranged to perform an independent remapping for each bank of registers, so that for example data items can be remapped independently of coefficients.<br>
Typically, an instruction may include a plurality of operands, each operand comprising a logical register reference, and in such cases the register remapping logic may be arranged to perform an independent remapping for each operand.<br>
As mentioned earlier, the data processing apparatus may be any apparatus used to process data, but in preferred embodiments, the apparatus is a digital signal processing apparatus. Digital signal processing involves the use of instruction loops which particularly benefit from the use of the present invention, since for such instruction loops, code density and performance can often be significantly improved.<br>
Viewed from a second aspect, the present invention provides a method of operating a data processing apparatus, comprising: (a) storing within a plurality of registers data items to be processed; (b) retrieving from the plurality of registers one or more data items required for processing an instruction; (c) processing the instruction using said one or more data items retrieved; said retrieving step (b) comprising, for a preselected set of instructions, the additional step of converting a logical register reference within said preselected set of instructions to a physical register reference identifying the register containing the data item required for said processing step (c).<br>
According   to   the   present  invention   there   is   provided   a   data  processing<br>
apparatus comprising:<br>
(i)         a plurality of registers for storing data items to be processed.<br>
(ii)        a processor for processing instructions to be applied to data items stored<br>
in said plurality of registers; and (iii)      hardware   register   remapping   logic   for   converting   a   logical   register<br>
reference within a preselected set of instructions to a physical register<br>
reference identifying the register containing the data item required for<br>
processing by  said processor;  and  said  processor being arranged to<br>
handle (iv)       a repeat instruction for defining a range of instructions to be repeated,<br>
said    range    of   instructions    comprising    said       preselected    set   of<br>
instructions; and (v)        loop  hardware  for managing the  repeat instruction  and  arranged to<br>
periodically update the hardware register remapping logic so as to alter<br>
the logical register reference to physical register reference conversion<br>
applied by the hardware register remapping logic.<br>
According to the present invention there is also provided a method of operating a data processing apparatus, comprising the steps of:<br>
(a)	storing within a plurality of registers data items to be processed;<br>
(b)	retrieving from the plurality of registers one or more data items required<br>
for  processing  an  instruction  including,  if the  instruction  is  one  of a<br>
preselected set of instructions, employing hardware register remapping logic<br>
to convert a logical register reference within said instruction to a physical<br>
register reference identifying the register containing the data item required<br>
for processing said instruction;<br>
(c)	processing the instruction using said one or more data items retrieved;<br>
(d)	defining a range of instructions to be repeated, said range of instructions<br>
comprising said preselected set of instructions; and<br>
(e)	employing   loop   hardware   to   manage   the   repeat   instruction   and   to<br>
periodically update said hardware register remapping logic so as to alter a<br>
logical register reference to a physical register reference, conversion applied<br>
by the hardware register remapping logic;<br>
An embodiment of the invention will now be described, by way of example only, with reference to the accompanying drawings in which:<br>
Figure 1 illustrates the high level configuration of a digital signal processing apparatus;<br>
Figure 2 illustrates the input buffer of register configuration of a coprocessor;<br>
Figure 3 illustrates the datapath through the coprocessor;<br>
Figure 4 illustrates a multiplexing circuit for read high or low order bits from a register;<br>
Figure 5 is a block diagram illustrating register remapping logic used by the coprocessor in preferred embodiments;<br>
Figure 6 illustrates in more detail the register remapping logic shown in Figure 5; and<br>
Figure 7 is a table illustrating a Block Filter Algorithm.<br>
The system described below is concerned with digital signal processing (DSP). DSP can take many forms, but may typically be considered to be processing that requires the high speed (real time) processing of large volumes of data. This data typically represents some analogue physical signal. A good example of DSP is that used in digital mobile telephones in which radio signals are received and transmitted that require decoding and encoding (typically using convolution, transform and correlation operations) to and from an analogue sound signal. Another example is disk driver controllers in which the signals recovered from the disk heads are processed to yield head tracking control.<br>
In the context of the above, there follows a description of a digital signal processing system based upon a microprocessor core (in this case an ARM core from the range of microprocessors designed by Advanced RISC Machines Limited of Cambridge, United Kingdom) cooperating with a coprocessor. The interface of the microprocessor and the coprocessor and the coprocessor architecture itself are specifically configured to provide DSP functionality. The microprocessor core will be referred to as the ARM and the coprocessor as the Piccolo. The ARM and the Piccolo will typically be fabricated as a single integrated circuit that will often include other elements (e.g. on-chip DRAM, ROM, D to A and A to D converters etc.) as<br>
part of an ASIC.<br>
Piccolo is an ARM coprocessor, it therefore executes part of the ARM instruction set. The ARM coprocessor instructions allow ARM to transfer data between Piccolo and memory (using Load Coprocessor, LDC and Store Coprocessor, STC, instructions), and to transfer ARM registers to and from Piccolo (using move to coprocessor, MCR, and move from coprocessor, MRC, instructions). One way of viewing the synergistic interaction of the ARM and Piccolo is that ARM acts as a powerful address generator for Piccolo data, with Piccolo being left free to perform DSP operations requiring the real tune handling of large volumes of data to produce corresponding real time results.<br>
Figure 1 illustrates the ARM 2 and Piccolo 4 with the ARM 2 issuing control signals to the Piccolo 4 to control the transfer of data words to and from Piccolo 4. An instruction cache 6 stores the Piccolo program instruction words that are required by Piccolo 4. A single DRAM memory 8 stores all the data and instruction words required by both the ARM 2 and Piccolo 4. The ARM 2 is responsible for addressing the memory 8 and controlling all data transfers. The arrangement with only a single memory 8 and one set of data and address buses is less complex and expensive than the typical DSP approach that requires multiple memories and buses with high bus bandwidths.<br>
Piccolo executes a second instruction stream (the digital signal processing program instruction words) from the instruction cache 6, which controls the Piccolo datapath. These instructions include digital signal processing type operations, for example Multiply-Accumulate, and control flow instructions, for example zero overhead loop instructions. These instructions operate on data which is held in Piccolo registers 10 (see Figure 2). This data was earlier transferred from memory 8 by the ARM 2. The instructions are streamed from the instruction cache 6; the instruction cache 6 drives the data bus as a full bus master. A small Piccolo instruction cache 6 will be a 4 line, 16 words per line direct mapped cache (64 instructions). In some implementations, it may be worthwhile to make the instruction cache bigger.<br>
Thus two tasks are run independently - ARM loading data, and Piccolo<br>
processing it. This allows sustained single cycle data processing on 16 bit data. Piccolo has a data input mechanism (illustrated in Figure 2) that allows the ARM to prefetch sequential data, loading the data before it is required by Piccolo. Piccolo can access the loaded data in any order, automatically refilling its register as the old data is used for the last time (all instructions have one bit per source operand to indicate that the source register should be refilled). This input mechanism is termed the reorder buffer and comprises an input buffer 12. Every value loaded into Piccolo (via an LDC or MCR see below) carries with it a tag Rn specifying which register the value is destined for. The tag Rn is stored alongside the data word in the input buffer. When a register is accessed via a register selecting circuit 14 and the instruction specifies the data register is to be refilled, the register is marked as empty by asserting a signal E. The register is then automatically refilled by a refill control circuit 16 using the oldest loaded value destined for that register within the input buffer 12. The reorder buffer holds 8 tagged values. The input buffer 12 has a form similar to a FIFO except that data words can be extracted from the centre of the queue after which later stored words will be passed along to fill the space. Accordingly, the data words furthest from the input are the oldest and this can be used to decide which data word should be used to refill a register when the input buffer 12 holds two data words with the correct tag Rn.<br>
Piccolo outputs data by storing it in an output buffer 18 (FIFO) as shown in Figure 3. Data is written to the FIFO sequentially, and read out to memory 8 in the same order by ARM. The output buffer 18 holds 8 32 bit values.<br>
Piccolo connects to ARM via the coprocessor interface (CP Control signals of Figure 1). On execution of an ARM coprocessor instruction Piccolo can either execute the instruction, cause the ARM to wait until Piccolo is ready before executing the instruction or refuse to execute the instruction. In the last case ARM will take an undefined instruction exception.<br>
The most common coprocessor instructions that Piccolo will execute are LDC and STC, which respectively load and store data words to and from the memory 8 via the data bus, with ARM generating all addresses. It is these instructions which load data into the reorder buffer, and store data from the output buffer 18. Piccolo will<br>
stall the ARM on an LDC if there is not enough room in the input reorder buffer to load in the data and on an STC if there is insufficient data in the output buffer to store, i.e. the data the ARM is expecting is not in the output buffer 18. Piccolo also executes ARM/Coprocessor register transfers to allow ARM to access Piccolo's special registers.<br>
Piccolo fetches its own instructions from memory to control the Piccolo datapath illustrated in Figure 3 and to transfer data from the reorder buffer to registers and from registers to the output buffer 18. The arithmetic logic unit of the Piccolo that executes these instructions has a multiplier/adder circuit 20 that performs multiplies, adds, subtracts, multiple-accumulates, logical operations, shifts and rotates. There is also provided in the datapath an accumulate/decumulate circuit 22 and a scale/saturate circuit 24.<br>
The Piccolo instructions are initially loaded from memory into the instruction cache 6, where Piccolo can access them without needing access back to the main memory.<br>
Piccolo cannot recover from memory aborts. Therefore if Piccolo is used in a virtual memory system, all Piccolo data must be in physical memory throughout the Piccolo task. This is not a significant limitation given the real time nature of Piccolo tasks, e.g. real time DSP. If a memory abort occurs Piccolo will stop and set a flag in a status register S2.<br>
Figure 3 shows the overall datapath functionality of Piccolo. The register bank 10 uses 3 read ports and 2 write ports. One write port (the L port) is used to refill registers from the reorder buffer. The output buffer 18 is updated directly from the ALU result bus 26, output from the output buffer 18 is under ARM program control. The ARM coprocessor interface performs LDC (Load Coprocessor) instructions into the reorder buffer, and STC (Store Coprocessor) instructions from the output buffer 18, as well as MCR and MRC (Move ARM register to/from CP register) on the register bank 10.<br>
The remaining register ports are used for the ALU. Two read ports (A and B) drive the inputs to the multiplier/adder circuit 20, the C read port is used to drive the accumulator/decumulator circuit 22 input. The remaining write port W is used<br>
to return results to the register bank 10.<br>
The multiplier 20 performs a 16 x 16 signed or unsigned multiply, with an optional 48 bit accumulate. The sealer unit 24 can provide a 0 to 31 immediate arithmetic or logical shift right, followed by an optional saturate. The shifter and logical unit 20 can perform either a shift or a logical operation every cycle.<br>
Piccolo has 16 general purpose registers named DO-D15 or AO-A3, XO-X3, YO-Y3, ZO-Z3. The first four registers (AO-A3) are intended as accumulators and are 48 bits wide, the extra 16 bits providing a guard against overflow during many successive calculations. The remaining registers are 32 bits wide.<br>
Each of Piccolo's registers can be treated as containing two independent 16 bit values. Bits 0 to 15 contain the low half, bits 16 to 31 contain the high half. Instructions can specify a particular 16 bit half of each register as a source operand, or they may specify the entire 32 bit register.<br>
Piccolo also provides for saturated arithmetic. Variants of the multiply, add and subtract instructions provide a saturated result if the result is greater than the size of the destination register. Where the destination register is a 48 bit accumulator, the value is saturated to 32 bits (i.e. there is no way to saturate a 48 bit value). There is no overflow detection on 48 bit registers. This is a reasonable restriction since it would take at least 65536 multiply accumulate instructions to cause an overflow.<br>
Each Piccolo register is either marked as "empty" (E flag, see Figure 2) or contains a value (it is not possible to have half of a register empty). Initially, all registers are marked as empty. On each cycle Piccolo attempts with the refill control circuit 16 to fill one of the empty registers by a value from the input reorder buffer. Alternatively if the register is written with a value from the ALU it is no longer marked as "empty". If a register is written from the ALU and at the same time there is a value waiting to be placed in the register from the reorder buffer then the result is undefined. Piccolo's execution unit will stall if a read is made to an empty register.<br>
The Input Reorder Buffer (ROB) sits between the coprocessor interface and Piccolo's register bank. Data is loaded into the ROB with ARM coprocessor transfers. The ROB contains a number of 32-bit values, each with a tag indicating the<br>
Piccolo register that the value is destined for. The tag also indicates whether the data should be transferred to a whole 32-bit register or just to the bottom 16-bits of a 32-bit register. If the data is destined for a whole register, the bottom 16 bits of the entry will be transferred to the bottom half of the target register and the top 16 bits will be transferred to the top half of the register (sign extended if the target register is a 48-bit accumulator). If the data is destined for just the bottom half of a register (so called 'Half Register'), the bottom 16 bits will be transferred first.<br>
The register tag always refers to a physical destination register, no register remapping is performed (see below regarding register remapping).<br>
On every cycle Piccolo attempts to transfer a data entry from the ROB to the register bank as follows:<br>
-Each entry in the ROB is examined and the tags compared with the registers that are empty, it is determined whether a transfer can be made from part or all of an entry to a register.<br>
-From the set of entries that can make a transfer, the oldest entry is selected and its data transferred to the register bank.<br>
-The tag of this entry is updated to mark the entry as empty. If only part of the entry was transferred, only the part transferred is marked empty.<br>
For example, if the target register is completely empty and the selected ROB entry contains data destined for a full register, the whole 32 bits are transferred and the entry is marked empty. If the bottom half of the target register is empty and the ROB entry contains data destined for the bottom half of a register, the bottom 16 bits of the ROB entry are transferred to the bottom half of the target register and the bottom half of the ROB is marked as empty.<br>
The high and low 16-bits of data in any entry can be transferred independently. If no entry contains data that can be transferred to the register bank, no transfer is made that cycle. The table below describes all possible combinations of target ROB entry and target register status.<br>
(Table Removed)<br>
To summarise, the two halves of a register may be refilled independently from the ROB. The data in the ROB is either marked as destined for a whole register or as two 16-bit values destined for the bottom half of a register.<br>
Data is loaded into the ROB using ARM coprocessor instructions. How the data is marked in the ROB depends on which ARM coprocessor instruction was used to perform the transfer. The following ARM instructions are available for filling the ROB with data:<br>
LDP{<cond>}<dest>, [Rn]{!}, #<size><br>
-LDP{<cond>}W<dest>, <wrap>, [Rn]{!}, #<size> —<br>
LDP{<cond>}16U<bank>,<br>
MPR{  }  , Rn<br>
MRP{<cond>}<dest>, Rn<br>
The following ARM instruction is provided for configuring the ROB:<br>
LDPA<br>
The first three are assembled as LDCs, MPR and MRP as MCRs, LDPA is assembled as a CDP instruction.<br>
In the above <dest> stands for a Piccolo register (AO-Z3), Rn for an ARM register,  for a constant number of bytes which must be a non zero multiple of 4 and  for a constant (1,2,4,8). Fields surrounded by {} are optional. For<br>
a transfer to be able to fit into the Reorder Buffer, <size> must be at most 32. In many circumstances  will be smaller than this limit to avoid deadlock. The  field indicates whether the data being loaded should be treated as 16-bit data, and endianess specific action taken (see below), or as 32-bit data.<br>
Notel: In the following text, when referring to LDP or LDPW this refers to both the 16-bit and 32-bit variants of the instructions.<br>
Note2: A 'word' is a 32-bit chunk from memory, which may consist of two 16-bit data items or one 32-bit data item.<br>
The LDP instruction transfers a number of data items, marking them as destined for a full register. The instruction will load  /4 words from address Rn in memory, inserting them into the ROB. The number of words that can be transferred is limited by the following:<br>
-The quantity <size> must be a non-zero multiple of 4;<br>
-<size> must be less than or equal to the size of the ROB for a particular implementation (8 words in the first version, and guaranteed to be no less than this in future versions).<br>
The first data item transferred will be tagged as destined for , the second as destined for <dest> +1 and so on (with wrapping from Z3 to AO). If the ! is specified then the register Rn is incremented by <size> afterwards.<br>
If the LDP 16 variant is used, endian specific action is performed on the two 16-bit halfwords forming the 32-bit data items as they are returned from the memory system. See below for more details on Big Endian and Little Endian Support.<br>
The LDPW instruction transfers a number of data items to a set of registers. The first data item transferred is tagged as destined for <dest>, the next for <dest> +1, etc. When <wrap> transfers have occurred, the next item transferred is tagged as destined for <dest>, and so on. The <wrap> quantity is specified in halfword quantities.<br>
For LDPW, the following restrictions apply: -The quantity <size> must be a non-zero multiple of 4;<br>
-<size> must be less than or equal to the size of the ROB for a particular implementation (8 words in the first version, and guaranteed to be no less than this in future versions);<br>
-<dest> may be one of {AO, XO, YO, ZO};<br>
-<wrap> may be one of {2,4,8} halfwords for LDP32W and one of {1,2,4,8} halfwords for LDP16W;<br>
-The quantity <size> must be greater than 2*<wrap>, otherwise no wrapping occurs and the LDP instruction shall be used instead.<br>
For example, the instruction, LDP32WXO, 2, [RO]!, #8<br>
will load two words into the ROB, marking them as destined for the full register X0. RO will be incremented by 8.The instruction,<br>
LDP32WXO, 4, [RO], #16<br>
will load four words into the ROB, marking them as destined for X0, X1, X0, X1 (in that order). RO will not be affected.<br>
For LDP16W, <wrap> may be specified as 1,2,4 or 8. The wrap of 1 will cause all data to be tagged as destined for the bottom half of the destination register <dest>.l. This is the 'Half Register' case.<br>
For example the instruction,<br>
LDP16WXO, 1, [RO]!, #8<br>
will load two words into the ROB, marking them as 16-bit data destined for XO.l. RO will be incremented by 8. The instruction,<br>
LDP16WXO, 4, [RO], #16<br>
will behave in a similar fashion to the LDP32W examples, except for the fact that endian specific action may be performed on the data as it is returned from memory.<br>
All unused encodings of the LDP instruction may be reserved for future expansion.<br>
The LDP16U instruction is provided to support the efficient transfer of non-word aligned 16-bit data. LDP16U support is provided for registers D4 to D15 (the X, Y and Z banks). The LDP16U instruction will transfer one 32-bit word of data (containing two 16-bit data items) from memory into Piccolo. Piccolo will discard the bottom 16 bits of this data and store the top 16 bits in a holding register. There is a holding register for the X, Y and Z banks. Once the holding register of a bank is primed, the behaviour of LDP{W} instructions is modified if the data is destined for a register in that bank. The data loaded into the ROB is formed by the concatenation of the holding register and the bottom 16 bits of data being transferred by the LDP instruction. The upper 16 bits of data being transferred is put into the holding register:<br>
entry 
This mode of operation is persistent until it is turned off by a LDPA instruction. The holding register does not record the destination register tag or size.<br>
These characteristics are obtained from the instruction that provides the next value of data.l.<br>
Endian specific behaviour may always occur on the data returned by the memory system. There is no non 16-bit equivalent to LDP16U since it is assumed that all 32-bit data items will be word aligned in memory.<br>
The LDPA instruction is used to switch off the unaligned mode of operation initiated by a LDP16U instruction. The unaligned mode may be turned off independently on banks X, Y, Z. For example the instruction,<br>
LDPA{X, Y}<br>
will turn off the unaligned mode on banks X and Y. Data in the holding registers of these anks will be discarded.<br>
Executing an LDPA on a bank which is not in unaligned mode is allowed, and will leave that bank in aligned mode.<br>
The MPR instruction places the contents of ARM register Rn into the ROB, destined for Piccolo register <dest>. The destination register <dest> may be any full register in the range AO-Z3. For example the instruction,<br>
MPRXO, R3<br>
will transfer the contents of R3 into the ROB, marking the data as destined for the full register XO.<br>
No endianess specific behaviour occurs to the data as it is transferred from ARM to Piccolo since the ARM is internally little endian.<br>
The MPRW instruction places the contents of ARM register Rn into the ROB, marking it as two 16-bit data items destined for the 16-bit Piccolo register <dest> .1.<br>
The restrictions on <dest> are the same as those for the LDPW instructions (i.e. AO,XO,YO,ZO). For example the instruction,<br>
MPRWXO, R3<br>
will transfer the contents of R3 into the ROB, marking the data as 2 16-bit quantities destined for XO.l. It should be noted that as for the LDP16W case with a wrap of 1, only the bottom half of a 32-bit register can be targeted.<br>
As with MPR no endianess specific operations are applied to the data. LDP is encoded as:<br>
31 30 29 28 21 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
where PICCOLO 1 is Piccolo's first coprocessor number (currently 8). The N bit selects between LDP32 (1) and LDP 16 (0).<br>
LDPW is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
where DEST is 0-3 for destination register AO,XO,YO,ZO and WRAP is 0-3 for wrap values 1,2,4,8. PICCOLO2 is Piccolo's second coprocessor number (currently 9). The N bit selects between LDP32 (1) and LDP16 (0).<br>
LDP16U is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
where DEST is 1-3 for the destination bank X, Y, Z.<br>
LDPA is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
where BANK[3:0] is used to turn off the unaligned mode on a per bank basis. If BANK[1] is set, unaligned mode on bank X is turned off. BANK[2] and BANK[3] turn off unaligned mode on banks Y and Z if set, respectively. N.B. This is a CDP operation.<br>
MPR is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
MPRW is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
where DEST is 1-3 for the destination register XO,YO,ZO.<br>
The output FIFO can hold up to eight 32-bit values. These are transferred from Piccolo by using one of the following (ARM) opcodes:<br>
STP{<cond>}<br>
MRP	Rn<br>
!}, #<size><br>
The first saves <size>/4 words from the output FIFO to the address given by the ARM register Rn, indexing Rn if the ! is present. To prevent deadlock, <size> must not be greater than the size of the output FIFO (8 entries in the this implementation). If the STP 1 6 variant is used, endian specific behaviour may occur to the data returned from the memory system.<br>
The MRP instruction removes one word from the output FIFO and places it in ARM register Rn. As with MPR no endian specific operations are applied to the data.<br>
The ARM encoding for STP is:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
where N selects between STP32 (1) and STP16 (0). For the definitions of the P, U and W bits, refer to an ARM data sheet.<br>
The ARM encoding for MRP is:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
The Piccolo instruction set assumes little endian operation internally. For example when accessing a 32-bit register as 16 bits halves, the lower half is assumed to occupy bits 15 to 0. Piccolo may be operating in a system with big endian memory or peripherals and must therefore take care to load 16-bit packed data in the correct manner.<br>
Piccolo (i.e. the DSP adapted coprocessor), like the ARM (e.g. the ARM7 microprocessors produced by Advanced RISC Machines Limited of Cambridge, United Kingdom), has a 'BIGEND' configuration pin which the programmer can control, perhaps with a programmable peripheral. Piccolo uses this pin to configure the input reorder buffer and output FIFO.<br>
When the ARM loads packed 16-bit data into the reorder buffer it must indicate this by using the 16-bit form of the LDP instruction. This information is combined with the state of the 'BIGEND' configuration input to place data into the holding latches and reorder buffer in the appropriate order. In particular when in big endian mode the holding register stores the bottom 16 bits of the loaded word, and is paired up with the top 16 bits of the next load. The holding register contents abvays end up in the bottom 16 bits of the word transferred into the reorder buffer.<br>
The output FIFO may contain either packed 16-bit or 32-bit data. The programmer must use the correct form of the STP instruction so that Piccolo can ensure that the 16-bit data is provided on the correct halves of the data bus. When configured as big endian the top and bottom 16-bit halves are swapped when the 16-bit forms of STP are used.<br>
Piccolo has 4 private registers which can only be accessed from the ARM. They are called SO-S2. They can only be accessed with MRC and MCR instructions. The opcodes are:<br>
MPSR	Sn, Rm<br>
MRPS	Rm, Sn<br>
These opcodes transfer a 32-bit value between ARM register Rm and private register Sn. They are encoded in ARM as a coprocessor register transfer:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
where L is 0 for the MPSR and 1 for the MRPS.<br>
Register SO contains the Piccolo unique ID and revision code<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
Bits[3:0] contain the revision number for the processor.<br>
Bits[15:4] contain a 3 digit part number in binary coded decimal format: 0x500 for Piccolo<br>
Bits[23:16] contain the architecture version: 0x00 = Version 1<br>
Bits[31:24] contain the ASCII code of an implementers trademark: 0x41 = A = ARM Ltd<br>
Register SI is the Piccolo status register.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
Primary condition code flags (N,Z,C,V)<br>
Secondary condition code flags (SN,SZ,SC,SV)<br>
E bit: Piccolo has been disabled by the ARM and has halted.<br>
U bit: Piccolo encountered an UNDEFINED instruction and has halted.<br>
B bit: Piccolo encountered a BREAKPOINT and has halted.<br>
H bit: Piccolo encountered a HALT instruction and has halted.<br>
A bit: Piccolo suffered a memory abort (load, store or Piccolo instruction) and has halted.<br>
D bit: Piccolo has detected a deadlock condition and has halted (see below).<br>
Register S2 is the Piccolo program counter:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
Program Counter<br>
0 0<br>
Writing to the program counter will start Piccolo executing a program at that address (leaving halted state if it is halted). On reset the program counter is undefined, since Piccolo is always started by writing to the program counter.<br>
During execution Piccolo monitors the execution of instructions and the status of the coprocessor interface. If it detects that:<br>
-Piccolo has stalled waiting for either a register to be refilled or the output FIFO to have an available entry.<br>
-The coprocessor interface is busy-waiting, because of insufficient space in the ROB or insufficient items in the output FIFO.<br>
If both of these conditions are detected Piccolo sets the D-bit in its status register, halts and rejects the ARM coprocessor instruction, causing ARM to take the undefined instruction trap.<br>
This detection of deadlock conditions allows a system to be constructed which can at least warn the programmer that the condition has occurred and report the exact point of failure, by reading the ARM and Piccolo program counters and registers. It should be stressed that deadlock can only happen due to an incorrect program or perhaps another part of the system corrupting Piccolo's state. Deadlock can not occur due to data starvation or 'overload'.<br>
There are several operations available that may be used to control Piccolo from the ARM, these are provided by CDP instructions. These CDP instructions will only be accepted when the ARM is in a privileged state. If this is not the case Piccolo will reject the CDP instruction resulting in the ARM taking the undefined instruction trap. The following operations are available:<br>
Reset<br>
Enter State Access Mode<br>
Enable<br>
Disable<br>
Piccolo may be reset in software by using the PRESET instruction.<br>
PRESET<br>
; Clear Piccolo's state<br>
This instruction is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 10<br><br>
(Table Removed)<br>
When this instruction is executed the following occurs:<br>
-All registers are marked as empty (ready for refill).<br>
-Input ROB is cleared.<br>
-Output FIFO is cleared.<br>
-Loop counters are reset.<br>
-Piccolo is put into halted state (and H bit of S2 will be set).<br>
Executing the PRESET instruction may take several cycles to complete (2-3 for this embodiment). Whilst it is executing, following ARM coprocessor instructions to be executed on Piccolo will be busy waited.<br>
In state access mode, Piccolo's state may be saved and restored using STC and LDC instructions (see the below regarding accessing Piccolo state from ARM). To enter state access mode, the PSTATE instruction must first be executed:<br>
PSTATE;<br>
Enter State Access Mode<br>
This instruction is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
When executed, the PSTATE instruction will:<br>
-Halt Piccolo (if it is not already halted), setting the E bit in Piccolo's Status Register. -Configure Piccolo into its State Access Mode.<br>
Executing the PSTATE instruction may take several cycles to complete, as Piccolo's instruction pipeline must drain before it can halt. Whilst it is executing, following ARM coprocessor instructions to be executed on Piccolo will be busy waited.<br>
The PENABLE and PDISABLE instructions are used for fast context switching. When Piccolo is disabled, only private registers 0 and 1 (the ID and Status registers) are accessible, and only then from a privileged mode. Access to any other state, or any access from user mode will cause an ARM undefined instruction exception. Disabling Piccolo causes it to halt execution. When Piccolo has halted execution, it will acknowledge the fact by setting the E bit in the status register.<br>
Piccolo is enabled by executing the PENABLE instruction:<br>
PENABLE;<br>
Enable Piccolo<br>
This instruction is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
Piccolo is disabled by executing the PDISABLE instruction:<br>
PDISABLE<br>
; Disable Piccolo<br>
This instruction is encoded as:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
When this instruction is executed, the following occurs:<br>
-Piccolo's instruction pipeline will drain.<br>
-Piccolo will halt and the H bit in the Status register set.<br>
The Piccolo instruction cache holds the Piccolo instructions which control the Piccolo datapath. If present it is guaranteed to hold at least 64 instructions, starting on a 16 word boundary. The following ARM opcode assembles into an MCR. Its action is to force the cache to fetch a line of (16) instructions starting at the specified address (which must be on a 16-word boundary). This fetch occurs even if the cache already<br>
holds data related to this address.<br>
PMIR Rm<br>
Piccolo must be halted before a PMIR can be performed.<br>
The MCR encoding of this opcode is:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
This section discusses the Piccolo instruction set which controls the Piccolo data path. Each instruction is 32 bits long. The instructions are read from the Piccolo instruction cache.<br>
Decoding the instruction set is quite straight forward. The top 6 bits (26 to 31) give a major opcode, with bits 22 to 25 providing a minor opcode for a few specific instructions. Bits shaded in grey are currently unused and reserved for expansion (they must contain the indicated value at present).<br>
There are eleven major instruction classes. This does not fully correspond to the major opcode filed in the instruction, for ease of decoding some sub-classes.<br>
3222222222211111111119876543210 098765432109876543210<br><br>
(Table Removed)<br>
The instructions in the above table have the following names:<br>
Standard Data Operation<br>
Logical Operation<br>
Conditional Add/Subtract<br>
Undefined<br>
Shifts<br>
Select -<br>
Undefined<br>
Parallel Select<br>
Multiply Accumulate<br>
Undefined<br>
Multiply Double<br>
Undefined<br>
Move Signed Immediate<br>
Undefined<br>
Repeat<br>
Repeat<br>
Register List Operations<br>
Branch<br>
Renaming Parameter Move<br>
Halt/Break<br>
The format for each class of instructions is described in detail in the following sections. The source and destination operand fields are common to most instructions and described in detail in separate sections, as is the register re-mapping.<br>
Most instructions require two source operands; Source 1 and Source 2. Some exceptions are saturating absolute.<br>
The Source 1 (SRC1) operand has the following 7 bit format:<br>
18    17     16    15     14         13           12<br><br>
(Table Removed)<br>
The elements of the field have the following meaning:<br>
-Size - indicates the size of operand to read (l=32-bit, 0=16-bit).<br>
-Refill - specifies that the register should be marked as empty after being read and can<br>
be refilled from the ROB.<br>
-Register Number - encodes which of the 16 32-bit registers to read.<br>
-Hi/Lo - For 16-bit reads indicates which half of the 32-bit register to read. For 32-bit<br>
operands, when set indicates that the two 16-bit halves of the register should be<br>
interchanged.<br><br>
(Table Removed)<br>
The register size is specified in the assembler by adding a suffix to the register number: .1 for the low 16 bits, .h for the high 16 bits or .x for 32 bits with the upper and lower sixteen bits interchanged.<br>
The general Source 2 (SRC2) has one of the following three 12 bit formats: 11      10     987654         3210<br><br>
(Table Removed)<br>
Figure 4 illustrates a multiplexer arrangement responsive to the Hi/Lo bit and Size bit to switch appropriate halves of the selected register to the Piccolo datapath. If the Size bit indicates 16 bits, then a sign extending circuit pads the high order bits of the datapath with Os or Is as appropriate.<br>
The first encoding specifies the source as being a register, the fields having the same encoding as the SRC1 specifier. The SCALE field specifies a scale to be applied to the result of the ALU.<br>
(Table Removed)<br>
The 8-bit immediate with rotate encoding allows the generation of a 32-bit<br>
immediate which is expressible by an 8-bit value and 2-bit rotate. The following table shows the immediate values that can be generated from the 8-bit value XY:<br><br>
(Table Removed)<br>
The 6-bit Immediate encoding allows the use of a 6-bit unsigned immediate (range 0 to 63), together with a scale applied to the output of the ALU.<br>
The general Source 2 encoding is common to most instruction variants. There are some exceptions to this rule which support a limited subset of the Source 2 encoding or modify it slightly:<br>
-Select Instructions.<br>
-Shift Instructions.<br>
-Parallel Operations.<br>
-Multiply Accumulate Instructions.<br>
-Multiply Double Instructions.<br>
Select instructions only support an operand which is a register or a 6-bit unsigned immediate. The scale is not available as these bits are used by the condition field of the instruction.<br>
11      10     9       8   1    0<br><br>
SRC2 SEL<br><br>
(Table Removed)<br>
Shift instructions only support an operand which is a 16-bit register or a 5-bit unsigned immediate between 1 and 31. No scale of the result is available.<br>
11      10     9       8       7                   1       0<br>
SRC2 SHIFT<br><br>
(Table Removed)<br>
In the case of parallel operations, if a register is specified as the source of the operand, a 32-bit read must be performed. The immediate encoding has slightly different meaning for the parallel operations. This allows an immediate to be     — duplicated onto both 16-bit halves of a 32-bit operand. A slightly restricted range of scales are available for parallel operations.<br>
11      10          8                                            1            0<br>
SRC2 PARALLEL<br>
(Table Removed)<br>
If the 6-bit immediate is used then it is always duplicated onto both halves of the 32-bit quantity. If the 8-bit immediate is used it is duplicated only if the rotate indicates that the 8-bit immediate should be rotated onto the top half of the 32-bit quantity:<br>
(Table Removed)<br>
No scale is available for parallel select operations; the scale field shall be set to 0 for these instructions.<br>
The multiply accumulate instructions do not allow an 8-bit rotated immediate to be specified. Bit 10 of the field is used to partly specify which accumulator to use. Source 2 is implied as a 16-bit operand.<br>
11      10     987654         3210 SRC2 MULA<br>
(Table Removed)<br>
Multiply double instructions do not allow the use of a constant. Only a 16-bit register can be specified. Bit 10 of the field is used to partly specify which accumulator to use.<br>
11      10     9       8                  1       0<br>
SRC2 MULD<br>
(Table Removed)<br>
Some instructions always imply a 32-bit operation (e.g. ADDADD), and in these cases the size bit shall be set to 1, with the Hi/Lo bit used to optionally swap the two 16-bit halves of the 32-bit operand. Some instructions always imply a 16-bit operation (e.g. MUL) and the size bit should be set to 0. The Hi/Lo bit then selects which half of the register is used (it is assumed that the missing size bit is clear). Multiply-accumlulate instructions allow independent specification of the source accumulator and destination registers. For these instructions the Size bits are used to indicate the source accumulator, and the size bits are implied by the instruction type as 0.<br>
When a 16-bit value is read (via the A or B busses) it is automatically sign extended to a 32-bit quantity. If a 48 bit register is read (via the A or B busses), only the bottom 32 bits appear on the bus. Hence in all cases source 1 and source 2 are converted to 32-bit values. Only accumulate instructions using bus C can access the full 48 bits of an accumulator register.<br>
If the refill bit is set, the register is marked as empty after use and will be refilled from the ROB by the usual refill mechanism (see the section on the ROB). Piccolo will not stall unless the register is used again as a source operand before the refill has taken place. The minimum number of cycles before the refilled data is valid (best case - the data is waiting at the head of the ROB) will be either 1 or 2. Hence it is advisable not to use the refilled data on the instruction following the refill request. If use of the operand on the next two instructions can be avoided it should be, since this will prevent performance loss on deeper pipeline implementations.<br>
The refill bit is specified in the assembler by suffixing the register number with a '^'. The section of the register marked as empty depends on the register operand. The two halves of each register may be marked for refill independently (for example X0.1^ will mark only the bottom half of XO for refill, X0^ will mark<br>
the whole of X0 for refill).   When the top 'half (bits 47:16) of a 48-bit register are refilled, the 16-bits of data is written to bits 31:16 and is sign extended up to bit<br>
47.<br>
If an attempt is made to refill the same register twice (eg ADD X1,X0^,X0^), then only one refill takes place. The assembler should only allow the syntax ADD X1,X0,X0^.<br>
If a register read is attempted before that register has been refilled, Piccolo stalls waiting for the register to be refilled. If a register is marked for refill, and the<br>
register is then updated before the refilled value is read, the result is		<br>
UNPREDICTABLE (for example ADD X0, X0^, X1 is unpredictable since it marks X0 for refill and then refills it by placing the sum of X0 and X1 into it).<br>
The 4-bit scale field encodes fourteen scale types:<br>
-ASR#0, 1, 2, 3,4, 6, 8, 10 -ASR#12 to 16 -LSL #1<br>
Parallel Max/Min instructions do not provide a scale, and therefore the six bit constant variant of source 2 is unused (Set to 0 by assembler).<br>
Within a REPEAT instruction register re-mapping is supported, allowing a REPEAT to access a moving 'window' of registers without unrolling the loop. This is described in more detail in below.<br>
Destination operands have the following 7 bit format:<br>
25       24         23           22              21            20          19<br><br>
(Table Removed)<br>
There are ten variants of this basic encoding:<br>
25    24    23    22   21   20   19<br>
(Table Removed)<br>
Assembler Mnemonic<br>
Dx<br>
Dx^<br>
Dx.l<br>
Dx.l^<br>
Dx.h<br>
Dx.h^<br>
Undefined<br>
.1 (No register writeback 16-bits)      7 "" (No register writeback 32-bits)      8 .1^ (16-bit) output ^ (32-bit) output<br><br><br><br><br>
The register number (Dx) indicates which of the 16 registers is being addressed. The Hi/Lo bit and the Size bit work together to address each 32-bit register as a pair of 16-bit registers. The Size bit defines how the appropriate flags, as defined in the instruction type, will be set, irrespective of whether a result is written to the register bank and/or output FIFO. This allows the construction of compares and similar instructions. The add with accumulate class of instruction must write back the result to a register.<br>
The following table shows the behaviour of each encoding:<br><br>
(Table Removed)<br>
In all cases the result of any operation prior to writing back to a register or inserting into the output FIFO is a 48 bit quantity. There are two cases:<br>
If the write is of 16-bits the 48 bit quantity is reduced to a 16-bit quantity by selecting the bottom 16 bits [15:0]. If the instruction saturates then the value will be saturated into the range -2^15 to 2^15-1. The 16-bit value is then written back to the indicated register and, if the Write FIFO bit is set, to the output FIFO. If it is written to the output FIFO then it is held until the next 16-bit value is written when the values are paired up and placed into the output FIFO as a single 32-bit value.<br>
For 32-bit writes the 48 bit quantity is reduced to a 32-bit quantity by selecting the bottom 32 bits [31:0].<br>
For both 32-bit and 48-bit writes, if the instruction saturates the 48-bit value will be converted to a 32-bit value in the range -2^31-1 to 2^31. Following the saturation:<br>
-If writeback to an accumulator is performed, the full 48 bits will be written.<br>
-If writeback to a 32-bit register is performed, bits [31:0] are written.<br>
-If writeback to the output FIFO is indicated, again bits [31:0] will be written.<br>
The destination size is specified in the assembler by a .1 or .h after the register number. If no register writeback is performed then the register number is unimportant, so omit the destination register to indicate no write to a register or use ^ to indicate a write only to the output FIFO. For example, SUB , X0, Y0 is equivalent to CMP <br>
X0, Y0 and ADD ^, X0, Y0 places the value of X0+Y0 into the output FIFO.<br>
If there is no room in the output FIFO for a value, Piccolo stalls waiting for space to become available.<br>
If a 16-bit value is written out, for example ADD X0.h^, X1, X2, then the value is latched until a second 16-bit value is written. The two values are then combined and placed into the output FIFO as a 32-bit number. The first 16-bit value written always appears in the lower half of the 32-bit word. Data entered into the<br>
output FIFO is marked as either 16 or 32-bit data, to allow endianess to be corrected on big endian systems.<br>
If a 32-bit value is written between two 16-bit writes then the action is undefined.<br>
Within a REPEAT instruction register re-mapping is supported, allowing a REPEAT to access a moving 'window' of registers without unrolling the loop. This is described in more detail below.<br>
In preferred embodiments of the present invention, the REPEAT instruction provides a mechanism to modify the way in which register operands are specified within a loop. Under this mechanism, the registers to be accessed are determined by a function of the register operand in the instruction and an offset into the register bank. The offset is changed in a programmable manner, preferably at the end of each instruction loop. The mechanism may operate independently on registers residing in the X, Y and Z banks. In preferred embodiments, this facility is not available for registers in the A bank.<br>
The notion of a logical and physical register can be used. The instruction operands are logical register references, and these are then mapped to physical register references identifying specific Piccolo registers 10. All operations, including refilling, operate on the physical register. The register remapping only occurs on the Piccolo instruction stream side - data loaded into Piccolo is always destined for a physical register, and no remapping is performed.<br>
The remapping mechanism will be discussed further with reference to Figure 5, which is a block diagram illustrating a number of the internal components of the Piccolo coprocessor 4. Data items retrieved by the ARM core 2 from memory are placed in the reorder buffer 12, and the Piccolo registers 10 are refilled from the reorder buffer 12 in the manner described earlier with reference to Figure 2. Piccolo instructions stored in the cache 6 are passed to an instruction decoder 50 within<br>
Piccolo 4, where they are decoded prior to being passed to the Piccolo processor core 54. The Piccolo processor core 54 includes the multiplier/adder circuit 20, the accumulate/decumulate circuit 22, and the scale/saturate circuit 24 discussed earlier with reference to Figure 3.<br>
If the instruction decoder 50 is handling instructions forming part of an instruction loop identified by a REPEAT instruction, and the REPEAT instruction has indicated that remapping of a number of registers should take place, then the register remapping logic 52 is employed to perform the necessary remapping. The register remapping logic 52 can be considered as being part of the instruction decoder 50, although it will be apparent to those skilled in the art that the register remapping logic 52 may be provided as a completely separate entity to the instruction decoder 50.<br>
An instruction will typically include one or more operands identifying registers containing the data items required by the instruction. For example, a typical instruction may include two source operands and one destination operand, identifying two registers containing data items required by the instruction, and a register in to which the result of the instruction should be placed. The register remapping logic 52 receives the operands of an instruction from the instruction decoder 50, these operands identifying logical register references. Based on the logical register references, the register remapping logic will determine whether remapping should or should not be applied, and will then apply a remapping to physical register references as required. If it is determined that remapping should not be applied, the logical register references are provided as the physical register references. The preferred manner in which the remapping is performed will be discussed in more detail later.<br>
Each output physical register reference from the register remapping logic is passed to the Piccolo processor core 54, such that the processor core can then apply the instruction to the data item in the particular register 10 identified by the physical register reference.<br>
The remapping mechanism of the preferred embodiment allows each bank of registers to be split into two sections, namely a section within which registers may be remapped, and a section in which registers retain their original register references without remapping. In preferred embodiments, the remapped section starts at the bottom of the register bank being remapped.<br>
A number of parameters are employed by the remapping mechanism, and these parameters will be discussed in detail with reference to Figure 6, which is a block diagram illustrating how the various parameters are used by the register remapping logic 52. It should be noted that these parameters are given values that are relative to a point within the bank being remapped, this point being, for example, the bottom of the bank.<br>
The register remapping logic 52 can be considered as comprising two main logical blocks, namely the Remap block 56 and the Base Update block 58. The register remapping logic 52 employs a base pointer that provides an offset value to be added to the logical register reference, this base pointer value being provided to the remap block 56 by base update block 58.<br>
A BASESTART signal can be used to define the initial value of the base pointer, this for example typically being zero, although some other value may be specified. This BASESTART signal is passed to multiplexor 60 within the Base Update block 58. During the first iteration of the instruction loop, the BASESTART signal is passed by the multiplexor 60 to the storage element 66, whereas for subsequent iterations of the loop, the next base pointer value is supplied by the multiplexor 60 to the storage element 66.<br>
The output of the storage element 66 is passed as the current base pointer value to the ReMap logic 56, and is also passed to one of the inputs of an adder 62 within the Base Update logic 58. The adder 62 also receives a BASEINC signal that provides a base increment value. The adder 62 is arranged to increment the current base pointer<br>
value supplied by storage element 66 by the BASEINC value, and to pass the result to the modulo circuit 64.<br>
The modulo circuit also receives a BASEWRAP value, and compares this value to the output base pointer signal from the adder 62. If the incremented base pointer value equals or exceeds the BASEWRAP value, the new base pointer is wrapped round to a new offset value. The output of the modulo circuit 64 is then the next base pointer value to be stored in storage element 66. This output is provided to the multiplexor 60, and from there to the storage element 66.<br>
However, this next base pointer value cannot be stored in the storage element 66 until a BASEUPDATE signal is received by the storage element 66 from the loop hardware managing the REPEAT instruction. The BASEUPDATE signal will be produced periodically by the loop hardware, for example each time the instruction loop is to be repeated. When a BASEUPDATE signal is received by the storage element 66, the storage element will overwrite the previous base pointer value with the next base pointer value provided by the multiplexor 60. In this manner, the base pointer value supplied to the ReMap logic 58 will change to the new base pointer value.<br>
The physical register to be accessed inside a remapped section of a register bank is determined by the addition of a logical register reference contained within an operand of an instruction, and the base pointer value provided by the base update logic 58. This addition is performed by adder 68 and the output is passed to modulo circuit 70. In preferred embodiments, the modulo circuit 70 also receives a register wrap value, and if the output signal from the adder 68 (the addition of the logical register reference and the base pointer value) exceeds the register wrap value, the result will wrap through to the bottom of the remapped region. The output of the modulo circuit 70 is then provided to multiplexor 72.<br>
A REGCOUNT value is provided to logic 74 within Remap block 56, identifying the number of registers within a bank which are to be remapped. The Ipgic<br>
74 compares this REGCOUNT value with the logical register reference, and passes a control signal to multiplexor 72 dependent on the result of that comparison. The multiplexor 72 receives as its two inputs the logical register reference and the output from modulo circuit 70 (the remapped register reference). In preferred embodiments of the present invention, if the logical register reference is less than the REGCOUNT value, then the logic 74 instructs the multiplexor 72 to output the remapped register reference as the Physical Register Reference. If, however, the logical register reference is greater than or equal to the REGCOUNT value, then the logic 74 instructs the multiplexor 72 to output the logical register reference directly as the physical register reference.<br>
As previously mentioned, in preferred embodiments, it is the REPEAT instruction which invokes the remapping mechanism. As will be discussed in more detail later, REPEAT instructions provide four zero cycle loops in hardware. These hardware loops are illustrated in Figure 5 as part of the instruction decoder 50. Each time the instruction decoder 50 requests an instruction from cache 6, the cache returns that instruction to the instruction decoder, whereupon the instruction decoder determines whether the returned instruction is a REPEAT instruction. If so, one of the hardware loops is configured to handle that REPEAT instruction.<br>
Each repeat instruction specifies the number of instructions in the loop and the number of times to go around the loop (which is either a constant or read from a Piccolo register). Two opcodes REPEAT and NEXT are provided for defining a hardware loop, the NEXT opcode being used merely as a delimiter and not being assembled as an instruction. The REPEAT goes at the start of the loop, and NEXT delimits the end of the loop, allowing the assembler to calculate the number of instructions in the loop body. In preferred embodiments, the REPEAT instruction can include remapping parameters such as the REGCOUNT, BASEINC, BASEWRAP and REGWRAP parameters to be employed by the register remapping logic 52.<br>
A number of registers can be provided to store remapping parameters used by<br>
the register remapping logic. Within these registers, a number of sets of predefined remapping parameters can be provided, whilst some registers are left for the storage of user defined remapping parameters. If the remapping parameters specified with the REPEAT instruction are equal to one of the sets of predefined remapping parameters, then the appropriate REPEAT encoding is used, this encoding causing a multiplexor or the like to provide the appropriate remapping parameters from the registers directly to the register remapping logic. If, on the other hand, the remapping parameters are not the same as any of the sets of predefined remapping parameters, then the assembler will generate a Remapping Parameter Move Instruction (RMOV) which allows the configuration of the user defined register remapping parameters, the RMOV instruction being followed by the REPEAT instruction. Preferably, the user defined remapping parameters would be placed by the RMOV instruction in the registers left aside for storing such user defined remapping parameters, and the multiplexor would then be programmed to pass the contents of those registers to the register remapping logic.<br>
In the preferred embodiments, the REGCOUNT, BASEINC, BASEWRAP and REGWRAP parameters take one of the values identified in the following chart:<br>
PARAMETER    DESCRIPTION<br><br>
REGCOUNT<br>
This identifies the number of 16 bit registers to perform remapping on, and may take the values 0, 2, 4, 8. Registers below REGCOUNT are remapped, those above or equal to REGCOUNT are accessed directly.<br><br>
BASEINC<br>
This defines by how many 16 bit registers the base pointer is incremented at the end of each loop iteration.  It may in preferred embodiments take the values 1, 2,_or 4, although in fact it can take other values if desired, including negative values where appropriate.<br><br>
BASEWRAP<br>
This determines the ceiling of the base calculation.  The base wrapping modulus may take the values 2, 4, 8.<br><br>
REGWRAP<br>
This determines the ceiling of the remap calculation.  The register wrapping modulus may take the values 2, 4, 8. REGWRAP may be chosen to be equal to REGCOUNT.<br>
Returning to Figure 6, an example of how the various parameters are used by the remap block 56 is as follows (in this example, the logical and physical register values are relative to the particular bank):<br>
if (Logical Register 
Physical Register = (Logical Register + Base) MOD REGCOUNT<br>
else<br>
Physical Register = Logical Register<br>
end if<br>
At the end of the loop, before the next iteration of the loop begins, the following update to the base pointer is performed by the base update logic 58:<br>
Base = (Base + BASEINC) MOD BASEWRAP<br>
At the end of a remapping loop, the register remapping will be switched off and all registers will then be accessed as physical registers. In preferred embodiments, only one remapping REPEAT will be active at any one time. Loops may still be nested, but only one may update the remapping variables at any particular time. However, it will be appreciated that, if desired, remapping repeats could be nested.<br>
To illustrate the benefits achieved with regards to code density as a result of employing the remapping mechanism according to the preferred embodiment of the present invention, a typical block filter algorithm will now be discussed. The principles of the block filter algorithm will first be discussed with reference to Figure 7. As illustrated in Figure 7, accumulator register A0 is arranged to accumulate the results of a number of multiplication operations, the multiplication operations being the multiplication of coefficient c0 by data item d0, the multiplication of coefficient cl by data item dl, the multiplication of coefficient c2 by data item d2, etc. Register Al accumulates the results of a similar set of multiplication operations, but this time the set of coefficients have been shifted such that c0 is now multiplied by dl, cl is now multiplied by d2, c2 is now multiplied by d3, etc. Likewise, register A2<br>
accumulates the results of multiplying the data values by the coefficient values shifted another step to the right, such that cO is multiplied by d2, cl is multiplied by d3, c2 is multiplied by d4, etc. This shift, multiply, and accumulate process is then repeated with the result being placed in register A3.<br>
If register remapping in accordance with the preferred embodiment of the present invention is not employed, then the following instruction loop will be required to perform the block filter instruction:<br>
; start with 4 new data values<br>
ZERO {A0-A3}	; Zero the accumulators<br>
REPEAT  Zl	; Zl= (number of coeffs/4)<br>
; do the next four coefficients, on the first time around:<br>
; a0 += d0*c0+dl*cl+d2*c2+d3*c3<br>
; al += dl*c0+d2*cl+d3*c2+d4*c3<br>
; a2 += d2*c0+d3*cl+d4*c2+d5*c3<br>
; a3 += d3*c0+d4*cl+d5*c2+d6*c3<br>
MULA   A0, X0.l^, Y0.l , A0    ; a0 += d0*c0, and load d4<br>
MULA    Al, X0.h , Y0.l , Al    ; al += dl*c0<br>
MULA    A2, Xl.l , Y0.l , A2    ; a2 + = d2*c0<br>
MULA   A3, XI.h , Y0.l*, A3    ; a3 += d3*c0, and load c4<br>
MULA    A0, X0.h*, Y0.h , A0    ; a0 += dl*cl, and load d5<br>
MULA    Al, Xl.l , Y0.h , Al    ; al += d2*cl<br>
MULA   A2, Xl.h , Y0.h , A2    ; a2 += d3*cl<br>
MULA   A3, X0.l , Y0.h*, A3    ; a3 += d4*cl, and load c5<br>
MULA   A0, Xl.l*, Yl.l , A0    ; a0 += d2*c2, and load d6<br>
MULA    Al, Xl.h , Yl.l , Al    ; al += d3*c2<br>
MULA    A2, X0.l , Yl.l , A2    ; a2 += d4*c2<br>
MULA   A3, X0.h , Yl.l*, A3    ; a3 += d5*c2, and load c6<br>
MULA   A0, Xl.h*, Yl.h , A0    ; a0 += d3*c3, and load d7<br>
MULA    Al, X0.l , Yl.h , Al    ; al += d4*c3<br>
MULA    A2, X0.h , Yl.h , A2    ; a2 += d5*c3<br>
MULA   A3, Xl.l , Yl.h*, A3    ; a3 += d6*c3, and load c7<br>
NEXT<br>
In this example, the data values are placed in the X bank of registers and the coefficient values are placed in the Y bank of registers. As a first step, the four accumulator registers A0, Al, A2, and A3 are set to zero. Once the accumulator registers have been reset, an instruction loop is then entered, which is delimited by the REPEAT and NEXT instructions. The value Zl identifies the number of times that the instruction loop should be repeated, and for the reasons that will be discussed later, this will actually be equal to the number of coefficients (c0, cl, c2, etc.) divided by 4.<br>
The instruction loop comprises 16 multiply accumulate instructions (MULA), which, after the first iteration through the loop, will result in the registers A0, Al, A2, A3 including the result of the calculations shown in the above code between the REPEAT and the first MULA instruction. To illustrate how the multiply accumulate instructions operate, we will consider the first four MULA instructions. The first instruction multiplies the data value within the first, or lower, 16 bits of the X bank register zero with the lower 16 bits within Y bank register zero, and adds the result to the accumulator register A0. At the same time the lower 16 bits of the X bank register zero are marked by a refill bit, this indicating that that part of the register can now be refilled with a new data value. It is marked in this way, since as will be apparent from Figure 7, once data item d0 has been multiplied by the coefficient c0 (this being represented by the first MULA instruction), then d0 is no longer required for the rest of the block filter instruction and so can be replaced by a new data value.<br>
The second MULA instruction then multiplies the second, or higher 16 bits of the X bank register zero with the lower 16 bits of the Y bank register zero (this representing the multiplication dl x c0 shown in Figure 7). Similarly, the third and fourth MULA instructions represent the multiplications d2 x c0, and d3 x c0, respectively. As will be apparent from Figure 7, once these four calculations have been performed, coefficient C0 is no longer required and so the register Y0.l is marked by a refill bit to enable it to be overwritten with another coefficient (c4).<br>
The next four MULA instructions represent the calculations dlxcl, d2xcl, d3xcl, and d4xcl, respectively. Once the calculation dlxcl has been performed, the register X0.h is marked by a refill bit since dl is no longer required. Similarly, once all four calculations have been performed, the register Y0.h is marked for refilling, since the coefficient cl is no longer needed. Similarly, the next four MULA instructions correspond to the calculations d2xc2, d3xc2, d4xc2, and d5xc2, whilst the final four calculations correspond to the calculations d3xc3, d4xc3, d5xc3, and d6xc3.<br>
Since, in the above described embodiment, registers are not remappable, each multiplication operation has to be reproduced explicitly with the specific register required being designated in the operands. Once the sixteen MULA instructions have been performed, the instruction loop can be repeated for coefficients c4 to c7 and data items d4 to dl0. Also, because the loop acts on four coefficient values per iteration, then the number of coefficient values must be a multiple of four and the computation Zl = no. of coeffs/4 must be calculated.<br>
By employing the remapping mechanism in accordance with the preferred embodiment of the present invention, the instruction loop can be dramatically reduced, such that it now only includes 4 multiply accumulate instructions, rather than the 16 multiply accumulate instructions that were otherwise required. Using the remapping mechanism, the code can now be written as follows:<br>
; start with 4 new data values<br>
ZERO {A0-A3}	; Zero the accumulators<br>
REPEAT  Zl, X++ n4 w4 r4, Y++ n4 w4 r4; Zl= (number of coefficients)<br>
; Remapping is applied to the X and Y banks.<br>
; Four 16 bit registers in these banks are remapped.<br>
; The base pointer for both banks is incremented by one on each<br>
; iteration of the loop.<br>
; The base pointer wraps when it reaches the fourth register in the<br>
; bank.<br>
MULA   A0, X0.1A, Y0.l , A0    ; a0 += d0*c0, and load d4<br>
MULA    Al, X0.h,  Y0.l , Al    ; al += dl*c0<br>
MULA    A2, Xl.l,  Y0.l , A2    ; a2 += d2*c0<br>
MULA   A3, XI.h,  Y0.l", A3    ; a3 += d3*c0, and load c4<br>
NEXT<br>
;   go round loop and advance remapping<br>
As before, the first step is to set the four accumulator registers A0-A3 to zero. Then, the instruction loop is entered, delimited by the REPEAT and NEXT opcodes. The REPEAT instruction has a number of parameters associated therewith, which are as follows:<br>
X++    : indicates that BASEINC is ' 1 ' for the X Bank of registers<br>
n4        : indicates that REGCOUNT is '4' and hence the first four X Bank registers<br>
X0.l to Xl.h are to be remapped<br>
w4       : indicates that BASEWRAP is '4' for the X Bank of registers r4        : indicates that REGWRAP is '4' for the X Bank of registers Y++    : indicates that BASEINC is ' 1' for the Y Bank of registers n4        : indicates that REGCOUNT is '4' and hence the first four Y Bank registers<br>
Y0.l to Yl.h are to be remapped<br>
w4       : indicates that BASEWRAP is '4' for the Y Bank of registers r4        : indicates that REGWRAP is '4' for the Y Bank of registers<br>
It should also be noted that now the value Zl is equal to the number of coefficients, rather than being equal to the number of coefficients/4 as in the prior art example.<br>
For the first iteration of the instruction loop, the base pointer value is zero, and so there is no remapping. However, next time the loop is executed, the base pointer value will be ' 1' for both the X and Y banks, and so the operands will be mapped as follows:<br>
X0.l becomes X0.h X0.h becomes Xl.l XI.1 becomes Xl.h<br>
Xl.h becomes X0.l (since BASEWRAP is '4')<br>
Y0.l becomes Y0.h<br>
Y0.h becomes Yl.l<br>
Yl.l becomes Yl.h<br>
Yl.h becomes Y0.l (since BASEWRAP is '4')<br>
Hence, it can be seen that on the second iteration, the four MULA instructions actually perform the calculations indicated by the fifth to eight MULA instructions in the example discussed earlier that does not include the remapping of the present invention. Similarly, the third and fourth iterations through the loop perform the calculations formerly performed by the ninth to twelfth, and thirteenth to sixteenth MULA instructions of the prior art code.<br>
Hence, it can be seen that the above code performs exactly the same block filter algorithm as the prior art code, but improves code density within the loop body by a factor of four, since only four instructions need to be provided rather than the sixteen required by the prior art.<br>
By employing the register remapping technique in accordance with preferred embodiments of the present invention, the following benefits can be realised:<br>
1.	It improyes code density;<br>
2.	It can in certain situations hide the latency from marking a register being as<br>
empty to that register being refilled by Piccolo's reorder buffer.    This could be<br>
achieved by unrolling loops, at the cost of increased code size;<br>
3.	It enables a variable number of registers to be accessed - by varying the<br>
number of loop iterations performed the number of registers accessed may be varied;<br>
and<br>
4.	It can ease algorithm development.  For suitable algorithms, the programmer<br>
can produce a piece of code for the nth stage of the algorithm, then use register<br>
remapping to apply the formula to a sliding set of data.<br>
It will be apparent that certain changes can be made to the above described register remapping mechanism without departing from the scope of the present invention. For example, it is possible for the bank of registers 10 to provide more physical registers than can be specified by the programmer in an instruction operand. Whilst these extra registers cannot be accessed directly, the register remapping mechanism can make these registers available. For example, consider the example discussed earlier where the X bank of registers has four 32 bit registers available to the programmer, and hence eight 16 bit registers can be specified by logical register references. It is possible for the X bank of registers to actually consist of, for example, six 32 bit registers, in which case there will be four additional 16 bit registers not directly accessible to the programmer. However, these extra four registers can be made available by the remapping mechanism thereby providing additional registers for the storage of data items.<br>
The following assembler syntax may will be used:<br>
&gt;&gt; means logical shift right or shift left if the shift operand is negative (see <lscale> below).<br>
-&gt;&gt; means arithmetic shift right or shift left if the shift operand is negative (see <scale> below).<br>
RORmeans Rotate Right.<br>
SAT(a)means the saturated value of a (saturated to 16 or 32 bits depending on the size of the destination register). Specifically, to saturate to 16 bits, any value greater than +0x7fff is replaced by +0x7fff and any value less than -0x8000 is replaced by -0x8000. Saturation to 32 bits is similar with extremes +0x7fffffff and -0x80000000. If the destination register is 48 bits the saturation is still at 32 bits.<br>
Source operand 1 can be one of the following formats:<br><srcl>will be used a shorthand for [Rn│Rn.l│Rn.h!Rn.x][^]. In other words all 7 bits of the source specifier are valid and the register is read as a 32-bit value (optionally swapped) or a 16-bit value sign extended. For an accumulator only the bottom 32 bits are read. The ^ specifies register refill.<br><srcl_16>is short for [Rn.l|Rn.h][^]. Only 16-bit values can be read.<br><srcl_32>is short for [Rn]Rn.x][^]. Only a 32-bit value can be read, with the upper and lower halves optionally swapped.<br>
Source operand 2 can be one of the following formats:<br><src2>will be a shorthand for three options:<br>
a source register of the form [Rn|Rn.l|Rn.h]Rn.x][^], plus a scale (<scale>) of the final result.<br>
an optionally shifted eight bit constant (<immed_8>), but no<br>
scale of the final result.<br>
a six bit constant (<immed_6>), plus a scale (<scale>) of the<br>
final result.<br><src2_maxmin>         is the same as <src2> but a scale is not permitted. <src2_shift>   shift instructions provide a limited subset of <src2>. See above.<br>
for details. <src2_par>     as for <src2_shift><br>
For instructions which specify a third operand:<br><acc>	is short for any of the four accumulator registers [A0│A1│A2│A3].<br>
All 48 bits are read. No refill can be specified. The destination register has the format:<br><dest> extension<br>
which is short for [Rn|Rn.l|Rn.h|.l| ][^]. With no "."<br>
the full register is written (48 bits in the case of an accumulator). In the case where no write back to the register is required, the<br>
register<br>
used is unimportant. The assembler supports the omission of a destination register to indicate that write back is not required or ".1" to indicate that no writeback is required but flags should be set as though the result is a 16-bit quantity. ^ denotes that the value is written to the output FIFO.<br><scale>	represents a number of arithmetic scales. There are fourteen<br>
available<br>
scales:<br>
ASR#0, 1,2, 3,4, 6, 8, 10 ASR#12to 16 LSL#1<br><immed_8>    stands for a unsigned 8-bit immediate value. This consists of a byte<br>
rotated left by a shift of 0,  8,   16  or 24.  Hence values 0xYZ000000,<br>
0x00YZ0000, 0x0000YZ00 and 0x000000YZ can be encoded<br>
for any YZ. The rotate is encoded as a 2 bit quantity. <imm_6>        Stands for an unsigned 6-bit immediate. <params>   is used to specify register re-mapping and has the following format:<br><bank><baseinc> n<renumber> w<basewrap><br><bank>	can be [X|YJZ]<br><baseinc>	can be [++|+l|+2|+4]<br><renumber>        can be [0!2|4|8] <basewrap>         can be [2|4|8]<br>
The expression <cond> is shorthand for any one of the following condition codes. Note that the encoding is slightly different from the ARM since the unsigned LS and HI codes have been replaced by more useful signed overflow/underflow tests. The V and N flags are set differently on Piccolo than on the ARM so the translation from condition testing to flag checking is not the same as the ARM either.<br>
0	EQ      Z=0	Last result was zero.<br>
1	NE      Z=l	Last result was non zero.<br><br>
10	CS       C=l	Used after a shift/MAX operation.<br>
11	CC      C=0<br><br>
100	MI/LT	N=l	Last result was negative.<br>
101	PL/GE	N=0	Last result was positive<br><br>
110	VS      V=l	Signed overflow/saturation on last result<br>
111	VC      V=0	No overflow/saturation on last result<br><br>
1000	VP      V=l &amp; N=0	Overflow positive on last result.<br>
1001	VN      V=l &amp; N=l	Overflow negative on last result<br><br>
1010	reserved<br>
1011	reserved<br>
1100    GT      N=0&amp;Z=0<br>
1101    LE      N=l ! Z=l<br>
1110	AL<br>
1111	reserved<br>
Since Piccolo deals with signed quantities, the unsigned LS and HI conditions have been dropped and replaced by VP and VN which describe the direction of any overflow. Since the result of the ALU is 48 bits wide, MI and LT now perform the same function, similarly PL and GE. This leaves 3 slots for future expansion.<br>
All operations are signed unless otherwise indicated.<br>
The primary and secondary condition codes each consist of: N - negative. Z - zero. C - carry/unsigned overflow.<br>
V - signed overflow.<br>
Arithmetic instructions can be divided into two types; parallel and 'full width'. The 'full width' instructions only set the primary flags, whereas the parallel operators set the primary and secondary flags based on the upper and lower 16-bit halves of the result.<br>
The N, Z and V flags are calculated based on the full ALU result, after the scale has been applied but prior to being written to the destination. An ASR will always reduce the number of bits required to store the result, but an ASL would increase it. To avoid this Piccolo truncates the 48-bit result when an ASL scale is applied, to limit the number of bits over which zero detect and overflow must carried out.<br>
The N flag is calculated presuming signed arithmetic is being carried out. This is because when overflow occurs, the most significant bit of the result is either the C<br>
flag or the N flag, depending on whether the input operands are signed or unsigned.<br>
The V flag indicates if any loss of precision occurs as a result of writing the result to the selected destination. If no write-back is selected a 'size' is still implied, and the overflow flag is set correctly. Overflow can occur when:<br>
-Writing to a 16-bit register when the result is not in the range -2^15 to 2^15-1. -Writing to a 32-bit register when the result is not in the range -2^31 to 2^31-1.<br>
Parallel add/subtract instructions set the N, Z and V flags independently on the upper and lower halves of the result.<br>
When writing to an accumulator the V flag is set as if writing to a 32-bit register. This is to allow saturating instructions to use accumulators as 32-bit registers.<br>
The saturating absolute instruction (SABS) also sets the overflow flag if the absolute value of the input operand would not fit in designated destination.<br>
The Carry flag is set by add and subtract instructions and is used as a 'binary' flag by the MAX/MIN, SABS and CLB instructions. All other instructions, including multiply operations preserve the Carry flag(s).<br>
For add and subtract operations the Carry is that which is generated by either bit 31 or bit 15 or the result, based on whether the destination is 32 or 16-bits wide.<br>
The standard arithmetic instructions can be divided up into a number types, depending on how the flags are set:<br>
In the case of Add and Subtract instructions, if the N bit is set, then all flags are preserved. If the N bit is not set then the flags are updated as follows:<br>
Z is set if the full 48 bit result was 0.<br>
N is set if the full 48 bit result had bit 47 set (was negative).<br>
V is set if either:<br>
The destination register is 16-bit and the signed result will not fit into a 16-bit register (not in the range -2^15
The destination register is a 32/48 bit register and the signed result will<br>
not fit into 32 bits.<br>
If <dest> is a 32 or 48 bit register then the C flag is set if there is a carry out of bit 31 when summing <srcl> and <src2> or if no borrow occurred from bit 31 when subtracting <src2> from <srcl> (the same carry value you would expect on the ARM). If <dest> is a 16-bit register then the C flag is set if there is a carry out of bit 15 of the sum.<br>
The secondary flags (SZ, SN, SV, SC) are preserved.<br>
In the case of instructions which either carry out a multiplication or accumulate from a 48-bit register.<br>
Z is set if the full 48 bit result was 0.<br>
N is set if the full 48 bit result had bit 47 set (was negative).<br>
V is set if either (1) the destination register is 16-bit and the signed result will<br>
not fit into a 16-bit register (not in the range -2^15
destination register is a 32/48 bit register and the signed result will not fit into<br>
32 bits.<br>
C is preserved.<br>
The secondary flags (S2', SN, SV, SC) are preserved.<br>
The other instructions, including logical operations, parallel adds and subtracts, max and min, shifts etc. are covered below.<br>
The Add and Subtract instructions add or subtract two registers, scale the result, and then store back to a register. The operands are treated as signed values. Flag updating for the non-saturating variants is optional and may be suppressed by appending an N to the end of the instruction.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
OPC specifies the type of instruction.<br>
Action (OPC):<br>
100N0<br>
110N0<br>
10001<br>
11001<br>
01110<br>
01111<br>
101N0<br>
111N0<br>
dest - (srcl + src2) (-&gt;&gt; scale) (, N)<br>
dest = (srcl - src2) (-&gt;&gt; scale) (, N)<br>
dest = SAT((srcl + src2) (-&gt;&gt; scale))<br>
dest = SAT((srcl - src2) (-&gt;&gt; scale))<br>
dest = (src2 - srcl) (-&gt;&gt; scale)<br>
dest = SAT((src2 - srcl) (-&gt;&gt; scale))<br>
dest - (srcl + src2 + Carry) (-&gt;&gt; scale) (, N)<br>
dest = (srcl - src2 + Carry - 1) (-&gt;&gt; scale) (, N)<br><br>
(Table Removed)<br>
The assembler supports the following opcodes CMP   <srcl>, <src2> CMN   <srcl>, <src2><br>
CMP is a subtract which sets the flags with the register write disabled. CMN is an add which sets the flags with register write disabled.<br>
Flags:<br>
-These have been discussed above.<br>
Reasons for inclusion:<br>
ADC is useful for inserting carry into the bottom of a register following a shift/MAX/MIN operation. It is also used to do a 32/32 bit divide. It also provides for extended precision adds. The addition of an N bit gives finer control of the flags, in particular the carry. This enables a 32/32 bit division at 2 cycles per bit.<br>
Saturated adds and subtracts are needed for G.729 etc.<br>
Incrementing/decrementing counters. RSB is useful for calculating shifts (x=32-x is a common operation). A saturated RSB is needed for saturated negation (used in G.729).<br>
Add/subtract accumulate instructions perform addition and subtraction with<br>
accumulation and scaling/saturation. Unlike the multiply accumulate instructions the accumulator number cannot be specified independently of the destination register. The bottom two bits of the destination register give the number, ace, of the 48 bit accumulator to accumulate into. Hence ADDA X0,X1,X2,A0 and ADDA A3,X1,X2,A3 are valid, but ADDA X1,X1,X2,A0 is not. With this class of instruction, the result must be written back to a register - the no writeback encodings of the destination field are not allowed.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
OPC specifies the type of instruction. In the following ace is (DEST[1:0]). The Sa bit indicates saturation.<br>
Action (OPC):<br>
0 1<br>
dest = {SAT}(acc + (srcl + src2)) {-&gt;&gt; scale} dest - {SAT}(ace + (srcl - src2)) {-&gt;&gt; scale}<br><br>
Mnemonics:<br>
(S}ADDA {S}SUBA<br><dest>, <srcl>, <src2>, <acc> {,<scale>} <dest>, <srcl>, <src2>, <acc> {,<scale>}<br>
An S before the command indicates saturation.<br>
Flags:<br>
See above.<br>
Reasons for inclusion:<br>
The ADDA (add accumulate) instruction is useful for summing two words of an array of integers with an accumulator (for instance to find their average) per cycle. The SUBA (subtract accumulate) instruction is useful in calculating the sum of the differences (for correlation); it subtracts two separate values and adds the difference to a third register.<br>
Addition with rounding can be done by using <dest> different from <acc>. For example, X0-(X1+X2+16384)&gt;&gt;15 can be done in one cycle by keeping 16384 m A0. Addition with a rounding constant can be done by ADDA X0,X1,#16384,A0.<br>
For a bit exact implementation of:<br>
sum of ((a_i * b_i)&gt;&gt;k) (quite common - used in TrueSpeech) the standard Piccolo code would be:<br>
MUL      tl, a_0, b_0, ASR#k<br>
ADD      ans, ans, tl<br>
MUL      t2, a_l, b_l, ASR#k<br>
ADD      ans, ans, t2<br>
There are two problems with this code; it is too long and the adds are not to 48-bit precision so guard bits can't be used. A better solution is to use ADDA:<br>
MUL tl, a_0, b_0, ASR#k MUL t2, a_l, b_l, ASR#k ADDA ans, tl, t2, ans<br>
This gives a 25% speed increase and retains 48-bit accuracy.<br>
Add/Subtract in Parallel instructions perform addition and subtraction on two<br>
signed 16-bit quantities held in pairs in 32-bit registers. The primary condition code flags are set from the result of the most significant 16 bits, the secondary flags are updated from the least significant half. Only 32-bit registers can be specified as the source for these instructions, although the values can be halfword swapped. The individual halves of each register are treated as signed values. The calculations and scaling are done with no loss of precision. Hence ADD ADD X0, XI, X2, ASR#1 will produce the correct averages in the upper and lower halves of X0. Optional saturation is provided for each instruction for which the Sa bit must be set.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
OPC defines the operation. Action (OPC):<br>
0	dest.h = (srcl.h + src2.h) -&gt;&gt; {scale},<br>
dest.l = (srcl.l + src2.1) -&gt;&gt; {scale}<br>
1	dest.h = (srcl.h + src2.h) -&gt;&gt; {scale},<br>
dest.l = (srcl.l - src2.1) -&gt;&gt; {scale}<br><br>
100	dest.h = (srcl.h - src2.h) -&gt;&gt; {scale},<br>
dest.l = (srcl.l + src2.1) -&gt;&gt; {scale}<br>
101	dest.h = (srcl.h - src2.h) -&gt;&gt; {scale},<br>
dest.l = (srcl.l - src2.1) -&gt;&gt; {scale}<br>
Each sum/difference is independently saturated if the Sa bit is set.<br>
Mnemonics:<br>
0	{S}ADDADD	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
1	{S}ADDSUB	<dest>, <srcl_32>, <src2_32> {,<scale>}<br><br>
100	{S}SUBADD	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
101	{S}SUBSUB	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
An S before the command indicates saturation. The assembler also supports<br>
CMNCMN	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
CMNCMP	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
CMPCMN	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
CMPCMP	<dest>, <srcl_32>, <src2_32> {,<scale>}<br>
generated by the standard instructions with no write-back.<br>
Flags:<br>
C         is set if there is a carry out of bit 15 when adding the two upper<br>
sixteen bit halves.<br>
Z         is set if the sum of the upper sixteen bit halves is 0. N         is set if the sum of the upper sixteen bit halves is negative. V         is set if the signed 17 bit sum of the upper sixteen bit halves<br>
will not fit into 16 bits (post scale). SZ, SN, SV, and SC are set similarly for the lower 16-bit halves.<br>
Reason for inclusion:<br>
The parallel Add and Subtract instructions are useful for performing operations on<br>
complex numbers held in a single 32-bit register. They are used in the FFT kernel. It is also useful for simple addition/subtraction of vectors of 16-bit data, allowing two elements to be processed per cycle.<br>
The Branch (conditional) instruction allows conditional changes in control flow. Piccolo may take three cycles to execute a taken branch.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
Action:<br>
Branch by offset if <cond> holds according to the primary flags.<br>
The offset is a signed 16-bit number of words. At the moment the range<br>
of the offset is restricted to -32768 to +32767 words.<br>
The address calculation performed is<br>
target address = branch instruction address + 4 + OFFSET<br>
Mnemonics:<br>
B<cond><destination label><br>
Flags:<br>
Unaffected.<br>
Reasons for inclusion:<br>
Highly useful in most routines.<br>
Conditional Add or Subtract instructions conditionally add or subtract src2 to<br>
srcl.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
OPC specifies the type of instruction.<br>
Action (OPC):<br>
0         if (carry set) temp=srcl-srcl else temp=srcl+src2<br>
dest = temp {-&gt;&gt; scale}<br>
if (carry set) temp=srcl-src2 else temp=srcl+src2<br>
dest = temp {-&gt;&gt; scale} BUT if scale is a shift left<br>
then the new value of carry (from srcl-src2 or<br>
srcl+src2) is shifted into the bottom.<br>
Mnemonics:<br>
0	CAS    <dest>, <srcl>, <src2> {,<scale>}<br>
1	CASC <dest>, <srcl>, <src2> {,<scale>}<br>
Flags:<br>
See above. Reasons for inclusion:<br>
The Conditional Add or Subtract instruction enables efficient divide code to be constructed.<br>
Example 1: Divide the 32-bit unsigned value in XO by the 16-bit unsigned value in X1 (with the assumption that XO 
LSL    X1, X1, #15	; shift up divisor<br>
SUB    X1, X1, #0	; set the carry flag<br>
REPEAT #16<br>
CASC X0, X0, X1,LSL#1<br>
NEXT<br>
At the end of the loop X0.l holds the quotient of the divide. The remainder can be recovered from X0.h depending on the value of carry.<br>
Example 2: Divide the 32-bit positive value in XO by the 32-bit positive value in XI, with early termination.<br>
MOV<br>
LOG<br>
LOG<br>
SUBS<br>
BLT<br>
LSL<br>
ADD<br>
SUBS<br>
REPEAT<br>
CAS<br>
ADCN<br>
NEXT<br>
X2, #0<br>
zo, xo<br>
Zl, XI<br>
Z0, Zl, Z0<br>
div_end<br>
XI, XI, Z0<br>
Z0, Z0, #1<br>
Z0, Z0, #0<br>
Z0<br>
X0, X0, XI, LSL#1<br>
X2, X2, X2<br>
clear the quotient<br>
number of bits X0 can be shifted<br>
number of bits XI can be shifted<br>
XI shift up so 1's match<br>
X1&gt;X0 so answer is 0<br>
match leading ones<br>
number of tests to do<br>
set carry<br>
divend<br>
At the end, X2 holds the quotient and the remainder can be recovered from X0. The Count Leading Bits instruction allows data to be normalised.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
Action:<br>
dest is set to the number of places the value in srcl must be shifted left in order for bit 31 to differ from bit 30. This is a value in the range 0-30 except in the special cases where srcl is either -1 or 0 where 31 is returned.<br>
Mnemonic:<br>
CLB    <dest>, <srcl><br>
Flags:<br>
Z	is set if the result is zero.<br>
N	is cleared.<br>
C	is set if srcl is either -1 or 0.<br>
V	is preserved.<br>
Reasons for inclusion:<br>
Step needed for normalisation.<br>
Halt and Breakpoint instructions are provided for stopping Piccolo execution<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
OPC specifies the type of instruction.<br>
Action (OPC):<br>
0	Piccolo execution is stopped and the Halt bit is set in the<br>
Piccolo status register.<br>
1	Piccolo execution is stopped, the Break bit is set in the<br>
Piccolo status register and the ARM is interrupted to say<br>
that a breakpoint has been reached.<br>
Mnemonics:<br>
0	HALT<br>
1	BREAK<br>
Flags:<br>
Unaffected<br>
Logical Operation instructions perform a logical operation on a 32 or 16-bit register. The operands are treated as unsigned values.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
OPC encodes the logical operation to perform. Action (OPC):<br>
0	dest = (srcl &amp; src2) {-&gt;&gt; scale}<br>
1	dest = (srcl ] src2) {-&gt;&gt; scale}<br><br>
10	dest - (srcl &amp; ~src2) {-&gt;&gt; scale}<br>
11	dest = (srcl ^ src2) {-&gt;&gt; scale}<br>
Mnemonics:<br>
0	AND   <dest>, <srcl>, <src2> {,<scale>}<br>
1	ORR   <dest>, <srcl>, <src2> {,<scale>}<br><br>
10	BIC     <dest>, <srcl>, <src2> {,<scale>}<br>
11	EOR   <dest>, <srcl>, <src2> {,<scale>}<br>
The assembler supports the following opcodes<br>
1ST    <srcl>, <src2> TEQ    <srcl>, <src2><br>
TST is an AND with the register write disabled. TEQ is an EOR with the register write disabled.<br>
Flags:<br>
Z	is set if the result is all zeros<br>
N, C, V	are preserved<br>
SZ, SN, SC, SV are preserved<br>
Reasons for inclusion:<br>
Speech compression algorithms use packed bitfields for encoding information. Bitmasking instructions help for extracting/packing these fields.<br>
Max  and Min Operation instructions perform maximum  and  minimum operations.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
OPC specifies the type of instruction. Action (OPC):<br>
0	dest = (srcl 
1	dest = (srcl &gt; src2) ? srcl : src2<br>
Mnemonics:<br>
0	MIN    <dest>, <srcl>, <src2><br>
1	MAX  <dest>, <srcl>, <src2><br>
Flags:<br>
Z         is set if the result is zero N        is set if the result is negative C         For Max: C is set if src2&gt;=srcl (dest=srcl case) For Min: C is set if src2&gt;=srcl (dest=src2 case) V        preserved.<br>
Reasons for inclusion:<br>
In order to find the strength of a signal many algorithms scan a sample to find the minimum/maximum of the absolute value of the samples. The MAX and MIN operations are invaluable for this. Depending on whether you wish to find the first or last maximum in the signal the operands srcl and src2 can be swapped around.<br>
MAX X0, X0, #0 will convert XO to a positive number with clipping below. MIN    X0, X0, #255 will clip XO above. This is useful for graphics processing.<br>
Max and Min Operations in Parallel instructions perform maximum and minimum operations on parallel 16-bit data.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
OPC specifies the type of instruction.<br>
Action (OPC):<br>
0         dest.l - (srcl.l 
dest.h = (srcl.h 
1	dest.l - (srcl.l &gt; src2.1) ? srcl.l : src2.1<br>
dest.h = (srcl.h &gt; src2.h) ? srcl.h : src2.h<br>
Mnemonics:<br>
0         MINMIN        <dest>, <srcl>, <src2><br>
1	MAXMAX     <dest>, <srcl>, <src2><br>
Flags:<br>
Z         is set if the upper 16 bits of the result is zero<br>
N         is set if the upper 16 bits of the result is negative<br>
C         For Max: C is set if src2.h&gt;=srcl.h (dest=srcl case)<br>
For Min: C is set if src2.h&gt;=srcl.h (dest=src2 case)<br>
V         preserved.<br>
SZ,SN,SC,SV are set similarly for the lower 16-bit halves.<br>
Reasons for inclusion:<br>
As for 32-bit Max and Min.<br>
Move Long Immediate Operation instructions allow a register to be set to any signed 16-bit, sign extended value. Two of these instructions can set a 32-bit register to any value (by accessing the high and low half in sequence). For moves between registers see the select operations.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
Mnemonics:<br>
MOV  <dest>, #<imm_16><br>
The assembler will provide a non-interlocking NOP operation using this MOV instruction, i.e. NOP is equivalent to  MOV , #0.<br>
Flags:<br>
Flags are unaffected.<br>
Reasons for inclusion: Initialising registers/counters.<br>
Multiply Accumulate Operation instructions perform signed multiplication with accumulation or de-accumulation, scaling and saturation.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
The field OPC specifies the type of instruction.<br>
Action (OPC):<br>
00       dest = (ace + (srcl * src2)) {-&gt;&gt; scale}<br>
01        dest = (ace - (srcl * src2)) {-&gt;&gt; scale}<br>
In each case the result is saturated before being written to the destination if the Sa bit is set.<br>
Mnemonics:<br>
0	(S}MULA        <dest>, <srcl_16>, <src2_16>, <acc> {,<scale>}<br>
1	{S}MULS         <dest>, <srcl_16>, <src2_16>, <acc> {,<scale>}<br>
An S before the command indicates saturation.<br>
Flags:<br>
See section above. Reasons for inclusion:<br>
A one cycle sustained MULA is required for FIR code. MULS is used in the FFT butterfly. A MULA is also useful for multiply with rounding. For example AO=(X0*X1+16384)&gt;&gt;15 can be done in once cycle by holding 16384 in another accumulator (Al for example). Different <dest> and <acc> is also required for the FFT kernel.<br>
Multiply Double Operation instructions perform signed multiplication, doubling the result prior to accumulation or de-accumulation, scaling and saturation.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
OPC specifies the type of instruction. Action (OPC):<br>
0	dest = SAT((acc + SAT(2 * srcl * src2)) {-&gt;&gt; scale})<br>
1	dest = SAT((acc - SAT(2 * srcl * src2)) {-&gt;&gt; scale})<br>
Mnemonics:<br>
0	SMLDA	<dest>, <srcl_16>, <src2_16>, <acc> {,<scale>}<br>
1	SMLDS	<dest>, <srcl_16>, <src2_16>, <acc> {,<scale>}<br>
Flags:<br>
See section above. Reasons for inclusion:<br>
The MLD instruction is required for G.729 and other algorithms which use fractional arithmetic. Most DSPs provide a fractional mode which enables a left shift of one bit at the output of the multiplier, prior to accumulation or writeback. Supporting this as a specific instruction provides more programming flexibility. The name equivalents for some of the G series basic operations are:<br>
L_msu =&gt; SMLDS L_mac =&gt; SMLDA<br>
These make use of the saturation of the multiplier when left shifting by one bit. If a sequence of fractional multiply-accumulates is required, with no loss of precision, MULA can be used, with the sum maintained in 33.14 format. A left shift and saturate can be used at the end to convert to 1.15 format, if required.<br>
Multiply Operation instructions perform signed multiplication, and optional<br>
scaling/saturation. The source registers (16-bit only) are treated as signed numbers.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
OPC specifies the type of instruction. Action (OPC):<br>
0	dest - (srcl * src2) {-&gt;&gt; scale}<br>
1	dest - SAT((srcl * src2) {-&gt;&gt; scale})<br>
Mnemonics:<br>
0	MUL   <dest>, <srcl_16>, <src2> {,<scale>}<br>
1	SMUL	<dest>, <srcl_16>, <src2> {,<scale>}<br>
Flags:<br>
See section above. Reasons for inclusion:<br>
Signed and saturated multiplies are required by many processes.<br>
Register List Operations are used to perform actions on a set of registers. The Empty and Zero instructions are provided for resetting a selection of registers prior to, or in between routines. The Output instruction is provided to store the contents of a list of registers to the output FIFO.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
OPC specifies the type of instruction. Action (OPC):<br>
000	for (k=0; k
if bit k of the register list is set then register k is marked as being empty.<br>
001	for (k=0; k
if bit k of the register list is set then register k is set to contain 0.<br>
10	Undefined<br>
11	Undefined<br>
100	for (k=0; k
if bit k of the register list is set then<br>
(register k -&gt;&gt; scale) is written to the output FIFO.<br>
101	for (k=0; k
if bit k of the register list is set then<br>
(register k -&gt;&gt; scale) is written to the output FIFO and<br>
register k is marked as being empty.<br>
110	for (k=0; k
if bit k of the register list is set then<br>
SAT(register k -&gt;&gt; scale) is written to the output FIFO.<br>
111	for (k=0; k
if bit k of the register list is set then<br>
SAT(register k -&gt;&gt; scale) is written to the output FIFO and<br>
register k is marked as being empty.<br>
Mnemonics:<br>
000 001 010 Oil 100 101 110 111<br>
EMPTY<br>
ZERO<br>
Unused<br>
Unused<br>
OUTPUT<br>
OUTPUT<br>
SOUTPUT<br>
SOUTPUT<br><register_list><register_list><br><register_list> {,<scale>} <register_list>^ {,<scale>} <register_list> {,<scale>} <register_list>^ {,<scale>}<br>
Flags:<br>
Unaffected<br>
Examples:<br>
EMPTY	{A0, Al, XO-X3}<br>
ZERO	{Y0-Y3}<br>
OUTPUT        {X0-Y1}^<br>
The assembler will also support the syntax<br>
OUTPUT        Rn In which case it will output one register using a MOV ^, Rn instruction.<br>
The EMPTY instruction will stall until all registers to be empties contain valid data (i.e. are not empty).<br>
Register list operations must not be used within re-mapping REPEAT loops. The OUPUT instruction can only specify up to eight registers to output. Reasons for inclusion:<br>
After a routine has finished, the next routine expects all registers to be empty so it can receive data from the ARM. An EMPTY instruction is needed to accomplish this. Before performing a FIR or other filter all accumulators and partial results need to be zeroed. The ZERO instruction helps with this. Both are designed to improve code density by replacing a series of single register moves. The OUTPUT instruction is included to improve code density by replacing a series of MOV ^, Rn instructions.<br>
A Remapping Parameter Move Instruction RMOV is provided to allow the configuration of the user defined register re-mapping parameters.<br>
The instruction encoding is as follows:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
Each PARAMS field is comprised of the following entries:<br>
(Table Removed)<br>
The meaning of these entries is described below<br>
PARAMETER DESCRIPTION<br>
RENUMBER<br>
Number of 16-bit registers to perform re-mapping on, may take the values 0, 2, 4, 8.<br>
Registers below RENUMBER are re-mapped, those above are accessed directly.<br><br>
BASEINC<br>
The amount the base pointer is incremented at the end of each loop. May take the values 1, 2, or<br>
4.<br>
BASEWRAP<br>
The base wrapping modulus may take the values 2, 4, 8.<br>
Mnemonics:<br>
RMOV <params>, [<params>] The <params> field has the following format:<br><params>    ::=  <bank><baseinc> n<renumber><br>
w<basewrap><br><bank>       ::= [X|Y|Z] <baseinc>   ::= [++|+l|+2| <renumber> ::= [O|2|4|8] <basewrap> ::= [2|4|8]<br>
If the RMOV instruction is used whilst re-mapping is active, the behaviour is UNPREDICTABLE.<br>
Flags:<br>
Unaffected<br>
Repeat Instructions provide four zero cycle loops in hardware. The REPEAT instruction defines a new hardware loop. Piccolo uses hardware loop 0 for the first REPEAT instruction, hardware loop 1 for a REPEAT instruction nested within the first repeat instruction and so on. The REPEAT instruction does not need to specify which loop is being used. REPEAT loops must be strictly nested. If an attempt is made to nest loops to a depth greater than 4 then the behaviour is unpredictable.<br>
Each REPEAT instruction specifies the number of instructions in the loop (which immediately follows the REPEAT instruction) and the number of times to go around the loop (which is either a constant or read from a Piccolo register).<br>
If the number of instructions in the loop is small (1 or 2) then Piccolo may take extra cycles to set the loop up.<br>
If the loop count is register-specified, a 32-bit access is implied (S 1=1),._<br>
though only the bottom 16 bits are significant and the number is considered to be unsigned. If the loop count is zero, then the action of the loop is undefined. A copy of the loop count is taken so the register can be immediately reused (or even refilled) without affecting the loop.<br>
The REPEAT instruction provides a mechanism to modify the way in which register operands are specified within a loop. The details are described above<br>
Encoding of a REPEAT with a register specified number of loops:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
Encoding of REPEAT with a fixed number of loops:<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 10<br><br>
(Table Removed)<br>
The RFIELD operand specifies which of 16 re-mapping parameter configurations to use inside the loop.<br>
(Table Removed)<br>
The assembler provides two opcodes REPEAT and NEXT for defining a hardware loop. The REPEAT goes at the start of the loop and the NEXT delimits the end of the loop, allowing the assembler to calculate the number of instructions in the loop body. For the REPEAT it is only necessary to specify the number-ef loops either as a constant or register. For example:<br><br>
REPEAT<br>
MULA<br>
MULA<br>
NEXT<br><br>
X0<br>
A0, Y0.l , Z0.l , A0<br>
A0, Y0.h^, Z0.h^, A0<br><br>
This will execute the two MULA instructions X0 times. Also, REPEAT        #10<br>
MULA NEXT<br>
A0, X0^, Y0^, A0<br><br>
will perform 10 multiply accumulates. The assembler supports the syntax:<br>
REPEAT #iterations [, <params>]<br>
To specify the re-mapping parameters to use for the REPEAT. If the required remapping parameters are equal to one of the predefined set of parameters, then the appropriate REPEAT encoding is used. If it is not then the assembler will generate an RMOV to load the user defined parameters, followed by a REPEAT instruction. See the section above for details of the RMOV instruction and the re-mapping parameters format.<br>
If the number of iterations for a loop is 0 then the action of REPEAT is UNPREDICTABLE.<br>
If the number of instructions field is set to 0 then the action of REPEAT is UNPREDICTABLE.<br>
A loop consisting of only one instruction, with that instruction being a branch will have UNPREDICTABLE behaviour.<br>
Branches within the bounds of a REPEAT loop that branch outside the bounds of that loop are UNPREDICTABLE.<br>
The Saturating Absolute instruction calculates the saturated absolute of source 1.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
Action:<br>
dest = SAT((srcl &gt;= 0) ? srcl : -srcl). The value is always<br>
saturated. In particular the absolute value of 0x80000000 is 0x7fffffff and NOT 0x80000000!<br>
Mnemonic:<br>
SABS <dest>, <srcl> Flags:<br>
Z	is set if the result is zero.<br>
N	is preserved.<br>
C	is set of src
V	is set if saturation occured.<br>
Reasons for inclusion:<br>
Useful in many DSP applications.<br>
Select Operations (Conditional Moves) serve to conditionally move either source 1 or source 2 into the destination register. A select is always equivalent to a move. There are also parallel operations for use after parallel adds/subtracts.<br>
Note that both source operands may be read by the instruction for implementation reasons and so if either one is empty the instruction will stall, irrespective of whether the operand is strictly required.<br>
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0<br><br>
(Table Removed)<br>
OPC specifies the type of instruction.<br>
Action (OPC):<br>
00        If <cond> holds for primary flags	then dest=srcl<br>
else dest=src2.<br>
01        If <cond> holds for the primary flags         then dest.h=srcl.h<br>
else dest.h=src2.h,<br>
If <cond> holds for the secondary flags      then dest.l=srcl.l<br>
else dest.l=src2.1.<br>
10       If <cond> holds for the primary flags         then dest.h=srcl.h<br>
else dest.h=src2.h,<br>
If <cond> fails for the secondary flags        then dest.l-srcl.l<br>
else dest.l=src2.1.<br>
11        Reserved<br>
Mnemonics<br>
00        SEL<cond><dest>, <srcl>, <src2><br>
01        SELTT<cond><dest>, <srcl>, <src2><br>
10        SELTF<cond><dest>, <srcl>, <src2><br>
11        Unused<br>
If a register is marked for refill, it is unconditionally refilled. The assembler also provides the mnemonics:<br>
MOV<cond><dest>, <srcl><br>
SELFT<cond><dest></dest></cond></srcl></dest></cond></src2></srcl></dest></cond></src2></srcl></dest></cond></src2></srcl></dest></cond></cond></cond></cond></cond></cond></srcl></dest></params></basewrap></renumber></baseinc></bank></basewrap></renumber></baseinc></bank></params></params></params></params></scale></register_list></scale></register_list></scale></register_list></scale></register_list></register_list></register_list></scale></src2></srcl_16></dest></scale></src2></srcl_16></dest></scale></acc></src2_16></srcl_16></dest></scale></acc></src2_16></srcl_16></dest></acc></dest></scale></acc></src2_16></srcl_16></dest></scale></acc></src2_16></srcl_16></dest></imm_16></dest></src2></srcl></dest></src2></srcl></dest></src2></srcl></dest></src2></srcl></dest></src2></srcl></src2></srcl></scale></src2></srcl></dest></scale></src2></srcl></dest></scale></src2></srcl></dest></scale></src2></srcl></dest></srcl></dest></scale></src2></srcl></dest></scale></src2></srcl></dest></destination></cond></cond></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></scale></src2_32></srcl_32></dest></acc></dest></scale></acc></src2></srcl></dest></scale></acc></src2></srcl></dest></src2></srcl></src2></srcl></dest></srcl></src2></src2></srcl></dest></cond></basewrap></renumber></baseinc></bank></basewrap></renumber></baseinc></bank></params></imm_6></immed_8></scale></dest></acc></src2_shift></src2_par></src2></src2_shift></src2></src2_maxmin></scale></immed_6></immed_8></scale></src2></srcl_32></srcl_16></srcl></scale></lscale></size></size></size></cond></dest></dest></dest></dest></dest></wrap></wrap></size></wrap></dest></size></size></wrap></dest></wrap></dest></dest></size></dest></size></size></size></dest></dest></cond></bank></cond></size></wrap></dest></cond></size></dest></cond></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">2577-del-1997-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">2577-del-1997-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1jb3JyZXNwb25kZW5jZS1vdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">2577-del-1997-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1jb3JyZXNwb25kZW5jZS1wby5wZGY=" target="_blank" style="word-wrap:break-word;">2577-del-1997-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">2577-del-1997-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">2577-del-1997-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1mb3JtLTEucGRm" target="_blank" style="word-wrap:break-word;">2577-del-1997-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1mb3JtLTEzLnBkZg==" target="_blank" style="word-wrap:break-word;">2577-del-1997-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1mb3JtLTE5LnBkZg==" target="_blank" style="word-wrap:break-word;">2577-del-1997-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1mb3JtLTIucGRm" target="_blank" style="word-wrap:break-word;">2577-del-1997-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1mb3JtLTI5LnBkZg==" target="_blank" style="word-wrap:break-word;">2577-del-1997-form-29.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1mb3JtLTMucGRm" target="_blank" style="word-wrap:break-word;">2577-del-1997-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1mb3JtLTQucGRm" target="_blank" style="word-wrap:break-word;">2577-del-1997-form-4.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1mb3JtLTYucGRm" target="_blank" style="word-wrap:break-word;">2577-del-1997-form-6.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1ncGEucGRm" target="_blank" style="word-wrap:break-word;">2577-del-1997-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1wY3QtMjEwLnBkZg==" target="_blank" style="word-wrap:break-word;">2577-del-1997-pct-210.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1wY3QtNDA4LnBkZg==" target="_blank" style="word-wrap:break-word;">2577-del-1997-pct-408.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1wY3QtNDA5LnBkZg==" target="_blank" style="word-wrap:break-word;">2577-del-1997-pct-409.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1wY3QtNDE2LnBkZg==" target="_blank" style="word-wrap:break-word;">2577-del-1997-pct-416.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1wZXRpdGlvbi0xMzcucGRm" target="_blank" style="word-wrap:break-word;">2577-del-1997-petition-137.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU3Ny1kZWwtMTk5Ny1wZXRpdGlvbi0xMzgucGRm" target="_blank" style="word-wrap:break-word;">2577-del-1997-petition-138.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QuanBn" target="_blank" style="word-wrap:break-word;">abstract.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="215084-a-process-for-the-recovery-of-zinc-from-zinc-bearing-industrial-waste.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="215086-a-flat-metal-heat-exchanger.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>215085</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2577/DEL/1997</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>10/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>07-Mar-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>21-Feb-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>11-Sep-1997</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>ARM LIMITED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>110, FULBOURN ROAD, CHERRY HINTON, CAMBRIDGE CB1 9NJ, ENGLAND.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>RICHARD YORK,</td>
											<td>6 VIOLET CLOSE, CHERRY HINTON, CAMBRIDGE, CB1 4YW.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>HEDLEY JAMES FRANCES</td>
											<td>SPRING COTTAGE, WESTON GREEN, WESTON COLVILLE, CAMBRIDGE, CB1 5NS</td>
										</tr>
										<tr>
											<td>3</td>
											<td>DOMINIC SYMES</td>
											<td>7 WEDGEWOOD DRIVE, CHERRY HINTON, CAMBRIDGE, CB1 4HY.</td>
										</tr>
										<tr>
											<td>4</td>
											<td>STUART BILES</td>
											<td>622 NEWMARKET ROAD, CAMBRIDGE, CB5 8LP.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 9/34</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>9619823.9</td>
									<td>1996-09-23</td>
								    <td>U.K.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/215085-a-data-processing-apparatus-and-a-method-of-operating-the-same by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:09:26 GMT -->
</html>
