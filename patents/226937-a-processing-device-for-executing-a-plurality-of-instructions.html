<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/226937-a-processing-device-for-executing-a-plurality-of-instructions by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:42:03 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 226937:&quot;A PROCESSING DEVICE FOR EXECUTING A PLURALITY OF INSTRUCTIONS&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;A PROCESSING DEVICE FOR EXECUTING A PLURALITY OF INSTRUCTIONS&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A processor for executing a plurality of instructions comprising: execution resources (105) to execute the plurality of instructions; a monitor (110) coupled to the execution resources, the monitor to detect a low progress indicating condition of said execution resources, said monitor to selectively disrupt processing of at least one program by transferring to a handler in response to detecting said low progress indicating condition.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>The   present   invention   relates   to   a  processor   for   executing   a  plurality   of instructions.<br>
The present disclosure pertains to the field of processing apparatuses and systems that process sequences of instructions or the like, as well as certain insiniclion sequences to program such apparatuses and/or systems. Some embodiments relate to monitoring and/or responding to conditions or events within execution resources of such processing apparatuses.<br>
2. Description of Related An<br>
. Various mechanism are presently used to change the flow of control (i.e., the processing path or instruction sequence being followed) in a processing system. For example, a jump instruction in a program sequence explicitly and precisely causes a jump to a new address. The jump instruction is an example of an explicit change of the control flow because the instruction directs the processor to jump to a location and continue executing at that point. A traditional jump instruction is "precise" (or synchronous) because the jump occurs as a direct result of execution of the jump instruction.<br>
Another traditional example of a change in the flow of control is an interrupt. An interrupt may be an external signal provided to an apparatus such as a processor. The processor may respond by jumping to an interrupt handler, a routine that handles the<br>
event(s) signaled by a particular interrupt.  Interrupts are typically also relatively precise in that they are recognized and acted upon by a processor within a particular window of lime in relation to their receipt.  In particular, interrupts are oflen serviced at the next instruction boundary after they are received internally.     In some cases, only the operating system or other software operating at a high privilege level is allowed to mask interrupts, so a user program may have no opportunity to enable or disable these control flow changing events.   Another traditional example of a change in the flow of control occurs  in response  to  an  exception.     An exception  typically  reflects a predefined  architectural condition such as a result of a mathematical instruction meeting certain criteria (denormal,  underflow, overflow, not a number, etc.).   Some exceptions can be masked, for example,  by setting a bit in a control register.   If an exception occurs and is not masked, then an exception handler is called to handle the exception.<br>
 Another technique that changes the flow of control of a processor is the use of<br>
 • breakpoints.  Breakpoints are typically u.sed in debugging.  A particular instruction address<br>
  may be programmed into a breakpoint register.  The processor may do various acts (other<br>
than continue with the program as usual) when a breakpoint is active and the target address<br>
is reached. Breakpoints allow single-stepping through a program, among other things.<br>
 Multi-threading is a technique by which processor hardware may be utilized by<br>
multiple different threads.   Multi-threaded processors may switch between threads for a<br>
variety of reasons.   For example, a processor may have an algorithm that automatically<br>
switches between available threads.   Other processors use switch-on-event multithreading<br>
(SoEMT), whereby certain events such as a cache miss may give rise to a thread switch.<br>
Thread switching  can be considered a change of control  flow because the processor<br>
switches the .sequence or stream which it execules.<br>
 In one prior art reference, a quiesce instruction is detailed (see US Pat. No. 6,493,741). In one example, the quiesce instruction slops processing in one thread until either a timer expires or a memory write to a memory location occurs. Therefore, an instruction such as the quiesce instruction may itself trigger the temporary cessation of processing of the thread containing the quiesce instruction and a switch to another thread.<br><br>
According to the present invention there is provided aprocessing device for executing a plurality of instructions comprising:<br>
execution resources  to execute the plurality of instructions;<br>
a monitor coupled to the execution resources, the monitor to detect a low progress indicating condition of said execution resources, said monitor to selectively disrupt processing of at least one program by transferring to a handler in response to detecting said low progress indicating condition.<br>
Brief Description of the Figures<br>
The present invention is illustrated by way of example and not limitation in the Figures of the accompanying drawings.<br>
Figure 1 illustrates one embodiment of a system that can delect and respond to processing conditions of execution resources.<br>
Figure 2 illustrates a flow diagram of operations for one embodiment of the system of Figure 1.<br>
Figure 3 illustrates a flow diagram of operations for another embodiment of the system of Figure 1.<br>
Figure 4 illustrates another embodiment of a system that can respond to multiple different performance events and/or to composite performance events.<br>
Figure 5a illustrates one embodiment of a monitor that may recognize composite events.<br>
Figure 5b illustrates another embodiment of a monitor.<br>
Figure 5c illustrates another embodiment of a monitor.<br>
Figure 6 illustrates a flow diagram for execution of a user program that activates helper threads in response to program-definable triggers according to one embodiment.<br>
Figure 7 illustrates a flow diagram for a process of refming monitor settmgs according to one embodiment.<br>
Figure 8 illustrates a flow diagram for a process of updating software<br>
according to one embodiment.<br>
       Figure 9a illustrates a flow diagram in which multiple nested helper threads<br>
are activated to assist processing of a program.<br>
   Figure 9b illustrates thread switching logic for one embodiment which<br>
supports virtual threads.<br>
    Figure 10a illustrates one embodiment of a context-sensitive event schema<br>
vector and mask implementation.<br>
      Figure 10b illustrates one embodiinent of a context-sensitive event schema<br>
vector and mask implementation.<br>
    Figure 11 illustrates one embodiment of a multithreaded processor which<br>
performs thread switching based on monitor events.<br>
Detailed Description<br>
 The following description describes embodiments of a programmable event driven yield mechanism which may activate other threads. In the following description, numerous specific details such as processor types, microarchitectural conditions, events, enablement mechanisms, and the like are set forth in order to provide a more thorough understanding of the present invention. It will be appreciated, however, by one skilled in the art that the invention may be practiced without such specific details. Additionally, some well known structures, circuits, and the like have not been shown in detail to avoid unnecessarily obscuring the present invention.<br>
 In .some embodiments, disclo.sed techniques may allow a program to actively monitor and respond to conditions of the execution resources which execute the program while executing the program. Effectively, such embodiments may incorporate real-time execution resource operating condition feedback to improve performance. If the execution resources encounter execution delaying conditions, the program execution may be disrupted to make adjustments. In some embodiments, a handler may be activated and may spawn a helper thread to attempt to improve execution of the original thread. In other embodiments, the disruption may be accomplished by switching to another program thread that may not be a helper thread. These and other embodiments may in some cases advantageously improve processing throughput and/or allow optimizations to be tailored to particular hardware.     Turning to Figure 1, one embodiment of a system that can detect and respond<br>
to processing conditions of execution resources is illustrated. In the embodiment of Figure 1, execution resources 105, a monitor 110, and enable logic 120 form a ponion of a processor 100 that is capable of executing instructions. The execution resources may include hardware resources that may be integrated into a single component or integrated circuit in some embodiments. However the execution resources may include software or firmware resources or any combination of hardware and software and/or firmware that may also be used in execution of program instructions. For example, firmware may be used as a part of an abstraction layer or may add functions to processing hardware, as may software. Software also may be used to emulate part or all of an instruction set or to otherwise assist in processing.<br>
      The processor may be any of a variety of different types of processors that execute instructions.   For example, the processor may be a general purpose processor such as a processor in the Pentium® Processor Family or the Itanium® Processor Family or other  processor  families  from  Intel   Corporation  or  other  processors  from  other companies.    Thus, the processor may be a reduced instrviction set computing (RISC) processor, a complex instruction set computing (CISC) processor, a very long instaiction word (VLfW) processor, or any hybrid or alternative processor type.   Moreover, special purpose   processors   such   as   network   or  communication   processors,   co-processors, embedded processors, compression engines, graphics processors, etc., may use disclosed techniques.   As integration trends continue and processors become even more complex, the need to monitor and react to internal performance indicators may further increase, thus making presently disclosed techniques more desirable.    However, due to rapid technological   advance  in   this  area  of technology,   it  is  difficult  to  foresee  all   the<br>
applications of disclosed technology, though they may be widespread for complex hardware that executes program sequences.<br>
 As shown in Figure 1, the processor 100 is coupled to a storage medium 150 such as a memory. The storage medium 150 may be a memory subsystem having various levels of hierarchy which may include but are not limited to various levels of cache memory, system memory such as dynamic random access memory or the like, and nonvolatile storage such as flash memory (e.g. memory' stick etc), a magnetic or optical disk. As illustrated, the storage medium stores a program 160 and a handler and/or other thread such as a helper thread 170.<br>
 To allow the monitor to monitor the desired events, the monitor 110 may be coupled to various portions of execution resources in order to detect particular conditions or to be informed of cenain microarchitectural events. Signal lines may be routed to the monitor 110, or the monitor may be strategically placed with or integrated with relevant resources. The monitor may include various programmable logic or software or firmware elements or may be custom designed to detect a particular condition. The monitor tracks the various events or conditions, and if the events or conditions it is programmed to detect occur, then the execution resources 105 are signaled to disrupt the norma! control flow the program would otherwise follow. As indicated in Figure 1, the disruption may result in an event handler being called or a thread switch occurring.<br>
 One example of a specific detectable condition is that data may be missing from a cache memory, resulting in the event of a cache miss occurring. In fact, a program may generate a pattern of memory accesses that causes repeated cache misses, thereby degrading performance. Such an occurrence of a cenain number of cache misses within a<br>
period of time or during execution of a portion of code is one example of an event thai indicates a relatively low level of progress is being made in executing that section of code.<br>
 Other detectable events which may be low progress indicators may relate to various other microarchitectural or structural details of the execution resources. A monitor may detect a condition involving one or more of a stall of a resource, a cache event, a retirement event, a branch or branch prediction result, an exception, a bus event, or a variety of other commonly monitored or performance-impacting events or conditions. The monitor may count or otherwise time, quantify, or characterize such events or conditions, and may be programmable when a particular metric associated with one or more events or conditions occurs.<br>
 Figure 2 illustrates a flow diagram of operations for one embodiment of the system of Figure 1. As indicated in block 200 of Figure 2, the program 160 may set conditions to cau.se a change in the execution control flow. For example, the enablement logic 120 may control both activation of the monitor and which event(s) to detect. Alternatively, the enablement logic 120 may enable and/or mask events, and the monitor 110 may it.self also be programmable for further flexibility in specifying the events or conditions within the execution resources or system that are tracked. In either case, the program 160 itself may specify conditions that are to be watched during its own execution. The program 160 may also provide the handler or thread 170 which is activated when the monitored condition(s) occur. For example, the program may be a program which includes a main thread and a helper thread or helper routine that attempts to improve execution of the main thread if conditions the program specifies occur.<br><br>
        As indicated in block 205, the program instructions are executed.   Execution of the program causes the state of the execution resources to change.   For example, a variety of conditions may occur or be present that inhibit forward progress in execution of the  program.     As  indicated  in  block  210,  the  various  processing  metrics  and/or microarchitectural conditions may be monitored to determine if the triggering event programmed in block 200 occurs.  If the triggering state does not occur in block 210, the monitor is not triggered, and program execution continues by returning to block 205.         In some cases, the triggering state bears only an  indirect  relationship to execution of any single instruction. For example, a prior art breakpoint detector typically causes a break when an instruction pointer reaches a designed address.  Such breakpoints are preci.se because a particular instruction (i.e., its address) directly triggers the break. Also, the prior art quiesce instruction itself causes a thread to stop at least temporarily. In contrast, some embodiments utilizing disclosed techniques trigger control flow changes on a set of conditions that are not necessarily caused by a single instruction, but rather may be cau.sed by the overall program flow and/or system environment. Thus, while the monitor may repeatedly trigger at the same instruction execution state in a single system, other conditions, environments, system, etc., may cause different trigger points for the same program.   In this sense, di.sclo.sed techniques, in some cases, provide an imprecise or asynchronous mechanism generating a control flow change that is not directly tied to an instruction execution boundary.    Moreover, such an imprecise mechanism may, in some embodiments, test for events at a less fine granularity than each instruction and/or may delay recognition of events for some period of time because architectural correctness does nol depend on any  processing-rate-enhancing helper routines executing at any<br>
particular point m time.<br>
   When the triggering state is delected by the monitor in block 210, processing of the program is disrupted as indicated in block 215.    Generally, the system may responsively adjust because processing of the program is occurring inefficiently or in a manner other than the manner the programmer desired.   For example, another software routine such as another program portion may be invoked. The other program portion may be another thread unrelated to the original thread or may be a helper thread that helps execute the original thread, for example by prefetching data to reduce cache misses. Alternatively, a program-transparent (e.g.,  hardware) mechanism may perform some optimizations,   reconfiguration  (including,  but   not   limited  to  reconfiguration   of the monitor setup), reallocation of resources or the like to hopefully improve processing.   One example which invokes a helper thread is illustrated in Figure 3.    In particular, the flow diagram of Figure 3 details operations for one embodiment of the system of Figure 1 in which the execution resources are multithreaded resources and the program invokes a helper thread when a certain triggering condition occurs.   Thus, as indicated in block 300, a first thread (e.g., a main program) sets a monitor condition. The condition may be any one or more of the variety of conditions discussed herein. The first thread executes a code section as indicated in block 310.  If the triggering condition does not occur, as tested in block 320, then the code section continues executing, as indicated in block 310.<br>
 If the triggering condition does occur, then a helper thread is activated to assist the first thread as indicated in block 330. The helper thread may be activated by a routine such as a handler routine or just be activated by a thread switch.   For example, in one<br>
embodiment, the trigger condition signaled by the monitor to the execution resource may cause the execution resource to jump to an event handler that spawns a helper thread. In another embodiment, the helper thread may just be one of the other active threads. In yet another embodiment, one or more special helper thread execution slots may be provided by the processor and the monitor may cause a switch to a helper thread from one of these slots. As indicated in block 340, both threads may then continue to execute. Hopefully, the helper thread, runs ahead and clears up conditions that would otherwise cause the first thread to stall or perform poorly.<br>
   Figure 4 illustrates another embodiment of a system that can respond to multiple different performance events and/or to composite performance events.   In the embodiment of Figure 4, execution resources 400 are shown as including a set of N monitors 410-1 through 410-N.    Additionally, an event schema vector (ESV) storage location 420 and  an event schema  vector mask (ESVM) storage  location 425  are provided.    The embodiment of Figure 4 shows a number of monitors (N) corresponding to the number of bits in the event schema vector and the event schema mask vector.   In other embodiments, there may be different numbers of monitors and bits in these vectors, and the monitors may or may not correlate directly to the bits.  For example, a condition involving multiple monitors may correlate to a single vector bit in some embodiments.  The execution resources 400 are optionally coupled to an event descriptor table 430 (EDT), which may be locally implemented on the processor or in a coprocessor or system memory.    Control flow logic 435 is coupled the monitors 410-1 through 410-N and lo receive values from the event schema vector and the event schema vector mask.   The control flow logic 435 changes the control flow for processing logic<br>
when a condition detected by one or more of the monitors is enabled according to the event schema vector and event schema vector mask.<br>
 The embodiment of Figure 4 also illustrates decode logic 402 and a set of machine or model specific registers 404 (MSRs).  Either or both of the decode logic 402 and the model specific registers may be used to program and/or activate the monitors and the event schema vector and mask.   For example, MSRs may be used to program the types or number of events that trigger the monitors. MSRs may also be used to program the   event   schema   vector   and   mask.      Alternatively,   one   or   more   new   dedicated instruction(s) to be decoded by the decoder 402 may be used for either or both of programming the monitors and the event schema vector and mask.   For example, a yield instruction may be used to enable disruption of processing a program when a certain set of conditions occurs. Some or all of the conditions may be specified by an operand to the yield instruction or otherwise programmed in advance of its execution.   Such a yield instruction may be decoded by the decoder 402 to trigger a microcode routine, to produce a corresponding micro-operation or micro-instruction, or sequences of micro-operations to directly signal appropriate logic, or activate a co-processor or to otherwise implement the  yield   functionality.     The   concept  of yielding   may   appropriately  describe   the instruction in some embodiments in  which one thread is allowed to continue after executing the yield instruction but may be slowed at some point by execution of another thread or handler.    For example, a largely single-threaded program may invoke extra helper threads and share the processor with those extra helper threads.  In the embodiment of Figure 4, a memory 440 includes event handlers 450 and a main thread 460. In some embodiments, the event descriptor table may be stored in<br><br>
the same memory or in the same memory hierarchy as the main thread 460 and handlers 450. As previously discussed, the hand!er(s) may spawn a helper thread to assist the main program in executing efficiently.<br>
 The memory 440 may also store an update module 442 to communicate via a<br>
communications interface 444. The update module 442 may be a hardware module or a<br>
software routine executed by the execution resources to obtain new conditions to be<br>
programmed into various monitors and/or enablement logic. The update module 442 may<br>
also obtain new helper threads or routines. For example, these may be downloaded by a<br>
software program from the vendor of the software program to provide enhanced<br>
performance.	Thus,   the   network   interface   444   may   be   any   network   and/or<br>
communication interface that allows information transfer via a communication channel. In some cases, the network interface may interface to the Internet to download new conditions and/or helper routines or threads.<br>
 In one embodiment, each bit of the event schema vector indicates the occurrence or non-occurrence of a particular event, with the particular event possibly being a composite event reflective of (and/or expressed via Boolean operations in terms of) a variety of conditions or other events. Occurrence of the particular event may set the bit in the event schema vector. Each bit in the event schema vector may have a corresponding bit in the event schema mask vector. If the mask bit indicates that the particular event is masked, then the control flow logic 435 may disregard the event, although the bit in the event .schema vector may remain set due to its occurrence. The user may choose whether to clear the event schema vector when unmasking events. Thus, an event may be masked for some time and handled laler. In some embodiments, the user<br>
may choose to specify the trigger as a level trigger or an edge trigger, depending upon various issues such as the relationship between event update, sampling and reset (or the hold lime of a trigger event in the ESV)<br>
  If the mask bit indicates that an event is unmasked, then the control flow logic 435 calls an event handler for that particular event in this embodiment. The control flow logic 435 may vector into the event descriptor table 430 based on the bit position in the event .schema vector, and accordingly, the event descriptor table may have N entries corresponding to the N bits in the event schema vector.   The event descriptor table may contain a handler address indicating an address to which the control flow logic 435 should re-direct execution, and may also include other information as may be useful in a particular embodiment.     For example,  privilege  level,  thread,  process,  and/or other information may be maintained or updated in the event descriptor table.    In another embodiment, the event descriptor table 430 may not be necessary or may be a single entry that indicates an address for a single event handier to handle all events.    In this case, the entry may be stored in a register or other processor storage location,  in one embodiment, a single handler may be used, and that handler may access the event schema vector to determine which event occurred and therefore how to respond. In another embodiment, the event schema vector may collectively define an event that causes the control flow logic 435 to call a handler.   In other words, the event schema vector may represent a variety of conditions that together signal one event.   For example, the event schema mask vector may be used to designate which of the events indicated by the event schema vector must occur to trigger execution of the handier.   Each bit may represent a  monitor reaching a programmable condition.    When all the non-masked<br>
monitors reach their respective designated conditions, then the handler is called. Thus, the entire event schema vector may be used to designate some complex composite condition that should trigger the execution of the handler.<br>
 In another embodiment, multiple event schema vectors and masks may be used to designate different conditions. The different vectors may vector to different handlers via the event descriptor table or some other mechanism. In another embodiment, some bits of one or more event schema vectors may be grouped to form events that trigger the calling of handlers. A variety of other different permutations will be apparent to those of skill in the an.<br>
     Figure 5a illustrates one embodiment of a monitor 500 that is programmable and capable of interfacing with a variety of performance monitors to signal a composite event.    For example, such performance monitors may record occurrences of various microarchitectural events or conditions such as: cache misses incurred at a given level of cache hierarchy, branch retirement; branch misprediction (or retirement of mispredicted branches); trace cache delivery mode changes or events; branch prediction unit fetch requests; cancellations of memory request;   cache line splits (count of completion of a split load, store, etc.); replay events; various types of bus transactions (e.g., locks, burst reads, writebacks, invalidates); allocations in a bus sequencer (or only certain types); numerical assist (an underflow, denormal, etc.); execution/retirement of a particular type of instruction or micro-operation (uOP);   machine clear (or count of pipeline flushes); resource stalls (register renaming resources, pipeline, etc.); processing of tagged uOPs; instructions or uOPs retired; lines allocated (&amp;/or of a particular state (e.g., M)) in cache; a number of cycles instruction fetch is stalled; a number of cvcles instruction length<br>
decoder is stalled; a number of cache fetches; a number of lines allocated (or evicted) in cache or the like. These are only a few examples of microarchitectural events or condilions that may be monitored. Various other possibilities as well as combinations of these or other conditions will be apparent to one of skill in the art. Moreover, those and/or other conditions or events may be monitored with any of the disclosed or like monitors in any of the disclosed embodiments.<br>
 Performance monitors are often included in processors to count certain events. The programmer may read such performance monitors' counts by manufacturer-defined interfaces such as specific processor macro-instructions like the RDPMC instruction supported by known Intel Processors. See, e.g.. Appendix A of Volume III of the Intel Software Developers Guide for the Pentium® 4 Processor. Other internal or microinstructions or micro-operations may be used to read performance counters in some embodiments. Thus, for example, performance monitors may be adapted for use with disclosed techniques. In some cases, a programmable performance monitor may be modified to provide event signaling capabilities. In other embodiments, performance monitors may be readable by other monitors to establish events.<br>
In the embodiment of Figure 5a, the monitor 500 may include a .set of programmable entries. Each entry may include an entry number 510, an enable field 511, a performance monitor number (EMON #) 512 to specify one of a set of performance monitors and a triggering condition 514. The triggering condition may be, for example, a certain count that is reached, a count that is reached within a certain period, a difference in count, etc. The monitor 500 may include logic to read or otherwise be coupled to receive counts from the designated performance monitors.   The monitor 500 signals the<br>
control flow logic when the various M conditions occur. A subset of the M entries may be used by selectively programming the enable fields for each entry.  Figure 5b illustrates another embodiment of a monitor 520. The monitor 520 represents a custom composite event monitor. The monitor 520 receives a set of signals via signal lines 528-1 through 528-X from various execution resources or resource portions and combines them via combinational logic 530. If the proper combination of signals is received, the monitor 520 signals the control flow logic via an output signal line 532.<br>
 Figure 5c illustrates another embodiment of a monitor 540. The monitor 540 includes a table having M entries. Each entry includes an enable field 552, a condition field 554, and a trigger field 556. The condition field may be programmed to specify what combination of input signals is to be monitored. The conditions may or may not be tied to other event detecting structures such as performance monitors, and therefore may be more general than those discussed with respect to Figure 5a. The trigger field 556 may specify the stale of those input signals needed to signal the control fiow logic. Again, each entry may be enabled/disabled via the enable field 552. In some embodiments, the condition and trigger fields may be combined. Various combinations of these and other types of known or otherwise available like, simpler, or more complex monitors will be apparent to one of skill in the art.<br>
Figure 6 illustrates a flow diagram for execution of a user program that activates helper threads in response to program-definable triggers according to one embodiment. In block 600, the program first tests whether the yield capability is present. The "yield capability" may be used herein as shorthand to refer to the ability of to disrupt<br>
processing flow based on a condition or event occurring. Alternatively to testing for yield compatibility support, the yield capability may use opcodes previous defined as no-operation opcodes and/or previously unused or undefined MSRs so that use of the yield capability will have no effect on processor lacking such capabilities. The presence of such capabilities can also be queried via checking special CPU-ID that encodes hints indicating if such capabilities are present on a given processor or platform. Similarly, special instruction such as Itanium's PAL (processor-abstraction layer) call or SALE (system abstraction layer environment) can be used to query the processor specific configuration information including availability of such program-definable yield capability. Assuming the yield capability is present, then the user program may read and/or reset various counters, as indicated in block 610. For example, performance monitor counters may be read so that a delta may be computed, or the values may be reset if that capability is available.<br>
 As indicated in block 620, the user program then sets the helper thread trigger condition. The yield capability may be accessible at a low privileged level (e.g., a user level) such that any program or most programs can utilize this feature. For example, the yield capability may be available to ring three privilege level programs in a Pentium® Processor family processor, or the like. Therefore, the user program itself is able to set its own performance-based trigger conditions. A user program or operating system that is aware of existence of such context-sensitive monitor configurations, may choose to save and restore such application specific monitor configuration/setup across thread/process context switch, if the application demands or the operating system can provide persistent monitoring capability.<br>
 As indicated in block 630, the user program continues to execute after programming the yield conditions. Whether the yield conditions occur is tested in block 640. If the yield condition does not occur, then program execution continues as indicated in block 630. If the yield condition does occur, then a helper thread is activated, as indicated in block 650. The flowchart form of Figure 6 tends to imply that a synchronous polling for events occurs, and this approach may be used in some embodiments. However, some embodiments asynchronously react to events when they occur or within a number of clock cycles of when they occur rather than polling for them at certain intervals. In some embodiments, a monitor condition may be set outside of a loop or other code section to detect a particular condition. This concept is demonstrated by the following pseudo-code example for a main thread and a helper thread.<br>
(Formula Removed)<br>
 One advantage of setting the trigger outside the loop is that compiler optimizations within the loop will not be inhibited. For example, some compilers do not optimize loops or sections of code with inlrinsics such as those which may be used to<br>
activate the yield capability.    By placing such intrinsics outside the loop, interference with compiler optimizations may be removed.<br>
 Figure 7 illustrates a flow diagram for a process of refining yield settings according to one embodiment. Using a processor with a yield capability or the like, a programmer may design a program as well as helper routines to be invokes under various circumstances as indicated in block 700. Thus, helper routines may be provided for various processing-impeding conditions that the programmer anticipates. The processor can invoke these routines if and when they are needed during execution of the program. The yield settings may include the event schema vector and mask values and/or monitor settings or the like.<br>
 On a particular processor, a certain yield setting might result in a favorable execution throughput. However, such determination may be quite difficult manually and thus better derived empiricaliy. Therefore a compiler or other tuning software (e.g., the Intel VTune code analyzer) may repeatedly simulate the code with different yield settings, thereby deriving optimal or desirable settings as indicated in block 710. Thus, desirable values for yield settings for runtime may be chosen as indicated in block 720. A program may be simulated on multiple different versions of a processor or multiple different processors, or in multiple different systems to derive different yield settings. A system or processor identification such as a CPU ID may be used by the program to select which yield settings to apply when it runs as indicated in block 730.<br>
 Furthermore, the use of a compact group of settings to optimize performance may facilitate software updates. For example, new yield values may be downloaded to optimize performance for a given processor or may be used to update software when new<br>
processors are released. Such new values may allow a binary or modular modification which does not substantially disturb or jeopardize the functionality of the existing software.<br>
 Figure 8 illustrates a flow diagram for a process of updating software according to one embodiment. As indicated in block 800, a new version of a microprocessor is released. The new version may have different latencies associated with microarchitectural events such as cache misses. Therefore, a routine previously written to activate helper threads after a given number of cache misses may be less effective due to a new cache miss latency. Therefore, the yield settings are re-optimized as indicated in block 810.<br>
  Once new settings are derived, the program can be updated (e.g., via an update module that may be a part of the program) as indicated in block 820. A modification or addition  to  the  yield  values  may  be  performed,  depending  on  the  details  of the implementation. Moreover, additional or different helper routines may be added to assist on the new processor implementations. In either case, the yield capability can enable the delivery of performance enhancements after the initial delivery of the software.   Such a capability may be quite advantageous in a great variety of scenarios, and may be used just to   provide   new   optimizations   without   any   change   in   the   underlying   hardware. Addilionally, the underlying software may be maintained in some cases. For example, if a helper routine is written to deal with a synthetic event (e.g., bad cache misses), then on different hardware the composition of events which triggers this routine may be changed without changing the actual routines themselves. For example, the monitor configuration values and/or ESV/ESVM values may be changed and the routines left in tact.<br>
 The effectiveness of disclosed techniques may be further enhanced by creating nested helper threads, and Figure 9a illustrates one example of such usage. In the embodiment of Figure 9a, the program sets the yield event(s) in block 900. The program continues execution in block 910. Whether a yield event (a trigger) occurs is tested in block 920. If no yield event occurs, then program execution continues as shown via block 910. If a yield event occurs, then a helper thread is activated as indicated in block 925. The helper thread sets another yield event as indicated in block 930. Thus, the helper thread effectively identifies a further condition that indicates that further processing assistance may be helpful. Such further condition may indicate whether the first helper thread is effective and/or may be designed to indicate a further condition that may be suspected to develop as a result of or in spite of activation of the first helper thread.<br>
 As indicated in block 940, both the program and the helper thread are active and executing threads. These threads execute concurrently in the sense that they are both active and executing in a multithreaded processing resource. Whether the new trigger condition has occurred by the combination of both the program and the helper thread is tested in block 950. If the new triggering condition does not occur, then execution for both threads continues as indicated in block 940. If the new triggering condition does occur, a second or nested helper thread is activated as indicated in block 960. Thereafter, the program and multiple helper threads may be active and execute as indicated in block 962. Thus, multiple nested helper threads may be employed in some embodiments. [0063] In one embodiment, multiple helper threads (either nested or non-nested) may be activated by the use of virtual threads. Rather than dedicating a full set of resources to<br>
expand the number of threads a processor can handle, a processor may effectively cache context  data   (in   a  cache   location,   a   register   location,   or   other  storage   location). Accordingly, one physical thread slot may be rapidly switched between multiple threads.  For example, the embodiment of Figure 9b illustrates thread switching logic according to one embodiment that allows virtual threads to be switched into a limited number of physical thread slots which have dedicated hardware to maintain a thread context. In the embodiment of Figure 9b, a plurality of helper threads 965-1 through 965-k may be presented to a virtual thread switcher 970. The virtual thread switcher 970 may also include other logic and/or microcode (not shown) to swap context information between the new and previously selected helper threads.  The virtual thread switcher 970 may be triggered to switch threads by either a synchronous or an asynchronous stimulus. For example, an asynchronous event defined by a yield-type of instruction may cause a thread switch between the virtual threads.    Additionally, helper threads may include synchronous   means   such   as   a   hall,   quiesce,   or  other   type   of execution-stopping instruction to signal a switch to another thread.    The virtual thread switch logic 970 presents a subset (e.g., in the embodiment of Figure 9b, one) of the virtual threads to the processor thread switch logic 980.    The processor thread switch logic 980 then switches between one of the helper threads as a first thread 967-1 and its other N-1 threads, up to thread 967-N.<br>
 In some embodiments, it may be advantageous to confine the yield capability to a particular program or thread. Therefore, the yield capability may be made context sensitive or non-promiscuous. For example. Figure 10a illustrates one embodiment of a context-sensitive event schema vector and mask implementation.   In the embodiment of<br>
Figure 10a, a storage area 1000 includes a context indicator field 1010 associated with each event schema vector and mask storage location 1020. The context indicator field identifies the context to which each event schema vector and mask pair applies. For example, a context value such as value of a control register (e.g., CR3 in an x86 processor indicating operating system process ID) may be used. Additional or alternatively, thread number information may be u.sed to define context. Therefore, in some embodiment, when a particular context is active, certain context specific events may be enabled to disrupt processing. As such, the yield mechanism may be non-promiscuous in that its events only affect certain contexts.<br>
 Figure 10b illustrates another embodiment of a context-sensitive event schema vector and mask implementation. In the embodiment of Figure 10b, an integer number k of contexts may be handled by providing one set of event schema vector and mask locations 1050-1 through 1050-k for each of the k contexts. For example, there may be k threads in a multithreaded processor, and each thread may have an event schema vector and mask or like yield-enablement mechanism. Notably, in other embodiments, it may be undesirable to track events only in certain contexts. For example, events may be reflective of overall processing activity and/or events may be pertain to or be caused by to multiple related threads.<br>
 Figure 11 illustrates one embodiment of a multithreaded processor which performs thread switching based on monitor or yield-type events. Although many embodiments have been di.scussed as disrupting processing flow by causing a handler to execute, other embodiments may define events that cause thread switches in a multithreaded processor.   For example, in the embodiment of Figure 11, thread switch<br>
logic is coupled to receive signals from a set of N monitors 1110-1 through 1110-N. The thread switch logic 1105 may also be coupled to one or more sets of event schema and mask pairs 1130-1 through 1130-p (p is a positive whole number). The event schema and mask pairs may allow the thread switch to combine and/or disregard certain monitor events in determining when to switch threads.<br>
 Execution resource 1120 may support execution of p threads, yet may be indifferent to whether an instruction belongs to a particular thread. The execution resource may be an execution unit, fetch logic, a decoder, or any other resource used in instruction execution. A multiplexer 1115 or other selection resource arbitrates between the various threads for access to the execution resource 1120. One of skill in the art will recognize that various resources may be shared or duplicated in a multithreaded processor and that various resources may have thread-switched access which allows a limited number of threads (e.g., one) to access the resource at a lime.<br>
If a set of conditions indicated by one or more monitors and/or one of the event schema vector and mask pairs occurs, the thread switch logic 1105 switches threads of execution. Thus, another thread may be activated instead of the thread that was active when the processor conditions matched those programmed. For example, a user program may control events that trigger thread switches.<br>
 In some multithreaded processors, each thread may have an associated set of event schema vector and mask pairs or the like. Thus, as shown in Figure 11, the multiplexer 1115 may arbitrate between p threads, and there may be a corresponding p event schema and mask pairs. Just because a processor is multithreaded, however, does not mean that all implementations use multiple event schema vectors and masks.   Some<br>
embodiments may use only one pair, or may use other enablement indicators. For example a single bit could be used as an enablement indicator to turn on or off a particular yield-type capability.<br>
 During developement, a design may go through various stages, from creation to simulation to fabrication.   Data representing a design may represent the design in a number of manners.   First, as is useful in simulations, the hardware may be represented using  a  hardware  description  language  or  another  functional  description   language Additionally, a circuit level model with logic and/or transistor gates may be produced at some stages of the design process.   Furthermore, most designs, at some stage, reach a level of data representing the physical placement of various devices in the hardware model.   In the case where conventional semiconductor fabrication techniques are used, the data representing the hardware model may be the data specifying the presence or absence of various features on different mask layers for masks used to produce the integrated circuit.  In any representation of the design, the data may be stored in any form of a machine readable medium.   An optical or electrical wave modulated or otherwise generated (o transmit such information, a memory, or a magnetic or optical storage such as a disc may be the machine readable medium.   Any of these mediums may "carry" or "indicate" the design or software information. When an electrical carrier wave indicating or carrying the code or design is transmitted, to the extent that copying, buffering, or retransmission   of the electrical  signal  is  performed,  a new copy  is  made.     Thus,  a communication provider or a network provider may make copies of an article (a carrier wave) embodying techniques of the present invention.   Thus, techniques for a programmable event driven yield mechanism which<br>
may activate other threads are disclosed. While certain exemplary embodiments have been described and shown in the accompanying drawings, it is to be understood that such embodiments are merely illustrative of and not restrictive on the broad invention, and that this invention not be limited to the specific constructions and arrangements shown and described, since various other modifications may occur to those ordinarily skilled in the art upon studying this disclosure. In an area of technology such as this, where growth is fast and further advancements are not easily foreseen, the disclosed embodiments may be readily modifiable in arrangement and detail as facilitated by enabling technological advancements without departing from the principles of the present disclosure or the scope of the accompanying claims.<br><br><br><br>
We Claim:<br>
1.	A   processing   device   for   executing   a   plurality   of  instructions<br>
comprising:<br>
execution resources (105) to execute the plurality of instructions; a monitor (110) coupled to the execution resources, the monitor to detect a low progress indicating condition of said execution resources, said monitor to selectively disrupt processing of at least one program by transferring to a handler in response to detecting said low progress indicating condition<br>
an enable logic (120) to enable the said monitor (110) to detect the low progress indicating condition by an instruction, wherein said low progress indicating condition which is a count of microarchitectural events is to be detected subsequent to completion of execution of the instruction.<br>
2.	The processing device as claimed in claim 1 wherein said monitor<br>
(110) is one of a plurality of monitor (410) and wherein said low<br>
progress indicating condition comprises one or more programmble<br>
counts being reached by one or more of the plurality of monitors.<br>
3.	The processing device as claimed in claim 2 wherein said plurality of monitors (410) are processor performance monitors that are also readable by a processor instruction.<br>
4.	The processing device as claimed in claim 1 wherein said low progress indicating condition comprises a programmable combination of processor-internal events.<br>
5.	The processing device as claimed in claim 1 comprising control flow logic (435) to cause an imprecise control flow change tied to one or more processor events rather than an instruction-execution boundary.<br>
6.	The processing device as claimed in claim 2 comprising control flow logic 435 to cause an asynchronous control flow change tied to one or more processor events rather execution of a single instruction.<br>
7.	The processing device as claimed in claim 1 wherein said monitor (110) is one of a plurality of monitors (410), the processor comprising:<br>
an event schema vector storage location (420) to store an event schema vector comprising a plurality of bits, each bit corresponding to one or more conditions associated with said plurality of monitors;<br>
an event schema vector mask storage location (425) to store an event schema vector mask comprising a second plurality of bits to indicate whether corresponding bits of the event schema vector are masked.<br>
8.	The processing device as claimed in claim 7 wherein each of the<br>
plurality of bits of the event schema vector represents an event all<br>
of which are to occur to indicate a composite event and disrupt<br>
processing unless masked.<br>
9.	The processing device as claimed in claim 7 wherein each of the plurality of bits of the event schema vector represent one or more events which disrupts processing unless masked.<br>
10.	The processing device as claimed in claim 9 comprising a memory to store an event descriptor table.<br>
11.	The processing device as claimed in claim 1 wherein said handler is an event handler routine stored in a computer readable medium.<br>
12.	The processing device as claimed in claim 10 wherein said execution resources comprise multithreaded execution logic capable of executing a plurality of threads, and wherein said event handler routine, if executed, is to launch a helper thread.<br>
13.	The processing device as claimed in claim 12 wherein said helper thread and a first thread executing when said low progress indicating condition is detected are executed concurrently.<br>
14.	The processing device as claimed in claim 13 wherein said helper thread sets a new low progress indicating condition to trigger another helper thread.<br>
15.	The processing device as claimed in claim 1 comprising a storage location (1010) to store a context indicator.<br>
16.	The processing device as claimed in claim 1 wherein said monitor is programmble by a user program.<br>
17.	A processing device for executing a plurality of instructions<br>
substantially as herein described with reference to the<br>
accompanying drawings.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">1501-del-2003-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1hc3NpZ25tZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">1501-del-2003-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1ERUwtMjAwMy1DbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">1501-DEL-2003-Claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1jb21wbGV0ZSBzcGVjaWZpY2F0aW9uKGFzIGZpbGVkKS5wZGY=" target="_blank" style="word-wrap:break-word;">1501-del-2003-complete specification(as filed).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1jb21wbGV0ZSBzcGVjaWZpY2F0aW9uKGdyYW50ZWQpLnBkZg==" target="_blank" style="word-wrap:break-word;">1501-del-2003-complete specification(granted).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1ERUwtMjAwMy1Db3JyZXNwb25kZW5jZS1PdGhlcnMtKDI0LTA0LTIwMDkpLnBkZg==" target="_blank" style="word-wrap:break-word;">1501-DEL-2003-Correspondence-Others-(24-04-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1jb3JyZXNwb25kZW5jZS1vdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">1501-del-2003-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1jb3JyZXNwb25kZW5jZS1wby5wZGY=" target="_blank" style="word-wrap:break-word;">1501-del-2003-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1ERUwtMjAwMy1EZXNjcmlwdGlvbiAoQ29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">1501-DEL-2003-Description (Complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">1501-del-2003-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1mb3JtLTEucGRm" target="_blank" style="word-wrap:break-word;">1501-del-2003-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1mb3JtLTEzLSgyNC0wNC0yMDA5KS5wZGY=" target="_blank" style="word-wrap:break-word;">1501-del-2003-form-13-(24-04-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1mb3JtLTE5LnBkZg==" target="_blank" style="word-wrap:break-word;">1501-del-2003-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1ERUwtMjAwMy1Gb3JtLTIucGRm" target="_blank" style="word-wrap:break-word;">1501-DEL-2003-Form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1mb3JtLTMucGRm" target="_blank" style="word-wrap:break-word;">1501-del-2003-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1mb3JtLTUucGRm" target="_blank" style="word-wrap:break-word;">1501-del-2003-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1ncGEucGRm" target="_blank" style="word-wrap:break-word;">1501-del-2003-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1wZXRpdGlvbi0xMzcucGRm" target="_blank" style="word-wrap:break-word;">1501-del-2003-petition-137.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUwMS1kZWwtMjAwMy1wZXRpdGlvbi0xMzgucGRm" target="_blank" style="word-wrap:break-word;">1501-del-2003-petition-138.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QuanBn" target="_blank" style="word-wrap:break-word;">abstract.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="226936-method-of-producing-specific-pathogen-free-hamster-for-the-preparation-of-a-variety-of-biological-products.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="226938-multimedia-messaging-system-in-a-communication-network.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>226937</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1501/DEL/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>03/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>16-Jan-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>30-Dec-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>02-Dec-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTEL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2200 MISSION COLLEGE BOULEVARD, SANTA CLARA, CALIFORNIA 95052, U.S.A.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>HONG WANG</td>
											<td>P.O.BOX 10242, SAN JOSE, CALIFORNIA 95157, U.S.A</td>
										</tr>
										<tr>
											<td>2</td>
											<td>PER HAMMARLUND</td>
											<td>2601 NE 2ND DRIVE, HILLSBORO, OREGON 97124, U.S.A</td>
										</tr>
										<tr>
											<td>3</td>
											<td>XIANG ZHU</td>
											<td>92 SW HORTON WAY, BEAVERTON, OREGON, U.S.A</td>
										</tr>
										<tr>
											<td>4</td>
											<td>JOHN SHEN</td>
											<td>2303 QUAIL BLUFF PLACE, SAN JOSE, CALIFORNIA 95121, U.S.A</td>
										</tr>
										<tr>
											<td>5</td>
											<td>XINMIN TIAN</td>
											<td>4291 NORWALK DRIVE, V102, SAN JOSE, CALIFORNIA 95129, U.S.A</td>
										</tr>
										<tr>
											<td>6</td>
											<td>MILIND GIRKAR</td>
											<td>1049 W.OLIVE DRIVE, #3, SUNNYVALE, CALIFORNIA 94086, U.S.A</td>
										</tr>
										<tr>
											<td>7</td>
											<td>PERRY WANG</td>
											<td>2907 KIPERASH DRIVE, SAN JOSE, CALIFORNIA 95133, U.S.A</td>
										</tr>
										<tr>
											<td>8</td>
											<td>PIYUSH DESAI</td>
											<td>792 SUMMIT GREEK LANE, PLEASANTON, CALIFORNIA 94566, U.S.A</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/370,251</td>
									<td>2003-02-19</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/226937-a-processing-device-for-executing-a-plurality-of-instructions by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:42:04 GMT -->
</html>
