<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/260152-processing-video-images-having-plural-units by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 22:42:49 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 260152:PROCESSING VIDEO IMAGES HAVING PLURAL UNITS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">PROCESSING VIDEO IMAGES HAVING PLURAL UNITS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A computer-implemented method (1000; 1100, .800) of processing one or more video images having plural units, wherein binary symbols indicate whether the plural units are skipped or not. According to the method, a coding mode is selected (1010, 1110) from a group of plural available coding modes. The binary symbols are then processed (1020, 1120) at a level higher than macroblock level in bitstream syntax the binary symbols according to the selected coding mode, wherein a unit of the plural units is skipped if the unit uses predicted motion based upon motion of one or more other predicted units (1830) and if the unit lacks residual information (1850).</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>SKIP MACROBLOCK CODING<br>
RELATED APPLICATION INFORMATION<br>
The present application claims the benefit of U.S. Provisional Patent Application Serial No. 60/341,674, entitled "Techniques and Tools for Video Encoding and Decoding," filed December 17, 2001, the disclosure of which is incorporated by reference. The present application also claims the benefit of U.S. Provisional Patent Application Serial No. 60/377,712, entitled "Skip Macroblock Coding," filed May 3, 2002, the disclosure of which is incorporated by reference.<br>
TECHNICAL FIELD<br>
Techniques and tools for encoding/decoding binary information in video coding/decoding applications are described. For example, a video encoder encodes skipped macroblock information.<br>
BACKGROUND<br>
Digital video consumes large amounts of storage and transmission capacity. A typical raw digital video sequence includes 15 or 30 frames per second. Each frame can include tens or hundreds of thousands of pixels (also called pels). Each pixel represents a tiny element of the picture. In raw form, a computer commonly represents a pixel with 24 bits. Thus, the number of bits per second, or bit rate, of a typical raw digital video sequence can be 5 million bits/second or more.<br>
Most computers and computer networks lack the resources to process raw digital video. For this reason, engineers use compression (also called coding or encoding) to reduce the bit rate of digital video. Compression can be lossless, in which quality of the video does not suffer but decreases in bit rate are limited by the complexity of the video.  Or, compression can be lossy, in which quality of the video suffers but decreases in bit rate are more dramatic. Decompression reverses compression.<br>
In general, video compression techniques include intraframe compression and interframe compression.  Intraframe compression techniques compress individual frames, typically called l-frames, or key frames. Interframe compression techniques compress frames with reference to preceding and/or following frames, and are called typically called predicted frames, P-frames, or B-frames.<br>
Microsoft Corporation's Windows Media Video, Version 7 ["WMV7"] includes a video encoder and a video decoder. The WMV7 encoder uses intraframe and interframe compression, and the WMV7 decoder uses intraframe and interframe decompression.<br>
A.        Intraframe Compression in WMV7<br>
Figure 1 illustrates block-based intraframe compression (100) of a block (105) of pixels in a key frame in the WMV7 encoder. A block is a set of pixels, for example, an 8x8 arrangement of pixels. The WMV7 encoder splits a key video frame into 8x8 blocks of pixels and applies an 8x8 Discrete Cosine Transform ["DCT"] (110) to individual blocks such as the block (105). A DCT is a type of frequency transform that converts the 8x8 block of pixels (spatial information) into an 8x8 block of DCT coefficients (115), which are frequency information. The DCT operation itself is lossless or nearly lossless. Compared to the original pixel values, however, the DCT coefficients are more efficient for the encoder to compress since most of the significant information is concentrated in low frequency coefficients (conventionally, the upper left of the block (115)) and many of the high frequency coefficients (conventionally, the lower right of the block (115)) have values of zero or close to zero.<br>
The encoder then quantizes (120) the DCT coefficients, resulting in an 8x8 block of quantized DCT coefficients (125). For example, the encoder applies a uniform, scalar quantization step size to each coefficient, which is analogous to dividing each coefficient by the same value and rounding. For example, if a DCT coefficient value is 163 and the step size is 10, the quantized DCT coefficient value is 16. Quantization is lossy. The reconstructed DCT coefficient value will be 160, not 163. Since low frequency DCT coefficients tend to have higher values, quantization results in loss of precision but not complete loss of the information for the coefficients. On the other hand, since high frequency DCT coefficients tend to have values of zero or close to zero, quantization of the high frequency coefficients typically results in contiguous regions of zero values. In addition, in some cases high frequency DCT coefficients are quantized more coarsely than low frequency DCT coefficients, resulting in greater loss of precision/information for the high frequency DCT coefficients.<br>
The encoder then prepares the 8x8 block of quantized DCT coefficients (125) for entropy encoding, which is a form of lossless compression. The exact<br>
type of entropy encoding can vary depending on whether a coefficient is a DC coefficient (lowest frequency), an AC coefficient (other frequencies) in the top row or left column, or another AC coefficient.<br>
The encoder encodes the DC coefficient (126) as a differential from the DC coefficient (136) of a neighboring 8x8 block, which is a previously encoded neighbor (e.g., top or left) of the block being encoded. (Figure 1 shows a neighbor block (135) that is situated to the left of the block being encoded in the frame.) The encoder entropy encodes (140) the differential.<br>
The entropy encoder can encode the left column or top row of AC coefficients as a differential from a corresponding column or row of the neighboring 8x8 block. Figure 1 shows the left column (127) of AC coefficients encoded as a differential (147) from the left column (137) of the neighboring (to the left) block (135). The differential coding increases the chance that the differential coefficients have zero values. The remaining AC coefficients are from the block (125) of quantized DCT coefficients.<br>
The encoder scans (150) the 8x8 biock (145) of predicted, quantized AC DCT coefficients into a one-dimensional array (155) and then entropy encodes the scanned AC coefficients using a variation of run length ceding (160). The encoder selects an entropy code from one or more run/level/last tables (165) and outputs the entropy code.<br>
A key frame contributes much more to bit rate that a predicted frame. In iow or mid-bit rate applications, key frames are often critical bottlenecks for performance, so efficient compression of key frames is critical.<br>
Figure 2 illustrates a disadvantage of intraframe compression such as shown in Figure 1. In particular, exploitation of redundancy between blocks of the key frame is limited to prediction of a subset of frequency coefficients (e.g., the DC coefficient and the left column (or top row) of AC coefficients) from the left (220) or top (230)-neighboring block of a block (210). The DC coefficient represents the average of the block, the left column of AC coefficients represents the averages of the rows of a block, and the top row represents the averages of the columns. In effect, prediction of DC and AC coefficients as in WMV7 limits extrapolation to the row-wise (or column-wise) average signals of the left (or top) neighboring block. For a particular row (221) in the left block (220), the AC coefficients in the left DCT coefficient column for the left block (220) are used to predict the entire corresponding row (211) of the block (210).<br>
B.        Interframe Compression in WMV7<br>
Interframe compression in the WMV7 encoder uses block-based motion compensated prediction coding followed by transform coding of the residual error. Figures 3 and 4 illustrate the block-based interframe compression for a predicted frame in the WMV7 encoder. In particular, Figure 3 illustrates motion estimation for a predicted frame (310) and Figure 4 illustrates compression of a prediction residual for a motion-estimated block of a predicted frame.<br>
The WMV7 encoder splits a predicted frame into 8x8 blocks of pixels. Groups of 4 8x8 blocks form macroblocks. For each macroblock, a motion estimation process is performed. The motion estimation approximates the motion of the macroblock of pixels relative to a reference frame, for example, a previously coded, preceding 1rame. In Figure 3, the WMV7 encoder computes a motion vector for a macroblock (315) in the predicted frame (310). To compute the motion vector, the encoder searches in a search area (335) of a reference frame (330). Within the search area (335), the encoder compares the macroblock (315) from the predicted frame (310) to various candidate macroblocks in order to find a candidate macroblock that is a good match. The encoder can check candidate macroblocks every pixel or every ½ pixel in the search area (335), depending on the desired motion estimation resolution for the encoder. Other video encoders check at other increments, for example, every ¼ pixel. For a candidate macroblock, the encoder checks the difference between the macroblock (315) of the predicted frame (310) and the candidate macroblock and the cost of encoding the motion vector for that macroblock. After the encoder finds a good matching macroblock, the block matching process ends. The encoder outputs the motion vector (entropy coded) for the matching macroblock so the decoder can find the matching macroblock during decoding. When decoding the predicted frame (310), a decoder uses the motion vector to compute a prediction macroblock for the macroblock (315) using information from the reference frame (330). The prediction for the macroblock (315) is rarely perfect, so the encoder usually encodes 8x8 blocks of pixel differences (also called the error or residual blocks) between the prediction macroblock and the macroblock (315) itself.<br>
Figure 4 illustrates the computation and encoding of an error block (435) for a motion-estimated block in the WMV7 encoder. The error block (435) is the difference between the predicted block (415) and the original current block (425).<br>
The encoder applies a DCT (440) to error block (435), resulting in 8x8 block (445) of coefficients. Even more than was the case with DCT coefficients for pixel values, the significant information for the error block (435) is concentrated in low frequency coefficients (conventionally, the upper left of the block (445)) and many of the high frequency coefficients have values of zero or close to zero (conventionally, the lower right of the block (445)).<br>
The encoder then quantizes (450) the DCT coefficients, resulting in an 8x8 block of quantized DCT coefficients (455).   The quantization step size is adjustable. Again, since low frequency DCT coefficients tend to have higher values, quantization results in loss of precision, but not complete loss of the information for the coefficients. On the other hand, since high frequency DCT coefficients tend to have values of zero or close to zero, quantization of the high frequency coefficients results in contiguous regions of zero values. In addition, in some cases high frequency DCT coefficients are quantized more coarsely than low frequency DCT coefficients, resulting in greater loss of precision/information for the high frequency DCT coefficients.<br>
The encoder then prepares the 8x8 block (455) of quantized DCT coefficients for entropy encoding. The encoder scans (460) the 8x8 block (455) into a one dimensional array (465) with 64 elements, such that coefficients are generally ordered from lowest frequency to highest frequency, which typical creates long runs of zero values.<br>
The encoder entropy encodes the scanned coefiicients using a variation of run length coding (470). The encoder selects an entropy code from one or more run/level/last tables (475) and outputs the entropy code.<br>
When the motion vector for a macroblock is zero (i.e., no motion) and no residual block information is transmitted for the macroblock, the encoder uses a 1-bit skip macroblock flag for the macroblock.  For many kinds of video content (e.g., low motion and/or low bitrate video), this reduces bitrate by avoiding the transmission of motion vector and residual block information. The encoder puts the skip macroblock flag for a macroblock at the macroblock layer in the output bitstream, along with other information for the macroblock.<br>
Figure 5 shows the decoding process (500) for an inter-coded block. Due to the quantization of the DCT coefficients, the reconstructed block (575) is not identical to the corresponding originaf block. The compression is lossy.<br>
 In summary of Figure 5, a decoder decodes (510, 520) entropy-coded information representing a prediction residual using variable length decoding and one or more run/level/last tables (515). The decoder inverse scans (530) a one-dimensional array (525) storing the entropy-decoded information into a two-dimensional block (535). The decoder inverse quantizes and inverse discrete cosine transforms (together, 540) the data, resulting in a reconstructed error block (545). In a separate path, the decoder computes a predicted block (565) using motion vector information (555) for displacement from a reference frame. The decoder combines (570) the predicted block (555) with the reconstructed error block (545) to form the reconstructed block (575).<br>
When the decoder receives a skip macroblock flag for a macroblock, the decoder skips computing a prediction and decoding residual block information for the macroblock. Instead, the decoder uses corresponding pixel data from the location of the macroblock in the reference frame.<br>
The amount of change between the original and reconstructed frame is termed the distortion and the number of bits required to code the frame is termed the rate. The amount of distortion is roughly inversely proportional to the rate. In other words, coding a frame with fewer bits (greater compression) will result in greater distortion and vice versa. One of the goals of a video compression scheme is to try to improve the rate-distortion - in other words to try to achieve the same distortion using fewer bits (or the same bits and lower distortion).<br>
Although the use of skip macroblock flags in WMV7 typically reduces bitrate for many kinds of video content, it is less than optimal in some circumstances. In many cases,.it fails to exploit redundancy in skip macroblock flags from macroblock to macroblock, for example, when skipped macroblocks occur in bunches in a picture. Also, WMV7 ignores motion prediction for macroblocks in predicted frames when the macroblocks are skipped, which hurts the efficiency of compression of predicted frames in some cases.<br>
C.        Standards for Video Compression and Decompression<br>
Aside from WMV7, several international standards relate to video compression and decompression. These standards include the Motion Picture Experts Group ["MPEG"] 1, 2, and 4 standards and the H.261, H.262, and H.263 standards from the International Telecommunication Union ["ITU"]. Like WMV7, these standards use a combination of intraframe and interframe compression,<br>
although the standards typically differ from WMV7 in the details of the compression techniques used.<br>
Some international standards recognize skipping coding of macroblocks as a tool to be used in video compression and decompression. For additional detail about skip macroblock coding in the standards, see the standards' specifications themselves.<br>
The skipped macroblock coding in the above standards typically reduces bitrate for many kinds of video content, but is less than optimal in some circumstances. In many cases, it fails to exploit redundancy in skip macroblock flags from macroblock to macroblock, for example, when skipped macroblocks occur in bunches in a picture. Also, it ignores motion prediction for macroblocks in predicted macroblocks/pictures when the macroblocks are skipped, which hurts the efficiency of compression of predicted macroblocks/pictures in some cases.<br>
Given the critical importance of video compression and decompression to digital video, it is not surprising that video compression and decompression are richly developed fields. Whatever the benefits of previous video compression and decompression techniques, however, they do not have the advantages of the following techniques and tools.<br>
SUMMARY<br>
In summary, the detailed description is direcad to various techniques and tools for encoding and decoding (e.g., in a video encoder/decoder) binary information. The binary information may comprise bits indicating whether a video encoder or decoder skips certain macroblocks in a video frame. Or, the binary information may comprise bits indicating motion vector resolution for macroblocks (e.g. 1-MV or 4-MV), interlace mode (e.g., field or frame), or some other information. Binary information may be encoded on a frame-by-frame basis or on some other basis.<br>
In some embodiments, the binary information is arranged in a bit plane.  For example, the bit plane is coded at the picture/frame layer. Alternatively, the binary information is arranged in some other way and/or coded at a different layer. The encoder and decoder process the binary information. The binary information may comprise macroblock-level information. Alternatively, the encoder and decoder process bit planes of block-level, sub-block-level, or pixel-level information.<br>
In some embodiments, the encoder and decoder switch coding modes. For example, the encoder and decoder use normal, row-skip, or column-skip mode. The different modes allow the encoder and decoder to exploit redundancy in the binary information. Alternatively, the encoder and decoder use other and/or additional modes such as differential modes. To increase efficiency, the encoder and decoder may use a bit plane inversion technique in some modes.<br>
In some embodiments, the encoder and decoder define a skipped macroblock as a predicted macroblock whose motion is equal to its causally predicted motion and which has zero residual error. Alternatively, the encoder and decoder define a skipped macroblock as a predicted macroblock with zero motion and zero residual error.<br>
In some embodiments, the encoder and decoder use a raw coding mode to allow for low-latency applications. For example, in the raw coding mode, encoded macroblocks can be transmitted to the decoder right away, without having to wait until all macroblocks in the frame/picture are encoded. The encoder and decoder can switch between the raw coding mode and other modes.<br>
The various techniques and tools can be used in combination or independently. In particular, the application describes two implementations of skipped macroblock encoding and decoding, along with corresponding bitstream syntaxes. Different embodiments implement one or more of the described techniques and tools.<br>
Additional features and advantages will be made apparent from the following detailed description of different embodiments that proceeds with reference to the accompanying drawings.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
Figure 1 is a diagram showing block-based intraframe compression of an 8x8 block of pixels according to prior art.<br>
Figure 2 is a diagram showing prediction of frequency coefficients according to the prior art.<br>
Figure 3 is a diagram showing motion estimation in a video encoder according to the prior art.<br>
Figure 4 is a diagram showing biock-based interframe compression for an 8x8 block of prediction residuals in a video encoder according to the prior art.<br>
Figure 5 is a diagram showing block-based intraframe decompression for an 8x8 block of prediction residuals according to the prior art.<br>
Figure 6 is a block diagram of a suitable computing environment in which several described embodiments may be implemented.<br>
Figure 7 is a block diagram of a generalized video encoder system used in several described embodiments.<br>
Figure 8 is a block diagram of a generalized video decoder system used in several described embodiments.<br>
Figure 9 is a chart showing the bitstream elements that make up the P picture layer according to the first implementation.<br>
Figure 10 is a flowchart showing a technique for encoding skipped macroblock information in a video encoder having plural skip-macroblock coding modes.<br>
Figure 11 is a flowchart showing a technique for decoding skipped macroblock information encoded by a video encoder having plural skip-macroblock coding modes.<br>
Figure 12 shows an example of a skipped macroblock coding frame.<br>
Figure 13 is a flowchart showing a technique for encoding in normal skip-macroblock coding mode.<br>
Figure 14 is a flowchart showing a technique for encoding in a row-prediction skip-macroblock coding mode.<br>
Figure 15 is a code listing showing pseudo-code for row-prediction decoding of skipped macroblock information.<br>
Figure 16 is a flowchart showing a technique for encoding in a column-prediction skip-macroblock coding mode.<br>
Figure 17 is a code listing showing pseudo-code for column-prediction decoding of skipped macroblock information.<br>
Figure 18 is a flowchart showing a technique for determining whether to skip coding of certain macroblocks in a video encoder.<br>
Figure 19 is a flowchart showing a technique for encoding binary information in a bit plane in a row-skip coding mode.<br>
Figure 20 is a flowchart showing a technique for encoding binary information in a bit plane in a column-skip coding mode.<br>
Figure 21 is a flowchart showing a technique for encoding binary information in a bit plane in a normal-2 coding mode.<br>
Figures 22, 23 and 24 show examples of frames of binary information tiled in normal-6 mode.<br>
Figure 25 is a flowchart showing a technique for encoding binary information in a bit plane in a normal-6 coding mode.<br>
Figure 26 is a flowchart showing a technique for encoding binary information in a differential coding mode.<br>
Figure 27 is a flowchart showing a technique for decoding binary information encoded in a differential coding mode.<br>
Figure 28 is a flowchart showing a technique for selectively encoding binary information in raw coding mode for low latency applications.<br>
DETAILED DESCRIPTION<br>
Described embodiments relate to techniques and tools for encoding and decoding (e.g., in a video encoder/decoder) binary information. The binary information may comprise bits indicating whether a video encoder or decoder skips certain rnacroblocks in a video frame. Or, the binary information may comprise bits indicating motion vector resolution for rnacroblocks (e.g. 1-MV or 4-MV), interlace mode (e.g., field or frame), or some other information. Binary information may be encoded on a frame-by-frame basis or on some other basis.<br>
h some embodiments, the binary information is arranged in a bit plane. The bit plane is coded at the picture/frame layer. Alternatively, the binary information is arrangen in some other way and/or coded at a different layer.<br>
In some embodiments, the encoder and decoder switch coding modes. For example, the encoder and decoder use normal, row-skip, or column-skip modes. The different modes allow the encoder and decoder to exploit redundancy in the binary information. Alternatively, the encoder and decoder use other and/or additional modes.<br>
In some embodiments, the encoder and decoder define a skipped macrobiock as a predicted macrobiock whose motion is equal to its causally predicted motion and which has zero residual error. Alternatively, the encoder and decoder define a skipped macrobiock as a predicted macrobiock with zero motion and zero residua! error.<br>
In some embodiments, instead of efficient frame/picture-ievel coding, a raw coding mode is permitted to allow for low-latency applications. In the raw coding<br>
mode, encoded macroblocks can be transmitted to the decoder right away, without having to wait until all macroblocks in the frame/picture are encoded.<br>
In some embodiments, the encoder and decoder process bit planes of macroblock level information. Alternatively, the encoder and decoder process bit planes of block, sub-block, or pixel-level information.<br>
The various techniques and tools can be used in combination or independently. In particular, the application describes two implementations of skipped macroblock encoding and decoding, along with corresponding bitstream syntaxes. Different embodiments implement one or more of the described techniques and tools.<br>
In described embodiments, the video encoder and decoder perform various techniques. Although the operations for these techniques are typically described in a particular, sequential order for the sake of presentation, it should be understood that this manner of description encompasses minor rearrangements in the order of operations, unless a particular ordering is required. For example, operations described sequentially may in some cases be rearranged or performed concurrently. Moreover, for the sake of simplicity, flowcharts typically do not show the various ways in which particular techniques can be used in conjunction with other techniques.<br>
In described embodiments, the video encoder an:i decoder use various flags and signals in a bitstream. While specific flags anc signals are described, it should be understood that this manner of description encompasses different conventions (e.g., O's rather than 1 's) for the flags and signals.<br>
L	Computing Environment<br>
Figure 6 illustrates a generalized example of a suitable computing environment (600) in Which several of the described embodiments may be implemented. The computing environment (600) is not intended to suggest any limitation as to scope of use or functionality, as the techniques and tools may be implemented in diverse general-purpose or special-purpose computing environments.<br>
With reference to Figure 6, the computing environment (600) includes at least one processing unit (610) and memory (620). In Figure 6, this most basic configuration (630) is included within a dashed line. The processing unit (610) executes computer-executable instructions and may be a real or a virtual<br>
processor. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power. The memory (620) may be volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory, etc.), or some combination of the two. The memory (620) stores software (680) implementing an encoder or decoder, such as a video encoder or decoder.<br>
A computing environment may have additional features. For example, the computing environment (600) includes storage (640), one or more input devices (650), one or more output devices (660), and one or more communication connections (670). An interconnection mechanism (not shown) such as a bus, controller, or network interconnects the components of the computing environment (600). Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment (600), and coordinates activities of the components of the computing environment (600).<br>
The storage (640) may be removable or non-removable, and includes magnetic disks, magnetic tapes or cassettes, CD-ROMs, DVDs, or any other medium which can be used to store information and which can be accessed within the computing environment (600). The storage (640) stores instructions for the software (680) implementing the encoder or decoder.<br>
The input device(s) (650) may be a touch input device such ? s a keyboard, mouse, pen, or trackball, a voice input device, a scanning device, or another device that provides input to the computing environment (600). For audio cr video encoding, the input device(s) (650) may be a sound card, video cara, TV tuner card, or similar device that accepts audio or video input in analog or digital form, or a CD-ROM or CD-RW that reads audio or video samples into the computing environment (600). The output device(s) (660) may be a display, printer, speaker, CD-writer, or another device that provides output from the computing environment (600).<br>
The communication connection(s) (670) enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer-executable instructions, audio or video input or output, or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired or wireless techniques implemented with an electrical, optical, RF, infrared, acoustic, or other carrier.<br>
The techniques and tools can be described in the general context of computer-readable media. Computer-readable media are any available media that can be accessed within a computing environment. By way of example, and not limitation, with the computing environment (600), computer-readable media include memory (620), storage (640), communication media, and combinations of any of the above.<br>
The techniques and tools can be described in the general context of computer-executable instructions, such as those included in program modules, being executed in a computing environment on a target real or virtual processor. Generally, program modules include routines, programs, libraries, objects, classes, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer-executable instructions for program modules may be executed within a local or distributed computing environment.<br>
For the sake of presentation, the detailed description uses terms like "determine," "select," "reconstruct," and "inform" to describe computer operations in a computing environment. These terms are high-level abstractions for operations performed by a computer, and should not be confused with acts performed by a human being. The actual computer operations corresponding to these terms vary depending on implementation.<br>
II.        Generalized Video Encoder and Decoder<br>
Figure 7 is a block diagram of a generalized video encoder (700) and Figure 8 is a block diagram of a generalized video decoder (800).<br>
The relationships shown between modules within the encoder and decoder indicate the main flow of information in the encoder and decoder; other relationships are not shown for the sake of simplicity. In particular, Figures 7 and 8 usually do not show side information indicating the encoder settings, modes, tables, etc. used for a video sequence, frame, macroblock, block, etc. Such side information is sent in the output bitstream, typically after entropy encoding of the side information. The format of the output bitstream can be Windows Media Video version 8 format or another format.<br>
The encoder (700) and decoder (800) are block-based and use a 4:2:0 macroblock format with each macroblock including 4 luminance 8x8 luminance<br>
blocks (at times treated as one 16x16 macroblock) and two 8x8 chrominance blocks. Alternatively, the encoder (700) and decoder (800) are object-based, use a different macroblock or block format, or perform operations on sets of pixels of different size or configuration than 8x8 blocks and 16x16 macroblocks.<br>
Depending on implementation and the type of compression desired, modules of the encoder or decoder can be added, omitted, spiit into multiple modules, combined with other modules, and/or replaced with like modules. In alternative embodiments, encoder or decoders with different modules and/or other configurations of modules perform one or more of the described techniques.<br>
A.       Video Encoder<br>
Figure 7 is a block diagram of a general video encoder system (700). The encoder system (700) receives a sequence of video frames including a current frame (705), and produces compressed video information (795) as output. Particular embodiments of video encoders typically use a variation or supplemented version of the generalized encoder (700).<br>
The encoder system (700) compresses predicted frames and key frames. For the sake of presentation, Figure 7 shows a path for key frames through the encoder system (700) and a path for forward-predicted frames. Many of the components Df the encoder system (700) are used for compressing both key frames and predicted frames. The exact operations performed by those components ^an vary depending on the type of information being compressed.<br>
A predicted frame [also called p-frame, b-frame for bi-directional prediction, or inter-coded frame] is represented in terms of prediction (or difference) from one or more other frames. A prediction residual is the difference between what was predicted and the original frame. In contrast, a key frame [also called i-frame, intra-coded frame] is compressed without reference to other frames.<br>
If the current frame (705) is a forward-predicted frame, a motion estimator (710) estimates motion of macroblocks or other sets of pixels of the current frame (705) with respect to a reference frame, which is the reconstructed previous frame (725) buffered in the frame store (720). In alternative embodiments, the reference frame is a later frame or the current frame is bi-directionally predicted. The motion estimator (710) can estimate motion by pixel, 1/2 pixel, % pixel, or other increments, and can switch the resolution of the motion estimation on a frame-by-frame basis or other basis. The resolution of the motion estimation can be the same or different<br>
horizontally and vertically. The motion estimator (710) outputs as side information motion information (715) such as motion vectors. A motion compensator (730) applies the motion information (715) to the reconstructed previous frame (725) to form a motion-compensated current frame (735). The prediction is rarely perfect, however, and the difference between the motion-compensated current frame (735) and the original current frame (705) is the prediction residual (745). Alternatively, a motion estimator and motion compensator apply another type of motion estimation/compensation.<br>
A frequency transformer (760) converts the spatial domain video information into frequency domain (i.e., spectral) data. For block-based video frames, the frequency transformer (760) applies a discrete cosine transform ["DCT"] or variant of DCT to blocks of the pixel data or prediction residual data, producing blocks of DCT coefficients. Alternatively, the frequency transformer (760) applies another conventional frequency transform such as a Fourier transform or uses wavelet or subband analysis. In embodiments in which the encoder uses spatial extrapolation (not shown in Figure 7) to encode blocks of key frames, the frequency transformer (760) can apply a re-oriented frequency transform such as a skewed DCT to blocks of prediction residuals for the key frame. In other embodiments, the frequency transformer (760) applies an 8x8, 8x4, 4x8, or other size frequency transforms (e.g., DCT) to prediction residuals for predicted frames.<br>
A quantizer (770) then quantizes the blocks of spectra' data coefficients. The quantizer applies uniform, scalar quantization to the spectral data with a step-size that varies on a frame-by-frame basis or other basis. Alternatively, the quantizer applies another type of quantization to the spectral data coefficients, for example, a non-uniform, vector, or non-adaptive quantization, or directly quantizes spatial domain data in an encoder system that does not use frequency transformations. In addition to adaptive quantization, the encoder (700) can use frame dropping, adaptive filtering, or other techniques for rate control.<br>
If a given macroblock in a predicted frame has no information of certain types (e.g., no motion information for the macroblock and no residual information), the encoder (700) may encode the macroblock as a skipped macroblock. If so, the encoder signals the skipped macroblock in the output bitstream of compressed video information (795).<br>
When a reconstructed current frame is needed for subsequent motion estimation/compensation, an inverse quantizer (776) performs inverse quantization<br>
on the quantized spectral data coefficients. An inverse frequency transformer (766) then performs the inverse of the operations of the frequency transformer (760), producing a reconstructed prediction residual (for a predicted frame) or a reconstructed key frame. If the current frame (705) was a key frame, the reconstructed key frame is taken as the reconstructed current frame (not shown). If the current frame (705) was a predicted frame, the reconstructed prediction residual is added to the motion-compensated current frame (735) to form the reconstructed current frame. The frame store (720) buffers the reconstructed current frame for use in predicting the next frame. In some embodiments, the encoder applies a deblocking filter to the reconstructed frame to adaptively smooth discontinuities in the blocks of the frame.<br>
The entropy coder (780) compresses the output of the quantizer (770) as well as certain side information (e.g., motion information (715), spatial extrapolation modes, quantization step size). Typical entropy coding techniques include arithmetic coding, differential coding, Huffman coding, run length coding, LZ coding, dictionary coding, and combinations of the above. The entropy coder (780) typically uses different coding techniques for different kinds of information (e.g., DC coefficients, AC coefficients, different kinds of side information), and can choose from among multiple code tables within a particular coding technique.<br>
The entropy coder (780) puts compressed video information (795 in the buffer (790). A buffer level indicator is fed back to bit rate adaptive modu es.<br>
The compressed video information (795) is depleted from the butter (790) at a constant or relatively constant bit rate and stored for subsequent streaming at that bit rate. Therefore, the level of the buffer (790) is primarily a function of the entropy of the filtered, quantized video information, which affects the efficiency of the entropy coding. Alternatively, the encoder system (700) streams compressed video information immediately following compression, and the level of the buffer (790) also depends on the rate at which information is depleted from the buffer (790) for transmission.<br>
Before or after the buffer (790), the compressed video information (795) can be channel coded for transmission over the network. The channel coding can apply error detection and correction data to the compressed video information (795).<br>
B.        Video Decoder<br>
Figure 8 is a block diagram of a genera! video decoder system (800). The<br>
decoder system (800) receives information (895) for a compressed sequence of video frames and produces output including a reconstructed frame (805). Particular embodiments of video decoders typically use a variation or supplemented version of the generalized decoder (800).<br>
The decoder system (800) decompresses predicted frames and key frames. For the sake of presentation, Figure 8 shows a path for key frames through the decoder system (800) and a path for forward-predicted frames. Many of the components of the decoder system (800) are used for compressing both key frames and predicted frames. The exact operations performed by those components can vary depending on the type of information being compressed. A buffer (890) receives the information (895) for the compressed video sequence and makes the received information available to the entropy decoder (880). The buffer (890) typically receives the information at a rate that is fairly constant over time, and includes a jitter buffer to smooth short-term variations in bandwidth or transmission. The buffer (890) can include a playback buffer and other buffers as well. Alternatively, the buffer (890) receives information at a varying rate. Before or after the buffer (890), the compressed video information can be channel decoded and processed for error detection and correction.<br>
The entropy decoder (880) entropy decodes entropy-coded quantized data as well as entropy-coded side information (e.g., motion information (815), spatial extrapolation modes, quantization step size), typically applying the inverse of the entropy encoding performed in the encoder. Entropy decoding techniques include arithmetic decoding, differential decoding, Huffman decoding, run length decoding, LZ decoding, dictionary decoding, and combinations of the above. The entropy decoder (880) frequently uses different decoding techniques for different kinds of information (e.g., DC coefficients, AC coefficients, different kinds of side information), and can choose from among multiple code tables within a particular decoding technique.<br>
If the frame (805) to be reconstructed is a forward-predicted frame, a motion compensator (830) applies motion information (815) to a reference frame (825) to form a prediction (835) of the frame (805) being reconstructed. For example, the motion compensator (830) uses a macroblock motion vector to find a macroblock in the reference frame (825). A frame buffer (820) stores previous reconstructed frames for use as reference frames. The motion compensator (830) can compensate for motion at pixel, Vz pixel, V* pixel, or other increments, and can<br>
switch the resolution of the motion compensation on a frame-by-frame basis or other basis. The resolution of the motion compensation can be the same or different horizontally and vertically. Alternatively, a motion compensator applies another type of motion compensation. The prediction by the motion compensator is rarely perfect, so the decoder (800) also reconstructs prediction residuals.<br>
When the decoder needs a reconstructed frame for subsequent motion compensation, the frame store (820) buffers the reconstructed frame for use in predicting the next frame. In some embodiments, the encoder applies a deblocking filter to the reconstructed frame to adaptively smooth discontinuities in the blocks of the frame.<br>
An inverse quantizer (870) inverse quantizes entropy-decoded data. In general, the inverse quantizer applies uniform, scalar inverse quantization to the entropy-decoded data with a step-size that varies on a frame-by-frame basis or other basis. Alternatively, the inverse quantizer applies another type of inverse quantization to the data, for example, a non-uniform, vector, or non-adaptive quantization, or directly inverse quantizes spatial domain data in a decoder system that does not use inverse frequency transformations.<br>
An inverse frequency transformer (860) converts the quantized, frequency domain data into spatial domain video information. For block-based video frames, the inverse frequency transformer (860) applies an inverse DCT ["IDCT"] or variant of IDCT to blocks of the DCT coefficients, producing pixel data or prediction residual data for &gt;;ey frames or predicted frames, respectively. Alternatively, the frequency transformer (860) applies another conventional inverse frequency transform such as a Fourier transform or uses wavelet or subband synthesis. In embodiments in which the decoder uses spatial extrapolation (not shown in Figure 8) to decode blocks of key frames, the inverse frequency transformer (860) can apply a re-oriented inverse frequency transform such as a skewed IDCT to blocks of prediction residuals for the key frame.  In other embodiments, the inverse frequency transformer (860) applies an 8x8, 8x4, 4x8, or other size inverse frequency transforms (e.g., IDCT) to prediction residuals for predicted frames.<br>
When a skipped macroblock is signaled in the bitstream of information (895) for a compressed sequence of video frames, the decoder (800) reconstructs the skipped macroblock without using the information (e.g., motion information and/or residual information) normally included in the bitstream for non-skipped macroblocks.<br>
III.        First Implementation<br>
In a first implementation, a video encoder and decoder encode and decode, respectively, skipped macroblock information with improved efficiency. The skipped macroblock information is signaled at the picture layer in the video bitstream, which allows the encoder to exploit redundancy in the skipped macroblock information. Also, the encoder and decoder select between multiple coding modes for encoding and decoding the skipped macroblock information.<br>
A.        Picture Layer Coding of Skipped Macroblock Information<br>
In the first implementation, a compressed video sequence is made up of data structured into four hierarchical layers. From top to bottom the layers are: 1) sequence layer; 2) picture layer; 3) macroblock layer; and 4) block layer. At the picture layer, data for each picture consists of a picture header followed by data for the macroblock layer. (Similarly, at the macroblock layer, data for each macroblock consists of a macroblock header followed by the block layer.) While some of the bitstream elements for I pictures and P pictures are identical, others appear only in P pictures, and vice versa.<br>
Figure 9 shows the bitstream elements that make up the P-picture layer (900). Table 1 briefly describes the bitstream elements of the P-pict jre layer (900).<br>
(Table Removed) <br>
Table 1: Bitstream elements of the P-picture layer in first implementation<br>
In particular, the P-picture layer (900) includes a Skipped Macrobiock field ("SMB") (930) for the macroblocks in the P picture as well as a Skipped Macrobiock Code ("SMBC") field (920) that signals the coding mode for the skipped macroblock field (930). The SMBC field (920) is present only in P-picture headers. SMBC<br>
(920) is a 2-bit value that signals one of four modes used for indicating the skipped macroblocks in the frame. In the first implementation, the fixed length codes ("FLCs") for the skipped macroblock coding modes are as follows:<br>
(Table Removed) <br>
Table 2: Skipped macroblock coding mode code table in first implementation<br>
If the coding mode is normal, row-prediction, or column-prediction, then the next field in the bitstream is the SMB field (930) containing the skipped macroblock information. So, the SMB field is present only in P-picture headers and only if SMBC signals normal, row-prediction, or column-prediction skipped macroblock coding. If SMBC signals normal coding, then the size of the SMB field is equal to the number of macroblocks in the frame. If SMBC signals row-prediction or column-prediction, then the size of the SMB is variable as described below.<br>
The skipped macroblock information informs the decoder as to which macroblocks in the frame are not present in the macroblock layer. For these macroblocks, the decoder will copy the corresponding macroblock pixel data from the reference frame when reconstructing that macroblock.<br>
B.        Switching Coding Modes for Skipped Macroblock Information<br>
As described above, the SMBC field (920) signals the coding mode for the skipped macroblock field (930). More generally, Figure 10 shows a technique (1000) for encoding skipped macroblock information in a video encoder having multiple skip-macroblock coding modes. Figure 11 shows a corresponding technique (1100) for decoding skipped macroblock information encoded by a video encoder having plural skip-macroblock coding modes.<br>
With reference to Figure 10, the encoder selects a skip-macroblock coding mode for coding skipped macroblock information (1010). For example, in the first implementation, the skipped macroblock coding modes include a mode where no macroblocks are skipped, a normal mode, a row-prediction (or, "row-skip") mode, and a column-prediction (or "column-skip") mode. After the coding mode is selected, the encoder encodes the skipped macroblock information (1020). The encoder selects coding modes on a picture-by-picture basis. Alternatively, the<br>
encoder selects coding modes on some other basis (e.g., at the sequence level). When the encoder is done encoding the skipped macroblock information (1030), encoding ends.<br>
With reference to Figure 11, the decoder determines the skip-macroblock coding mode used by the encoder to encode the skipped macroblock information (1110). The decoder then decodes the skipped macroblock information (1120). The decoder determines coding modes on a picture-by-picture basis. Alternatively, the decoder determines coding modes on some other basis (e.g., at the sequence level). When the decoder is done decoding the skipped macroblock information (1130), decoding ends.<br>
C.        Coding Modes<br>
In the first implementation, the skipped macroblock coding modes include a mode where no macroblocks are skipped, a normal mode, a row-prediction (or, "row-skip") mode, and a column-prediction (or "column-skip") mode. The following sections describe how skipped macrobiock information is encoded in each mode with reference to Figure 12, which shows an example (1200) of a skipped macroblock coding frame.<br>
1.        Normal Skipped Macroblock Coding Mode<br>
In normal mode, the skipped/not-skipped status of each macroblock is represented with a bit. Therefore, the size of the SMB field in bits is equal to the number of macroblocks in the frame. The bit position within the SMB field corresponds to the raster scan order of the macroblocks within the frame starting with the upper-left macroblock. A bit value of 0 indicates that the corresponding macroblock is not skipped; a bit value of 1 indicates that the corresponding macroblock is skipped.<br>
Figure 13 shows a technique (1300) for encoding in normal skip-macroblock coding mode. First, the encoder checks whether coding of a macroblock will be skipped (1310). If so, the encoder adds a bit value of 1 to the SMB field to indicate that the corresponding macroblock is skipped (1320). Otherwise, the encoder adds a bit value of 0 to the SMB field to indicate that the corresponding macroblock is not skipped (1330). When the encoder is done adding bits to the SMB field (1340), skip macroblock coding ends.<br>
As an example, using normal mode coding, the SMB field for the example frame (1200) in Figure 12 would be encoded as: 010010111111111111010010.<br>
2.	Row-prediction Skipped Macrobiock Coding Mode<br>
In row-prediction mode, the status of each macrobiock row (from top to bottom) is indicated with a bit.  If the bit is 1, then the row contains all skipped macroblocks and the status for the next row follows. If the bit equals 0, then the skipped/not skipped status for each macrobiock in that row is signaled with a bit. Therefore, a bit field equal in length to the number of macroblocks in a row follows. The bits in the bit field represent the macroblocks in left-to-right order. Again, a value of 0 indicates that the corresponding macrobiock is not skipped; a value of 1 indicates that the corresponding macrobiock is skipped.<br>
Figure 14 shows a technique (1400) for encoding in row-prediction (or, "row-skip") macrobiock coding mode. First, the encoder checks if a row contains all skipped macroblocks (1410). If so, the encoder adds an indicator bit of 1 to the SMB field (1420) and the status for the next row follows. If the row does not contain all skipped macroblocks, the encoder adds an indicator bit of 0 to the SMB field, and the skipped/not-skipped status for each macrobiock in that row is signaled with a bit (1430). When the encoder is done with all the rows in the frame (1440), the row-prediction encoding ends.<br>
As for decoding Figure 15 shows pseudo-code (1500) illustrating row-prediction decoding of tne skipped macrobiock information.  In the pseudo-code (1500), the function get_bits(n) reads n bits from the bitstream and returns the value.<br>
As an example, using row-prediction mode coding, the SMB field for the example frame (1200) in Figure 12 would be encoded as: 0010010110010010.<br>
3.	Column-prediction Skipped Macrobiock Coding Mode<br>
In column-prediction mode, the status of each macrobiock column (from left to right) is indicated with a bit. If the bit is 1, then the column contains all skipped macroblocks and the status for the next column follows. If the bit equals 0, then the skipped/not skipped status for each macrobiock in that column is signaled with a bit. Therefore, a bit field equal in length to the number of macroblocks in a column follows. The bits in the bit field represent the macroblocks in top-to-bottom order.<br>
Again, a value of 0 indicates that the corresponding macroblock is not skipped; a value of 1 indicates that the corresponding macroblock is skipped.<br>
Figure 16 shows a technique (1600) for encoding in column-prediction (or, "column-skip") macroblock coding mode. First, the encoder checks if the column contains all skipped macroblocks (1610). If so, the encoder adds an indicator bit of 1 to the SMB field (1620) and the status for the next column follows. If the column does not contain all skipped macroblocks, the encoder adds an indicator bit of 0 to the SMB field, and the skipped/not-skipped status for each macroblock in that column is signaled with a bit (1630). When the encoder is done with all the columns in the frame (1640), the column-prediction encoding ends.<br>
As for decoding, Figure 17 shows pseudo-code (1700) illustrating column-prediction decoding of the skipped macroblock information.<br>
As an example, using column-prediction mode coding, the SMB field for the example frame (1200) in Figure 12 would be encoded as: 0011010011000110100110.<br>
IV.       Second Implementation<br>
In a second implementation, a video encoder and decoder encooe and decode, respectively, skipped macroblock information and/or other 2-D t inary data with improved efficiency. The encoder and decoder define a skipped macroblock as having a de:ault motion (not necessarily zero motion), which allows the encoder and decoder tc skip more macroblocks in many cases. Efficient frame-l:vel coding of bit planes indicates skipped macroblock information and/or other 2-D Dinary data. Also, the encoder and decoder may use a raw (MB-level) coding option of skipped macroblocks for low-latency applications.<br>
A.        Skip Bit Definition (Definition of Skipped Macroblock)<br>
The second implementation includes a new definition of the concept of a skipped macroblock. "Skip" refers to a condition in a bitstream where no further information needs to be transmitted at that level of granularity. A skipped macroblock (block) is a macroblock (block) that has a default type, default motion, and default residual error. (In comparison, in other implementations and standards, skipped macroblocks are predicted macroblocks with zero motion and zero residuals.<br>
The new definition of skipped macroblock is a predicted macrobiock whose motion is equal to its causally predicted motion, and which has zero residual error. (The point of difference from the other definition is the default motion is equal to the motion predictor, and this may not necessarily be zero.)<br>
For example, in some embodiments, predicted motion vectors for a current macroblock are taken from the macroblock directly above or directly to the left of the current macroblock. Or, horizontal and vertical components of the predictor are generated from the horizontal and vertical component-wise medians of the macroblocks the left, top, and top right of the current macroblock.<br>
The motion vectors of a skipped macroblock with four motion vectors (4MV) are given by their predictions performed sequentially in the natural scan order. As with the one motion vector (1MV) case, the error residuals are zero.<br>
Figure 18 shows a technique (1800) for determining whether to skip coding of particular macroblocks in a video encoder according to the new definition of skipped macroblocks. First, the encoder checks whether the current frame is an I-frame or a P-frame (1810). If the current frame is an l-frame, no macroblocks in the current frame are skipped (1820), and skip-macroblock coding for the frame ends.<br>
On the other hand, if the current frame is a P-frame, the encoder checks for macroblocks in the current frame that can be skipped. For a given macroblock, the encoder checks whether the motion vector for the macroblock is equal to the causally predicted motion vector for the macroblock (e.g., whether the differen.ial motion vector for the macroblock is equal to zero) (1830). If the motion for a macroblock does not equal the causally predicted motion, the encoder does not skip the macroblock (1840). Otherwise, the encoder checks whether there is any residual to be encoded for the macroblock (1850). If there is a residual to be coded, the encoder does not skip the macroblock (1860). If there is no residual for the macroblock, however, the encoder skips the macroblock (1870). The encoder continues to encode or skip macroblocks until encoding is done (1880).<br>
B.        Bit Plane Coding<br>
In the second implementation, certain macroblock-specific information (including signaling skipped macroblocks) can be encoded in one bit per macroblock. The status for all macroblocks in a frame can be coded together as a bit plane and transmitted in the frame header.<br>
In the second implementation, the encoder uses bit plane coding in three cases to signal information about macroblocks in a frame. The three cases are: 1) signaling skipped macroblocks, 2) signaling field or frame macroblock mode, and 3) signaling 1 -MV or 4-MV motion vector mode for each macroblock. This section describes bit plane coding for any of the three cases and corresponding decoding.<br>
Frame-level bit plane coding is used to encode two-dimensional binary arrays. The size of each array is rowMB x coIMB, where rowMB and coIMB are the number of macroblock rows and columns, respectively. Within the bitstream, each array is coded as a set of consecutive bits. One of seven modes is used to encode each array, as enumerated in Table 3 and described below.<br>
(Table Removed) <br>
Table 3: Coding modes in second implementation<br>
In the 5 scond implementation, the encoder uses three syntax elements to embed the information in a bit plane: MODE, INVERT and DATABITS.<br>
The MODE field is a variable length code ("VLC") that encodes tie coding mode for the bit plane. For example, the VLC in the MODE field represents any of the seven coding modes enumerated in Table 3. To save bits, the encoder can assign shorter codes to more probable coding modes and longer codes to less probable coding modes. As noted above, the MODE field is transmitted in the frame header.<br>
The encoder and decoder switch between coding modes on a frame-by-frame basis.  For example, the encoder and decoder switch between coding modes as like the encoder and decoder of the first implementation switch between skipped macroblock coding modes in Figures 10 and 11, respectively. Alternatively, the encoder and decoder switch using some other technique and/or on some other basis.<br>
If the mode is not raw mode, the one bit INVERT field is sent. In several coding modes where conditional inversion may be performed, the INVERT field indicates whether the bits in the bit plane are to be inverted before encoding takes<br>
place in the encoder and whether the output of decoding in the decoder is to be inverted. The INVERT field is 1 when most of the bits in the bit plane are equal to 1, and 0 when most of the bits in the bit plane are equal to 0. The encoder employs several coding modes (such as normal-2 and normal-6) that consume less bits when more Os are present. If the bit plane to be encoded has more 1 s than Os, the encoder can invert the bit plane to increase the proportion of Os in the bit plane and increase the potential for bit savings. Other modes (such as diff-2 and diff-6) use the value of the INVERT to calculate a predictor bit plane. Therefore, in some coding modes, the final bit plane reconstructed at the decoder depends on INVERT. The DATABITS field is an entropy coded stream of VLC symbols containing the information necessary to reconstruct the bit plane, given the MODE and INVERT fields.<br>
C.        Coding Modes<br>
In the second implementation, the encoder encodes binary information (e.g., skipped macroblock information) in any of seven different coding modes: row-skip mode, column-skip mode, normal-2 mode, normal-6 mode, diff-2 mode, diff-6 mode, and raw mode. A decoder performs corresponding decoding for any of the seven coding modes. Each mode is described in detail below.<br>
Alternatively, the encoder and decoder use other and/or additional coding modes.<br>
1.        Row-skip and Column-skip Modes<br>
The row-skip coding mode saves bits by representing a row in a bit plane with a single bit if each binary symbol in the row is of a certain value. For example, the encoder represents a skipped macroblock with a 0 in a bit plane, and uses a row-skip coding mode that represents a row of all Os with a single bit. The encoder therefore saves bits when entire rows of macroblocks are skipped. The decoder performs corresponding decoding.<br>
In the secondjmplementation, all-zero rows are indicated using one bit set to 0. When the row is not all zero, the one bit indicator is set to 1, and this is followed by coIMB bits containing the bit plane row in order.  Rows are scanned in the natural order.<br>
Likewise, for the column-skip mode, if the entire row is zero, a 0 bit is sent. Else, a 1 is sent, followed by the rowMB bits containing the entire column, in order.<br>
Columns are scanned in the natural order.<br>
For coding of leftover rows and/or columns in diff-6 and normal-6 modes (described below), the same logic is applied. A one-bit flag indicates whether the row or column is all zero. If not, the entire row or column is transmitted using one bit per symbol.<br>
When the encoder encodes a bit plane consisting primarily of 1s, row-skip and column-skip coding are usually less efficient, because of the lower probability that rows/columns will consist entirely of Os. However, the encoder can perform an inversion on the bit plane in such a situation to increase the proportion of Os and potentially increase bit savings. Thus, when conditional inversion is indicated through the INVERT bit, the encoder pre-inverts the bit plane before the bit plane is tiled and coded. On the'decoder side, conditional inversion is implemented by taking.the inverse of the final output. (This is not performed for the diff-2 and diff-6 mode.)<br>
Figure 19 shows a technique (1900) for encoding binary information in a bit plane in a row-skip coding mode. The encoder first checks whether inversion of the bit plane is appropriate, and, if so, performs the inversion (1910). The encoder then checks a row in the bit plane to see if each bit in the row is equal to 0 (1920). If so, the encoder sets the indicator bit for the row to 0 (1930). If any of the bits in the row are not 0, the encoder sets the indicator bit for the row to 1 and encodes each bit in the row with one bit (1940). When the encoder is.done encoding all row .3 in the bit plane (1950), encoding of the bit plane ends.<br>
A decoder performs corresponding decoding for the row-skip coding mode. Figure 20 shows a technique for encoding binary information in a column-skip coding mode. The encoder first checks whether inversion of the bit plane is appropriate, and, if so, performs the inversion (2010). The encoder then checks a column in the bit plane to see if each bit in the column is equal to 0 (2020). If so, the encoder sets the indicator bit for the column to 0 (2030). If any of the bits in the column are not 0, the encoder sets the indicator bit for the column to 1 and encodes each bit in the column with one bit (1940). When the encoder is done encoding all columns in the bit plane (1950), encoding of the bit plane ends.<br>
A decoder performs corresponding decoding for the column-skip coding mode.<br>
2.        Normal-2 Mode<br>
The encoder uses the normal-2 mode to jointly encode plural binary symbols in a bit plane (e.g., by using a vector Huffman or other variable length encoding scheme). The encoder encodes pairs of binary symbols with variable length codes. The decoder performs corresponding decoding.<br>
If rowMB x coIMB is odd, the first symbol is encoded as a single bit. Subsequent symbols are encoded pairwise, in natural scan order. A VLC table is used to encode the symbol pairs to reduce overall entropy.<br>
When conditional inversion is indicated through the INVERT bit, the encoder pre-inverts the bit plane before the bit plane is coded pairwise. On the decoder side, conditional inversion is implemented by taking the inverse of the final output. (When the diff-2 mode is used, conditional inversion is not performed at this step.)<br>
Figure 21 shows a technique (2100) for encoding binary information in normal-2 mode. The encoder performs an initial check to determine whether inversion of the bit plane is appropriate to improve coding efficiency and, if so, performs the inversion (2110). The encoder then determines whether the bit plane being coded has an odd number of binary symbols (2120). If so, the encoder encodes the first symbol with a single bit (2130). The encoder then encodes symbol pairs with variable length codes, using shorter codes to represent more probable pairs and longer codes to represent less probable pairs (2140). When encoding of the symbol pairs is done (2150), the encoding ends.<br>
A decoder performs corresponding decoding for the normal-2 coding mode<br>
3.        Normal-6 Mode<br>
The encoder also uses the normal-6 mode to jointly encode plural binary symbols in a bit plane (e.g., by using a vector Huffman or other variable length encoding scheme). The encoder tiles groups of six binary symbols and represents each group with a variable length code. The decoder performs corresponding decoding.<br>
In the normal-6 mode (and the diff-6 mode), the bit plane is encoded in groups of six pixels. These pixels are grouped into either 2x3 or 3x2 tiles. The bit plane is tiled maximally using a set of rules, and the remaining pixels are encoded using variants of row-skip and column-skip modes.<br>
In the second implementation, 3x2 "vertical" tiles are used if and only if rowMB is a multiple of 3 and coIMB is not a multiple of 3. Otherwise, 2x3<br>
"horizontal" tiles are used. Figures 22, 23 and 24 show examples of frames tiled in the normal-6 coding mode. Figure 22 shows a frame (2200) with 3x2 vertical tiles and a 1-symbol wide remainder (shown as a shaded area) to be coded in column-skip mode. Figure 23 shows a frame (2300) with 2x3 horizontal tiles and a 1-symbol wide remainder to be coded in row-skip mode. Figure 24 shows a frame (2400) with 2x3 horizontal tiles and 1-symbol wide remainders to be coded in row-skip and column-skip modes.<br>
While 3x2 and 2x3 tiles are used in this example, in other embodiments, different configurations of tiles and/or different tiling rules are used.<br>
The 6-element tiles are encoded first, followed by the column-skip and row-skip encoded linear tiles. If the array size is a multiple of 3x2 or 2x3, the latter linear tiles do not exist and the bit plane is perfectly tiled. The 6-element rectangular tiles are encoded using a VLC table.<br>
When conditional inversion is indicated through the INVERT bit, the encoder pre-inverts the bit plane before the bit plane is tiled and coded. On the decoder side,.conditional inversion is implemented by taking the inverse of the final output. (When the diff-6 mode is used, conditional inversion is not performed at this step.)<br>
Figure 25 shows a technique (2500) for encoding binary information in normal-6 mode. Tne encoder performs an initial check to determine whether inversion of the bit plane is appropriate to improve coding efficiency and, if so, performs the inversion (2510). The encoder then checks whether the number of rows in the bit plane is a multiple of three (2520). If the number of rows is not a multiple of three, the encoder groups the symbols in the bit plane into 2x3 horizontal tiles (2530).<br>
If the number of rows is a multiple of three, the encoder checks whether the number of columns in the bit plane is a multiple of three (2540). If the number of columns is a multiple of three, the encoder groups the symbols in the bit plane into 2x3 horizontal tiles (2530). If the number of columns is not a multiple of three, the encoder groups the symbols into 3x2 vertical tiles (2550).<br>
After grouping symbols into 3x2 or 2x3 tiles, the encoder encodes the groups of six tiled symbols using a technique such as a six-dimension vector Huffman coding technique or some other coding technique (2560). The encoder encodes any remaining untiled symbols using the row-skip and/or column-skip coding techniques described above (2570).<br>
A decoder performs corresponding decoding for the normal-6 coding mode.<br>
In other embodiments, an encoder uses other techniques to code the tiled and untiled symbols.<br>
4.        Diff-2 and Diff-6 Modes<br>
Differential coding modes such as diff-2 or diff-6 mode encode bit planes by first generating a bit plane of differential (or residual) bits for the bit plane to be coded, based on a predictor for the bit plane to be coded. The residual bit plane is then encoded using, for example, the normal-2 or normal-6 coding mode, without conditional inversion.-<br>
In the second implementation, the diff-2 and diff-2 modes employ differential coding denoted by the operation diff. If either differential mode is used, a bit plane<br>
• of differential bits is first generated by examining the predictor b(i, j) of the bit plane<br>
b\i,j), which is defined as the causal operation:<br>
(Equation Removed) <br>
(1).<br>
In other words, the predictor b(i, j) of a given binary symbol b(i, j) will be the binary symbol just to the left b(i -1, j) except in the following special cases:<br>
1)	If b(i, ;') is at the top left corner of the bit plane, or if the above binary<br>
symbol b{i,   -1) is not equal to the binary symbol to the left<br>
b(i-1 J), the predictor b(i, j) is equal to the value of INVERT; or<br>
2)	If 1) does not apply and b(i, j) is in the left column (/ == 0), the<br>
predictor b(i,j) will be the above binary symbol b(i, j-l).<br>
On the encoder side, the diff operation computes the residual bit plane r according to:<br>
(2),  (Equation Removed) <br>
where ® is the exclusive or operation. The residual bit plane is encoded using the normal-2 or normal-6 modes with no conditional inversion.<br>
On the decoder side, the residual bit plane is regenerated using the appropriate normal mode. Subsequently, the residua! bits are used to regenerate the original bit plane as the binary 2-D difference:<br>
(3).  (Equation Removed) <br>
 Figure 26 shows a technique (2600) for encoding binary information in a differential coding mode. The encoder calculates a predictor for a bit plane (2610), for example, as shown in equation 1. The encoder then calculates a residual bit plane, for example, by performing an XOR operation on the bit plane and its predictor (2620). The encoder then encodes the residual bit plane (e.g., in normal-2 or normal-6 mode) (2630).<br>
Figure 27 shows a technique (2700) for decoding binary information encoded in a differential coding mode. The decoder decodes the residual bit plane (2710) using an appropriate decoding technique, based on the mode used to encode the residual bit plane (e.g., normal-2 or normal-6 mode). The decoder also calculates the predictor for the bit plane (2720), using the same technique used in the encoder. The decoder then reconstructs the original bit plane, for example, by performing-.an XOR operation on the decoded residual bit plane and the predictor bit plane (2730).<br>
5.	Raw Mode<br>
All modes except for raw mode encode a bit plane at the frame level, which calls for a second pass through the frame during encoding. However, for low-latency situations, the second pass can add unacceptable delay (e.g., because transmission of the frame header and macroblock layer information is delayed until the last macroblock in the frame is reached, because of the time spent encoding the bit plane).<br>
The raw mode uses the traditional method of encoding the bit plane one bit per binary symbol at the same location in the bitstream as the rest of the macroblock level information. Although macroblock-level coding of symbols is not a new concept by itself, switching the coding of symbols from frame level to macroblock level provides a low latency alternative to frame-level coding.<br>
Figure 28 shows a technique (2800) for selectively encoding binary information for a macroblock in raw coding mode for low latency applications.  First, the encoder checks whether to use raw mode to encode the binary information (2810). If so, the encoder encodes a bit at the macroblock level for a macroblock (2820) and checks whether the macroblock is the last macroblock in the frame (2830). If the macrobiock is not the last macroblock in the frame, the encoder continues by encoding a bit for the next macroblock at the macroblock level (2820).<br>
If the encoder does not use the raw coding mode, the encoder encodes a bit plane at the frame level for the macroblocks in the frame (2840). When the encoding of the macroblocks in the frame is done (2850), the encoding ends for the frame.<br>
While the technique (2800) shows switching modes on a frame-by-frame basis, alternatively the encoder switches on some other basis.<br>
Having described and illustrated the principles of our invention with reference to various embodiments, it will be recognized that the various embodiments can be modified in arrangement and detail without departing from such principles. It should be understood that the programs, processes, or methods described herein are not related or limited to any particular type of computing environment, unless indicated otherwise. Various types of general purpose or specialized computing environments may be used with or perform operations in accordance with the teachings described herein. Elements of embodiments shown in software may be implemented in hardware and vice versa.<br>
In view of the many possible embodiments to which the principles of our invention may be applied, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto.<br><br><br><br><br><br><br><br><br><br><br><br>
I/We claim:<br>
1.	A computer-implemented method of processing plural video pictures of a video<br>
sequence, the plural video pictures including plural predicted macroblocks, wherein each block<br>
of the plural predicted macroblocks is predicted from no more than one reference video picture,<br>
the method comprising:<br>
receiving encoded video in a bitstream, the encoded video including an entropy coding mode selection syntax element;<br>
based upon the entropy coding mode selection syntax element, selecting an entropy coding mode from among plural available entropy coding modes;<br>
for one or more skipped macroblocks among the plural predicted macroblocks, decoding skipped macroblock information at a layer of bitstrean syntax in the bitstream according to the selected entropy coding mode, the skipped macroblock information having been encoded according to the entropy coding mode selected from among the plural available entropy coding modes; and<br>
decoding the one or more skipped macroblocks, wherein the decoding for one of the one or more skipped macroblocks uses motion compensation with predicted motion for the skipped macroblock based upon motion of plural other predicted macroblocks around the skipped macroblock, and wherein each of the one or more skipped macroblocks lacks residual information.<br>
2.	The method as claimed in claim 1, wherein the bitstream syntax includes plural hierarchical layers, and wherein the laye at. which the skipped macroblock information is signaled is higher than macroblock layer in the bitstream syntax.<br>
3.	The method as claimed in claim 2, wherein the plural hierarchical layers include at least a picture layer and the macroblock layer, and wherein the higher layer is the picture layer.<br>
4.	The method as claimed in claim 2, wherein a header at the higher layer includes the skipped macroblock information.<br>
5.	The method as claimed in claim 1, wherein the predicted motion for the skipped macroblock uses a motion vector equal to a predictor motion vector derived from motion vectors of the plural other predicted macroblocks around the skipped macroblock.<br>
6.	The method as claimed in claim 1, wherein the one or more skipped macroblocks include plural skipped macroblocks, and wherein:<br>
according to a first entropy coding mode of the plural available entropy coding modes, a single code in the bitstream represents the skipped macroblock information for the plural skipped macroblocks; and<br>
according to a second entropy coding mode of the plural available entropy coding modes, multiple codes in the bitstream represent the skipped macroblock information for the plural skipped macroblocks.<br>
7.	A computer-implemented method of processing plural video pictures of a video<br>
sequence, the plural video pictures including plural predicted macroblocks, wherein each block<br>
of the plural predicted macroblocks is predicted from no more than one reference video picture,<br>
the method comprising:<br>
selecting an entropy coding mode from among plural available entropy coding modes;<br>
encoding one or more skipped macroblocks among the plural predicted macroblocks, wherein the encoding for one of the one or more skipped macroblocks uses motion compensation with predicted motion for the skipped macroblock based upon motion of plural other predicted macroblocks around the skipped macroblock, and wherein each of the one or more skipped macroblocks lacks residual information;<br>
encoding skipped macroblock information for the one or more skipped macroblocks at a layer of bitstream syntax in a bitstream, wherein the encoding the skipped macroblock information includes encoding the skipped macroblock information according to the entropy coding mode selected from among the plural available entropy coding modes; and<br>
outputting encoded video in the bitstream, the encoded video including an entropy coding mode selection syntax element that indicates the selected entropy coding mode.<br>
8.	The method as claimed in claim 7, wherein the layer at which the skipped macroblock information is signaled is higher than macroblock layer  in the bitstream syntax, and wherein the higher layer is picture layer.<br>
9.	The method as claimed in claim 7, wherein the layer at which the skipped macroblock information is signaled is higher than macroblock layer in the bitstream syntax, and wherein a header at the higher layer includes the skipped macroblock information.<br><br>
10.	The method as claimed in claim 7, wherein the predicted motion for the skipped macroblock is equal to a predictor motion vector derived from motion vectors of the plural other predicted macroblocks around the skipped macroblock.<br>
11.	The method as claimed in claim 7, wherein the one or more skipped macroblocks include plural skipped macroblocks, and wherein:<br>
according to a first entropy coding 'node of the plural available entropy coding modes, a single code in the bitstream represents the skipped macroblock information for the plural skipped macroblocks; and<br>
according to a second entropy coding mode of the plural available entropy coding modes, multiple codes in the bitstream represent the skipped macroblock information for the plural skipped macroblocks.<br>
12.	A system comprising:<br>
means for processing plural video pictures of a video sequence, the plural video pictures including one or more predicted video pictures, wherein each of the one or more predicted video pictures includes plural macroblocks, the means for processing plural video pictures comprising: means for selecting an entropy coding mode from among plural available entropy coding modes;<br>
means for encoding one or more skipped macroblocks among the plural macroblocks of at least one of the o ne or more predicted video pictures, wherein each of the at least one of the one or more predicted video pictures is predicted from no more than one reference video picture, wherein the encoding for one of the one or more<br>
skipped macroblocks uses motion compensation with predicted motion for the skipped macroblock based upon motion of plural other macroblocks around the skipped macroblock, and wherein each of the one or more skipped macroblocks lacks residual information; and<br>
means for encoding skipped macroblock information for the one or more skipped macroblocks at a layer higher than macroblock layer of bitstream syntax in a bitstream, wherein the encoding the skipped macroblock information includes encoding the skipped macroblock information according to the entropy coding mode selected from among the plural available entropy coding modes; and<br>
means for outputting encoded video in the bitstream, the encoded video including an entropy coding mode selection syntax element that indicates the selected entropy coding mode.<br>
13.	The system as claimed in claim 12, wherein the predicted motion for the skipped macroblock is equal to a predictor motion vector derived from motion vectors of the plural other macroblocks around the skipped macroblock.<br>
14.	A system comprising:<br>
means for receiving encoded video in a bitstream, the encoded video including an entropy coding mode selection syntax element; and<br>
means for processing plural video pictures of a video sequence, the plural video pictures including plural predicted macroblocks, wherein each block of the plural predicted macroblocks is predicted from no more than one reference video picture, the means for processing plural video pictures comprising:<br>
means for selecting, based upon the entropy coding mode selection syntax<br>
element, an entropy coding mode selected from among plural available entropy coding<br>
modes;<br>
means for decoding, for one or more skipped macroblocks among the plural<br>
predicted macroblocks, skipped macroblock information at a layer higher than<br>
macroblock layer of bitstream syntax in the bitatream according to the selected entropy<br>
coding mode, the skipped macroblock information having been encoded according to the<br>
entropy coding mode selected from among the plural available entropy coding modes; and<br>
means for decoding the one or more skipped macroblocks among the plural predicted macroblocks, wherein the decoding for one of the one or more skipped macroblocks uses motion compensation with predicted motion for the skipped macroblock based upon motion of plural other predicted macroblocks around the skipped macroblock, and wherein each of the one or more skipped macroblocks lacks residual information.<br>
15.	The system as claimed in claim 14, wherein the bitstream syntax includes plural<br>
hierarchical layers, the plural hierarchical layers including at least a picture layer and the<br>
macroblock layer.<br>
16.	The system as claimed in claim .14, wherein the higher layer is the picture layer.<br>
17.	The system as claimed in claim 14, wherein a header at the higher layer includes the skipped macroblock information.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1ERUxOUC0yMDA0LUFic3RyYWN0LSgyMi0wOS0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">1521-DELNP-2004-Abstract-(22-09-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LUNsYWltcy0oMDItMDQtMjAxNCkucGRm" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-Claims-(02-04-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1ERUxOUC0yMDA0LUNsYWltcy0oMjItMDktMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1521-DELNP-2004-Claims-(22-09-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMDItMDQtMjAxNCkucGRm" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-Correspondence Others-(02-04-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMTUtMDEtMjAxNCkucGRm" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-Correspondence Others-(15-01-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1ERUxOUC0yMDA0LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMjItMDktMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1521-DELNP-2004-Correspondence Others-(22-09-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LUNvcnJlc3BvbmRlbmNlLU90aGVycy0oMjUtMDQtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-Correspondence-Others-(25-04-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1ERUxOUC0yMDA0LURyYXdpbmdzLSgyMi0wOS0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">1521-DELNP-2004-Drawings-(22-09-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1ERUxOUC0yMDA0LUZvcm0tMS0oMjItMDktMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1521-DELNP-2004-Form-1-(22-09-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LWZvcm0tMTMucGRm" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LWZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1ERUxOUC0yMDA0LUZvcm0tMi0oMjItMDktMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1521-DELNP-2004-Form-2-(22-09-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LUZvcm0tMy0oMjUtMDQtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-Form-3-(25-04-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1ERUxOUC0yMDA0LUdQQS0oMjItMDktMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1521-DELNP-2004-GPA-(22-09-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LWdwYS5wZGY=" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LXBjdC0yMTAucGRm" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-pct-210.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LXBjdC0zMDQucGRm" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-pct-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LXBjdC00MDkucGRm" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-pct-409.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LXBjdC00MTYucGRm" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-pct-416.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUyMS1kZWxucC0yMDA0LVBldGl0aW9uLTEzOC0oMjUtMDQtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1521-delnp-2004-Petition-138-(25-04-2011).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="260151-compound-chain-drive-guide.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="260153-method-for-replacing-outdated-content-at-a-communication-device-operable-pursuant-to-a-push-content-in-a-radio-communication-system.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>260152</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1521/DELNP/2004</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>14/2014</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>04-Apr-2014</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>02-Apr-2014</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>02-Jun-2004</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>MICROSOFT CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>ONE MICROSOFT WAY, REDMOND, WASHINGTON 98052-6399, UNITED STATES OF AMERICA.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>SRIDHAR SRINIVASAN</td>
											<td>1504 AURORA AVENUE N., #509, SEATTLE, WA 98109, USA.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>POHSIANG HSU</td>
											<td>4850 156TH AVENUE N.E., UNIT 93, REDMOND, WA 98052 USA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04N 7/50</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US02/40208</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-12-16</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/341,674</td>
									<td>2001-12-17</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/377,712</td>
									<td>2002-05-03</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/260152-processing-video-images-having-plural-units by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 22:42:50 GMT -->
</html>
