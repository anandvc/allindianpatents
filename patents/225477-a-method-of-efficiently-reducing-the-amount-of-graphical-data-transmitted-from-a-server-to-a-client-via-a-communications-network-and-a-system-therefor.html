<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/225477-a-method-of-efficiently-reducing-the-amount-of-graphical-data-transmitted-from-a-server-to-a-client-via-a-communications-network-and-a-system-therefor by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:57:04 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 225477:A METHOD OF EFFICIENTLY REDUCING THE AMOUNT OF GRAPHICAL DATA TRANSMITTED FROM A SERVER TO A CLIENT VIA A COMMUNICATIONS NETWORK, AND A SYSTEM THEREFOR</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD OF EFFICIENTLY REDUCING THE AMOUNT OF GRAPHICAL DATA TRANSMITTED FROM A SERVER TO A CLIENT VIA A COMMUNICATIONS NETWORK, AND A SYSTEM THEREFOR</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The present invention relates to a method of efficiently reducing the amount of graphical data transmitted from a server (150) to a client (110) via a communications network (140), said method comprising the steps of separating (830) a path into a plurality of strips; determining (820) a quantized angle associated with the absolute angle for each of the plurality of strips; forming a protocol stream at the server (150), the protocol stream having a beginning coordinate of the path and the strip length and an indicia of the quantized angle of each of the plurality of strips; and transmitting (870) the protocol stream from the server (150) to the client (110) via the communications network (140); characterised in that each of the plurality of strips having a beginning and an endpoint coordinate defined within a coordinate system, a strip length and an absolute angle associated therewith, the coordinate system corresponding to a region of a display surface associated with the client (110). A system for carrying out the method is also disclosed.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>A METHOD OF EFFICIENTLY REDUCING THE AMOUNT OF GRAPHICAL<br>
DATA TRANSMITTED FROM A SERVER TO A CLIENT VIA A<br>
COMMUNICATIONS NETWORK, AND A SYSTEM THEREFOR<br>
CROSS-REFERENCE TO RELATED APPLICATIONS<br>
[0001] This claims, priority to and the benefit of U.S. provisional patent application<br>
numbers 60/207,532, filed May 26,2000, and 60/225,217, filed August 14,2000, the entirety of<br>
which are incorporated herein by reference.<br>
HELD OF THE INVENTION<br>
[0002] The present invention relates generally to communication between an<br>
application server and a thin client in a distributed system and, in particular, to the redaction in<br>
the amount of graphical display data transmitted over a low bandwidth transport protocol<br>
mechanism.<br>
BACKGROUND OF THE INVENTION<br>
[0003] Distributed computer systems utilize the technique of distributing application<br>
execution. More specifically, an application server locally executes an application program and<br>
provides the application output data to clients/network users who then display the results cm a<br>
display screen coupled to their local computer. By performing the application processing<br>
functions at the server and displaying the application output at the client, these distributed<br>
systems make the best use of server and client resources, i.e., the more capable server performs<br>
the compute and memory intensive application processing functions while the client, with<br>
potentially greater video performance, displays the output During execution of the application<br>
program, a user of the client views the application output data on the client's display and<br>
interacts with the application program via keyboard or mouse inputs. The client user's inputs<br>
correspond to requests to the application server to perform certain actions that affect the<br>
operation of the application program. The application server passes these requests to the<br>
application for further processing. The application server also intercepts the application output<br>
data, generated by the application program and typically targeted to the operating system of the<br>
application server, and transmits all or part of the data to the client for display. From the<br>
perspective of the user, the application program seems to be executing locally even though it is<br>
actually being executed on a remote server and just being displayed locally.<br>
[0004] The performance of distributed systems depends to % large "degree on the<br>
capability of the network, which couples the client and the server, and therefore on the amount of<br>
graphical data (corresponding to the application output data) that is transmitted over the network.<br>
Since the application server and the client workstation are generally linked only by a transport<br>
mechanism (such as serial lines, telephone lines, local area networks and wide area networks)<br>
that possesses lower bandwidth than would be otherwise available if the application program<br>
were executing locally, the perceived performance of the distributed system may suffer.<br>
Accordingly, manufacturers of distributed systems/software continually strive to improve the<br>
performance of such systems.<br>
SUMMARY OF THE INVENTION<br>
[0005] The present invention improves the performance of distributed systems by<br>
reducing the amount of graphical data (e.g., bitmapped graphical data, encoded bitmaps, glyphs,<br>
and line data) transmitted between the server and the client. The invention achieves this<br>
reduction in several different ways, for example, by encoding the graphical data into a smaller<br>
object, by representing a graphical object with indicia of the object, by increasing the<br>
repetitiveness of the data in the protocol stream so that compression algorithms operate more<br>
efficiently, by tracking and leveraging the prior transmissions of identical/repetitive paphical<br>
objects, by adapting the rate of processing activity or the encoding technique in response to<br>
changes in the network performance or in response to performance mismatches between the<br>
client and server, and in several other ways described herein.<br>
[0006] In one embodiment, the present invention enables the efficient transmission of<br>
graphical display data from an application server node to a client node. In this embodiment, the<br>
invention intercepts a plurality of graphical display information commands issued by an<br>
application executing on the server. Once these commands have been intercepted or otherwise<br>
obtained, they are analyzed to determine whether they should be selected for further transmission<br>
to remote client nodes. The selected commands are then encoded and packaged into a protocol<br>
packet stream for eventual transmission to the remote client nodes. Prior to transmission, the<br>
packet stream can be further compressed by subjecting the encoded packets to compression<br>
techniques.<br>
[0007] The encoding technique of the present invention substantially maximizes<br>
compression of the protocol packet stream by building in repeatability into the protocol stream<br>
that allows the compression algorithm to substitute pointers for repetitive data. This technique<br>
focuses on maximizing the efficiency of the compression algorithm, rather than solely reducing<br>
the amount of data via encoding prior to transmission. The result of this encoding scheme is that<br>
the degree of compression is significantly increased for many types of graphical data. The<br>
encoding technique of the present invention encodes the graphical data so that portions of the<br>
graphical data that repeat are encoded in the same manner. The compression algorithm then<br>
operates on this repetitive encoded data to realize a greater degree of efficiency.<br>
[0008] In one embodiment, the present invention efficiently reduces the amount of<br>
repetitive graphical data transmitted to a remote display device coupled to the client. In this<br>
embodiment, a server agent searches for an index (that may have been previously stored on the<br>
server by the server agent) associated with the graphical data and which is indicative of a prior<br>
transmission of the graphical data to a client agent. The index or handle represents a memory<br>
location in the client's cache memory that currently stores the previously transmitted graphical<br>
data. If the index is found, then the index is transmitted to the client agent, thus avoiding the<br>
need to transmit the graphical data itself. The client agent obtains the graphical object stored in<br>
the cache location identified by the index and performs additional processing activities as<br>
directed by the server agent. In one aspect of the invention, commands and information<br>
transmitted between the server agent and the client agent are queued at the server. The<br>
commands in the queue can then be processed in accordance with an estimate of the relative<br>
performance between the client and server agents or computers.<br>
[0009] If the server agent is unable to locate the index, the server agent searches a fuzzy<br>
database for a fuzzy key that is associated with the graphical data. The fuzzy key, for example,<br>
corresponds to a length of the graphical data. The fuzzy key indicates that the graphical data had<br>
at one time been transmitted to the client and that there is a strong likelihood that the graphical<br>
data is stored within the client's persistent storage memory. One or more fuzzy keys are<br>
provided to the server agent upon initiating a session between the client and server agents.<br>
Alternatively, the fuzzy keys are transmitted to the server agent in accordance "with a<br>
predetermined polling interval. Regardless of how the fuzzy keys are received, the server agent<br>
stores them in the fuzzy database for subsequent use during the client/server session. The fuzzy<br>
database relating to a particular session can also be maintained beyond the term of the session so<br>
that it is available for future sessions, by, for example; having the client agent persistently cache<br>
the graphical data from the particular session and causing the server agent to dynamically<br>
construct the fuzzy database on the server from the client's persistently-cached graphical data<br>
during a future session. This may prove useful in environments where frequent, but short,<br>
sessions are present.<br>
[0010] If the fuzzy key is located, then the server agent transmits the fuzzy key together<br>
with a command to the client agent, which, for example, retrieves the graphical data stored in its<br>
persistent storage memory and copies it into its volatile memory. If the client agent fails to<br>
retrieve the graphical data, the server agent can transmit the graphical data, together with a<br>
recovery marker, to the client agent.<br>
[0011] If the server agent is unable to locate the fuzzy key within the fuzzy database,<br>
the server agent forms the fuzzy key and stores the fuzzy key in the fuzzy database. The server<br>
agent then transmits the fuzzy key, an index, and the graphical data to the client agent, which is<br>
instructed to store the data in the client's volatile memory associated with the index. As the<br>
client-server session continues and the client's volatile memory becomes full, graphical data will<br>
be transferred into the client's persistent storage. In one aspect the client agent stores the<br>
graphical data in a file residing in the persistent storage memory that reflects the fuzzy key as<br>
part of the file's name.<br>
[0012] In one aspect of the invention, the server agent instructs the client agent to<br>
update an off-screen surface coupled to the client agent using the graphical data identified by the<br>
server agent and/or stored in the client's volatile or persistent storage memory. These<br>
instructions can be triggered in response to a change in the off-screen surface, such as when the<br>
off-screen surface and on-screen surface of the client node interact. If the client agent fails to<br>
update the off-screen surface in accordance with the server agent's instructions, the server agent<br>
can transmit the graphical data to the client agent and direct that the client agent update portions<br>
of its on-screen or off-screen surfaces, which may have been corrupted, with the transmitted<br>
graphical data.<br>
[0013] Further, the encoding technique used to encode the graphical data prior to<br>
transmission can be selected based on an estimate of the network conditions of the network that<br>
couples the client agent with the server agent. This estimate can correspond to a time differential<br>
measured by the client agent that relates to the amount of time expended to receive a particular<br>
encoded graphical data.<br>
[0014] In one embodiment, the present invention adapts a processing rate in response to<br>
changing network conditions. In one aspect of the invention, the server agent processes graphical<br>
data addressed to the client agent at a first rate. By determining the network conditions of the<br>
network that couples the client and server agents, the server agent can adjust its processing rate<br>
from the first rate to a second rate in response to a change in the network conditions. The server<br>
agent can determine information about the network conditions by transmitting the processed<br>
graphical data to the client agent and instructing the client to measure a time differential<br>
associated with the transmission or receipt of the graphical data. In this manner, the time<br>
differential provides an Indicator of the network conditions and the server agent can rationally<br>
select the second rate in accordance with this time differential. Similarly, the encoding technique<br>
used while processing the graphical data by the server agent at the first rate can be modified to a<br>
second encoding scheme/technique in response to changes in the network conditions that are<br>
determined by the server agent. The network conditions can be estimated in accordance with the<br>
time differeritial discussed previously. Once the second encoding technique is selected by the<br>
server agent, the server agent will process subsequent graphical data using this second encoding<br>
technique.<br>
[0015] In one embodiment, the invention adapts a processing rate of the server in<br>
response to a performance mismatch between the server and the client coupled to the server via<br>
the network. In operation, the server agent processes graphical data and determines a first time<br>
period associated with such processing. For example, the first time period can be determined by<br>
scrolling a frame buffer of the server. The client agent also processes the graphical data and<br>
determines a second time period associated with its processing. The server agent then<br>
determines the time differential between the first and second time periods and adjusts its<br>
processing rate in accordance therewith.<br>
[0016] In one embodiment, the invention efficiently reduces the amount of graphical<br>
line data transmitted from a server to a client via a communications network. The server agent<br>
separates a path defining a line or region into a plurality of strips, where each of the strips have a<br>
beginning and an endpoint coordinate defined within a coordinate system (e.g., a Cartesian<br>
coordinate system). The coordinate system corresponds to a region of a display surface<br>
associated with the client. In one aspect of the invention, the server agent quantizes the<br>
coordinate system into a plurality of quantized angles (e.g., 16 quantized angles) and determines<br>
the endpoint coordinate of one of the plurality of strips. The coordinate system is then<br>
normalized so that its origin coincides with this endpoint coordinate. The beginning coordinate<br>
of the adjacent strip in the path is then associated by the server agent with the endpoint<br>
coordinate of the first strip. The server agent then selects one of the quantized segments of the<br>
coordinate system as corresponding to an approximate angle of the adjacent strip. This technique<br>
enables the transmission of the difference between the endpoint coordinates of the two srrips(i.c.,<br>
the .strip length) and an indication of the selected quantized angle and thus avoids having to<br>
transmit both sets of coordinates or a coordinate and the precise angle for each strip.<br>
|0017] In one embodiment of the invention, the server agent remotely controls the<br>
formation of an off-screen surface at a client, which is coupled to the server via a<br>
communications network. The server agent informs the client agent that an off-screen surface of<br>
a particular size or type is to be formed within the client's memory and the client agent responds<br>
by selecting and allocating a first memory region having an appropriate format to represent the<br>
off-screen surface from a plurality of available memory regions in the client's memory. The<br>
server agent then either transmits a bitmap or an indicia of the bitmap (e.g., index or fuzzy key)<br>
to the client agent and instructs the client agent to copy the bitmap to a particular location within<br>
the first memory region. Once the bitmap is copied to the off-screen surface, it can be used to<br>
update the client's on-screen surface. Such off-screen operations can also be performed for non-<br>
bitmap data, such as lines or text.<br>
[0018] The server agent can also respond to error conditions by storing a duplicate of<br>
the client's off-screen surface in the server's local memory. In the event of an error condition,<br>
such as when a preselected memory region of the client's memory is not sufficiently large<br>
enough to store a particular off-screen surface, the client agent asynchronously informs the server<br>
agent of the error. In response to the error condition, the server agent transmits at least one<br>
portion of its duplicate off-screen surface or a copy of the bitmap to the client agent and instructs<br>
the client agent to update the client's on-screen surface using the transmitted duplicate off-screen<br>
surface data.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0019] The foregoing discussion will be understood more readily from the following<br>
detailed description of the invention, when taken in conjunction with the accompanying<br>
drawings, in which:<br>
Fig. 1 schematically illustrates a client node coupled to a server node via a<br>
communication network, where the client and server nodes each have respective client and server<br>
agents operating in accordance with an embodiment of the present invention;<br>
Fig. 2 provides a high-level flow diagram of the steps performed by the server agent of<br>
Fig. 1 in accordance with an embodiment of the present invention;<br>
Fig. 3 provides a more detailed flow diagram to the diagram of Fig. 2 in accordance with<br>
an embodiment of the present invention;<br>
Fig. 4 schematically illustrates the contents of the client and server's volatile and<br>
persistent memory, as affected by operations of the client and server agents of Fig. 1, in<br>
accordance with an embodiment of the present invention;<br>
Fig. 5 provides a flow diagram of the steps taken to minimize the amount of data<br>
transmitted to the client by using caching techniques involving a fuzzy database and fuzzy keys,<br>
in accordance with an embodiment of the present invention;<br>
Fig. 6 schematically illustrates a set of procedures used to remote text information<br>
generated by an application program on a server to a display of a distant client in accordance with<br>
an embodiment of the present invention;<br>
Fig. 7A provides a line diagram illustrating a plurality of segments forming a particular<br>
path;<br>
Fig. 7B provides a pixel-level representation of the line diagram of Fig. 7A, illustrating<br>
how the path is actually approximated on a computer display;<br>
Fig. 8 provides a flow diagram of the steps taken when processing and encoding segment<br>
and strip data in accordance with an embodiment of the present invention;<br>
Fig. 8B provides a coordinate system organized into a set of 16 regions that is used to<br>
quantize angle information relating to strips and which improves compression efficiency in<br>
accordance with an embodiment of the present invention;<br>
Fig. 9 superimposes the coordinate system of Fig. 8B on the pixel-level representation of<br>
Fig. 7B to illustrate an embodiment of a strip processing technique in accordance with the<br>
present invention;<br>
Fig. 10 provides a table, which illustrates how to get to the next strip from the endpoint of<br>
the previous strip, for strips in each of the quantized segments of Fig. 8B in accordance with an<br>
embodiment of the present invention; and<br>
Fig. 11 provides a flow diagram of the steps performed by the server agent in response to<br>
an error condition involving the formation of a client's off-screen surface.<br>
DETAILED DESCRIPTION OF THE INVENTION<br>
[0020] The present invention reduces the amount of graphical data transmitted between<br>
an application server, which is executing an application program, and a subscribing client, which<br>
is locally displaying the output data of the application program, by encoding the data into<br>
relatively small representations that repeat within the protocol'stream transmitted between the<br>
client and the server. In this manner, the invention minimizes the size of each discrete data<br>
element that must be transmitted and increases the repeatability of the data within the protocol<br>
stream so that compression algorithms that operate more efficiently on repetitive encoded data<br>
can realize a greater degree of compression efficiency. The invention uses a number of<br>
techniques to realize this enhanced compression, including the following: scanning a command<br>
queue for later-issued commands which supercede earlier-issued commands; disk-caching<br>
techniques that improve compression of data that has been previously encountered during a<br>
client-server session; transmission of relative coordinates using quantized regions to avoid<br>
sending both endpoints and/or the angle of an associated strip; and manipulation of off-screen<br>
surfaces to enhance performance during the client-server session. The invention also reduces the<br>
frequency of overscroll problems encountered when there is a performance mismatch between a<br>
fast server and a relatively slow network or client.<br>
[0021] With reference to Fig. 1, one or more client nodes 110', 110" (hereinafter each<br>
client node or plurality of client nodes is generally referred to as 110) are in communication with<br>
one or more server nodes 150', 150" (hereinafter each server node or plurality of server nodes is<br>
generally referred to as 150) via a communications network 140. The network 140 can be a<br>
local-area network (LAN), a medium-area network (MAN), or a wide area network (WAN) such<br>
as the Internet or the World Wide Web. Users of the client node 110 can be connected to the<br>
network 140 through a variety of connections including standard telephone lines, LAN or WAN<br>
links (e.g., T1, T3, 56kb, X.25), broadband connections (ISDN, Frame Relay, ATM), and<br>
wireless connections. The connections can be established using a variety of communication<br>
protocols (e.g., TCP/IP, IPX, SPX, NetBIOS, and direct asynchronous connections). In some<br>
particularly advantageous embodiments, the protocol used may be the Independent Computing<br>
Architecture protocol manufactured by Citrix Systems, Inc. of Fort Lauderdale, Florida or the<br>
Remote Display Protocol manufactured by Microsoft Corporation of Redmond, Washington.<br>
[0022] The client node 110 can be any personal computer (e.g., 286, 386,486, Pentium,<br>
Pentium n, Macintosh computer), Windows-based terminal, Network Computer, wireless device,<br>
information appliance, RISC Power PC, X-device, workstation, mini computer, main frame<br>
computer or other computing device that has a windows-based desktop and sufficient memory<br>
for executing a small, display presentation program. The display presentation program uses<br>
commands and data sent to it by the application server 150 across the network 140 to render a<br>
graphical display. In a distributed computer system model, the execution of application<br>
programs occurs primarily on the application server 150 and the user interface, keystrokes, and<br>
mouse movements produced by client-side inputs are transmitted over the network 140 to and<br>
from the client node 110.<br>
[0023] The client node 110 typically includes a processor 112, a volatile memory 114<br>
(e.g., RAM cache), an operating system 116, a client agent 118, a persistent storage memory 120,<br>
a network interface 122 (e.g., a network interface card), a keyboard 124, a mouse 126, and a<br>
display 128. Windows-oriented platforms supported by the client node 110 can include, without<br>
limitation, WINDOWS 3.x, WINDOWS 95, WINDOWS 98, WINDOWS NT 3.51, WINDOWS<br>
NT 4.0, WINDOWS 2000, WINDOWS CE, MAC/OS, Java, and UNIX. The client agent 118<br>
corresponds to a software program that receives commands and data from the server node 150<br>
and from a user (not shown) of the client node 110. The client agent 118 uses the received<br>
information when interacting with other components of the client node 110 (e.g., when directing<br>
the operating system 116 to output data onto the display 128). The client agent 118 also transmits<br>
requests and data to the server node 150 in response to server-issued commands or user actions at<br>
the client node 110.<br>
[0024] Similarly, the server node 150 includes a processor 152, a volatile memory 154,<br>
an operating system 156, an application program 158, a server agent 160, persistent storage<br>
memory 162, and a network interface 164. The server agent 160 corresponds to a software<br>
program that interfaces with the client agent 118 and other components of the server node 150 to<br>
support the remote display and operability of the application program 158.<br>
[0025] Each application server 150 hosts one or more application programs 158 that can<br>
be accessed by the client nodes 110. Examples of such applications include word processing<br>
programs such as MICROSOFT WORD and spreadsheet programs such as MICROSOFT<br>
EXCEL, both manufactured by Microsoft Corporation of Redmond, Washington, financial<br>
reporting programs, customer registration programs, programs providing technical support<br>
information, customer database applications, or application set managers.<br>
[0026] During execution of the application program 158, a server 150 communicates<br>
with the client node 110 over a transport mechanism (part of the server agent 160). In one<br>
embodiment, the transport mechanism provides multiple virtual channels and one of the virtual<br>
channels provides a protocol for transmission of graphical screen data from the server node 150<br>
to the client node 110. The server 150 executes a protocol driver (part of the server agent 160)<br>
that intercepts graphical display interface commands (generated by the application program 158<br>
and targeted at the server's operating system 156) and translates them into a protocol packet<br>
suitable for transmission over the transport mechanism.<br>
[0027] In one embodiment and with reference to Fig. 2, the server agent 160 intercepts<br>
a graphical display interface command (step 202) issued by the application program 158 and<br>
directed to the operating system 156, encodes graphical data associated with the command and<br>
the application program 158 (step 204), compresses the encoded graphical data (step 206),<br>
creates a transport protocol packet incorporating the intercepted command and compressed,<br>
encoded data (step 208), and transmits the transport protocol packet to the target client node 110<br>
(step 210). Graphical data refers to any type of data that can be displayed on the display 128,<br>
such as bitmaps, glyphs, coordinates, list of lines, strips, etc. Hereinafter, descriptions of<br>
techniques which are applied to particular types of graphical data or graphical objects can be<br>
construed to apply to all types of graphical data.<br>
[0028] More particularly, a protocol driver of the server agent 160 intercepts the<br>
graphical display interface commands (step 202). In one embodiment the protocol driver<br>
intercepts high-level application programming interface calls made by the application program<br>
158. In one embodiment, the protocol driver intercepts GDI commands provided by<br>
WINDOW$-based operating systems. In another embodiment, the protocol driver intercepts<br>
QUICKDRAW commands, provided by MAC/OS-based operating systems. In still other<br>
embodiments, the protocol driver intercepts lower-level commands, such as interface calls to the<br>
device driver associated with the graphical display of the server node 150. In still other<br>
embodiments, the graphical display interface command may be duplicated rather than<br>
intercepted. In these embodiments, the display of the application program output data on the<br>
server 150 and the client 110 will be substantially similar, if not identical. The protocol driver<br>
creates a transport protocol packet based on the intercepted graphical display command (step<br>
208). The protocol driver may use a protocol command set that contains an analogous command<br>
for each possible intercepted display interface command. Alternatively, the protocol driver may<br>
use a command set that is a subset of the intercepted display interface commands. In other<br>
embodiments, the protocol command set may be a superset of the possible intercepted display<br>
interface commands.<br>
[0029] For each intercepted GDI command and affected graphical data that must be<br>
transmitted to the client agent 118 in order to display the output of the application program 158<br>
on the client's display 128, the server agent 160 queues the related protocol command together<br>
with a unique key 412 (Fig. 4) associated with the affected graphical data. The unique key 412<br>
describes and uniquely identifies the graphical data. In one embodiment the unique key is<br>
generated by performing a 64 bit cyclic redundancy check (CRC) on the graphical data. In<br>
another embodiment, the 64 bit CRC is generated as two 32 bit CRCs, performed on the<br>
graphical data sequentially and in opposite directions. Other methods of generating a unique key<br>
associated with graphical data, as known to one skilled in the art, may also be used. The protocol<br>
command and the unique key 412 are queued at the server 150, together with other<br>
command/unique key sets. The queued commands are then scanned to ascertain whether later-<br>
issued commands (i.e., those near the back of the queue) supercede earlier-issued commands<br>
(i.e., those closer to the front of the queue). If the earlier-issued commands are superceded, then<br>
the server agent 160 removes them from the queue and thus avoids having to transmit<br>
unnecessary data to the client agent 118.<br>
[0030] For example, a series of commands to display the next page of data issued in<br>
quick succession need not be displayed individually at the client 110. All that need be displayed<br>
is the last display page issued, since this last page of data will overwrite all previous pages of<br>
data. By removing the unnecessary commands and unique keys corresponding to the earlier<br>
pages from the server's queue, the server agent 160 substantially reduces the amount of data that<br>
must be processed and transmitted.<br>
[0031) In one illustrative embodiment, only unnecessary commands and related data<br>
pertaining to opaque operations are removed from the server's queue. For example, if a<br>
previously-queued command involving the creation of a rectangular region having coordinates<br>
10,10,50,50 is followed by a more recently-queued command involving the creation of a<br>
larger/covering rectangular region having coordinates 0,0,100,100, then the previously-queued<br>
command and related data is deemed unnecessary and is removed from the queue.<br>
[0032| Table 1 below lists an exemplary set of protocol command"; provided in one<br>
embodiment of the invention.<br>
[0033] In one embodiment, the protocol commands and associated graphical data are<br>
configured to maximize the repetition of information in the protocol packet stream created by the<br>
protocol driver. In one aspect of the invention, the graphical data is first encoded (step 204) prior<br>
to subjecting the encoded graphical data and/or protocol commands to a compression algorithm<br>
(step 206) that takes advantage of the repetitive nature of the protocol stream (e.g., a Lempel-Ziv<br>
compression protocol may be used). In one embodiment and upon the first instance of the<br>
graphical data in the client-server session, an indicia of the graphical data is transmitted together<br>
with the corresponding encoded data in the protocol stream so as to reduce the amount of data<br>
transferred via the network 140 for future instances of the graphical data occurring during the<br>
same client-server session. The compressed data is subsequently bundled into the transport<br>
protocol packet and transmitted to the client node 110 (step 208) for decompression and<br>
interpretation.<br>
[0034] hi one illustrative embodiment, the application program 158 executes a GDI<br>
command that instructs the server's operating system 156 to draw a bitmap. The server agent<br>
160 intercepts this GDI command (step 202) and issues a BITBLT command to the client agent<br>
118, which instructs the client agent 118 to display the application program's output data on the<br>
client's dispjay 128. Prior to issuing the BITBLT command, the server agent 160 encodes the<br>
output data (step 204) and includes the encoded data, together with the BITBLT command in the<br>
compressed protocol packet stream transmitted to the client agent 118. In one embodiment, the<br>
data describing the bitmap 410 (FIG. 4) is encoded and compressed (steps 204 and 206) to take<br>
advantage of some of the redundancies present in the bitmap 410. For example, the bitmap 410<br>
may be such that successive raster lines are redundant or adjacent pixels are redundant.<br>
[0035] In addition to encoding bitmaps or other discrete graphical data elements based<br>
on their internal data redundancies, the invention also incorporates caching techniques that<br>
further improve the encoding and compression of graphical data that has been previously<br>
encountered during a particular client-server session. For example, when a particular bitmap is<br>
first encountered during a client-server session it is encoded as described above. For subsequent<br>
transmissions of the bitmap during the same client-server session, indicia of the bitmap can be<br>
transmitted rather than the relatively larger, encoded bitmap. In one embodiment, the indicia<br>
correspond to a location within the client's volatile memory that contains the previously<br>
transmitted bitmap.<br>
[0036] More particularly and with reference to Figs. 3 and 4, the server agent 160<br>
generates the unique key 412 (step 330), as described above, and associates the unique key 412<br>
with the graphical data (e.g., bitmap 410). This association essentially defines the bitmap 410<br>
and its related data as a graphical object, which is subsequently registered, together with its<br>
unique key 412 and encoded data 414 (step 340), in a data structure 411 (e.g., a table) stored in<br>
the server's volatile memory 154 (e.g. the server's cache subsystem). In other embodiments, the<br>
bitmap-related data may be written into the server's persistent storage 162.<br>
[0037] Assuming that the protocol command (e.g., BITBLT) and associated graphical<br>
data are not superceded by later-issued commands (as described previously), the server agent 160<br>
dequeues (step 360) the BITBLT command and the unique key 412 from the queue and searches<br>
the table 411 stored in the server's volatile memory 154 to determine if the unique key 412 had<br>
been previously stored therein. If the unique key 412 is located within the table 411, then the<br>
server agent 160 determines that the encoded data 414 has been previously processed by the<br>
server 150. The server agent 160 then searches the table 411 for an index or handle 416<br>
associated with the encoded bitmap 414. If the index 416 is located, then the server agent 160<br>
determines that the encoded bitmap 414 has not only been processed by the server 150, but that it<br>
has also been previously transmitted to the client agent 118. If the index 416 is not located<br>
within the table 411, then the server agent 160 determines that the encoded bitmap 414 has not<br>
been previously transmitted.<br>
[0038] In one embodiment, the index 416 identifies a particular location within the<br>
client's volatile memory 114, which stores the previously-transmitted encoded bitmap 414. In<br>
one embodiment, the client agent 118 provides a snapshot of its available volatile memory 114 to<br>
the server agent 160 upon initiating a client-server session with the server agent 160. Once the<br>
session is established, the server agent 160 thereafter controls the allocation of the client's<br>
available volatile memory 114. In this manner, the server agent 160 is able to allocate the<br>
client's volatile memory 114 to the encoded bitmap 414 and to maintain the index 416 as a<br>
pointer or reference to the allocated memory and as an identifier of the previously-transmitted<br>
encoded bitmap 414.<br>
[0039] If the index 416 is located within the server's table 411, the server agent 160<br>
obtains the index 416 (step 370), compresses the index 416 together with the related protocol<br>
command (step 380), and transmits the compressed data in a packet directed to the client agent<br>
118 via the network 140. In one embodiment, the index 416 is shorter in length (e.g., 16 bits)<br>
than the unique key 412 (e.g., 64 bits), and consequently consumes less bandwidth when<br>
transmitted.. Upon receipt and decompression of the compressed packet, the client agent 118<br>
accesses the particular memory location in the client's volatile memory 114 that is specified by<br>
the index 416 in order to obtain the appropriate graphical data 410. The client agent 118<br>
subsequently manipulates the obtained graphical data 410 in accordance with the command<br>
which accompanied the index 416 in the compressed packet. In this manner, the invention<br>
avoids having to retransmit relatively large bitmap or other graphical data that have been<br>
previously encountered during a particular client-server session.<br>
[0040] If the index 416 is not located within the server's table 411 (and thus has not<br>
been previously transmitted to the client agent 118), the server agent 160 allocates a portion of<br>
the client's volatile memory 114 for the bitmap 410 and forms the index 416 that identifies the<br>
memory location. The server agent 160 then stores the encoded bitmap 414 (corresponding to<br>
the bitmap 410), the newly-formed index 416, and the unique key 412 associated with the<br>
encoded bitmap 414 in the server's table 411. The server agent 160 subsequently compresses the<br>
encoded bitmap 414, the index 416, and related command and transmits the compressed data in a<br>
packet directed to the client agent 118. Upon receipt and decompression, the client agent 118<br>
decodes the encoded data 414 and stores the resulting bitmap 410 in the memory location<br>
identified by the index 416 and manipulates the resulting bitmap 410 in accordance with the<br>
accompanying command. Alternatively, the client agent 118 stores the encoded data 414 in the<br>
memory location identified by the index 416 and only decodes the encoded data 414 when<br>
necessary to further manipulate the resulting bitmap 410. In this manner, client memory is more<br>
efficiently used.<br>
[0041] Although the invention has heretofore been described with the server agent 160<br>
controlling the client's memory allocation and index formation, it is also possible that the client<br>
agent 118 perform these functions. For example, when a bitmap is first encountered during a<br>
client-server session and is encoded, compressed, and transmitted to the client agent 118 (with<br>
the accompanying command, but without the index 416), the client agent 118 can determine the<br>
particular location within its volatile memory 114 to store the bitmap 410. In this embodiment,<br>
the client agent 118 forms an index (not shown) that uniquely identifies the encoded bitmap and<br>
its corresponding memory location and transmits the index to the server agent 160, which stores<br>
the index in the appropriate location in the server's table 411.<br>
[0042] Continuing with the embodiment in which the server agent 160 controls the<br>
allocation of the client's volatile memory 114, the client agent 118 maintains a circular queue<br>
421 of all indexes specified by the server agent 160 in accordance with queue maintenance<br>
instructions also received therefrom. For example, the server agent 160 can direct the client<br>
agent 118 to disassociate a predetermined block of indexes 417 (e.g., corresponding to 128K of<br>
memory) from their respective graphical data in order to accommodate newly-encountered<br>
graphical objects when the client's volatile memory 114 is otherwise fully subscribed.<br>
Consequently, a subsequent new graphical object acquires a previously-used index.<br>
[0043] The server agent 160 also determines, according to predetermined criteria,<br>
whether to purge or save each graphical object affected by the reassignment of the indexes. The<br>
server agent 160 communicates this decision to the client agent 118. For example, if the server<br>
agent 160 is reassigning indexes 0,1,2, and 3, and determines that the graphical objects<br>
associated with handles 0 and 2 are to be deleted or moved into the client's persistent storage 120<br>
and the objects associated with handles 1 and 3 are to be saved, the server agent 160 thus<br>
instructs the client agent 118 to delete (or move) 0 and 2, and save 1 and 3. The client agent 118<br>
then moves the index of each saved object to the tail of the circular queue. At least one index<br>
remains available at the queue tail for assignment to the moved object; that is, in one<br>
embodiment the head and tail of the queue do not point to the same index in the circular queue.<br>
Consequently, a moved object is both stored in a different physical memory location and<br>
associated with a different index.<br>
[0044] The maintenance actions performed on the client's circular queue 421 will<br>
typically become more frequent as the client-server session continues and the limited volatile<br>
memory 114 of the client 110 becomes full of previously-transmitted bitmaps 410 or other<br>
graphical objects. Accordingly, the number of previously-transmitted graphical objects 422 that<br>
are moved into the client's persistent storage 120 from volatile memory 114 increases. The<br>
present invention further enhances the caching technique described above to search for indicia<br>
(see "fuzzy key" below) of previously-transmitted graphical objects 422 that may be stored in the<br>
client's persistent storage 120 when an index to that graphical object 422 is not found in the<br>
server's table 411. If such indicia is found, then there is a strong likelihood that the previously-<br>
transmitted graphical object 422 is still locally resident and accessible to the client agent 118 and<br>
that the graphical object 422 may not therefore need to be retransmitted from the server agent<br>
150 to the client agent 110. It is important to note that locating such indicia provides a strong<br>
likelihood, but not a certainly, that the graphical object 422 is locally resident, because other<br>
programs or client agents which may share the same persistent storage 120 may have deleted the<br>
graphical object 422 from persistent storage 120 (e.g., to make room in the persistent storage for<br>
a new object).<br>
[0045] More particularly and with reference to Figs. 4 and 5, if the server agent 160 is<br>
unable to locate an index for a particular bitmap 422 in the server's index table 411, the server<br>
agent 118 searches a second table 418 (hereinafter "fuzzy database") for an entry 419 (hereinafter<br>
"fuzzy key") associated with the bitmap 422 (step 520). In one embodiment, each fuzzy key 419<br>
is a combination of the unique key 412 in the server's table 411 and the length/size of the<br>
associated bitmap 422. The fuzzy key can be formed, for example, via an XOR (exclusive OR)<br>
of both 32-bit CRCs used to compute the 64-bit unique key 412 in the server's table 411 and the<br>
length of the bitmap 422 associated with the unique key 412. The fuzzy database 418 essentially<br>
provides an initial prediction as to whether the persistent storage 120 of the client 110 has a copy<br>
of the bitmap 422 stored therein. If the fuzzy database 418 does not contain the fuzzy key 419<br>
associated with the bitmap 422, then the client's persistent storage 120 probably does not have a<br>
stored copy of the bitmap 422 and the server agent 160 will, therefore, need to transmit an<br>
encoded version of the bitmap 422 to the client agent 118, as previously described. On the other<br>
hand, if the fuzzy database 418 contains the fuzzy key 419 for the bitmap 422, then there is a<br>
strong possibility that the bitmap 422 is stored in the client's persistent storage 120.<br>
[0046] In more detail, when the server agent 160 does not find a fuzzy key 419 in the<br>
fuzzy database 418 that is associated with the bitmap 422, the server agent 160 sends an encoded,<br>
bitmap (corresponding to the bitmap 422) to the client agent 118 with a command that requests<br>
the client agent 118 to store the bitmap 422 (or the corresponding encoded bitmap) in the volatile<br>
memory 114 (step 530). Also and as described above, the server agent 160 adds the fuzzy key<br>
419 associated with the bitmap 422 to the fuzzy database 418 (step 540). Note that the order of<br>
steps 530 and 540 can be reversed, such that the fuzzy database 418 is updated prior to the<br>
transmission of the command and the encoded version of the bitmap 422. The client agent 118<br>
subsequently copies the bitmap 422 to a particular location within the client's volatile memory<br>
114 as specified by the server agent 160 (step 560).<br>
[0047] In one embodiment, the server agent 160 does not wait for an acknowledgement<br>
from the client agent 118 that the encoded bitmap associated with the bitmap 422 has been<br>
successfully received and processed. Rather, the server agent 160 assumes that the encoded<br>
bitmap has been properly processed and continues to stream protocol commands without<br>
awaiting the return of an acknowledgement message from the client agent 118. The server agent<br>
160 does, however, track the number of protocol commands issued since the last<br>
acknowledgement read. The server agent 160 blocks further transmission of protocol commands<br>
if the number reaches a predefined threshold. The threshold enables the client agent 118 to<br>
establish an upper bound on the amount of memory needed to queue incoming protocol<br>
commands during recovery mode operation, as described in more detail below.<br>
[0048] When a fuzzy key 419 is found in the fuzzy database 420, the server agent 160<br>
sends a command to the client 110 directing the client agent 118 to copy the bitmap 422<br>
associated with the fuzzy key 419 from the client's persistent storage 120 into the client's volatile<br>
memory 114 (step 550). This command is accompanied not only by the fuzzy key 419 which<br>
uniquely identifies the bitmap 422 of interest, but also by the associated index generated by the<br>
server agent 160 (as previously described) in order to identify the specific location within the<br>
client's volatile memory 114 that will receive and store the copied bitmap 422. By copying the<br>
bitmap 422 into volatile memory 114 rather than just maintaining its location in persistent<br>
storage 120, the invention can rapidly respond to several requests to draw the bitmap 422 that are<br>
received in quick succession or without much intervening cache activity by copying the bitmap<br>
422 on the occurrence of the first request.<br>
[0049] If the bitmap 422 is not currently stored in the persistent storage 120 despite the<br>
presence of the corresponding fuzzy key 419 in the fuzzy database 418, then the client agent 118<br>
returns a message to the server agent 160 (in response to the "CACHE_READ_DISK_OBJECr'<br>
command previously issued by the server agent 160) indicating that the bitmap 422 is missing.<br>
Upon receiving this message, the server agent 160 retransmits the encoded bitmap data<br>
associated with the bitmap 422 to the client agent 118 (step 530). Note that the server agent 160<br>
maintains a sequential list of all such CACHE_READ_DISK_OBJECT commands sent to the<br>
client agent 118 for which the server agent 160 has not yet received an acknowledgement so that<br>
the server agent 160 can properly associate a received acknowledgement with a particular bitmap<br>
422 (so as to properly identify the encoded bitmap that needs to be transmitted).<br>
[0050] Meanwhile, the client agent 118 enters a recovery mode in which the client agent<br>
118 continues to read the incoming protocol stream, but does not process it. Instead, the client<br>
agent 118 builds a queue for receiving the stream of commands that continue to flow from the<br>
server 150 subsequent to the command that failed to find the bitmap 422 in persistent storage<br>
120. The client agent 118 continues to store these commands in this queue, in FIFO (first in, first<br>
out) fashion, until the encoded bitmap is received and successfully decoded to produce the<br>
bitmap 422. To recognize the missing bitmap 422 in the incoming stream of commands, the<br>
client agent 118 looks for graphical data accompanying a recovery marker in the protocol stream.<br>
In one embodiment, the recovery marker is a particular pseudo-random number that is XORed<br>
with the unique key of the bitmap 422 (i.e., the 64-bit CRC and 32-bit length). The server agent<br>
160 creates the recovery marker upon receiving a no-acknowledgement message from the client<br>
agent 118. When the bitmap 422 arrives, the client agent 118 stores it in its volatile memory 114<br>
(step 560) (i.e., where the bitmap 422 would have been stored had the object been initially<br>
present in the persistent storage 120) and begins to process the commands in the queue. After<br>
processing all of the commands in the queue, the client agent 118 resumes processing the<br>
incoming stream of protocol commands coming from the server 150 over'the network 140.<br>
[0051] An advantage to the above-described recovery process is that it avoids the time<br>
delay penalty incurred by those cache systems that flush the commands in the pipeline upon the<br>
occurrence of a cache miss. Also, the recovery process causes no disruption to the stream of<br>
protocol commands nor any increase in the traffic on the channel by more than a few bytes<br>
beyond what the server 150 would have sent to the client 110 had the server agent 160 initially<br>
known that the bitmap 422 was not in the persistent storage 120.<br>
[0052] In one embodiment, the present invention facilitates the location of the bitmap<br>
422 in the client's persistent storage 120 by storing the bitmap 422 in a file whose file name is<br>
formed by encoding the fuzzy key 419 along with least-recently-used and/or least-frequently-<br>
used information associated with the bitmap 422. In this manner, the file name itself provides<br>
the information desired and thus avoids having to open and read the file. The encoding of the<br>
fuzzy key 419 as part of the bitmap's file name also enables the client agent 118 to rapidly<br>
extract the fiizzy key information from the file name and send it to the server agent 160 during an<br>
initial boot of the client 110 or at the start of the client/server session. The extracted fuzzy keys<br>
can be transmitted to the server 150 in an order that, for example, is based on the least-recently-<br>
used and/or least-frequently-used information that also forms a part of the file name.<br>
[0053] In one embodiment, fuzzy keys 419 are added to and deleted from the fuzzy<br>
database 418 in one of three ways. First, at the start-up of the client agent 118 or upon<br>
establishing a client-server session with the server agent 160, the client agent 118 sends<br>
commands to the server agent 160 to add a fuzzy key 419 to the fuzzy database 418 for each<br>
appropriate bitmap 422 in the client's persistent storage 120 (the fuzzy keys accompany the client<br>
agent's commands). The client agent 118 can maintain a send list that specifies an order (e.g.,<br>
based on most-recently-used or most-frequently-used information determined from prior client-<br>
server sessions) for sending fuzzy keys at startup to the server 150. The send list can be formed<br>
by the client agent 118 upon reading the directory of its persistent storage 120 and keeping a<br>
representation of the directory in volatile memory 114. In one aspect of the invention, the client<br>
agent 118 extracts fuzzy key information from the file name of the file, which contains the<br>
bitmap 422, when preparing the representation of the directory. Second, at predetermined<br>
polling intervals, the client agent 118 polls its persistent storage 120 to determine those bitmaps<br>
that are currently in its persistent storage 120 (e.g., by searching for file names containing a fuzzy<br>
key-like structure) and then sends add and/or delete commands to the server agent 160, as needed<br>
to update the server's fuzzy database 418. Third, when the server agent 160 sends a command to<br>
the client agent 118 to write a bitmap into the client's persistent storage 120, the server agent 160<br>
generates and stores a corresponding fuzzy key 419 in the fuzzy database 418.<br>
[0054] Transmission of bitmap data from the server 150 to the client 110 can take a<br>
relatively lengthy period of time, particularly when the network connection between the client<br>
and server is relatively slow. In one embodiment, the invention adapts the server's operation to<br>
changing network conditions by determining the relative speed of the network 140. For example,<br>
by dynamically assessing the bandwidth of the network 140, the server agent 160 can modify the<br>
encoding and compression techniques used to process bitmap data in order to reduce bandwidth<br>
requirements when transmitting over a slow network. The invention processes columns of<br>
bitmap data from left to right and primes the client cache 114 accordingly. As the encoded<br>
bitmap 414 is being transmitted, the transmission time can be monitored to determine the<br>
performance of the network 140. If the transmission time exceeds a threshold value, the client<br>
agent 118 can draw whatever bitmap data has already been stored in its cache 114 and display the<br>
remaining portions of the bitmap data either in real-time as it is received in the cache 114 or at<br>
predetermined intervals. In this manner, a user of the client will recognize that the client 110 is<br>
still operating on the bitmap data and be able to discern that the client 110 is not in a hung or<br>
failed/error condition. By approximating the effective network bandwidth to the client 110 and<br>
adapting the behavior of the server 150 accordingly, the server agent 160 can, for example,<br>
instruct the client agent 118 to use a whole bitmap versus using a whole column mode of display<br>
for a particular bitmap.<br>
[0055] More particularly, the server agent 160 sends a Start_StopWatch command<br>
followed by encoded bitmap data 414 and a Stop_StopWatch command to the client agent 118.<br>
The client agent 118 responds to the Start_StopWatch command by reading the current time tick<br>
and writing it into a first array element. After the encoded bitmap 414 is received, the client<br>
agent 118 responds to the Stop_Stop Watch command by reading the current time tick and<br>
writing it into a second array element. Comparing the difference in time ticks between the<br>
Start_Stop Watch and Stop_Stop Watch commands provides an estimate of the time that was<br>
expended to receive the encoded bitmap data. The resulting time difference is then transmitted<br>
back to the server agent 160. This procedure can be repeated to compute a smoothed, moving<br>
average from which a reasonable estimate of the effective throughput of encoded bitmap data can<br>
be determined. The invention uses the throughput estimate in view of the size of the encoded<br>
data for a particular bitmap to decide whether to use whole bitmap mode (e.g., if it is likely to<br>
take less than 5 seconds) or use progressive whole columns (e.g., if it is likely to take more than<br>
5 seconds). Note that although this procedure does not result in a 100% accurate throughput<br>
estimate, it does provide sufficient granularity to detect fast or slow network connections from<br>
which different display modes can be determined. A similar technique can be used to time large<br>
screen-to-screen copies at the client end and to build up a similar moving average estimate of the<br>
client's performance during these operations, which can then be used to slow a producer thread<br>
oh the server 150 and prevent an overrun at the source when the server 150 generates data faster<br>
than the client 110 can handle it.<br>
[0056] In one embodiment, the invention forms objects that are sufficient in size to<br>
contain the data of a whole cache column. For example, the maximum object size and the size of<br>
the cache can be selected by the server agent 160 upon startup of the client/server session to be a<br>
function of the size of the connection window and its color depth, with larger sizes being<br>
allocated for the larger screens and depths. Further, current techniques for breaking up a bitmap<br>
into columns can result in columns of less than standard width at one or both ends of the bitmap.<br>
If these nonstandard columns are too narrow, then they may not be large enough to be retained in<br>
the client's persistent storage 120 and thus will not be present at the client 110 during subsequent<br>
client/server sessions. The invention avoids this problem by merging the narrow columns with<br>
neighboring columns so that only wide columns are used and thus all parts of a splash screen, for<br>
example, will be contained in the persistent storage 120. In one embodiment, whole columns are<br>
then displayed in two phases. The first phase primes the cache 114 with any missing data and the<br>
second phase draws the column from the cache 114, which may involve using more than one<br>
cached object. The column is therefore displayed on the display screen 128 in an atomic fashion.<br>
As previously discussed, when the network connection is slow, the columns can be displayed<br>
atomically, one-by-one, to reassure the user at the client 110 that the system is still working.<br>
Alternatively, the whole bitmap can be displayed atomically using a similar technique when a<br>
fast network connection is detected.<br>
[0057] The moving average estimate technique discussed above can also be used to<br>
mitigate longstanding overscroll problems in an application that is being executed on a fast<br>
server and that is being displayed on a relatively slow client The overscroll problem occurs, for<br>
example, when a user of the client 110 initiates a plurality of scroll commands such as by<br>
clicking on the scroll bar (or dragging the scrollbar) with a mouse 126 a number of times. As the<br>
scroll commands are sent to the fast server, the server 150 performs the scrolling operations and<br>
returns the associated data faster than the slow client 110 (or slow network 140) displays the<br>
results on its display screen 128. Consequently when the user at the client 110 eventually views<br>
the desired screen position and wants to stop the scrolling (by stopping the mouse clicks and/or<br>
scrollbar dragging), the display will continue to scroll beyond the desired screen position. This<br>
overscroll condition occurs because the fast server 150 has already processed the scroll<br>
commands and has transmitted the appropriate data back to the client 110, but the data has been<br>
queued at the slow client and has not yet been entirely processed.<br>
[0058] The invention mitigates this overscroll problem by reducing its frequency of<br>
occurrence. More particularly, the invention periodically times selected scroll events at the<br>
server 150 (by scrolling the frame buffer) and at the client 110 (via the Stop Watch commands<br>
discussed above) to compute a moving average estimate of their respective speeds. In this<br>
manner, the server agent 160 estimates how long a particular scroll event will take (speed times<br>
the number of pixels involved) to process at the server 150 and how long the client 110 is<br>
expected to take and if the expected processing time at the client 110 is larger than that of the<br>
server 150, the server processing is suspended by the appropriate time differential so as to keep<br>
the client 110 and server 150 substantially in step. This approach results in many fewer<br>
overscrolls due to the time lag between the client 110 and server 150 as compared to the number<br>
of overscrolls occurring when this approach is not implemented.<br>
[0059] In addition to manipulating bitmap data, the present invention can also remote a<br>
text string that is generated on the server 150 to the display 128 of the distant client 110. With<br>
reference to Fig. 6, the server 150 executes the application program 158, which generates a text<br>
string that needs to be remoted to the client 110. The server agent 160 intercepts the commands<br>
sent from the application program 158 to the server operating system 156, which relate to the text<br>
string, and causes a display driver 612 of the server agent 160 to process the text-related<br>
information and to transmit a series of protocol commands 614 to the client agent 118 for<br>
displaying a text string 416 on the client's display 128. For example, the application 158<br>
performs procedure calls that set the text color and the background color (here, "Hello!").<br>
Execution of the TextOut procedure 618 by the application 158 triggers execution of the<br>
DrvTextOut procedure 620 of the display driver 612. As shown, the DrvTextOut procedure 620<br>
defines the clip region, the bounding rectangle, and the text mode (including background and text<br>
color) by executing a sequence of corresponding procedures.<br>
[0060] Execution of such procedures cause the display driver 612 to send the<br>
appropriate data and protocol commands (such as a subset of those provided in Table 1) to the<br>
client agent 118. The protocol commands are received and processed by the client agent 118,<br>
which executes procedures 614 that specify the clip region, the bounding rectangle, the text<br>
mode, and the glyph associated with each text character to be displayed. Note that the protocol<br>
associated with a glyph object encodes not only the glyph bitmap itself, but also its relative<br>
positioning information. The server 150 can also send other protocol commands to the client<br>
agent 118 that direct the client agent 118 to store the associated glyphs in volatile memory 114<br>
and/or in the persistent storage 120, as previously described. The client agent 118 creates a<br>
bitmap corresponding to the size of the bounding rectangle that surrounds the text string and sets<br>
the relative positions of each glyph in its proper position within the bounding rectangle. Once the<br>
last glyph is received and its position set, the client agent 118 instructs the client operating<br>
system 116 to draw/render the bitmap on the display screen 128 of the client 110.<br>
[0061] The present invention also supports several different descriptions of paths (a set<br>
of lines or curves used as part of the description of a line drawing operation or, in the case of a<br>
closed path, to describe a region) including ellipses, beziers, segments, strips, and styles.<br>
Segments refer to line segments that, when combined, form a path. Similarly, segments can be<br>
further parsed into strips, which are portions of the line segment (corresponding to a series of<br>
consecutive pixels) that exhibit the same angle characteristics. The encoding technique used to<br>
represent ships, for example, uses relative location information and quantized angles to<br>
characterize consecutive strips in particular line segments, which not only minimizes the amount<br>
of graphical line data that needs to be encoded but also results in a more repeatable sequence of<br>
data that can be more efficiently compressed. The increase in repeatability is particularly<br>
enhanced when representing strips that form a shape such as a rectangle or circle. The protocol<br>
used for strips also enables the client agent 118 to accurately reproduce a path independently and<br>
without knowledge of the algorithm used by the server agent 160 to convert the path into a<br>
sequence of pixels.<br>
[0062] With reference to the nonlimiting example in Fig. 7A, a path 700 comprises two<br>
line segments 710, 720, which appear to be perfectly linear. However, those skilled in the art<br>
recognize that line segments that are not perfectly horizontal, vertical, or at a 45 degree diagonal<br>
must be approximated by a corresponding series of strips when the path 700 is displayed on a<br>
display screen 128 (Fig. 1). This approximation is necessary, because the individual pixels on<br>
the display screen 128 are surrounded by, at most, eight other pixels that are either perfectly<br>
horizontal, vertical, or at a 45 degree diagonal relative to each other, and thus any line segments<br>
710, 720 that are at a different overall angle, must be approximated by a series of strips.<br>
Accordingly and with reference to the exemplary path 700 of Fig. 7B, segment 710 is comprised<br>
of four strips 712, 714, 716,718 where the individual pixels (depicted by square blocks) of each<br>
strip 712, 714, 716, 718 are organized at 45 degree diagonals relative to each other, and segment<br>
720 is comprised of five strips 722, 724, 726,728, 730 where the individual pixels of each strip<br>
722, 724, 726,728, 730 are organized horizontally relative to each other.<br>
[0063] In one embodiment and with reference to Figs. 7B and 8A, the server agent 160<br>
parses the path 700 into line segments 710,720, each having a particular length and angle (step<br>
810). An array of line segments is then formed to store quantized segment information<br>
(hereinafter referred to as a quantized angle or "QA") for each line segment 710,720 (step 820).<br>
With reference also to Fig. 8B, rather than computing the absolute angle associated with a<br>
particular segment 710,720, the server agent 160 instead determines in which of the sixteen<br>
quantized angles 880 the absolute angle lies. This quantization technique determines in which<br>
sixteenth of the circumference the end point lies for a line segment starting at the center of a<br>
circle (a radius). This information can be expressed as the unsigned delta from the last segment<br>
specified in this context (mod 16, initialized to 0). This technique results in a more repeatable<br>
sequence (than if the absolute angle was used), particularly when the segments form a shape such<br>
as a rectangle or a circle.<br>
[0064] The server agent 160 then parses each line segment 710,720 into strips (712,<br>
714, 716,718; 722, 724, 726, 728, 730 respectively) (step 830). The length of each strip of a<br>
particular segment 710,720 is subsequently stored in a strip length array for further processing<br>
(step 840). In one embodiment, the Windows NT algorithm, bLine, is used to break up the path<br>
700 into an array of strips. The NT algorithm determines the quantized angle of each strip and<br>
segment so that there is no ambiguity associated with segments or strips that lie on a boundary<br>
between quantized angle regions. The NT algorithm vertically flips a line going up so that the<br>
line is always going down (the y value keeps increasing) and sets the flag, FL_FLIP_V.<br>
Similarly, a line going to the left is flipped horizontally so that it always goes to the right (the x<br>
value keeps increasing) and sets the flag, FL_FLIP_H. As a result, the array of strips output by<br>
this algorithm fall into a single quadrant. In this particular embodiment, the server agent 160<br>
undoes the flipping operation of the NT algorithm so that the array of strips are flipped back to<br>
their previous/original quantized angles to ensure that the endpoint of a previous strip and the<br>
starting point of the next consecutive strip coincide so as to avoid having to send the starting<br>
coordinate of the next consecutive strip.<br>
[0065] The server agent 160 then encodes the beginning coordinate of the path 700<br>
together with the quantized angle data in the line segment array and pixel length data in the strip<br>
length array to form a protocol stream (step 850). The encoded data is then subjected to a<br>
compression algorithm to take advantage of the data redundancies in the protocol stream (step<br>
860) and the compressed graphical line data is subsequently transmitted to the client agent 118<br>
for decoding and further processing (step 870).<br>
[0066] With reference to the exemplary illustration in Fig. 9 and the quantized angle<br>
information of Fig. 10, the line segment 710 comprises four strips 712, 714, 716,718 positioned<br>
within quantized angle 1. The beginning coordinate of the path 700, which is transmitted from<br>
the server agent 160 to the client agent 118 as part of the compressed graphical line data,<br>
corresponds to the first pixel in strip 712 (positioned at the origin of 880). The graphical line<br>
data further includes the pixel length of each strip 712, 714,716, 718 in the segment 710. Since<br>
the segment 710 does not correspond to a perfectly horizontal, vertical, or 45 degree diagonal,<br>
each consecutive strip 714, 716, and 718 in segment 710 is adjusted by a particular delta value as<br>
indicated in Fig. 10 in order to properly approximate the overall angle of the segment 710. In the<br>
present example, in order to get from the last point in the previous strip 712 to the beginning<br>
point in the next consecutive strip 714, the client agent 118 displays strip 714 at substantially the<br>
same x value and at an increasing y value. This process is repeated for each strip in the segment<br>
710 as well as for the strips in segment 720, which are positioned within QA 15.<br>
[0067] Accordingly and in one embodiment, the protocol stream generated by the<br>
present invention when processing strips comprises the starring position of the path, an index (if<br>
any) corresponding to a location in the client's volatile memory 114 (Fig. 1) which may already<br>
store a particular strip transmitted some time earlier in the client-server session, the number of<br>
segments in the path, the quantized angle of each segment (from which the delta values reflected<br>
in Fig. 10 are determined), the length of each strip together with some control information, and<br>
quantized angle delta information that is added to the quantized angle of a first or prior segment<br>
in order to inform the client agent 118 of the quantized angle of subsequent segments. In this<br>
manner, the invention avoids having to send coordinate and absolute angle information for each<br>
strip in the path. Further, the strip processing technique discussed above facilitates the efficient<br>
compression of graphical line data by leveraging the repetitiveness of the data in the<br>
uncompressed protocol stream.<br>
[0068] The present invention can also be applied to bitmaps that are displayed in an on-<br>
screen surface, as well as to bitmaps in an off-screen surface (e.g., that are stored in a video<br>
display adapter's memory and/or in a pre-allocated section of the client's volatile memory 114<br>
that will be operated on by a graphics conversion library). Off-screen surfaces are frequently<br>
formed by applications, such as Microsoft Word, that write bitmaps to the off-screen surface<br>
until the surface is complete, at which time the off-screen surface is displayed on the display<br>
screen 128 of the client 110 in final form as an on-screen surface. Therefore, off-screen surfaces<br>
frequently provide the source for on-screen surfaces.<br>
[0069] In one embodiment and with respect to off-screen surfaces, the client agent 118<br>
informs the server agent 160 as to the amount of local volatile memory 114 available for offscreen<br>
surfaces so that the server agent 160 does not form an off-screen surface larger than the<br>
client's available memory. The server agent 160 subsequently forms an off-screen surface and<br>
transmits it to the client agent 118 with instructions to store the surface in its volatile memory<br>
114. The client agent 118 selects and allocates a particular section of its volatile memory 114 to<br>
the surface and stores the surface therein. Each off-screen surface has a set of associated<br>
attributes, such as an identifier that uniquely identifies the surface, pixel format, dimensions,<br>
drawing attributes, protocol state, etc.<br>
[0070] In one embodiment, in order to efficiently use the client's volatile memory 114,<br>
the server agent 160 can issue commands to the client agent 118, directing that certain operations<br>
be performed to the off-screen surface only when the off-screen surface interacts with the on-<br>
screen surface (e.g., when updating the on-screen surface with bitmap data from the off-screen<br>
surface). If the only interaction between the on-screen surface and the off-screen surface is a<br>
final copy to the screen, then the operations can be targeted to the on-screen surface and thus<br>
reduce the amount of bitmap data that must be transmitted over the network 140. Alternatively,<br>
the source of the on-screen surface can be restricted to either correspond to an off-screen surface<br>
stored remotely at the server 150 or to an off-screen surface stored locally at the client 110.<br>
Typical operations to the off-screen surface that are requested by the server agent 160 include<br>
updating the bitmap in the off-screen surface with updated text, line, or other data.<br>
[0071] In one embodiment and with reference to Fig. 11, the server agent 160 intercepts<br>
calls made to the server operating system 156, which relate to the creation of an off-screen<br>
surface, and the server agent 160 forms a duplicate copy of the surface and stores it, along with<br>
its attributes, in the server's local memory. The server agent 160 then issues a command to the<br>
client agent 118 to form the off-screen surface in the client's volatile memory 114 (step 1102).<br>
The command is accompanied by an encoded representation of the off-screen surface if this is the<br>
first instance of the off-screen surface or by an index or fuzzy key if the off-screen surface has<br>
been previously transmitted during the client-server session (step 1104). The server agent 160<br>
instructs the client agent 118 to incorporate the graphical data identified by the index/fuzzy key<br>
indicia or encoded surface into the client's off-screen surface (step 1106). The client agent 118<br>
responds to.the server agent's instructions by copying the identified surface/bitmap to the client's<br>
off-screen surface (step 1108). If a BITBLT command issued by the server agent 160 fails, for<br>
example, to form a bitmap in the client's off-screen surface, such as when a memory allocation<br>
error occurs, the client agent 118 sends a C2S_OSS_Error command to the server agent 160<br>
indicating the failed condition (step 1110). In response to the error condition, the server agent<br>
160 uses its local copy of the off-screen surface as the source for updating the client's off-screen<br>
surface. The client agent 118 uses the information received from the server's local copy to<br>
update the off-screen surface on the client 110 and to correct any corrupted/dirty regions of the<br>
off-screen surface. Alternatively, when an error condition, is encountered, the server agent 160<br>
trangmits its locall/duplicate copy of the off-screen surface (step 1112) to fee client agent 118 and<br>
instructs the client agent 118 to use the duplicate surface as the source for updating the client's<br>
on-screen surface and to discard the corrupted off-screen srafeee at the client (step 1114).<br>
[0072] Although the present invention has been described-with reference to specific<br>
details, it is not intended that such details should be regarded as limitations upon the scope of the<br>
invention, except as and in the extent that they are included in the accompanying claims<br>
WE CLAIM :<br>
1. A method of efficiently reducing the amount of graphical data transmitted from a server (150) to<br>
a client (110) via a communications network (140), said method comprising the steps of:<br>
separating (830) a path into a plurality of strips;<br>
determining (820) a quantized angle associated with the absolute angle for each of the plurality<br>
of strips;<br>
forming a protocol stream at the server (150), the protocol stream having a beginning coordinate<br>
of the path and the strip length and an indicia of the quantized angle of each of the plurality of strips ;<br>
and<br>
transmitting (870) the protocol stream from the server (150) to the client (110) via the<br>
communications network (140);<br>
characterised in that each of the plurality of strips having a beginning and an endpoint<br>
coordinate defined within a coordinate system, a strip length and an absolute angle associated<br>
therewith, the coordinate system corresponding to a region of a display surface associated with the<br>
client (110).<br>
2. A method as claimed in claim 1, which involves the step of:<br>
compressing (860) the beginning coordinate of the path and the strip length and the indicia of<br>
the quantized angle of each of the plurality of strips prior to transmitting the protocol stream to the<br>
client (110).<br>
3. A method as claimed in claim 1 or claim 2, wherein the protocol stream comprises an indicia<br>
associated with at least one of the plurality of strips, the indicia corresponding to an index identifying a<br>
location of the at least one of the plurality of strips within a cache memory coupled to the client (110).<br>
4. A method as claimed in claim 1 or claim 2, wherein the protocol stream comprises an indicia<br>
associated with at least one of the plurality of strips, the indicia corresponding to a fuzzy key<br>
identifying a location of the at least one of the plurality of strips within a persistent storage memory<br>
coupled to the client (110).<br>
5. A method as claimed in any one of the preceding claims, wherein the indicia of the qeantized<br>
angle corresponds to a quantized angle delta<br>
6. The method as claimed in claim 1, which involves the steps of:<br>
quantizing the coordinate system into a plurality of quantized angles ;<br>
determining the endpoint coordinate of a first one of the plurality of strips ;<br>
normalizing the endpoint coordinate of the first strip to correspond to the origin of the<br>
coordinate system;<br>
associating the endpoint coordinate of the first strip to a beginning coordinate of a second one of<br>
the plurality of strips ;<br>
selecting one of the plurality of quantized angles of the coordinate system, the selected<br>
quantized angle corresponding to an approximate angle of the second strip; and<br>
transmitting a difference between the endpoint coordinates of the first and second strips and an<br>
indication of the quantized angle to the client (110).<br>
7. A system for efficiently reducing the amount of graphical data transmitted from a server (150)<br>
to a client (110) via a communications network (140), said system comprising:<br>
a server agent (160) operating on the server (150) and coupled to the client (110) via the<br>
communications network (140), wherein the server agent (160) is adapted to<br>
a) separate (830) a path into a plurality of strips;<br>
b) determine (820) a quantized angle associated with the absolute angle for each of the plurality<br>
of strips;<br>
c) form (850) a protocol stream at the server (150), said protocol stream having a beginning<br>
coordinate of the path and the strip length and an indicia of the quantized angle of each of the plurality<br>
of strips; and<br>
d) transmit (870) the protocol stream from the server (150) to the client (110) via the<br>
communications network (140);<br>
wherein each of the plurality of strips having a beginning and an endpoint coordinate defined<br>
within a coordinate system, a strip length and an absolute angle associated therewith, the coordinate<br>
system corresponding to a region of a display surface associated with the client (110).<br>
8. A system as claimed in claim 7 wherein the server agent (160) is adapted to compress (860)-the<br>
beginning coordinate of the path and the strip length and the indicia of the quantized angle of each of<br>
the plurality of strips prior to transmitting the protocol stream to the client (110).<br>
9. A system as claimed in claim 7 or claim 8, wherein the server agent (160) is adapted to form a<br>
protocol stream having an indicia associated witfi at least one of the plurality of strips, said indicia<br>
corresponding to an index identifying a location of the at least one of the plurality of strips within a<br>
cache memory coupled to the client (110).<br>
10. A system as claimed in claim 7 or claim 8, wherein the server agent (160) is adapted to form a<br>
protocol stream having an indicia associated with at least one of the plurality of strips, said indicia<br>
corresponding to a fuzzy key identifying a location of the at least one of the plurality of strips within a<br>
persistent storage memory coupled to the client (110).<br>
11. A system as claimed in any one of claims 7 to 10, wherein the server agent (160) is adapted to<br>
form a protocol stream in which the indicia of the quantized angle corresponds to a quantized angle<br>
delta.<br>
12. The system as claimed in claim 7, wherein the server agent (160) is adapted to quantize the<br>
coordinate system into a plurality of quantized angles.<br>
13. The system as claimed in claim 7 wherein the server agent (160) is adapted to determine the<br>
endpoint coordinate of a first one of the plurality of strips.<br>
14. The system as claimed in claim 7 wherein the server agent (160) is adapted to normalize the<br>
endpoint coordinate of the first strip to correspond to the origin of the coordinate system.<br>
15. The system as claimed in claim 7 wherein the server agent (160) is adapted to associate the<br>
endpoint coordinate of the first strip to a beginning coordinate of a second one of the plurality of strips.<br>
16. The system as claimed in claim 7 wherein the server agent (160) is adapted to select one of the<br>
plurality of quantized angles of the coordinate system, the selected quantized angle corresponding to an<br>
approximate angle of the second strip.<br>
17. The system as claimed in claim 7 wherein the server agent (160) is adapted to transmit a<br>
difference between the endpoint coordinates of the first and second strips and an indication of the<br>
quantized angle to the client (110).<br>
The present invention relates to a method of efficiently reducing the amount of graphical<br>
data transmitted from a server (150) to a client (110) via a communications network (140), said<br>
method comprising the steps of separating (830) a path into a plurality of strips; determining<br>
(820) a quantized angle associated with the absolute angle for each of the plurality of strips;<br>
forming a protocol stream at the server (150), the protocol stream having a beginning<br>
coordinate of the path and the strip length and an indicia of the quantized angle of each of the<br>
plurality of strips; and transmitting (870) the protocol stream from the server (150) to the client<br>
(110) via the communications network (140); characterised in that each of the plurality of strips<br>
having a beginning and an endpoint coordinate defined within a coordinate system, a strip<br>
length and an absolute angle associated therewith, the coordinate system corresponding to a<br>
region of a display surface associated with the client (110). A system for carrying out the<br>
method is also disclosed.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDItMTQwNS1LT0wtKDMwLTA0LTIwMTIpLUZPUk0tMjcucGRm" target="_blank" style="word-wrap:break-word;">IN-PCT-2002-1405-KOL-(30-04-2012)-FORM-27.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1hc3NpZ25tZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1jb3JyZXNwb25kZW5jZS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1leGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1mb3JtIDEucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1mb3JtIDE4LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1mb3JtIDMucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1mb3JtIDUucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1ncGEucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1yZXBseSB0byBleGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC1zcGVjaWZpY2F0aW9uLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-specification.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTQwNS1rb2wtZ3JhbnRlZC10cmFuc2xhdGVkIGNvcHkgb2YgcHJpb3JpdHkgZG9jdW1lbnQucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1405-kol-granted-translated copy of priority document.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="225476-floor-covering.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="225478-a-base-station-apparatus-and-a-method-for-radio-communications-using-an-orthogonal-frequency-division-multiplexing-system.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>225477</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2002/1405/KOL</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>46/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>14-Nov-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>12-Nov-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>14-Nov-2002</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>CITRIX SYSTEMS, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>851 W. CYPRESS CREEK ROAD, FORT LAUDERDALE, FL</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>COLEMAN PAUL</td>
											<td>1070 SW 46TH AVENUE, POMPANO BEACH, FL 33326</td>
										</tr>
										<tr>
											<td>2</td>
											<td>YANG RUIGUO</td>
											<td>6844 PALMETTO CIR S #101, BOCA RATON, FL 33433</td>
										</tr>
										<tr>
											<td>3</td>
											<td>COLLINS HENRY</td>
											<td>6 WESTOVER ROAD, HIGH WYCOMBE, BUCKS HP13 5HY</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04L 29/06</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US01/17323</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2001-05-29</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/225,217</td>
									<td>2000-08-14</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/207,532</td>
									<td>2000-05-26</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/225477-a-method-of-efficiently-reducing-the-amount-of-graphical-data-transmitted-from-a-server-to-a-client-via-a-communications-network-and-a-system-therefor by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:57:05 GMT -->
</html>
