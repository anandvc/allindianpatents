<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/218298-a-system-for-processing-a-originator-request-of-a-customer by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:41:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 218298:&#x27;&#x27;A SYSTEM FOR PROCESSING A ORIGINATOR REQUEST OF A CUSTOMER&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&#x27;&#x27;A SYSTEM FOR PROCESSING A ORIGINATOR REQUEST OF A CUSTOMER&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The invention provides a method and system for processing securely an originator request of a customer. This originator request can be sent to at least one first entity. The method for processing the originator request comprises the steps of a) sending from the customer the originator request to the or each first entity; b) connecting the or each first entity to a computation entity; c) adding by the or each first entity, on receipt of the originator request, information concerning the originator request thereby forming a first-modified request; d) sending at least part of the first-modified request to at least the computation entity; e) having received at least part of the first-modified request by the computation entity deriving a computation-entity result from the at least part of the first-modified request; f) sending at least part of the computation-entity result to the or each first entity; g) having received at least part of the computation-entity result by the or each first entity deriving therefrom a first-entity result and forwarding it at least in part; and h) having received at least part of the first-entity result by the customer deriving therefrom a customer result.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>TECHNICAL FIELD<br>
The present invention relates to a method and system for processing a request of a customer. More particularly, the invention relates to cryptographic security of mobile agents.<br>
BACKGROUND OF THE INVENTION<br>
In the increasingly networked world, mobile code is a programming paradigm that becomes more and more important. It provides a flexible way to structure cooperative computation in distributed systems. At present, the Internet is full of mobile code fragments, such as Java applets, which represent only a simple form of mobile code.<br>
Mobile agents are mobile code that acts autonomously on behalf of a user for continuous collecting, filtering, and processing of information. They combine the benefits of the agent paradigm, such as reacting to a changing environment and autonomous operation, with the features of remote code execution; they operate in computer networks and are capable of moving from server to server as necessary to full their goals. Important applications include mobile computing, where bandwidth is limited or users are disconnected, data retrieval from large repositories, and configuration management of software and networks. The vision of mobile agents roaming the Internet may soon become reality as the paradigm is incorporated in large-scale applications.<br>
Mobile code is to be understood as a program that is produced by one entity, called the originator, and is subsequently transferred to a entity, the host, immediately before it is executed by the host. In other words, no manual intervention, such as performing an installation or running a setup routine, is required on behalf of the host; mobile code comes ready to run. Moreover, mobile agents are capable of continued, autonomous operation disconnected from the originator and migrate freely to other hosts during their lifetime. Such agents have also been called itinerant agents. Mobile code is exposed to various security threats: a malicious host may examine the code, try to learn the secrets carried by an agent.<br><br>
nd exploit this knowledge in its interaction with the agent to gain an unfair advantage. A host might also try to manipulate the result of a computation.<br>
There are at least two security problems that arise in the area of mobile code: (1) protecting the host from malicious code and (2) protecting the code from malicious hosts. The first problem has received considerable attention because of the imminent threat of computer viruses and Trojan horses. Current solutions are to run mobile code in a so-called sandbox with fine-grained access control and to apply code signing for exploiting a trust relation with the code producer.<br>
Protecting mobile code was deemed impossible by some mobile code researchers until T. Sander and C. F. Tschudin realized that tools from theoretical cryptography could be useful to execute mobile code in an encrypted form on an untrusted host, as described in their article "Protecting mobile agents against malicious hosts, Mobile Agents and Security" (G. Vigna, ed.), Lecture Notes in Computer Science, vol. 1419, Springer, 1998. Most protocols for so-called secure computation require several rounds of interaction, however, and are not applicable to achieve secrecy for mobile applications and integrity for their outputs. Sander and Tschudin concluded that only functions representable as polynomials can be computed securely in this manner. Subsequent work of Sander et al. extends this to all functions computable by circuits of logarithmic depth, as disclosed by T. Sander, A. Young, and M. Yung in "Non-interactive CryptoComputing for NC'", Proc. 40th DEEE Symposium on Foundations of Computer Science (FOCS), 1999.<br>
A further form of code is active mobile code that performs some immediate action on the host. Thereby often information about the encrypted computation is leaked to the host whereby only the originator shall receive any output.<br>
A basic problem with active mobile code is that a malicious host can observe the output of the computation and simply run the code again with a different input. The only existing defense for active mobile code against a malicious host uses trusted hardware. This has been proposed and entails running mobile code exclusively inside tamperproof hardware, encrypting it as soon as it leaves the trusted environment.<br>
US Patent No. 6,026,374 is related to a system and method using of a trusted third party to provide a description of an information product to potential buyers without disclosing the entire contents of the information products, which might compromise the interests of the seller. The buyer trusts the third party to give an accurate description of the information that is for sale, while the seller trusts the third party not to reveal an excessive amount of the information product's content. The system can include a seller of information products, a buyer of such products, and a trusted third party summarizer, each operating as a node in a communications network, such as the Internet. A disadvantage of this system and method is that the third party has to be a trusted one and that this third party gets information and learns about everything. This could be dangerous if said third party gets cracked. Moreover, several messages are necessary to process the request of the buyer.<br>
SUMMARY AND ADVANTAGES OF THE INVENTION<br>
The invention provides a method and system for processing securely an originator request of a customer, i.e. the request being initiated by the customer. This originator request is sent within a mobile code or agent to at least one first entity. The method for processing the originator request comprises the steps of a) sending from the customer, i.e. form the customer's device, the originator request to the or each first entity; b) connecting the or each first entity to a computation entity; c) adding by the or each first entity, on receipt of the originator request, information concerning the originator request thereby forming a first-modified request; d) sending at least part of the first-modified request to at least the computation entity; e) having received at least part of the first-modified request by the computation entity deriving a computation-entity result from the at least part of the first-modified request; f) sending at least part of the computation-entity result to the or each first entity; g) having received at least part of the computation-entity result by the or each first entity deriving therefrom a first-entity result and forwarding it at least in part; and h) having received at least part of the first-entity result by the customer deriving therefrom a customer result.<br>
It is an advantage that only the customer learns the result of the calculation, whereby other entities or hosts learn nothing at all except results which are designated lo them. The mobile code or agent comprising the originator request is sent around a network to several entities<br>
whereby the code or at least fragments thereof can be securely executed without any additional client hardware at the first entity. Security is obtained through the computation entity that is a generic independent entity. This independent entity can be a computation service that performs an encrypted computation on behalf of the mobile agent, but does not learn anything about the encrypted computation. The independent entity can serve many different applications whereby nothing about its usage is necessary to know before deploying it. Privacy as well as authenticity for the mobile agents can be achieved. Moreover, the computation service itself does not learn anything about the computation, assumed it does not collude with the code originator or the first entity.<br>
The independent entity may be universal rather than bound to a particular service or to an application context. For example, secure computation servers can be set up and operated by independent entities.<br>
The method and system may be based on software and commodity hardware and therefore may be less expensive to build and operate than any solution involving specialized hardware.<br>
A cryptographic operation can be applied to the mobile agent comprising the request or a result. Thus, integrity for the mobile agent can be advantageously guaranteed.<br>
When the originator request is formed by applying an encrypted circuit construction, then the advantage occurs that a secure computation of the request can be achieved and the originator of that request can define how much information an entity shall receive.<br>
The originator request may comprise a function in encrypted form. This is advantageous, because then other entities processing the originator request can not derive useful information therefrom except results which are designated to those entities.<br>
The originator request, the first-modified request, the computation-entity result, and the first-entity result may comprise an encrypted part. This is advantageous, because then sensitive information is protected and is not readable as plaintext.<br>
The originator request may comprise an offer or any other legal instrument. It may also comprises purchase information or customer information, such as the address for delivering or the credit card number for financial transactions.<br>
The first entity comprises a web server offering a service or goods. This service can merely be everything including sale, lease, license, or financing transaction.<br>
The first-entity result may comprise a customer information concerning acceptance of the originator request. This is advantageous, because then the first-entity can deliver its service or goods immediately and initiate the necessary transactions.<br>
The customer result may comprise the first-entity information concerning acceptance of the originator request. The customer therefore knows that its originator request will be fulfilled and no further actions are necessary.<br>
DESCRIPTION OF THE DRAWINGS<br>
Preferred embodiments of the invention are described in detail below, by way of example only, with reference to the following schematic drawings.<br>
FIG. 1	shows an  illustration  of a communication  flow according  to  the  present<br>
invention.<br>
FIG. 2	shows a more detailed illustration of a communication flow.<br>
FIG. 3	shows another illustration of a communication flow.<br>
The drawings are provided for illustrative purpose only and do not necessarily represent practical examples of the present invention to scale.<br>
DESCRIPTION OF THE INVENTION<br>
With general reference to the figures the features of a method and system for processing a request of a customer using cryptographic functions is described in more detail below. When referring to the word customer, it appears obvious that a device, such as a computer or mobile appliance, used by the customer is meant.<br>
A defining element of a mobile code or agent computation is that it proceeds autonomously and independently of the originator of the code. The secure mobile agent computation is modeled in principle as depicted in Fig. 1, whereby the boxes are labeled according to the description below.<br>
There are a code originator O, and / hosts, hereinafter referred to as entities H,	H/, on<br>
which the mobile agent, hereinafter short agent, runs.<br>
Fig. 1 shows a network, such as the Internet, whereby the code originator O is connected to a first entityH/, that is further connected to a second entity f/2 . The second entity H2 is connected to an entity labeled withH,• that further has a connection to an entity labeled withH,+i, whereby several other entities are possible in-between as indicated by the dotted line. The entityH,» is connected to an entity labeled withH, that in the following is connected back to the code originator O. Each of the entitiesH/, H2, ...,H,, Hj+\,H/ is connected to a computing entity T.<br>
The code originator O as well as each entityH/, H2, ...,H/, HJ+\, H/ sends and receives only a single message, that comprises the agent. The message that the code originator O sends to the first entity H, is denoted by m0 and the message that a further entity Ht sends to H^\ by m, for y=l, ..., /-I, and the message that the last entity HI returns to the code originator O is denoted by nil.<br>
Fig. 2 depicts a more detailed illustration of the communication flow as shown in Fig. 1. The code originator O, that here is a customer (9, is connected to the first entity, here labeled with H, that further is connected to the computing entity T. The method for processing an originator request OR, e.g. a price request including a threshold for a product, of the customer O runs as follows. The customer O sends the originator request OR to the first entity H. This<br>
is indicated by the arrow labeled with m0R. The first entity H offers several products to a particular price. The first entity H connects to the computation entity T and adds, on receipt of the originator request OR, information / concerning the originator request OR, e.g. its price willing to accept, thereby forming a first-modified request FMR. This first-modified request FMR is sent to the computation entity T as indicated by the arrow labeled with mFMR. If the computation entity T has received the first-modified request FMR it derives therefrom a computation-entity result CER without learning anything from this computation. Afterwards, the computation-entity result CER is sent back to the first entity H as indicated by the arrow labeled with OTCER. If the first entity H has received the computation-entity result CER it derives therefrom a first-entity result FER and forwards this back to the customer O as indicated by the arrow labeled with mFEK. The customer O is able to derive from the first-entity result FER a customer result CR. This customer result CR provides the information to the customer O whether or not his originator request OR has been fulfilled. The first entity H knows form the first-entity result FER whether or not its offer is acceptable to the customer O. The originator request OR may contain information about the customer O, i.e. address, credit card information, which allows the first entity H to deliver the requested product immediately.<br>
In the embodiment described above, the mobile agent visits several vendor sites and compares offers. The originator request OR does not only be based on price, but can also include other attributes. The originator or customer O wants to maintain the privacy of his preferences, but a shop has an interest to learn the buyer's strategy as well as information about other vendor's offers. For complex offers where the price is determined individually for each customer based on its needs, such as in the insurance market, the vendor wants to keep its method of calculating the price secret. All these requirements can be fulfilled by the described scheme for secure mobile code.<br>
In another embodiment, a shopping agents is traveling around the network and collects offers from several vendors or entities HI, H2, ..., Ht, H:+\,H,, whereby a prior agreement on the data format of the offers is helpful.<br>
Fig. 3 shows another embodiment using the same or like parts as shown in Figs. 1 and 2. The difference is the code originator O sends directly to each entity H,, H?, ..., H, its originator<br>
request OR, whereby the originator request OR can be the same or different to each entityH/,<br>
In a further embodiment an electronic negotiation is described. The electronic negotiation between a buyer and a single vendor can take place using the scheme for secure mobile code that visits a single host or entity H. Typically, the vendor would act as the originator O and download an applet to the buyer's browser (as is already quite common on the Internet). The applet is executed using the help of the computation entity T by the buyer and the offer is displayed to the buyer. The vendor may obtain some information as well, which it would have to spell out clearly in a "privacy statement" accompanying the applet.<br>
Auctions with generalized bidding strategies present an interesting application area for secure mobile agents. Bidding agents can implement a complex strategy being a function of time and other participants' behavior, which gives the bidder more flexibility compared to traditional single-parameter auctions based purely on price. As the value of the lots is interrelated, a bidder is interested to define his bidding behavior as dynamically as possible, for example making the valuation of a lot depend on other winning bids that he observed in the previous rounds. If the bidders can express their strategies as a computable function, then one may construct a circuit to compute the auction function, i.e., the outcome of the auction, with the strategies as the private inputs of all participants. This would require an auction agent that visits each bidder only once. However, in the likely case that the bidders are unable to express their strategies mathematically, each round of the auction could also be performed securely by an auction applet that visits each bidder once and returns to the auctioneer. There it outputs the winning bids or the end of the auction if the bids did not exceed the minimum increment. If the scheme for secure mobile computing is used, then there is no single entity H,, H2, ..., HhH,•+!, Hi that sees all bids (like the auctioneer, its computer system, or its operators). Generalized auctions are common in electricity markets, equities trading, bandwidth auctions, and transportation exchanges, and bidders often have preferences over combination of items.<br>
In the following, implementation details are described.<br><br>
Computation: Let the state of the mobile agent be an element of a set X . Its initial state x0 is determined by O. Let the input byH, be an element of a set Yj and the output toH,- an element of Zj. The agent computation on the entityH, is represented by two functions<br>
(Formula Removed)<br>
that determine the new state x} •• =• gj(xj-\,yj) of the agent and the output Zj ~ hj(xj-t,yj). O obtains the final state ^ = xi e X of the agent. The functions g, and h, are known to all entities HI, ..., HI.<br>
A mobile computing scheme comprises 21 + 2 algorithms A0, At, ..., A,, B\, ..., B,, and D such that for ally = 1, .... / and xo e X, y, e Yj, and with<br>
mo =Ao(xo)<br>
nij=Aj(mj-\,yj) for 7 = 1, ..., /<br>
Zj = Bj(mh\,yj)    fory= 1, ...,/<br>
the following two conditions Correctness and Privacy hold.<br>
Correctness:        £ = gi(xi-\,yi)   and   ij •• = hj(xj-\ , y,)     for; = 1, ...,/ using<br>
Privacy: The inputs, outputs, and the computations of all entities remain hidden from the originator and from all other entities, except for what follows from their outputs. O learns only £ but nothing else about any y, than what follows from x0 and £, and similarly, H, learns only i, but nothing about x0 and y,- for _/"<_ than what follows from z and y .></_>
For simplicity reasons, the above scheme assumes that the order in which the agent visits all entities is fixed. It is extended to allow for the sequence to depend on z, by introducing a function n : Z, -»{ 1, ..., /} and sending the agent to Hn(li) from H,. In the case of mobile code<br><br>
- 10-<br>
applications with a single host, i.e. the first entity H only, the function g yields O's output £, and h gives H's oulput z.<br>
A computation entity T, that can be a generic secure computation service, is provided. This computation entity T is on-line and connected to all entitiesH/, ..., HI or hosts running agent applications and is at their disposal for securing agent computations. The computation entity T itself does not gain any information about the computation, no matter how it behaves, under the assumptions that (1) the computation entity 7 does not collude with the originator against any entity, and (2) the computation entity T does not collude with any entity against the originator or against any other entity. All computations proceed with minimal or no interaction. The scheme is generic and not bound to any particular application. Hence the service of the computation entity T might be offered as a public service for "secure mobile agent computation" on the Internet. Clients or customers who use this service in the role of O or H (e.g., for comparison shopping) do not have to fear that the computation entity T has "second thoughts" trying to violate their privacy (e.g., of customer profiling and collecting marketing data). Moreover, the computation entity T itself has an interest to maintain its reputation as a security provider.<br>
The scheme is based on functions in encrypted form. For example, encrypting a binary digital circuit realizes the part of the agent computation. This can be realized by an encrypted circuit construction as described in the following.<br>
Encrypted circuit construction<br>
The encrypted circuit construction of Yao, as introduced by A. C. Yao in his article "How to generate and exchange secrets" at Proc. 27th IEEE Symposium OP Foundations of Computer Science (FOCS), 1986, pp. 162-167, is an interactive protocol for secure function evaluation between two parties or entities. This is described for a binary function #(•,-) and parties Alice (with input x) and Bob (with input y). Bob receives the output z - g(x, y) but learns nothing else and Alice learns nothing at all.<br>
Let (x\	,v,,,), (yi, ...,}'„,), and (zi,...,z,,;) denote the binary representations of A, y, and z,<br>
respectively, and let C denote a polynomial-sized binary circuit computing g. The components of Yao's construction are (I) a first algorithm construct that Alice uses to construct an<br><br>
-11 -<br>
encrypted circuit, (El) a transfer protocol between Alice and Bob, and (HI) a second algorithm evaluate allowing Bob to retrieve g(x, y). More precisely, these procedures are as follows.<br>
(I) The probabilistic first algorithm construct(C) takes the circuit as input and outputs the tuple<br>
(C, I, X, U),<br>
where C may be viewed as an encrypted version of the n, + «,-input circuit C(-, •) and where /, X, and U denote lists of so called key pairs<br>
X = (K\,Q,K[,\),...,(Kn,$,Kn&gt;.,\)<br>
corresponding to x, y, and z, respectively.<br>
In order to compute C(x, y) from the encryption G , Bob needs one "key" for each input bit: Z,,.*<br>
corresponds to input bit ;c, = b and K^ corresponds to input bit y
The particular method in which C is encrypted ensures that for every gate in the circuit, given two keys representing its input bits, the key representing the resulting output bit can be readily computed, but no information is revealed about which cleartext bit it represents.<br>
(FT) Alice and Bob engage in a protocol for oblivious transfer, for example, as disclosed by S. Even, O. Goldreich and A. Lempel in "A randomized protocol for signing contract", Communications of the ACM 28 (1985), 637-647 or by G. Brassard, C. Crepeau, and J.-M Robert in "Information-theoretic reductions among disclosure problems", Proc. 27th EEEE Symposium on Foundations of Computer Science (FOCS), 1986. This is an interactive two-party protocol for a sender with input two messages m0 and m\ and a chooser with input a bit a. At the end, the chooser receives ma but does not learn anything about ma®\, and the sender has no information about a.<br>
More precisely, Alice acts as the sender and Bob obtains for every bit y, of his input the value K'j = Kj.yt but learns nothing about /£",.&gt;•,© i - At the same time, Alice learns nothing about y,.<br><br>
In addition, Alice computes the keys representing* as L\ = L,-iJCl. for /' = 1, ..., nf and sends    G,<br>
L\, ....L^.Ut<br>
(HI) The second algorithm evaluate(C,L\, ..., L'ni, K\, ..., K'ny) takes as inputs the encrypted circuit, a representation of x, and a representation of y by the respective keys. It outputs the keys U\ , ..., U'ni from which Bob can recover z, and if Alice and Bob obey the protocol, then z = g(x, y)-<br>
Implementing the first and second algorithms construct and evaluate can be achieved by pseudo-random functions, as for example proposed by O. Goldreich, S. Goldwasser, and S, Micali in "How to construct random functions", Journal of the ACM 33 (1986), no. 4, 792-807, which are realized in practice by block ciphers. Block ciphers are very fast cryptographic primitives, even if implemented in software.<br>
The following describes how to use the encrypted circuit construction for realizing secure mobile code computation with a single or first entity. The extension to multiple entities is considered after that.<br>
The computation entity T publishes the public key of an encryption scheme. The corresponding encryption and decryption operations are denoted by ET(-) and DT(-), respectively. All entities can communicate over secure authenticated links, which could be realized by using standard public-key encryption and digital signatures.<br>
The basic scheme is that O constructs an encrypted circuit C computing the two values f, and -. The code originator O sends C to the first entity H, but encrypts all keys in X for T and does not include the key pairs in U which correspond to £, (denoted by I/,) so that the first entity H will not learn anything about £. Next, the first entity H selects from X the encrypted keys representing y and invokes the computation entity T to decrypt them in a single round of interaction. Then, the first entity H evaluates the circuit and obtains z; it also returns the keys in the circuit output representing c, to O, who can determine £ from this.<br>
Let C be the binary circuit computing (c,z) - (g(x, y), h(x, y)) from the same inputs with n, + n, input bits ,vi ..... •*«,.&gt;'! ..... &gt;', and n, + nt output bits c, \ , ...,£„,, z\ , ..., c,,., slightly<br><br>
- 13 -<br>
modifying the notation from the previous section. The scheme proceeds in five steps 1) to 5), as described in the following.<br>
1) O chooses a string id that uniquely identifies the computation, e.g., containing the name of O, a description of g and h, and a sequence counter. O invokes construct(C) and obtains (C, I, X, U) as above with U consisting of n^ + n^ key pairs in total. Ux denotes the pairs in U with indices 1,..., n, and 14 denotes those with indices nt+ 1,..., n, + nz.<br>
For/ = 1, ..., ny and be {0, 1} , it computes<br>
Kij, = ET(id || i || Kij,).<br>
Let K_ denote the list of pairs of all such K. Then O lets L\ = L,,*, as above for / = 1,..., nf and sends<br>
id, C , L |, ..., L,, r, X_, U to the first entity H.<br>
2)	The first entity H sets AT, = Kt,yi for / = 1, ..., /i&gt;. to be the encryptions representing its input y<br>
and sends them to the computation entity T along with id.<br>
	/<br>
3)	The computation entity T decrypts K, for / = 1, ..., ny and verifies that the ith decrypted<br>
string contains the identifier id and index /'. If all checks are successful, the computation entity r returns the decrypted keys/f',, ..., K'ny to the first entity H.<br>
4)	The first entity H invokes the second algorithm evaluate(C, L\, ...,L'n
obtains   £/',, ..., U',,^,,..   Then,   the   first   entity   H   determines   z = (21, ...,z,,.)   such   that<br>
U„,+!.;. - U'n
originator O.<br>
5)	The code originator O determines its output £ = (£i	C«J such that U,^, = U\ for / = 1, ....<br><br>
- 14 -<br>
For increased security, the computation entity T should use a public-key cryptosystem that is secure against adaptive chosen-ciphertext attacks, which means non-malleable, as described by D. Dolev, C. Dwork, and M. Naor in "Non-malleable cryptography", SIAM Journal on Computing 30 (2000), no. 2, 391-437. The code originator O and the first entity H should also commit to their inputs. In a practical system, all of these can be realized in the so-called "random oracle model" as described, for example, by M. Bellare and P. Rogaway in "Random oracles are practical: A paradigm for designing efficient protocols", Proc. 1st ACM Conference on Computer and Communications Security, 1993. using a secure hash function. In this case, the public-key encryption scheme and the pseudo-random functions for circuit encryption can be implemented with discrete logarithms based on the hardness of the Diffie-Hellman problem, as described by M. Naor and O. Reingold in "Number-theoretic constructions of efficient pseudo-random functions", Proc. 38th EEEE Symposium on Foundations of Computer Science (FOCS), 1997.<br>
In the following, an extension of the above-described method is disclosed in order to achieve a general mobile computing scheme with multiple entities H\, ..., Hi, as indicated in Fig. 1. The generalization is the natural one in which each entity executes steps 2) to 4) of the basic scheme above and sends the agent to the next entity afterwards.<br>
Thereby, the code originator O prepares one encrypted circuit C for each entity H\, ...,H/ and incorporates the encrypted state x.-,. \ from C^'Mnto Cw for; &gt; 1. This is achieved by using the output keys U\ , ..., Un, from C^'^ for decrypting a hidden representation of the inputs to<br>
In a symmetric cryptosystem with encryption and decryption operations under key k denoted by Ek(-) and D*(-), respectively, the cryptosystem includes sufficient redundancy such that given a potential key U and a ciphertext c one can determine with high probability whether c results from an encryption under U. The modifications to the scheme are as follows.<br>
la) The code originator O obtains CJ
 <br>
and<br>
for each j &gt; 1 and /=!,...,«,, and randomly permutes them before assigning them to V^ and VJf, ;call the list of such pairs<br>
Then, the code originator O sends<br>
id,L\ ..... L;,,,^",^", V" and   (*\ W\ Uz w, V w   fory = 2, ...,/ to the first entityHi within a single message.<br>
2a) Fory &gt; 1, when H, runs step 2 of the basic scheme, is receives V^ and U'^~{\ ..., U'^'1* from HJ.\, which has before evaluated C0"1'.<br>
Each entity interprets each u'^~ ' as a symmetric key to £, determines which one of the ciphertexts V$, and V^}, it decrypts, and then decrypts the one that matches. This yields K^, an oblivious representation of the /th bit in the current state x, of the agent. Those keys are then used to evaluate Cw.<br>
3a) When H/ has obtained its output from evaluating Cw, it forwards all data that it has received from H, . i, together with f/',0), ..., u'^ toH; + 1 . At the end of the circle, HI returns U',(r&gt; to the code originator O.<br>
The computation entity T generates the code<br>
In a variation where the roles of O and T are switched, the computation entity T generates the encrypted circuit. Because it is trusted to follow the protocol one does not have to add a costly zero-knowledge proof for correctness of the whole circuit. Therefore, the operations of the other entities and the corresponding proofs ensuring robustness become much simpler. The computation entity T has to know # and h for constructing the circuit, but it may obtain a description of C from O in a first protocol message.<br>
A three-party oblivious transfer protocol is used, as introduced by M. Naor, B. Pinkas, and R. Sumner in "Privacy preserving auctions and mechanism design", Proc. 1st ACM Conference<br><br>
on Electronic Commerce, 1999, in which the role of the chooser is separated among the chooser and a third party, called the receiver. Compared to the standard notion of oblivious transfer, the receiver gets the output message /^specified by the chooser, who itself learns nothing. This so-called "proxy" oblivious transfer can be realized using three message flows: from chooser to receiver and from receiver to sender and back.<br>
The protocol uses also a one-round implementation of standard oblivious transfer between two parties, which can be realized using the method of C. Cachin, J. Camenisch, J. Kilian, and J. Miiller, published in their article "One-round secure computation and secure autonomous mobile agents", at Proc. 27th International Colloquium on Automata, Languages and Programming (ICALP) (U. Montanari, J. P. Rolim, and E. Welzl, eds.), Lecture Notes in Computer Science, vol. 1853, Springer, July 2000, pp. 512-523.<br>
As in the basic scheme the component of a encrypted circuit construction is applied. The protocol is described for the basic case of mobile code with a single entity H. Suppose O employs a public-key encryption scheme with encryption and decryption operations denoted by Eo(-) and D(-), respectively. O starts the computation as the chooser in nf parallel three-party oblivious transfers, one for each bit of x. It sends these hidden choices to H, who acts as the receiver in the three-party oblivious transfers, together with C and Eo(-)- H forwards the appropriate data to T, who acts as the sender; it will send the key pairs L in the three-party oblivious transfer. Furthermore, H also prepares its input to ny parallel one-round oblivious transfers (playing the role of the chooser), one for each bit of y. It sends these to T, together with the descriptions of C and EO(-)\ T will send the key pairs K in the one-round oblivious transfers.<br>
T invokes construct(C) to obtain C and the key pairs L , I, and U . It replies to H withEo(U,), C, Ut and the final flows in all oblivious transfer protocols.<br>
From this, H can determine the keys    L\	L'HI  representing x and the keys K\	L'n<br>
representing y.  It runs evaluate( C , L\, ...,L',,t, K\	K',,t.) to obtain U\	£/),,+„.as above.<br>
Then it determines its output z from .U'n&gt;+], ..., U',li+,,.and from K, and it forwards U\	U'n&gt;<br>
together with Eo(U,)lo O. This enables O to obtain its output d;.<br><br>
The following shows an extension of the protocol from a single host or first entityH, to / hostsHi, ..., HI. The protocol starts as before for the first host. However, the steps for H2, ..., HI are slightly different: three-party oblivious transfer and encryption under Eo are not used. Instead, T encrypts the keys JL^ in the input of C^ and representing the state Xj-\ of the agent under the output keys in U^"0 from C0"1' as before V^. The keys Uu~l} can be stored by T between step j - 1 and step j or they can be sent along with the protocol flow and are transmitted to T viaHj., andH,, whereby they are encrypted by£V(*)- In addition, the last host obtains U, encrypted with EO(-) from T and forwards this to O as above.<br>
The communication pattern is the same as in the basic scheme: there is one message from O to Hi, one from each Hj .\ toH, and one fromH/ to O, plus one communication flow between each host and the computation entity T. Robustness can be added by using non-malleable public-key encryption schemes and non-interactive zero-knowledge proofs. However, the result will be much more practical because zero-knowledge proofs are not needed for the potentially large encrypted circuit. Moreover, the encrypted circuit construction can be implemented by a block cipher instead of public-key operations.<br>
Any disclosed embodiment may be combined with one or several of the other embodiments shown and/or described. This is also possible for one or more features of the embodiments.<br>
The present invention can be realized in hardware, software, or a combination of hardware and software. Any kind of computer system - or other apparatus adapted for carrying out the method described herein - is suited. A typical combination of hardware and software could be a general purpose computer system with a computer program that, when being loaded and executed, controls the computer system such that it carries out the methods described herein. The present invention can also be embedded in a computer program product, which comprises all the features enabling the implementation of the methods described herein, and which -when loaded in a computer system - is able to carry out these methods.<br>
Computer program means or computer program in the present context mean any expression, in any language, code or notation, of a set of instructions intended to cause a system having an information processing capability to perform a particular function either directly or after either<br><br>
or both of the following a) conversion to another language, code or notation; b) reproduction in a different material form.<br><br><br><br><br><br>
We Claim:<br>
1.	A method for processing an originator request (OR) of a customer (O) by<br>
a first entity (H), the method comprising:<br>
(a)	receiving from said customer (O) said originator request (OR) that<br>
is part of a mobile code and comprises a function in encrypted<br>
from, and adding information (I) concerning said originator request<br>
thereby forming a first-modified request (FMR);<br>
(b)	sending at least part of said first-modified request (FMR) to at least<br>
a computation entity (T) that derives a computation-entity result<br>
(CER) therefrom and returns it at least in part, the computation<br>
entity (T) being a secure computation service for a decryption<br>
operation; and<br>
(c)	having received at least part of said computation-entity result<br>
(CER) by said first entity (H) deriving therefrom a first entity<br>
result  (PER)  and  forwarding  it  at least in part, whereby a<br>
cryptographic operation is applied to the requests (OR, FMR) and<br>
the computation-entity result (CER), and said customer (O) is able<br>
to derive a customer result (CR) from said at least part of said first-<br>
entity result (PER). (Computation entity T)<br>
2.	A method for processing a first-modified request (FMR) from at least one<br>
first entity (H) comprising at least part of an originator request (OR) from<br>
a customer (O) by a computation entity (T), the originator request (OR)<br>
being part of a mobile code and comprising a function in encrypted from, the method comprising:<br>
(a)	receiving said first-modified request (FMR) from the or each first<br>
entity (H);<br>
(b)	deriving a computation-entity result (CER) from at least part of<br>
said first-modified request (FMR) by a decryption operation;<br>
(c)	sending at least part of said computation-entity result (CER) to the<br>
or each first entity (H) that derives therefrom a first-entity result<br>
(PER) and forwards it at least in part, whereby a cryptographic<br>
operation   is   applied   to   the   requests   (OR,   FMR)   and   the<br>
computation-entity result (CER), and said customer (O) is able to<br>
derive a customer result (CR) from said at least part of said first-<br>
entity result (PER). (Customer O)<br>
3. A method for processing an originator request (OR), the method comprising;<br>
(a)	forming said originator request (OR) that is part of a mobile code<br>
and comprises a function in encrypted from ;<br>
(b)	sending said originator request (OR) to at least one first entity (H),<br>
whereby the or each first entity (H) adds its information (I)<br>
concerning said originator request (OR) thereby forming a first-<br>
modified request (FMR), and sends at least part of said first-<br>
modified request (FMR) to at least a computation entity (T) that<br>
derives   therefrom   a   computation-entity   result   (CER),   the<br>
computation entity (T) being a secure computation service for a<br>
decryption operation, at least part of said computation-entity result (CER) being sent to the or each first entity (H) that derives therefrom a first-entity result (PER), and forwards it at least in part, a cryptographic operation being applied to the requests (OR, FMR) and the computation-entity result (CER)
(c) having received said at least part of said first-entity result (PER) deriving therefrom a customer result (CR).<br>
4.	The method as claimed in claim 3, whereby the step of forming the<br>
originator   request   (OR)   comprises   applying   an   encrypted   circuit<br>
construction (c).<br>
5.	A system for processing an originator request (OR), comprising:<br>
a customer (O) connected to at least one first entity (H); and<br>
a computation entity (T) connected to at least said first entity (H), the computation entity (T) being a secure computation service for a decryption operation;<br>
wherein said customer (O) sends said originator request (OR) that is part of a mobile code and comprises a function in encrypted from to the or each first entity (H) that adds information (I) concerning said originator request (OR) thereby forming a first-modified request (FMR) and sends at least part of said first-modified request (FMR) to at least said computation entity (T), said computation entity (T)<br>
derives a computation-entity result (CER) from said at least part of said first-modified request (FMR) and sends at least part of said computation-entity result (CER) to the or each first entity (H), the or each first entity (H) derives a first entity result (FER) from said at least part of said computation-entity result (CER) and forwards it at least in part, a cryptographic operation is applied to the requests (OR, FMR) and the computation-entity result (CER),<br>
said customer (O) being able to derive a customer result (CR) from said at least part of said first-entity result (FER).<br>
6.	The system as claimed in claim 7, wherein the originator request (OR)<br>
comprises a function in encrypted form.<br>
7.	The system as claimed in claim 8, wherein the function in encrypted form<br>
comprises an encrypted circuit construction (C).<br>
8.	The system as claimed in claim 7, wherein the originator request (OR) is<br>
part of a mobile code.<br>
9.	The system as claimed in claim 7, wherein the originator request (OR),<br>
the first-modified request (FMR), the computation-entity result (CER),<br>
and the first-entity result (FER) comprise an encrypted part.<br>
10.The system as claimed in any of the preceding claims 7 to 11, wherein the originator request (OR) comprises one or more information of an offer, customer information, purchase information.<br>
11 .The system as claimed in claim 7, wherein the first entity (H) comprises a web server offering a service and/or a customer information concerning acceptance of the originator request (OR).<br>
12.The system as claimed in claim 7, wherein the customer result (CR) comprises a first-entity information concerning acceptance of the originator request (OR).<br>
13. A method for processing an originator request of a customer substantially as herein described with reference to the accompanying drawings.<br>
14.A system for processing an originator request substantially as herein described with reference to the accompanying drawings.<br><br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">836-delnp-2003-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtYXNzaWdubWVudC5wZGY=" target="_blank" style="word-wrap:break-word;">836-delnp-2003-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LURFTE5QLTIwMDMtQ2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">836-DELNP-2003-Claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtY29tcGxldGUgc3BlY2lmaWNhdGlvbiAoZ3JhbnRlZCkucGRm" target="_blank" style="word-wrap:break-word;">836-delnp-2003-complete specification (granted).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtY29ycmVzcG9uZGVuY2Utb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">836-delnp-2003-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtY29ycmVzcG9uZGVuY2UtcG8ucGRm" target="_blank" style="word-wrap:break-word;">836-delnp-2003-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">836-delnp-2003-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">836-delnp-2003-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtZm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">836-delnp-2003-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtZm9ybS0xOS5wZGY=" target="_blank" style="word-wrap:break-word;">836-delnp-2003-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtZm9ybS0yLnBkZg==" target="_blank" style="word-wrap:break-word;">836-delnp-2003-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtZm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">836-delnp-2003-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">836-delnp-2003-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtZ3BhLnBkZg==" target="_blank" style="word-wrap:break-word;">836-delnp-2003-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtcGN0LTMwNC5wZGY=" target="_blank" style="word-wrap:break-word;">836-delnp-2003-pct-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODM2LWRlbG5wLTIwMDMtcGV0aXRpb24tMTM4LnBkZg==" target="_blank" style="word-wrap:break-word;">836-delnp-2003-petition-138.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="218297-method-for-assaying-a-target.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="218299-a-mathod-of-packaging-for-atleast-one-cigarette-and-a-package-thereof.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>218298</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>836/DELNP/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>41/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>10-Oct-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>31-Mar-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>28-May-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTERNATIONAL BUSINESS MACHINES CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>NEW ORCHARD ROAD, ARMONK, NEW YORK 10504, U.S.A.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>ALGESHEIMER MULLER JOY</td>
											<td>TRAMSTRASSE 89, CH-8050, ZURICH SWITZERLAND.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>CACHIN CHRISTIAN</td>
											<td>EGLISTRASSE 6, CH-8942 OBERRIEDEN, SWITZERLAND.</td>
										</tr>
										<tr>
											<td>3</td>
											<td>CAMENISCH JAN</td>
											<td>BAHNHOFSTRASSE 13, CH-8803 RUESCHLIKON,SWITZERLAND.</td>
										</tr>
										<tr>
											<td>4</td>
											<td>KARJOTH GUNTER</td>
											<td>BUERGLIPARK 19, CH-8820, WAEDENSWIL, SWITZERLAND.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 1/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/IB01/01988</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2001-10-24</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>00124061.3</td>
									<td>2000-11-06</td>
								    <td>EPO</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/218298-a-system-for-processing-a-originator-request-of-a-customer by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:41:39 GMT -->
</html>
