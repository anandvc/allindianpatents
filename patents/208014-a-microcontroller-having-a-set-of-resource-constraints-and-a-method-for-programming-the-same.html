<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/208014-a-microcontroller-having-a-set-of-resource-constraints-and-a-method-for-programming-the-same by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:08:59 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 208014:A MICROCONTROLLER HAVING A SET OF RESOURCE CONSTRAINTS AND A METHOD FOR PROGRAMMING THE SAME</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A MICROCONTROLLER HAVING A SET OF RESOURCE CONSTRAINTS AND A METHOD FOR PROGRAMMING THE SAME</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>An integrated circuit card is used with a terminal. The integrated circuit card includes a memory that stores an interpreter and an application that has a high level programming language format. A processor of the card is configured to use the interpreter to interpret the application for execution and to use a communicator of the card to communicate with the terminal.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br><br><br><br><br>
The present invention relates to a microcontroller having a set of resource constraints and a method for programming the same. A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by any one of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.<br>
Under 35 U.S.C. S 119(e), this application claims benefit of prior U.S. provisional application Serial No.60/029,057, filed October 25, 1996.<br>
BACKGROUND OF THE INVENTION<br>
This invention relates in general to the field of programming, and more particularly to using a high level programming language with a smart card or a microcontroller.<br>
Software applications written in the Java high-level programming language have been so designed that an application written in Java can be run on many different computer brands or computer platforms without change. This is accomplished by the following procedure. When a Java application is written, it is compiled into "Class" files containing byte codes that are instructions for a hypothetical computer called a Java Virtual Machine. An implementation of this virtual machine is written for each platform that is supported. When a user wishes to run a particular Java application on a selected platform, the class files compiled from the desired application is loaded onto the selected platform. The Java virtual machine for the selected platform is run, and interprets the byte codes in the class file, thus effectively running the Java application.<br><br>
Java is described in the following references which are hereby incorporated by reference: (1) Arnold, Ken, and James Gosling, "The Java Programming Language," Addison-Wesley, 1996; (2) James Gosling, Bill Joy, and Guy Steele, "The Java Language Specification," Sun Microsystems, 1996, (web site: http://java-sun.com/doc/language_specification);<br>
James Gosling and Henry McGilton, "The Java Language Environment: A White Paper," Sun Microsystems, 1995 (web site: http://java.sun.com/doc/language_environment/); and<br>
Tim Lindholm and Frank Yellin, "The Java Virtual Machine Specification," Addison-Wesley, 1997.  These texts among many others describe how to program using Java.<br>
In order for a Java application to run on a specific platform, a Java virtual machine implementation must be written that will run within the constraints of the platform, and a mechanism must be provided for loading the desired Java application on the platform, again keeping within the constraints of this platform-Conventional platforms that support Java are typically microprocessor-based computers, with access to relatively large amounts of memory and hard disk storage space.  Such microprocessor implementations frequently are used in desktop and personal computers.  However, there are no conventional Java implementations on microcontrollers, as would typically be used in a smart card.<br>
Microcontrollers differ from microprocessors in many ways.  For example, a microprocessor typically has a central processing unit that requires certain external components (e.g., memory, input controls and output controls) to function properly.  A typical microprocessor can access from a megabyte to a gigabyte of memory, and is capable of processing 16, 32, or 64 bits of information or more with a single instruction.   In contrast to the microprocessor, a<br><br>
microcontroller includes a central processing unit, memory and other functional elements, all on a single semiconductor substrate, or integrated circuit (e.g., a "chip").  As compared to the relatively large external memory accessed by the microprocessor, the typical microcontroller accesses a much smaller memory.  A typical microcontroller can access one to sixty-four kilobytes of built-in memory, with sixteen kilobytes being very common.<br>
There are generally three different types of memory used: random access memory (RAM), read only memory (ROM), and electrically erasable programmable read only memory (EEPROM).  In a microcontroller, the amount of each kind of memory available is constrained by the amount of space on the integrated circuit used for each kind of memory. Typically, RAM takes the most space, and is in shortest supply.  ROM takes the least space, and is abundant.  EEPROM is more abundant than RAM, but less than ROM.<br>
Each kind of memory is suitable for different purposes.  Although ROM is the least expensive, it is suitable only for data that is unchanging, such as operating system code.  EEPROM is useful for storing data that must be retained when power is removed, but is extremely slow to write.  RAM can be written and read at high speed, but is expensive and data in RAM is lost when power is removed. A microprocessor system typically has relatively little ROM and EEPROM, and has 1 to 128 megabytes of RAM, since it is not constrained by what will fit on a single integrated circuit device, and often has access to an external disk memory system that serves as a large writable, non-volatile storage area at a lower cost that EEPROM.  However, a microcontroller typically has a small RAM of 0.1 to 2.0 K, 2K to 8K of EEPROM, and 8K - 56K of ROM.<br><br>
Due to the small number of external components required and their small size, microcontrollers frequently are used in integrated circuit cards, such as smart cards. Such smart cards come in a variety of forms, including contact-based cards, which must be inserted into a reader to be used, and contactless cards, which need not be inserted. In fact, microcontrollers with contactless communication are often embedded into specialized forms, such as watches and rings, effectively integrating the functionality of a smart card in an ergonomically attractive manner.<br>
Because of the constrained environment, applications for smart cards are typically written in a low level programming language (e.g., assembly language) to conserve memory.<br>
The integrated circuit card is a secure, robust, tamper-resistant and portable device for storing data.  The integrated circuit card is the most personal of personal computers because of its small size and because of the hardware and software data security features unique to the integrated circuit card.<br>
The primary task of the integrated circuit card and f the microcontroller on the card is to protect the data stored on the card.  Consequently, since its invention in 1974, integrated circuit card technology has been closely guarded on these same security grounds.  The cards were first used by French banks as debit cards.  In this application, before a financial transaction based on the card is authorized, the card user must demonstrate knowledge of a 4-digit personal identification number (PIN) stored in the card in addition to being in possession of the card. Any information that might contribute to discovering the PIN number on a lost or stolen card was blocked from public distribution.  In fact, since nobody could tell what<br><br>
information might be useful in this regard, virtually all information about integrated circuit cards was withheld.<br>
Due to the concern for security, applications written for integrated circuit cards have unique properties. For example, each application typically is identified with a particular owner or identity.  Because applications typically are written in a low-level programming language, such as assembly language, the applications are written for a particular type of microcontroller.  Due to the nature of low level programming languages, unauthorized applications may access data on the integrated circuit card.  Programs written for a integrated circuit card are identified with a particular identity so that if two identities want to perform the same programming function there must be two copies of some portions of the application on the microcontroller of the integrated circuit card.<br>
Integrated circuit card systems have historically been closed systems.  An integrated circuit card contained a dedicated application that was handcrafted to work with a specific terminal application.  Security checking when an integrated circuit card was used consisted primarily of making sure that the card application and the terminal application were a matched pair and that the data on the card was valid.<br>
As the popularity of integrated circuit cards grew, it became clear that integrated circuit card users would be averse to carrying a different integrated circuit card for each integrated circuit card application.  Therefore, multiple cooperating applications began to be provided on single provider integrated circuit cards.  Thus, for example, an automated teller machine (ATM) access card and a debit card may coexist on a single integrated circuit card platform.  Nevertheless, this was still a closed system<br><br>
since all the applications in the terminal and the card were built by one provider having explicit knowledge of the other providers.<br>
The paucity of information about integrated circuit cards -- particularly information about how to communicate with them and how to program them -- has impeded the general application of the integrated circuit card.  However, the advent of public digital networking (e.g., the Internet and the World Wide Web) has opened new domains of application for integrated circuit cards.  In particular, this has lead to a need to load new applications on the card that do not have explicit knowledge of the other providers, but without the possibility of compromising the security of the card. However, typically, this is not practical with conventional cards that are programmed using low level languages.<br>
Summary of the Invention<br>
In general, in one aspect, the invention features an integrated circuit card for use with a terminal.  The integrated circuit card includes a memory that stores an interpreter and an application that has a high level programming language format.  A processor of the card is configured to use the interpreter to interpret the application for execution and to use a communicator of the card to communicate with the terminal.<br>
Among the advantages of the invention are one or more of the following.  New applications may be downloaded to a smart card without compromising the security of the smart card.  These applications may be provided by different companies loaded at different times using different terminals.  Security is not comprised since the applications are protected against unauthorized access of any application code or data by the security features provided by the Java<br><br>
virtual machine.  Smart card applications can be created in high level languages such as Java and Eiffel, using powerful mainstream program development tools.  New applications can be quickly prototyped and downloaded to a smart card in a matter of hours without resorting to soft masks.  Embedded systems using microcontrollers can also gain many of these advantages for downloading new applications, high level program development, and rapid prototyping by making use of this invention.<br>
Implementations of the invention may include one or more of the following.  The high level programming language format of the application may have a class file format and may have a Java programming language format.  The processor may be a microcontroller.  At least a portion of the memory may be located in the processor.<br>
The application may have been processed from a second application that has a string of characters, and the string of characters may be represented in the first application by an identifier (e.g., an integer).<br>
The processor may be also configured to receive a request from a requester (e.g., a processor or a terminal) to access an element (e.g., an application stored in the memory, data stored in the memory or the communicator) of the card, after receipt of the request, interact with the requester to authenticate an identity of the requester, and based on the identity, selectively grant access to the element.<br>
The memory may also store an access control list for the element.  The access control list furnishes an indication of types of access to be granted to the identity, and based on the access control list, the processor selectively grants specific types of access (e.g., reading<br><br>
data, writing data, appending data, creating data, deleting data or executing an application) to the requester.<br>
The application may be one of a several applications stored in the memory.  The processor may be further configured to receive a request from a requester to access one of the plurality of applications; after receipt of the request, determine whether said one of the plurality of applications complies with a predetermined set of rules; and based on the determination, selectively grant access to the requester to said one of the plurality of applications.  The predetermined rules provide a guide for determining whether said one of the plurality of applications accesses a predetermined region of the memory.  The processor may be further configured to authenticate an identity of the requester and grant access to said one of the plurality of applications based on the identity.<br>
The processor may be also configured to interact with the terminal via the communicator to authenticate an identity; determine if the identity has been authenticated; and based on the determination, selectively allow communication between the terminal and the integrated circuit card.<br>
The communicator and the terminal may communicate via communication channels.  The processor may also be configured to assign one of the communication channels to the identity when the processor allows the communication between the terminal and the integrated circuit card.   The processor may also be configured to assign a session key to the assigned communication channel and use the session key when the processor and the terminal communicate via the assigned communication channel.<br>
The terminal may have a card reader, and the    communicator may include a contact for communicating with<br><br>
the card reader.  The terminal may have a wireless communication device, and the communictor may include a wireless transceiver for communicating with the wireless communication device.  The terminal may have a wireless communication device, and the communicator may include a wireless transmitter for communicating with the wireless communication device.<br>
In general, in another aspect, the invention features a method for use with an integrated circuit card and a terminal.  The method includes storing an interpreter and at least one application having a high level programming language format in a memory of the integrated circuit card. A processor of the integrated circuit card uses the interpreter to interpret the at least one application for execution, and the processor uses a communicator of the card when communicating between the processor and the terminal.<br>
In general, in another aspect, the invention features a smart card.  The smart card includes a memory that stores a Java interpreter and a processor that is configured to use the interpreter to interpret a Java application for execution.<br>
In general, in another aspect, the invention features a microcontroller that has a semiconductor substrate and a memory located in the substrate.  A programming language interpreter is stored in the memory and is configured to implement security checks.  A central processing unit is located in the substrate and is coupled to the memory.<br>
Implementations of the invention may include one or more of the following.  The interpreter may be a Java byte code interpreter.  The security checks may include establishing firewalls and may include enforcing a sandbox security model.<br><br>
In general, in another aspect, the invention features a smart card that has a programming language interpreter stored in a memory of the card.  The interpreter is configured to implement security check.  A central processing unit of the card is coupled to the memory.<br>
In general, in another aspect, the invention features an integrated circuit card that is used with a terminal.  The card includes a communicator and a memory that stores an interpreter and first instructions of a first application.  The first instructions have been converted from second instructions of a second application.  The integrated circuit card includes a processor that is coupled to the memory and is configured to use the interpreter to execute the first instructions and to communicate with the terminal via the communicator.<br>
Implementations of the invention may include one or more of the following.  The first and/or second applications may have class file format(s).  The first and/or second applications may include byte codes, such as Java byte codes.  The first instructions may be generalized or renumbered versions of the second instructions.  The second instructions may include constant references, and the first instructions may include constants that replace the constant references of the second instructions.  The second instructions may include references, and the references may shift location during the conversion of the second instructions to the first instructions.  The first instructions may be relinked to the references after the shifting.  The first instructions may include byte codes for a first type of virtual machine, and the second instructions may include byte codes for a second type of virtual machine. The first type is different from the second type.<br><br>
In general, in another aspect, the invention features a method for use with an integrated circuit card. The method includes converting second instructions of a second application to first instructions of a first application; storing the first instructions in a memory of the integrated circuit card; and using an interpreter of the integrated circuit card to execute the first instructions.<br>
In general, in another aspect, the invention features an integrated circuit for use with a terminal.  The integrated circuit card has a communicator that is configured to communicate with the terminal and a memory that stores a first application that has been processed from a second application having a string of characters.  The string of characters are represented in the first application by an identifier.  The integrated circuit card includes a processor that is coupled to the memory.  The processor is configured to use the interpreter to interpret the first application for execution and to use the communicator to communicate with the terminal.<br>
In general, in another aspect, the invention features a method for use with an integrated circuit card and a terminal.  The method includes processing a second application to create a first application.  The second application has a string of characters.  The string of characters is represented by an identifier in the second application.  An interpreter and the first application are stored in a memory of the integrated circuit card,  A processor uses an interpreter to interpret the first application for execution.<br>
In general, in another aspect, the invention features a microcontroller that includes a memory which stores an application and an interpreter.  The application has a class file format.  A processor of the microcontroller<br><br>
is coupled to the memory and is configured to use the interpreter to interpret the application for execution.<br>
In implementations of the invention, the microcontroller may also include a communicator that is configured to communicate with a terminal.<br>
In general, in another aspect, the invention features a method for use with an integrated circuit card. The method includes storing a first application in a memory of the integrated circuit card, storing a second application in the memory of the integrated circuit card, and creating a firewall that isolates the first and second applications so that the second application cannot access either the first application or data associated with the first application.<br>
In general, in another aspect, the invention features an integrated circuit card for use with a terminal. The integrated circuit card includes a communicator that is configured to communicate with the terminal, a memory and a processor.  The memory stores applications, and each application has a high level programming language format. The memory also stores an interpreter.  The processor is coupled to the memory and is configured to: a.) use the interpreter to interpret the applications for execution, b.) use the interpreter to create a firewall to isolate the applications from each other, and c.) use the communicator to communicate with the terminal.<br>
Other advantages and features will become apparent from the following description and from the claims.<br>
Brief Description of the Drawing Fig. 1 is a block diagram of an integrated card system.<br><br>
Fig. 2 is a flow diagram illustrating the preparation of Java applications to be downloaded to an integrated circuit card.<br>
Fig. 3 is a block diagram of the files used and generated by the card class file converter.<br>
Fig. 4 is a block diagram illustrating the transformation of application class file(s) into a card class file.<br>
Fig. 5 is a flow diagram illustrating the working of the class file converter.<br>
Fig, 6 is a flow diagram illustrating the modification of the byte codes.<br>
Fig. 7 is a block diagram illustrating the transformation of specific byte codes into general byte codes.<br>
Fig. 8 is a block diagram illustrating the replacement of constant references with constants.<br>
Fig. 9 is a block diagram illustrating the replacement of references with their updated values.<br>
Fig. 10 is a block diagram illustrating renumbering of original byte codes.<br>
Fig. 11 is a block diagram illustrating translation of original byte codes for a different virtual machine architecture.<br>
Fig 12 is a block diagram illustrating loading applications into an integrated circuit card.<br>
Fig. 13 is a block diagram illustrating executing applications in an integrated circuit card.<br>
Fig. 14 is a schematic diagram illustrating memory organization for ROM, RAM and EEPROM.<br>
Fig. 15 is a flow diagram illustrating the overall architecture of the Card Java virtual machine.<br><br>
Fig. 16 is a flow diagram illustrating method execution in the Card Java virtual machine with the security checks.<br>
Fig. 17 is a flow diagram illustrating byte code execution in the Card Java virtual machine.<br>
Fig. 18 is a flow diagram illustrating method execution in the Card Java virtual machine without the security checks.<br>
Fig. 19 is a block diagram illustrating the association between card applications and identities.<br>
Fig. 20 is a block diagram illustrating the access rights of a specific running application.<br>
Fig. 21 is a perspective view of a microcontroller on a smart card.<br>
Fig. 22 is a perspective view of a microcontroller on a telephone.<br>
Fig. 23 is a perspective view of a microcontroller on a key ring.<br>
Fig. 24 is a perspective view of a microcontroller on a ring.<br>
Fig. 25 is a perspective view of a microcontroller on a circuit card of an automobile.<br>
Detailed Description of the Preferred Embodiments Referring to Fig. 1, an integrated circuit card 10 (e.g., a smart card) is constructed to provide a high level, Java-based, multiple application programming and execution environment.  The integrated circuit card 10 has a communicator 12a that is configured to communicate with a terminal communicator 12b of a terminal 14.  In some embodiments, the integrated circuit card 10 is a smart card with an 8 bit microcontroller, 512 bytes of RAM, 4K bytes of EEPROM, and 20K of ROM; the terminal communicator 12b is a<br><br>
conventional contact smart card reader; and the terminal 14 is a conventional personal computer running the Windows NT operating system supporting the personal computer smart card (PC/SC) standard and providing Java development support.<br>
In some embodiments, the microcontroller, memory and communicator are embedded in a plastic card that has substantially the same dimensions as a typical credit card. In other embodiments, the microcontroller, memory and communicator are mounted within bases other than a plastic card, such as jewelry (e.g., watches, rings or bracelets), automotive equipment, telecommunication equipment (e.g., subscriber identity module (SIM) cards), security devices (e.g., cryptographic modules) and appliances.<br>
The terminal 14 prepares and downloads Java applications to the integrated circuit card 10 using the terminal communicator 12b.  The terminal communicator 12b is a communications device capable of establishing a communications channel between the integrated circuit card 10 and the terminal 14.  Some communication options include contact card readers, wireless communications via radio frequency or infrared techniques, serial communication protocols, packet communication protocols, ISO 7816 communication protocol, to name a few.<br>
The terminal 14 can also interact with applications running in the integrated circuit card 10.  In some cases, different terminals may be used for these purposes.  For example, one kind of terminal may be used to prepare applications, different terminals could be used to download the applications, and yet other terminals could be used to run the various applications.  Terminals can be automated teller machines (ATM)s, point-of-sale terminals, door security systems, toll payment systems, access control<br><br>
systems, or any other system that communicates with an integrated circuit card or microcontroller.<br>
The integrated circuit card 10 contains a card Java virtual machine (Card JVM) 16, which is used to interpret applications which are contained on the card 10.<br>
Referring to Fig. 2, the Java application 20 includes three Java source code files A.Java 2 0a, B.java 20b, and C.java 20c. These source code files are prepared and compiled in a Java application development environment 22-  When the Java application 20 is compiled by the development environment 22, application class files 24 are produced, with these class files A.class 24a, B.class 24b, and C.class 24c corresponding to their respective class Java source code 20a, 20b, and 20c.  The application class files 24 follow the standard class file format as documented in chapter 4 of the Java virtual machine specification by Tim Lindholm and Frank Yellin, "The Java Virtual Machine Specification," Addison-Wesley, 1996.  These application class files 24 are fed into the card class file converter 26, which consolidates and compresses the files, producing a single card class file 27.  The card class file 27 is loaded to the integrated circuit card 10 using a conventional card loader 28.<br>
Referring to Fig. 3, the card class file converter 26 is a class file postprocessor that processes a set of class files 24 that are encoded in the standard Java class file format, optionally using a string to ID input map file 30 to produce a Java card class file 27 in a card class file format.  One such card class file format is described in Appendix A which is hereby incorporated by reference.  In addition, in some embodiments, the card class file converter 26 produces a string to ID output map file 32 that is used<br><br>
as input for a subsequent execution of the card class file converter.<br>
In some embodiments, in order for the string to ID mapping to be consistent with a previously generated card class file (in the case where multiple class files reference the same strings), the card class file converter 2 6 can accept previously defined string to ID mappings from a string to ID input map file 30.  In the absence of such a file, the IDs are generated by the card class file converter 26.  Appendix B, which is hereby incorporated by reference, describes one possible way of implementing and producing the string to ID input map file 3 0 and string to ID output map file 32 and illustrates this mapping via an example.<br>
Referring to Fig. 4, a typical application class file 24a includes class file information 41; a class constant pool 42; class, fields created, interfaces referenced, and method information 43; and various attribute information 44, as detailed in aforementioned Java Virtual Machine Specification.  Note that much of the attribute information 44 is not needed for this embodiment and is eliminated 45 by the card class file converter 26. Eliminated attributes include SourceFile, Constant Value, Exceptions, LineNumberTable, LocalVariableTable, and any optional vendor attributes.  The typical card class file 27 as described in Appendix A is derived from the application class files 24 in the following manner.  The card class file information 46 is derived from the aggregate class file information 41 of all application class files 24a, 24b, and 24c.  The card class file constant pool 47 is derived from the aggregate class constant pool 42 of all application class files 24a, 24b, and 24c.  The card class, fields created, interfaces referenced, and method information 48 is derived from the aggregate class, fields created, interfaces<br><br>
referenced, and method information 43 of all application class files 24a, 24b, and 24c.  The card attribute information 49 in this embodiment is derived from only the code attribute of the aggregate attribute information 44 of all application class files 24a, 24b, and 24c.<br>
To avoid dynamic linking in the card, all the information that is distributed across several Java class file 24a, 24b, and 24c that form the application 24, are coalesced into one card class file 27 by the process shown in the flowchart in Fig. 5.  The first class file to be processed is selected 51a.  The constant pool 42 is compacted 51b in the following manner.  All objects, classes, fields, methods referenced in a Java class file 24a are identified by using strings in the constant pool 42 of the class file 24a.  The card class file converter 26 compacts the constant pool 42 found in the Java class file 24a into an optimized version.  This compaction is achieved by mapping all the strings found in the class file constant pool 42 into integers (the size of which is microcontroller architecture dependent). These integers are also referred to as IDs. Each ID uniquely identifies a particular object, class, field or method in the application 20. Therefore, the card class file converter 26 replaces the strings in the Java class file constant pool 42 with its corresponding unique ID.  Appendix B shows an example application HelloSmartCard.Java, with a table below illustrating the IDs corresponding to the strings found in the constant pool of the class file for this application.  The IDs used for this example are 16-bit unsigned integers.<br>
Next, the card class file converter 26 checks for unsupported features 51c in the Code attribute of the input Java class file 24a.  The Card JVM 16 only supports a subset of the full Java byte codes as described in Appendix C,<br><br>
which is hereby incorporated by reference.  Hence, the card class file converter 26 checks for unsupported byte codes in the Code attribute of the Java class file 24a.  If any unsupported byte codes are found 52, the card class file converter flags an error and stops conversion 53.  The program code fragment marked "A" in APPENDIX D shows how these spurious byte codes are apprehended.  Another level of checking can be performed by requiring the standard Java development environment 22 to compile the application 20 with a '-g' flag. Based on the aforementioned Java virtual machine specification, this option requires the Java compiler to place information about the variables used in a Java application 2 0 in the LocalVariableTable attribute of the class file 24a- The card class file converter 26 uses this information to check if the Java class file 24a references data types not supported by the Java card.<br>
Next, the card class file converter 26 discards all the unnecessary parts 51c of the Java class file 24a not required for interpretation.  A Java class file 24a stores information pertaining to the byte codes in the class file in the Attributes section 44 of the Java class file. Attributes that are not required for interpretation by the card JVM 16, such as SourceFile, ConstantValue, Exceptions, LineNumberTable, and LocalVariableTable may be safely discarded 45.  The only attribute that is retained is the Code attribute.  The Code attribute contains the byte codes that correspond to the methods in the Java class file 24a.<br>
Modifying the byte codes 54 involves examining the Code attribute information 44 for each method in the class file, and modifying the operands of byte codes that refer to entries in the Java class file constant pool 42 to reflect the entries in the card class file constant pool 47.  In<br><br>
some embodiments, the byte codes are also modified, as described below.<br>
Modifying the byte codes 54 involves five passes (with two optional passes) as described by the flowchart in Fig. 6.  The original byte codes 60 are found in the Code attribute 44 of the Java class file 24a being processed. The first pass 61 records all the jumps and their destinations in the original byte codes.  During later byte code translation, some single byte code may be translated to dual or triple bytes.  Fig. 7 illustrates an example wherein byte code ILOAD_0 is replaced with two bytes, byte code ILOAD and argument 0,  When this is done, the code size changes, requiring adjustment of any jump destinations which are affected.  Therefore, before these transformations are made, the original byte codes 60 are analyzed for any jump byte codes and a note made of their position and current destination-   The program code fragment marked "B" in Appendix D shows how these jumps are recorded.  Appendix D is hereby incorporated by reference.<br>
Once the jumps are recorded, if the optional byte code translation is not being performed 62, the card class file converter 26 may proceed to the third pass 64.<br>
Otherwise, the card class file converter converts specific byte codes into generic byte codes.  Typically, the translated byte codes are not interpreted in the Card JVM 16 but are supported by converting the byte codes into equivalent byte codes that can be interpreted by the Card JVM 16 (see Fig. 7).  The byte codes 70 may be replaced with another semantically equivalent but different byte codes 72. This generally entails the translation of short single specific byte codes such as ILOAD_0 into their more general versions.  For example, ILOAD_0 may be replaced by byte code ILOAD with an argument 0.  This translation is done to<br><br>
reduce the number of byte codes translated by the Card JVM 16, consequently reducing the complexity and code space requirements for the Card JVM 16.  The program code fragment marked "C" in Appendix D shows how these translations are made.  Note that such translations increase the size of the resulting byte code and force the re-computation of any jumps which are affected.<br>
In the third pass 64, the card class file converter rebuilds constant references via elimination of the strings used to denote these constants.  Fig. 8 shows an example wherein the byte code LDC 80 referring to constant "18" found via an index in the Java class file 24a constant pool 42 may be translated into BIPUSH byte code 82.  In this pass the card class file converter 26 modifies the operands to all the byte codes that refer to entries in the Java class file constant pool 42 to reflect their new location in the card class file constant pool 47.  Fig, 9 shows an example wherein the argument to a byte code, INVOKESTATIC 90, refers to an entry in the Java class file constant pool 42 that is modified to reflect the new location of that entry in the card class file constant pool 47.  The modified operand 94 shows this transformation.  The program code fragment marked "D" in Appendix D shows how these modifications are made.<br>
Once the constant references are relinked, if the optional byte code modification is not being performed, the card class file converter may proceed to the fifth and final pass 67.<br>
Otherwise, the card class file converter modifies the original byte codes into a different set of byte codes supported by the particular Card JVM 16 being used.  One potential modification renumbers the original byte codes 60 into Card JVM 16 byte codes (see Fig, 10).  This renumbering causes the byte codes 100 in the original byte codes 60 to<br><br>
be modified into a renumbered byte codes 102.  Byte code ILOAD recognized by value 21 may be renumbered to be recognized by value 50.  This modification may be done for optimizing the type tests (also known in prior art as Pass 3 checks) in the Card JVM 16.  The program code fragment marked "E" in Appendix D shows an implementation of this embodiment.  This modification may be done in order to reduce the program space required by the Card JVM 16 to interpret the byte code.  Essentially this modification regroups the byte codes into Card JVM 16 byte codes so that byte codes with similar operands, results are grouped together, and there are no gaps between Card JVM 16 byte codes.  This allows the Card JVM 16 to efficiently check Card JVM 16 byte codes and validate types as it executes.<br>
In some embodiments, the card class file converter modifies the original byte codes 60 into a different set of byte codes designed for a different virtual machine architecture, as shown in Fig. 11.  The Java byte code ILOAD 112 intended for use on a word stack 114 may be replaced by Card JVM 16 byte code ILOAD_B 116 to be used on a byte stack 118.  An element in a word stack 114 requires allocating 4 bytes of stack space, whereas an element in the byte stack 118 requires only one byte of stack space.  Although this option may provide an increase in execution speed, it risks losing the security features available in the original byte codes.<br>
Since the previous steps 63, 64 or 66  may have changed the size of the byte codes 60 the card class file converter 26 has to relink 67 any jumps which have been effected.  Since the jumps were recorded in the first step 61 of the card class file converter 26, this adjustment is carried out by fixing the jump destinations to their<br><br>
appropriate values.  The program code fragment marked "F" in Appendix D shows how these jumps are fixed.<br>
The card class file converter now has modified byte codes 68 that is equivalent to the original byte codes 60 ready for loading.  The translation from the Java class file 24a to the card class file 27 is now complete.<br>
Referring back to Fig. 5, if more class files 24 remain to be processed 55 the previous steps 51a, 51b, 51c, 52 and 54 are repeated for each remaining class file.  The card class file converter 26 gathers 56 the maps and modified byte codes for the classes 24 that have been processed, places them as an aggregate and generates 57 a card class file 27.  If required, the card class file converter 26 generates a string to ID output map file 32, that contains a list of all the new IDs allocated for the strings encountered in the constant pool 42 of the Java class files 24 during the translation.<br>
Referring to Fig. 12, the card loader 2 8 within the terminal 14 sends a card class file to the loading and execution control 120 within the integrated circuit card 10 using standard ISO 7816 commands.  The loading and execution control 120 with a card operating system 122, which provides the necessary system resources, including support for a card file system 124, which can be used to store several card applications 126.  Many conventional card loaders are written in low level languages, supported by the card operating system 122.  In the preferred embodiment, the bootstrap loader is written in Java, and the integrated circuit card 10 includes a Java virtual machine to run this application.  A Java implementation of the loading and execution control 120 is illustrated in Appendix E which is hereby incorporated by reference.  The loading and execution control 120 receives the card class file 26 and produces a<br><br>
Java card application 126x stored in .the card file system 126 in the EEPROM of the integrated circuit card 10. Multiple Java card applications 126x, 126y, and 126z can be stored in a single card in this manner.  The loading and execution control 12 0 supports commands whereby the terminal 14 can select which Java card application to run immediately, or upon the next card reset.<br>
Referring to Fig. 13, upon receiving a reset or an execution command from the loading and execution control 120, the Card Java Virtual Machine (Card JVM) 16 begins execution at a predetermined method (for example, main) of the selected class in the selected Java Card application 126z.  The Card JVM 16 provides the Java card application 126z access to the underlying card operating system 122, which provides capabilities such as I/O, EEPROM support, file systems, access control, and other system functions using native Java methods as illustrated in Appendix F which is hereby incorporated by reference.<br>
The selected Java card application 126z communicates with an appropriate application in the terminal 14 using the communicator 12a to establish a communication channel to the terminal 14.  Data from the communicator 12a to the terminal 14 passes through a communicator driver 132 in the terminal, which is specifically written to handle the communications protocol used by the communicator 12a.  The data then passes to an integrated circuit card driver 134, which is specifically written to address the capabilities of the particular integrated circuit card 10 being used, and provides high level software services to the terminal application 136.  In the preferred embodiment, this driver would be appropriate PC/SC Smartcard Service Provider (SSP) software.  The data then passes to the terminal application 136, which must handle the capabilities provided by the<br><br>
particular card application 126z being run. In this manner, commands and responses pass back and forth between the terminal application 136 and the selected card application 126z.  The terminal application interacts with the user, receiving commands from the user, some of which are passed to the selected Java card application 126z, and receiving responses from the Java card application 126z, which are processed and passed back to the user.<br>
Referring to Fig. 14, the Card JVM 16 is an interpreter that interprets a card application 126x.  The memory resources in the microcontroller that impact the Card JVM 16 are the Card ROM 140, Card RAM 141 and the Card EEPROM 142.  The Card ROM 140 is used to store the Card JVM 16 and the card operating system 122.  Card ROM 140 may also be used to store fixed card applications 140a and class libraries 140b.  Loadable applications 141a, 141b and libraries 141c may also be stored in Card RAM 141.  The Card JVM 16 interprets a card application 141a, 141b, or 140a. The Card JVM 16 uses the Card RAM to store the VM stack 144a and system state variables 144b.  The Card JVM 16 keeps track of the operations performed via the VM stack 144a. The objects created by the Card JVM 16 are either on the RAM heap 144c, in the EEPROM heap 146a, or in the file system 147.<br>
All of the heap manipulated by the Card JVM 16 may be stored in the Card RAM 141 as a RAM Heap 144c, or it may be distributed across to the Card EEPROM 142 as a EEPROM Heap 146a.  Card RAM 141 is also used for recording the state of the system stack 148 that is used by routines written in the native code of the microcontroller.  The Card JVM 16 uses the Card EEPROM 142 to store application data either in the EEPROM heap 146a or in the file system 147. Application data stored in a file may be manipulated via an<br><br>
interface to the card operating system 122.  This interface is provided by a class library 140b stored in Card ROM 140, by a loadable class library 141c stored in Card EEPROM 142. One such interface is described in Appendix F.  Applications and data in the card are isolated by a firewall mechanism 149.<br>
To cope with the limited resources available on microcontrollers, the Card JVM 16 implements a strict subset of the Java programming language.  Consequently, a Java application 20 compiles into a class file that contains a strict subset of Java byte codes.  This enables application programmers to program in this strict subset of Java and still maintain compatibility with existing Java Virtual Machines.  The semantics of the Java byte codes interpreted by the Card JVM 16 are described in the aforementioned Java Virtual Machine Specification.  The subset of byte codes interpreted by the Card JVM 16 can be found in Appendix C. The card class file converter 26 checks the Java application 20 to ensure use of only the features available in this subset and converts into a form that is understood and interpreted by the Card JVM 16.<br>
In other embodiments, the Card JVM 16 is designed to interpret a different set or augmented set of byte codes 116.  Although a different byte code set might lead to some performance improvements, departing from a strict Java subset may not be desirable from the point of view of security that is present in the original Java byte codes or compatibility with mainstream Java development tools-<br>
All Card JVM 16 applications 126 have a defined entry point denoted by a class and a method in the class. This entry point is mapped in the string to ID input map 3 0 and assigned by the card class file converter 26.  Classes, methods and fields within a Java application 20 are assigned<br><br>
IDs by the card class file converter 26.  For example, the ID corresponding to the main application class may be defined as F001 and the ID corresponding to its main method, such as "main()v" could be defined as F002.<br>
The overall execution architecture of the Card JVM is described by the flowchart in Fig. 15.  Execution of the Card JVM 16 begins at the execution control 120, which chooses a card application 126z to execute.  It proceeds by finding and assigning an entry point 152 (a method) in this card application for the Card JVM 16 to interpret.  The Card JVM 16 interprets the method 153.  If the interpretation proceeds successfully 154, the Card JVM 16 reports success 155 returning control back to the execution control 120.  If in the course of interpretation 153 the Card JVM 16 encounters an unhandled error or exception (typically a resource limitation or a security violation), the Card JVM 16 stops 156 and reports the appropriate error to the terminal 14.<br>
An essential part of the Card JVM 16 is a subroutine that handles the execution of the byte codes.  This subroutine is described by the flowchart in Fig. 16.  Given a method 160 it executes the byte codes in this method.  The subroutine starts by preparing for the parameters of this method 161.  This involves setting the VM stack 144a pointer, VM stack 144a frame limits, and setting the program counter to the first byte code of the method.<br>
Next, the method flags are checked 162.  If the method is flagged native, then the method is actually a call to native method code (subroutine written in the microcontroller's native processor code).  In this case, the Card JVM 16 prepares for an efficient call 163 and return to the native code subroutine.  The parameters to the native method may be passed on the VM stack 144a or via the System<br><br>
stack 148.  The appropriate security checks are made and the native method subroutine is called.  On return, the result (if any) of the native method subroutine is placed on the VM stack 144a so that it may be accessed by the next byte code to be executed.<br>
The dispatch loop 164 of the Card JVM 16 is then entered. The byte code dispatch loop is responsible for preparing, executing, and retiring each byte code.  The loop terminates when it finishes interpreting the byte codes in the method 160, or when the Card JVM 16 encounters a resource limitation or a security violation.<br>
If a previous byte code caused a branch to be taken 165 the Card JVM prepares for the branch 165a.  The next byte code is retrieved 165b. In order to keep the cost of processing each byte code down, as many common elements such as the byte code arguments, length, type are extracted and stored.<br>
To provide the security offered by the security model of the programming language, byte codes in the class file must be verified and determined conformant to this model.  These checks are typically carried out in prior art by a program referred to as the byte code verifier, which operates in four passes as described in the Java Virtual Machine Specification.  To offer the run-time security that is guaranteed by the byte code verifier, the Card JVM 16 must perform the checks that pertain to the Pass 3 and Pass 4 of the verifier.  This checking can be bypassed by the Card JVM 16 if it can be guaranteed (which is almost impossible to do) that the byte codes 60 interpreted by the Card JVM 16 are secure. At the minimum, code security can be maintained as long as object references cannot be faked and the VM stack 144a and local variable bounds are observed.<br><br>
This requires checking the state of the VM stack 144a with respect to the byte code being executed.<br>
To enforce the security model of the programming language, a 256-byte table is created as shown in Appendix G which is hereby incorporated by reference.  This table is indexed by the byte code number.  This table contains the type and length information associated with the indexing byte code.  It is encoded with the first 5 bits representing type, and the last 3 bits representing length.  The type and length of the byte code is indexed directly from the table by the byte code number.  This type and length is then used for checking as shown in Appendix H which is hereby incorporated by reference.  In Appendix H, the checking process begins by decoding the length and type from the table in Appendix G which is hereby incorporated by reference.  The length is used to increment the program counter.  The type is used first for pre-execution checking, to insure that the data types on the VM stack 144a are correct for the byte code that is about to be executed.  The 256 bytes of ROM for table storage allows the original Java byte codes to be run in the Card JVM 16 and minimizes the changes required to the Java class file to be loaded in the card.  Additional Java byte codes can be easily supported since it is relatively easy to update the appropriate table entries.<br>
In other embodiments, as shown in Fig. 10, the Java byte codes in the method are renumbered in such a manner that the byte code type and length information stored in the table in Appendix H is implicit in the reordering.  Appendix H is hereby incorporated by reference.  Consequently, the checks that must be performed on the state of the VM stack 144a and the byte code being processed does not have to involve a table look up.  The checks can be performed by set<br><br>
of simple comparisons as shown in Appendix I which is hereby incorporated by reference.  This embodiment is preferable when ROM space is at a premium, since it eliminates a 256-byte table.  However adding new byte codes to the set of supported byte codes has to be carefully thought out since the new byte codes have to fit in the implicit numbering scheme of the supported byte codes.<br>
In another embodiment, the Card JVM 16 chooses not to perform any security checks in favor of Card JVM 16 execution speed.  This is illustrated in the flowchart in Fig. 18.  The flow chart in Fig, 18 is the same as that of Fig. 16 with the security checks removed.  This option is not desirable from the point of view of security, unless it can be guaranteed that the byte codes are secure.<br>
The Card JVM 16 may enforce other security checks as well.  If the byte code may reference a local variable, the Card JVM 16 checks if this reference is valid, throwing an error if it is not.  If the reference is valid, the Card JVM 16 stores the type of the local variable for future checking.  The VM stack 144a pointer is checked to see if it is still in a valid range.  If not an exception is thrown. The byte code number is checked.  If it is not supported, an exception is thrown.<br>
Finally, the byte code itself is dispatched 165d, The byte codes translated by the Card JVM 16 are listed in Appendix C.  The semantics of the byte codes are described in the aforementioned Java Virtual Machine Specification with regard to the state of the VM stack 144a before and after the dispatch of the byte code.  Note also that some byte codes (the byte codes, INVOKESTATIC, INVOKESPECIAL, INVOKENONVIRTUAL and INVOKEVIRTUAL) may cause reentry into the Card JVM 16, requiring processing to begin at the entry of the subroutine 161.  Fig. 17 shows the flowchart of the<br><br>
byte code execution routine.  The routine is given a byte code 171 to execute.  The Card JVM 16 executes 172 the instructions required for the byte code.  If in the course of executing the Card JVM 16 encounters a resource limitation 173, it returns an error 156.  This error is returned to the terminal 16 by the Card JVM 16.  If the byte code executes successfully, it returns a success 175.<br>
After execution, the type of the result is used to set the VM stack 144a state correctly 165e, properly flagging the data types on the VM stack 144a.  The byte code information gathered previously 165b from the byte code info table is used to set the state of the VM stack 144a in accordance with the byte code that just executed.<br>
In other embodiments, setting the output state of the VM stack 144a with respect to the byte code executed is simplified if the byte code is renumbered.  This is shown in Appendix I which is hereby incorporated by reference.<br>
In yet another embodiment, the Card JVM 16 may bypass setting the output state of the VM stack 144a in favor of Card JVM 16 execution speed.  This option is not desirable from the point of view of security, unless it can be guaranteed that the byte codes are secure.<br>
After the byte code has been executed, the byte code is retired 165f.  This involves popping arguments off the VM stack 144a.  Once byte code processing is completed, the loop 164 is repeated for the next byte code for the method.<br>
Once the dispatch loop 164 terminates, the VM stack 144a is emptied 166. This prevents any object references filtering down to other Card JVM 16 invocations and breaking the Card JVM's 16 security.  Termination 167 of the byte code dispatch loop 164 indicates that the Card JVM 16 has completed executing the requested method.<br><br>
To isolate data and applications in the integrated circuit card 10 from each other, the integrated circuit card 10 relies on the firewall mechanism 149 provided by the Card JVM 16.  Because the Card JVM implements the standard pass 3 and pass 4 verifier checks, it detects any attempt by an application to reference the data or code space used by another application, and flag a security error 156.  For example, conventional low level applications can cast non-reference data types into references, thereby enabling access to unauthorized memory space, and violating security. With this invention, such an attempt by a card application 126z to use a non-reference data type as a reference will trigger a security violation 156.  In conventional Java, this protected application environment is referred to as the sandbox application-interpretation environment.<br>
However, these firewall facilities do not work independently.  In fact, the facilities are overlapping and mutually reinforcing with conventional access control lists and enc2ryption mechanisms shown in the following table:<br><br><br>
Taken together, these facilities isolate both data and applications on the integrated circuit card 10 and ensure that each card application 126 can access only the authorized resources of the integrated circuit card 10.<br>
Referring to Fig. 19, card applications 126x, 126y, 126z can be endowed with specific privileges when the card applications 126 execute.  These privileges determine, for example, which data files the card applications 126 can access and what operations the card applications 126 can perform on the file system 147.  The privileges granted to the card applications 126 are normally set at the time that a particular card application 126z is started by the user, typically from the terminal 14.<br>
The integrated circuit card 10 uses cryptographic identification verification methods to associate an identity 190 (e.g., identities 190a, 190b and 190c) and hence, a set of privileges to the execution of the card application 126. The association of the specific identity 190c to the card application 126z is made when the card application 126z begins execution, thus creating a specific running application 200, as shown in Fig. 20.  The identity 190 is a unique legible text string reliably associated with an identity token.  The identity token (e.g., a personal identification number (PIN) or a RSA private key) is an encryption key.<br>
Referring to Fig. 20, in order to run a specific card application 126z, the identity 190c of the card application 126z must be authenticated.  The identity 190c is authenticated by demonstrating knowledge of the identity token associated with the identity 190c.  Therefore, in order to run the card application 126z, an agent (e.g., a card holder or another application wishing to run the<br><br>
application) must show that it possesses or knows the application's identity-defining encryption key.<br>
One way to demonstrate possession of an encryption key is simply to expose the key itself.  PIN verification is an example of this form of authentication.  Another way to demonstrate the possession of an encryption key without actually exposing the key itself is to show the ability to encrypt or decrypt plain text with the key.<br>
Thus, a specific running application 200 on the integrated circuit card 10 includes a card application 126z plus an authenticated identity 190c.  No card application 126 can be run without both of these elements being in place.  The card application 126z defines data processing operations to be performed, and the authenticated identity 190c determines on what computational objects those operations may be performed.  For example, a specific application 126z can only access identity C's files 202 in the file system 147 associated with the specific identity 190c, and the specific card application 126z cannot access other files 204 that are associated with identities other than the specific identity 190c.<br>
The integrated circuit card 10 may take additional steps to ensure application and data isolation.  The integrated circuit card 10 furnishes three software features sets: authenticated-identity access control lists; a Java-based virtual machine; and one-time session encryption keys to protect data files, application execution, and communication channels, respectively.  Collectively, for one embodiment, these features sets provide the application data firewalls 149 for one embodiment.  The following discusses each software feature set and then shows how the three sets work together to insure application and data isolation on the integrated circuit card 10.<br><br>
An access control list (ACL) is associated with every computational object (e.g., a data file or a communication channel) on the integrated circuit card 10 that is be protected, i.e., to which access is to be controlled.  An entry on an ACL (for a particular computational object) is in a data format referred to as an e-tuple:<br>
type:identity:permissions The type field indicates the type of the following identity (in the identity field), e.g., a user (e.g., "John Smith"), or a group.  The permissions field indicates a list of operations (e.g., read, append and update) that can be performed by the identity on the computational object.<br>
As an example, for a data file that has the ACL entry:<br>
USER:AcmeAirlines:RAU, any application whose identity is "AcmeAirlines" can read ("R"), append ("A") and update ("U") the data file.  In addition, the ACL may be used selectively to permit the creation and deletion of data files.  Furthermore, the ACL may be used selectively to permit execution of an application.<br>
Whenever a computational object is accessed by a running application 200, the access is intercepted by the Card JVM 16 and passed to the card operating system 122, which determines if there is an ACL associated with the object.  If there is an associated ACL, then the identity 190c associated with the running application 2 00 is matched on the ACL-  If the identity is not found or if the identity is not permitted for the type of access that is being requested, then the access is denied.  Otherwise, the access is allowed to proceed.<br><br>
Referring to Fig. 13, to prevent the potential problems due to the single data path between the integrated circuit card 10 and the terminal 14, communication channel isolation is accomplished by including in the identity authentication process the exchange of a one-time session key 209 between the a card application 126z and the terminal application 136.  The key 209 is then used to encrypt subsequent traffic between the authenticating terminal application 136 and the authenticated card application 126z. Given the one-time session key 209, a rogue terminal application can neither "listen in" on an authenticated communication between the terminal 14 and the integrated circuit card 10, nor can the rogue terminal application "spoof" the card application into performing unauthorized operations on its behalf.<br>
Encryption and decryption of card/terminal traffic can be handled either by the card operating system 122 or by the card application itself 126z.  In the former case, the communication with the terminal 14 is being encir^ted transparently to the application, and message traffic arrives decrypted in the data space of the application.  In the latter case, the card application 1262 elects to perform encryption and decryption to provide an extra layer of security since the application could encrypt data as soon as it was created and would decrypt data only when it was about to be used.  Otherwise, the data would remain encrypted with the session key 209.<br>
Thus, the application firewall includes three mutually reinforcing software sets.  Data files are protected by authenticated-identity access control lists. Application execution spaces are protected by the Card JVM 16.  Communication channels are protected with one-time session encryption keys 209.<br><br>
In other embodiments, the above-described techniques are used with a microcontroller (such as the processor 12) may control devices (e.g., part of an automobile engine) other than an integrated circuit card.  In these applications, the microcontroller provides a small platform (i.e., a central processing unit, and a memory, both of which are located on a semiconductor substrate) for storing and executing high level programming languages.  Most existing devices and new designs that utilize a microcontroller could use this invention to provide the ability to program the microcontroller using a high level language, and application of this invention to such devices is specifically included.<br>
The term application includes any program, such as Java applications, Java applets, Java aglets, Java servlets, Java commlets, Java components, and other non-Java programs that can result in class files as described below.<br>
Class files may have a source other than Java program files.  Several programming languages other than Java also have compilers or assemblers for generating class files from their respective source files.  For example, the programming language Eiffel can be used to generate class files using Pirmin Kalberer's "J-Eiffel", an Eiffel compiler with JVM byte code generation (web site:<br>
http://www.spin.ch/-kalberer/jive/index.htm).  An Ada 95 to Java byte code translator is described in the following reference (incorporated herein by reference): Taft, S. Tucker, "Programming the Internet in Ada 95", proceedings of Ada Europe '96, 1996.  Jasmin is a Java byte code assembler that can be used to generate class files, as described in the following reference (incorporated herein by reference): Meyer, Jon and Troy Downing, "Java Virtual Machine", O'Reilly, 1997.  Regardless of the source of the class<br><br>
files, the above description applies to languages other than Java to generate codes to be interpreted.<br>
Fig, 21 shows an integrated circuit card, or smart card, which includes a microcontroller 210 that is mounted to a plastic card 212.  The plastic card 212 has approximately the same form factor as a typical credit card. The communicator 12a can use a contact pad 214 to establish a communication channel, or the communicator 12a can use a wireless communication system.<br>
In other embodiments, a microcontroller 210 is mounted into a mobile or fixed telephone 220, effectively adding smart card capabilities to the telephone, as shown in Fig. 22.  In these embodiments, the microcontroller 210 is mounted on a module (such as a Subscriber Identity Module (SIM)), for insertion and removal from the telephone 220.<br>
In other embodiments, a microcontroller 210 is added to a key ring 230 as shown in Fig. 23.  This can be used to secure access to an automobile that is equipped to recognize the identity associated with the microcontroller 210 on the key ring 23 0.<br>
Jewelry such as a watch or ring 240 can also house a microcontroller 210 in an ergonomic manner, as shown in Fig, 24.  Such embodiments typically use a wireless communication system for establishing a communication channel, and are a convenient way to implement access control with a minimum of hassle to the user.<br>
Fig. 25 illustrates a microcontroller 210 mounted in an electrical subsystem 252 of an automobile 254.  In this embodiment, the microcontroller is used for a variety of purposes, such as to controlling access to the automobile, (e.g. checking identity or sobriety before enabling the ignition system of the automobile), paying tolls via wireless communication, or interfacing with a global<br><br>
positioning system (GPS) to track the location of the automobile, to name a few.<br>
While specific embodiments of the present invention have been described, various modifications and substitutions will become apparent to one skilled in the art by this disclosure.  Such modifications and substitutions are within the scope of the present invention, and are intended to be covered by the appended claims.<br><br>
APPENDIX A<br>
Card Class File Format For Preferred Embodiment<br>
Introduction<br>
The card class file is a compressed form of the original class file(s). The card class file contains only the semantic information required to interpret Java programs from the original class files. The indirect references in the original class file are replaced with direct references resulting in a compact representation. The card class file format is based on the following principles:<br>
Stay close to the standard class file format: The card class file format should remain as close to the standard class file format as possible. The Java byte codes in the class file remain unaltered. Not altering the byte codes ensures that the structural and static constraints on them remain verifiably intact.<br>
Ease of implementation: The card class file format should be simple enough to appeal to Java Virtual Machine implementers. It must allow for different yet behaviorally equivalent implementations.<br>
Feasibility: The card class file format must be compact in order to accommodate smart card technology. It must meet the constraints of today's technology while not losing sight of tomorrow's innovations.<br>
This document is based on Chapter 4, "The class file format", in the book titled "The Java™ Virtual Machine Specification"[1], henceforth referred to as the Red book. Since the document is based on the standard class file format described in the Red book, we only present information that is different. The Red book serves as the final authority for any clarification. The primary changes from the standard class file fonnat are:<br>
The constant pool is optimized to contain only 16-bit identifiers and, where possible, indirection is replaced by a direct reference.<br>
Attributes in the original class file are eliminated or regrouped.<br>
The Java Card class File Format<br>
This section describes the Java Card class file format. Each card class file contains one or many Java types, where a type may be a class or an interface.<br>
A card class file consists of a stream of 8-bit bytes. All 16-bit, 32-bit. and 64-bit quantities arc constructed by reading in two. four, and eight consecutive 8-bit bytes, respectively. Multi-byte data items are always stored in big-endian order, where the high bytes come first. In Java, this format is supported by interfaces java.io.DataInput and java.io.DataOutput and classes such as java.io.DataInputStream and java.io.DataOutputStream.<br>
We define and use the same set of data types representing Java class file data: The types ul, u2, and u4 represent an unsigned one-, two-, or four-byte quantity, respectively. In Java, these types may be read by methods such as readUnsignedByte, readUnsignedShort, and readint of the interface java.io.DataInput. The card class file fonnat is presented using pseudo-structures written in a C-like structure notation. To avoid confusion with the fields of Java Card Virtual Machine classes and class instances, the contents of the structures describing the card class file fonnat are refened to as items. Unlike the fields of a C structure, successive items are stored in the card class file sequentially, without padding or alignment. Variable-sized tables, consisting of variable-sized items, are used in several class file structures. Although we will use C-like array syntax to refer to table items, the fact that tables are streams of varying-sizcd structures means that it is not possible to directly translate a table index into a byte offset into the table. Where we refer to a data structure as an array, it is literally an array.<br>
In order to distinguish between the card class file structure and the standard class file structure, we add capitalization; for example, we rename field_info in the original class file to Fieldlnfo in the card class file.<br><br>
1<br>
Card Class File<br>
A card class file contains a single CardCIassFile structure: CardClassFile ( ul major_version; ul minor_version; u2 name_ndex; u2 const_size: u2 max.class;<br>
CpInfoconstant_pool[const_size]; Classlnfo class(max_class];<br>
} The items in the CardClassFile structure are as follows: minor.version, major.version<br>
The values of the minor.version and major_version items are the minor and major version numbers of the off-card Java Card Virtual Machine that produced this card class file. An implementation of the Java Card Virtual Machine normally supports card class files having a given major version number and minor version numbers 0 through some pardcuiar minor.version.<br>
Only the Java Card Forum may define the meaning of card class file version numbers. namejndex<br>
The value of the name_index item must represent a valid Java class name. The Java class name represented by name_ndex must be exactly the same Java class name that corresponds to the main application that is to run in the card. A card class file contains several classes or interfaces that constitute the application that runs in the card. Since Java allows each class to contain a main method there must be a way to distinguish the class file containing the main method which corresponds to the card application. const_size<br>
The value of const.size gives the number of entries in the card class file constant pool. A constant_pool index is considered valid if it is greater than or equal to zero and less than const_size. max_class<br>
This value refers to the number of classes present in the card class file. Since the name resolution and linking in the Java Card are done by the off-card Java Virtual Machine all the class files or classes required for an application are placed together in one card class file. constant_pool<br>
The constant_pool is a table of variable-length structures (0) representing various siring constants, class names, field names, and other constants that are referred to within the CardClassFile structure and its substructures.<br>
The first entry in the card class file is constant_pool[0].<br>
Each of the consiant_pool table entries at indices 0 through const_size is a variable-length structure (0). class(] The class is a table of max.class classes that constitute the application loaded onto the card.<br>
Constant Pool<br>
All constant_pool table entries have the following general format: CpInfo{ ul tag; ul info[];<br>
} Each item in the constant_pool table must begin with a 1-byte tag indicating the kind of cp Jnfo entry. The contents of the info array varies with the value of tag. The valid tags and their values are the same as those specified in the Red book.<br>
Each tag byte must be followed by two or more bytes giving information about the specific constant. The format of the additional information varies with the tag value. Currently the only tags that need to be included are CONSTANT.Class, CONSTANT.FieldRef, CONSTANT.MethodRef and CONST ANT_InterfaceRef. Support for other tags be added as they are included in the specification.<br><br>
The CONSTANT_Class,info structure is used to represent a class or an interface: CONSTANT.ClassInfo { ul tag; u2 name_ndex:<br>
1 The items of the CONSTANT_CIassJnfo structure are the following: tag<br>
The lag item has the value CONSTANT_Class (7). name_index<br>
The value of the name_index item must represent a valid Java class name. The Java class name represented by namejndex must be exactly the same Java class name that is described by the corresponding CONSTANT_Class entry in the constant_pool of the original class file. CONSTANT.Fieldrcf, CONSTANT.Methodref, and CONSTANT JnterfaceMethodref Fields, methods, and interface methods are represented by similar structures: CONSTANT.Fieldreflnfo {<br>
ul tag;<br>
u2 class Jndex;<br>
u2 name_sig_index;<br>
} CONSTANT_Melhodreflnfo {<br>
u1 tag;<br>
u2 class Jndex;<br>
u2 name_sig_index;<br>
} CONSTANT_InterfaceMethodreflnfo { ul tag;<br>
u2 class Jndex;<br>
u2 namc_sig_index;<br>
} The items of these structures are as follows: tag<br>
The tag item of a CONSTANT.Fieldreflnfo structure has the value CONSTANT.Fieldref (9). The tag item of a CONSTANT_Methodreflnfo structure has the value CONSTANT_Methodref (10). The tag item of a CONSTANT JnterfaceMethodreflnfo structure has the value CONSTANT JnterfaceMethodref (11). ciasssjndex<br>
The value of the class_index item must represent a valid Java class or interface name. The name represented by class Jndex must be exactly the same name that is described by the corresponding CONSTANT.CIassJnfo entry in the constant_pool of the original class file. name_sig_index<br>
The value of the name_sig_index item must represent a valid Java name and type. The name and type represented by name.sigjndex must be exactly the same name and type described by the CONSTANT.NamcAndTypc -Info entry in the constant_pool structure of the original class file.<br>
Class<br>
Each class is described by a fixed-length Classlnfo structure. The format of this structure is: Classlnfo (<br>
u2 name_ndex: ul max_field; ul max_field; ul max_method; ul max_interface; u2 superclass; u2 access_flags;<br><br>
Fieldlnfo rielcl[max_field+max_sfieid];<br>
Interfacelnfo interface(max_interface];<br>
Methodlnfo method[max_method; } The items of the Classlnfo structure arc as follows: name_ndex<br>
The value of the name_ndex item must represent a valid Java class name. The Java class name represented by namejndex must be exactly the same Java class name that is described in the corresponding ClassFile structure of the original class file. max_field<br>
The value of the max_field item gives the number of Fieldlnfo (0) structures in the field table that represent the instance variables, declared by this class or interface type. This value refers to the number of non-static the fields in the card class file. If the class represents an interface the value of max_field is 0. max_sfield<br>
The value of the max_sfield item gives the number of Fieldlnfo structures in the field table that represent the class variables, declared by this class or interface type. This value refers to the number of static the fields in the card class file. max_method<br>
The value of the max_method item gives the number of Methodlnfo (0) structures in the method table. max_nterface<br>
The value of the maxjnterface item gives the number of direct superinterfaces of this class or interface type.<br>
superclass<br>
For a class, the value of the superclass item must represent a valid Java class name. The Java class name  represented by superclass must be exactly the same Java class name that is described in the corresponding ClassFile structure of the original class file. Neither the superclass nor any of its superclasses may be a final class.<br>
If the value of superclass is 01 then this class must represent the class java.lang.Object, the only class or interface without a superclass.<br>
For an interface, the value of superclass must always represent the Java class java.lang.Object. access_flags<br>
The value of the access_flags item is a mask of modifiers used with class and interface declarations. The acccss_flags modifiers and their values are the same as the access_flags modifiers in the corresponding ClassFile structure of the original class file. field[]<br>
Each value in the field table must be a fixed-length Fieldlnfo (0) structure giving a complete description of a field in the class or interface type. The field table includes only those fields that are declared by this class or interface. It does not include items representing fields that are inherited from superclasses or superinterfaces. interface[]<br>
Each value in the interface array must represent a valid interface name. The interface name represented by each entry must be exactly the same interface name that is described in the corresponding interface array of the original class file.<br>
method[]<br>
Each value in the method table must be a variable-length Methodlnfo (0) structure giving a complete description of and Java Virtual Machine code for a method in the class or interface. The Methodlnfo structures represent all methods, both instance methods and, for classes, class (static) methods, declared by this class or interface type. The method table only includes those methods that are explicitly declared by this class. Interfaces have only the single method <clinit>, the interface initialization method. The methods table docs not include items representing methods that are inherited from superclasses or superinterfaces.<br>
' Or a standard vet fixed value.<br><br>
Fields<br>
Each field is described by a fixed-length fieId_info structure. The format of this structure is Fieldlnfo (<br>
u2 name_ndex; u2 signature_index; u2 access_fla2s;<br>
) The items of the Fieldlnfo structure are as follows: name_index<br>
The value of the name_index item must represent a valid Java field name. The Java field name represented by name_index must be exactly the same Java field name that is described in the corresponding field_info structure of the original class file. signaturejndex<br>
The value of the signature_index item must represent a valid Java field descriptor. The Java field descriptor represented by signature index must be exactly the same Java field descriptor that is described in the corresponding field _info structure of the original class file. access_flags<br>
The value of the access_flags item is a mask of modifiers used to describe access permission to and properties of a field. The access_flags modifiers and their values are the same as the access_flags modifiers in the corresponding field_info structure of the original class file.<br>
Methods<br>
Each method is described by a variable-length Method_info structure. The Methodlnfo structure is a variable-length structure that contains the Java Virtual Machine instructions and auxiliary information for a single Java method, instance initialization method, or class or interface initialization method. The structure has the following format: Methodlnfo { u2 name_ndex; u2 signature_ndex; ui max_local; ul max_arg; ui max_stack; ul access_fiags; u2 code_length; u2 exception_length; ul code[code_ength]; {       u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; } einfo[exception length};<br>
} The items of the Methodlnfo structure are as follows: namejndex<br>
The value of the name_ndex item must represent either one of the special internal method names, either <init> or <clinit>, or a valid Java method name. The Java method name represented by name_index must be exactly the same Java method name that is described in the corresponding method Jnfo structure of the original class file. signaturejndex<br>
The value of the signature_index item must represent a valid Java method descriptor. The Java method descriptor represented by signature_ndex must be exacdy the same Java method descriptor that is described in the corresponding method Jnfo structure of the original class file. maxjocai<br><br>
The value of the max_locals item gives the number of local variables used by this method, excluding the<br>
parameters passed to the method on invocation. The index of the first local variable is 0. The greatest local<br>
variable index for a one-word value is maxjocals-1.<br>
max_arg<br>
The value of the max_arg item gives the maximum number of arguments to this method.<br>
max .stack<br>
The value of the max_stack item gives the maximum number of words on the operand stack at any point<br>
during execution of this method.<br>
access.flags<br>
The value of the access_flags item is a mask of modifiers used to describe access permission to and<br>
properties of a method or instance initiaiizadon method.. The access.flags modifiers and their values are<br>
the same as the access_flags modifiers in the corresponding method_info structure of the original class file.<br>
code_length<br>
The value of the code_engdi item gives the number of bytes in the code array for this method. The value of<br>
code_length must be greater than zero; the code array must not be empty.<br>
exception_length<br>
The value of the exception_length item gives the number of entries in the exception_info table.<br>
coded<br>
The code array gives the actual bytes of Java Virtual Machine code that implement the method. When the<br>
code array is read into memory on a byte addressable machine, if the first byte of the array is aligned on a 4-<br>
byte boundary, the tableswitch and lookupswitch 32-bit offsets will be 4-byte aligned; refer to the<br>
descriptions of those instructions for more information on the consequences of code array alignment.<br>
The detailed constraints on the contents of the code array are extensive and are the same as described in the<br>
Java Virtual Machine Specification.<br>
einfo[]<br>
Each entry in the einfo array describes one exception handier in the code array. Each einfo entry contains<br>
the following items:<br>
start_pc, end_pc<br>
The values of the two items start_pc and end_pc indicate the ranges in the code array at which the exception<br>
handler is active.<br>
The value of start_pc must be a valid index into the code array of the opcode of an instruction. The value of<br>
end.pc either must be a valid index into the code array of the opcode of an instruction, or must be equal to<br>
code_length, the length of the code array. The value of start_pc must be less than the value of end_pc.<br>
The start_pc is inclusive and end_pc is exclusive; that is, the exception handler must be active while the<br>
program counter is within the interval [start_pc, end_pc).<br>
handier.pc<br>
The value of the handler_pc item indicates the start of the exception handler. The value of the item must be<br>
a valid index into the code array, must be the index of the opcode of an instruction, and must be less than<br>
the value of the codejength item.<br>
catch_type<br>
If the value of the catch _ype item is nonzero, it must represent a valid Java class type. The Java class type<br>
represented by catch _type must be exactiy the same as the Java class type that is described by the<br>
catch jype in the corresponding method _nfo structure of the original class file. This class must be the class<br>
Throwable or one of its subclasses. The exception handler will be called only if the thrown exception is an<br>
instance of the given class or one of its subclasses.<br>
If the value of the catch_type item is zero, this exception handler is called for all exceptions. This is used to<br>
implement finally.<br>
Attributes<br>
Attributes used in the original class file are either eliminated or regrouped for compaction. The predefined attributes SourceFile, ConstantValue, Exceptions, LineNumberTable, and Local-VariableTable may be eliminated without sacrificing any information required for Java byte code interpretation.<br><br>
The predefined attribute Code which contains ail the byte codes for a particular method are moved in the corresponding Methodlnfo structure.<br>
Constraints on Java Card Virtual Machine Code<br>
The Java Card Virtual Machine code for a method, instance initialization method, or class or interface initialization method is stored in the array code of the Methodlnfo structure of a card class file. Both the static and the structural constraints on this code array are the same as those described in the Red book. Limitations of the Java Card Virtual Machine and Java Card class File Format<br>
The following limitations in the Java Card Virtual Machine are imposed by this version of the Java Card Virtual Machine specification:<br>
The per-card class file constant pool is limited to 65535 entries by the 16-bit const.size field of the CardClassFile structure (0). This acts as an internal limit on the total complexity of a single card class file. This count also includes the entries corresponding to the constant pool of the class hierarchy available to the application in the card.2<br>
The amount of code per method is limited to 65535 bytes by the sizes of the indices in the Methodlnfo structure.<br>
The number of local variables in a method is limited to 255 by the size of the max _local item of the Methodlnfo structure (0).<br>
The number of fields of a class is limited to 510 by the size of the max_field and the max_sfield items of the Classlnfo structure (0).<br>
The number of methods of a class is limited to 255 by the size of the max,method item of the Classlnfo structure (0).<br>
The size of an operand stack is limited to 255 words by the max_stack field of the Methodlnfo structure (0).<br>
Bibliography<br>
[1] Tim Lindhoim and Frank Yellin, The Java Virtual Machine Specification, Addison-Wesley. 1996.<br>
• A single card class file constant pool has 65535-A entries available, where A corresponds to the number of entries in the constant pool of the class hierarchies accessible to the application.<br><br>
APPENDIX B<br>
string To ID Input And Output<br>
For the correct operation of Card JVM it is very important that the declared and generated IDs are correctly managed. This management is controlled by the definitions in the string to ID input file String-ID INMap. This textual file, the basis for which is shown below, declares which areas of the namespace can be used for what purposes. One possible arrangement of this map may reserve some IDs for internal use by the Card JVM interpreter, and the rest is allocated to Card JVM applications.<br><br>
Essentially, all applications which are to be loaded into a smart card are allocated their own IDs within the 0x4000 to 0x7FFF. This space is free for each application since no loaded application is permitted to access other applications.<br>
Care must be taken on managing the IDs for preloaded class libraries. The management of these IDs is helped by the (optional) generation of the string to ID output file String-ID OUTMap file. This map is the String-ID INMap augmented with the new String-ID bindings. These bindings may be produced when the Card Class File Converter applicadon terminates. The String-ID OUTMap is generated for support libraries and OS interfaces loaded on the card. This map may be used as the String-ID INMap for smart card applications using the support libraries and OS interfaces loaded on the card. When building new applications this file can generally be discarded.<br><br>
As an example consider the following Java program. HelloSmanCard.java. When compiled it generates a class file HelloSmartCard.class. This class file has embedded in it strings that represent the class name, methods and type information. On the basis of the String-ID INMap described above Card Class File Converter generates a card class file that replaces the strings present in the class file with IDs allocated by Card Class File Convener. Table I lists the strings found in the constant pool of HelloSmanCard.ciass with their respective Card Class File Convener assigned IDs. Note that some strings (like "java/lang/Object") have a pre-assigned value (F002) and some strings (like "() V") get a new value (4004).<br><br><br>
APPENDIX C<br>
Byte codes supported by the Card JVM in the preferred embodiment<br><br><br><br><br><br><br><br><br>
APPENDIX D<br>
Card Class File Converter byte code conversion process<br>
! <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
APPENDIX G<br>
Byte Code Attributes Tables<br>
Dividing Java byte codes into type groups<br>
Each bytecode is assigned a 5 bit type associated with it. This is used to group the codes into similarly behaving sets. In general this behaviour reflects how the types of byte codes operate on the stack, but types 0, 13, 14, and 15 reflect specific kinds of instructions as denoted in the comments section.<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
APPENDIX H<br>
Checks Done On Java Byte Codes By Type<br><br><br>
APPENDIX I<br>
Checks Done On Renumbered Java Byte Codes<br><br><br><br><br><br><br><br><br><br><br><br>
WE CLAIM:<br>
1.	An integrated circuit card for use with a<br>
terminal, comprising:<br>
a communicator configured to communicate with the terminal;<br>
a memory storing:<br>
an application having a high level programming language format, and<br>
an interpreter; and<br>
a processor coupled to the memory, the processor configured to use the interpreter to interpret the application for execution and to use the communicator to communicate with the terminal.<br>
2.	The integrated circuit card of claim 1, wherein the high level programming language format comprises a class file format.<br>
3.	The integrated circuit card of claim 1 wherein the processor comprises a microcontroller.<br><br>
4.	The integrated circuit card of claim 1 wherein at least a portion of the memory is located in the processor,<br>
5.	The integrated circuit card of claim 1 wherein the high level programming language format comprises a Java programming language format.<br><br>
6.	The integrated circuit card of claim 1, wherein<br>
the application has been processed from a<br>
second application having a string of characters, and<br>
the string of characters is represented in the first application by an identifier.<br>
7.	The integrated circuit card of claim 6, wherein the identifier comprises an integer.<br>
8.	The integrated circuit card of claim 1 wherein the processor is further configured to:<br>
receive a request from a requester to access an element of the card;<br>
after receipt of the request, interact with the requester to aut aenticate an identity of the requester; and<br>
based on the identity, selectively grant access to the element.<br>
9.	The integrated circuit card of claim 8, wherein the requester comprises the processor.<br>
10.	The integrated circuit card of claim 8, wherein the recluester comprises the terminal.<br>
11.	They integrated circuit card of claim 8, wherein<br>
the element comprises the application stored in<br>
the memory, and<br>
once access is allowed, the requester is configured to use the application.<br>
12.	The integrated circuit card of claim 8, wherein<br>
the element comprises another application<br>
stored in the memory.<br><br>
13.	The integrated circuit card of claim 8, wherein the element includes data stored in the memory.<br>
14.	The integrated circuit card of claim 8 wherein the element comprises the communicator.<br>
15.	The integrated circuit card of claim 8, wherein the memory also stores an access control list for the element, the access control list furnishing an indication of types of access to be granted to the identity, the processor further configured to:<br>
based on the access control list, selectively grant specific types of access to the requester.<br>
16.	The integrated circuit card of claim 15 wherein the types of access include reading data.<br>
17.	The integrated circuit card of claim 15 wherein the types of aciess include writing data.<br>
18.	The integrated circuit card of claim 15 wherein the types of access include appending data.<br><br>
19.	The integrated circuit card of claim 15 wherein the types of access include creating data.<br>
20.	The integrated circuit card of claim 16 wherein the types of access include deleting data.<br>
21.	The integrated circuit card of claim 15 wherein the types of access include executing an application.<br><br>
22.	The integrated circuit card of claim 1, wherein<br>
the application is one of a plurality of applications stored<br>
in the memory, the processor is further configured to:<br>
recessive a request from a requester to access one of the plurality of applications;<br>
after receipt of the request, determine whether said one of the plurality of applications complies with a predetermined sec of rules; and<br>
based on the determination, selectively grant access to the requester to said one of the plurality of applications.<br>
23.	The integrated circuit card of claim 22, wherein the predetermined rules provide a guide for determining whether said one of the plurality of applications accesses a predetermined region of the memory.<br>
24.	The integrated circuit card of claim 22, wherein the processor is further configured to:<br>
authenticate an identity of the requester; and grant access to said one of the plurality of applications based on the identity.<br>
25.	The integrated circuit card of claim 1, wherein<br>
the processor is further configured to:<br>
interact with the terminal via the communicator to authenticate an identity; and<br>
determine if the identity has been authenticated; and<br>
based on the determination, selectively allow communication between the terminal and the integrated circuit card.<br><br>
26.	The integrated circuit card of claim 25, wherein the communicator and the terminal communicate via communication channels, the processor further configured to assign one of the communication channels to the identity when the processor allows the communication between the terminal and the; integrated circuit card.<br>
27.	The integrated circuit card of claim 26, wherein the processor is further configured to:<br>
assign a session key to said one of the communication channels, and<br>
use the session key when the processor and the terminal communicate via said one of the communication channels.<br>
28.	The integrated circuit card of claim 1, wherein the terminal has a card reader and the communicator comprises a contact for communicating with the card reader.<br>
29.	The integrated circuit card of claim 1, wherein the terminal has a wireless communication device and the communictor a wireless transceiver for communicating with the wireless communication device.<br>
30.	The integrated circuit card of claim 1, wherein<br>
the terminal has a wireless communication device and the<br>
communicator comprises a wireless transmitter for<br>
communicating with the wireless communication device.<br><br>
31.	A method for use with an integrated circuit<br>
card and a terminal, comprising:<br>
storing an interpreter and an application having a high level programming language format in a memory of the integrated circuit card; and<br>
using a processor of the integrated circuit card to use the interpreter to interpret the application for execution; and<br>
using a communicator of the card when communicating between the processor and the terminal,<br>
32.	The method of claim 31, wherein the high level programming language format comprises a class file format.<br>
33.	The method of claim 31, wherein the processor comprises a microcontroller.<br>
34.	The method of claim 31, wherein at least a portion of the memory is located in the processor.<br><br>
35.	The method of claim 31, wherein the high level programming language format comprises a Java programming language format<br>
36.	The method of claim 1, wherein<br>
the application has been processed from a second application having a string of characters, further comprising:<br>
representing the string of characters in the first application by an identifier.<br>
37.	The method of claim 36, wherein the identifier<br>
includes an integer.<br><br>
38.	The method of claim 31, further comprising:<br>
receiving a request from a requester to access<br>
an element of the  card;<br>
after receipt of the request, interacting with the requester to authenticate an identity of the requester; and<br>
based on the identity, selectively granting access to the element.<br>
39.	The method of claim 38, wherein the requester comprises the processor.<br>
40.	The method of claim 38, wherein the requester comprises the terminal,<br>
41.	The method of claim 38, wherein the element comprises the application stored in the memory, further comprising:<br>
once access is allowed, using the application with the requester-<br>
42.	The method of claim 38, wherein the element comprises another application stored in the memory.<br>
43.	The method of claim 38, wherein the element includes data stored in the memory.<br>
44.	The method of claim 38, wherein the element comprises the communicator.<br><br>
45.	The method of claim 38, wherein the memory also<br>
stores an access control list for the element, the access<br>
control list furnishing an indication of types of access to<br>
be granted to the identity, further comprising:<br>
based of the access control list, using the processor to seltictively grant specific types of access to the requester.<br>
46.	The method of claim 45, wherein the types of access include reading data.<br>
47.	The method of claim 45, wherein the types of access include waiting data.<br>
48.	The method of claim 45, wherein the types of access include appending data.<br>
49.	The method of claim 45, wherein the types of access include creating data.<br>
50.	The method of claim 45, wherein the types of access include deleting data.<br>
51.	The method of claim 45, wherein the types of<br>
access including executing an application.<br><br>
52.	The method of claim 31, wherein the application<br>
is one of a plurality of applications stored in the memory,<br>
further comprising:<br>
receivin: a request from a requester to access one of the applications stored in the memory;<br>
upon receipt of the request, determining whether said one of the plurality of applications complies with a predetermined set of rules; and<br>
based on the determining, selectively granting access to the said one of the plurality of applications.<br>
53.	The method of claim 52, wherein the<br>
predetermined r.iles provide a guide for determining whether<br>
said one of the plurality of applications accesses a<br>
predetermined region of the memory.<br>
54.	The method of claim 52, further comprising:<br>
authenticating an indentity of the requester; and<br>
based on the indencity, granting access to said one<br>
of the plurality of applications.<br>
55.	The method of claim 31, further comprising:<br>
conmunicating with the terminal to authenticate<br>
an identity;<br>
determining if the identity has been authenticated; and<br>
based on the determining, selectively allowing communication between the terminal and the integrated circuit card.<br><br>
56.	The method of claim 55, further comprising:<br>
communcating between the terminal and the<br>
processor via communication channels; and<br>
assigning one of the communication channels to the identity when the allowing allows communication between the card reader and the integrated circuit card.<br>
57.	The method of claim 56, further comprising:<br>
assigning a session key to said one of the<br>
communication channels; and<br>
using the session key when the processor and the terminal communicate via said one of the communication channels.<br><br>
58.	A srrart   card comprising:<br>
a memory storing a Java interpreter; and a processor configured to use the interpreter to interpret a Java application for execution.<br>
59.	A microcontroller comprising:<br>
a semiconductor substrate;<br>
a memory located in the substrate;<br>
a programming language interpreter stored in the memory and configured to implement security checks; and<br>
a central processing unit located in the substrate and coupled to the memory.<br>
60.	The microcontroller of claim 59, wherein the interpreter comprises a Java byte code interpreter.<br>
61.	The microcontroller of claim 59, wherein the security checks comprise establishing firewalls.<br>
62.	The microcontroller of claim 59, wherein the security checks comprise enforcing a sandbox security model<br>
63.	A smart card comprising:<br>
a memory;<br>
a programming language interpreter stored in the memory and configured to implement security checks; and<br>
a central processing unit coupled to the memory.<br>
64.	The smart card of claim 63, wherein the<br>
interpreter comprises a Java byte code interpreter.<br><br>
65.	The smart card of claim 63, wherein the security checks comprise establishing firewalls.<br>
66.	The smarc card of claim 63, wherein the security checks comprise enforcing a sandbox security model.<br>
67.	An integrated circuit card for use with a terminal, comprising:<br>
a communicator;<br>
a memory storing an interpreter and first instructions of a first application, the first instructions having been converted from second instructions of a second application; and<br>
a processor coupled to the memory and configured to use the interpreter to execute the first instructions and to communicate with the terminal via the communicator.<br>
68.	The integrated circuit card of claim 67, wherein the first application has a class file format.<br>
69.	The integrated circuit card of claim 67, wherein the second application has a class file format.<br><br>
70.	The integrated circuit card of claim 67, wherein the first instructions comprise byte codes.<br>
71.	The integrated circuit card of claim 67, wherein the second instructions comprise byte codes.<br>
72.	The integrated circuit card of claim 67, wherein the first instructions comprise Java byte codes.<br><br>
73.	The integrated circuit card of claim 67, wherein the second instructions comprise Java byte codes.<br>
74.	The integrated circuit card of claim 61, wherein the first instructions comprise generalized versions of the second instructions,<br>
75.	The integrated circuit card of claim 67, wherein the first instructions comprise renumbered versions of the second instructions.<br>
76.	The integrated circuit card of claim 67, wherein<br>
the second instructions include constant references, and<br>
the first instructions include constants that replace the comitant references of the second instructions,<br>
77.	The integrated circuit card of claim 67,<br>
wherein<br>
the second instructions include references, the references shifting location during the conversion of the second instructions to the first instructions, and<br>
the firsv: instructions are relinked to the references after the shifting.<br>
78.	The integrated circuit card of claim 67,<br>
wherein<br>
the first instructions comprise byte codes for a first type of virtual machine, and<br>
the second instructions comprise byte codes for a second type of virtual machine, the first type being different from the second type.<br><br>
79.	A method for use with an integrated circuit<br>
card, comprisinc;<br>
converting second instructions of a second application to first instructions of a first application;<br>
storing the first instructions in a memory of the integrated circuit card; and<br>
using an interpreter of the integrated circuit card to execute the first instructions.<br>
80.	The method of claim 79, wherein the first application has a class file format.<br>
81.	The method of claim 79, wherein the second application has a class file format.<br>
82.	The method of claim 79, wherein the first instructions comprise byte codes.<br>
83.	The method of claim 79, wherein the second instructions comprise byte codes.<br><br>
84.	The method of claim 79, wherein the first instructions comprise Java byte codes.<br>
85.	The method of claim 79, wherein the second instructions corrprise Java byte codes.<br>
86.	The method of claim 79, wherein the first instructions are generalized versions of the second instructions.<br><br>
87.	The method of claim 79, wherein the converting includes renumbe ring the second instructions to form first instructions.<br>
88.	The method of claim 79, wherein the second instructions include constant references, and<br>
the converting includes replacing the constant references of the second instructions with constants.<br>
89.	The method of claim 79, wherein the second<br>
instructions include references and the converting includes<br>
shifting location of the references, further comprising:<br>
relinking the first instructions to the references after the converting.<br>
90.	The method of claim 79, wherein<br>
the first instructions comprise byte codes for a first type of virtual machine, and<br>
the second instructions comprise byte codes for a second type of virtual machine, the first type being different from the second type.<br><br>
91.	An integrated circuit for use with a terminal,<br>
comprising:<br>
a commun;.cator configured to communicate with the terminal;<br>
a memory storing a first application that has been processed from a second application having a string of characters, the string of characters being represented in the first application by an identifier; and<br>
a processor coupled to the memory, the processor conficured to use the interpreter to interpret the first applicatics for execution and to use the communicator to communicate with the terminal.<br>
92.	The integrated circuit card of claim 91, wherein the identifier comprises an integer.<br>
93.	A method for use with an integrated circuit card and a terminal comprising:<br>
processing a second application to create a first application, the second application having a string of characters;<br>
representing the string of characters of the first application by an identifier in the second application;<br>
storing an interpreter and the first application in a memory of the integrated circuit card; and<br>
using a processor of the integrated circuit card to use an interpreser to interpret the first application for execution.<br>
94.	The method of claim 93, wherein the indentifier<br>
includes an integer.<br><br>
95.	A microcontroller comprising:<br>
a memory storing:<br>
an application having a class file format, and<br>
an interpreter; and a processor coupled to the memory, the processor configured to use the interpreter to interpret the application for execution.<br>
96.	The microcontroller of claim 95, further<br>
comprising:<br>
a commuiticator configured to communicate with a terminal.<br>
97.	The microcontroller of claim 96, wherein the terminal has a card reader and the communicator comprises a contact for communicating with the card reader.<br>
98.	The microcontroller of claim 96, wherein the terminal has a wireless communication device and the communictor a wireless transceiver for communicating with the wireless communication device.<br>
99.	The microcontroller of claim 96, wherein the terminal has a wireless communication device and the communicator ccmprises a wireless transmitter for communicating with the wireless Communication device.<br>
100.	The microcontroller of claim 95, wherein the class file format comprises a Java class file format.<br><br>
101. A method for use with an integrated circuit card, comprising:<br>
storing a first application in a memory Of the integrated circuit card;<br>
storing a second application in the memory of the integrated circuit card; and<br>
creating a firewall that isolates the first and second applications so that the second application cannot access either the first application or data associated with the first application.<br>
102. The method of claim 101, wherein the first and second applications comprise Java byte codes.<br>
103.	The method of claim 100, wherein the-creating includes using a Java interpreter.<br>
104.	The method of claim 101, wherein<br>
the storing of the first application is performed in association with manufacture of the integrated circuit card; and <br>
the storing of the second application is performed at a later time after the manufacture is completed.<br><br>
105. An integrated circuit card for use with a terminal, comprising:<br>
a Communicator configured to communicate with the terminal;<br>
a memory storing:<br>
applications, each application having a high level programming language format, and<br>
an interpreter; and a processor coupled to the memory, the processor configured to:<br>
a.) use the interpreter to interpret the applications for execution,<br>
b.) use the interpreter to create a firewall to isolate the applications from each other, and<br>
c.) use the communicator to communicate with the terminal.<br>
106. An integrated circuit card for use with a terminal, substantially as hereinabove described and illustrated with reference to the acccompanying  drawings.<br><br><br>
105. An integrated circuit cara for use with a<br>
terminal, comprising:<br>
a communicator configured to communicate with the terminal;<br>
a memory storing:<br>
applications, each application having a high level programming language format, and<br>
an interpreter; and a processor coupled to the memory, the processor configured to:<br>
a.) use the interpreter to interpret the applications for execution,<br>
b.) use the interpreter to create a firewall to isolate the applications from each other, and<br>
c.) use the communicator to communicate with the terminal.<br>
106.  An  integrated circuit card for use with  a  terminal, substantially  as  hereinabove described  and   illustrated with reference to the accompanying  drawings.<br><br></clinit></init></clinit></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Ny1tYXMtMTk5Ny1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">2397-mas-1997-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Ny1tYXMtMTk5Ny1jbGFpbXMgZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">2397-mas-1997-claims duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Ny1tYXMtMTk5Ny1jbGFpbXMgb3JpZ2luYWwucGRm" target="_blank" style="word-wrap:break-word;">2397-mas-1997-claims original.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Ny1tYXMtMTk5Ny1jb3JyZXNwb25kZW5jZSBvdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">2397-mas-1997-correspondence others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Ny1tYXMtMTk5Ny1jb3JyZXNwb25kZW5jZSBwby5wZGY=" target="_blank" style="word-wrap:break-word;">2397-mas-1997-correspondence po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Ny1tYXMtMTk5Ny1kZXNjcmlwdGlvbiBjb21wbGV0ZSBkdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">2397-mas-1997-description complete duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Ny1tYXMtMTk5Ny1kZXNjcmlwdGlvbiBjb21wbGV0ZSBvcmlnaW5hbC5wZGY=" target="_blank" style="word-wrap:break-word;">2397-mas-1997-description complete original.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Ny1tYXMtMTk5Ny1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">2397-mas-1997-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Ny1tYXMtMTk5Ny1mb3JtIDEucGRm" target="_blank" style="word-wrap:break-word;">2397-mas-1997-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Ny1tYXMtMTk5Ny1mb3JtIDI2LnBkZg==" target="_blank" style="word-wrap:break-word;">2397-mas-1997-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Ny1tYXMtMTk5Ny1mb3JtIDMucGRm" target="_blank" style="word-wrap:break-word;">2397-mas-1997-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Ny1tYXMtMTk5Ny1mb3JtIDQucGRm" target="_blank" style="word-wrap:break-word;">2397-mas-1997-form 4.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="208013-a-process-for-coating-and-protecting-elastomers.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="208015-a-process-for-preparing-an-aqueous-suspension.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>208014</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2397/MAS/1997</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>30/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>27-Jul-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>06-Jul-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>23-Oct-1997</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SCHLUMBERGER TECHNOLOGIES INC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>8311 NORTH RR 620 AUSTIN ,TEXAS 78726.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>TIMOTHY J WILKINSON</td>
											<td>8311 NORTH RR 620 AUSTIN ,TEXAS 78726.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F13/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/029,057</td>
									<td>1996-10-25</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/208014-a-microcontroller-having-a-set-of-resource-constraints-and-a-method-for-programming-the-same by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:09:00 GMT -->
</html>
