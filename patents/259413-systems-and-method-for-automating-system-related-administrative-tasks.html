<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/259413-systems-and-method-for-automating-system-related-administrative-tasks by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 02:05:16 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 259413:SYSTEMS AND METHOD FOR AUTOMATING SYSTEM RELATED ADMINISTRATIVE TASKS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">SYSTEMS AND METHOD FOR AUTOMATING SYSTEM RELATED ADMINISTRATIVE TASKS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>In an administrative tool environment, user input is supplied to an administrative tool framework for processing. The administrative tool framework maps user input to cmdlet objects. The cmdlet objects describe a grammar for parsing the user input and input objects to obtain expected input parameters. The input objects are emitted by one cmdlet and are available as input to another cmdlet. The input objects maybe any precisely parseable input, such as NET objects, plain strings, XML documents, and the like. The cmdlets may operate within the same process. Alternatively, one cmdlet may operate locally while another cmdlet operates remotely. The cmdlets may be provided by the administrative tool framework or may be provided by third party developers. The User input may be supplied to the framework via a host cmdlet.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>ADMINISTRATIVE TOOL ENVIRONMENT<br>
TECHNICAL FIELD<br>
Subject matter disclosed herein relates to runtime environments, and in particular to administrative tool environments for automating administrative tasks.<br>
BACKGROUND OF THE INVENTION<br><br><br><br><br><br><br>
Administrative tasks support the day to day operation of computing devices, such as laptop, desktops, and the like. For example, administrative tasks typically allow a user to create a new folder, install or upgrade an application, and perform various other system tasks. System administrators, who maintain networked computers, perform even more complex administrative tasks, such as creating new users, deploying software and software patches, monitoring the network, troubleshooting the network, and the like. Often, command line interfaces or graphical user interfaces (GUI) facilitate execution of administrative tasks.<br>
Most graphical user interfaces require the user to navigate a series of menus or pages and then click on a desired option. According to such interfaces, the user is required to follow the series of menus or pages and is not allowed to jump from one page to another without starting over or traversing up and back down the series of pages. Such interfaces may be referred to as restricted navigation interfaces wherein the user must follow a regimented and predetermined procedure to achieve an administrative goal. A novice user may benefit from using such a GUI because it provides helpful information on each menu or page that directs the novice user to the desired administrative task. However, for many advanced users, such as system administrators,  using   a  GUI   that  has   rigid  navigation   restrictions   is  very<br>
cumbersome. These advanced users already know the administrative task that they want to perform. In addition, advance users desire at least some degree of task automation. However, automating administrative tasks accessed through a GUI is very difficult. Also, if the GUI changes, the corresponding automation may no longer operate properly. Thus, many advanced users prefer using a more robust command line interface.<br>
A command line interface allows a user to directly perform a task by typing in a command. One disadvantage with a command line interface is that the user must know the exact command to type in because helpful information is not provided on the display. However, once the command is known, it becomes much more efficient to type the command than to navigate a series of menus. In addition, tasks executed from a command line interface may be automated. For example, when users notice that they are continually typing the same commands (e.g., a series of commands, etc.) they may create a script (e.g., a .bat file) that includes the repetitive commands. When the script is executed, all the commands listed in the script are executed. The users may also soon notice that different scripts contain similar items. Upon noticing this, the users may wish to create parameterized subroutines within the script to further automate the tasks.<br>
However, many scripting solutions that provide sophisticated automation features (e.g., parameterized subroutines) are developed in the same manner as a full blown application and require system programming knowledge. Thus, these solutions are not ideal for system administrators who do not generally have sophisticated programming knowledge.<br>
Therefore, currently, system administrators must either forego automation or automate using systems programming skills. Neither option is highly desirable.  If<br>
the administrator selects to forego automation, additional costs are incurred to support several other administrators to help run the tasks manually. However, if the administrator selects to automate the tasks, costs are incurred to support a programming environment and to obtain the necessary programming skills. In addition, maintenance costs are expensive because the automated tool must be rebuilt whenever a change occurs.<br>
Therefore, there is a need for an administrative tool framework that allows administrators to effectively and efficiently automate administrative tasks.<br>
SUMMARY OF THE INVENTION<br>
An administrative tool framework is provided. User input is supplied to the administrative tool framework for processing. The administrative tool framework maps user input to cmdlct objects. The cmdlet object is associated with a grammar for parsing the user input and input objects to obtain expected input parameters identified within the cmdlet. The grammar may be associated directly within the cmdlet, such as using parameter declarations. Alternatively, the grammar may be associated indirectly with the cmdlet, such through an XML document. The input objects are emitted by one cmdlet and are available as input to another cmdlet. The input objects may be any precisely parseable input, such as .NET objects, plain strings, XML documents, and the like. The cmdlets may operate within the same process. Alternatively, one cmdlet may operate locally while another cmdlet operates in another process or remotely. The cmdlets may be provided by the administrative tool framework or may be provided by third party developers. The user input may be supplied to the framework via a host cmdlet.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
FIGURE 1 illustrates an exemplary computing device that may use an exemplary administrative tool environment.<br>
FIGURE 2 is a block diagram generally illustrating an overview of an exemplary administrative tool framework for the present administrative tool environment.<br>
FIGURE 3 is a block diagram illustrating components within the host-specific components of the administrative tool framework shown in FIGURE 2.<br>
FIGURE 4 is a block diagram illustrating components within the core engine component of the administrative tool framework shown in FIGURE 2.<br>
FIGURE 5 is one exemplary data structure for specifying a cmdlet suitable for use within the administrative tool framework shown in FIGURE 2.<br>
FIGURE 6 is an exemplary data structure for specifying a command base type from which a cmdlet shown in FIGURE 5 is derived.<br>
FIGURE 7 is another exemplary data structure for specifying a cmdlet suitable for use within the administrative tool framework shown in FIGURE 2.<br>
FIGURE 8 is a logical flow diagram illustrating an exemplary process for host processing that is performed within the administrative tool framework shown in FIGURE 2.<br>
FIGURE 9 is a logical flow diagram illustrating an exemplary process for handling input that is performed within the administrative tool framework shown in FIGURE 2.<br>
FIGURE 10 is a logical flow diagram illustrating a process for processing scripts suitable for use within the process for handling input shown in FIGURE 9.<br>
FIGURE 11 is a logical flow diagram illustrating a script pre-processing process suitable for use within the script processing process shown in FIGURE 10.<br>
FIGURE 12 is a logical flow diagram illustrating a process for applying constraints suitable for use within the script processing process shown in FIGURE 10.<br>
FIGURE 13 is a functional flow diagram illustrating the processing of a command string in the administrative tool framework shown in FIGURE 2.<br>
FIGURE 14 is a logical flow diagram illustrating a process for processing commands strings suitable for use within the process for handling input shown in FIGURE 9.<br>
FIGURE 15 is a logical flow diagram illustrating an exemplary process for creating an instance of a cmdlet suitable for use within the processing of command strings shown in FIGURE 14.<br>
FIGURE 16 is a logical flow diagram illustrating an exemplary process for -populating properties of a cmdlet suitable for use within the processing of commands shown in FIGURE 14.<br>
FIGURE 17 is a logical flow diagram illustrating an exemplary process for executing the cmdlet suitable for use within the processing of commands shown in FIGURE 14.<br>
FIGURE 18 is a functional block diagram of an exemplary extended type manager suitable for use within the administrative tool framework shown in FIGURE 2.<br>
FIGURE 19 graphically depicts exemplary sequences for output processing cmdlets within a pipeline.<br>
FIGURE 20 illustrates exemplary processing performed by one of the output processing cmdlets shown in FIGURE 19.<br>
FIGURE 21 graphically depicts an exemplary structure for display information accessed during the processing of FIGURE 20.<br>
FIGURE 22 is a table listing an exemplary syntax for exemplary output processing cmdlets.<br>
FIGURE 23 illustrates results rendered by the out/console cmdlet using various pipeline sequences of the output processing cmdlets.<br>
DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT<br>
Briefly stated, the present administrative tool environment provides a computing framework that reduces administrative costs associated with, maintaining and supporting computers and computer networks. In addition, the framework supports rapid ad-hoc development of administrative tools by both programmers and non-programmers.<br>
The following description sets forth a specific exemplary administrative tool environment. Other exemplary environments may include features of this specific embodiment and/or other features, which aim to facilitate administrative tasks.<br>
The following detailed description is divided into several sections. A first section describes an illustrative computing environment in which the administrative tool environment may operate. A second section describes an exemplary framework for the administrative tool environment. Subsequent sections describe individual components of the exemplary framework and the operation of these components.<br>
Exemplary Computing Environment<br>
FIGURE 1 illustrates an exemplary computing device that may be used in an exemplary administrative tool environment. In a very basic configuration, computing device 100 typically includes at least one processing unit 102 and system<br>
memory 104. Depending on the exact configuration and type of computing device, system memory 104 may be volatile (such as RAM), non-volatile (such as ROM, flash memory, etc.) or some combination of the two, System memory 104 typically includes an operating system 105, one or more program modules 106, and may include program data 107. The operating system 106 include a component-based framework 120 that supports components (including properties and events), objects, inheritance, polymorphism, reflection, and provides an object-oriented component-based application programming interface (API), such as that of the .NET™ Framework manufactured by Microsoft Corporation, Redmond, WA. The operating system 105 also includes an administrative tool framework 200 that interacts with the component-based framework 120 to support development of administrative tools (not shown). This basic configuration is illustrated in FIGURE 1 by those components within dashed line 108.<br>
Computing device 100 may have additional features or functionality. For example, computing device 100 may also include additional data storage devices (removable and/or non-removable) such as, for example, magnetic disks, optical disks, or tape. Such additional storage is illustrated in FIGURE 1 by removable storage 109 and non-removable storage 110. Computer storage media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. System memory 104, removable storage 109 and non-removable storage 110 are all examples of computer storage media. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium<br>
which can be used to store the desired information and which can be accessed by computing device 100. Any such computer storage media may be part of device 100. Computing device 100 may also have input device(s) 112 such as keyboard, mouse, pen, voice input device, touch input device, etc. Output device(s) 114 such as a display, speakers, printer, etc. may also be included. These devices are well know in the art and need not be discussed at length here.<br>
Computing device 100 may also contain communication connections 116 that allow the device to communicate with other computing devices 118, such as over a network. Communication connections 116 are one example of communication media. Communication media may typically be embodied by computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism, and includes any information delivery media. The term "modulated data signal" means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. The term computer readable media as used herein includes both storage media and communication media.<br>
Exemplary Administrative Tool Framework<br>
FIGURE 2 is a block diagram generally illustrating an overview of an exemplary administrative tool framework 200. Administrative tool framework 200 includes one or more host components 202, host-specific components 204, host-independent components 206, and handler components 208. The host-independent components 206 may communicate with each of the other components (i.e., the host<br>
components 202, the host-specific components 204, and the handler components 208).   Each of these components are briefly described below and described in further detail, as needed, in subsequent sections.<br>
Host components<br>
The host components 202 include one or more host programs (e.g., host programs 210-214) that expose automation features for an associated application to users or to other programs. Each host program 210-214 may expose these automation features in its own particular style, such as via a command line, a graphical user interface (GUI), a voice recognition interface, application programming interface (API), a scripting language, a web service, and the like. However, each of the host programs 210-214 expose the one or more automation features through a mechanism provided by the administrative tool framework.<br>
In this example, the mechanism uses cmdlets to surface the administrative tool capabilities to a user of the associated host program 210-214. In addition, the mechanism uses a set of interfaces made available by the host to embed the administrative tool environment within the application associated with the corresponding host program 210-214. Throughout the following discussion, the term "cmdlet" is used to refer to commands that are used within the exemplary administrative tool environment described with reference to FIGURES 2-23.<br>
Cmdlets correspond to commands in traditional administrative environments. However, cmdlets are quite different than these traditional commands. For example, cmdlets are typically smaller in size than their counterpart commands because the cmdlets can utilize common functions provided by the administrative tool framework, such as parsing, data validation, error reporting, and the like. Because such common functions can be implemented once and tested once, the use<br>
of cmdlets throughout the administrative tool framework allows the incremental development and test costs associated with application-specific functions to be quite low compared to traditional environments.<br>
In addition, in contrast to traditional environments, cmdlets do not need to be stand-alone executable programs. Rather, cmdlets may run in the same processes within the administrative tool framework. This allows cmdlets to exchange "live" objects between each other. This ability to exchange "live" objects allows the cmdlets to directly invoke methods on these objects. The details for creating and using cmdlets are described in further detail below.<br>
In overview, each host program 210-214 manages the interactions between the user and the other components within the administrative tool framework. These interactions may include prompts for parameters, reports of errors, and the like. Typically, each host program 210-213 may provide its own set of specific host cmdlets (e.g., host cmdlets 218). For example, if the host program is an email program, the host program may provide host cmdlets that interact with mailboxes and messages. Even though FIGURE 2 illustrates host programs 210-214, one skilled in the art will appreciate that host components 202 may include other host programs associated with existing or newly created applications. These other host programs will also embed the functionality provided by the administrative tool environment within their associated application. The processing provided by a host program is described in detail below in conjunction with FIGURE 8.<br>
In the examples illustrated in FIGURE 2, a host program may be a management console (i.e., host program 210) that provides a simple, consistent, administration user interface for users to create, save, and open administrative tools that manage the hardware, software, and network components of the computing<br><br>
device. To accomplish these functions, host program 210 provides a set of services for building management GUIs on top of the administrative tool framework. The GUI interactions may also be exposed as user-visible scripts that help teach the users the scripting capabilities provided by the administrative tool environment.<br>
 	In another example, the host program may be a command line interactive<br>
shell (i.e., host program 212). The command line interactive shell may allow shell metadata 216 to be input on the command line to affect processing of the command line.<br>
In still another example, the host program may be a web service (i.e., host       program 214) that uses industry standard specifications for distributed computing and interoperability across platforms, programming languages, and applications.<br>
In addition to these examples, third parties may add their own host components by creating "third party" or "provider" interfaces and provider cmdlets that are used with their host program or other host programs.    The provider<br>
   interface exposes an application or infrastructure so that the application or infrastructure can be manipulated by the administrative tool framework. The provider cmdlets provide automation for navigation, diagnostics, configuration, lifecycle, operations, and the like. The provider cmdlets exhibit polymorphic cmdlet  behavior  on  a  completely heterogeneous  set  of data   stores.     The<br>
    administrative tool environment operates on the provider cmdlets with the same priority as other cmdlet classes. The provider cmdlet is created using the same mechanisms as the other cmdlets. The provider cmdlets expose specific functionality of an application or an infrastructure to the administrative tool framework. Thus, through the use of cmdlets, product developers need only create<br>
      one host component that will then allow their product to operate with many<br>
administrative  tools.     For example,  with the exemplary administrative  tool environment, system level graphical user interface help menus may be integrated and ported to existing applications.<br>
Host-specific components<br>
The host-specific components 204 include a collection of services that computing systems (e.g., computing device 100 in FIGURE 1) use to isolate the administrative tool framework from the specifics of the platform on which the framework is running. Thus, there is a set of host-specific components for each type of platform. The host-specific components allow the users to use the same administrative tools on different operating systems.<br>
Turning briefly to FIGURE 3, the host-specific components 204 may include an intellisense/metadata access component 302, a help cmdlet component 304, a configuration/registration component 306, a cmdlet setup component 308, and an output interface component 309 Components 302-308 communicate with a database store manager 312 associated with a database store 314. The parser 220 and script engine 222 communicate with the intellisense/metadata access component 302. The core engine 224 communicates with the help cmdlet component 304, the configuration/registration component 306, the cmdlet setup component 308, and the output interface component 309. The output interface component 309 includes interfaces provided by the host to out cmdlets. These out cmdlets can then call the host's output object to perform the rendering. Host-specific components 204 may also include a logging/auditing component 310, which the core engine 224 uses to communicate with host specific (i.e., platform specific) services that provide logging and auditing capabilities.<br>
 In one exemplary administrative tool framework, the intellisense/metadata access component 302 provides auto-completion of commands, parameters, and parameter values.   Trie help cmdlet component 304 provides a customized help system based on a host user interface.<br>
Handler components<br>
Referring back to FIGURE 2, the handler components 208 includes legacy utilities 230, management cmdlets 232, non-management cmdlets 234, remoting cmdlets 236, and a web service interface 238. The management cmdlets 232 (also referred to as platform cmdlets) include cmdlets that query or manipulate the configuration information associated with the computing device. Because management cmdlets 232 manipulate system type information, they are dependant upon a particular platform. However, each platform typically has management cmdlets 232 that provide similar actions as management cmdlets 232 on other platforms. For example, each platform supports management cmdlets 232 that get and set system administrative attributes (e.g., get/process, set/IP Address). The host-independent components 206 communicate with the management cmdlets via cmdlet objects generated within the host-independent components 206. Exemplary data structures for cmdlets objects will be described in detail below in conjunction with FIGURES 5-7.<br>
The non-management cmdlets 234 (sometimes referred to as base cmdlets) include cmdlets that group, sort, filter, and perform other processing on objects provided by the management cmdlets 232. The non-management cmdlets 234 may also include cmdlets for formatting and outputting data associated with the pipelined objects. An exemplary mechanism for providing a data driven command line output is described below in conjunction with FIGURES 19-23.   The non-<br>
management cmdlets 234 may be the same on each platform and provide a set of utilities that interact with host-independent components 206 via cmdlet objects. The interactions between the non-management cmdlets 234 and the host-independent components 206 allow reflection on objects and allow processing on the reflected objects independent of their (object) type. Thus, these utilities allow developers to write non-management cmdlets once and then apply these non-management cmdlets across all classes of objects supported on a computing system. In the past, developers had to first comprehend the format of the data that was to be processed and then write the application to process only that data. As a consequence, traditional applications could only process data of a very limited scope. One exemplary mechanism for processing objects independent of their object type is described below in conjunction with FIGURE 18.<br>
The legacy utilities 230 include existing executables, such as Win32 executables that run under cmd.exe. Each legacy utility 230 communicates with the administrative tool framework using text streams (i.e., stdin and stdout), which are a type of object within the object framework. Because the legacy utilities 230 utilize text streams, reflection-based operations provided by the administrative tool framework are not available. The legacy utilities 230 execute in a different process than the administrative tool framework. Although not shown, other cmdlets may also operate out of process.<br>
The remoting cmdlets 236, in combination with the web service interface 238, provide remoting mechanisms to access interactive and programmatic administrative tool environments on other computing devices over a communication media, such as internet or intranet (e.g., internet/intranet 240 shown in FIGURE 2). In one exemplary administrative tool framework, the remoting mechanisms support<br>
federated services that depend on infrastructure that spans multiple independent control domains. The remoting mechanism allows scripts to execute on remote computing devices. The scripts may be run on a single or on multiple remote systems. The results of the scripts may be processed as each individual script completes or the results may be aggregated and processed en-masse after all the scripts on the various computing devices have completed.<br>
For example, web service 214 shown as one of the host components 202 may be a remote agent. The remote agent handles the submission of remote command requests to the parser and administrative tool framework on the target system. The remoting cmdlets serve as the remote client to provide access to the remote agent. The remote agent and the remoting cmdlets communicate via a parsed stream. This parsed stream may be protected at the protocol layer, or additional cmdlets may be used to encrypt and then decrypt the parsed stream.<br>
Host-independent components<br>
The host-independent components 206 include a parser 220, a script engine 222 and a core engine 224. The host-independent components 206 provide mechanisms and services to group multiple cmdlets, coordinate the operation of the cmdlets, and coordinate the interaction of other resources, sessions, and jobs with the cmdlets.<br>
Exemplary Parser<br>
The parser 220 provides mechanisms for receiving input requests from various host programs and mapping the input requests to uniform cmdlet objects that are used throughout the administrative tool framework, such as within the core engine 224. In addition, the parser 220 may perform data processing based on the input received. One exemplary method for performing data processing based on the<br>
input is described below in conjunction with FIGURE 12. The parser 220 of the present administrative tool framework provides the capability to easily expose different languages or syntax to users for the same capabilities. For example, because the parser 220 is responsible for interpreting the input requests, a change to the code within the parser 220 that affects the expected input syntax will essentially affect each user of the administrative tool framework. Therefore, system administrators may provide different parsers on different computing devices that support different syntax. However, each user operating with the same parser will experience a consistent syntax for each cmdlet. In contrast, in traditional environments, each command implemented its own syntax. Thus, with thousands of commands, each environment supported several different syntax, usually many of which were inconsistent with each other.<br>
Exemplary Script Engine<br>
The script engine 222 provides mechanisms and services to tie multiple cmdlets together using a script. A script is an aggregation of command lines that share session state under strict rules of inheritance. The multiple command lines within the script may he executed either synchronously or asynchronously, based on the syntax provided in the input request. The script engine 222 has the ability to process control structures, such as loops and conditional clauses and to process variables within the script. The script engine also manages session state and gives cmdlets access to session data based on a policy (not shown).<br>
Exemplary Core Engine<br>
The core engine 224 is responsible for processing cmdlets identified by the parser 220. Turning briefly to FIGURE 4, an exemplary core engine 224 within the administrative tool framework 200 is illustrated.  The exemplary core engine 224<br>
includes a pipeline processor 402, a loader 404, a metadata processor 406, an error &amp; event handler 408, a session manager 410, and an extended type manager 412. Exemplary Metadata Processor<br>
The metadata processor 406 is configured to access and store metadata within a metadata store, such as database store 314 shown in FIGURE 3. The metadata may be supplied via the command line, within a cmdlet class definition, and the like. Different components within the administrative tool framework 200 may request the metadata when performing their processing. For example, parser 202 may request metadata to validate parameters supplied on the command line. Exemplary Error &amp; Event Processor<br>
The error &amp; event processor 408 provides an error object' to store information about each occurrence of an error during processing of a command line. For additional information about one particular error and event processor which is particularly suited for the present administrative tool framework, refer to<br>
U.S. Patent Application No.	/ U.S. Patent No.	, entitled "System and<br>
Method for Persisting Error Information in a Command Line Environment", which<br>
is owned by the same assignee as the present invention, and is incorporated here by<br>
reference.<br>
Exemplary Session Manager<br>
The session manager 410 supplies session and state information to other components within the administrative tool framework 200. The state information managed by the session manager may be accessed by any cmdlet, host, or core engine via programming interfaces. These programming interfaces allow for the creation, modification, and deletion of state information.<br>
Exemplary Pipeline Processor and Loader<br>
The loader 404 is configured to load each cmdlet in memory in order for the pipeline processor 402 to execute the cmdlet. The pipeline processor 402 includes a cmdlet processor 420 and a cmdlet manager 422. The cmdlet processor 420 dispatches individual cmdlets. If the cmdlet requires execution on a remote, or a set of remote machines, the cmdlet processor 420 coordinates the execution with the remoting cmdlet 236 shown in FIGURE 2. The cmdlet manager 422 handles the execution of aggregations of cmdlets. The cmdlet manager 422, the cmdlet processor 420, and the script engine 222 (FIGURE 2) communicate with each other in order to perform the processing on the input received from the host program 210-214. The communication may be recursive in nature. For example, if the host program provides a script, the script may invoke the cmdlet manager 422 to. execute a cmdlet, which itself may be a script. The script may then be executed by the script engine 222. One exemplary process flow for the core engine is described in detail below in conjunction with FIGURE 14. Exemplary Extended Type Manager<br>
As mentioned above, the administrative tool framework provides a set of utilities that allows reflection on objects and allows processing on the reflected objects independent of their (object) type. The administrative tool framework 200 interacts with the component framework on the computing system (component framework 120 in FIGURE 1) to perform this reflection. As one skilled in the art will appreciate, reflection provides the ability to query an object and to obtain a type for the object, and then reflect on various objects and properties associated with that type of object to obtain other objects and/or a desired value.<br>
Even though reflection provides the administrative tool framework 200 a considerable amount of information on objects, the inventors appreciated that<br>
reflection focuses on the type of object. For example, when a database datatable is reflected upon, the information that is returned is that the datatable has two properties: a column property and a row property. These two properties do not provide sufficient detail regarding the "objects" within the datatable. Similar problems arise when reflection is used on extensible markup language (XML) and other objects.<br>
Thus, the inventors conceived of an extended type manager 412 that focuses on the usage of the type. For this extended type manager, the type of object is not important. Instead, the extended type manager is interested in whether the object can be used to obtain required information. Continuing with the above datatable example, the inventors appreciated that knowing that the datatable has a column property and a row property is not particularly interesting, but appreciated that one column contained information of interest. Focusing on the usage, one could associate each row with an "object" and associate each column with a "property" of that "object". Thus, the extended type manager 412 provides a mechanism to create "objects" from any type of precisely parse-able input. In so doing, the extended type manager 412 supplements the reflection capabilities provided by the component-based framework 120 and extends "reflection" to any type of precisely parse-able input.<br>
In overview, the extended type manager is configured to access precisely parse-able input (not shown) and to correlate the precisely parse-able input with a requested data type. The extended type manager 412 then provides the requested information to the requesting component, such as the pipeline processor 402 or parser 220. In the following discussion, precisely parse-able input is defined as input in which properties and values may be discerned. Some exemplary precisely parse-able input include Windows Management Instrumentation (WMI) input,<br>
ActiveX Data Objects (ADO) input, extensible Markup Language (XML) input, and object input, such as .NET objects.   Other precisely parse-able input may include third party data formats.<br>
Turning briefly to FIGURE 18, a functional block diagram of an exemplary extended type manager for use within the administrative tool framework is shown. For explanation purposes, the functionality (denoted by the number "3" within a circle) provided by the extended type manager is contrasted with the functionality provided by a traditional tightly bound system (denoted by the number "1" within a circle) and the functionality provided by a reflection system (denoted by the number "2" within a circle). In the traditional tightly bound system, a caller 3802 within an application directly accesses the information (e.g., properties PI and P2, methods Ml and M2) within object A. As mentioned above, the caller 1802 must know, a priori, the properties (e.g., properties PI and P2) and methods (e.g., methods Ml and M2) provided by object A at compile time. In the reflection system, generic code 1820 (not dependent on any data type) queries a system 1808 that performs reflection 1810 on the requested object and returns the information (e.g., properties PI and P2, methods Ml and M2) about the object (e.g., object A) to the generic code 1820. Although not shown in object A, the returned information may include additional information, such as vendor, file, date, and the like. Thus, through reflection, the generic code 1820 obtains at least the same information that the tightly bound system provides. The reflection system also allows the caller 1802 to query the system and get additional information without any a priori knowledge of the parameters.<br>
In both the tightly bound systems and the reflection systems, new data types can not be easily incorporated within the operating environment. For example, in a tightly bound system, once the operating environment is delivered, the operating<br>
environment can not incorporate new data types because it would have to be rebuilt in order to support them.   Likewise, in reflection systems, the metadata for each object class is fixed. Thus, incorporating new data types is not usually done.<br>
However, with the present extended type manager new data types can be incorporated into the operating system. With the extended type manager 1822, generic code 1820 may reflect on a requested object to obtain extended data types (e.g., object A') provided by various external sources, such as a third party objects (e.g., object A' and B), a semantic web 1832, an ontology service 1834, and the like. As shown, the third party object may extend an existing object (e.g., object A') or may create an entirely new object (e.g., object B).<br>
Each of these external sources may register their unique structure within a type metadata 1840 and may provide code 1842. When an object is queried, the extended type manager reviews the type metadata 1840 to determine whether the object has been registered. If the object is not registered within the type metadata 1840, reflection is performed. Otherwise, extended reflection is performed. The code 1842 returns the additional properties and methods associated with the type being reflected upon. For example, if the input type is XML, the code 1842 may include a description file that describes the manner in which the XML is used to create the objects from the XML document. Thus, the type metadata 1840 describes how the extended type manager 412 should query various types of precisely parse-able input (e.g., third party objects A' and B, semantic web 1832) to obtain the desired properties for creating an object for that specific input type and the code 1842 provides the instructions to obtain these desired properties. As a result, the extended type manager 412 provides a layer of indirection that allows "reflection" on all types of objects.<br>
In addition to providing extended types, the extend type manager 412 provides additional query mechanisms, such as a property path mechanism, a key mechanism, a compare mechanism, a conversion mechanism, a globber mechanism, a property set mechanism, a relationship mechanism, and the like. Each of these query mechanisms, described below in the section "Exemplary Extended Type Manager Processing", provides flexibility to system administrators when entering command strings. Various techniques may be used to implement the semantics for the extended type manager. Three techniques are described below. However, those skilled in the art will appreciate that variations of these techniques may be used without departing from the scope of the claimed invention.<br><br><br><br>
I/We claim:<br>
1. A computing device (100) for automating system related administrative tasks in a<br>
computing system, the computing device (100) comprising:<br>
a processor (102);<br>
a parser component (220) coupled to the processor (102) configured to parse input<br>
(1350) and to identify at least one cmdlet (500) based on the input (1350), wherein the<br>
cmdlet (500) refers to set of commands used within the computing system and provide<br>
system related administrative tool capabilities to a user; and<br>
an engine component (224) coupled to the processor (102) configured to populate a<br>
parameter associated with the cmdlet (500) using information from an input source, and to<br>
execute the cmdlet (500) to generate a precisely parseable stream, wherein the input source<br>
comprises the precisely parseable stream emitted from another cmdlet, and wherein the<br>
precisely parseable stream comprising at least one live object; and<br>
the engine component (224) coupled to the processor (102) flirther configured to<br>
release the precisely parseable stream to a handler component (208) to initiate the<br>
automation of system related administrative tasks in the computing system.<br>
2. The computing device (100) as claimed in claim 1, computing device (100) flirther<br>
comprising a host component (210, 212, 214) configured to supply the input (1350) about at<br>
least one command.<br>
3. The computing device (100) as claimed in claim 2, wherein the host component<br>
(210,212,214) supplies the input (1350) directly to the parser component (220).<br>
4. The computing device (100) as claimed in claim 2, wherein the host component<br>
(210,212,214) supplies the input (1350) using a host cmdlet (218) that is processed as one of<br>
the cmdlets within the engine component (224).<br>
5. The computing device (100) as claimed in claim 1, wherein the cmdlet (500)<br>
includes a base cmdlet (602) that provides a common utility that operates on a plurality of data<br>
types.<br>
6. The computing device (100) as claimed in claim 1, wherein the cmdlet (500)<br>
includes a host cmdlet (218) that provides a system utility.<br>
75<br>
7. The computing device (100) as claimed in claim 1, wherein the cmdlet (500)<br>
includes a provider cmdlet that provides functionality associated with an application.<br>
8. A computer implemented method for automating system related administrative task in a<br>
computing system (100) having a processor (102), the computer implemented method<br>
comprising:<br>
receiving at least one input (1350) by a processor (102);<br>
parsing the at least one input (1350) by the processor (102);<br>
identifying, by the processor (102), at least one cmdlet class (1330-1336) based on<br>
the parsing of the input (1350), the cmdlet (500) identifying at least one input parameter;<br>
for each input parameter that specifies obtaining data from the input (1350),<br>
populating, by the processor (102), the input parameter with data from the input (1350);<br>
for each expected input parameter that specifies obtaining information from an input<br>
stream to the cmdlet (500), populating, by the processor (102), the input parameter with the<br>
information; and<br>
executing, by the processor (102), the cmdlet (500) to generate an object stream<br>
based on the information and the data, and emitting the object stream, wherein the input<br>
stream comprises the object stream emitted by another cmdlet, and wherein the object<br>
stream comprising at least one live object.<br>
9. The computer implemented method as claimed in claim 8, wherein the input stream<br>
comprises a .NET object, an XML document, or an Active Directory Object.<br>
10. The computer implemented method as claimed in claim 8, wherein the cmdlet (500)<br>
and the other cmdlet operate in a same process.<br>
11. The computer implemented method as claimed in claim 8, wherein the cmdlet (500)<br>
operates in a local process and the other cmdlet operates in a remote process.<br>
12. The computer implemented method as claimed in claim 8, wherein the input<br>
comprises a string.<br>
13. The computer implemented method as claimed in claim 8, wherein the input<br>
comprises a script.<br>
76<br>
1 ^<br>
14. A computing system (100) for automating system related administrative tasks,<br>
comprising:<br>
a processor (102); and<br>
a memory (104) coupled to the processor (102), the memory (104) being allocated<br>
for a plurality of computer- executable instructions which are loaded into the memory (104)<br>
for execution by the processor (102), the computer-executable instructions that, when executed,<br>
cause the processor (102) to:<br>
performing the computer implemented method as claimed in one of claims 8 to 13.<br>
15. The computer implemented method as claimed in claim 8, wherein the populating<br>
includes populating at least one input with information obtained from the object stream.<br>
16. The computer implemented method as claimed in claim 8, wherein the at least one<br>
cmdlets includes a third party cmdlet provided by a third party developer.<br>
17. A computer implemented method for automating system related administrative tasks<br>
comprising:<br>
receiving at least one user input (1350) by a processor (102);<br>
converting, by the processor (102), the at least one user input (1350) to an input<br>
format recognized by a computing system (200);<br>
processing, by the processor (102), the input format to the computing system<br>
(200) configured to parse the input format, and instantiate a cmdlet (500) based on the at<br>
least one user input (1350), the cmdlet (500) specifying an expected input parameter;<br>
and<br>
populating the expected input parameter from an input source, the input source<br>
comprising at least one live object.<br>
18. The computer implemented method as claimed in claim 17, wherem the input source<br>
comprises the input format.<br>
19. The computer implemented method as claimed in claim 17, the method ftirther<br>
comprising providing a host cmdlet that provides an interface between a host application and<br>
the computing system (200).<br>
77<br>
20. The computer implemented method as claimed in claim 17, wherein the user input<br>
(1350) comprises voice input.<br>
21. The computer implemented method as claimed in claim 17, wherein the user input<br>
(1350) comprises a command string entered on a command line.<br>
Dated this 3/5/2005 ^S.JAYARAM<br>
IN/PA-13tt7<br>
AGENT I[OR THE APPLICANTS<br>
78<br>
In one technique, a series of classes having static methods (e.g., getpropertyO ) may be provided. An object is input into the static method (e.g., getproperty(object) ), and the static method returns a set of results. In another technique, the operating environment envelopes the object with an adapter. Thus, no input is supplied. Each instance of the adapter has a getproperty method that acts upon the enveloped object and returns the properties for the enveloped object. The following is pseudo code illustrating this technique:<br>
(Sequence Removed) <br>
In still another technique, an adaptor class subclasses the object. Traditionally, subclassing occurred before compilation. However, with certain operating environments, subclassing may occur dynamically. For these types of environments, the following is pseudo code illustrating this technique:<br>
(Sequence Removed) <br>
Thus, as illustrated in FIGURE 18, the extended type manager allows developers to create a new data type, register the data type, and allow other applications and cmdlets to use the new data type. In contrast, in prior administrative environments, each data type had to be known at compile time so that a property or method associated with an object instantiated from that data type could be directly accessed. Therefore, adding new data types that were supported by the administrative environment was seldom done in the past.<br>
Referring back to FIGURE 2, in overview, the administrative tool framework 200 does not rely on the shell for coordinating the execution of commands input by users, but rather, splits the functionality into processing portions (e.g., host-independent components 206) and user interaction portions (e.g., via host cmdlets). In addition, the present administrative tool environment greatly simplifies the programming of administrative tools because the code<br>
required for parsing and data validation is no longer included within  each command, but is rather provided by components (e.g., parser 220) within the administrative tool framework.   The exemplary processing performed within the administrative tool framework is described below.<br>
Exemplary Operation FIGURES 5-7 graphically illustrate exemplary data structures used within the administrative tool environment. FIGURES 8-17 graphically illustrate exemplary processing flows within the administrative tool environment. One skilled in the art will appreciate that certain processing may be performed by a different component than the component described below without departing from the scope of the present invention. Before describing the processing performed within the components of the administrative tool framework, exemplary data structures used within the administrative tool framework are described. Exemplary Data Structures for Cmdlet Objects<br>
FIGURE 5 is an exemplary data structure for specifying a cmdlet suitable for use within the administrative tool framework shown in FIGURE 2. When completed, the cmdlet may be a management cmdlet, a non-management cmdlet, a host cmdlet, a provider cmdlet, or the like. The following discussion describes the creation of a cmdlet with respect to a system administrator's perspective (i.e., a provider cmdlet). However, each type of cmdlet is created in the same manner and operates in a similar manner. A cmdlet may be written in any language, such as C#. In addition, the cmdlet may be written using a scripting language or the like. When the administrative tool environment operates with the .NET Framework, the cmdlet maybe a .NET object.<br>
The provider cmdlet 500 (hereinafter, referred to as cmdlet 500) is a public class having a cmdlet class name (e.g., StopProcess 504). Cmdlet 500 derives from<br>
a cmdlet class 506. An exemplary data structure for a cmdlet class 506 is described below in conjunction with FIGURE 6. Each cmdlet 500 is associated with a command attribute 502 that associates a name (e.g., Stop/Process) with the cmdlet 500. The name is registered within the administrative tool environment. As will be described below, the parser looks in the cmdlet registry to identify the cmdlet 500 when a command string having the name (e.g., Stop/Process) is supplied as input on a command line or in a script.<br>
The cmdlet 500 is associated with a grammar mechanism that defines a grammar for expected input parameters to the cmdlet. The grammar mechanism may be directly or indirectly associated with the cmdlet. For example, the cmdlet 500 illustrates a direct grammar association. In this cmdlet 500, one or more public parameters (e.g., ProcessName 510 and PID 512) are declared. The declaration of the public parameters drives the parsing of the input objects to the cmdlet 500. Alternatively, the description of the parameters may appear in an external source, such as an XML document. The description of the parameters in this external source would then drive the parsing of the input objects to the cmdlet.<br>
Each public parameter 510, 512 may have one or more attributes (i.e., directives ) associated with it. The directives may be from any of the following categories: parsing directive 521, data validation directive 522, data generation directive 523, processing directive 524, encoding directive 525, and documentation directive 526. The directives may be surrounded by square brackets. Each directive describes an operation to be performed on the following expected input parameter. Some of the directives may also be applied at a class level, such as user-interaction type directives. The directives are stored in the metadata associated with<br>
 the cmdlet. The application of these attributes is described below in conjunction with FIGURE 12.<br>
These attributes may also affect the population of the parameters declared within the cmdlet. One exemplary process for populating these parameters is described below in conjunction with FIGURE 16. The core engine may apply these directives to ensure compliance. The cmdlet 500 includes a first method 530 (hereinafter, interchangeably referred to as StartProcessing method 530) and a second method 540 (hereinafter, interchangeably referred to as processRecord method 540). The core engine uses the first and second methods 530, 540 to direct i the processing of the cmdlet 500. For example, the first method 530 is executed once and performs set-up functions. The code 542 within the second method 540 is executed for each object (e.g., record) that needs to be processed by the cmdlet 500. The cmdlet 500 may also include a third method (not shown) that cleans up after the cmdlet 500.<br>
Thus, as shown in FIGURE 5, code 542 within the second method 540 is typically quite brief and does not contain functionality required in traditional administrative tool environments, such as parsing code, data validation code, and the like. Thus, system administrators can develop complex administrative tasks without learning a complex programming language.<br>
FIGURE 6 is an exemplary data structure 600 for specifying a cmdlet base class 602 from which the cmdlet shown in FIGURE 5 is derived. The cmdlet base class 602 includes instructions that provide additional functionality whenever the cmdlet includes a hook statement and a corresponding switch is input on the command line OT in the script (jointly referred to as command input).<br>
The exemplary data structure 600 includes parameters, such as Boolean parameter verbose 610, whatif 620, and confirm 630. As will be explained below, these parameters correspond to strings that may be entered on the command input. The exemplary data structure 600 may also include a security method 640 that determines whether the task being requested for execution is allowed.<br>
FIGURE 7 is another exemplary data structure 700 for specifying a cmdlet. In overview, the data structure 700 provides a means for clearly expressing a contract between the administrative tool framework and the cmdlet. Similar to data structure 500, data structure 700 is a public class that derives from a cmdlet class 704. The software developer specifies a cmdletDeclaration 702 that associates a noun/verb pair, such as "get/process" and "format/table", with the cmdlet 700. The noun/verb pair is registered within the administrative tool environment. The verb or the noun may be implicit in the cmdlet name. Also, similar to data structure 500, data structure 700 may include one or more public members (e.g., Name 730, Recurse 732), which may be associated with the one or more directives 520-526 described in conjunction with data structure 500.<br>
However, in this exemplary data structure 700, each of the expected input parameters 730 and 732 is associated with an input attribute 731 and 733, respectively. The input attributes 731 and 733 specifying that the data for its respective parameter 730 and 732 should be obtained from the command line. Thus, in this exemplary data structure 700, there are not any expected input parameters that are populated from a pipelined object that has been emitted by another cmdlet. Thus, data structure 700 does not override the first method (e.g., StartProcessing) or the second method (e.g., ProcessRecord) which are provided by the cmdlet base class.<br><br>
The data structure 700 may also include a private member 740 that is not recognized as an input parameter. The private member 740 may be used for storing data that is generated based on one of the directives.<br>
Thus, as illustrated in data structure 700, through the use of declaring public properties and directives within a specific cmdlet class, cmdlet developers can easily specify a grammar for the expected input parameters to their cmdlcts and specify processing that should be performed on the expected input parameters without requiring the cmdlet developers to generate any of the underlying logic. Data structure 700 illustrates a direct association between the cmdlet and the grammar mechanism. As mentioned above, this associated may also be indirect, such as by specifying the expected parameter definitions within an external source, such as an XML document.<br>
The exemplary process flows within the administrative tool environment are now described.<br>
Exemplary Host Processing Flow<br>
FIGURE 8 is a logical flow diagram illustrating an exemplary process for host processing that is performed within the administrative tool framework shown in FIGURE 2. The process 800 begins at block 801, where a request has been received to initiate the administrative tool environment for a specific application. The request may have been sent locally through keyboard input, such as selecting an application icon, or remotely through the web services interface of a different computing device. For either scenario, processing continues to block 802.<br>
At block 802, the specific application (e.g., host program) on the "target" computing device sets up its environment. This includes determining which subsets of cmdlets (e.g., management cmdlets 232, non-management cmdlets 234, and host<br>
cmdlets 218) are made available to the user. Typically, the host program will make<br>
all the non-management cmdlets 234 available and its own host cmdlets 218<br>
available.   In addition, the host program will make a subset of the management<br>
cmdlets 234 available, such as cmdlets dealing with processes, disk, and the like.<br>
Thus,  once the host program makes the subsets of cmdlets available,  the<br>
administrative tool framework is effectively embedded within the corresponding<br>
application. Processing continues to block 804.<br>
At block 804, input is obtained through the specific application. As mentioned above, input may take several forms, such as command lines, scripts, voice, GUI, and the like. For example, when input is obtained via a command line, the input is retrieve from the keystrokes entered on a keyboard. For a GUI host, a string is composed based on the GUI. Processing continues at block 806.<br>
At block 806, the input is provided to other components within the administrative tool framework for processing. The host program may forward the input directly to the other components, such as the parser. Alternatively, the host program may forward the input via one of its host cmdlets. The host cmdlet may convert its specific type of input (e.g., voice) into a type of input (e.g., text string, script) that is recognized by the administrative tool framework. For example, voice input may be converted to a script or command line string depending on the content of the voice input. Because each host program is responsible for converting their type of input to an input recognized by the administrative tool framework, the administrative tool framework can accept input from any number of various host components. In addition, the administrative tool framework provides a rich set of utilities that perform conversions between data types when the input is forwarded via one of its cmdlets. Processing performed on the input by the other components<br>
is described below in conjunction with several other figures.   Host processing continues at decision block 808.<br>
At decision block 808, a determination is made whether a request was received for additional input. This may occur if one of the other components responsible for processing the input needs additional information from the user in order to complete its processing. For example, a password may be required to access certain data, confirmation of specific actions may be needed, and the like. For certain types of host programs (e.g., voice mail), a request such as this may not be appropriate. Thus, instead of querying the user for additional information, the host program may serialize the state, suspend the state, and send a notification so that at a later time the state may be resumed and the execution of the input be continued. In another variation, the host program may provide a default value after a predetermined time period. If a request for additional input is received, processing loops back to block 804, where the additional input is obtained. Processing then continues through blocks 806 and 808 as described above. If no request for additional input is received and the input has been processed, processing continues to block 810.<br>
At block 810, results are received from other components within the administrative tool framework. The results may include error messages, status, and the like. The results are in an object form, which is recognized and processed by the host cmdlet within the administrative tool framework. As will be described below, the code written for each host cmdlet is very minimal. Thus, a rich set of output may be displayed without requiring a huge investment in development costs. Processing continues at block 812.<br>
At block 812, the results may be viewed. The host cmdlet converts the results to the display style supported by the host program. For example, a returned<br>
 object may be displayed by a GUI host program using a graphical depiction, such as<br>
an icon, barking dog, and the like. The host cmdlet provides a default format and<br>
output for the data. The default format and output may utilize the exemplary output<br>
processing cmdlets described below in conjunction with FIGURES 19-23.  After<br>
the results are optionally displayed, the host processing is complete.<br>
Exemplary Process Flows for Handling Input<br>
FIGURE 9 is a logical flow diagram illustrating an exemplary process for handling input that is performed within the administrative tool framework shown in FIGURE 2. Processing begins at block 901 where input has been entered via a host program and forwarded to other components within the administrative tool framework. Processing continues at block 902.<br>
At block 902, the input is received from the host program. In one exemplary administrative tool framework, the input is received by the parser, which deciphers the input and directs the input for further processing. Processing continues at decision block 904.<br>
At decision block 904, a determination is made whether the input is a script. The input may take the form of a script or a string representing a command line (hereinafter, referred to as a "command string"). The command string may represent one or more cmdlets pipelined together. Even though the administrative tool framework supports several different hosts, each host provides the input as either a script or a command string for processing. As will be shown below, the interaction between scripts and command strings is recursive in nature. For example, a script may have a line that invokes a cmdlet. The cmdlet itself may be a script.<br>
Thus, at decision block 904, if the input is in a form of a script, processing continues at block 906, where processing of the script is performed.   Otherwise,<br>
processing continues at block 908, where processing of the command string is performed.    Once the processing performed within either block 906 or 908 is completed, processing of the input is complete. Exemplary Processing of Scripts<br>
FIGURE 10 is a logical flow diagram illustrating a process for processing a script suitable for use within the process for handling input shown in FIGURE 9. The process begins at block 1001, where the input has been identified as a script. The script engine and parser communicate with each other to perform the following functions. Processing continues at block 1002.<br>
At block 1002, pre-processing is performed on the script. Briefly, turning to FIGURE 11, a logical flow diagram is shown that illustrates a script pre-processing process 1100 suitable for use within the script processing process 1000. Script preprocessing begins at block 1101 and continues to decision block 1102.<br>
At decision block 1102, a determination is made whether the script is being run for the first time. This determination may be based on information obtained from a registry or other storage mechanism. The script is identified from within the storage mechanism and the associated data is reviewed. If the script has not run previously, processing continues at block 1104.<br>
At block 1104, the script is registered in the registry. This allows information about the script to be stored for later access by components within the administrative tool framework. Processing continues at block 1106.<br>
At block 1106, help and documentation are extracted from the script and stored in the registry. Again, this information may be later accessed by components within the administrative tool framework. The script is now ready for processing and returns to block 1004 in FIGURE 10.<br>
Returning to decision block 1102, if the process concludes that the script has run previously, processing continues to decision block 1108. At decision block 1108, a determination is made whether the script failed during processing. This information may be obtained from the registry. If the script has not failed, the script is ready for processing and returns to block 1004 in FIGURE 10.<br>
However, if the script has failed, processing continues at block 1110. At block 1110, the script engine may notify the user through the host program that the script has previously failed. This notification will allow a user to decide whether to proceed with the script or to exit the script. As mentioned above in conjunction with FIGURE 8, the host program may handle this request in various ways depending on the style of input (e.g., voice, command line). Once additional input is received from the user, the script either returns to block 1004 in FIGURE 10 for processing or the script is aborted.<br>
Returning to block 1004 in FIGURE 10, a line from the script is retrieved. Processing continues at decision block 1006. At decision block 1006, a determination is made whether the line includes any constraints. A constraint is detected by a predefined begin character (e.g., a bracket "{") and a corresponding end character (e.g., a close bracket "]"). If the line includes constraints, processing continues to block 1008.<br>
At block 1008, the constraints included in the line are applied. In general, the constraints provide a mechanism within the administrative tool framework to specify a type for a parameter entered in the script and to specify validation logic which should be performed on the parameter. The constraints are not only applicable to parameters, but are also applicable to any type of construct entered in the script, such as variables. Thus, the constraints provide a mechanism within an interpretive environment to specify a data type and to validate parameters.   In<br>
traditional   environments,  system   administrators   are  unable   to   formally  test parameters entered within a script. An exemplar}' process for applying constraints is illustrated in FIGURE 12.<br>
At decision block 1010, a determination is made whether the line from the script includes built-in capabilities. Built-in capabilities are capabilities that are not performed by the core engine. Built-in capabilities may be processed using cmdlets or may be processed using other mechanisms, such as in-line functions. If the line does not have built-in capabilities, processing continues at decision block 1014. Otherwise, processing continues at block 1012.<br>
At block 1012, the built-in capabilities provided on the line of the script are processed. Example built-in capabilities may include execution of control structures, such as "if statements, "for" loops, switches, and the like. Built-in capabilities may also include assignment type statements (e.g., a=3). Once the built-in capabilities have been processed, processing continues to decision block 1014.<br>
At decision block 1014, a determination is made whether the line of the script includes a command string. The determination is based on whether the data on the line is associated with a command string that has been registered and with a syntax of the potential cmdlet invocation. As mentioned above, the processing of command strings and scripts may be recursive in nature because scripts may include command strings and command strings may execute a cmdlet that is a script itself. If the line does not include a command string, processing continues at decision block 1018. Otherwise, processing continues at block 1016.<br>
At block 1016, the command string is processed. In overview, the processing of the command string includes identifying a cmdlet class by the parser and passing the corresponding cmdlet object to the core engine for execution. The<br>
ommand string may also include a pipelined command string that is parsed into several individual cmdlet objects and individually processed by the core engine. One exemplary process for processing command strings is described below in conjunction with FIGURE 14. Once the command string is processed, processing continues at decision block 1018.<br>
At decision block 1018, a determination is made whether there is another line in the script. If there is another line in the script, processing loops back to block 1004 and proceeds as described above in blocks 1004-1016. Otherwise, processing is complete.<br>
An exemplary process for applying constraints in block 1008 is illustrated in FIGURE 12. The process begins at block 1201 where a constraint is detected in the script or in the command string on the command line. When the constraint is within a script, the constraints and the associated construct may occur on the same line or on separate lines. When the constraint is within a command string, the constraint and the associated construct occur before the end of line indicator (e.g., enter key). Processing continues to block 1202.<br>
At block 1202, constraints are obtained from the interpretive environment. In one exemplary administrative tool environment, the parser deciphers the input and determines the occurrence of constraints. Constraints may be from one of the following categories: predicate directive, parsing directive, data validation directive, data generation directive, processing directive, encoding directive, and documentation directive. For one exemplary parsing syntax, the directives are surrounded by square brackets and describe the construct that follows them. The construct may be a function, a variable, a script, or the like.<br>
As will be described below, through the use of directives, script authors are allowed to easily type and perform processing on the parameters within the script or<br>
 command line (i.e., an interpretive environment) without requiring the script authors to generate any of the underlying logic.   Processing continues to block 1204.<br>
At block 1204, the constraints that are obtained are stored in the metadata for the associated construct. The associated construct is identified as being the first non-attribution token after one or more attribution tokens (tokens that denote constraints) have been encountered. Processing continues to block 1206.<br>
At block 1206, whenever the construct is encountered within the script or in the command string, the constraints defined within the metadata are applied to the construct. The constraints may include data type, predicate directives 1210, documentation directives 1212, parsing directives 1214, data generation directives 1216, data validation directives 1218, and object processing and encoding directives 1220. Constraints specifying data types may specify any data type supported by the system on which the administrative tool framework is running. Predicate directives 1210 are directives that indicate whether processing should occur. Thus, predicate directives 1210 ensure that the environment is correct for execution. For example, a script may include the following predicate directive:<br>
tPredicateScript("isInstalled","ApplicationZ")] •<br>
The predicate directive ensures that the correct application is installed on the computing device before running the script. Typically, system environment variables may be specified as predicate directives. Exemplary directives from directive types 1212-1220 are illustrated in Tables 1-5. Processing of the script is then complete.<br>
Thus, the present process for applying types and constraints within an interpretive environment, allows system admiiustrators to easily specify a type,<br>
 specify validation requirements, and the like without having to write the underlying logic for performing this processing. The following is an example of the constraint processing performed on a command string specified as follows:<br>
[Integer][ValidationRange(3,5)]$a=4.<br>
There are two constraints specified via attribution tokens denoted by "[]". The first attribution token indicates that the variable is a type integer and a second attribution token indicates that the value of the variable $a must be between 3 and 5 inclusive. The example command string ensures that if the variable $a is assigned in a subsequent command string or line, the variable $a will be checked against the two constraints. Thus, the following command strings would each result in an error:<br>
$a = 231<br>
Sa = "apple"<br>
$a = $(get/location).<br>
The constraints are applied at various stages within the administrative tool framework. For example, applicability directives, documentation directives, and parsing guideline directives are processed at a very early stage within the parser. Data generation directives and validation directives are processed in the engine once the parser has finished parsing all the input parameters.<br>
The following tables illustrate representative directives for the various categories, along with an explanation of the processing performed by the administrative tool environment in response to the directive.<br>
Table 1. Applicability Directives<br>
Table 2. Parsing Guideline Directives<br>
Table 3. Documentation Directives<br>
Table 4. Data Validation Directives<br>
Table 5. Processing and Encoding Directives  (Table Removed) <br>
When the exemplary administrative tool framework is operating within the .NET™ Framework, each category has a base class that is derived from a basic category class (e.g., CmdAttribute). The basic category class derives from a System.Attribute class. Each category has a pre-defined function (e.g., attrib.funcQ ) mat is called by the parser during category processing. The script author may create a custom category that is derived from a custom category class (e.g., CmdCustomAttribute).   The script author may also extend an existing category<br>
 class by deriving a directive class from the base category class for that category and<br>
override the pre-defmed function with their implementation. The script author may<br>
also override directives and add new directives to the pre-defined set of directives.<br>
The order of processing of these directives may be stored in an external data store accessible by the parser. The administrative tool framework looks for registered categories and calls a function (e.g., ProcessCustomDirective) for each of the directives in that category. Thus, the order of category processing may be dynamic by storing the category execution information in a persistent store. At different processing stages, the parser checks in the persistent store to determine if any metadata category needs to be executed at that time. This allows categories to be easily deprecated by removing the category entry from the persistent store.<br>
Exemplary Processing of Command Strings<br>
One exemplary process for processing command strings is now described. FIGURE 13 is a functional flow diagram graphically illustrating the processing of a command string 1350 through a parser 220 and a core engine 224 within the administrative tool framework shown in FIGURE 2. The exemplary command string 1350 pipelines several commands (i.e., process command 1360, where command 1362, sort command 1364, and table command 1366). The command line 1350 may pass input parameters to any of the commands (e.g., "handlecount &gt; 400" is passed to the where command 1362). One will note that the process command 1360 does not have any associated input parameters.<br>
In the past, each command was responsible for parsing the input parameters associated with the command, determining whether the input parameters were valid, and issuing error messages if the input parameters were not valid. Because the commands were typically written by various programmers, the syntax for the input<br>
 parameters on the command line was not very consistent.   In addition, if an error occurred, the error message, even for the same error, was not very consistent between the commands.<br>
For example, in a UNIX environment, an "Is" command and a "ps" command have many inconsistencies between them. While both accept an option "-w", the "-w" option is used by the "Is" command to denote the width of the page, while the "-w" option is used by the "ps" command to denote print wide output (in essence, ignoring page width). The help pages associated with the "Is" and the "ps" command have several inconsistencies too, such as having options bolded in one and not the other, sorting options alphabetically in one and not the other, requiring some options to have dashes and some not.<br>
The present administrative tool framework provides a more consistent approach and minimizes the amount of duplicative code that each developer must write. The administrative tool framework 200 provides a syntax (e.g., grammar), a corresponding semantics (e.g., a dictionary), and a reference model to enable developers to easily take advantage of common functionality provided by the administrative tool framework 200.<br>
Before describing the present invention any further, definitions for additional terms appearing through-out this specification are provided. Input parameter refers to input-fields for a cmdlet. Argument refers to an input parameter passed to a cmdlet that is the equivalent of a single string in the argv array or passed as a single element in a cmdlet object. As will be described below, a cmdlet provides a mechanism for specifying a grammar. The mechanism may be provided directly or indirectly.   An argument is one of an option, an option-argument, or an operand<br>
 following the command-name.   Examples of arguments are given based on the following command line:<br>
findstr /i /d:\winnt;\winnt\system32 aa*b *.ini.<br>
In the above command line, "findstr" is argument 0, "/i" is argument 1, 7d:\winnt;\winnt\system32" is argument 2, "aa*b" is argument 3, and "*.ini" is argument 4. An "option" is an argument to a cmdlet that is generally used to specify changes to the program's default behavior. Continuing with the example command line above, "/i" and 7d" are options. An "option-argument" is an input parameter that follows certain options. In some cases, an option-argument is included within the same argument string as the option. In other cases, the option-argument is included as the next argument. Referring again to the above command line, "winnt;\winnt\system32" is an option-argument. An "operand" is an argument to a cmdlet that is generally used as an object supplying information to a program necessary to complete program processing. Operands generally follow the options in a command line. Referring to the example command line above again, "aa*b" and "*.ini" are operands. A "parsable stream" includes the arguments.<br>
Referring to FIGURE 13, parser 220 parses a parsable stream (e.g., command string 1350) into constituent parts 1320-1326 (e.g., where portion 1322). Each portion 1320-1326 is associated with one of the cmdlets 1330-1336. Parser 220 and engine 224 perform various processing, such as parsing, parameter validation, data generation, parameter processing, parameter encoding, and parameter documentation.   Because parser 220 and engine 224 perform common<br>
 functionality on the input parameters on the command line, the administrative tool framework 200 is able to issue consistent error messages to users.<br>
As one will recognize, the executable cmdlets 1330-1336 written in accordance with the present administrative tool framework require less code than commands in prior administrative environments. Each executable cmdlet 1330-1336 is identified using its respective constituent part 1320-1326. In addition, each executable cmdlet 1330-1336 outputs objects (represented by arrows 1340, 1342, 1344, and 1346) which are input as input objects (represented by arrows 1341, 1343, and 1345) to the next pipelined cmdlet. These objects may be input by passing a reference (e.g., handle) to the object. The executable cmdlets 1330-1336 may then perform additional processing on the objects that were passed in.<br>
FIGURE 14 is a logical flow diagram illustrating in more detail the processing of command strings suitable for use within the process for handling input shown in FIGURE 9. The command string processing begins at block 1401, where either the parser or the script engine identified a command string within the input. In general the core engine performs set-up and sequencing of the data flow of the cmdlets. The set-up and sequencing for one cmdlet is described below, but is applicable to each cmdlet in a pipeline. Processing continues at block 1404.<br>
At block 1404, a cmdlet is identified. The identification of the cmdlet may be thru registration. The core engine determines whether the cmdlet is local or remote. The cmdlet may execute in the following locations: 1) within the application domain of the administrative tool framework; 2) within another application domain of the same process as the administrative tool framework; 3) within another process on the same computing device; or 4) within a remote computing device. The communication between cmdlets operating within the same<br>
 process is through objects.  The communication between cmdlets operating within different processes is through a serialized structured data format.   One exemplary serialized structured data format is based on the extensible markup language (XML). Processing continues at block 1406.<br>
At block 1406, an instance of the cmdlet object is created. An exemplary process for creating an instance of the cmdlet is described below in conjunction with FIGURE 15. Once the cmdlet object is created, processing continues at block 1408.<br>
At block 1408, the properties associated with the cmdlet object are populated. As described above, the developer declares properties within a cmdlet class or within an external source. Briefly, the administrative tool framework will decipher the incoming object(s) to the cmdlet instantiated from the cmdlet class based on the name and type that is declared for the property. If the types are different, the type may be coerced via the extended data type manager. As mentioned earlier, in pipelined command strings, the output of each cmdlet may be a list of handles to objects. The next cmdlet may inputs this list of object handles, performs processing, and passes another list of object handles to the next cmdlet. In addition, as illustrated in FIGURE 7, input parameters may be specified as coming from the command line. One exemplary method for populating properties associated with a cmdlet is described below in conjunction with FIGURE 16. Once the cmdlet is populated, processing continues at block 1410.<br>
At block 1410, the cmdlet is executed. In overview, the processing provided by the cmdlet is performed at least once, which includes processing for each input object to the cmdlet. Thus, if the cmdlet is the first cmdlet within a pipelined command string, the processing is executed once. For subsequent cmdlets, the processing is executed for each object that is passed to the cmdlet.  One exemplary<br>
 method for executing cmdlets is described below in conjunction with FIGURE 5. When the input parameters are only coming from the command line, execution of the cmdlet uses the default methods provided by the base cmdlet case.  Once the cmdlet is finished executing, processing proceeds to block 1412.<br>
At block 1412, the cmdlet is cleaned-up. This includes calling the destructor for the associated cmdlet object which is responsible for de-allocating memory and the like. The processing of the command string is then complete. Exemplary Process for Creating a Cmdlet Object<br>
FIGURE 15 is a logical flow diagram illustrating an exemplary process for creating a cmdlet object suitable for use within the processing of command strings shown in FIGURE 14. At this point, the cmdlet data structure has been developed and attributes and expected input parameters have been specified. The cmdlet has been compiled and has been registered. During registration, the class name (i.e., cmdlet name) is written in the registration store and the metadata associated with the cmdlet has been stored. The process 1500 begins at block 1501, where the parser has received input (e.g., keystrokes) indicating a cmdlet. The parser may recognize the input as a cmdlet by looking up the input from within the registry and associating the input with one of the registered cmdlets. Processing proceeds to block 1504.<br>
At block 1504, metadata associated with the cmdlet object class is read. The metadata includes any of the directives associated with the cmdlet. The directives may apply to the cmdlet itself or to one or more of the parameters. During cmdlet registration, the registration code registers the metadata into a persistent store. The metadata may be stored in an XML file in a serialized format, an external database, and the like. Similar to the processing of directives during script processing, each<br>
 category of directives is processed at a different stage.   Each metadata directive handles its own error handling. Processing continues at block 1506.<br>
At block 1506, a cmdlet object is instantiated based on the identified cmdlet class. Processing continues at block 1508.<br>
At block 1508, inforrmation is obtained about the cmdlet. This may occur through reflection or other means.The information is about the expected input parameters. As mentioned above, the parameters that are declared public (e.g., public string Name 730) correspond to expected input parameters that can be specified in a command string on a command line or provided in an input stream. The administrative tool framework through the extended type manager,.described in FIGURE 18, provides a common interface for returning the information (on a need basis) to the caller. Processing continues at block 1510.<br>
At block 1510, applicability directives (e.g., Table 1) are applied. The applicability directives insure that the class is used in certain machine roles and/or user roles. For example, certain cmdlets may only be used by Domain Administrators. If the constraint specified in one of the applicability directives is not met, an error occurs. Processing continues at block 1512.<br>
At block 1512, metadata is used to provide intellisense. At this point in processing, the entire command string has not yet been entered. The administrative tool framework, however, knows the available cmdlets. Once a cmdlet has been determined, the administrative tool framework knows the input parameters that are allowed by reflecting on the cmdlet object. Thus, the administrative tool framework may auto-complete the cmdlet once a disambiguating portion of the cmdlet name is provided, and then auto-complete the input parameter once a disambiguating portion of the input parameter has been typed on the command line.<br>
uto-completion may occur as soon as the portion of the input parameter can identify one of the input parameters unambiguously.  In addition, auto-completion may occur on cmdlet names and operands too. Processing continues at block 1514.<br>
At block 1514, the process waits until the input parameters for the cmdlet have been entered. This may occur once the user has indicated the end of the command string, such as by hitting a return key. In a script, a new line indicates the end of the command string. This wait may include obtaining additional information from the user regarding the parameters and applying other directives. When the cmdlet is one of the pipelined parameters, processing may begin immediately. Once, the necessary command string and input parameters have been provided, processing is complete.<br>
Exemplary Process for Populating the Cmdlet<br>
An exemplary process for populating a cmdlet is illustrated in FIGURE 16 and is now described, in conjunction with FIGURE 5. In one exemplary administrative tool framework, the core engine performs the processing to populate the parameters for the cmdlet. Processing begins at block 1601 after an instance of a cmdlet has been created. Processing continues to block 1602.<br>
At block 1602, a parameter (e.g., ProcessName) declared within the cmdlet is retrieved. Based on the declaration with the cmdlet, the core engine recognizes that the incoming input objects will provide a property named "ProcessName". If the type of the incoming property is different than the type specified in the parameter declaration, the type will be coerced via the extended type manager. The process of coercing data types is explained below in the subsection entitled "Exemplary Extended Type Manager Processing." Processing continues to block 1603.<br>
At block 1603, an attribute associated with the parameter is obtained. The attribute identifies whether the input source for the parameter is the command line or whether it is from the pipeline. Processing continues to decision block 1604.<br>
At decision block 1604, a determination is made whether the attribute specifies the input source as the command line. If the input source is the command line, processing continues at block 1609. Otherwise, processing continues at decision block 1605.<br>
At decision block 1605, a determination is made whether the property name specified in the declaration should be used or whether a mapping for the property name should be used. This determination is based on whether the command input specified a mapping for the parameter. The following line illustrates an exemplary mapping of the parameter "ProcessName" to the "foo" member of the incoming object:<br>
$ get/process ( where han* -gt 500 j stop/process -ProcessName
At block 1606, the mapping is applied. The mapping replaces the name of the expected parameter from "ProcessName" to "foo", which is then used by the core engine to parse the incoming objects and to identify the correct expected parameter. Processing continues at block 1608.<br>
At block 1608, the extended type manager is queried to locate a value for the parameter within the incoming object. As explain in conjunction with the extended type manager, the extended type manager takes the parameter name and uses reflection to identify a parameter within the incoming object with parameter name. The extended type manager may also perform other processing for the parameter, if necessary. For example, the extended type manager may coerce the type of data to<br>
the expected type of data through a conversion mechanism described above. Processing continues to decision block 1610.<br>
Referring back to block 1609, if the attribute specifies that the input source is the command line, data from the command line is obtained. Obtaining the data from the command line may be performed via the extended type manager. Processing then continues to decision block 1610.<br>
At decision block 1610, a determination is made whether there is another expected parameter. If there is another expected parameter, processing loops back to block 1602 and proceeds as described above. Otherwise, processing is complete and returns.<br>
Thus, as shown, cmdlets act as a template for shredding incoming data to obtain the expected parameters. In addition, the expected parameters are obtained without knowing the type of incoming object providing the value for the expected parameter. This is quite different than traditional administrative environments. Traditional administrative environments are tightly bound and require that the type of object be known at compile time. In addition, in traditional environments, the expected parameter would have been passed into the function by value or by reference. Thus, the present parsing (e.g., "shredding") mechanism allows programmers to specify the type of parameter without requiring them to specifically know how the values for these parameters are obtained.<br><br>
For example, given the following declaration for the cmdlet Foo:<br>
(Sequence Removed) <br>
The command line syntax may be any of the following:<br>
$ Foo -Name: (string) -Recurse: True S Foo -Name <string> -Recurse True $Foo -Name (string).<br>
The set of rules may be modified by system administrators in order to yield a desired syntax. In addition, the parser may support multiple sets of rules, so that more than one syntax can be used by users. In essence, the grammar associated with the cmdlet structure (e.g., string Name and Bool Recurse) drives the parser.<br>
In general, the parsing directives describe how the parameters entered as the command string should map to the expected parameters identified in the cmdlet object. The input parameter types are checked to determine whether correct. If the input parameter types are not correct, the input parameters may be coerced to<br>
become correct. If the input parameter types are not correct and can not be coerced, a usage error is printed. The usage error allows the user to become aware of the correct syntax that is expected. The usage error may obtain information describing the syntax from the Documentation Directives. Once the input parameter types have either been mapped or have been verified, the corresponding members in the cmdlet object instance are populated. As the members are populated, the extended type manager provides processing of the input parameter types. Briefly, the processing may include a property path mechanism, a key mechanism, a compare mechanism, a conversion mechanism, a globber mechanism, a relationship mechanism, and a property set mechanism. Each of these mechanisms is described in detail below in the section entitled "Extended Type Manager Processing", which also includes illustrative examples.<br>
Exemplary Process for Executing the Cmdlet<br>
An exemplary process for executing a cmdlet is illustrated in FIGURE 17 and is now described. In one exemplary administrative tool environment, the core engine executes the cmdlet. As mentioned above, the code 1442 within the second method 1440 is executed for each input object. Processing begins at block 1701 where the cmdlet has already been populated. Processing continues at block 1702.<br>
At block 1702, a statement from the code 542 is retrieved for execution. Processing continues at decision block 1704.<br>
At decision block 1704, a determination is made whether a hook is included within the statement. Turning briefly to FIGURE 5, the hook may include calling an API provided by the core engine. For example, statement 550 within the code 542 of cmdlet 500 in FIGURE 5 calls the confirmprocessing API specifying the<br>
4<br>
necessary parameters, a first string (e.g., "PID="), and a parameter (e.g., PID). Turning back to FIGURE 17, if the statement includes the hook, processing<br>
continues to block 1712. Thus, if the instruction calling the confirmprocessing API is specified, the cmdlet operates in an alternate executing mode that is provided by the operating environment.   Otherwise, processing continues at block 1706 and execution continues in the "normal" mode.<br>
At block 1706, the statement is processed. Processing then proceeds to decision block 1708. At block 1708, a determination is made whether the code includes another statement. If there is another statement, processing loops back to block 1702 to get the next statement and proceeds as described above. Otherwise, processing continues to decision block 1714.<br>
At decision block 1714, a determination is made whether there is another input object to process. If there is another input object, processing continues to block 1716 where the cmdlet is populated with data from the next object. The population process described in FIGURE 16 is performed with the next object. Processing then loops back to block 1702 and proceeds as described above. Once all the objects have been processed, the process for executing the cmdlet is complete and returns.<br>
Returning back to decision block 1704, if the statement includes the hook, processing continues to block 1712. At block 1712, the additional features provided by the administrative tool environment arc processed. Processing continues at decision block 1708 and continues as described above.<br>
The additional processing performed within block 1712 is now described in conjunction with the exemplary data structure 600 illustrated in FIGURE 6. As explained above, within the command base class 600 there may be parameters declared that correspond to additional expected input parameters (e.g., a switch).<br>
The switch includes a predetermined string, and when recognized, directs the core engine to provide additional functionality to the cmdlet.   If the parameter<br>
 verbose 610 is specified in the command input, verbose statements 614 are<br>
executed. The following is an example of a command line that includes the verbose<br>
switch:<br>
$ get/process j where "han* -gt 500" | stop/process -verbose.<br>
In general, when "-verbose" is specified within the command input, the core engine executes the command for each input object and forwards the actual command that was executed for each input object to the host program for display. The following is an example of output generated when the above command line is executed in the exemplary administrative tool environment:<br>
$ stop/process PID=15 $ stop/process PID=33.<br>
If the parameter whatif 620 is specified in the command input, whatif statements 624 are executed. The following is an example of a command line that includes the whatif switch:<br>
$ get/process | where "han* -gt 500" | stop/process -whatif.<br>
In general, when "-whatif is specified, the core engine does not actually execute the code 542, but rather sends the commands that would have been executed to the host program for display. The following is an example of output generated when the above command line is executed in the administrative tool environment of the present invention:<br>
#$ stop/process PID^IS #$ stop/process PID=33.<br>
If the parameter confirm 630 is specified in the command input, confirm statements 634 are executed. The following is an example of a command line that includes the confirm switch:<br>
$ get/process | where "han* -gt 500" | stop/process -confirm.<br>
In general, when "-confirm" is specified, the core engine requests additional user input on whether to proceed with the command or not. The following is an example of output generated when the above command line is executed in the administrative tool environment of the present invention.<br>
$ stop/process PID 15<br>
Y/N Y<br>
$ stop/process PID 33<br>
Y/NN.<br>
As described above, the exemplary data structure 600 may also include a security method 640 that determines whether the task being requested for execution should be allowed. In traditional administrative environments, each command is responsible for checking whether the person executing the command has sufficient privileges to perform the command. In order to perform this check, extensive code is needed  to  access  information  from  several  sources.     Because  of these<br>
complexities, many commands did not perform a security check. The inventors of the present administrative tool environment recognized that when the task, is specified in the command input, the necessary information for performing the security check is available within the administrative tool environment. Therefore, the administrative tool framework performs the security check without requiring complex code from the tool developers. The security check may be performed for any cmdlet that defines the hook within its cmdlet. Alternatively, the hook may be an optional input parameter that can be specified in the command input, similar to the verbose parameter described above.<br>
The security check is implemented to support roles based authentication, which is generally defined as a system of controlling which users have access to resources based on the role of the user. Thus, each role is assigned certain access rights to different resources. A user is then assigned to one or more roles. In general, roles based authentication focus on three items: principle, resource, and action. The principle identifies who requested the action to be performed on the resource.<br>
The inventors of the present invention recognized that the cmdlet being requested corresponded to the action that was to be performed. In addition, the inventors appreciated that the owner of the process in which the administrative tool framework was executing corresponded to the principle. Further, the inventors appreciated that the resource is specified within the cmdlet. Therefore, because the administrative tool framework has access to these items, the inventors recognized that the security check could be performed from within the administrative tool framework without requiring tool developers to implement the security check.<br>
The operation of the security check may be performed any time additional functionality is requested within the cmdlet by using the hook, such as the<br>
 confirmprocessing API. Alternatively, security check may be performed by checking whether a security switch was entered on the command line, similar to verbose, whatif, and confirm. For either implementation, the checkSecurity method calls an API provided by a security process (not shown) that provides a set of APIs for determining who is allowed. The security process takes the information provided by the administrative tool framework and provides a result indicating whether the task may be completed. The administrative tool framework may then provide an error or just stop the execution of the task.<br>
Thus, by providing the hook within the cmdlet, the developers may use additional processing provided by the administrative tool framework. Exemplary Extended Type Manager Processing<br>
As briefly mentioned above in conjunction with FIGURE 18, the extended type manager may perform additional processing on objects that are supplied. The additional processing may be performed at the request of the parser 220, the script engine 222, or the pipeline processor 402. The additional processing includes a property path mechanism, a key mechanism, a compare mechanism, a conversion mechanism, a globber mechanism, a relationship mechanism, and a property set mechanism. Those skilled in the art will appreciate that the extended type manager may also be extended with other processing without departing from the scope of the claimed invention. Each of the additional processing mechanisms is now described.<br>
First, the property path mechanism allows a string to navigate properties of objects. In current reflection systems, queries may query properties of an object. However, in the present extended type manager, a string may be specified that will provide a navigation path to successive properties of objects. The following is an illustrative syntax for the property path: PI .P2.P3.P4.<br>
 Each component (e.g., PI, P2, P3, and P4) comprises a string that may represent a property, a method with parameters, a method without parameters, a field, an XPATH, or the like. An XPATH specifies a query string to search for an element (e.g., "/FOO@=13"). Within the string, a special character may be included to specifically indicate the type of component. If the string does not contain the special character, the extended type manager may perform a lookup to determine the type of component. For example, if component PI is an object, the extended type manager may query whether P2 is a property of the object, a method on the object, a field of the object, or a property set. Once the extended type manager identifies the type for P2, processing according to that type is performed. If the component is not one of the above types, the extended type manager may further query the extended sources to determine whether there is a conversion function to convert the type of PI into the type of P2. These and other lookups will now be described using illustrative command strings and showing the respective output.<br>
The following is an illustrative string that includes a property path:<br>
$ get/process j /where hand* -gt&gt; 500 | format/table name.toupper, ws.kb, exe*.ver*.description.tolower.trunc(30).<br>
In the above illustrative string, there are three property paths: (1) "name.toupper"; (2) "ws.kb"; and (3) "exe*.ver*.description.tolower,trunc(30). Before describing these property paths, one should note that "name", "ws", and "exe" specify the properties for the table. In addition, one should note that each of these properties is a direct property of the incoming object, originally generated by "get/process" and then pipelined through the various cmdlets. Processing involved for each of the three property paths will now be described.<br>
 In the first property path (i.e., "name .toupper"), name is a direct property of the incoming object and is also an object itself. The extended type manager queries the system using the priority lookup described above to determine the type for toupper. The extended type manager discovers that toupper is not a property. However, toupper may be a method inherited by a string type to convert lower case letters to upper case letters within the string. Alternatively, the extended type manager may have queried the extended metadata to determine whether there is any third party code that can convert a name object to upper case. Upon finding the component type, processing is performed in accordance with that component type.<br>
In the second property path (i.e., "ws.kb"), "ws" is a direct property of the incoming object and is also an object itself. The extended type manager determines that "ws" is an integer. Then, the extended type manager queries whether kb is a property of an integer, whether kb is a method of an integer, and finally queries whether any code knows how to take an integer and convert the integer to a kb type. Third party code is registered to perform this conversion and the conversion is performed.<br>
In the third property path (i.e., "exe*.ver*.description.tolower.trunc(30)"), there are several components. The first component ("exe*") is a direct property of the incoming object and is also an object. Again, the extended type manager proceeds down the lookup query in order to process the second component ("ver*). The "exe* object does not have a "ver*" property or method, so the extend type manager queries the extended metadata to determine whether there is any code that is registered to convert an executable name into a version. For this example, such code exists. The code may take the executable name string and use it to open a file, then accesses the version block object, and return the description property (the third<br><br>
 component ("description") of the version block object. The extended type manager<br>
then performs this same lookup mechanism for the fourth component ("tolower")<br>
and the fifth component ("trunc(40)").    Thus, as illustrated, the extended type<br>
manager may perform quite elaborate processing on a command string without the<br>
administrator needing to write any specific code.    Table  1  illustrates output<br>
generated for the illustrative string.<br>
(Table Removed) <br>
Table 1.<br>
Another query mechanism 1824 includes a key. The key identifies one or more properties that make an instance of the data type unique. For example, in a database, one column may be identified as the key which can uniquely identify each row (e.g., social security number). The key is stored within the type metadata 1840 associated with the data type. This key may then be used by the extended type manager when processing objects of that data type. The data type may be an extended data type or an existing data type.<br>
Another query mechanism 1824 includes a compare mechanism. The compare mechanism compares two objects. If the two objects directly support the compare function, the directly supported compare function is executed. However, if neither object supports a compare function, the extended type manager may look in the type metadata for code that has been registered to support the compare<br>
between the two objects.  An illustrative series of command line strings invoking<br>
the compare mechanism is shown below, along with corresponding output in Table<br>
2.<br>
 (Table Removed) <br>
Table 2.<br>
Compare/time cmdlet is written to compare two datetime objects.   In this case, the DateTime object supports the IComparable interface.<br>
Another query mechanism 1824 includes a conversion mechanism.   The extended type manager allows code to be registered stating its ability to perform a<br>
specific conversion. Then, when an object of type A is input and a cmdlet specifies an object of type B, the extended type manager may perform the conversion using one of the registered conversions. The extended type manager may perform a series of conversions in order to coerce type A into type B. The property path described above ("ws.kb") illustrates a conversion mechanism.<br>
Another query mechanism 1824 includes a globber mechanism. A globber refers to a wild card character within a string. The globber mechanism inputs the string with the wild card character and produces a set of objects. The extended type manager allows code to be registered that specifies wildcard processing. The property path described above ("exe*.ver*.description.tolower.trunc(30)) illustrates the globber mechanism. A registered process may provide globbing for file names, file objects, incoming properties, and the like.<br>
Another query mechanism 1824 includes a property set mechanism. The property set mechanism allows a name to be defined for a set of properties. An administrator may then specify the name within the command string to obtain the set of properties. The property set may be defined in various ways. In one way, a predefined parameter, such as "?", may be entered as an input parameter for a cmdlet. The operating environment upon recognizing the predefined parameter lists all the properties of the incoming object. The list may be a GUI that allows an administrator to easily check (e.g., "click on") the properties desired and name the property set. The property set information is then stored in the extended metadata. An illustrative string invoking the property set mechanism is shown below, along with corresponding output in Table 3:<br>
$ get/process | where han* -gt&gt; 500 j format/table config.<br>
In this illustrative string, a property set named "config" has been defined to<br>
include a name property, a process id property (Pid), and a priority property.  The<br>
output for the table is shown below.<br>
Table 3. (Table Removed) <br>
Another query mechanism 1824 includes a relationship mechanism. In contrast to traditional type systems that support one relationship (i.e., inheritance), the relationship mechanism supports expressing, more than one relationship between types. Again, these relationships are registered. The relationship may include finding items that the object consumes or finding the items that consume the object. The extended type manager may access ontologies that describe various relationships. Using the extended metadata and the code, a specification for accessing any ontology service, such as OWL, DAWL, and the like, may be described. The following is a portion of an illustrative string which utilizes the relationship mechanism: .OWL:"string".<br>
The "OWL" identifier identifies the ontology service and the "string" specifies the specific string within the ontology service.   Thus, the extended type manager may access types supplied by ontology services. Exemplary Process for Displaying Command Line Data<br>
The present mechanism provides a data driven command line output. The formatting and outputting of the data is provided by one or more cmdlets in the pipeline of cmdlets. Typically, these cmdlets are included within the non-management cmdlets described in conjunction with FIGURE 2 above. The cmdlets may include a format cmdlet, a markup cmdlet, a convert cmdlet, a transform cmdlet, and an out cmdlet.<br>
FIGURE 19 graphically depicts exemplary sequences 1901-1907 of these cmdlets within a pipeline. The first sequence 1901 illustrates the out cmdlet 1910 as the last cmdlet in the pipeline. In the same manner as described above for other cmdlets, the out cmdlet 1910 accepts a stream of pipeline objects generated and processed by other cmdlets within the pipeline. However, in contrast to. most cmdlets, the out cmdlet 1910 does not emit pipeline objects for other cmdlets. Instead, the out cmdlet 1910 is responsible for rendering/displaying the results generated by the pipeline. Each out cmdlet 1910 is associated with an output destination, such as a device, a program, and the like. For example, for a console device, the out cmdlet 1910 may be specified as outfconsole; for an internet browser, the out cmdlet 1910 may be specified as out/browser; and for a window, the out cmdlet 1910 may be specified as out/window. Each specific out cmdlet is familiar with the capabilities of its associated destination. Locale information (e.g., date ¤cy formats) are processed by the out cmdlet 1910, unless a convert cmdlet preceded the out cmdlet in the pipeline. In this situation, the convert cmdlet processed the local information.<br>
Each host is responsible for supporting certain out cmdlets, such as out/console. The host also supports any destination specific host cmdlet (e.g., out/chart that directs output to a chart provided by a spreadsheet application). In addition, the host is responsible for providing default handling of results.  The out<br>
cmdlet in this sequence may decide to implement its behavior by calling other output processing cmdlets (such as format/markup/convert/transform).   Thus, the out cmdlet may implicitly modify sequence 1901 to any of the other sequences or may add its own additional format/output cmdlets.<br>
The second sequence 1902 illustrates a format cmdlet 1920 before the out cmdlet 1910. For this sequence, the format cmdlet 1920 accepts a stream of pipeline objects generated and processed by other cmdlets within the pipeline. In overview, the format cmdlet 1920 provides a way to select display properties and a way to specify a page layout, such as shape, column widths, headers, footers, and the like. The shape may include a table, a wide list, a columnar list, and the like. In addition, the format cmdlet 1920 may include computations of totals or sums. Exemplary processing performed by a format cmdlet 1920 is described below in conjunction with FIGURE 20. Briefly, the format cmdlet emits format objects, in addition to emitting pipeline objects. The format objects can be recognized downstream by an out cmdlet (e.g., out cmdlet 1920 in sequence 1902) via the extended type manager or other mechanism. The out cmdlet 1920 may choose to either use the emitted format objects or may choose to ignore them. The out cmdlet determines the page layout based on the page layout data specified in the display information. In certain instances, modifications to the page layout may be specified by the out cmdlet. In one exemplary process the out cmdlet may determine an unspecified column width by finding a maximum length for each property of a predetermined number of objects (e.g., 50) and setting the column width to the maximum length. The format objects include formatting information, header/footer information, and the like.<br>
The third sequence 1903 illustrates a format cmdlet 1920 before the out cmdlet 1910.   However, in the third sequence 1903, a markup cmdlet 1930 is<br>
 pipelined between the format cmdlet 1920 and the out cmdlet 1910.  The markup<br>
cmdlet 1930 provides a mechanism for adding property annotation (e.g., font, color) to selected parameters. Thus, the markup cmdlet 1930 appears before the output cmdlet 1910. The property annotations may be implemented using a "shadow property bag", or by adding property annotations in a custom namespace in a property bag. The markup cmdlet 1930 may appear before the format cmdlet 1920 as long as the markup annotations may be maintained during processing of the format cmdlet 1920.<br>
The fourth sequence 1904 again illustrates a format cmdlet 1920 before the out cmdlet 1910. However, in the fourth sequence 1904, a convert cmdlet 1940 is pipelined between the format cmdlet 1920 and the out cmdlet 1910. The convert cmdlet 1940 is also configured to process the format objects emitted by the format cmdlet 1920. The convert cmdlet 1940 converts the pipelined objects into a specific encoding based on the format objects. The convert cmdlet 1940 is associated with the specific encoding. For example, the convert cmdlet 1940 that converts the pipelined objects into Active Directory Objects (ADO) may be declared as "convert/ADO" on the command line. Likewise, the convert cmdlet 1940 that converts the pipelined objects into comma separated values (csv) may be declared as "convert/csv" on the command line. Some of the convert cmdlets 1940 (e.g., convert/XML and convert/html) may be blocking commands, meaning that all the pipelined objects are received before executing the conversion. Typically, the out cmdlet 1920 may determine whether to use the formatting information provided by the format objects. However, when a convert cmdlet 1920 appears before the out cmdlet 1920, the actual data conversion has already occurred before the out cmdlet receives the objects. Therefore, in this situation, the out cmdlet can not ignore the conversion.<br>
 The fifth sequence 1905 illustrates a format cmdlet 1920, a markup cmdlet<br>
1930, a convert cmdlet 1940, and an out cmdlet 1910 in that order.   Thus, this<br>
illustrates that the markup cmdlet 1930 may occur before the convert cmdlet 1940.<br>
The sixth sequence 1906 illustrates a format cmdlet 1920, a specific convert cmdlet (e.g., convert/xml cmdlet 1940'), a specific transform cmdlet (e.g., transform/xslt cmdlet 1950), and an out cmdlet 1910. The convert/xml cmdlet 1940' converts the pipelined objects into an extended markup language (XML) document. The transform/xslt cmdlet 1950 transforms the XML document into another XML document using an Extensible Style Lanuagc (XSL) style sheet. The transform process is commonly referred to as extensible style language transformation (XSLT), in which an XSL processor reads the XML document and follows the instructions within the XSL style sheet to create the new XML document.<br>
The seventh sequence 1907 illustrates a format cmdlet 1920, a. markup cmdlet 1930, a specific convert cmdlet (e.g., convert/xml cmdlet 1940'), a specific transform cmdlet (e.g., transform/xslt cmdlet 1950), and an out cmdlet 1910. Thus, the seventh sequence 1907 illustrates having the markup cmdlet 1930 upstream from the convert cmdlet and transform cmdlet.<br>
FIGURE 20 illustrates exemplary processing 2000 performed by a format cmdlet. The formatting process begins at block 2001, after the format cmdlet has been parsed and invoked by the parser and pipeline processor in a manner described above. Processing continues at block 2002.<br>
At block 2002, a pipeline object is received as input to the format cmdlet. Processing continues at block 2004.<br>
At block 2004, a query is initiated to identify a type for the pipelined object. This query is performed by the extended type manager as described above in<br>
 conjunction with FIGURE 18.  Once the extended type manager has identified the type for the object, processing continues at block 2006.<br>
At block 2006, the identified type is looked up in display information. An exemplary format for the display information is illustrated in FIGURE 21 and will be described below. Processing continues at decision block 2008.<br>
At decision block 2008, a determination is made whether the identified type is specified within the display information. If there is no entry within the display information for the identified type, processing is complete. Otherwise, processing continues at block 2010.<br>
At block 2010, formatting information associated with the identified type is obtained from the display information. Processing continues at block 2012.<br>
At block 2012, information is emitted on the pipeline. Once the information is emitted, the processing is complete.<br>
Exemplary information that may be emitted is now described in further detail. The information may include formatting information, header/footer information, and a group end/begin signal object The formatting information may include a shape, a label, numbering/bullets, column widths, character encoding type, content font properties, page length, group-by-property name, and the like. Each of these may have additional specifications associated with it. For example, the shape may specify whether the shape is a table, a list, or the like. Labels may specify whether to use column headers, list labels, or the like. Character encoding may specify ASCII, UTF-8, Unicode, and the like. Content font properties may specify the font that is applied to the property values that are display. A default font property (e.g., Courier New, 10 point) may be used if content font properties are not specified.<br><br>
The header/footer information may include a header/footer scope, font properties, title, subtitle, date, time, page numbering, separator, and the like. For example, the scope may specify a document, a page, a group, or the like. Additional properties may be specified for either the header or the footer. For example, for group and document footers, the additional properties may include properties or columns to calculate a sum/total, object counts, label strings for totals and counts, and the like.<br>
The group end/begin signal objects are emitted when the format cmdlet detects that a group-by property has changed. When this occurs, the format cmdlet treats the stream of pipeline objects as previously sorted and does not re-sort them. The group endVbegin signal objects may be interspersed with the pipeline objects. Multiple group-by properties may be specified for nested sorting. The format cmdlet may also emit a format end object that includes final sums and totals.<br>
Turning briefly to FIGURE 21, an exemplary display information 2100 is in a structured format and contains information (e.g., formatting information, header/footer information, group-by properties or methods) associated with each object that has been defined. For example, the display information 2100 may be XML-based. Each of the afore-mentioned properties may then be specified within the display information. The information within the display information 2100 may be populated by the owner of the object type that is being entered. The operating environment provides certain APIs and cmdlets that allow the owner to update the display information by creating, deleting, and modifying entries.<br>
FIGURE 22 is a table listing an exemplary syntax 2201-2213 for certain format cmdlets (e., format/table, format/list, and format/wide), markup cmdlets (e.g., add/markup), convert cmdlets (e.g., convert/text, convert/sv, convert/csv, convert/ADO,     convert/XML,      convert/html),     transform     cmdlets      (e.g.,<br>
 transform/XSLT)  and out cmdlets  (e.g., out/console,  out/file).     FIGURE 23 illustrates results  rendered by the out/console cmdlet using various pipeline sequences of the output processing cmdlets (e.g., format cmdlets, convert cmdlets, and markup cmdlets).<br>
Because the present administrative tool framework allows tasks to be initiated from any host (e.g., the user-interface, the command line, programmatically), system administrators and product developers may share code and experiences which will make both types of users more effective and efficient. In addition, system administrators will only need to learn one set of concepts, commands, and troubleshooting techniques. Likewise, product developers will only need to create one provider cmdlet to leverage all the management tools.<br>
Thus, as described, because the present administrative tool framework simplifies the access to and the control of management objects and provides transparent remoting, the present administrative tool framework decreases the skill level that is required to develop administrative tools. In addition, the framework allows developers to see the scripts run by GUI interactions which help the developers learn the framework and to create their own automated scripts. In addition, because testing has already been performed on the functionality provided by the framework, product level testing is reduced to only testing the GUI paths to invoke functions provided by the framework. Another benefit is that the management GUI can expose its inner workings via cmdlets which provides developers and testers easy access to the internal state and control of the GUI for debugging/diagnostics/automated test.<br>
Although details of specific implementations and embodiments are described above, such details are intended to satisfy statutory disclosure obligations rather than to limit the scope of the following claims. Thus, the invention as defined by<br><br>
the claims is not limited to the specific features described above.   Rather, the invention is claimed in any of its forms or modifications that fall within the proper scope of the appended claims, appropriately interpreted in accordance with the doctrine of equivalents.<br><br><br><br><br><br><br><br>
CLAIMS<br>
1.	At least one computer-readable medium having computer executable<br>
instructions that provide a framework for automating administrative tasks, the<br>
framework comprising:<br>
a parser component configured to parse input and to identify at least one cmdlet based on the input; and<br>
an engine component configured to populate a parameter associated with the cmdlet using information from an input source, and to execute the cmdlet to generate a precisely parseable stream, wherein the input source comprises the precisely parseable stream emitted from another cmdlet.<br>
2.	The computer-readable medium of claim 1, further comprising; a host component configured to supply the input about at least one command.<br>
3.	The computer-readable medium of claim 2, wherein the host component supplies the input directly to the parser component.<br>
4.	The computer-readable medium of claim 2, wherein the host component supplies the input using a host cmdlet that is processed as one of the crndlets within the engine compdhent.<br>
5.	The computer-readable medium of claim 1, wherein the cmdiet includes a base cmdiet that provides a common utility that operates on a plurality of data types.<br>
6.	The computer-readable medium of claim 1, wherein the cmdiet includes a host cmdiet that provides a system utility.<br>
7.	The computer-readable medium of claim 1, wherein the parameter being associated with the cmdiet comprises a parameter declaration for the parameter within the cmdiet.<br>
8.	The computer-readable medium of claim 1, wherein the, parameter being associated with the cmdiet comprises a reference to an external source defining the parameter.<br>
9.	The computer-readable medium of claim 1, wherein the cmdiet includes a provider cmdiet that provides functionality associated with an application.<br>
10.	At least one computer-readable medium containing instructions that<br>
perform the following when executed by one or more computers:<br>
receiving input;<br>
associating a cmdlet with the input, the cmdlet identifying at least one expected input parameter;<br>
for each expected input parameter that specifies obtaining data from the input, populating the expected input parameter with data from the input; and<br>
for each expected input parameter that specifies obtaining information from an input stream to the cmdlet, populating the expected input parameter with the informatipn, executing the cmdlet to generate an object stream based on the information and the data, and emitting-the object stream, wherein the input stream comprises the object stream emitted by another cmdlet.<br>
11.	The computer-readable medium of claim 10, wherein the input object comprises a .NET object, an XML document, or an Active Directory Object.<br>
12.	The computer-readable medium of claim 10, wherein the cmdlet and the other cmdlet operate in a same process.<br>
13.	The computer-readable medium of claim 10, wherein the cmdlet operates in a local process and the other cmdlet operates in a remote process.<br>
14.	The computer-readable medium of claim 10, wherein the input comprises a string.<br>
15.	The computer-readable medium of claim 10, wherein the input comprises a script.<br>
16.	A system that provides an administrative tool framework for automating administrative tasks, comprising:<br>
a processor; and<br>
a memory, the memory being allocated for a plurality of computer-executable instructions which are loaded into the memory for execution by the processor, the computer-executable instructions providing a method for automating administrative tasks, the method comprising:<br>
receiving receive input about at least one command;<br>
parsing the input to idenity one cmdlet<br>
populating a parameter defined within the cmdlet with information from an input source;<br>
executing the cmdlet to generate an object stream; and<br>
outputting the object stream.<br>
17. the system of claim 16, wherein the input source comprises the object stream generated by another cmdlet.<br>
18.	An administrative framework configured to operate on a computing<br>
device, the administrative framework comprising:<br>
a means for receiving input;<br>
a means for parsing the input into at least one cmdlet, the cmdlet providing a means for describing at least one expected input parameter associated with an input source;<br>
a means for populating each expected input parameter; and<br>
a means for processing the cmdlet in a manner such that the input source comprises an output strearh generated by another cmdlet.<br>
19.	The administrative framework of claim 18, wherein the one cmdlet and the other cmdlet execute within a same process.<br>
20.	The administrative framework of claim 18, wherein the object stream comprises .NET objects.<br>
21.	The administrative framework of claim 18, wherein processing the cmdlet includes populating at least one expected input property with information obtained from the object stream.<br>
22.	The administrative framework of claim i8, wherein the at least one cmdlets includes a base cmdlet provided by the administrative framework.<br>
23.	The administrative framework of claim 18, wherein the at least one cmdlets incudes a third party cmdlet provided by a third party developer.<br>
24.	The administrative framework of claim 18, further providing a<br>
means for accessing the cmdlet on a remote computing device.<br>
25.      A computer, readable medium containing instructions that perform the<br>
following when executed by a computer:<br>
accepting user input;<br>
converting user input to a input format recognized by an administrative tool framework; and<br>
forwarding the input format to the administrative tool framework, the admimstrative tool framework configured to:<br>
parse the input format;<br>
instantiate a cmdlet based on the input, the cmdlet specifying air expected input parameter; and<br>
. populating the expected input parameter from an input source.<br>
26.	The computer readable medium of claim 25, wherein the input source comprises the input format.<br>
27.	The computer readable medium of claim 25, wherem the input source comprises an input stream emitted from another cmdlet.<br>
28.	The computer readable medium of claim 25, further comprising providing a host cmdlet that provides an interface between a host application and the administrative tool framework.<br>
29.	The computer readable medium of claim 25, wherein the user input comprises voice input.<br>
30.	The computer readable medium of claim 25, wherein the user input comprises a command string entered on a command line.<br></string></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LWFzc2lnbm1lbnQucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LUNsYWltcy0oMDEtMDgtMjAxMykucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-Claims-(01-08-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LUNsYWltcy0oMTktMDItMjAxNCkucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-Claims-(19-02-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMTktMDItMjAxNCkucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-Correspondence Others-(19-02-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LUNvcnJlc3BvbmRlbmNlLU90aGVyLSgwNC0wNC0yMDEzKS5wZGY=" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-Correspondence-Other-(04-04-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1ERUxOUC0yMDA1LUNvcnJlc3BvbmRlbmNlLU90aGVycy0oMDEtMDYtMjAxMCkucGRm" target="_blank" style="word-wrap:break-word;">1815-DELNP-2005-Correspondence-Others-(01-06-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LUNvcnJlc3BvbmRlbmNlLU90aGVycy0oMDEtMDgtMjAxMykucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-Correspondence-Others-(01-08-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LUNvcnJlc3BvbmRlbmNlLU90aGVycy0oMTYtMTItMjAxMCkucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-Correspondence-Others-(16-12-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LURyYXdpbmdzLSgwMS0wOC0yMDEzKS5wZGY=" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-Drawings-(01-08-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LUZvcm0tMS0oMTYtMTItMjAxMCkucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-Form-1-(16-12-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LWZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LUZvcm0tMi0oMDEtMDgtMjAxMykucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-Form-2-(01-08-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LUZvcm0tMy0oMDQtMDQtMjAxMykucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-Form-3-(04-04-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1ERUxOUC0yMDA1LUdQQS0oMDEtMDYtMjAxMCkucGRm" target="_blank" style="word-wrap:break-word;">1815-DELNP-2005-GPA-(01-06-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LWdwYS5wZGY=" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LXBjdC0xMDEucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-pct-101.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LXBjdC0xMDUucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-pct-105.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LXBjdC0zMDEucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-pct-301.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LXBjdC0zMDQucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-pct-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LVBldGl0aW9uLTEzNy0oMDEtMDgtMjAxMykucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-Petition-137-(01-08-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTgxNS1kZWxucC0yMDA1LVBldGl0aW9uLTEzNy0oMDQtMDQtMjAxMykucGRm" target="_blank" style="word-wrap:break-word;">1815-delnp-2005-Petition-137-(04-04-2013).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="259412-a-method-of-assigning-frequency-subbands-in-a-communication-system-and-apparatus-thereof.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="259414-a-subscriber-unit.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>259413</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1815/DELNP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>11/2014</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>14-Mar-2014</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>12-Mar-2014</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>03-May-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>MICROSOFT CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>ONE MICROSOFT WAY, REDMOND, WASHINGTON 98052, USA.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>DARYL W. WRAY</td>
											<td>16426 NE 40th STREET, REDMOND, WASHINGTON 98052, USA.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>JAMES W. TRUHER III</td>
											<td>6006-147th AVENUE SE, BELLEVUE, WASHINGTON 98006, USA.</td>
										</tr>
										<tr>
											<td>3</td>
											<td>BRUCE G. PAYETTE</td>
											<td>16423 SE 15th STREET, BELLEVUE, WASHINGTON 98008, USA.</td>
										</tr>
										<tr>
											<td>4</td>
											<td>JEFFREY P. SNOVER</td>
											<td>12208 202nd AVENUE NE, WOODINVILLE, WASHINGTON 98077, USA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US04/023730</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-07-23</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/693,785</td>
									<td>2003-10-24</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/259413-systems-and-method-for-automating-system-related-administrative-tasks by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 02:05:17 GMT -->
</html>
