<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/278967-efficient-generation-of-executable-file-from-program-files-when-some-of-the-program-files-expressly-incorp0orate-other-program-files by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:57:51 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 278967:EFFICIENT GENERATION OF EXECUTABLE FILE FROM PROGRAM FILES WHEN SOME OF THE PROGRAM FILES EXPRESSLY INCORP0ORATE OTHER PROGRAM FILES</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">EFFICIENT GENERATION OF EXECUTABLE FILE FROM PROGRAM FILES WHEN SOME OF THE PROGRAM FILES EXPRESSLY INCORP0ORATE OTHER PROGRAM FILES</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Efficient generation of executable file from program files when some of the program files expressly incorporate other program files. In an embodiment, dependency information representing which program files (conditionally or unconditionally) incorporate other program files is generated and stored in a secondary (non-volatile) storage. When some program files are modified, the dependency information is used to identify for recompilation all the program files that incorporate any of the modified program files. The modified program files and the identified program files are recompiled and the executable file is regenerated.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT, 1970 <br>
(39 of 1970)<br>
PROVISIONAL / COMPLETE SPECIFICATION<br>
(See section 10; rule 13)<br>
1.TITLE OF THE INVENTION:	Efficient Generation of Executable File From<br>
Program Files When Some of the Program Files Expressly Incorporate Other Program Files<br>
2. APPLICANT: (a)		Oracle International Corporation<br>
(b)	Oracle Parkway M/S5OP7, Redwood  Shores California, USA 94065<br>
(c)	A California Corporation<br>
The following specification particularly describes the nature of this invention (and the manner in which it is to be performed)<br>
Patent Specification	 Page 1 of 15	 	ORCL-033/India<br>
<br>
 <br>
Background of the Invention<br>
Field of the Invention<br>
The present invention relates to software, and more specifically to a method and apparatus to generate an executable file from program files when some of the program files expressly incorporate other program files.<br>
Related Art<br>
A program file is typically represented as text containing a list of instructions in a programming language. Large program files may be split into a number of smaller program files for separating functionality, providing modularity and/or for ease of usage, as is well understood in the relevant arts.<br>
In general, instructions are provided by the programming language using which program files can be expressly incorporated into one another - thereby effectively designed for operation as one large program file. For convenience, the file incorporating another file is referred to as an “incorporating file” and the file being incorporated is referred to as an “incorporated file”.<br>
An example of such a programming language is C programming language where large program files can be split into header and source files. The C programming language provides a construct “#include <filename>“ by which one header or source file can expressly incorporate another header or source file. Typically, source files ending with extension” .c” incorporate header files ending with extension “.h”.<br>
Program files need to be converted into an executable file before they can be executed by the underlying hardware. The executable file generally contains instructions (typically in binary form) suitable for execution by the processors contained in the hardware.<br>
The process of generating an executable file from program files typically consists of converting (or compiling) each program file into a compiled file using a compiler of the programming language and then building the executable file from the compiled files. Building generally entails linking the compiled filed into an executable file noted above.<br>
Typically, an executable file is generated from a large number of program files. As such, a change made in one of the program files may necessitate the recompilation of all the program files, which is not desirable. Various approaches have been proposed for increasing the efficiency of generating an executable file from program files.<br>
In one prior approach, a program file is recompiled only when the modification date of a program file (as maintained by the underlying opera <br>
Patent Specification	Page 2 of 15ting 			ORCL-033/India<br>
 <br>
system) is more recent than the modification date of its corresponding compiled file. Such an approach is used in utilities such as ‘make’ and ‘gmake’ well known in Unix type environments and ‘nmake’ well known in Windows type environments.<br>
One disadvantage with such an approach is that consideration of modification date alone may not lead to efficient generation of accurate executable file since incorporating files need to be recompiled if the incorporated files are modified. Various aspects of the present invention overcome such deficiencies as described in sections below.<br>
What is therefore needed is an approach, which enables the efficient generation of an executable file from program files while addressing one or more problems/ requirements described above.<br>
Brief Description of the Drawings<br>
The present invention will be described with reference to the accompanying drawings briefly described below.<br>
Figure 1 is a block diagram illustrating the details of a digital processing system in which various aspects of the present invention are operative by execution of appropriate software instructions.<br>
Figure 2 is a flowchart illustrating the manner in which an executable file can be generated from program files wherein some of the program files expressly incorporate other program files according to an aspect of the present invention.<br>
Figure 3 A depicts the contents of some program files used to generate an executable file in an example scenario according to some aspects of the present invention.<br>
Figure 3B depicts a hierarchy representation of the dependency information generated by parsing the program files of Figure 3 A.<br>
Figure 3C depicts the contents of a file stored in secondary storage containing the dependency information generated from the program files of Figure 3 A.<br>
Figure 4A depicts the contents of some program files used to generate an executable file, which conditionally incorporate other files in an example scenario.<br>
Figure 4B depicts a hierarchy based on the dependency information generated from the program files of Figure 4A.<br>
Figure 4C depicts the contents of a file stored in secondary storage containing the conditional dependency information generated from the program files of Figure 4A according to an example convention/format<br>
Figure 5 is a block diagram illustrating an example implementation in which several aspects of the present invention are implemented.<br>
Patent Specification 		Page 3 of 15 		ORCL-033/India<br>
 <br>
In the drawings, like reference numbers generally indicate identical, functionally similar, and/or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit(s) in the corresponding reference number.<br>
Detailed Description of The Preferred Embodiments<br>
1.	Overview<br>
An aspect of the present invention generates an executable file accurately from program files by using dependency information between incorporated files and incorporating files. The dependency information is generated by parsing the program files and is stored in secondary storage. On receiving an indication that a program file has been modified, the dependency information is retrieved from secondary storage and is used to identify for recompilation all the incorporating files that incorporate (directly or indirectly) the modified program file. By recompiling all the incorporating files along with the modified program file, the executable file can be generated accurately.<br>
Another aspect of the present invention generates an executable file accurately when the program files are conditionally incorporated. Data representing each condition is stored associated with each file in which the condition is present. In an embodiment, the result of evaluation of a condition depends on whether a flag (part of the condition) is defined or not, and data representing the specific flags which are defined is also received. On receiving an indication that a program file has been modified, the conditions associated with the program files are evaluated (based on the flag information in the noted embodiment), and used to identify the incorporating files which have to be recompiled for accurately generating the executable file.<br>
Several aspects of the invention are described below with reference to examples for illustration. It should be understood that numerous specific details, relationships, and methods are set forth to provide a full understanding of the invention. One skilled in the relevant art, however, will readily recognize that the invention can be practiced without one or more of the specific details, or with other methods, etc. In other instances, well-known structures or operations are not shown in detail to avoid obscuring the features of the invention.<br>
2.	Digital Processing System<br>
Figure 1 is a block diagram illustrating the details of digital processing system 100 in which various aspects of the present invention are operative by execution of appropriate software instructions. Digital processing system 100 may contain one or more processors such as central processing unit (CPU) 110, random access memory (RAM) 120, secondary memory 130, graphics controller 160, display unit 170, network interface 180, and input interface 190. All the components except display unit 170 may communicate with each other over communication path 150, which<br>
Patent Specification	Page 4 of 15	ORCL-033/India<br>
 <br>
may contain several buses as is well known in the relevant arts. The components of Figure 1 are described below in further detail.<br>
CPU 110 may execute instructions stored in RAM 120 to provide several features of the present invention described in the present application. CPU 110 may contain multiple processing units, with each processing unit potentially being designed for a specific task. Alternatively, CPU 110 may contain only a single general purpose-processing unit RAM 120 may receive instructions from secondary memory 130 using communication path 150.<br>
Graphics controller 160 generates display signals (e.g., in RGB format) to display unit 170 based on data/instructions received from CPU 110. Display unit 170 contains a display screen to display the images defined by the display signals. Display unit 170 may be used to display the dependency information (described below) stored in secondary memory 130. Input interface 190 may correspond to a key-board and/or mouse. Network interface 180 provides connectivity to a network and may be used to communicate with other external systems.<br>
Secondary memory 130 may contain hard drive 135; flash memory 136 and removable storage drive 137. Some or all of the data and instructions may be provided on removable storage unit 140, and the data and instructions may be read and provided by removable storage drive 137 to CPU 110. Secondary memory 130 may be used to store the dependency information generated from the program files (also potentially stored in secondary memory 130). Floppy drive, magnetic tape drive, CD-ROM drive, DVD Drive, Flash memory, removable memory chip (PCMCIA Card, EPROM) are examples of such removable storage drive 137.<br>
Removable storage unit 140 may be implemented using medium and storage format compatible with removable storage drive 137 such that removable storage drive 137 can read the data and instructions. Thus, removable storage unit 140 includes a computer readable storage medium having stored therein computer software and/or data.<br>
In this document, the term “computer program product” is used to generally refer to removable storage unit 140 or hard disk installed in hard drive 135. These computer program products are means for providing software to digital processing system 100. CPU 110 may retrieve the software instructions, and execute the instructions to provide various features of the present invention described below.<br>
3. Generating an Executable File<br>
Figure 2 is a flowchart illustrating the manner in which an executable file can be generated from program files wherein some of the program files expressly incorporate other program files according to an aspect of the present invention. The<br>
Patent Specification	Page 5 of 15	ORCL-033/India<br>
 <br>
flowchart is described with respect to the system of Figure 1 merely for illustration. However, the features can be implemented in various other environments without departing from the scope and spirit of the present invention. The flowchart begins in step 201, in which control passes to step 210.<br>
In step 210, CPU 110 parses each of the program files read from secondary memory 130 and determines dependency information representing which program files incorporate other program files. In an embodiment, CPU 110 parses each of the program files written in the C programming language to identify all the “#include <filename>“ instructions and determines that the parsed program file incorporates all the “filename” program files.<br>
In step 220, CPU 110 stores the dependency information in secondary memory 130. The dependency information can be stored in any form. An example form/format is described in sections below.<br>
In step 240, CPU 110 receives an indication that a program file has been modified. In an embodiment, this indication may be in the form of a list of file names and may be received from a source control program (which keeps track of the modifications related information).<br>
In step 260, CPU 110 identifies program files, which directly (incorporating files) or indirectly (i.e., files incorporating an identified incorporating file) incorporate the modified program file based on the dependency information retrieved from secondary memory 130.<br>
In step 270, CPU 110 marks each of the identified program files as candidates for recompilation. In an embodiment, the marking may be done by changing the modified date (in the underlying operating system) of the identified program files, which would automatically cause the recompilation of the identified program files.<br>
In step 280, CPU 110 recompiles all the marked program files to generate the corresponding compiled files. In a Unix environment where C-programming language is used, object files with extension “.o” are generated from the header and source files.<br>
In step 290, CPU 110 generates the executable file from the compiled files of all the program files. Due to the recompilation of the incorporating files when the corresponding incorporated file is modified, an accurate executable file can be generated. The flowchart ends in step 299.<br>
It may be appreciated that the storage of dependency information in secondary storage facilitates the reuse of the dependency information, other than the efficient<br>
Patent Specification	Page 6 of 15		ORCL-033/India<br>
 <br>
<br>
generation of an executable file. In an example, the dependency information may be used to analyze the impact of changing a program file by identifying all the program files that are affected due to the change. The files that need to be recompiled (and/or a count thereof) may be displayed to a user in response to receiving an identifier (e.g., file name) of a program file of interest. As such, a user may interactively provide several identifiers to check the relative impact of changing each program file, and decide to change program files which would cause least impact if there is a choice of modifying one of several program files to achieve a given objective.<br>
In another example, statistics concerning the program files like the number of dependent/independent files, cross-incorporated files, and cyclic incorporation among the program files may be generated using the dependency information. The features of Figure 2 are illustrated with an example below.<br>
4. Example<br>
Figure 3 A depicts the contents of some program files used to generate an executable file in an example scenario according to some aspects of the present invention. The figure contains program files a.h 310, b.h 320, c.h 330, d.c 340 and e.c 350 containing instructions written in C programming language.<br>
File b.h 320 contains the instruction “#include <a.h>“ implying that the contents of file a.h 310 must be expressly incorporated into file b.h 320 thereby specifying a dependency of file b.h 320 (incorporating file) on file a.h 310 (incorporated file). Any modification made to file a.h 310 necessitates the recompilation of “x” files incorporating file b.h 320, since b.h 320 is a header file. Similarly, file c.h 330 depends on file a.h 310 and file e.c 350 depends on file c.h 330. File d.c 340 contains two “#include” instructions by which the contents of files b.h 320 and c.h 330 are expressly incorporated thereby specifying a dependency of file d.c 340 on both files b.h 320 and c.h 330.<br>
Figure 3B depicts a hierarchy representation of the dependency information generated by parsing the program files of Figure 3 A. As will be clearer from the description below, such a view may be generated from the data representation of Figure 3C while performing step 240 in one embodiment. The figure contains nodes a.h 360, b.h 365, c.h 370, d.c 375 and e.c 380. The hierarchy is generated from the dependency information by depicting each program file as a node in the hierarchy, and all the “filename” program files (incorporated files) as parents to the node, making the incorporating file as a child node to all the incorporated files.<br>
In relation to Figure 3A, the same file name (with .h or x extension) is repeated in Figure 3B, but a different number is conveniently chosen. Thus, file b.h 320 is represented as node b.h 365 in the hierarchy. The file a.h 310 that is expressly incorporated by file b.h 320 is represented as node a.h 360, a parent of node b.h 365.<br>
Patent Specification	Page 7 of 15	ORCL-033/India<br>
 <br>
The parent relationship is represented as an arrow directed from node b.h 365 to node a.h 360. Similarly, node c.h 370 representing file c.h 330 is made a child of node a.h 360 and node e.c 380 is made a child of node c.h 370.<br>
Figure 3C depicts the contents of a file stored in secondary storage containing the dependency information generated from the program files of Figure 3A. The dependency information can be stored in secondary storage using different formats. An example format is illustrated with reference to Figure 3C. As will be appreciated from the description, the hierarchy of Figure 3B is represented in a depth first manner.<br>
Each node of the hierarchy of Figure 3B is represented using a unique identification number, following which the file name, the file path, the number of children and the details of each child is stored as fields using a delimiter between the fields. Thus, line 391 represents node b.h 365 and is stored with its unique identification number (2), the file name (“b.h”), the file path (“c:\”) in the underlying operating system, and the number of children (1) using the delimiter (“~”)- As the number of children is 1, the details of the 1 child node are stored (Line 392).<br>
Once the details of a node have been stored, the node is referred using its unique identification number. For example, in Line 394, unique identification number 3 is used to refer to the node whose details are stored in Line 392. In general, the formats need to enable the dependency information to be reconstructed as a hierarchy (of Figure 3B).<br>
It may be appreciated that the dependency information stored in secondary storage can be retrieved and used when an indication (that a program file has been modified) is received. It may be further appreciated that the dependency information needs to be updated for only the modified program files thereby reducing the computational requirements associated with maintaining the dependency information.<br>
To implement steps 240 and 260, CPU 110 on receiving an indication about the modified program files, may retrieve the dependency information from secondary storage and generate the hierarchy (of Figure 3B) from the dependency information. CPU 110 identifies all the child nodes of the node corresponding to each modified program file by examining the data of Figure 3C stored in the secondary storage. The program files corresponding to the identified child nodes (incorporating files) are identified for recompilation.<br>
For example, when CPU 110 receives an indication that file c.h 330 (incorporated file) has been modified, CPU 110 generates the hierarchy and identifies node c.h 370 as the node corresponding to the modified file c.h 330. CPU 110 then identifies the child nodes d.c 375 and e.c 380 of node c.h 370, and then- <br>
Patent Specification 		Page 8 of 15 	ORCL-033/India<br>
 <br>
corresponding program files d.c 340 and e.c 350 (incorporating files) for recompilation. Both the modified files (file c.h 330) and the corresponding identified files (file d.c 340 and file e.c 350) are recompiled and the executable file is generated.<br>
The above example describes the generation of executable file when some program files incorporate other program files unconditionally. On the other hand several programming languages support conditional incorporation of program files and the approaches described above may need to be extended to support such constructions.<br>
For example, in C programming language, a user may define various flags (e.g., “#define FLAG”) and then include conditional instructions (“:#ifdef FLAG... #endif’) for controlling the incorporation of files only upon the flag being defined. Assuming a include (!t#include <filename>“) instruction is contained in the body of an ifdef construct (“:#ifdef FLAG... #endif’, ), the “filename” program file is incorporated only the “FLAG” is defined in the environment. The features of the present invention in such a context are illustrated with an example below.<br>
5. Example of Conditional Incorporation<br>
Figure 4A depicts the contents of some program files used to generate an executable file, which conditionally incorporate other files in an example scenario according to another aspect of the present invention. The figure contains program files a.h 410, b.h 420, c.h 430, d.c 440 and e.c 450 containing instructions written in C programming language.<br>
The file b.h 420 contains the instruction “#ifdefX #include <a.h> #define Y #endif’ implying that the contents of file a.h 410 must be incorporated into file b.h 420 only when the flag “X” has been defined thereby specifying a conditional dependency of b.h 420 (incorporating file) on file a.h 410 (incorporated file) (or that b.h 420 conditionally incorporates a.h 410). Similarly, the other dependencies (for files c.h 430, d.c 440 and e.c 450) are also generated.<br>
Step 210 needs to be extended to handle such conditional incorporation. Each of the program files is parsed to determine not only all the “#include <filename>“ instructions but also the “#define FLAG” instructions and the “#ifdef FLAG ... #endif instructions that enclose the “#include” instructions.<br>
Figure 4B depicts a hierarchy based on the dependency information generated from the program files of Figure 4A due to the execution of such extended step 210. The figure contains nodes a.h 460, b.h 465, c.h 470, d.c 475 and e.c 480. The hierarchy is generated from the dependency information as described above in detail. Each node in the hierarchy is also associated with the text (obtained from the extended step 210) of all the u#define” and “#ifdef instructions contained in the<br>
Patent Specification	Page 9 of 15	ORCL-033/India<br>
<br>
 <br>
corresponding file of the node (to the extent applicable). Thus, nodes a.h 460 and b.h 465 are shown with the corresponding text.<br>
Figure 4C depicts the contents of a file stored in secondary storage containing the conditional dependency information generated from the program files of Figure 4A according to an example convention/format. Each node of the hierarchy of Figure 4B is represented as described in detail above with respect to Figure 3C. The detail of the text (conditional information) associated with each node is also stored after the file path in secondary storage. For example, lines 491-492 and 493-495 respectively represent the details of nodes b.h 465 and c.h 470 in secondary storage.<br>
The description is continued with respect to the manner in which the information of Figures 4B abd 4C is used for identifying the program files for recompilation in step 260 noted above.<br>
6. Identifying Program Files in case of Conditional Incorporation<br>
Step 240 needs to be extended to handle conditional incorporation. CPU 110 besides receiving an indication that program file has been modified, also receives a list of flags that have been defined. In an embodiment, the list of flags may be received by parsing a make file (containing flag definitions as options) used to generate the executable file from the program files or the list of flags may be specified in a configuration file. For example, when CPU 110 receives an indication that file c.h 430 (incorporated file) has been modified, CPU 110 may generate the hierarchy and identifies node c.h 470 as the node corresponding to the modified file c.h 430. CPU 110 also receives a list of flags, which are maintained in RAM 120.<br>
Step 260 needs to be extended to handle conditional incorporation. CPU 110 identifies all the child nodes of the node corresponding to the modified file. The text associated with the nodes corresponding to modified program files and the identified child (any number of levels down) nodes, is retrieved and parsed to identify the “#define” and “#ifdef” instructions. When a “#define FLAG” instruction is identified in the associated text, the “FLAG” is added to the list of flag maintained in RAM 120. When the “#ifdef FLAG” instruction is identified, the list of flags is checked for “FLAG” and if “FLAG” is found, the child node is identified for recompilation.<br>
For example, continuing with the above example in which file c.h 430 has been modified, node c.h 470 (corresponding to file c.h 430 in the hierarchy) associated with the text “#define Z” is parsed to identify flag “Z”, which is added to the list of flags maintained in RAM 120. CPU 110 then identifies the child nodes d.c 475 and e.c 480 of node c.h 470, and parses the text associated with each node to verify any conditional dependencies. In this example, node e.c 480 is associated with the text “#ifdef X #include <c.h> #endif” which specifies a conditional dependency between node e.c 480 and node c.h 470 based on the flag “X”.<br>
PatentSpecification	Page10of15	ORCL-033/India<br>
<br>
 <br>
If flag “X” is not defined (in the list maintained in RAM 120), node ex 480 is not included in the list of nodes identified for recompilation. In general, if the evaluation of the condition does not require the incorporation of the conditionally incorporated program file, the corresponding incorporating program file is not identified for recompilation.<br>
As explained in detail above, CPU 110 generates the executable file after recompiling the identified files. The features thus described above can be implemented in various types of embodiments. The description is continued with respect to an example implementation.<br>
7. Example Implementation<br>
Figure 5 is a block diagram illustrating an example implementation in which several aspects of the present invention are implemented. The figure contains file list 510, file finder 520, file reader 530, file parser 540, file association 550, dependency finder 560 and source control 570. It should be appreciated that the activities illustrated are part of an example implementation and may be implemented in software or hardware and they may be performed in sequence or in parallel.<br>
File list 510 contains a list of file identifiers identifying the program files (as depicted in Fig 3 A or Fig 4A) used to generate the executable file. In an embodiment, file list 510 may be in the form of a list of file names and may be received from input interface (e.g., combination of a display device, mouse and key-board) or from secondary storage.<br>
File finder 520 receives file list 510 and uses it to identify the files in the underlying file system and passes the information to file reader 530. In an embodiment, file finder 520 may search for each file name in the underlying file system and retrieve the actual location or path of the file, which is then passed to file reader 530.<br>
File reader 530 receives the information about the files from file finder 520 and reads the content of the files from secondary storage 130. The content of the files is then passed to file parser 540. In an embodiment, a circular queue may be implemented between file reader 530 and file parser 540. File reader 530 adds the content of each file to the queue, while file parser 540 removes each file from the queue for processing.<br>
File parser 540 receives the content of each file from file reader 530 and parses the content to identify instructions specifying the incorporation of other program files (identified by file identifiers in file list 510) in the parsed file. File parser 540 also identifies any instructions that are used to specify conditional<br>
Patent Specification	Page 11 of 15	ORCL-033/India<br>
 <br>
<br>
incorporation of other program files. The identified instructions are passed to file association 550.<br>
File association 550 receives instructions from file parser 540 for each file and generates the dependency information in the form of a hierarchy (as depicted in Fig 3B or Fig 4B in the case of conditional dependency) in memory. After file association 550 has processed all the files (according to file list 510), the dependency information is stored in secondary storage 130 (as depicted in Fig 3C or Fig 4C).<br>
File association 550 receives an indication from source control 570 that some program files have been modified. In an embodiment, the indication may be in the form of a list of file names (each name identifying a program file). On receiving the indication, file association 550 retrieves the dependency information from secondary storage 130, generates a hierarchy and passes the hierarchy and the modified program files to dependency finder 560.<br>
Dependency finder 560 receives the hierarchy representing the dependency information and the modified program files and identifies all the program files that need to be recompiled (in response to change of an incorporated file) by using the dependency information (using the approaches described in sections above). Dependency finder 560 may then send the list of identified program files to source control 570.<br>
Source control 570 may change the modification date of each file identified by dependency finder 560. The change causes automatic recompilation of the identified files (and the modified files) during the generation of the executable file (due to the manner in which make type utilities operate).<br>
Thus, due to the use of the dependency information, only the modified files and the incorporating files are recompiled, and the executable file is generated accurately. Due to the storing of the dependency information in the secondary storage, the information generated once can be maintained and used multiple times extending over large durations (thereby reducing computational requirements).<br>
8. Conclusion<br>
While various embodiments of the present invention have been described above, it should be understood that they have been presented by way of example only, and not limitation. Thus, the breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents. Also, the various aspects, features, components and/or embodiments of the present invention described above may be embodied singly or in any combination in a data storage system such as a database system.<br>
Patent Specification	Page 12 of 15	ORCL-033/India<br>
</c.h></filename></a.h></filename></a.h></filename></filename></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=ZwCBvFdEh/k/YRVtpSZnPA==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=ZwCBvFdEh/k/YRVtpSZnPA==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==</a></p>
		<br>
		<div class="pull-left">
			<a href="278966-a-technology-for-ethanol-from-banana-pseudostem-waste.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="278968-a-method-for-making-primary-standard-gas-mixtures.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>278967</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>548/CHE/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>01/2017</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>06-Jan-2017</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>05-Jan-2017</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>27-Mar-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>ORACLE INTERNATIONAL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>500 ORACLE PARKWAY, M/S5OP7 REDWOOD SHORES, CALIFORNIA, USA 94065.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>MRINAL SHARMA</td>
											<td>E-10, UNIVERSITY CAMPUS, KURUKSHETRA UNIVERSITY, KURUKSHETRA, HARYANA-136119.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>SHELENDRA SINGH</td>
											<td>SINGH HOUSE, ICE FAQCTORY ROAD, SURENDRA NAGAR, ALIGARH - 202001</td>
										</tr>
										<tr>
											<td>3</td>
											<td>VIVEK SAM SUNDER RAJ</td>
											<td>14, ZION, ASARIVILLAI, KURUNTHEN CODE P.O, KK DIST, TAMIL, NADU 629805.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 17/30, G06F 17/60</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td></td>
									<td></td>
								    <td>NA</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/278967-efficient-generation-of-executable-file-from-program-files-when-some-of-the-program-files-expressly-incorp0orate-other-program-files by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:57:52 GMT -->
</html>
