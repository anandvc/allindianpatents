<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/226828-system-and-method-for-server-load-balancing-and-server-affinity by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:20:16 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 226828:SYSTEM AND METHOD FOR SERVER LOAD BALANCING AND SERVER AFFINITY</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">SYSTEM AND METHOD FOR SERVER LOAD BALANCING AND SERVER AFFINITY</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A system and method for server load balancing that includes server affinity. The system can be incorporated into application servers to support load balancing algorithms for RMI objects that provide server affinity. Server affinity uses smart load balancing for external client connections in such a way that it uses preexisting connection and reduces overhead: the client considers its exstmg connections to the application server instances when choosing the server instance on which to access a service. If a service is configured for server affinity, the client-side stub attempts to choose a server instance to which it is already connected, and continues to use the same server instance for method calls. All stubs on that client will attempt to use that server instance. If the server instance becomes unavailable, the stubs fail over, if possible, to a server instance to which the client is already connected.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
SYSTEM AND METHOD FOR SERVER LOAD BALANCING<br>
AND SERVER AFFINITY<br>
COPYRIGHT NOTICE<br>
A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.<br>
Claim of Priority:<br>
[0001]	This application claims priority to U.S. Provisional Patent<br>
Application 60/449,775, filed February 24, 2003 (Atty. Docket No. BEAS-01345US0), and incorporated herein by reference.<br>
Field of the Invention:<br>
[0002]	The invention relates generally to application servers and<br>
server clustering, and particularly to a system and method for server load balancing that supports server affinity.<br>
Background:<br>
[0003]	In the field of application servers and distributed systems,<br>
clusters of servers are often used to provide highly available and scalable resources. One example of an application server is the WebLogic Server from BEA Systems, Inc. A cluster (such as a WebLogic Server cluster) comprises multiple server instances running simultaneously and working together to provide increased scalability and reliability. A cluster appears to clients to be a single server. The server instances that constitute a cluster can run on the same machine, or be located on different machines. A cluster's capacity can be increased by adding additional server resnces to<br><br>
the cluster on an existing machine, or by adding machines to the cluster to<br>
host the incremental server instances.  Each server instance in a cluster<br>
must typically run the same version of the server product.<br>
[0004]	In terms of how a cluster relates to the environment in which<br>
the application server exists, a cluster is usually part of a particular server (e.g. WebLogic Server) domain. A domain is an interrelated set of resources that are managed as a unit. A domain includes one or more server instances, which can be clustered, non-clustered, or a combination of clustered and non-clustered instances. A domain can include multiple clusters. A domain also contains the application components deployed in the domain, and the resources and services required by those application components and the server instances in the domain. Examples of the resources and services used by applications and server instances include machine definitions, optional network channels, J2EE components, EJB, connectors, and startup classes. An administrator can use a variety of criteria for organizing server instances into domains. For instance, they might choose to allocate resources to multiple domains based on logical divisions of the hosted application, geographical considerations, or the number or complexity of the resources under management<br>
[0005]	I n a WebLogic domain, one WebLogic Server instance typically<br>
acts as the Administration Server—the server instance which configures, manages, and monitors all other server instances and resources in the domain. Each Administration Server manages one domain only. If a domain contains multiple clusters, each cluster in the domain has the same Administration Server. All server instances in a cluster must reside in the same domain; i.e. you cannot "split" a cluster over multiple domains. Similarly, you cannot share a configured resource or subsystem between domains. For example, if you create a JDBC connection pool in one domain, you cannot use it with a server instance or cluster in another domain. (Instead, you must create a similar connection pool in the second domain.).<br><br>
[0006]	Clustered server instances behave similarly to non-dustered<br>
instances, except that they provide failover and load balancing. The process and tools used to configure clustered server instances are the same as those used to configure non-clustered instances. A server cluster provides the following benefits and features:<br>
Scalability - The capacity of an application deployed on a duster can be increased dynamically to meet demand. Server instances can be added to a duster without interruption of service—the application continues to run without impact to dients and end users.<br>
High-Availability - In a cluster, application processing can continue when a server instance fails. Application components are "dustered" by deploying them on multiple server instances in the cluster—so, if a server instance on which a component is running fails, another server instance on which that component is deployed can continue application processing.<br>
Failover - Failover means that when an application component (typically referred to as a "service" in the following sections) doing a particular "job"— some set of processing tasks—becomes unavailable for any reason, a copy of the failed service finishes the job. For the new service to be able to take over for the failed service there must be a copy of the failed service available to take over the job. There must also be information, available to other services and the program that manages failover, defining the location and operational status of all services— so that it can be determined that the first service failed before finishing its job. There must also be information, available to other services and the program that manages failover, about the progress of jobs in process—so that a service taking over an interrupted job knows how much of the job was completed before the first service failed, for example, what data has been changed, and what steps in the process were completed. Many application servers, induding WebLogic Server, use standards-based communication techniques and facilities—mufcast, IP sockets, and the Java Naming and Directory interface (JNDf)—fcjgjKiand<br><br>
maintain information about the availability of services in a cluster. These techniques allow the server to determine that a service stopped before finishing its job, and where there is a copy of the service to complete the job that was interrupted. Information about what has been done on a job is called state. WebLogic Server maintains information about state using techniques called session replication and replica-aware stubs. When a particular service unexpectedly stops doing its job, replication techniques enable a copy of the service to pic: up where the failed service stopped, and finish the job.<br>
Load Balancing - Load balancing is the even distribution of jobs and associated communications across the computing and networking resources in the application server environment. For load balancing to occur there must be multiple copies of a service that can do a particular job. Information about the location and operational status of all services must also be available. In addition, WebLogic Server allows services to be clustered—deployed on multiple server instances—so that there are alternative services to do the same job. WebLogic Server shares and maintains the availability and location of deployed services using multicast, IP sockets, and JNDI.<br>
[0007]	A clustered application or application component is one that is<br>
available on multiple server instances in a cluster. If a service is clustered, failover and load balancing for that service is available. Web applications can consist of different types of services, including Enterprise Java Beans (EJBs), servlets, and Java Server Pages (JSPs). Each service type has a unique set of behaviors related to control, invocation, and how it functions within an application. For this reason, the methods that WebLogic Server uses to support clustering—and hence to provide load balancing and failover—can vary for different types of services. The following types of services can be clustered in a WebLogic Server deployment: Servlets; JSPs; EJBs; Remote Method Invocation (RMI) objects; Java Messaging Service<br><br>
(JMS) destinations; and, Java Database Connectivity (JDBC) connections.<br>
[0008]	Different service types can have certain behaviors in common.<br>
When this is the case, the clustering support and implementation considerations for those similar service types may be same. In the sections that follow, explanations and instructions for the following types of services are generally combined: Servlets and JSPs; and EJBs and RMI objects. The sections that follow briefly describe the dustering, failover, and load balancing support that WebLogic Server provides for drfferent types of services.<br>
Servlets and JSPs<br>
[0009]	WebLogic Server provides clustering support for servlets and<br>
JSPs by replicating the HTTP session state of clients that access clustered servlets and JSPs. WebLogic Server can maintain HTTP session states in memory, a filesystem, or a database.<br>
EJBs and RMI Objects<br>
[0010]	Load balancing and failover for EJBs and RMI objects is<br>
handled using replica-aware stubs, which can locate instances of the service throughout the cluster. Replica-aware stubs are created for EJBs and RMI objects as a result of the service compilation process. EJBs and RMI objects are deployed homogeneously—to all the server instances in the cluster. Failover for EJBs and RMI objects is accomplished using the service's replica-aware stub. When a client makes a call through a replica-aware stub to a service that fails, the stub detects the failure and retries the call on another replica.<br>
JDBC Connections<br>
[0011]	WebLogic Server allows you to duster JDBC servksknuding<br>
data sources, connection pools and multipoois, to improve tie aaeoft cr<br><br>
cluster-hosted applications. Each JDBC service you configure for your cluster must exist on each managed server in the cluster.<br>
JMS<br>
[0012]	The WebLogic Java Messaging Service (JMS) architecture<br>
implements clustering of multiple JMS servers by supporting cluster-wide, transparent access to destinations from any WebLogic Server server instance in the cluster. Although WebLogic Server supports distributing JMS destinations and connection factories throughout a cluster, the same JMS topic or queue is still managed separately by each WebLogic Server instance in the cluster.<br>
[0013]	However, even given the successes of clustering in the<br>
application server environment, a typical problem with today's clustered systems is that they do not suitably address the number of external client connections they handle. Method calls are typically load balanced among the available server instances according to the configured load balancing algorithm. As a result a large number of sockets must be opened and maintained between the external clients and server instances in the cluster. A new approach that disables traditional load balancing for external client connections, but still allows it for less costly server-to-server connections would be of great use in enhancing cluster stability and scalability.<br>
Summary of the Invention:<br>
[0014]	Server affinity can be used to minimize the number sockets<br>
opened between external Java clients and server instances in a clustered environment. The invention accomplishes this by causing method calls on services to "stick" to an existing connection, instead of being load balanced among the available server instances. Embodiments of the present invention introduce three new load balancing algorithms for services and RMI objects that provide server affinity. Server affinity turns offload balancing for external<br><br>
client connections: instead, the client considers its existing connections to server instances when choosing the server instance on which to access a service. If a service is configured for server affinity, the client-side stub attempts to choose a server instance to which it is already connected, and continues to use the same server instance for method calls. All stubs on that client attempt to use that server instance. If the server instance becomes unavailable, the stubs fail over, if possible, to a server instance to which the client is already connected.<br>
Brief Description of the Figures:<br>
[0015]	Figure 1 shows a context from the cluster, in which the client<br>
obtains context from the cluster, in accordance with an embodiment of the<br>
invention.<br>
[0016]	Figure 2 shows server affinity and failover, illustrating the effect<br>
that server affinity has on service failover, in accordance with an embodiment<br>
of the invention.<br>
[0017]	Figure   3   shows   server   affinity   and   server-to-server<br>
connections, in accordance with an embodiment of the invention.<br>
[0018]	Figure 4 shows a replica that is collocated with the stub itself,<br>
rather than using a replica that resides on a remote server, in accordance<br>
with an embodiment of the invention.<br>
[0019]	Figure 5 shows attempts to use service replicas that are<br>
collocated with the transaction, in accordance with an embodiment of the<br>
invention.<br>
Detailed Description;<br>
[0020]	The purpose of server affinity is to minimize the number<br>
sockets opened between external clients and server instances m a dister. An embodiment of the invention accomplishes this by causang service<br><br>
requests to "stick" to an existing connection, instead of being load balanced among the available server instances.<br>
Load Balancing for EJBs and RMI Objects<br>
[0021]	An embodiment of the invention introduces three new load<br>
balancing algorithms for services and RMI objects that provide server affinity-<br>
Server affinity turns off load balancing for external client connections:<br>
instead, the client considers its existing connections to server instances when<br>
choosing the server instance on which to access an service. If a service is<br>
configured for server affinity, the client-side stub attempts to choose a server<br>
instance to which it is already connected, and continues to use the same<br>
server instance for method calls. All stubs on that client attempt to use that<br>
server instance. If the server instance becomes unavailable, the stubs fail<br>
over, if possible, to a server instance to which the client is already connected.<br>
[0022]	Server affinity is used in combination with one of the standard<br>
load balancing methods: round-robin, weight-based, or random, providing a total of six alternatives for load balancing services:<br>
Round-robin—round robin load balancing is used for both internal and external connections.<br>
Weight-based—weight-based load balancing is used for both internal and external connections.<br>
Random—random load balancing is used for both internal and external connections.<br>
Round-robin-affinity—server affinity governs connections between external Java clients and server instances.<br>
Weight-based-affinity—server affinity governs connections between external Java clients and server instances.<br>
Random-affinity—server affinity governs connections between external Java clients and server instances.<br><br>
[0023]	By default, in one embodiment a WebLogic Server duster uses<br>
round-robin load balancing for services. An administrator can confiire a different default load balancing method for the cluster as a whole by using an Administration Console to set a weblogic.cluster.defaultLoadAlgorithm variable equal to the desired method. An administrator can also specify the load balancing algorithm for a specific RMI object using the -LoadAJgorithm option in the RMIC compiler (rmic), in a deployment descriptor. A load balancing algorithm that you configure for a service overrides the default load balancing algorithm for the cluster. The load balancing algorithm for a service is maintained in the replica-aware stub obtained for a clustered service.<br>
Server Affinity and Initial Context<br>
[0024]	A client can request an initial context from a particular server<br>
instance in the cluster, or from the cluster by specifying the cluster address in the URL. The connection process varies, depending on how the context is obtained:<br>
If the initial context is requested from a specific Managed Server, the context is obtained using a new connection to the specified server instance.<br>
If the initial context is requested from a the cluster, by defauft, context requests are typically load balanced on a round-robin basis among the clustered server instances.<br>
[0025]	To reuse an existing connection between a particular JVM and<br>
the cluster, set ENABLE_SERVER_AFFINITY to true in the hashtable of weblogic.jndi.WLContext properties you specify when obtaining context (If a connection is not available, a new connection IS created.) ENABLE_SERVER_AFFINITY is only supported when the context is requested from the duster address.<br><br>
Round Robin Load Balancing<br>
[0026]	An embodiment of the invention (as provided in WebLogic<br>
Server) uses the round-robin algorithm as the default load balancing strategy for clustered service stubs when no algorithm is specified. This algorithm is supported for RMI objects and EJBs. It is also the method used by WebLogic proxy plug-ins. The round-robin algorithm cycles through a list of server instances in order. For clustered services, the server list consists of server instances that host the clustered service. For proxy plug-ins, the list consists of all server instances that host the clustered servlet or JSP. The advantages of the round-robin algorithm are that it is simple, cheap and very predictable.<br>
Weight-Based Load Balancing<br>
[0027]	This algorithm applies only to EJB and RMI object clustering.<br>
Weight-based load balancing improves on the round-robin algorithm by taking into account a pre-assigned weight for each server. Other application servers and implementations could use a different type of weight-based algorithm than that described herein. You can use the Server -&gt; Configuration -&gt; Cluster tab in the Administration Console to assign each server in the cluster a numerical weight between 1 and 100, in the Cluster Weight field. This value determines what proportion of the load the serverwill bear relative to other servers. If all the servers have the same weight, they will each bear an equal proportion of the load. If one server has weight 50 and all other servers have weight 100, the 50-weight server will bear half as much as any other server. This algorithm makes it possible to apply the advantages of the round-robin algorithm to clusters that are not homogeneous. If you use the weight-based algorithm, carefully determine the relative weights to assign to each server instance. Factors to consider include the processing capacity of the server's hardware in relationship to other servers (for example, the number and performance of CPUs dedicated<br><br>
to the server); and the number of non-clustered ("pinned") services each server hosts. If you change the specified weight of a server and reboot ft, the new weighting information is propagated throughout the cluster.<br>
Random Load Balancing<br>
[0028]	The random method of load balancing applies only to EJB and<br>
RMI object clustering. In random load balancing, requests are routed to servers at random. Random load balancing is recommended only for homogeneous cluster deployments, where each server instance runs on a similarly configured machine. A random allocation of requests does not allow for differences in processing power among the machines upon which server instances run. If a machine hosting servers in a cluster has significantly less processing power than other machines in the cluster, random load balancing will give the less powerful machine as many requests as it gives more powerful machines. Random load balancing distributes requests evenly across server instances in the cluster, increasingly so as the cumulative number of requests increases. Over a small number of requests the load may not be balanced exactly evenly.<br>
Round-Robin Affinity, Weight-Based Affinity, and Random-Affinity<br>
[0029]	The invention introduces three new load balancing algorithms<br>
that provide server affinity: round-robin-affinity; weight-based-affinity; and random-affinity. Server affinity is supported for all types of RMI objects including JMS services, all EJB home interfaces, and stateless EJB remote interfaces. The server affinity algorithms consider existing connections between an external Java client and server instances in balancing the cBent load among server instances. Server affinity uses smart toad balancing between external Java clients and server instances m such a way that it uses preexisting connection and reduces overhead. Serveraffinfty causes raefliod calls from an external Java client to stick to a server instance <br><br>
client has an open connection, assuming that the connection supports the necessary protocol and QOS. In the case of failure, server affinity causes the client to failover to a server instance to which it has an open connection, assuming that the connection supports the necessary protocol and QOS. Server affinity does not affect the load balancing performed for server-to-server connections.<br>
Server Affinity Examples<br>
[0030]	The following examples illustrate the effect of server affinity<br>
under a variety of circumstances. In each example, the services deployed are<br>
configured for round-robin-affinity.<br>
[0031]	Figure 1 shows the context from cluster. In this example, the<br>
client obtains context from the cluster. Lookups on the context and service<br>
calls stick to a single connection. Requests for new initial context are load<br>
balanced on a round-robin basis:<br>
1.	Client requests a new initial context from the cluster<br>
(Provider_URL=clusteraddress) and obtains the context from MS1.<br>
2.	Client does a lookup on the context for Service A. The lookup goes to MS1.<br>
3.	Client issues a call to Service A. The call goes to MS1, to which the client is already connected. Additional method calls to Service A stick to MS1.<br>
4.	If in a different virtual machine, client requests a new initial context from the cluster (ProviderJJRL=clusteraddress) and obtains the context from MS2.<br>
5.	Client does a lookup on the context for Service B. The call goes to MS2, to which<br>
the client is already connected. Additional method calls to Service B stick to MS2.<br>
[0032]	Figure 2 shows server affinity and failover.   This example<br><br>
illustrates the effect that server affinity has on service failover. When a Managed Server goes down, the client fails over to another Managed Server to which it has a connection:<br>
1.	Client requests new initial context from MS1.<br>
2.	Client does a lookup on the context for Service A. The lookup goes to MS1.<br>
3.	Client makes a call to Service A. The call goes to MS1, to which the client is already connected. Additional calls to Service A stick to MS1.<br>
4.	The client obtains a stub for Service C, which is pinned to MS3. The client opens a connection to MS3.<br>
5.	MS1 fails.<br>
6.	Client makes a call to Service A. The client no longer has a connection to MS1. Because the client is connected to MS3, it fails over to a replica of Service A on MS3.<br>
[0033]	Figure   3   shows   server   affinity   and   server-to-server<br>
connections. This example illustrates that server affinity does not affect the connections between server instances:<br>
1.	A JSP on MS4 obtains a stub for Service B. MS4 in this instance is acting as a client to MSI, MS2 and MS3.<br>
2.	The JSP selects a replica on MS1. For each method call, the JSP cycles through<br>
the Managed Servers upon which Service B is available, on a round-robin basis. The request always goes to MS1 unless MS1 fails or is unavailable for some reason.<br>
Parameter-Based Routing for Clustered Services<br>
[0034]	Parameter-based routing allows you to control load balancing<br>
behavior at a lower level. Any clustered service can be assigned a CallRouter. This is a class that is called before each invocafcr mgt the<br><br>
parameters of the call. The CallRouter is free to examine the parameters and return the name server to which the call should be routed.<br>
Optimization for Collocated Services<br>
[0035]	WebLogic Server does not always load balance an service's<br>
method calls. In most cases, it is more efficient to use a replica that is collocated with the stub itself, rather than using a replica that resides on a remote server. The following figure illustrates this.<br>
[0036]	Figure 4 shows how collocation optimization overrides load<br>
balancing logic for method call. In this example, a client connects to a servlet hosted by the first WebLogic Server instance in the cluster. In response to client activity, the servlet obtains a replica-aware stub for Service A. Because a replica of Service A is also available on the same server instance, the service is said to be collocated with the client's stub. WebLogic Server always uses the local, collocated copy of Service A, rather than distributing the client's calls to other replicas of Service A in the cluster. It is more efficient to use the local copy, because doing so avoids the network overhead of establishing peer connections to other servers in the cluster. If your Web application is deployed to a single cluster, the collocation optimization overrides any load balancing logic inherent in the replica-aware stub.<br>
Transactional Collocation<br>
[0037]	As an extension to the basic collocation strategy, WebLogic<br>
Server attempts to use collocated clustered services that are enlisted as part of the same transaction. When a client creates a UserTransaction service, WebLogic Server attempts to use service replicas that are collocated with the transaction. This optimization is depicted in Figure 5. In this example, a client attaches to the first WebLogic Server instance in the cluster and obtains a UserTransaction service. After beginning a new transaction, the<br><br>
client looks up Services A and B to do the work of the transaction. In this<br>
situation WebLogic Server always attempts to use replicas of A and B that<br>
reside on the same server as the UserTransaction service, regardless of the<br>
load balancing strategies in the stubs for A and B. This transactional<br>
collocation strategy is even more important than the basic optimization. If<br>
remote replicas of A and B were used, added network overhead would be<br>
incurred for the duration of the transaction, because the peer connecSonsfbr<br>
A and B would be locked until the transaction committed. Furthermore,<br>
WebLogic Server would need to employ a multi-tiered JDBC connection to<br>
commit the transaction, incurring additional network overhead.<br>
[0038]	By using collocating clustered services during a transaction,<br>
WebLogic Server reduces the network load for accessing the individual services. The server also can make use of a single-tiered JDBC connection, rather than a multi-tiered connection, to do the work of the transaction.<br><br>
Load Balancing for JMS<br>
[0039]	WebLogic Server JMS supports server affinity for distributed<br>
JMS destinations and client connections. By default, a WebLogic Server cluster uses the round-robin method to load balance services. To use a load balancing algorithm that provides server affinity for JMS services, you must configure the desired algorithm. You can configure the load balancing algorithm by using the Administration Console to set weblogic.cluster.defaultLoadAlgorithm.<br>
Server Affinity for Distributed JMS Destinations<br>
[0040]	Server affinity is supported for JMS applications that use the<br>
distributed destination feature; this feature is not supported for pinned destinations. If you configure server affinity for JMS connection factories, a server instance that is load balancing consumers or producers across multiple physical destinations in a distributed destination set will attempt to load balance across any destinations that are running on the same a server instance.<br>
Initial Context Affinity and Server Affinity for Client Connections<br>
[0041]	A system administrator can establish load balancing of JMS<br>
destinations across multiple servers in a cluster by configuring multiple JMS servers and using targets to assign them to the defined WebLogic Servers. Each JMS server is deployed on exactly one WebLogic Server and handles requests for a set of destinations. During the configuration phase, the system administrator enables load balancing by specifying targets for JMS servers. A system administrator can establish cluster-wide, transparent access to destinations from any server in the cluster by configuring multiple connection factories and using targets to assign them to WebLogic Servers. Each connection factory can be deployed on multiple WebLogic Servers. The<br><br>
application uses the Java Naming and Directory Interface (JNDI) to look up<br>
a connection factory and create a connection to establish communication<br>
with a JMS server. Each JMS server handles requests for a set of<br>
destinations. Requests for destinations not handled by a JMS server are<br>
forwarded to the appropriate server. WebLogic Server provides server affinity<br>
for client connections. If an application has a connection to a given server<br>
instance, JMS will attempt to establish new JMS connections to frie same<br>
server instance. When creating a connection, JMS will try first to achieve<br>
initial context affinity. It will attempt to connect to the same server or servers<br>
to which a client connected for its initial context, assuming that the server<br>
instance is configured for that connection factory. For example, if the<br>
connection factory is configured for servers A and B, but the client has an<br>
InitialContext on server C, then the connection factory will not establish the<br>
new connection with A, but will choose between servers B and C. If a<br>
connection factory cannot achieve initial context affinity, it will try to provide<br>
affinity to a server to which the client is already connected. For instance,<br>
assume the client has an InitialContext on server A and some other type of<br>
connection to server B. If the client then uses a connection factory<br>
configured for servers B and C it will not achieve initial context affinity. The<br>
connection factory will instead attempt to achieve server affinity by trying to<br>
create a connection to server B, to which it already has a connection, rather<br>
than server C. If a connection factory cannot provide either initial context<br>
affinity or server affinity, then the connection factory is free to make a<br>
connection wherever possible. For instance, assume a client has an initial<br>
context on server A, no other connections and a connection factory<br>
configured for servers B and C. The connection factory is unable to provide<br>
any affinity and is free to attempt new connections to either server B or C.<br>
[0042]	Note: In the last case, if the client attempts to make a second<br>
connection using the same connection factory, it wffl go to the same server as it did on the first attempt That is, if i chose server E xw ie st<br><br>
connection, when the second connection is made, the client will have a connection to server B and the server affinity rule will be enforced.<br>
Load Balancing for JDBC Connections<br>
[0043]	Load balancing of JDBC connection requires the use of a<br>
multipool configured for load balancing. Load balancing support is an option you can choose when configuring a multipool. A load balancing multipool provides the high available behavior, and in addition, balances the load among the connection pools in the multipool. A multipool has an ordered list of connection pools it contains. If you do not configure the multipool for load balancing, it always attempts to obtain a connection from the first connection pool in the list. In a load-balancing multipool, the connection pools it contains are accessed using a round-robin scheme. In each successive client request for a multipool connection, the list is rotated so the first pool tapped cycles around the list.<br>
[0044]	The present invention may be conveniently implemented using<br>
a conventional general purpose or a specialized digital computer or microprocessor programmed according to the teachings of the present disclosure. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art.<br>
[0045]	In some embodiments, the present invention includes a<br>
computer program product which is a storage medium (media) having instructions stored thereon/in which can be used to program a computer to perform any of the processes of the present invention. The storage medium, can include, but is not limited to, any type of disk including floppy disks, optical discs, DVD, CD-ROMs, microdrive, and magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs),<br><br>
or any type of media or device suitable for storing instructions and/or data.<br>
[0046]	The foregoing description of the present invention has been<br>
provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to the practitioner skiUed in the<br>
t<br>
art. Particularly, it will be evident that while the examples described herein illustrate how the invention may be used in a WebLogic environment, other application servers, servers, and computing environments, may use and benefit from the invention. It will also be evident that the invention may be used with services other than those described, including for example J2EE components, such as EJBs, and JSPs.<br>
[0047]	The embodiments were chosen and described in order to best<br>
explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalence.<br><br><br>
Claims:<br>
What is claimed is:<br>
1.	A system for server load balancing that includes server affinity,<br>
comprising:<br>
a cluster that includes a plurality of server instances;<br>
a load balancing and affinity processor that assigns servers from said cluster to service client requests in the form of service requests from clients; and,<br>
a client-side stub which attempts to choose a server instance to which it is already connected, and continues to use the same server instance for service requests.<br>
2.	The system of claim 1 wherein all stubs on that client attempt to use that server instance.<br>
3.	The system of claim 1 wherein if the server instance becomes unavailable, the stubs fail over, if possible, to a server instance to which the client is already connected.<br>
4.	The system of claim 1 wherein the load balancing method is any of round-robin, weight-based, or random.<br>
5.	The system of claim 4 wherein the load balancing method includes round robin load balancing used for both internal and external connections.<br>
6.	The system of claim 4 wherein the load balancing method includes weight-based load balancing used for both internal and external connections.<br><br>
7.	The system of claim 4 wherein the load balancing method includes random load balancing used for both internal and external connecoons.<br>
8.	The system of claim 4 wherein the load balancing method includes server affinity that governs connections between external Java clients and server instances, and wherein round robin load balancing is used for connections between server instances.<br>
9.	The system of claim 4 wherein the load balancing method includes server affinity that governs connections between external Java clients and server instances, and wherein weight-based load balancing is used for connections between server instances.<br>
10.	The system of claim 4 wherein the load balancing method includes server affinity that governs connections between external Java clients and server instances, and wherein random load balancing is used for connections between server instances.<br>
11.	A method for server load balancing that includes server affinity, comprising the steps of:<br>
providing a plurality of server instances as a cluster assigning servers from said cluster to service client requests in the form of method calls from clients; and,<br>
wherein said step of assigning includes using a client-side stub which attempts to choose a server instance to which it is already connected, and continues to use the same server instance for method catts.<br>
12.	The method of claim 11 wherein all stubs on that cfient attempt to use<br>
that server instance.<br><br>
13.	The method of claim 11 wherein if the server instance becomes<br>
unavailable, the stubs fail over, if possible, to a server instance to which the<br>
client is already connected.<br>
14.	The method of claim 11 wherein the load balancing method is any of<br>
round-robin, weight-based, or random.<br>
15.	The method of claim 14 wherein the load balancing method includes<br>
round robin load balancing used for both internal and external connections.<br>
16.	The method of claim 14 wherein the load balancing method includes<br>
weight-based load balancing used for both internal and external connections.<br>
17.	The method of claim 14 wherein the load balancing method includes<br>
random load balancing used for both internal and external connections.<br>
18.	The method of claim 14 wherein the load balancing method includes<br>
server affinity that governs connections between external Java clients and<br>
server instances, and wherein round robin load balancing is used for<br>
connections between server instances.<br>
19.	The method of claim 14 wherein the load balancing method includes<br>
server affinity that governs connections between external Java clients and<br>
server instances, and wherein weight-based load balancing is used for<br>
connections between server instances.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1IGFic3RyYWN0IGdyYW50ZWQucGRm" target="_blank" style="word-wrap:break-word;">2392-chenp-2005 abstract granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1IGNsYWltcyBncmFudGVkLnBkZg==" target="_blank" style="word-wrap:break-word;">2392-chenp-2005 claims granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1IGRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">2392-chenp-2005 description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1IGRyYXdpbmdzIGdyYW50ZWQucGRm" target="_blank" style="word-wrap:break-word;">2392-chenp-2005 drawings granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">2392-chenp-2005-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">2392-chenp-2005-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">2392-chenp-2005-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1LWNvcnJlc3BvbmRuZWNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">2392-chenp-2005-correspondnece-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1LWRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">2392-chenp-2005-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">2392-chenp-2005-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">2392-chenp-2005-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1LWZvcm0gMTgucGRm" target="_blank" style="word-wrap:break-word;">2392-chenp-2005-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">2392-chenp-2005-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">2392-chenp-2005-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjM5Mi1jaGVucC0yMDA1LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">2392-chenp-2005-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="226827-a-mixing-apparatus-and-a-slurrying-apparatus.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="226829-a-nipper-unit-of-a-comber.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>226828</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2392/CHENP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>07/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>13-Feb-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>24-Dec-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>23-Sep-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>BEA SYSTEMS, INC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2315 NORTH FIRST STREET, SAN JOSE, CA 95131,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>HALPERN, ERIC, M</td>
											<td>160 DELMAR STREET, SAN FRANCISCO, CA 94117,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>PEDDADA, PRASAD</td>
											<td>3700 LYON ROAD, #52, FAIRFIELD, CA 94534,</td>
										</tr>
										<tr>
											<td>3</td>
											<td>REVANARU, NARESH</td>
											<td>2000 WALNUT AVENUE, #H-106, FREMONT, CA 94538,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F9/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US04/05429</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-02-24</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/449,775</td>
									<td>2003-02-24</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/226828-system-and-method-for-server-load-balancing-and-server-affinity by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:20:17 GMT -->
</html>
