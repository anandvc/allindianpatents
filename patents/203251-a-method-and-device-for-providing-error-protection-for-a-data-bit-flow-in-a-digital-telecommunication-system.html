<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/203251-a-method-and-device-for-providing-error-protection-for-a-data-bit-flow-in-a-digital-telecommunication-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:27:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 203251:&quot;A METHOD AND DEVICE FOR PROVIDING ERROR PROTECTION FOR A DATA BIT-FLOW IN A DIGITAL TELECOMMUNICATION SYSTEM&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;A METHOD AND DEVICE FOR PROVIDING ERROR PROTECTION FOR A DATA BIT-FLOW IN A DIGITAL TELECOMMUNICATION SYSTEM&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>This invention relates to a method for providing error protection for a data bit flow in a digital telecommunication system, especially for speech signals that transmit speech in a mobile radio telephone system. The aim of the invention is to reduce the bit error rate of such a data bit flow. To this end, a plurality of known dummy bits are inserted at predetermined bit positions of the primary data bit flow in the proximity of significant information—carrying bits before channel coding is carried out.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>2.<br>
The  invention relates to a method and  device for  providing error  protection  for  a  data  bit  flow  in  a  digital   data communication  system,  in  particular for speech  signals  that transmit speech in a mobile radio system.<br>
Source signals such as voice, sound, image and video almost always include statistical redundancy. As a result of source decoding it is possible to remove this redundancy, with the result that an efficient transition or storage of the source signal is made possible. On the other hand, when transmitting signals it is necessary to reinsert redundancy selectively by means of channel coding in order to eliminate channel interference.<br>
Owing  to the incomplete knowledge of the source signals  or restrictions  in the complexity of the coding method, the  source coding  can  usually only be implemented in a less  than  optimum fashion  i.e.  there is still a certain degree of  redundancy  in compressed data. This residual redundancy can be utilized in what is  referred to as source—controlled or common  channel  decoding for  correcting  further  bit errors; cf. DE  4224214  C2  and J, Hagenauer,  'Source—contro11ed channel  decoding' IEEE Trans. Commun Vol 43, pp. 2449-2457, Sept. 1995. Hcrc, the decoding process<br><br>
3.<br>
 of the  channel decoder is controlled both by the transmitted cade bits and by an Apriori—A Posteriori information item relating  to the  probable value of a number of important source bite. In  the case  of  VA  (Viterbi—Algorithm)  decoding,  this  method   was referred to as Apri-Va. It was already been applied  successfully for the transmission of voice, sound, image and video.<br><br>
-4-<br>
The bits (information bits) generated by source coding generally have highly varying degrees of sensitivity to bit errors which can arise, for example, in digital telecommunications transmission/storage so that unequal error protection (UEP) is necessary for different bits, i.e. important bits must be better protected than less important ones.<br>
An example is the voice codec, for example the enhanced full rate (EFR) and adaptive multirate (AMR) voice codec in the GSM standard, said speech codec being based on the CELP (code excited linear prediction). The GSM-EFR codec generates 244 bits (corresponding to 12.2 kbit/s) every 20 ms (corresponding to one frame). Errors in this bit stream have greatly varying effects on the voice quality after decoding. Errors in a large number of bits, for example bits of LPC (linear predictive coding) coefficients lead to incomprehensibility or loud noises, while errors in other bits (for example bits from fixed code books) are virtually imperceptible. This has given impetus to dividing up the bits, according to the voice coder, into classes (Class la, lb and 2) which are usually differently protected against errors. In order to obtain a reasonable voice quality, it is typically necessary (depending on the type of codec and quality requirement), to protect the most important bits up to a bit error rate BER of approximately 10-4 - 10-5 (after channel decoding) and to protect the least important bits up to a bit error rate BER of 10-1 - 10-2. This method is referred to as the UEP method.<br>
The customary methods for implementing a UEP are:<br><br>
-5-<br>
-	use of special codes which have a UEP mechanism (cf.,<br>
for example, H. Ma, "Binary unequal error-protection<br>
block  codes  formed  from  convolutional  codes  by<br>
generalized  tail-biting,"  IEEE  Trans.  Information<br>
Theory, Vol. 32, pp. 776-786, 1986).<br>
-	separate channel coding of the different classes of<br>
bits (for example in GSM-EFR; the bits of classes la<br>
and lb are coded by a convolutional code at the rate<br>
1/2 and memory m = 4, and the bits of class 2 are<br>
transmitted in uncoded form).<br>
-	combination  of  channel  coding  and  subsequent<br>
puncturing which is adapted to the importance of the<br>
bits {example: GSM-AMR standard).<br>
The third generation of mobile telephone systems 3GPP (third generation partner project) or UMTS (universal mobile telecommunication system) is currently being standardized. For general data transmission, a uniform structure has already been agreed (see; Figure 4-1 and Figure 4-2 of Transport channel multiplexing structure for uplink, in TS 25.212 V2.0.0 (1999-06), 3rd Generation Partnership Project (3GPP); Technical Specification Group (TSG) , Radio Access Network (RAN) ; Working Group 1 (WG1)).<br>
The channel coding is implemented with a convolutional code  (rate 1/2 and 1/3,  constraint length m+l=9,  m being referred to as code memory) or turbo codes. The rate matching serves here  to repeat  the code bits generated by the channel coding in accordance with the quality of the service and/or the possible  (fixed) length of the data block within a transport channel (if the code bits are too few) or to puncture them (if the code bits are too many) . All functional units  (CRC, multiplexing, channel coding,<br><br>
- 6-<br>
interleaving, rate matching, etc) may be applied to the entire data block (i.e. the complete input bit stream) but not parts thereof.<br>
Although such a structure makes the system simple and uniform for different services, it is difficult to implement a UEP, for example for voice services, with the customary methods of channel coding. In order to adapt the importance of the AMR-coded bits, the different classes of bits should be transmitted with different levels of protection. A simple solution is to transmit the different classes of bits via different transport channels.<br>
Disadvantages of such a UEP solution are the complicated management of the decomposition and combination of bits and the overhead necessary for said processes.<br>
We will consider the mode 12.2 kbit/s of the AMR codec as an example. This mode has 3 classes of bits: Class A (81 bits), Class B (103 bits) and Class C (60 bits). If the 3 classes of bits are transmitted via 3 transport channels, each class firstly has, for example, 16 CRC bits (for block error detection) added to it and then 8 tail bits (if, as foreseen, the convolutional code with rate 1/3, constraint length 9 is used) . The entire code bits after channel coding are 3x(81+16+8) + 3x(l03+16+8) + 3x(60+16+8) = 948 bits, of which 3x(16+8) + 3x(16+8) + 3x{16+8) = 216 bits, i.e. 216/948 = 23% of all code bits are associated with the overhead. If, however, all 244 bits are transmitted with a transport channel, the overhead is 3x (16+8) - 72 bits (these bits are necessary for UMTS data transmission), i.e. 72/804 = 9% of all code bits, where 804 = (244+16+8) x 3.<br><br>
-7-<br>
The invention is therefore based on the object of specifying an improved method of the generic type with reduced expenditure on. protection (overhead) and thus a relatively high net information density, together with a corresponding device.<br>
The invention includes the fundamental idea of selective insertion of known bits before the channel coding step. These known bits - also referred to below as dummy bits - are inserted in the vicinity of the important information bits, specifically in a non-terminating fashion (in contrast with the known code termination where a known bit group is located at the end of a data block), and in particular on both sides of the information bits. The more important an information bit is, the nearer its dummy bits should be located to it and/or the more known bits should be inserted near to it.<br>
A code with a relatively low rate is advantageously formed by inserting the previously known bits from a code with a relatively high rate. The application to a systematic code is particularly expedient, and the inserted previously known bits <dummy bits are not included in the transmission code bits.></dummy>
An advantageous linking to puncturing is also expedient by puncturing the code bits after application of the proposed method.<br>
Decoding methods such as the source-controlled channel decoding can be used in conjunction with the proposed method, the maximum<br><br><br>
(absolute) apriori knowledge (the log-likelihood ratio in the case of Apri-VA algorithm) for the known bits being set at the receiver end.<br>
Potential advantages of the proposed method are:<br>
-	simplicity of implementation. With the exception that<br>
a channel decoder which uses apriori knowledge (for<br>
example the Apri-VA algorithm instead of the normal<br>
VA (Viterbialgorithm) is used, all other parts of the<br>
channel codec remain unchanged. As a result, a UEP<br>
can be implemented for a predetermined transmission<br>
structure   (such  as   3  GPP)   without   further<br>
modification.<br>
-	flexibility. It is easy to adapt UEP to individual<br>
information bits.<br>
-	omission of a separate overhead.<br>
For the above example (12.2 kbit/s AMR-codec for UMTS), it is possible to transmit all 244 bits within a transport channel using the method proposed here.<br>
While the execution, specifically in the case of unequal error protection, only requires one classification of the information bits into two classes<br>
-	namely more important  (more significant)  and less<br>
important   (less  significant) ,   in  one  preferred<br>
embodiment a finely graduated classification into at<br>
least three classes takes place associated with the<br>
insertion of several successive dummy bits in each case<br>
near to information bits with a higher significance and<br>
of one dummy bit near to information bits with medium<br>
ranking significance.<br>
In a device which is suitable for carrying out the method according to the invention, the coder comprises means for inserting the previously known data bits (dummy bits) at positions<br><br>
- 9 -<br>
near to the positions of important information bits. Such a device also comprises a classification device for classifying information bits according to their significance or it is at least connected to a source of corresponding classification signals, for example to a memory device of an external classification device.<br>
For decoding the received {convolution-coded} bit stream, it is possible, for example, to use a Viterbi-Algorithm (VA) which is modified as follows, A trellis diagram of a convolutional code is composed of branches (state transitions) and nodes, it being possible for a plurality of branches to come together at each node. A node represents a state of the memory of the convolutional code. For a rate 1/n convolutional code and at a specific point in time there are branches to the next point in time in the trellis diagram 2m+1 if no bit is predefined. If a dummy bit is inserted, only 2m branches are then possible. The normal Viterbi decoder then can be modified in such as way that only these branches are reached. In other words, the paths which do not run over the 2m branches are rejected. This method can be expanded for several dummy bits and other codes.<br>
Here, such a system comprises a sequence controller for controlling the corresponding tests for the data bit streams processed via a plurality of paths in the trellis diagram, by reference to the positions and the values of the dummy bits, as well as a decision unit which is connected to the comparative device and makes a decision to reject or to confirm or select a path as a function of the result of the comparison which is respectively made.<br><br>
- 10-<br>
In a further preferred embodiment, such an overall system comprises a source-controlled channel decoder which implements, in particular, an Apri-Viterbi-Algorithm or MAP-Algorithm. Such a channel decoder comprises a database for what are referred to as "L values" (values of the log-likelihood ratio) of the inserted known bits.<br>
The proposed method has particular practical significance for the error-protected transmission of source signals, in particular voice signals. It is therefore particularly suitable for application in a mobile telephone system.<br>
Advantages and expediencies of the invention emerge,<br>
the<br>
the following<br>
explanation of specific embodiments and aspects with<br>
     reference to the accompanying figures, of which:<br>
Fig. 1 shows	a schematic view of	a data bit stream<br>
before  the	channel  coding  or	upstream  of  the<br>
corresponding	apriori  knowledge	base  for  channel<br>
decoding.<br>
Fig. 2 shows a simulation of the BER as a function of the bit number of a VA decoder of an AWGN channel,<br>
Fig. 3 shows a view of the protection of a convolutional code with predetermined dummy bits and,<br>
Fig. 4 shows a view of the simulation of an RSC code of an AWGN channel.<br>
As illustrated in Fig, 1, the bits u3 and u4 should be better protected than u8 and u9, which are in turn better protected than U1, u6, u7, ...  Two known bits<br><br>
-11-<br>
("0" or "1") can then be inserted between u3 and u4 and a known bit ("0" or "1") can be inserted between U8 and u9. This apriori knowledge should be used at the decoding end, i.e. the two bits between u3 and U4 are "0" and the bit between u8 and u9 is "1".<br>
The following methods are possible for decoding:<br>
-	In the case of a normal VA,  it is possible,  for<br>
example,  to  use  this  apriori  knowledge  in  the<br>
selection of the possible paths,  i.e. paths with<br>
which the known bits are incorrectly decoded are<br>
rejected. This is similar to the termination of a<br>
convolutional code.<br>
-	When an Apri-VA or a similar algorithm, for example<br>
the MAP (maximum a posteriori probability) decoding<br>
algorithm, is used, the apriori L values for the<br>
known dummy bits can be used as acceptable maximum<br>
values (e.g. L = +oo for bit "0" and L = -oo for bit<br>
"1") . For the information bits u1, u2, U3, u4, ... <br>
L1 = 0 (i = l,2,...}  if no apriori knowledge is<br>
present.<br>
-	For systematic channel codes such as, for example,<br>
the recursive systematic convolutional codes which<br>
are already used in the GSM-AMR channel coding and<br>
also as component codes in turbo codes, the Apriori L<br>
value of an information bit can firstly be added to<br>
the channel soft value (i.e. soft input value of the<br>
channel decoder) of the corresponding Systematic code<br>
bit (= information bit) and the resulting soft value<br>
can then be used as a soft input value of the channel<br>
decoder. In this way, a channel decoder which uses<br>
Apriori knowledge (for example the Apri-<br><br>
- 12-<br><br>
VA  algorithm) can be  implemented  directly with a conventional VA (without modification).<br>
Fig. 2 shows the simulation results for a convolutional code with constraint length m+1 - 5 and rate 1/3 under an AWGN (additive white Gaussian noise) channel.. The block length is 200 (bit 0...199). The generator polynomials used are<br><br>
the codes having a known initial state and being terminated at the end of the data block with m tailbits (4 bits = 0 in our case).<br>
The unbroken lines (with symbol "+") show the BER of all 200 information bits using normal coding/decoding (without dummy bits), and the broken lines (with the symbol "x") show the BER if known dummy bits are at the bit positions 9, 11, 15, 49, 89, 90, 129, 130, 131, 169, 170, 171, 172 (and the Apri-VA is used here). It is possible to infer that without taking into account the dummy bits whose BER = 0, the information bits directly next to the dummy bits have a lower BER than the information bits a long way from the dummy bits. As a result, a UEP is achieved. The various parallel lines represent the various channel conditions (from top to bottom, the signal-to-noise ratio S/N = -5.0, -4.5, -4.0, -3.5, -3.0, -2. 5, -2.0, -l.5, -l.0...).<br>
It is to be noted<br><br>
- 12-<br><br>
-	that the bits at the start and end of the datablock<br>
likewise have a lower BER. This is a consequence of<br>
the  known  starting  states and  final  states  (if<br>
terminated) of the convolutional code. In fact, the<br>
method proposed here is based on a similar principle<br>
to code termination. The difference is that during<br>
the termination the known bits are used only at the<br>
end of the datablock (all at once) because otherwise<br>
without termination the bits at the end of the<br>
datablock are significantly less well protected than<br>
the other bits. On the other hand, in our proposal,<br>
the known bits in the vicinity of the bits which are<br>
to be better protected are generally used more than<br>
once.<br>
-	by using additional dummy bits (i.e. inserting more<br>
redundancy), the information bits are always better<br>
protected.   There   is   no  degradation  of  the<br>
performance.<br>
- the additional protective effect of the dummy bits is also basically restricted to the constraint length of the code, similarly to the termination of a convolutional code. Depending on how many dummy bits are used, the protective range can be 2 to 3 times the constraint length (m+1). If, for example, the constraint length is equal to 5, the bits which are at a distance of up to 10-15 bits from the dummy bits can be additionally protected.<br>
-	for a normal non-systematic convolutional code, not<br>
more than m bits are to be used in succession as<br>
dummy bits,(m = code memory), because with m bits the<br><br>
- 14-<br>
code is already terminated, i.e. a further reduction of the BER by more than m bits is not possible.<br>
Fig.3 shows that the bit u4 is best protected by 8 dummy bits (4 on the left-hand side and 4 on the right-hand side) for a non-systematic convolutional code where m = 4.<br>
The above explanations apply to convolutional codes, but the principle can be applied to all codes for which correlation between the code bits placed in a serial arrangement is present after coding (for example turbo codes).<br>
The  proposed  method  is  particularly  attractive  and<br>
efficient for systematic channel codes	(for example the<br>
recursive systematic convolutional/RSC	codes or turbo<br>
codes) because the identical inserted	dummy bits  (for<br>
example "0's")  are mirrored into the	code words  (as<br>
systematic code bits) and do not need to	be transmitted.<br>
This will be explained with an example: If the bits a-b-c-0-d-O-e-f-g-. . . are channel-coded with a code with a rate 1/2 and transmitted where a-b-c-d-e-f-g are the data bits and d is to be protected better by inserting two O's, the coded bits (code bits or code words) have a form aA-bB-cC-OX-dD-OX-eE-fF-gG- ... in the case of a systematic code. Here, X e (0, 1) applies to a, A, b, B, ..., and in general X = a desired number (the first X is not necessarily equal to the second X) . Because the two dummy bits 0 at the receiver end are known, we only need to transmit the bits aA-bB-cC-X-dD-X-eE-f F-gG-... . The dummy bits which are not transmitted can, if appropriate, be reset before decoding (with maximum reliability). This corresponds to a lower equivalent code rate. In the case of a non-systematic code, the coded bits generally have a form AA-BB-CC-XX-DD-XX-EE-FF-GG which should/must all be transmitted.<br><br>
-15-<br>
All codes with relatively low rates can generally be formed (systematically or non-systematically) from codes with relatively high rates using this method (see the following example). It is therefore possible for this method to be combined with puncturing by means of which codes with relatively high rates can be generated from codes with relatively low rates in order to achieve a desired (any) code rate and/or an optimum performance.<br>
For example: We can form a systematic code with the rate 1/3 from a systematic code with the rate 1/2, namely by regular insertion of 0: a-0-b-0-c-0-d-0-... If these bits are coded with a rate 1/2 code, aA-0X-bB-0X-cC-0X-dD-0X-. . . are obtained. The bits to be transmitted are then aA-X-bB-X-cC-X-dD-X-... . The equivalent code rate is 1/3 because a rate 1/3 code generates the same number of code bits, specifically aAX-bBX-cCX-dDX-... . Similarly, we can form codes of equivalent rates 2/5 (a-b-c0-c-d-0-e...), 3/7 (a-b-c-0-d-e-f-0-. . .) , ... from a systematic code with a rate 1/2. In our simulation it has been shown that a rate 1/3 code which is formed in this way almost supplies the same performance as the optimum rate 1/3 code.<br>
The following information applies to Fig. 4: m=8, AWGN channel, RSC code with the polynorms from TS 25.212 V2.0.0 (1999-06), 3rd Generation Partnership Project (3GPP) ; Technical Specification Group (TSG) , Radio Access Network (RAN); Working Group 1 (WG1), where<br>
-	m8r2rscvach0.pro.-3 = code with a rate 1/2, channel<br>
Es/No = -3 dB<br>
-	m8r3rscvach0 .pro-3 = code with a rate 1/3, channel<br>
Es/N0 = -3 dB<br>
-	m8r2rscvach0_alp2.pro.-3 = code with an equivalent<br>
rate of 1/3, channel Es/N0 = -3 dB (proposed method)<br><br>
- 16 -<br>
-	m8r2rscvach0_alp3.pro.-3 =	code with an equivalent<br>
rate of 2/5, channel Es/N0 =	-3 dB (proposed method)<br>
-	m8r2rscvachG__alp4.pro.-3 =	code with an equivalent<br>
rate of 3/7, channel Es/N0 =	-3 dB (proposed method)<br>
-	m8r2rscvachO_alp5.pro.-3 =	code with an equivalent<br>
rate of 4/9, channel Es/N0 =	-3 dB (proposed method)<br>
The embodiments of the invention are not restricted to the examples described above, but are also possible in a multiplicity of refinements which are within the scope of the activities of a person skilled in the art.<br><br>
17.<br>
WE CLAIM:<br>
1.	Method for providing error protection for a data bit stream<br>
in a digital telecommunications transmissions system in order  to<br>
reduce the bit error rate, characterized in that, before  channel<br>
coding,  a  multiplicity  of  previously  known  dummy  bits  are<br>
inserted  in  a  non—termination  fashion  at  predetermined  bit<br>
positions in primary data bit stream near to information—carrying<br>
bits, in particular an both sides thereof.<br>
2.	The method as claimed in claim 1, wherein a code  with  a<br>
relatively low rate is formed from a code with a relatively high<br>
rate by inserting previously known dummy bits.<br>
3.	The  method  as  claimed  in  claim  1  or  2,   comprising<br>
application  to  a  systematic code, the  dummy  bits  not  being<br>
transmitted in the code bits.<br>
4.	The  method  as claimed in one  of  the  preceding  claims,<br>
wherein the code bits are subsequently punctured.<br>
5.	The  method  as claimed in one of  the  preceding  claims,<br>
whvraln  the information bits of the primary data bit stream  are<br>
subjected  to classification of their significance into at  least<br>
two classes And dummy bits are inserted near to bits which  carry<br>
information to a significant degree.<br><br>
18.<br>
6.	The method as claimed in one of the preceding claims wherein<br>
the method being applicable in a  mobile telephone system.<br>
7.	The method as claimed in one of the preceding claims, wherein<br>
the method is applicable for the transmission  of source signals,<br>
in  particular of voice signals.<br>
8.	The method as claimed in one of claims 4 to 7, wherein<br>
the method is applicable to a convolutional code.<br>
9- The method as claimed in one of the preceding claims wherein at the receiver end a path selection is carried out, in particular within the framework of a Viterbi algorithm, on the basis of the protected data bit stream, the resemblance between the processed data bit stream and the protected data bit stream being checked in each case at the locations of the dummy bits and the respective path being rejected in the case of non-correspondence .<br>
10. The method as claimed in one of the preceding claims, wherein the protected data bit stream is decoded as source-control led channel decoding, in particular by means of an Apri-Viterbi algorithm or MAP algorithm.<br>
11. The method as claimed in claim 9, wherein an Apriori-L value of an information bit is added to a soft in put value of the corresponding systematic code bit for a systematic channel code, in particular a recursive systematic convolutional code, and decoding is subsequently carried out by using a conventional Viterbi-algorithm.<br><br>
1 9.<br>
12.	A device for carrying out the method as claimed in  one  of<br>
the preceding claims comprising, a coder being operable to  insert<br>
previously known data bits at predetermined bit positions of  the<br>
primary data bit stream to be coded,<br>
13.	The  device  as claimed  in  claim  11,   comprising    a<br>
classification  device  for classifying the significance  of  the<br>
information  bits of the primary data bit stream, the  output  of<br>
said classification device being connected to the coder.<br>
14.	The  device  as claimed in claim 11  or  12,  comprising  a<br>
sequencing  control  unit  for  controlling  the  checking  of  a<br>
plurality of paths for the received data bit stream, a comparator<br>
unit  for checking the data bit streams which are  processed   by<br>
the plurality of paths, by reference to the positions and  values<br>
of  the dummy bits, and a decision unit, connected to the  output<br>
of  the  comparator  unit, for rejecting or  approving  the  path<br>
assigned to the respectively tested data bit stream, as a  result<br>
of  the comparison, for decoding information bits, in  particular<br>
using a Viterbi-Algorithm.<br>
15.	The device as claimed in one of claims 11 to 13,  comprising<br>
a source—controlled channel decoder, in particular for  executing<br>
an Apri-Viterbi-Algorithm or MAP-Algorithm.<br>
This invention relates to a method for providing error protection for a data bit flow in a digital telecommunication system, especially for speech signals that transmit speech in a mobile radio telephone system. The aim of the invention is to reduce the bit error rate of such a data bit flow. To this end, a plurality of known dummy bits are inserted at predetermined bit positions of the primary data bit flow in the proximity of significant information—carrying bits before channel coding is carried out.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
		<br>
		<div class="pull-left">
			<a href="203250-method-and-apparatus-for-simultaneously-recording-and-reproducing-real-time-information-on-from-a-disc-like-record-carrier.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="203252-apressure-fed-regulated-single-point-water-acid-pouring-instalment-for-storage-battery.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>203251</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2002/00063/KOL</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>10/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>09-Mar-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>09-Mar-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>14-Jan-2002</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SIEMENS AKTIENGESELLSCHAFT</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>WITTELSBACHERPLATZ 2, D-80333 MUNCHEN</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>XU WEN</td>
											<td>BISCHOFSHOFENER STRASSE 11, D-82008 UNTERHACHING</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H 04 L 1/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/DE00/01253</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-04-20</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>199 34 505.8</td>
									<td>1999-07-22</td>
								    <td>Germany</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/203251-a-method-and-device-for-providing-error-protection-for-a-data-bit-flow-in-a-digital-telecommunication-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:27:48 GMT -->
</html>
