<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/229213-a-method-for-updating-a-data-item-and-maintain-concurrency by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:53:03 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 229213:A METHOD FOR UPDATING A DATA ITEM AND MAINTAIN CONCURRENCY</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD FOR UPDATING A DATA ITEM AND MAINTAIN CONCURRENCY</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>ABSTRACT 652/CHENP/2004 &quot;A METHOD FOR UPDATING A DATA ITEM AND MAINTAIN CONCURRENCY&quot; The present invention relates to a concurrency can be maintained in cluster caching when processing an update request on network server that is storing a local copy of data item, the request can be processed using the local copy of the data item. A predicated update request can be sent to a network database storing the data item, wherein the database can commit the update if the local copy is current with the data item. If the local copy is not current, the network server can request a new copy, process the request using the current copy, and try another predicated request, the process can continue until the update is committed to the database or aborted. Once committed, any other servers in the cluster can be notified that the data item has been updated. Those other servers can drop any local copy of the data item and can request an updated copy of the data item. FIGURE 1</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
COPYRIGHT NOTICE<br>
[0001]	A portion of the disclosure of this patent document contains<br>
material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document of the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.<br>
CLAIM OF PRIORITY<br>
(00021	This application claims priority to the following applications<br>
which, are incorporated herein by reference:<br>
[0003]	U.S.  Provisional Patent Application entitled "CLUSTER<br>
CACHING WITH CONCURRENCY CHECKING", Application No. 60/316,187, filed August 30, 2001.<br>
[0004]	U.S. Patent Application entitled"CLUSTERCACHINGWlTH<br>
CONCURRENCY CHECKING", Application No. 10/211.713, filed August 2, 2002.<br>
[0005]	U.S. Provisional Patent Application entitled "METHOD FOR<br>
MAINTAINING ACCOUNTCONSISTENCY,"Application No. 60/316.190, filed August 30,2001.<br>
[0006]	U.S.    Patent    Application    entitled    "METHOD    FOR<br>
MAINTAININGACCOUNTCONSISTENCY.-Application No. 10/211,712, filed August 2, 2002.<br>
CROSS-REFERENCED CASE:<br>
[0007]	The    following    application    is    cross-referenced    and<br>
incorporated herein by reference:<br><br>
[0008]	U.S. Provisional Application No. 60/305,986 entitled "DATA<br>
REPLICATION PROTOCOL," by Dean Bernard Jacobs, Recto Kramer, and Ana than Bala Srinvasan, filed July 16, 2001.<br>
FIELD OF THE INVENTION<br>
[0009]	The invention relates generally to a system for storing data.<br>
The invention relates more specifically to a system and method for caching data and checking concurrency.<br>
BACKGROUND<br>
[0010]	When a data Item is stored in a single database or data store<br>
that is accessible over a network, it is often the case that multiple servers or clients will require access to that data item. Traditionally, this requires data be read from the database each time the data item is accessed. Each read from the database is relatively resource intensive and may be relatively Inefficient.<br>
[0011]	One way of overcoming some of the efficiency and scalability<br>
problems, associated with requiring a server or client to read from the database each time a data item is to be accessed, is to store the data item in cache memory. In this way, once a server or client has read a data item from the database it may simply store a copy of that item in a local cache. That local copy of the data item can then be used if future access is needed. This process may be appropriate and efficient for data items that never change, but problems arise when a data item is updated in the database.<br>
[0012]	If a data item stored in the database is updated, a copy of<br>
that data item stored in a local cache on the network may be different from the item in the database, as it will not automatically receive the update. The problem intensifies when there are multiple local copies on different servers and/or clients on the network. Since each of these local copies is<br><br>
created at a different time, there can be multiple versions of the data item<br>
on the network. If a user tries to update or view the data item, the copy<br>
accessed by the user may not be current and/or correct.<br>
[0013]	These   problems   with   concurrency   can   have   drastic<br>
consequences, such as for example when a user accesses a data item showing a bank account balance. If the local copy of the bank account balance has not been updated to show a withdrawal, for example, the bank account balance shown to the user may in fact show an incorrectly large balance. This could lead the user to unknowingly overdraw the account. Further, a third party accessing the account balance, or a device such as an ATM, would have no way of knowing that the balance being shown is incorrect.<br>
BRIEF SUMMARY<br>
[0014]	It is therefore desirable to develop a system and method for<br>
caching data items and data objects that ensures the accuracy of the cached copy.<br>
[0015]	It is further desirable to develop a system and method to<br>
ensure that any change to a copy of a data item is not allowed unless that<br>
copy reflects the current state of the data item in the database.<br>
[0016]	Systems and methods in accordance with the present<br>
invention provide a way to maintain concurrency in data item caching. A request to update an item is received by a network server, which can store a local copy of the data Item, such as in local cache. The network server can process the request using the local copy of the data item. A "conditional or "predicated" update request can be sent from the network server to a network database, whereby the database can update the data item if the data item contains the same version of the data as the local copy. The database may not update the data item if the data item is not the same version as the local copy.<br>
[0017]	If the copies do not contain the same version, the network<br>
server can request a current copy of the data item, and can process the<br><br>
update request using the new copy of the data item. The network sen/er can send another predicated update to the database. This process continues until the data item in the database is updated. Once the data item is updated, the other network servers, such as servers in a common cluster, can be notified that the data item has been updated. At this point, those network servers can drop any local copy of the data item and can request a new copy to store in local cache.<br>
[0018]	The modification to the network servers can be done by any<br>
of several appropriate methods, such as by multicasting an update<br>
message or version number to any other servers on the network.  The<br>
network servers can also connect to each other directly, such as by a point-<br>
to-point protocol, or can heartbeat information to the other servers.<br>
[0019]	Other features, aspects, and objects of the invention can be<br>
obtained from a review of the specification, the figures, and the claims.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0020]	Figure 1 Is a diagram of a the first part of an approach in<br>
accordance with one embodiment of the present invention.<br>
[0021]	Figure 2 is a diagram of the first and second parts of an<br>
approach in  radiance with one embodiment of the present invention.<br>
[0022]	Figure 3 is a flowchart for an update process in accordance<br>
with one embodiment of the present invent kin.<br>
[0023]	Figure 4 Is a flowchart for a process for updating a data item<br>
when the local copy and original copy are out-of-sync, in avoidance with one embodiment of the present Invention.<br>
[0024}	Figure 5 is a flowchart for a process for updating network<br>
servers on the network, in accordance with one embodiment of the present invention.<br>
[0025]	Figure 6 is a flowchart flora one phase process in accordance<br>
with one embodiment of the present invention.<br><br>
Â£0026]	Figure 7 is a flowchart for a two phase process in accordance<br>
with one embodiment of the present invention.<br>
DETAILED DESCRIPTION<br>
[0027]	Systems In accordance with the present invention allow for<br>
the caching of data while maintaining concurrency across a network, such<br>
as a local area network , theme, or Internet. Such a system can<br>
utilize one or both of a two-part approach to updating data items while<br>
maintaining concurrency. Such systems can implement concurrent<br>
caching through any software or hardware means known or used in the<br>
computer arts or thereinafter developed. These systems can also utilize<br>
any appropriate software applications, objects, languages, or executables,<br>
such as may be designed to utilize, for example, Java, HTML, and XML.<br>
[0028]	In the first part of one such approach in accordance with the<br>
present invention, a client or server on a network reads a data item from a database and stores a copy of the data item in a local cache. If the server or client wishes to update the data Item in the database, the update can be "conditioned" or "predicated" on whether the data item stored in local cache corresponds to the current version of the data item stored In the database. This approach maintains concurrency between the client/server desiring to update the data item and the database. The caching of data in this manner can also improve performance and scalability.<br>
[0029]	One example of a first part of an approach 100 is shown In<br>
Figure 1. Here, a client 102 makes an update request 104 to a network server 106. The network server 106 in this example stores a copy of the data item 110 to be updated in a local cache 108. When the network server 106 receives the update request 104, the server 106 checks the local copy of the item 110 to see if the update may be processed. If the server 106 determines that the update may be processed using intonation in the local copy of the data item 110, the server 106 sends a predicated<br><br>
update 112 to the database 114 storing the original copy of the data item<br>
116. If the information in the original copy of the data item 116 is the same<br>
as the information in the local copy 110, the update may be committed to<br>
the database. If the intonation is different, the update is not committed.<br>
The server 106 receives an update status message 118 from the database<br>
114, Indicating whether the update was committed.<br>
[0030]	If the update was committed, the server can also commit the<br>
update to the copy of the data item 110 in local cache 108. If the update was not committed, because the data items 110,116 were out of sync, the server can drop its copy of the data item 110 from local cache 108 and request a new copy from the database 114.<br>
[0031]	Once the server 106 has the new data item, it can again send<br>
a predicated update 112 to the database 114. Alternatively, the server can<br>
send a message to the client 102 asking whether or not to attempt an<br>
update on the new data item. The server 106 can either abort the update,<br>
or continue the process of trying a predicated update and getting new<br>
copies of the data item as needed until the update is committed. Once the<br>
update is committed or aborted, the server 106 can send an update<br>
response 120 to the client, indicating the end result of the update attempt.<br>
[0032]	The second part of this approach occurs after a client/server<br>
has updated a data item in the database. Since other clients and/or servers on the network may also have a copy of the data Item stored in local cache, the client/server making the update can contact the other servers on the network to let them know that the data item has been updated. The other clients and/or servers on the network can then update a copy of the data item stored in a local cache, request a current copy of the data item, or simply drop the local copy of the data item and request a copy from the database if and when it is needed. If a copy is later requested, the copy can be stored in local cache at that time.<br><br>
[0033]	Figure 2 shows the second stage of the approach 100<br>
described with respect to Figure 1. In Figure 2, once server 106 updates the data item 116 In the database 114 and the copy of the data item 110 in local cache 108. server 106 sends update messages 128,130 to the other servers 122.124 in the cluster 126. These messages can take the form  of point-to-point messages or multicast heartbeats, such as is described above.<br>
[0034]	For example, in a banking system, each server on the<br>
banking system network can potentially store a copy of a user's bank account balance in local cache. Each local cache can include other information about a user account, such as account Information and transaction history. This information can be cached. In whole or in part, on each server on the network.<br>
[0035]	In such a system, a transaction may occur such as an ATM<br>
.transaction. A server in communication with the ATM can store a cached copy of the account balance of the user initiating the transaction. If a user of the ATM wishes to withdraw $100 from a user account, for example, the server could read the balance from memory, determine whether the  account contains sufficient funds for the transaction, and subtract the $100<br><br>
 from the account balance either before or after disbursing the funds.<br><br>
10036]	In order to prevent the user from overdrawing the account,<br>
the server can first verify that the local copy of the user account balance is<br>
current with the balance stored in the database.   For example, if the<br>
previous balance stored locally was $500, the server could send an update<br>
message to the database such as "update balance = $400". which could<br>
also include the current value of the account in local cache, and make the<br>
 update predicated on the fact that the current account balance in the<br>
 database is the same as the current balance of the account in local cache.<br>
[0037]	If the account balance stored In the database is not the same<br>
as the balance In local cache, the server may roll back the update. Once<br>
an update Is rolled back, the server can drop its copy in local cache, read<br><br>
the account information from the database, then attempt the update again.<br>
For example, if the local copy of the account balance said that the balance<br>
was $500, and the database reflected a balance of $1000, the server<br>
would roll back the $400 update attempt and try a predicated $900 update,<br>
subtracting the $100 withdrawal from the current $1000 balance. This<br>
second update can again be predicated on the fact that the account<br>
balance has not changed since it was last read by the server. This process<br>
continues until either the account balance is updated appropriately, or the<br>
transaction is aborted due to insufficient funds, etc.<br>
[0038]	If a server succeeds in updating a data item In the database,<br>
it can also update the copy In local cache, such that the local copy is current with the version of the data Item in the database. For a network In which multiple servers {or clients) can have a copy of the data item in a local cache, the server updating the data item can notify the other servers that the data item has been updated. This can include any or all other servers or clients on a network, in a domain, in a cluster, or in any other network grouping. This notification can be accomplished in any of a number of ways, such as by a point-to-point connection with each server/client, by multicasting, by a one-phase distribution method, by a two-phase distribution method, by heartbeat an update or a delta, or any other appropriate messaging technique.<br>
[0039]	It may be desirable that the sending of the notification is tott^<br>
reliable in the face of failures and scalable, such that the process makes efficient use of the network. One simple approach is to have the server updating the data item ("updating server") individually contact each server or client on the network ("Newport server") and transfer a message over a point-to-point link, such as a TCP/IP connection. The message can tell these network servers that the data item has been updated, and that the network servers should drop any copy of this data item in local cache. This approach may lead to Inconsistent copies of the data If one or more of the<br><br>
network servers are temporarily unreachable, or if the network servers encounter an error in processing the update.<br>
[0040]	Steps in a general process that can be used in accordance<br>
with the present invention are shown in Figures 3-5. In the process 200 of Figure 3, an update request is received, such as from a client, to a network server storing a local copy of the data item to be updated 202. The update is processed by the network server using the local copy of the data item 204. A predicated update request is sent from the network server to the network database containing the original copy of the data item 206. If the original copy and local copy of the data item contain the same version of the data item, the update request is committed 208. If not, the predicated update request is aborted 210.<br>
[0041]	Figure 4 shows a process 300 that can be used if the<br>
predicated update request is aborted. The network server can request a current copy of the data item 302. The network server can then process the update request using the current copy of the data Item 304. A predicated update request is again sent from the network server to the network database containing the original copy of the data item 306. If the original copy and current copy of the data item contain the same version of the data item, the update request is committed 308. If not, the predicated update request is again extorted 310 and the process 300 may be repeated until the update is committed.<br>
[0042]	Figure 5 shows a process 400 that may be used once the<br>
update is committed. Any other servers on the network, such as servers in the scope of an update or servers in a common cluster or domain, are notified that the data item is being updated 402. Any server that is notified then drops any local copy of the data item being stored, such as in a local cache 404. Those servers may choose to request an updated copy of the data Item, either soon after dropping the local copy or upon receiving a subsequent request relating to that data item 406.<br><br>
[0043]	In the case of a two-phase commit, any other servers on the<br>
network, such as in the scope of an update or in the sane cluster, can be notified that an item is being updated during the commit. For example, an update can first go through a prepare stage in which it is determined whether or not the update can be successfully committed. During this phase, or at least before the update is committed, any server that is notified of the update can veto the commit. By vetoing the commit, any preparation is rolled back and the update does not get written to the database. If the update successfully goes through a prepare phase, and does not get vetoed by a server, the update can get committed to the data item in the database.<br>
[0044]	The sending of the notification  can also  be sent by<br>
multicasting the notification to the other servers/clients that might be caching a local copy of the data item. Multicasting in this Instance may comprise the updating server sending the notification once to the network/cluster/domain, which is then passed to the network servers/clients. In simple multicasting, the message is only sent once, such that a server that does not receive the update may fail to drop the outdated copy of the item. This can result in that server having to go through two or more iterations of predicated update attempts for that data item when processing a subsequent request.<br>
[0045]	The sending of the notification can also be sent through a<br>
"heartbeat." A heartbeat in this approach is a periodic message, typically<br>
multicast although other messaging means may be utilized, that is sent to<br>
servers/clients that might be storing a local copy of the data item. An<br>
updating server can continue to heartbeat the latest update(s) for a given<br>
period of time, for a given number of heartbeats, until each server/client<br>
responds it has received the heartbeat, or any other appropriate measure.<br>
[0046]	Each update to a data item can be packaged as an<br>
incremental delta between versions. A protocol in accordance with the present invention may integrate two methods for the distribution of<br><br>
updates, although other appropriate methods can be used accordingly. These distribution methods are refer-ed to as a one-phase method and a two-phase method, and provide a tradeoff between consistency and scalability. In a one-phase method, which can favor scalability, each of the network servers obtains and processes updates at its own pace. The network servers get updates from an updating server at different times, but commit to each update as soon as the update is received. One of the network servers can encounter an error in processing an update, but in the one-phase method this does not prevent the network servers from processing the update.<br>
[0047]	In a two-phase method in accordance with the present<br>
Invention, which can favor consistency, the distribution is "atomic." In that<br>
either all or none of the network servers successfully process the update.<br>
There are separate phases, such as prepare and commit phases, which<br>
can allow for a possibility of abort. In the prepare phase, the updating<br>
server determines whether each of the network servers can take the<br>
update. If all the network servers indicate that they can accept the update,<br>
the new data is sent to the network servers to be committed in the commit<br>
phase. If at least one of the network servers cannot take the update, the<br>
update can be aborted, resulting in no commit. In this case, an updating<br>
server is informed that it should roll back the prepare and nothing is<br>
changed. Such a protocol in accordance with the present invention Is<br>
reliable, as one of the network servers that is unreachable when an update<br>
Is committed, in either method, eventually gets the update.<br>
[0048]	A system in accordance with the present Invention can also<br>
ensure that a temporarily unavailable server eventually receives all updates. For example, a server may be temporarily isolated from the network, then come back Into the network without restarting. Since the server is not restarting, it normally would not check for updates. The server coming back into the network can be accounted for by having the server<br><br>
check periodically for new updates, or by having an updating server check<br>
periodically to see whether the network servers have received the updates.<br>
[0049]	In one embodiment, an updating server regularly sends<br>
multicast "heartbeats" to the network servers, such as for a given period o<br>
time or a given number of heartbeats. Since a multicast approach can be unreliable, it is possible for one of the network servers to miss arbitrary sequences of heartbeats. For this reason, heartbeats can contain a window of information about recent updates. Such information about previous updates can be used to reduce the amount of network traffic, as explained below. In an example such as an account balance, historical information may not be necessary, such that a heartbeat may simply contain the current balance.<br>
[0050]	The updating server can continue to periodically send a<br>
multicast heartbeat containing the version number to the network servers.<br>
This allows any server that was unavailable, or unable to receive and<br>
process a delta, to determine that it is not on the current version of the data<br>
item and request a delta or update at a later time, such as when the slave<br>
comes back into the system. If the current value is contained in the<br>
heartbeat, the server may simply commit the new value.<br>
[0051]	For an update In a one-phase method, these heartbeats can<br>
cause each of the network servers to request a delta starting from that server's current version of the data item. Such a process is shown in the flowchart of Figure 6. In this basic process 500 a version number for the cun-ent data item on the updating server, or in the database, Is sent from the updating server to one of the other network servers 502. The network server determines whether it has been updated to the current version number 504. If the network server Is not on the current version, it requests that a delta be sent from the updating server containing the information needed to update the data item 506. When the delta is sent, the network server processes the delta in order to update to the current version 508.<br><br>
The network server also updates its version number for the data Item to the current version number 510.<br>
[0052]	For an update in a two-phase method, the updating server<br>
can begin with a prepare phase in which it pro-actrvety sends each of the<br>
network servers a delta from the immediately-previous version. Such a<br>
process is shown in the flowchart of Figure 7. In this basic process 600,<br>
a packet of information is sent from the updating server to at least one<br>
other network server 602. Each of the network servers receiving the<br>
packet determines whether it can process that packet and update to the<br>
current version 604. Each server receiving the packet responds to the<br>
updating server, indicating whether the network server can process the<br>
packet 606. If all the networt( servers (to which the delta is sent)<br>
acknowledge successful processing of the delta within some timeout<br>
period, the updating server can decide to commit the update. Otherwise,<br>
the updating server can decide to abort the update. Once this decision is<br>
made, the updating server sends a message to the network server(s)<br>
indicating whether the update should be committed or at&gt;orted 608. If the<br>
decision is to commit, each of the network servers processes the commit<br>
610. Heartbeat can further be used to signal whettier a commit or abort<br>
occurred, in case the command was missed by one of the slaves.<br>
[0053]	In addition to the ability of a serverto pull a delta, an updating<br>
server can have the ability to push a delta during two-phase distribution. In one embodiment, these deltas are always tretween successive versions ofthedata. This two-phase distribution method can minimize the likelihood of inconsistencies between participants. Servers can process a prepare as far as possible without exposing the update to clients or making the update impossible to reill back. This may include such tasks as checking the servers for conflicts. If any of the servers signals an error, such as by sending a "disk full" or "inconsistent configuration" message, the update can be uniformly rolled back.<br><br>
[0054]	It is still possible, however, that inconsistencies may arise.<br>
For instance, there may be errors in processing a commit, for reasons such as an inability to open a socket. Servers may also commit and expose the update at different times. Because the data cannot reach every managed server at exactly the same time, there can be some rippling effect. The use of multicasting provides for a small time window, in an attempt to minimize the rippling effect. In one embodiment, a prepared server will abort if "it misses a commit, whether It missed the signal, the master crashed, etc.<br>
[0055]	A best-effort approach to multicasting can cause a server to<br>
miss a commit signal. If an updating server crashes part way through the commit phase, there may be no logging or means for recovery. There may be no way for the updating server to tell the remaining servers that they need to commit. Upon abort, some servers may end up committing the data if the version is not properly rolled back. In one embodiment, the remaining servers could get the update using one-phase distribution. This might happen, for example, when a server pulls a delta in response to a heartbeat received from an updating server. This approach may maintain system scalability, which might be lost if the system tied down distribution in order to avoid any commit or version errors.<br>
[0056]	If the information regarding the previous versions was not<br>
included in a delta, a server might have to abort and restart if that sep/er was prepared but missed a commit. With the inclusion of older version infomiation, the server can commit that portion of the update it was expecting upon the prepare, and ask for a new delta to handle more recent updates. Infomiation about a given version can be included for at least some fixed, configurable number of heartbeats, although rapid-fire updates may cause the window to Increase to an unacceptable size. In another embodiment, information about an older version is discarded once an updating server determines that all network servers have received the update.<br><br>
[0057]	Multicast heartbeats can have several properties that need<br>
to be taken into consideration. These heartbeats can be asynchronous or<br>
"one-way. As a result, by the time a server responds to a heartbeat, the<br>
updating server or database may have advanced to a new state. Further,<br>
not all servers respond at exactly the same time. As such, an updating<br>
server can assume that a server has no knowledge of its state, and can<br>
include that which the delta is intended to update.<br>
[0058]	These heartbeats can also be unreliable, as a slave may miss<br>
arbitrary sequences of heartbeats. This can again lead to the inclusion of<br>
older version information in the heartbeats. In one embodiment,<br>
heartbeats are received by a server in the order in which they were sent.<br>
For example, a server may not commit version seven until it has committed<br>
version six. The server can wait until it receives six, or it can simply throw<br>
out six and commit seven. This ordering eliminates the possibility for<br>
confusion that might be created by versions going backwards.<br>
[0059]	The foregoing description of the preferred embodiments of<br>
the present invention has been provided for the purposes of illustration and description. It is not Intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to the practitioner skilled in the art. Embodiments were chosen and described in order to best describe the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention, the various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents.<br><br>
WE CLAIM;<br>
1.	A method for updating a data item in a networked persistent data storage<br>
system, comprising:<br>
receiving a request to update a data item in a networked persistent data storage<br>
system, the request being received by a networked server computing device<br>
storing a local copy of the data item;<br>
processing the request using the local copy in the said networked server<br>
computing device;<br>
verifying that the local copy is a current copy of the data item by comparing the<br>
information in the copy of the data item in the said networked persistent data<br>
storage system with the information in the local copy of the data item, whereby<br>
the local copy is current if the two copies are same, and whereby the local copy<br>
is not current if the two copies are different; and<br>
updating the data item in the said networked persistent data storage system in<br>
response to the request if the local copy is a current copy.<br>
2.	A method as claimed in claim 1, comprising:<br>
notifying another server computing device on the network that the data item has been updated in the persistent data storage system.<br>
3.	A method as claimed in claim 1, comprising:<br>
storing the local copy in local cache on the networked server computing device.<br>
4.	A method as claimed in claim 1, comprising:<br>
deleting the local copy of the data item and requesting a current copy of the data item from the persistent data storage system if (he local copy in local cache on the networked server computing device is not a current copy of the data item.<br><br>
5.	A method for updating a data item in a cluster of server computing<br>
devices and persistent data storage system, comprising:<br>
processing an update request on a clustered server computing device, the clustered server computing device storing a local copy of a data item to be used in processing the request;<br>
sending a predicated update request to a clustered persistent data storage system containing the data item, whereby the clustered persistent data storage system updates the data item if the local copy is current with the data item before the update, and whereby the clustered persistent data storage system does not update the data item if the local copy is not current with the data item before the update,<br>
6.	A method as claimed in claim 5, comprising:<br>
receiving a message from the clustered persistent data storage system to the clustered server computing device indicating whether the data item has been updated.<br>
7.	A method as claimed in claim 5, comprising:<br>
reading a data item from the clustered persistent data storage system and storing a local copy of the data item in local cache on the clustered server computing device.<br>
8.	A method as claimed in claim 5, comprising:<br>
receiving an update request from a client to the clustered server computing device.<br>
9.	A method as claimed in claim 5, comprising:<br><br>
checking the local copy of the data item in local cache on the clustered server computing device to determine whether the update request can be processed.<br>
10.	A method according as claimed in claim 5, comprising:<br>
updating the local copy of the data item in local cache on the clustered server computing device if the data item in the clustered persistent data storage system is updated.<br>
11.	A method as claimed in claim 5, comprising:<br>
deleting the local copy and storing a new copy of the data item in local cache on the clustered server computing device if the local copy is not current with the data item.<br>
12.	A method as claimed in claim 11, comprising:<br>
sending an additional predicated update request to a clustered persistent data storage system containing the data item, whereby the clustered persistent data storage system updates the data item if the new copy is current with the data item before the update, and whereby the clustered persistent data storage system does not update the data item if the new copy is not current with the data item before the update.<br>
13.	A method as claimed in claim II, comprising:<br>
determining whether the client initiating the update request wishes to attempt the update with the data item current with the new copy.<br>
14.	A method as claimed in claim 5, comprising:<br>
notifying another server computing device in the cluster that the data item in the clustered persistent data storage system has been updated.<br>
15.	A method as claimed in claim 5, comprising:<br><br>
multicasting an update message to other server computing devices in the cluster.<br>
16.	A method as claimed in claim 5, comprising:<br>
multicasting a version number for the data item to other clustered server computing devices in the cluster after updating the data item.<br>
17.	A method as claimed in claim 5, comprising:<br>
contacting each server computing device in the cluster directly to indicate that the data item has been updated.<br>
18.	A method as claimed in claim 5, comprising:<br>
heartbreaking the version number for the updated data item to any other clustered server computing devices on the network.<br>
19.	A method as claimed in claim 14, comprising:<br>
dropping a local copy of the data item stored on any clustered server computing device being notified the data item has been updated.<br>
20.	A method as claimed in claim 14, comprising:<br>
requesting an updated copy of the data item on any clustered server computing device being notified the data item has been updated.<br>
21.	A method as claimed in claim 14, comprising:<br>
deleting a local copy of the data item on any clustered server computing device being notified the data item has been updated.<br>
22.	A method as claimed in claim 5, comprising:<br>
notifying another server computing device in the cluster that the data item in<br>
the clustered persistent data storage system is going to be updated.<br><br>
23.	A method as claimed in claim 22, comprising:<br>
allowing said another clustered server computing device to veto the update of the data item in the clustered persistent data storage system.<br>
24.	A method as claimed in claim 5, comprising:<br>
sending a packet of information to another server computing device in the cluster, the packet of information containing changes to the data item due to the update.<br>
25.	A method as claimed in claim 24, wherein:<br>
the packet of information contains changes between the state of the data item after the update and the prior state of the data item before the update.<br>
26.	A method as claimed in claim 5, comprising:<br>
determining whether other server computing devices in the cluster can accept the update to the data item; and<br>
committing the update to the other clustered server computing devices if the other clustered server computing devices can accept the update.<br>
27.	A method as claimed in claim 26, comprising;<br>
rolling back the update if the other clustered server computing devices carmot accept the update.<br>
28.	A method for maintaining concurrency for a copy of a data item cached<br>
locally on a clustered server computing device, comprising:<br>
receiving an update request, the update request being received by a clustered server computing device storing a local copy of a data item in local cache; processing the request using the local copy of the data item;<br><br>
sending a predicated update request to a clustered persistent data storage system storing the data item, whereby the clustered persistent data storage system updates the data item if the data item is current with the local copy, and whereby the clustered persistent data storage system does not update the data item if the data item is not current with the local copy;<br>
requesting a current copy of the data item for the clustered server computing device and sending another predicated update if the local copy is not current with the data item in the clustered persistent data storage system, the step of requesting a current copy and sending another predicated update continuing until one of the clustered persistent data storage system updating the data item and the method being aborted; and<br>
notifying other server computing devices in the cluster that the data item in the database has been updated.<br>
29.	A method as claimed in claim 28, wherein the step of notifying other<br>
server computing devices in the cluster comprises;<br>
multicasting an update message to other server computing devices in the cluster that might be storing a local copy of the data item.<br>
30.	A method as claimed in claim 28, wherein the step of notifying other<br>
server computing devices in the cluster comprises:<br>
multicasting a version number for the data item to other server computing devices in the cluster after the data item is updated.<br>
31.	A method as claimed in claim 28, wherein the step of notifying other<br>
server computing devices in the cluster comprises:<br>
contacting another server computing device in the cluster by a point-to-point connection to indicate that the data item has been updated.<br><br>
32.	A method as claimed in claim 28, wherein the step of notifying other<br>
server computing devices in the cluster comprises:<br>
heartbeating the version number for the data item to other server computing devices in the cluster after the data item is updated.<br>
33.	A method as claimed in claim 28, comprising:<br>
dropping a local copy of the data item on any other server computing device in the cluster being notified that the data item has been updated.<br>
34.	A method as claimed in claim 28, comprising:<br>
requesting an updated copy of the data item to any other server computing device in the cluster being notified that the data item has been updated.<br><br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGFic3RyYWN0IGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 abstract duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGFzc2llbmVtZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 assienement.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGNsYWltcyBkdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 claims duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGNvcnJlc3BvbmRlbmNlIG90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 correspondence others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGNvcnJlc3BvbmRlbmNlIHBvLnBkZg==" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 correspondence po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGRlc2NyaXBpdGlvbiBjb21wbGV0ZWQgZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 descripition completed duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGRlc2NyaXBpdGlvbiBjb21wbGV0ZWQucGRm" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 descripition completed.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGRyYXdpbmdzIGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 drawings duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGZvcm0tMjYucGRm" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IGZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IG90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IHBjdCBzZWFyY2ggcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 pct search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IHBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 pct.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDY1Mi1jaGVucC0yMDA0IHBldGl0aW9uLnBkZg==" target="_blank" style="word-wrap:break-word;">0652-chenp-2004 petition.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="229212-dosing-device-with-a-medium-reservoir-as-well-as-a-pumping-device.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="229214-screen-printing-method-for-flat-textile-structures-and-device-for-carrying-out-the-method.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>229213</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>652/CHENP/2004</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>12/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>20-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>13-Feb-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>29-Mar-2004</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>BEA SYSTEMS, INC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2315 NORTH FIRST STREET, SAN JOSE, CALIFORNIA 95131,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>JACOBS, DEAN, BERNARD</td>
											<td>1747 MADERA STREET, BERKELEY, CALIFORNIA 94707,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>WOOLEN, ROB</td>
											<td>2531 14TH AVENUE, SAN FRANCISCO, CA 94127,</td>
										</tr>
										<tr>
											<td>3</td>
											<td>MESSINGER, ADAM</td>
											<td>317 29TH SREET-APT.306, SAN FRANCISCO, CALIFORNIA 94131,</td>
										</tr>
										<tr>
											<td>4</td>
											<td>WHITE, SETH</td>
											<td>176 ESCOLTA WAY, SAN FRANCISCO, CALIFORNIA 94116,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>GO6F 17/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US02/27315</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-08-28</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/211,712</td>
									<td>2002-08-02</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/316,187</td>
									<td>2001-08-30</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>3</td>
									<td>60/316,190</td>
									<td>2001-08-30</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>4</td>
									<td>10/211,713</td>
									<td>2002-08-02</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/229213-a-method-for-updating-a-data-item-and-maintain-concurrency by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:53:04 GMT -->
</html>
