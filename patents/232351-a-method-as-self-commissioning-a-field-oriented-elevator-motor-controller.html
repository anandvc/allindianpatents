<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/232351-a-method-as-self-commissioning-a-field-oriented-elevator-motor-controller by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:06:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 232351:&quot;A METHOD AS SELF-COMMISSIONING A FIELD-ORIENTED ELEVATOR MOTOR CONTROLLER&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;A METHOD AS SELF-COMMISSIONING A FIELD-ORIENTED ELEVATOR MOTOR CONTROLLER&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A self-commissioning controller 7 for a field-oriented elevator motor controller 14 includes calculating an integral gain KI, a proportional gain Kp, and an overall gain (Gc) for the motor controller; obtaining initial values of a rotor time constant &amp;#964;R, magnetizing current Id, and motor torque constant KT for the motor controller 14, and obtaining a value of a motor transient inductance La; calculating final values for said rotor time constant &amp;#964;R and magnetizing current Id, using said transient inductance La; and calculating a system inertia J* parameter for speed loop compensation 16 within the motor controller 14. The controller 7 may also include calculating the initial values for &amp;#964;R, Id, and KT*, and performing self-commissioning automatically upon receiving a command from a service tool 80.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>Self-Commissioning Controller For A Field-Oriented Elevator Motor/Drive System<br>
Cross References to Related Applications<br>
Co-pending U.S. Application Serial Nos. (Otis Docket Nos. OT-3066, OT-3064, OT-3065, OT-4046 and OT-4054) filed contemporaneously herewith, contain subject matter related to that disclosed herein.<br>
Technical Field<br>
This invention relates to self-commissioning an elevator and, more particularly, to self-commissioning a field-oriented motor/drive system for an elevator.<br>
Background of the Invention<br>
It is known in the art of elevator systems to use an AC induction motor with a variable frequency drive to provide traction power to an elevator system. However, proper function of the drive/motor combination requires that the motor parameters be identified and that the motor/drive control parameters be set to values which provide the desired system response. In addition, the inertia of the moving<br>
components must be accurately determined for proper control of the motor and elevator.<br>
Typically, the motor parameters and the inertia of the moving components are determined through various techniques. One technique includes removing the motor from the job site to an engineering center for evaluation of motor parameters. Another technique requires sending an engineer to the job site with expensive test equipment to help match the motor and the drive. Determination of the inertia parameter may be determined by a complex calculation of system weights from contract data which may or may not be accurate at a given job site. Also, in many instances, all the system masses are not accurately known, and thus accurate calculation of system weights is not feasible. The above techniques are inefficient and costly, and in some cases, inaccurate. As a result, modernization or retrofit applications where new drives replace old drives in existing elevator systems become unattractive for building owners.<br>
Disclosure of the Invention<br>
Objects of the invention include provision of a self-commissioning elevator controller that automatically calibrates itself on-site for a given elevator/motor drive system.<br>
According to the present invention, a method of self-commissioning a field-oriented elevator motor controller includes:<br>
a) calculating an integral gain Kr, a proportional gain Kp, and an overall gain (Gc) for the motor controller; b) obtaining initial values of a rotor time constant τR, magnetizing current Id, and motor torque constant KT* for the motor controller, and obtaining a value of a motor transient inductance La; c) calculating final values for said rotor time constant τR and magnetizing current Id, using said transient inductance Lcr; and d) calculating a system inertia J* parameter for the motor controller.<br>
According further to the present invention, the step of obtaining includes calculating the initial values for τR, Id, and KT*. According still further to the present invention, performing steps (a)-(d) automatically upon receiving a command from a service tool.<br>
The invention represents a significant improvement over the prior art by providing a motor controller which is automatically self-commissioning. The invention determines the necessary motor, control, and inertia parameters at the job site without the need to unrope the elevator for separate motor tests or to employ expensive and/or complicated test equipment or specially trained personnel. Accordingly, the invention reduces the time and cost of adjusting the elevator system to a new motor controller, thereby making it more attractive to retrofit or modernize old controllers in the field. The present invention automatically determines the necessary parameters and communicates to service personnel when self-commissioning has been completed or when a fault has occurred.<br>
The foregoing and other objects, features and advantages of the present invention will become more apparent in light of the following detailed description of the exemplary embodiments thereof, as illustrated in the accompanying drawings.<br>
Brief Description of the Drawings<br>
Fig. 1 is a schematic block diagram of an elevator controller including auto-calibration logic, in accordance with the present invention.<br>
Fig. 2 is a block diagram of a field-oriented current regulator/ motor drive circuit within the controller of Fig. 1, in accordance with the present invention.<br>
Fig. 3 is a top level logic flow diagram of the auto-calibration logic of Fig. 1 in accordance with the present invention.<br>
Fig. 4 is a control system block diagram of system of Fig. 1, in accordance with the present invention.<br>
Fig. 5 is a plot of the magnitude frequency response of the open loop transfer function of the control system of Fig. 4, in accordance with the present invention.<br>
Fig. 6 is a plot of the magnitude frequency response of the closed loop transfer function of the control system of Fig. 4, in accordance with the present invention.<br><br>
Fig. 7 is a logic flow diagram of the auto-calibration logic of Fig. 1, in accordance with the present invention.<br>
Fig. 8 is a schematic drawing of an equivalent circuit model of an induction motor controlled by field orientation, in accordance with the present invention.<br>
Fig. 9 is a simplified schematic diagram of the equivalent circuit of Fig. 8, in accordance with the present invention.<br>
Fig. 10 is a logic flow diagram of the auto-calibration logic of Fig. 1, in accordance with the present invention.<br>
Fig. 11 is a graph of the imaginary part of the rotor impedance and of the motor impedance versus frequency, in accordance with the present invention.<br>
Fig. 12 is a logic flow diagram of a portion of the flow diagram of Fig. 10, in accordance with the present invention.<br>
Fig. 13 is a block diagram of a portion of the auto-calibration logic of Fig. 1, in accordance with the present invention.<br>
Fig. 14 is an induction motor coupled circuit diagram for q-axis variables for a field-oriented driven motor, in accordance with the present invention.<br>
Fig. 15 is an induction motor coupled circuit diagram for d-axis variables for a field-oriented driven motor, in accordance with the present invention.<br>
Fig. 26 is a graph of three motor speed parameters versus time when the inner loop gain estimate is correct, in accordance with the present invention.<br>
Fig. 27 is a graph of three parameters in the auto-calibration logic of Fig. 1 versus time when the inner loop gain estimate is correct, in accordance with the present invention.<br>
Fig. 28 is a graph of XAVG versus estimated inertia (J*) for various values of J*, in accordance with the present invention.<br>
Best Mode for Carrying Out the Invention<br>
Referring to Fig. 1, that shown to the left of the line 9 is a portion of an elevator controller 7, which includes a motion controller or motion control sub-system (MCSS) 10 which receives floor destination commands from operational control logic (not shown) on a line 8 and provides a speed (or velocity) reference signal ωREF on a line 12 (in the form of a speed profile) to a motor controller or drive/brake sub-system (DBSS) 14. The motor controller 14 comprises speed loop compensation logic 16 which closes a motor spe'ed control loop, such as that described in Copending US Patent Application, Serial No. (Otis Docket No. OT-3054), filed contemporaneously herewith, and provides a torque current reference signal IqREF1 on a line 15.<br>
Fig. 16 is a logic flow diagram of a portion of the auto-calibration logic of Fig. 1, in accordance with the present invention.<br>
Fig. 17 is a logic flow diagram of a portion of the flow diagram of Fig. 16, in according with the present invention.<br>
Fig. 18 is a graph of speed profile vs. time, in accordance with the present invention.<br>
Fig. 19 is a graph of Vd vs. RPM at no load for a motor running in clockwise and counterclockwise directions, in accordance with the present invention.<br>
Fig. 20 is a graph of a loss component XDF and a filtered up/down difference FUDD vs. rotor time constant for an up run and a down run, in accordance with the present invention.<br>
Fig. 21 is a block diagram of a portion of the auto-calibration logic of Fig. 1, in accordance with the present invention.<br>
Fig. 22 is a control system block diagram model of a portion of the controller of Fig. 1, in accordance with the present invention.<br>
Fig. 23 is a simplified control system block diagram of the system of Fig. 22, in accordance with the present invention.<br>
Fig. 24 is a simplified control system block diagram of the system of Fig. 23, in accordance with the present invention.<br>
Fig. 25 is a logic flow diagram of a portion of the auto-calibration logic of Fig. 1, in accordance with the present invention.<br>
The motor control 14 also includes a known field-oriented (or vector-based) motor drive control that has two control loops each corresponding to a different control axis, a d-axis relating to motor magnetization, and a q-axis relating to torque. The d-axis loop has a d-axis current reference input signal IdREF provided on a line 14 which sets the d-axis current Id. IdREF (and thus Id) is set to a predetermined constant value so as to provide appropriate magnetic flux in the motor based on motor magnetization curves. The IdREF signal is fed to a field-oriented current regulator/motor drive circuit 20, described more hereinafter with Fig. 2.<br>
The q-axis current loop has a first q-axis current reference input signal IqREF1 on the line 15 that is fed to one input of a switch 19, provided by the speed loop compensation logic 16. The logic 16 provides the q-axis current reference signal IqREF1 to the circuit 20 when it is not in auto-calibration (or self-commissioning) mode. The other input to the switch 19 is a second q-axis current reference input signal I qREFi on a nne 17. The output of the switch 19 is the q-axis current loop reference signal IqREF on a line 18, which is set equal to IqREF1 or IqREF2 based on the state of a MODE1 signal provided to the switch 19 on the line 13. The IqREF signal is fed to the field-oriented current regulator/motor drive circuit 20, described more hereinafter with Fig. 2.<br>
The circuit 20 provides 3-phase drive voltages VX,VY,VZ on lines 22 to a motor 24, e.g., a three phase induction motor. The motor 24<br>
provides a speed feedback signal ωR indicative of the rotational speed of the motor 24 on a line 36 back to the controller 7.<br>
Two examples of three phase AC induction motors which may be used with the present invention are, Model LUGA-225LB-04A, by Loher, having a rated power of 45KW, rated voltage of 355 volts, rated speed of 1480, and rated frequency of 50 Hz, in a geared configuration; and Model 156MST, by Tatung (of Taiwan), having a rated power of 40KW, rated voltage of 500 volts, rated speed of 251, and rated frequency of 16.7 Hz, in a gearless configuration. Other motors having other rated parameters may be used if desired.<br>
The motor 24 is connected by a mechanical linkage 26, e.g., a shaft and/or a gearbox, to a sheave 28. A rope or cable 30 is wrapped around the sheave 28 and has one end connected to an elevator car 32 and the other end connected to a counterweight 34. The weight of the counterweight is typically equal to the empty car weight plus 40-50% of the rated load for the car.<br>
Other elevator system configurations, and with or without a counterweight, with or without a gearbox, may be used if desired to convert the output torque of the motor 24 to movement of the elevator cab 32, such as dual lift (where two elevator cars are connected to a single rope, the cars move in opposite directions and each car provides a counterweight for the other car), drum machine (where the rope is wrapped around a drum driven by a motor), etc.<br>
A brake 37, e.g., an electro-magnetic actuated disk brake, is disposed on the shaft 26, and is driven by an electrical brake command signal BRKCMD on a line 38 from the circuit 20. The brake 37, when activated or "dropped", clamps onto the shaft 26 and prevents the motor shaft 26 from turning, i.e., locks the rotor, and thus prevents the sheave 28 from moving.<br>
Referring to Fig. 2, as discussed hereinbefore, it is known in the art of field-oriented motor control that such control uses current and voltage parameters corresponding to the d and q axes. In particular, the field-oriented current regulator/motor drive 20 of Fig. 1 comprises two current control loops, one for the d-axis (magnetizing) current Id and one for q-axis (torque) current Iq. The Id loop receives the IdREF signal on the line 14 to a positive input to a summer 102. A measured or feedback d-axis current signal Id on a line 104 is fed to a negative input to the summer 102. The output of the summer 102 is an error signal IdERR on a line 106 which is fed to control compensation logic 108, such as proportional-plus-integral (P-I) current loop control, having a proportional gain KP, an integral gain KI5 and an overall gain Gc, provided on lines 121, as described more hereinafter. The logic 108 provides a d-axis voltage command signal VdCMD on a line 110.<br>
For the q-axis, the Iq loop receives the IqREF signal on the line 18 to a positive input to a summer 114. A measured or feedback q-axis current signal Iq on a line 116 is fed to a negative input to the summer<br>
114. The output of the summer 114 is an error signal IqERR on a line 118 which is fed to control compensation logic 120, e.g., proportional-plus-integral (P-I) logic similar to the logic 108, having the proportional gain KP and the integral gain K,, the same as the gains for logic 108. The output of the logic 120 is a q-axis voltage command signal VqCMD on a line 122. Because the q and d axis current loops are integral loops, in steady state, Id will be equal to IdREF.<br>
The voltage commands VdCMD and VqCMD are fed to known field-oriented to three-phase conversion logic 124 which converts the d-axis and q-axis voltage commands to three phase voltage commands VXCMD, VYCMD, VZCMD on lines 126. The phase voltage commands VXCMD, VYCMD, VZCMD are fed to a known three phase drive circuit (or inverter) 128 which provides three phase voltages VX,VY,VZ on lines 130,132, 134, respectively (collectively, the lines 22), to drive the motor 24 (Fig.<br>
1).<br>
Within the drive circuit 128 (details not shown), each of the voltage commands VXCMD, VYCMD, VZCMDon lines 126 are converted to percent duty cycle commands indicative of the corresponding input voltage level. The percent duty cycle is converted into a pulse-width-modulated drive signal which drives power transistors to provide the pulse-width-modulated, variable frequency, three phase voltages Vx,VY,Vzon lines 130, 132, 134, respectively. The conversions within the drive 128 are performed using electronic components and/or<br>
software well known in the art of motor drive circuits. Any other type of drive circuit that receives input voltage commands and provides output phase voltages may be used, and the phase voltages need not be pulse-width modulated.<br>
Phase currents Ix, IY, Iz associated with the voltages VX,VY,VZ, respectively, are measured by known current sensors 136, 138, 140, e.g., closed-loop Hall-effect current sensors (such as LEMS), respectively, and are provided on lines 141, 142, 143, respectively. The phase currents Ix, IY, Iz are fed to known three phase to field-oriented conversion logic 150, which provides a known conversion from phase currents to d-axis and q-axis currents Id, Iq, on the lines 104,116 which are fed to the summers 102,114, respectively, as feedback currents.<br>
It is known in the art of field oriented drives that the value of the rotor time constant τR, the torque constant KT, the rated motor magnetizing current IdRATED and rated motor torque current IqRATEDmust be known. These motor parameters are provided to the logics 124,150 on lines 144. In particular, τR is used to establish the correct slip frequency cos to achieve field orientation, and these parameters are also needed to achieve the desired or rated torque of the motor at the rated speed and the rated voltage of the motor. The lines 116,118,104,122,110, are collectively referred to as 147 and the lines 121,144 are collectively referred to as 149.<br>
The converters 124,150 provide known conversions between vector (d and q axis) parameters and per-phase parameters, such as that described in D. Novotny, et al, "Vector Control and Dynamics of AC Drives", Oxford University Press, 1996, Ch 5, pp 203-251. The converters 124,150 may likely implement such conversions in software using a microprocessor or the like.<br>
The motor drive logic 111 also includes a brake drive circuit 145 which receives an input signal BRK on a line 146 and provides a BRKCMD signal on the line 38.<br>
Referring to Fig. 1, the present invention comprises self-commissioning logic 48 which automatically computes and provides the P-I control parameters Kl5 KP, Gc and the motor parameter τR on the lines 149, and computes and provides the parameters J*, KT* on lines 74, and the parameter IdREF on the line 14, to the motor controller 14. The logic also provides a secondary torque current reference signal IqREF2on the line 17. The logic 48 receives the parameters Vd, Vq, Id, Iq, and IqERR from the circuit 20 on the lines 147.<br>
The logic 48 also provides the MODE1 signal on the line 13 to the switch 19. The MODE1 flag causes the current reference signal IqREF2 from the calibration logic 48 to be fed to the logic 20. The logic 48 also provides a break request signal BRK on the line 146 to the circuit 20. Further, the logic 66 also provides MODE and FLRCMD signals on lines 71,72, respectively, to the motion control logic 10. The MODE<br>
flag causes the motion logic 10 to accept floor commands from the FLRCMD signal on the line 72.<br>
The FLRCMD signal commands the motion controller 10 to perform an elevator run in a commanded direction for a commanded number of floors (or to a particular destination floor) using a standard predetermined speed profile for ωREF (e.g., Fig. 18) in the motor control 10, discussed hereinafter. The motion control logic 10 also provides a motor controller fault signal MCFAULT on a line 73 to the logic 48 to indicate if a fault has occurred during an elevator run. During the elevator run, the elevator is run through a normal speed profile using an empty car with the normal safety features enabled.<br>
The logic 48 also communicates with a service tool 80 over a serial link 82. The service tool 80 includes a display 84 and a keypad (or keyboard) 86 for entering data into the service tool 80 and over the link 82 to the controller 7. In particular, the logic 48 receives a start command over the link 82 from the service tool 80, which controls when auto-calibration is started. The logic 48 also provides a DONE signal, a FAULT signal, and may also provide certain motor parameters, to the service tool 80 over the link 82. The DONE signal indicates when logic 48 has completed without faults and the FAULT signal indicates when a fault has been detected during self-commissioning.<br>
The elevator motion commands (destination floors) may be entered manually using the service tool 80, or, alternatively, the elevator may be<br>
set up to cycle between two predetermined floors using the service tool 80. Also, to simplify implementation and maximize safety, all motion of the elevator may be under control of the normal elevator control systems and all normal hoistway safety functions may be in effect.<br>
The logic 48 comprises known electronic components, which may include a microprocessor, interface circuitry, memory, software, and/or firmware, capable of performing the functions described herein.<br>
Referring to Fig. 3, the logic 48 comprises four tests, 252,258,262,266. The first two tests 252, 258 are locked rotor tests which are performed with the motor at standstill (i.e., with the brake dropped). The other two tests 256,258 are running rotor tests, where the elevator is run up and/or down to determine various motor parameters.<br>
In particular, the auto-calibration logic 48 enters at a step 250 which checks whether a start command has been received from the service tool 80. If a start command has not been received, the logic exits. If a start command has been received, a step 252 performs the first locked rotor test which calculates values for K,, KP and Gc for the current loop compensation 108,120 (Fig. 2) for the current regulator and motor drive 20 within the motor control 14 (Fig. 1), discussed more hereinafter. The locked rotor test 252 may be the same as that described in co-pending U.S. Patent Application Serial No. (Otis Docket No. OT-3066), filed contemporaneously herewith. Then, a step 254 tests whether a fault was detected during the previous test or if a stop<br>
command has been received from the service tool 80. If a fault was detected or a stop command was received, the logic 48 exits.<br>
Next, a step 256 tests whether certain motor parameters such as the rotor time constant τR, the d-axis current reference IdREF (and thus Id) the motor torque constant KT*5 and the transient inductance La, are available from the service tool 80, e.g., from the motor data sheet. If they are available, the second locked rotor test 258 is skipped and the logic 48 goes to the running rotor test 262. If the motor data sheet parameters are not available, the logic 48 performs the second locked rotor test 258 which calculates initial values for τR, IdREF (and thus Id) and KT*, and calculates certain other motor parameters, such as La and/or the stator resistance Rl, discussed more hereinafter. The second locked rotor test 258 may be the same as that described in co-pending U.S. Patent Application Serial No. (Otis Docket No. OT-3064), filed contemporaneously, herewith, discussed more hereinafter. Then, a step 260 tests whether a fault was detected during the previous test or if a stop command has been received from the service tool 80. If a fault was detected or a stop command was received, the logic 48 exits.<br>
Next, the logic 48 performs the first running rotor test 262 which fine runes the values for τR, IdREF (and thus Id), and KT*, using the values for the parameters calculated form the test 258 or received from the service tool 80. The first running rotor test 262 may be the same as that described in co-pending U.S. Patent Application Serial No. (Otis Docket<br>
No. OT-4046), filed contemporaneously herewith. Alternatively, The first running rotor test 262 may be the same as that described in co-pending U.S. Patent Application Serial No. (Otis Docket No. OT-3065), filed contemporaneously herewith, and which is incorporated herein by reference in its entirety. Then a step 264 tests whether a fault was detected during the previous test or if a stop command has been received from the service tool 80. If a fault was detected or a stop command was received, the logic 48 exits.<br>
Next, the logic 48 performs the second running rotor test 266 which calculates the value of the system inertia J*. The running rotor test 266 may be the same as that described in co-pending U.S. Patent Application Serial No. (Otis Docket No. OT-3054), filed contemporaneously herewith, discussed more hereinafter. Then a step 268 provides some or all of the parameters calculated in the four tests 252,258,262,266 to.the service tool 80 for use by service personnel. Each of the four tests makes up a portion of the auto-calibration logic 48, as described hereinafter, to compute the specific parameters for that test. First Locked Rotor Test:<br>
Referring to Fig. 4, a control system block diagram equivalent diagram of the q-axis current loop with the auto-calibration logic 48 of Figs. 1 and 2 is shown when the MODE1 signal (Fig. 1) commands the switch 19 to set IqREF equal to IqREF2 as the reference to the q-axis current<br>
loop (i.e., auto-calibration mode). Various portions of the control system of Fig. 4 may be analogized to the portions of the schematic block diagrams of Figs. 1 and 2. In particular, the control system of Fig. 4 comprises the q-axis current reference signal IqREF on a line 210 (analogous to the line 18 of Fig. 2) from the auto-calibration logic 48, which is fed to the positive input of a summer 212 (analogous to the summer 114 of Fig. 2). The Iq current feedback signal on a line 214 is fed to the negative input of the summer 212. The summer 212 provides an error signal IERR on a line 216 to a box 218 which represents the P-I control compensation (analogous to the q-axis loop compensation logic 120 in Fig. 2). The compensation 218 comprises a known proportional-plus-integral (P-I) control transfer function:<br>
(Equation Removed)<br>
Eq. 1<br>
where K{ is the integral gain, Kp is the proportional gain, Gc is the overall gain, and "s" is the known Laplace transform operator.<br>
The compensation 218 provides a voltage command signal VqCMD on a line 220 to a box 222 indicative of the transfer function of the motor drive 111 (Fig. 2) which, in the frequency range of interest, has a transfer function of 1. The drive 222 provides a per-phase drive voltage Vph on a line 224 to a box 226 representing the transfer function of the motor 24 (Fig. 1). The transfer function of the motor 24 is approximated by a first order lag having an equation:<br>
(Equation Removed)	Eq.2<br><br>
where L is the per-phase inductance of the motor, R is the per-phase resistance of the motor, and "s" is the Laplace transform operator. The motor 24 is a three-phase induction motor but may be any type of motor having a similar transfer function. The q-axis current Iq of the motor is indicated on a line 214 and is fed back to the summer 212. Iq is actually measured within the drive 1 1 1 (Fig. 2); however, the transfer function of the motor is part of the control system loop dynamics as shown in Fig. 3.<br>
As discussed hereinbefore with Figs. 1 and 2, the auto-calibration logic 48 provides IqREF2 to the q-axis current loop on the line 210 (as well as the MODE1 and the IdREF signals), which in this case, is equal to the q-axis current loop reference IqREF, receives the signals IqERR, Iq on lines 216,214, respectively, (analogous to the lines 1 18,1 16 of Fig. 2) from the q-axis current loop, provides the control parameters Kl5KP,Gc on lines 219 (analogous to lines 121 of Fig. 2) to the compensation block 218, and receives and provides parameters over the serial link 82.<br>
Referring to Figs. 4, 5, and 6, for the first locked rotor test 252, the auto-calibration logic 48 sets Gc and adjusts K1and KPto obtain the desired overall drive/motor loop response without disconnecting or removing the motor. In particular, the open loop transfer function for the control system block diagram combines Eqs. 1 and 2 as follows:<br>
(Equation Removed)<br>
If Kp = L and Kr = R, the open loop transfer function of Eq. 3 reduces to Gc/s, an integrator with a gain Gc, which provides desirable loop performance of the motor control system. The resultant integrator has a magnitude (or gain) frequency response which crosses 1 (0 dB) at ωc(rad/sec) = Gc (i.e., the open loop cross-over frequency). Thus, the integrator gain Gc is set to equal the desired open loop cross-over frequency in rad/sec (i.e., Gc = ωc = 2πFOL). For a system with an open loop transfer function equal to an integrator, the frequency at which the open loop gain crosses through 1 (0 dB), i.e., the open loop cross-over frequency (FOL), is equal to the frequency at which the closed loop response is less than 1 (0 dB) by a predetermined amount (e.g., 3 dB), i.e., the closed loop bandwidth.<br>
The auto-calibration logic 48 receives the value of Gc and/or FOL over the link 82 from the service tool 80 (computes Gc or FOL) and provides Gc to the circuit 20. The logic 48 also determines the value of K1 and KP using a two-step process (discussed in more detail hereinafter with Fig. 7). First, the proportional gain KP is varied (or tuned) with the integral gain K1 = 0 (or close to zero). The purpose of setting Kx= 0 (or close to zero) is to eliminate or minimize the integrator portion of the compensation 108,120 from contributing to the system response during this first step of the process. Other techniques may be used if desired to minimize integrator contribution, such as temporarily switching the<br>
integrator out of the system, or holding the output of the integrator to zero.<br>
A sinusoidal input signal is then provided as the reference current IqREFto me loop, where the input signal has a frequency FOL equal to the desired open loop cross-over frequency. The open loop magnitude is calculated by calculating the ratio of the signals Iq/IqERR. Kp is varied until the magnitude of the open loop gain is within a predetermined tolerance ofl (0dB).<br>
Referring to Figs. 5 and 6, if the break frequency FB is sufficiently small compared to the open loop crossover frequency FOL, the open loop response at the open loop crossover frequency resembles that of an integrator. Accordingly, the closed loop bandwidth (indicated by a point 300), i.e., the frequency at which the closed loop frequency response or gain begins to drop off or attenuate, will be substantially equal to the open loop crossover frequency FOL.<br>
Second, the integral gain K, is tuned with KP set to the value determined from the aforementioned first step. In that case, a sinusoidal input is provided as the reference current IqREF to the loop, where the input signal has a frequency FCL = 0.8 FOL, the desired closed loop bandwidth of the loop. Multipliers other than 0.8 may be used if desired based on the desired system response. K, is varied until the magnitude of the closed loop transfer function is within a predetermined tolerance of 1 (OdB).<br>
Referring to Fig. 7, more specifically, a top-level flow diagram for the first locked rotor test 252 begins at a step 302 which requests and receives the necessary parameters to perform auto-calibration, discussed hereinafter. Next, a series of steps 304 sets K1=0, KP = KP-INIT, Gc = 27tFOL and the value for IdREF, as described below. Also, the steps 304 set a variable COUNT = 0, set MODE1 = 1, and set BRK=1, which engages the brake 37 (Fig.l) and locks the rotor.<br>
The value of KP-INIT is calculated using information from the motor nameplate and/or motor data sheet. As discussed hereinbefore, it is desired for KP to be equal to the motor inductance L. As an initial value, KP-INIT is set based on an approximation of the motor transient inductance La, which is approximated based on a "base" inductance (L_BASE) of the motor, using the below equation:<br>
(Equation Removed)<br>
L_BASE comprises both the magnetizing inductance (Lm) and the transient inductance (La), and La is about 10-20% of Lm. Multipliers other than 0.1 may be used if desired. L_BASE is calculated from the motor nameplate data using the below equations:<br>
Z_BASE = (PWR_RATED)/(VLL_RATED)2<br>
L_BASE = Z_BASE/(2πHZ_RATED) where PWR_RATED is the rated motor shaft power in watts; RPM_RATED is the rated motor speed in RPM; VLL_RATED is the<br>
rated RMS line-to-line voltage in volts; and HZ_RATED is the rated frequency in hertz.<br>
The initial value of IdREF is set as follows:<br>
IdREF = 0.25 x I_BASE<br>
where I_BASE is the motor "base" current calculated from nameplate data as (PWR_RATED)/((3)½ x VLL_RATED). Other settings may be used for IdREF if desired, provided the appropriate amount of flux is generated in the motor.<br>
The values of KP-INIT and IdREF may be calculated by the logic 252 using the nameplate parameters PWR_RATED, RPM_RATED, VLL_RATED, and HZ_RATED, entered into the service tool 80 by service personnel and sent over the link 82 to the logic 48. Alternatively, the values of KP-INIT and IdREF may be calculated by service personnel and entered into the service tool 80 and sent over the link 82 to the logic 48.<br>
Next, a step 310 sets IqREF2 equal to a sinewave having a test frequency of FOL equal to the desired open loop crossover frequency, e.g., 180 to 333 Hz. Other frequencies may be used if desired. The sinusoid is generated digitally by a signal processor, such as a digital signal processor, e.g., Motorola DSP 56002 processor, with an update (or sample) rate of 5 KHz. Other hardware and/or software techniques or update rates may be used to generate the sinusoidal input signals.<br>
Next a step 312 monitors the signals IqERR and Iq on the lines 118, 116, respectively, and uses the aforementioned digital signal processor to perform a Discrete Fourier Transform (DFT) of the individual signals IqERR and Iq to obtain the magnitude of the fundamental or first harmonic of the IqERR and Iq signals (IqMAG , IqERR.MAG) to calculate the open loop gain. The first harmonic is used to calculate the open loop gain so that non-linearities in the control system do not distort the calculation. The fundamental or first harmonic component of a measured signal from a DFT, as is known, is Asin(cot) + Bcos(ωt) where co is the test frequency (2πFOL). Next a step 314 calculates the magnitude of the first harmonic by the known equation: (A2 + B2)1/2.<br>
To compute a DFT, as is known, standard sine and cosine waves of unit amplitude at the test frequency are generated within the logic 48. The measured signal (e.g., IqERR, Iq) is multiplied by the standard sinewave and the product is integrated over one period of the excitation to yield the Fourier series coefficient A of the signal. Multiplying the signal by the standard cosine and integrating yields the B coefficient. We have found that integrating over 15 periods of the input signal it is sufficient to filter out any transients in the system response. This also applies to the DFT performed for the closed loop gain, discussed hereinafter. Other numbers of periods may be used if desired. Also, other types of Fourier transforms may be used if desired, e.g., a Fast Fourier Transform (FFT), etc., provided the first harmonic of the desired signal is obtained. Further,<br>
instead of a Fourier transform, any other filtering or spectrum analysis technique may be used for determining the first harmonic of the desired signals.<br>
Next, a step 316 calculates the open loop gain GOL as the ratio of the magnitude of the current feedback signal IqMAG to the magnitude of the current loop error IqERR.MAG.<br>
Next, a step 3,18 checks whether GOL is within +/- 0.5% of 1 (i.e., +/- 0.005). Other tolerances may be used. If not, a step 320 tests whether COUNT is greater than or equal to ten, i.e., whether the loop has iterated at least ten times. If it has iterated ten times, a step 322 sets FAULT = 1 which is sent to the service tool 80 (Fig. 3) over the serial link 82 and a step 324 sets MODE1 = 0, BRK=0, and the logic exits. If the logic has iterated less than ten times, a step 326 checks if GOL is greater than one. If GOL is greater than one, KP is decremented by a predetermined amount at a step 328. If GOL is less than one, KP is incremented by a predetermined amount at a step 330. In either case, next a step 332 increments the counter COUNT by one and the logic goes to the step 310 to recalculate GOL with a new value of KP.<br>
One way to iterate KP is to use a binary search technique where the value of KP is determined by setting it equal to the average of an upper and lower bound after each test. The upper or lower bound is adjusted to reduce the search interval by a factor of two each time until the desired threshold is obtained. For example, the upper bound Kp-upper =<br>
and the lower bound Kp-lower = 0, and Kp = (Kp-upper + Kp-lower)/2. If Kp is to be increased (step 330), the lower bound is increased to Kp-lower=Kp, and if Kp is to be decreased (step 328), the upper bound is decreased to Kp-upper=Kp. Then, the next value of Kp is calculated based on the modified upper or lower bounds.<br>
Alternatively, Kp may be changed by a small amount e.g., 1%, each iteration until the desired tolerance is reached. Any other search techniques that converges within the desired time may be used if desired.<br>
If the value of GOL is within the desired predetermined tolerance in the step 3 18, the integral gain K1 is then determined based on the desired closed loop frequency response to a sinusoidal input frequency. In particular, a series of steps 340 sets COUNT=0 and KI = KI-INIT.<br>
To determine the value for Kt , the value for Kp is set to the value determined in the aforementioned first step in the process and K1 is set to an initial value KI-INIT Because it is desired for K1 to be equal to the motor resistance R, the value for KI-INIT is set to an estimated value for R of:<br>
Multipliers other than 1000 may be used to estimate<br>
Next, a step 342 sets IqREF2 equal to a sinewave having a test frequency of FCL = 0.8 x FOL equal to the desired closed loop bandwidth and IdREF is still set as before. The sinusoid is generated as described hereinbefore with the open loop test of step 310.<br>
Next a step 344 monitors the feedback current signal Iq on the lines 116 and computes the discrete Fourier transform (DFT) of the signal Iq to obtain the magnitude of the fundamental or first harmonic of the Iq signal (IqMAG) used to calculate the closed loop gain so that non-linearities in the control system do not distort the calculation, in a similar fashion to that done for the open loop gain discussed hereinbefore. The fundamental or first harmonic component of a measured signal from a DFT, as is known, is x = Asin(ωt) + Bcos(ωt) where co is the test frequency (2πFCL). Next, a step 346 calculates the magnitude of the first harmonic by the known equation: (A2 + B2)1/2. The number of integration periods for the DFT are the same as that discussed hereinbefore.<br>
Next, a step 348 calculates the closed loop gain GCL as the ratio of the magnitude of the current feedback signal IqMAG to the magnitude of the input current loop reference signal IqMAG (which was provided by the logic 48, and thus need not be measured).<br>
Next, a step 350 checks whether GOL is within +/- 6% of 1. Other tolerances may be used. If not, a step 352 tests whether COUNT is greater than or equal to ten, i.e., whether the loop has iterated at least ten times. If it has iterated ten times, a step 354 sets FAULT = 1 which is sent to the service tool 80 (Fig. 3) over the serial link 82 and a step 324 sets MODE1 = 0, BRK=0, and the logic exits. If the logic has iterated less than ten times, a step 356 checks if GCL is greater than one. If GCL is greater than one, K1 is decremented by a predetermined amount at a step<br>
360. If GCL is less than one, K1 is incremented by a predetermined amount at a step 358. In either case, next a step 362 increments the counter COUNT by one and the logic goes to the step 342 to recalculate GCL with a new value of KT.<br>
One way to iterate K1 is to use a binary search technique similar to that discussed regarding the iteration of KP hereinbefore, where the value of K1 is determined by setting it equal to the average of an upper and lower bound after each test. The upper or lower bound is adjusted to reduce the search interval by a factor of two each time until the desired threshold is obtained. For example, the upper bound Krupper = 2KI.INIT and the lower bound K,-lower = 0, and Kr = (K,-upper + Krlower)/2. If <br>
K1 is to be increased (step 358), the lower bound is increased to Kr lower=KIS and if Kr is to be decreased (step 360), the upper bound is decreased to KI-upper= K1. Then, the next value of K1 is calculated based on the modified upper or lower bounds.<br>
Alternatively, K1 may be changed by a small amount e.g., 1%, each iteration until the desired tolerance is reached. Any other search or iteration techniques that converges within the desired time may be used if desired.<br>
We have found that the binary search discussed hereinbefore for KP and K1 will converge within about eight iterations which is sufficiently accurate; however, more or less iterations may be used if desired.<br>
If GCL is within the desired tolerances in step 350, then a step 364 sets the DONE flag equal to 1 which is transmitted via the serial link 82 to the service tool 80, a step 324 sets MODE1=0, BRK=0, and the logic 252 exits.<br>
Other closed loop bandwidths and open loop cross-over frequencies and other input frequencies may be used if desired, e.g., the input frequency may be equal to FOL for both calculations if desired. Second Locked Rotor Test:<br>
Referring to Fig. 8, a known equivalent circuit 90 of an induction motor is similar to that described in "Vector Control and Dynamics of AC Drives", Novotny and Lipo, Oxford 1996, Chapter 5. Fig. 8 is a per-phase equivalent circuit for AC steady state operation where the current II and voltage VI are phasor quantities. The circuit 90 comprises a resistor Rs in series with an equivalent "transient" inductor La in series with a rotor impedance ZR which comprises a "magnetizing' inductance L in parallel with an equivalent resistance R2/S. Where: Rs (or R,) = stator winding resistance Ls = stator winding inductance Lr = rotor winding inductance Lm = mutual inductance Rr = the rotor winding resistance Lσ = Ls - Lm2/Lr = transient inductance L = Lm2/Lr = magnetizing inductance<br>
ωE = electrical frequency of the input current I,<br>
ωR= motor output rotational speed in radians per second referred to an<br>
electrical reference frame<br>
S = slip = (ωE - ωR)/ ωE<br>
ωs= slip frequency =ωE - ωR= (1/τR)(Iq/Id)<br>
where TR= rotor time constant Iq= q-axis (or torque) current, and Id =<br>
d-axis (or magnetizing) current<br>
R2 = (Lm2/Lr2)*Rr<br>
Also, the rotor time constant TR and motor torque constant KT* are related to the parameters of the circuit 90 as follows:<br>
τR = Lr/Rr = L/R2<br>
KT* = (3/2)(P/2) L Id = torque/current where P = number of poles.<br>
Referring to Fig. 9, the circuit 92 is an equivalent to the circuit 90 of Fig. 8 with the rotor impedance ZR transformed into an equivalent series circuit impedance having a real part Real(ZR) and an imaginary part Imag(ZR) equal to ωLx. The equivalent circuit 92 with the transformation of ZR is useful for determining the rotor time constant τR (discussed more hereinafter).<br>
Referring now to Fig. 10, a top level flow chart for the second locked rotor test 258 begins at a step 402 which requests and receives motor parameters from the service tool 80 over the link 82 (Fig. 1), which are entered by service personnel. The motor parameters received are: the<br>
rated motor shaft power in watts (PWR_RATED); the rated motor speed in rpm (RPM_RATED); the rated rms line-to-line voltage in volts (VLL_RATED); the rated frequency in hertz (HZ_RATED); and number of poles (POLES), all of which may be obtained from the motor nameplate data.<br>
Then, a step 403 sets MODE1 = 1, BRK = 1 to cause the brake 37 (Fig.l) to lock the rotor, and IdREF2 = 0 amps. For each of the tests described herein, the rotor remains locked (rotor speed ωR = 0) and IdREF2 = 0 amps. When ωR = 0 and IdREF2 = 0, the slip S=l, and the motor current I, is equal to the q-axis current Iq and the motor voltage V, is equal to the q-axis voltage Vq. When Iq=0, the motor is operated in single phase operation, in accordance with the circuits of Figs. 8,9.<br>
Next, a step 404 measures the transient inductance LΣ, by providing a sinusoidal current signal into the q-axis of the reference current IqREF2 on the line 17 (Fig. 1) at a frequency FHIGH high enough such that the motor impedance will be dominated by the transient inductance La, e.g., 31.25 Hertz. Other frequencies may be used if desired, e.g., greater than 30 Hz. The sinewave input signal is generated digitally by a signal processor, such as a digital signal processor, e.g., a Motorola DSP 56002 processor, with an update (or sample) rate of 5KHz. Other hardware and/or software techniques or update rates may be used to generate the sinusoidal input signals.<br>
The step 404 reads the q-axis feedback current Iq and the q-axis output voltage Vq (equal to the motor current I1 and motor voltage Vl, respectively, as discussed hereinbefore). Next, the step 404 uses the aforementioned digital signal processor to perform a Discrete Fourier Transform (DFT), similar to that discussed hereinbefore, of Iq and Vq to determine the first harmonic Fourier coefficients. The fundamental or first harmonic component of a measured signal from a DFT is A sin(ωt) + B cos(ωt), where ω=2πf is the input frequency (in rad/sec). The first harmonic is used to calculate the impedance primarily so that non-linearities in the system do not distort the calculation.<br>
To compute a DFT, as is known, standard sine and cosine waves of unit amplitude at the test frequency are generated within the logic 48. The measured signal (Iq,Vq) is multiplied by the standard sinewave and the product is integrated over one period of the excitation to yield the Fourier series coefficient A of the signal. Multiplying the signal by the standard cosine and integrating yields the B coefficient. We have found that integrating over 15 periods of the input signal it is sufficient to filter out any transients in the system response. Other numbers of periods may be used if desired. Also, for any DFT discussed herein, other types of Fourier transforms may be used if desired, e.g., a Fast Fourier Transform (FFT), etc., provided the first harmonic of the desired signal is obtained. Further, instead of a Fourier transform, any other filtering or spectrum<br>
analysis technique may be used for determining the first harmonic of the desired signals.<br>
Then, the step 404 computes the motor impedance ZMby calculating the ratio of voltage to current (V1/I1 = Vq/Iq) using the first harmonic components of voltage and current computed above. The step 404 then computes the real and imaginary parts of ZM from the Fourier coefficients. The imaginary part of the motor impedance ZMat FHIGH Hertz is dominated by the transient inductance term ωLa. Thus, the transient inductance La is the transient reactance (or imaginary part of ZM) with the input frequency equal to FHIGH Hz, divided by the frequency co in radians/sec (2π FHIGH), or :<br>
Lσ = Imag (ZM) @ FHIGH Hz /(2πFHIGH)<br>
Next, an optional step 406 measures the total resistance of the circuit impedance (RTOT = Rs+R2),i.e., the sum of the stator and rotor resistances, as the real part of the motor impedance ZM determined in step 404. Thus:<br>
RTOT = Real(Zm) @ FHIGH<br>
In particular, at the relatively high frequency FHIGH used in step 404, the inductance L in the circuit 90 is large and the real part of ZM will be equal to RTOT. The value of RTOT is saved for later use to calculate Rs (see step 412).<br>
Next, a step 408 measures the rotor time constant τR as follows. The step 408 produces a progression of low frequency sinusoidal input<br>
q-axis reference currents IqREF2 from 0.1 to 8.0 Hertz in increments defined by a search algorithm, discussed hereinafter. The sinewave input signal is generated digitally as discussed hereinbefore with step 404. At each frequency, the motor current Iq and voltage Vq (equal to the motor current I, and voltage V1,, respectively, as discussed hereinbefore) are measured and a DFT of the current I1 and the motor voltage V1, signals are computed separately. The fundamental or first harmonic Fourier coefficients are obtained as discussed hereinbefore with step 404.<br>
Then, the step 408 computes the motor impedance ZM at each frequency by calculating the ratio of voltage to current (V1/I1). The step 408 then calculates the real and imaginary parts of the ZM from the Fourier coefficients. Then, the step 408 calculates the imaginary part of the rotor impedance Imag(ZR) =  ωLx by subtracting the transient reactance (ωLσ) from the imaginary part of the motor impedance ZM, where Lσ was previously calculated in step 404 and ω is the input frequency, as follows:<br>
Imag(ZR) =  ωLx = Imag(ZM) - ωLσ<br>
Referring to Fig. 11, a curve 450 shows the imaginary part of the motor impedance Imag(ZM) = ω(Lσ + Lx) and a curve 452 shows the imaginary part of the rotor impedance Imag(ZR) =  ωLx. The frequency<br>
 ω (radians/second) at which the maximum 454 of the curve 452 occurs is the inverse of the rotor time constant, i.e., ω =1/τR A known search algorithm, e.g., a "golden section line search" algorithm, varies the input<br>
frequency and determines the frequency Fpeak at which the maximum value of  ωLx occurs. The type of search algorithm used is not critical to the present invention, and any search algorithm that varies an input parameter and determines the maximum value of an output parameter may be used. The rotor time constant τR is then calculated as follows:<br>
τR= l/ωpeak= l/(2πFpeak)<br>
Next a step 410 calculates the magnetizing inductance L In particular, at the frequency of rotor time constant (ω = I/τR), which is also the break frequency of the motor transfer function, the real and imaginary parts of the rotor impedance ZR are equal to each other, i.e.,  ωLx = Rx . Also, at this same frequency, it can be shown (below) that the  ωLx is also equal to ½ωL (the magnetizing reactance). In particular, the rotor impedance ZR is equal to jωL in parallel with R2, as shown below:<br>
ZR = jωLR2/ (R2 + jωL)<br>
Multiplying the numerator and denominator by the complex conjugate of the denominator (R2 - jωL), gives<br>
ZR = ω2L2R2/(R22 + ω2L2) + j ωL R22/(R22 + ω2L2) Eq. 4 Which has the form of a series combination of impedances, or a real and imaginary part as indicated below:<br>
ZR=   Rx +   jωLx<br>
ZR = Real +   j Imaginary<br>
At the peak 454 of the curve 452 of lmag(Z), the real and imaginary parts are equal, which gives:<br>
ω2L2 R2/(R22 + ω2L2) = ωL R22/(R22 + ω2L2)     Eq. 5 Simplifying Eq. 5, gives:<br>
ω2L2) = R2<br>
Substituting R2 = ωL into the Imaginary part of ZR, and setting equal to  ωLx, gives:<br>
Imag(ZR) = (ωL)(ω2L2)/(ω2L2 + ω2L2 =  ωLx   Eq. 6 Simplifying Eq. 6, gives:<br>
 ωLx = ωL/2	Eq. 7<br>
Thus, the magnetizing inductance L is calculated as follows:<br>
L = 2Imag(ZR)/ω     @ ω = I/τR<br>
Next, an optional step 412 calculates the stator resistance Rs by first calculating the value of R2. It can be shown (below) that the real part of the rotor impedance Real(Zy) at ω = I/ TR is equal to R2/2. In particular, the real part of Eq. 4 is:<br>
Real(ZR) = Rx =L2R2/(R22 + ω 2L2) Substituting R2=ωL, and simplifying, gives:<br>
Rx = R2/2 Thus,<br>
R2 = 2Real(ZR) @ ω = I/TR<br>
Alternatively, R2may be calculated using the equation:<br>
R2 = L/TR<br>
where L and τR were previously calculated in steps 404,408, respectively. In either case, the stator resistance Rs is then determined by subtracting R2 from the total resistance (RTOT= RS + R2) calculated in step 406. Thus,<br>
RS = RTOT ' R2 If the value for Rs for the motor is already known, e.g., from the data<br>
sheet, it may be provided to the" control over the link 82 and then Rs may also be range checked in the step 412 to ensure it is within a predetermined percentage of the expected value. If Rs is not within the desired range, the step 412 sets a fault flag FAULT 1 = 1. Alternatively, the value of Rs may be calculated and provided to the service tool to help service personnel determine the type of motor installed in the system.<br>
Next, a step 414 uses L,τR, and the input parameters PWR_RATED, RPM_RATED, VLL_RATED, HZ_RATED, and POLES, obtained in the step 402, to simulate motor parameters and to iterate and calculate the rated magnetizing current IdRATED and the torque constant KT*, as shown in Fig. 7.<br>
Referring to Fig. 12, the simulated motor parameters are indicated by an asterisk (*) to avoid confusion with actual measured motor parameters discussed hereinbefore. In particular, a step 500 calculates the rated rotational speed of the motor referred to the electrical reference frame ωRRATED. Next, a step 502 converts rated line-to-line voltage<br>
(VLL_RATED) to rated line-to-neutral voltage (or per-phase voltage) Vph_RATED. Next, a step 503 calculates the rated torque T_RATED based on rated power and rated RPM. Then, a step 504 calculates the stator inductance Ls as the sum of the transient inductance La and the magnetizing L. Next, a step 506 calculates an initial value for simulated d-axis current Id* based on a first order approximation of Id using rated voltage and speed. Next, a step 508 sets a variable COUNT equal to zero.<br>
Next, a series of steps 510 - 522 calculates KT* and a simulated motor voltage VM* using various simulated motor parameters based on the value of L calculated in step 410 (Fig. 10), the parameters calculated in steps 500-508 above, and using known relationships for a field-oriented motor controller, some of which are discussed hereinbefore. In particular, a step 510 calculates the torque constant KT* based on L calculated in step 410 (Fig. 10) and the current value of the magnetizing current Id*. Next, a step 512 calculates the torque current Iq*. Next, a step 514 calculates a simulated slip frequency ωs* which is used in a next step 516 to calculate a simulated electrical current frequency ωE* which is equal to the rotational frequency (or speed) of the motor (emulated as the rated speed) ωRRATED plus the slip frequency ωs*.<br>
Next, a step 518 calculates a simulated q-axis output voltage Vq* based on the magnetizing current Id* and a step 520 calculates a<br>
simulated d-axis output voltage Vd* based on the torque current Iq*. Then, a step 522 calculates a simulated vector sum total motor voltage Vm* equal to the square root of the sum of the squares of the d-axis and q-axis output voltages Vd*,Vq*, respectively.<br>
Next, a step 524 calculates a Ratio parameter equal to the ratio of the rated phase voltage Vph_RATED to the simulated per-phase motor voltage Vm*. The logic iterates until the Ratio goes to 1 within the desired tolerance, e.g., 0.001. When the ratio equals 1 the value of Id* will produce the rated voltage at the rated RPM and rated torque.<br>
Next, a step 526 calculates a next value for Id* equal to the value of the Ratio times the current value of Id*. Next, a step 528 checks whether Ratio is within a predetermined tolerance of 1, e.g., 0.001. If it is not within the desired tolerance, a step 530 checks whether COUNT is greater than or equal to ten (i.e., whether the loop has iterated at least ten times). If the loop has iterated at least ten times, a FAULT flag is set equal to 1 at a step 532 and output to the service tool 80 over the link 82 (Fig. 1) and the logic is exited. If it has iterated less than ten times, a step 534 increments COUNT by one and the logic 414 goes the step 510 to iterate again.<br>
If Ratio is within the desired tolerance in step 528, the logic is deemed to have converged and at convergence the values of Id* and Iq* are equal to the rated d-axis current IdRATED and the rated q-axis current IqRATED, respectively. Accordingly, a step 540 sets the d-axis current<br>
reference IdREF equal to Id* which is equal to IdRATED and a step 544 sets VATED equal to Iq*. Then the logic 414 exits and returns to the logic 258 of Fig. 10.<br>
Referring to Fig. 10, next, a step 416 determines whether an error has been detected in any of the above steps 402 - 414 (i.e., if FAULT 1=1). If a fault has been detected, a step 418 sets FAULT = 1 which is sent to the service tool 80 (Fig. 1) over the serial link 82 and a step 420 sets MODE1 = 0, BRK=0, and the logic exits. If a fault has not occurred, a step 422 sets the DONE flag equal to 1 which is transmitted via the serial link 82 to the service tool 80. Next, some or all of the motor parameters τR, KT*, IdRATED, La, L, Rs, and IqRATED are transmitted via the serial link 82 to the service tool 80 in a step 424. The service tool 80 displays the parameters for use by the service personnel. Next, the step 420 sets MODE 1=0, BRK=0, and the logic 258 exits. First Running Rotor Test:<br>
Referring to Figs. 14 and 15, coupled circuit diagrams 180,182, for q-axis and d-axis variables, respectively, for a field-oriented driven motor, have circuit parameters defined as follows: Id = d-axis (or magnetizing) current; Iq = q-axis (or torque) current; Vd = d-axis voltage; Vq = q-axis voltage; Rj = stator resistance;<br>
Lls = stator leakage inductance; Llr = rotor leakage inductance; Lm = mutual inductance;<br>
λds = d-axis stator flux; λdr = d-axis rotor flux;<br>
λs = q-axis stator flux; λqr = q-axis rotor flux;<br>
ωS = slip frequency; ωE= electrical frequency of the motor currents; and<br>
R2 = rotor resistance.<br>
For field orientation conditions to exist, as is known, the induction motor coupled circuit diagrams of Figs. 14 and 15 require that λqr= 0, λdr = Lmld, λqs = Lσlq and λds = Lsld, where Ls = Lm + Lls, and where La is the transient inductance of the motor.<br>
The variable frequency drive described herein operates with a constant magnetizing current. All current and voltage motor parameters designated herein by a subscript "r" or "R" are rotor parameters, and all other current and voltage motor parameters, unless described otherwise, are stator parameters.<br>
Also, in a field oriented drive, as is known, the controller reference frame is oriented so that the d-axis is aligned with the rotor flux. Referring to Fig. 15, in steady state, where the transients have stabilized (i.e., dld/dt = 0 and dlq/dt = 0), the voltage across the inductors Lm, Lls is Ov. Thus, the equation for the d-axis stator voltage Vd for a field-oriented drive is defined as:<br>
Vd = R,Id - ωELaIq	Eq. 8<br>
where the parameters of the Eq. 8 are defined above with Fig. 4.<br>
It is also known that ωE= ωR + ωs and ωs == lq/(ldi), where ωR is the rotational speed of the rotor. Substituting this for ωE in Eq. 8 yields:<br>
Vd = R,Id - (ΩR + Iq/(IdiR))LaIq	Eq. 9<br>
Moving the right side of Eq. 9 to the left side, we define a new parameter, VdERR, as:<br>
VdERR = Vd - R,Id + (ΩR + Iq/(IdτR))LσIq	Eq. 10<br>
A zero value of the VdERR indicates that the drive is field oriented, i.e., that Eq. 8 is satisfied, when motor core losses can be neglected.<br>
However, we have found that two factors may introduce errors into the calculation of VdERR. The first factor is errors in the stator resistance estimate (R1). In particular, we have found that the stator resistance R1 is difficult to measure in the drive due to the low signal amplitudes involved and that off-line tests of stator resistance do not accurately predict the d-axis voltage during drive operation. While this error does not impact the current regulator closed loop operation of the indirect field oriented drive (which regulates the current to achieve desired performance independent of the value of Rl), it does impact the accuracy of the calculation of VdERR.<br>
The second factor is core loss Lc in the induction motor, which is not modeled in the standard induction motor model of Figs. 14 and 15. The core loss Lc at constant motor flux is approximately proportional to motor speed and is manifested as a component of voltage in the d-axis of the motor (Vd). Also, core loss must be supplied electrically by the stator voltage and current, even when there is no torque, i.e., when the<br>
q-axis current Iq is zero. Thus, the electrical power input to the motor to supply the core loss appears as a positive component of Vd.<br>
More specifically, referring to Fig. 19, experiments on induction motors have shown, as is known, that the core loss component of Vd can be more than double the IR voltage drop component at rated speed. Fig. 19 shows core loss increases with speed by a plot of Vd vs. motor speed for a 32 kW 4-pole induction motor running at no load. In particular, at no load, Iq=0, and plugging Iq=0 into Eq. 8, gives Vd = R1Id, where Id is a constant. Thus, Vd should be a constant over motor speed. However, from the graph of Fig. 19, it can be seen that:<br>
Vd = R1Id + Lc(ωE) where core loss Lc is a function of motor speed ωE.<br>
Thus, rather than computing the VdERR signal, the first running rotor test 262 may instead compute a loss component VDX equal to the stator I-R voltage drop (R1Id) plus the core loss (Lc) which gives the following equation, derived from Eq. 10 and adding the core loss Lc:<br>
VDX = Vd + ωELσIq = R1Id + Lc	Eq. 11<br>
where Id, Iq, and Vd are stator parameters. Also, ωE= ωR + Iq/(IdτR), as is known, which, when substituted into Eq. 4, gives:<br>
VDX = Vd + (ωR+Iq/(IdτR)) Lσlq	Eq. 12<br>
If the rotor time constant τR is correct, two measurements made at the same speed but at different loads (i.e., different values of Iq) should yield substantially equal values of VDX.<br>
We have also found that the sign of VDX indicates whether the rotor time constant is low or high. In particular, VDX will be positive when the rotor time constant τR parameter is too low and negative when τR is too high, regardless of torque or direction and regardless of the IR drop and core loss.<br>
The first running rotor test 262 makes an lip run and a down run of the elevator with an empty car (using normal motion and speed profiles), thereby achieving two different load conditions. The value of VDX is computed and filtered to reduce noise (as a signal XDF) during the up run and the down run and the values of τR and IdREF (and thus Id) are adjusted until the values of XDF for the up and down runs are equal, or within a predetermined tolerance (discussed more hereinafter). The difference in the load conditions for up and down runs exists because the counterweight 34 (Fig. 1) has a weight equal to the empty car weight plus 40-50% of the rated load for the car as discussed hereinbefore.<br>
Once a value for τR has been obtained from the above search, the value of magnetizing current reference IdREF (which results in a corresponding change to the magnetizing current Id) is adjusted to achieve the correct value of motor voltage under loaded conditions (i.e., during a down run with an empty car). A change in magnetizing current Id will change the flux level and therefore the saturation of the magnetizing characteristics of the motor and a change in the flux level will change the required torque current. As a result, the rotor time<br>
constant τR may change. Thus, the rotor time constant τR tuning described above is repeated using the new adjusted value of magnetizing current IdREF, after which, the motor voltage is checked and the magnetizing current IdREF is adjusted again, if necessary, to adjust the motor voltage within a predetermined tolerance of the rated value.<br>
Referring to Fig. 13, more specifically, the first running rotor test portion 262 of the auto-calibration logic 48 comprises VDX calculation logic 50 which receives the necessary parameters to compute VDX using Eq. 11. VDX is calculated only when the speed parameter ωR is greater than 50% of the full or rated or contract speed (RPM_Duty), which provides a windowing function to allow the calculation to occur when the voltage and current measurements are the most accurate (i.e., at or near rated speed). Such a windowing function is not required but provides more accurate calculations. Also, other windowing or signal scaling techniques may be used to avoid erroneous signals. For example, VDX may be multiplied by the motor speed ωR or ωE which would weigh the VDX signal more heavily at high speeds where the measurements are more accurate and the motor is at rated speed.<br>
The value of VDX is provided on a line 52 to a low pass filter 62 having a break frequency at 10 Hz to reduce measurement noise. Other break frequencies for the filter 62 may be used if desired. The low pass filter 62 provides a filtered signal XDF on a line 64 to τR, IdREF calculation logic 66. Other types of filters may be used if desired.<br>
The logic 66 provides the constant La to the VDX calculation logic 50 on a line 68. The logic 66 computes the rotor time constant τR which is provided on the line 144 to the current regulator/motor drive circuit 20 and to the VDX calculation logic 50. The logic 66 also computes IdREF which is provided on a line 76 to the current regulator/motor drive circuit 20.<br>
The logic 66 also provides MODE and FLRCMD signals on lines 71,72, respectively, to the motion control logic 10. The MODE flag causes the motion logic 10 to accept floor commands from the FLRCMD signal on the line 72.<br>
The FLRCMD signal commands the motion controller 10 to perform an elevator run in a commanded direction for a commanded number of floors (or to a particular destination floor) using a standard predetermined speed profile for ωp (Fig. 18) in the motor control 10, discussed hereinafter. The motion control logic 10 also provides a motor controller fault signal MCFAULT on a line 73 to the logic 66 to indicate if a fault has occurred during an elevator run. During the elevator run, the elevator is run through a normal speed profile using an empty car with the normal safety features enabled.<br>
Referring to Fig. 18, a standard speed profile 600 for ωREF provided by the motion control logic 10 has a ramp up region A, a constant speed region B (where the motor runs at the duty or contract speed for a given application), and a ramp down region C. The duration of the constant<br>
speed portion B is based on the number of floors (or destination floor) commanded by the FLRCMD signal. Whenever an up or down elevator run is commanded herein, the number of floors commanded are such that the constant speed portion B of the elevator run has a duration long enough to allow transients in the system to stabilize, e.g., at least about 3 seconds, which corresponds to about 3 or 4 floors, depending on the building floor height. The profile 600 is merely for illustration purposes and other ramp up/down rates, duty speeds, and overall profiles may be used, provided there is a constant speed portion having a duration long enough to allow system transients to stabilize. The number of floors or destination floor may be provided by the service tool 80 over the link 82.<br>
The calculation logic 66 also communicates with a service tool 80 over a serial link 82. Also, the logic 66 receives motor parameters necessary to perform the first running rotor test 262, such as Lc, and initial values of τR (τRINIT) and d-axis current loop reference IdREF, as discussed more hereinafter. The logic 66 provides a DONE signal and a FAULT signal to the service tool 80 over the link 82. The DONE signal indicates when the first running rotor test 262 is complete and the FAULT signal indicates when a fault has been detected during the test 262.<br>
Referring to Fig. 16, a top-level flow diagram for the τR, calculation logic 66 begins at a step 602 which requests and receives the necessary parameters to perform the first running rotor test 262, such as , IdINIT, τR.INIT from the service tool 80. Some or all of the parameters<br>
Lσ, TR.JNH-, IdINIT may be set based on the values of Rl5 Lσ, TR, IdRATED, respectively, previously calculated by the second locked rotor test 258, discussed hereinbefore.<br>
Alternatively, some or all of the parameters Lσ, TRINIT, IdINIT may be approximated from motor data sheet parameters, as follows: Lσ = Ls - (Lm/Lr)<br>
MINI! = 'NO-LOAD where Ls is the stator winding inductance, Lr is the rotor winding<br>
inductance, Lm is the motor mutual inductance, Rr is the rotor winding resistance, and INO.LOAD  Is me no load current and where Ls, Lm, Lr, Rr, and INO-LAD are all obtained from the motor data sheet. In that case, the service personnel may calculate the parameters Lσ, provide them to the logic 66 by the service tool 80. Alternatively, the service personnel may provide the parameters Ls, Lm, Lr, Rr, and INO.LOAD to the logic 66 by the service tool 80, and the logic 66 calculates the parameters Lσ, TRINIT, IdINIT at the step 602. Other techniques may be used to obtain the initial parameters necessary to carry out the first running rotor test 262.<br>
It should be understood by those skilled in the art of motors that INO-LOAD is equal to the total motor current when the motor is under no load or torque, i.e., Iq=0. Thus, INO.LOAD is equal to the rated d-axis (or magnetizing) current IdRATED-<br>
Next, a series of steps 606 sets TR to the initial value τTRNT , sets IdREF to the initial value IdINIT, sets MODE=1 and a variable COUNT=1. Then, a step 612 calculates a value for τR with Id at the current setting of IdREF, discussed more hereinafter with Fig. 6. Next, a step 214 checks whether a fault has been detected in the step 212. If so, the logic 66 sets MODE=0 at a step 615 and exits.<br>
If a fault has not been detected, the logic 66 performs a series of steps to check the motor voltage and, if needed, adjusts the magnetizing current Id. In particular, an optional step 616 runs the elevator in the up direction to get the elevator above the ground floor, if needed. Then, a step 618 runs the elevator in the down direction to take measurements. While the elevator is running in the down-direction, a step 620 saves the values of Vd and Vq when the speed ΩR is at the end of (or during) the constant speed portion of the speed profile, to achieve steady state voltage measurement which cannot be obtained while the speed and/or torque are changing. Instead of running the elevator down to get Vm, the elevator may be run up, provided the motor is "pulling" a load, i.e., the motor is operating in a "motoring" operation as opposed to a regenerating or a braking operation, as this is the condition under which the drive is supplying power to the motor. To achieve this condition for an up run with the system shown in Fig. 1, the load in the car plus the car weight must be heavier than the counterweight.<br>
Then, a step 622 calculates the measured total motor voltage using the vector sum equation: VM = (Vd2 + Vq2)1/2. The steady state voltage Vm during the constant speed portion of the run should approximately equal the rated line-to-line voltage (VLL_RATED) adjusted for differences between the nameplate rated speed in rpm (RPM_RATED) and the maximum (or contract or duty) speed in rpm of the speed profile for that building application (RPM_DUTY). Because the motor is operated with an empty car during the auto-calibration procedure, the motor voltage during an empty car down run will be slightly lower than the full car up run voltage. Therefore, the target voltage VT for empty car down operation is set to about 98% of the adjusted nameplate voltage. Thus, the target voltage VT is calculated at a step 623 by the equation:<br>
VT = (K x VLL_RATED x RPM_DUTY)/RPM_RATED where K is a predetermined percentage, e.g., 98%, VLL_RATED is the rated line-to-line voltage and RPM_RATED is the rated speed in rpm, both from the motor nameplate data, and RPM_DUTY is the duty or contract or maximum speed of the speed profile for that building application.   The needed parameters may be provided by the service personnel from the service tool 80 over the link 82. Other percentages for the constant K may be used if desired.<br>
Next, a step 624 tests whether the motor voltage VM is within 2% of the target voltage VT. If not within 2%, a step 626 checks whether the<br>
loop has iterated at least five times. Typically, recalculation of IdREF is repeated approximately twice to get the magnetizing current to converge to the correct value. If it has iterated five times there is a problem with the system and a step 628 sets FAULT = 1 which is sent to the service tool 80 (Fig. 1) over the serial link 82 and a step 615 sets MODE = 0 and the logic exits. If it has iterated less than five times, a step 630 adjusts IdREF (and thus Id) by the equation: IdREF = IdREF (VT/VM). Next, a step 632 increments the COUNT by 1 and the logic 66 proceeds to the step 612 to iterate again. If VM is within 2% of VTin the step 624, the algorithm is deemed to have converged and a step 634 sets DONE = 1 which is sent to the service tool 80 via the link 82 and a step 615 sets MODE = 0 and the logic 66 exits and returns to the main logic 48 (Fig. 3).<br>
Referring to Fig. 17, the step 612 of Fig. 16, which calculates τR begins by setting a counter COUNT 1 = 0 at a step 700. Next, a step 702 runs the elevator in the up direction using the standard speed profile (Fig. 18) discussed hereinbefore. During the up run of the elevator, a step 704 saves the values of XDF as XDF(l) when the speed ΩR is at the end of (or during) the constant speed portion of the speed profile.<br>
Next, a step 706 runs the elevator in the down direction using the standard speed profile (Fig. 18) discussed hereinbefore. During the down run of the elevator, a step 708 saves the values of XDF as XDF(2) when ΩR is at the end of (or during) the constant speed portion of the speed profile of the run. Next, a step 710 calculates a filtered up/down<br>
difference (FUDD) equal to XDF(l) -XDF(2). The FUDD value for the run will indicate whether the τR is too high (FUDD &gt; 0) or too low (FUDD 
Next, a step 712 tests whether the sign (or polarity) of FUDD has changed from the FUDD for the previous up/down run of the elevator. If the sign of FUDD has not changed, a step 714 tests whether the sign of FUDD is positive. If FUDD is positive, τR is high and a step 716 decrements τR by a predetermined amount, e.g., 10%. If FUDD is not positive, τR is low and a step 718 increments τRby a predetermined amount, e.g. 10%. Other increment and/or decrement amounts may be used if desired.<br>
Then, a step 720 tests whether the loop has iterated at least ten times (i.e., whether COUNT is greater than or equal to ten). If it has iterated at least ten times, a step 722 sets FAULT = 1 which is transmitted via the serial link 82 to the service tool 80, and the logic 612 exits and returns to the logic 66 of Fig. 16. If it has iterated less than ten times, a step 724 increments COUNT 1 by 1 and the logic 612 proceeds to perform another up/down run of the elevator starting at the step 702. If FUDD has changed sign in the step 712, then a step 726 linearly interpolates between the positive and negative FUDD values and the corresponding τR values to find a New τR value where FUDD crosses through zero, and a step 728 sets τR to the New τR and the logic 612 returns to the logic 66.<br>
Other search techniques may be used if desired to iterate to the correct value of τR. An alternative search algorithm for τR is to use a binary type search where the search range is narrowed in successive runs until the change in τR or FUDD is within a predetermined tolerance.<br>
Also, the logic 66,612 monitors for a stop command (not shown) received by the service tool 80 over the link 82. If a stop command is received the logic 66,612 aborts the remainder of the procedure, goes to the step 615 and exits.<br>
The order of direction for the up-down elevator is run is not critical to the present invention, e.g., the elevator may be run down in the step 702 and up in the step 706 (Fig. 17). However, typically, service personnel will run the elevator to the ground or first floor to begin service or calibration. In that case, running the elevator up first may be necessary to provide a run which has a long enough duration, as discussed hereinbefore with the standard profile.<br>
Referring to Fig. 20, the curve 752 of XDF(l) for the elevator up un and the curve 750 of XDF(2) for the down run is shown as well as a curve 754 showing corresponding values of the FUDD variable. XDF(1),(2) values and the FUDD value are plotted against the rotor time constant τR parameter for measurements made on a 2.0 meter per second geared hoistway. The curve 754 of FUDD is a smoothly varying, monotonically increasing curve with a well-defined zero-crossing at a point 756 which clearly indicates the correct value of the rotor time<br>
constant. The step 612 in the logic 66 calculates the value of τR<br>
 corresponding to where FUDD crosses through zero shown as the point 756 on the FUDD curve 754.<br>
While an empty car may be the easiest condition to obtain, the invention will also work at full load or partial load, provided a net load imbalance is achieved between the car and the counterweight. However, for a load condition (such as full load) which causes a net load imbalance such that the car plus its load is heavier than the counterweight, the slopes of the graph of Fig. 20 would change, and the search logic would change correspondingly.<br>
Instead of using the filter 62 (Fig. 13), the signal VDX may be sampled directly by the logic 66 without a filter. In that case, the logic 612 would sample the value of VDX at the end of (or during) the constant speed portion of the run in steps 704,708 and VDX would replace XDF where ever it is referenced herein. Alternatively, instead or in addition to filtering VDX, the input signals to Eq. 12 for VDX may be filtered. Alternatively, the VDX calculation logic 50 may calculate VDX only when the motor speed is above a certain speed or has been at duty speed for a predetermined period of time. Second Running Rotor Test:<br>
Referring to Fig. 21, the second running rotor test portion 266 of the auto-calibration logic 48 comprises model logic 850 which models the transfer function of the desired closed outer loop transfer function of<br>
the motor controller and plant (as discussed hereinafter with Figs. 22-24). The logic 850 comprises a summer 852 which receives ωREF on the line 12 at the positive input of the summer 852 and receives an estimated speed value W* on a line 854 at a negative input of the summer 852. The output of the summer 852 is fed to an integrator 853 (G/s) with a gain G.<br>
The output of the logic 850 is the model (or estimated) speed signal W* provided on the line 854 to a negative input of a summer 855. The speed feedback signal ωR (or ωFB) from the motor 24 on the line 36 is fed to the positive input of the summer 855. The output of the summer 855 is a model reference error signal WMRE on a line 856 indicative of the difference between the actual motor speed ωR and the model motor speed W* from the model logic 850. The signal WMRE is fed to a multiplier 857. The speed reference signal ωREF on the line 12 is fed to an Absolute Value Circuit (ABS) 861 which provides an absolute value signal WABS on a line 862 indicative of the absolute value of ωREF which is fed to the multiplier 857. The multiplier 857 multiplies WMRE by the absolute value of the speed reference signal ωREF on the line 862.<br>
The output of the multiplier 857 is provided on a line 858 to a multiplier 859, which multiplies the signal on the line 858 by a Pass signal on a line 860. The purpose of the multipliers 857,859 is discussed hereinafter. The polarity of the summer 855 inputs may be reversed.<br>
The absolute value signal WABS on the line 862 is also fed to a comparator 863 which provides the Pass signal. When the signal WABS is greater than one half of the full (or contract or duty) running speed of the motor RPM_Duty, e.g., RPM_Duty = 700 rpm, the output signal Pass on the line 860 is one. Conversely, if the speed signal WABS is less than half of the full speed RPM_Duty, the output signal Pass from the comparator 863 is zero. The full speed RPM_Duty depends on the target application and may be 700 rpm, 1400 rpm, or other speeds as appropriate. The value for RPM_Duty may be provided by service personnel over the link 82 from the service tool 80.<br>
The output of the multiplier 859 is a signal DX on a line 864. When Pass equals one, the signal DX is equal to the signal on the line 858 and when the Pass signal equals zero, DX equals zero. The signal DX on the line 864 is fed to an integrator 865 which provides an output signal X on a line 867 to gain calculation logic 866. The logic 866 contains known electronics and/or software capable of performing the functions described herein (discussed more hereinafter with Fig. 25).<br>
Also, the gain calculation logic 866 provides an integrator reset signal on a line 870 to the integrator 865. The logic 866 also provides the MODE signal and the floor command signal FLRCMD on the lines 71,72, respectively, to the motion controller 10. The MODE signal causes the motion controller 10 to accept floor commands from the FLRCMD signal on the line 72.<br>
The FLRCMD signal commands the motion controller 10 to perform an elevator run in a commanded direction for a commanded number of floors time (or to a particular floor) which corresponds to running the elevator for a predetermined time using a standard predetermined speed profile in the motor control 10, discussed more hereinafter. The motion control logic 10 also provides a motor controller fault signal MCFAULT on a line 73 to the logic 866 to indicate if a fault has occurred during an elevator run. The logic 866 also provides an estimated value of J* and KT* on the lines 74 to the speed loop compensation logic 16 of the motor controller 14.<br>
The calculation logic 866 also communicates with the service tool 80 over the serial link 82. Also, the logic 866 receives parameters necessary for the second running rotor test 266 to compute the values of J* and KT* (discussed more hereinafter). The logic 866 provides a DONE signal and a FAULT signal to the service tool 80 over the link 82. The DONE signal indicates when the second running rotor test 266 has completed without any faults and the FAULT signal indicates when a fault has been detected during the test 266.<br>
The logic 866 monitors the signal X on the line 867 and after each elevator run. If the value of X is not within a predetermined threshold, it calculates a new value for J* and commands another elevator up/down run. The logic 866 iterates the value of J* until the value is within<br>
predetermined tolerance and thereby obtains a tuned system, discussed more hereinafter.<br>
Referring to Fig. 22, a control system block diagram equivalent diagram of a speed control loop comprising the motor controller 14, the motor 24 and the elevator system components connected to the motor 24 (Figs. 1 and 21), are shown. Various portions of the control system of Fig. 22 may be analogized to the portions of the schematic block diagrams of Figs. 1 and 21. In particular, the control system of Fig. 22 comprises the speed reference signal ωREF on a line 910 (analogous to the line 12 of Fig. 1) from the motion control logic 10. The speed feedback signal ωR on a line 914 is fed to the negative input of the summer 912. The summer 912 provides an error signal WE on a line 916 to outer loop forward path compensation 918 which comprises known proportional-plus-integral control logic having the following transfer function:<br>
(Equation Removed)<br>
Eq. 13<br>
s where G is the outer open loop gain, ωc is the break frequency for the<br>
numerator lead and "s" is the known Laplace transform operator.<br>
The output of the compensation logic 918 is a signal Wl provided on a line 920 which is a reference to an inner speed control loop 922. The inner loop speed reference Wj is fed to a positive input of a summer 924. The speed feedback signal ωR on the line 914 is fed to the negative input of the summer 924. The output of the summer 924 is an inner loop error<br>
signal W1E on a line 926 which is fed to a multiplier 928 which multiplies W1E by constants ωc x J*, where J* is the estimated system inertia. The output of the multiplier 928 is a torque signal T, on a line 932 provided to a multiplier 934 which multiplies the signal T, by 1/KT*, where KT* is the estimated motor torque constant. The output of the multiplier 934 is a current command I, on a line 936. The current command I1 is provided to a block 938 indicative of the transfer function of the current regulator/motor drive 20 (Fig. 1) which has a transfer function of 1, in the frequency range of interest for the present invention.<br>
The drive 938 provides a drive current I on a line 940 to a block 942 representing a current-to-torque multiplier (or torque constant KT) of the motor 24 (Fig. 1). The torque constant KT, as is known, is the ratio of motor torque to motor current. The motor 24 is a three-phase induction motor but may be any type of motor having a torque constant. For a field-oriented controlled induction motor, the current I represents the reference q-axis vector current IqREF. The output of the multiplier 942 is the motor output torque TE on a line 944, which is provided to a positive input of a summer 946. The negative input to the summer 946 is a signal TLOAD on a line 948 indicative of additional external load disturbances on the elevator cab system, such as friction or a load imbalance between the car and counterweight.  The output of the summer 946 is provided on a line 950 to a block 952 indicative of dynamics of the elevator inertia J, which is modeled as an integrator 1/Js with a gain 1/J. The output of the<br>
block 952 on the line 914 is the rotational speed ωR (or ωFB) of the motor 24 (Fig. 1). The numerals 912-934 illustrates the control logic within the speed loop compensation logic 16 (Fig. 1).<br>
Referring to Fig. 23, the block diagram of Fig. 22 can be simplified by expressing the inner loop 922 as a closed loop transfer function indicated by the below equation:<br>
(Equation Removed)<br>
where K{ = (J*/KT*)x( KT/J). Thus, the closed inner loop transfer function is a first order lag having a break frequency at ωcK1<br>
Referring to Fig. 24, if the constant K, is equal to 1, the numerator (lead) of the outer open loop transfer function 918 matches and cancels with the denominator (lag) of the inner closed loop transfer function 922. The resultant transfer function 960 is an integrator (G/s) having a gain G. We have found that when K, = 1, the elevator/motor system exhibits a desirable response.<br>
Referring to Fig. 25, a flow diagram for the gain calculation logic 866 begins at a step 1202 which requests and receives the necessary parameters to perform the second running rotor test 266, such as J*, KT*INIT from the service tool 80.<br>
The parameter KT*INIT may be obtained from the previously run second locked rotor test 258. The values for the parameter J*INIT may be<br>
approximated as shown below, and an alternative to receiving K from a previous motor test is to approximate it as shown below:<br>
J*mT = 2.0 + 6.0 x Load_Duty x ((RPM_Duty * 60)/RPM_Rated)2<br>
KT*INIT =TRATED /(IFULL-LOAD2-INO-LOAD2)½<br>
where TRATED is the rated torque from the motor data sheet, IFULL.LOAD is the full load motor current from the motor data sheet, INO.LOAD is the no load motor current from the motor data sheet, RPM_Duty is the contract or duty or max speed the motor is run for the application, Load_Duty is the duty or max load for the elevator for the application, RPM_Rated is the rated motor speed from the motor nameplate. In that case, the service personnel may calculate the parameters J*INIT, KT*INIT and provide them to the logic 866 by the service tool 80. Alternatively, the service personnel may provide the parameters Load_Duty, RPM_Duty, RPM_Rated, IFULL. LOAD* INO-LOAD   TRATED to the logic 866 by the service tool 80, and the logic 866 calculates the parameters J*INIT, KT*INIT- at the step 1201. Other values for the initial parameters J*INIT, KT*INIT may be used if desired; however, the values chosen for J*INIT, KT*INIT will determine how J* is adjusted (discussed more hereinafter). Other techniques may be used to obtain the initial parameters necessary to carry out the second running rotor test 266.<br>
Next, a series of steps 1202 sets J* and KT* to the initial values J*INIT, KT*INIT , respectively, sets Count = 0 to clear the loop counter, and sets MODE=1. Next, a step 1206 resets the integrator 865 (Fig. 21) output to zero.<br>
Next, a step 1210 sets the FLRCMD signal to run the elevator in the UP direction, using the standard speed profile discussed hereinafter. The floor where the elevator is initially positioned will determine which direction the elevator will be run.<br>
After the elevator up/down run is complete (as well as during the elevator run), a step 1212 determines whether a fault has occurred during the run of the elevator by reading the MCFAULT signal on the line 73 (Fig. 21). If a fault has been detected, a step 214 sets the FAULT signal equal to 1 which is sent over the link 82 to the service tool 80.<br>
If a fault has not been detected during the run of the elevator, the logic 866 checks whether a stop command has been received from the service tool 80 in a step 1216. If a stop command has been received, the step 1215 sets MODE=0 the logic exits, and the second running rotor test 266 is aborted. If the stop command has not been received, the logic reads the signal X on the line 867 (Fig. 21) and saves it as a variable X (1) in a step 1218.<br>
Next, a step 1220 runs the elevator in the DOWN direction (opposite to the run in the step 1210), using the standard speed profile discussed hereinafter. When the elevator up/down run is completed (as well as during the run), a step 1222 checks if a fault has occurred during the elevator run by monitoring the MCFAULT signal. If it has, the step 1214 sets the FAULT signal equal to 1 (Fig. 4), which is sent to the<br>
service tool 80 over the link 82, the step 1215 sets MODE=0, and the logic 866 exits. If a fault has not been detected, a step 1224 checks whether a Stop command has been received from the service tool 80. If a stop command has been received, the step 1215 sets MODE=0, the logic exits and the auto-calibration procedure is aborted. If not, a step 1226 saves the value of X as a variable X(2). The Up/Down run order may be reversed if desired.<br>
Next, a step 1228 calculates the average X value of the up/down run as: XAVG = [X(l) + X(2)]/2. Then, XAVG is checked at a step 1230 to see if it has changed sign (or polarity) from the last up/down run. If it has not changed sign, a step 1232 checks whether Count is greater than or equal to 10 iterations. If the loop has iterated less than ten times, a step 1234 sets the Fault flag to one and sends it to the service tool 80 over the link 82 (Fig. 21). If not, a step 1236 increments Count by one and a step 1238 calculates the next value of J*. For example, if J*INIT is set high as discussed hereinbefore, J* is reduced by a predetermined amount, e.g., 20% or J*(n+l) = J*(n) x 0.8, at the step 1238 and the logic 866 goes back to the step 1206 to perform another up/down run of the elevator. Other percentage changes for J* may be used. Conversely, if  J*INIT  is set low    J* is increased by a predetermined amount in the step 1238.<br>
If XAVG has changed sign, the result of the test 1230 will be yes and a step 1240 interpolates to determine the value of J* where XAVG<br>
crosses zero. In particular, referring to Fig. 28, a curve 1360 shows the values of X plotted for given estimated set of values of J*. When the value of X crosses through zero, the values of J* associated with the data points 1362, 1364 on both sides of zero are interpolated to determine the point 1366 at which the curve 1360 crosses through zero. The result of this interpolation is the approximated value for the system inertia J* which will be used by the motor controller 8 (Fig. 21).<br>
Other gain adjustment algorithms for the logic 866 may be used if desired, provided the algorithm converges to the correct value of J* within the desired tolerances. Also, the logic described herein may be performed using values of X from only an up or down run (i.e., without averaging); however, averaging X from up and down runs provides the most robust values for J*.<br>
Referring to Fig. 26, the reference signal ωREF, the output of the ideal model 850 (Fig. 21) W*, and the actual speed of the motor ωR (or ωFB) are indicated by the curves 1340, 1342, 1344, respectively. The speed profile reference curve 1340 (ωREF) is indicative of a typical speed profile for the elevator comprising a ramp-up (or increasing or acceleration) speed region A a constant speed region B (where the motor runs at the duty or contract or full speed for a given application) and a ramp down (or decreasing or deceleration) speed region C back to zero, as discussed hereinbefore.<br>
The duration of the constant speed portion B is based on the number of floors (or destination floor) commanded by the FLRCMD signal (Fig. 21). The duration of the constant speed portion B is not critical to the second running rotor test 266 to determine J*. However, the acceleration and deceleration regions λC of the speed profile provide information to determine the correct value of J*. Also, the higher the speed, the better the measurements for J*; thus, the elevator is run up to duty speed.<br>
The profile 1340 is merely for illustration purposes and other ramp up/down rates, duty speeds, and overall profiles may be used. The number of floors or destination floor may be provided by the service tool 80 over the link 82.<br>
If the parameters of the model of Figs. 22-24 are set as follows: J* = 4.0 (high); 1.0 (low); 2.28 (correct). KT* = 2.44, KT = 2.44, J = 2.28, G = 8, ωc = 4, this gives values for Kl, as Kl = J*/2.28, which when evaluated at J* = 1, 4.0, 2.28, yields Kl = 0.44, 1.75, 1, respectively.<br>
Referring now to Figs. 26 and 27, if the inertia value J* is the correct value (i.e., Kl = 1.0, J* = 2.26), the parameter ωREF is indicated by a curve 1340, the parameter W* is indicated by a curve 1342, and the parameter ωR is indicated by a curve 1344. As expected, the feedback signal ωR is substantially equal to the desired signal W* with minimal overshoot or undershoot. Referring to Fig. 27, parameter WMRE is<br>
indicated by a curve 1350, the parameter DX is indicated by a curve 1352 and the parameter X is indicated by a curve 1354. As expected, the parameter X is close to zero at the end of an elevator run indicating that the error between the desired speed output and the actual speed output is small and is within the desired tolerance.<br>
However, if the inertia J* value is high, e.g., J* = 4.0 and thus, Kl = 1.75, the actual motor speed response will exhibit a sluggish response. In this case, the value of X is negative at the end of the run. Conversely, when the inertia value J* is a low value, e.g., J*= 1.0 and, thus, Kl equals 0.44, the actual motor speed response will have an overshoot. In that case, with the inertial estimate low, the resultant value of X at the end of a single elevator run is positive.   .<br>
Referring to Fig. 21, the multiplier 857 provides speed scaling or windowing of the error signal WMRE to the integrator 865, such that at low speeds, i.e., during ramp up and ramp down regions of the speed profile, the signal error WMRE is scaled down. Such scaling is done because the model logic 850 does not account for the load torque on the elevator system which comprises friction and hoistway imbalance and will in general be difficult to quantify. The friction will be non-linear, particularly for geared elevator systems and gearbox friction will be higher at low speeds, and gradually reducing to the lowest values as the speed reaches full speed.<br>
Also, the multiplier 859 provides a windowing dead-band function which forces the integrator 865 to ignore model reference errors at low speeds by forcing DX to zero until the speed exceeds a predetermined percentage of the full speed. The comparator 863 uses a value of 50% of the full speed of the system as the width of the dead-band; however, other values may be used.<br>
While the multipliers 857,859 are not required for the present invention, they provide optimal performance. Also, instead of using both the multipliers 857,859 to scale and window the input signal DX to the integrator 865, either one may be used individually if desired to provide a similar effect. Also, other windowing or signal scaling techniques may be used to avoid erroneous signals.<br>
The term "loop gain" as used herein refers to the parameter (or factor) J* of the gain of the inner speed loop 922 (Fig. 22) within the speed loop compensation 16, which is varied as described herein, as well as the overall loop gain (e.g., ωc J*/KT*). The other factors ωc, KT* of the speed loop are constants, and as such, variation of J* results in variation of the speed loop gain. Also, it should be understood that instead of providing a variable J* and a constant KT*, the logic 866 may provide a single variable parameter equal to a combination of loop gain factors (e.g., J*/KT*) or equal to the overall loop gain (e.g., ωc J*/KT*) to the logic 16. In either case, the value of the loop gain is varied as described herein until the desired response is achieved.<br>
Instead of the integrator 865, a low pass filter or any other type of filter may be used to filter transients in DX and provide an average value of DX over a given run. In that case, the output of the filter 865 may be sampled by the logic 866 prior to Pass or ωR going to zero, e.g., during the constant or duty speed portion of the run. Also, the multipliers 857,859 may be modified to operate with the filter chosen, to provide the desired output signals.<br>
Alternatively, instead of using the integrator (or filter) 865, the signal DX may be sampled directly by the logic 866 without a filter or integrator. In that case, the logic 866 would sample the value of DX at the end of (or during) the constant speed portion of the run in steps 1218, 1226 (Fig. 25) and DX would replace X where ever it is referenced herein. Alternatively, instead or in addition to filtering DX, the input signals to the calculation of DX may be filtered. Alternatively, the logic 266 may calculate DX only when the motor speed is above a certain speed or has been at duty speed for a predetermined period of time.<br>
The order of direction for the up-down elevator is run is not critical to the present invention, e.g., the elevator may be run down in the step 1210 and up in the step 1220 (Fig. 25). However, typically, service personnel will run the elevator to the ground or first floor to begin service or calibration. In that case, running the elevator up first may be necessary to provide a run which has a long enough duration, as discussed hereinbefore with the standard profile.<br><br>
As each of the four tests 252,258,262,266 completes, parameters are automatically stored in the memory of the motor controller 14 eliminating the need for the installer or service personnel to enter such parameters manually. As each test in the self-commissioning process is completed, the logic 48 (or the specific test logic) provides a DONE flag to the service tool 80 and provides particular motor parameters of interest for the service personnel. Alternatively, the logic 48 may provide an indication to the service tool when all tests are completed.<br>
Instead of the four tests 252,258,262,266 running automatically, after each test completes, the logic 48 may wait for the service tool 80 to provide another start command to perform the next test in the sequence. Alternatively, the service tool 80 may command which test is to be performed.<br>
Although the invention has been described and illustrated with respect to exemplary embodiments thereof, it should be understood by those skilled in the art that the foregoing, and various other changes, omissions and additions may be made without departing from the spirit and scope of the present invention.<br><br><br><br><br>
We Claim:<br>
1.        A method of self-commissioning a field-oriented elevator motor controller, comprising the steps of:<br>
a)	determining an integral gain K1, a proportional gain Kp, and an<br>
overall gain (Gc) for the motor controller;<br>
b)	obtaining initial values of a rotor time constant R, magnetizing<br>
current Id,  and motor torque constant KT* for the motor<br>
controller,   and   obtaining   a   value   of  a   motor   transient<br>
inductance Lo ;<br>
c)	determining final values for said rotor time constant   R and<br>
magnetizing current ID, using said transient inductance Lo ;<br>
and<br>
d)	determining  a  system  inertia J*  parameter  for  the  motor<br>
controller.<br><br>
2.	The  method as  claimed in claim  1   wherein  said  step  (b)  of<br>
obtaining initial values comprises determining said initial values.<br>
3.	The method as claimed in claim 1 wherein said steps (a) - (d) are<br>
performed upon receiving a command from a service tool.<br>
4.	A method of self-commissioning a field-oriented elevator motor<br>
controller substantially as herein described and as illustrated by the<br>
accompanying drawings.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">3755-del-1998-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">3755-del-1998-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1jb3JyZXNwb25kZW5jZS1vdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">3755-del-1998-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1jb3JyZXNwb25kZW5jZS1wby5wZGY=" target="_blank" style="word-wrap:break-word;">3755-del-1998-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">3755-del-1998-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1mb3JtLTEucGRm" target="_blank" style="word-wrap:break-word;">3755-del-1998-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1mb3JtLTEzLnBkZg==" target="_blank" style="word-wrap:break-word;">3755-del-1998-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1mb3JtLTE5LnBkZg==" target="_blank" style="word-wrap:break-word;">3755-del-1998-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1mb3JtLTIucGRm" target="_blank" style="word-wrap:break-word;">3755-del-1998-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1mb3JtLTI5LnBkZg==" target="_blank" style="word-wrap:break-word;">3755-del-1998-form-29.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1mb3JtLTMucGRm" target="_blank" style="word-wrap:break-word;">3755-del-1998-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1mb3JtLTQucGRm" target="_blank" style="word-wrap:break-word;">3755-del-1998-form-4.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1mb3JtLTYucGRm" target="_blank" style="word-wrap:break-word;">3755-del-1998-form-6.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1ncGEucGRm" target="_blank" style="word-wrap:break-word;">3755-del-1998-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1wZXRpdGlvbi0xMzgucGRm" target="_blank" style="word-wrap:break-word;">3755-del-1998-petition-138.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Mzc1NS1kZWwtMTk5OC1wZXRpdGlvbi1vdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">3755-del-1998-petition-others.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="232350-novel-hypocholesterolemic-compounds.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="232352-a-medium-for-clonal-propagation-of-pandanus.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>232351</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>3755/DEL/1998</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>27-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>16-Mar-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>15-Dec-1998</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>OTIS ELEVATOR COMPANY</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>TEN FARM SPRINGS, PARMNINGTON, CONNECTICUT 06032, UNITED STATE OF AMERICA.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>RONNIE E. THEBEAU</td>
											<td>737 TOWN COLONY DRIVE, MIDDLE TOWN, CONNECTICUT 06457, USA.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>ROY STEPHEN COLBY</td>
											<td>8408 SEAGATE DRVIE, RALEIGH, NORTH CAROLINA 27615, USA.</td>
										</tr>
										<tr>
											<td>3</td>
											<td>ALBERTO VECCHIOTTI</td>
											<td>821 TOWN COLONY DRIVE, MODDLE TOWN, CONNECTICUT 06457, USA.</td>
										</tr>
										<tr>
											<td>4</td>
											<td>NAIL GREINER</td>
											<td>20 STILLMAN ROAD, WETHERSFIELD, CT 06109, USA.</td>
										</tr>
										<tr>
											<td>5</td>
											<td>LESLIE M. LAMONTAGNE</td>
											<td>11 HYDELOR AVENUE, PROSPECT, CONNECTICUT 06712, USA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H02P 21/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>8/996,264</td>
									<td>1997-12-22</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/232351-a-method-as-self-commissioning-a-field-oriented-elevator-motor-controller by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:06:38 GMT -->
</html>
