<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/262955-method-and-apparatus-for-managing-cache-partitioning by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 02:53:14 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 262955:METHOD AND APPARATUS FOR MANAGING CACHE PARTITIONING</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD AND APPARATUS FOR MANAGING CACHE PARTITIONING</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method of managing cache partitions provides a first pointer for higher priority writes and a second pointer for lower priority writes, and uses the first pointer to delimit the lower priority writes. For example, locked writes have greater priority than unlocked writes, and a first pointer may be used for locked writes, and a second pointer may be used for unlocked writes. The first pointer is advanced responsive to making locked writes, and its advancement thus defines a locked region and an unlocked region. The second pointer is advanced responsive to making unlocked writes. The second pointer also is advanced (or retreated) as needed to prevent it from pointing to locations already traversed by the first pointer. Thus, the first pointer delimits the unlocked region and allows the locked region to grow at the expense of the unlocked region.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT, 1970<br>
(39 of 1970)<br>
&amp;<br>
THE PATENTS RULES, 2003<br>
COMPLETE SPECIFICATION<br>
(See section 10, rule 13)<br>
"METHOD AND APPARATUS FOR MANAGING CACHE PARTITIONING"<br>
QUALCOMM INCORPORATED<br>
an American company of 5775 Morehouse Drive, San Diego, California 92121 (United States of America)<br>
The following specification particularly describes the invention and the manner in which it is to be performed.<br><br>
20U7/03S904	PCT/US2006/036938<br>
-METHOD AND APPARATUS FOR MANAGING CACHE<br>
PARTITIONING<br>
BACKGROUND Field of the Invention<br>
[0001]      The present invention generally relates to cache memories, and particularly relates to managing partitioning of such memories, such as between higher and lower priority entries.<br>
 Relevant Background<br>
[0002]       Partitioning cache memories into locked and unlocked regions represents a common practice. More particularly, it is known to apportion the ways of a cache set between locked and unlocked entries, but conventional approaches to locked/unlocked partition management have certain drawbacks.<br>
[0003]      For example, one method of dividing cache ways into locked and unlocked portions uses a total of three pointers per cache set. The three pointers include a locked pointer to indicate the next locked entry in the cache set, and an unlocked pointer used to indicate the next unlocked entry in the cache set. The third pointer defines an upper limit or ceiling for the locked entry partition, and thus establishes a fixed floor for the unlocked partition. That is, with the three-pointer approach, two pointers are used to manage successive writes for the locked and unlocked portions of the cache set, and a third pointer is used to indicate the fixed boundary between the locked and unlocked portions of the cache set.<br>
[0004]      Another approach to managing locked and unlocked portions of a given cache set relies on the use of locked/unlocked bits per cache line in each cache way of the set. With this approach, additional register bits mark individual cache lines as locked or unlocked.<br>
[0005]      While the above methods do permit at least limited management of locked and unlocked portions of cache sets, they do so at the expense of additional register<br><br><br>
2007/03SPU4	PCT/US2006/036M3&amp;<br>
usage, increased software overhead, and lowered cache usage efficiencies. These disadvantages become particularly problematic for large caches where significant register resources are given over to the management of cache memory partitions.<br>
SUMMARY OF THE DISCLOSURE [0006]      One embodiment of a method of managing cache memory partitioning as taught herein comprises providing a first write pointer for higher priority writes into a cache memory and a second write pointer for lower priority writes into the cache memory, and using the first write pointer as a delimiter for the lower priority writes. Using the first write pointer as a delimiter for the lower priority writes comprises generally precluding the second write pointer from pointing to cache memory locations to which higher priority writes have been made.<br>
[0007]      Associating the first pointer with higher priority writes and constraining the position of the second pointer accordingly establishes a dynamic boundary between adjacent higher and lower priority regions of cache memory. In other words, ongoing lower priority writes may be conducted as needed, but cache memory locations consumed by those lower priority writes may be reclaimed for higher priority writes through manipulation of the first and second pointers. In this manner, the software executing on a microprocessor incorporating cache partitioning as taught herein need not explicitly set and manage partition boundaries.<br>
[0008]      For example, a microprocessor can be configured to provide two pointers per cache set, with the first one of these pointers denoted as a (higher priority) locked pointer and a second one of these pointers denoted as a (lower priority) unlocked pointer. A cache partition control circuit included in the microprocessor is configured to point the locked pointer to the first unlocked entry in the cache set, for example, such that all entries below the pointer are locked. Further, both the locked and unlocked pointers would point to the next victim in the cache set depending on whether the next cache write is a locked write or an unlocked write. With this configuration, the locked<br><br><br>
WO 2007/035984	PCT/US2006/036938<br>
pointer serves as the floor of the unlocked region, and the unlocked pointer may be manipulated such that it moves to a maximum position in the cache set with successive unlocked writes and wraps back to the locked pointer.<br>
BRIEF DESCRIPTION OF THE DRAWINGS <br>
[0009]      Fig. 1 is a logic flow diagram illustrating one embodiment of pointer management and resultant dynamic cache partitioning as taught herein. <br>
[0010]      Figs. 2 and 3 are block diagrams of a cache memory, and illustrate the use of first and second pointers to create higher priority and lower priority regions of the cache memory with a dynamic boundary therebetween.<br>
[0011]      Figs. 4-7 are block diagrams of a cache set and illustrate the use of a pair of pointers to manage dynamically partitioned ways in the cache set. <br>
[0012]      Figs. 8 and 9 are block diagrams illustrating another embodiment of dynamically partitioning a cache set via the use of first and second pointers. <br>
[0013]      Fig. 10 is a block diagram illustrating the use of multiple pointers to create multiple dynamically bounded regions of differing priorities in a cache memory. <br>
[0014]       Fig. 11 is a block diagram of a microprocessor that incorporates a cache control circuit configured to carry out cache memory partitioning management through the use of pointer pairs, according to one or more of the methods taught herein. [0015]      Fig. 12 is a block diagram of a partition control circuit that may be included in, for example, the cache memory control circuit in the microprocessor of Fig. 11.<br>
DESCRIPTION OF EMBODIMENTS OF THE INVENTION <br>
[0016]      Fig. 1 is a logic flow diagram broadly illustrating a method of managing cache memory partitioning as taught herein. The method is based on providing a first write pointer for higher priority writes into a cache memory, and a second write pointer for lower priority writes into the cache memory (Step 100).<br>
[0017]      With the pointer pair thus defined, the method uses the first write pointer as a delimiter for lower priority writes (Step 102). Effectively, the method creates higher <br><br><br><br><br>
and lower priority regions in a cache memory, wherein the higher priority pointer serves as a dynamic boundary between the two regions.<br>
[0018]      This arrangement is shown in Fig. 2 wherein a cache memory 10 (or at least a selected portion of a cache memory) includes a higher priority region 12 that is addressed by a first pointer (PTR1) and a lower priority region 14 that is addressed by a second pointer (PTR2). PTR1 defines a boundary 16 between regions 12 and 14. Using PTR1 to mark the boundary between the regions allows the higher priority region 12 to grow at the expense of the lower priority region 14. That is, for the illustrated memory layout, PTR1 can take on values from a given starting (minimum) value associated with a lower bound of the cache memory 10, up to an ending (maximum) value associated with an upper bound of the cache memory 10. In contrast, PTR2 can take on values ranging from the current value of PTR1 up to the upper bound of the cache memory 10. PTR2 thus is generally precluded from pointing to cache memory locations to which higher priority writes have been made. [0019]      With this arrangement, PTR1 may be configured to advance through the cache set up to the maximum pointer value, or up to a defined offset from the maximum pointer value. Moreover, PTR2 can be configured to advance through the cache memory up to the maximum pointer value and then wrap back to a current value of the first write pointer, or wrap back to a value corresponding to a defined offset from the current value of the first write pointer. Fig. 2 particularly illustrates that the lower priority region 14 may include valid and invalid (un-initialized) entries. Such circumstances might exist at the outset of cache use, for example. Fig. 3 then illustrates that PTR2 will, with repeated lower priority writes, fill each available position of the lower priority region 14, and then wrap back down to the boundary 16 defined by PTR1, and begin overwriting previously written lower priority entries as it advances back toward the upper limit of the cache memory.<br>
[0020]      Of course, this wrap-around writing in the lower priority region 14 assumes that higher priority writes have not advanced the higher priority region 12 to its upper <br><br>
WO 2007/03S904	. PCT/US2006/036930<br>
limit. More particularly, PTR1 may be advanced up to the maximum value (or one less than the maximum value) and then allowed to "saturate" or otherwise stick at that value. Once PTR1 sticks at the top of the memory range, all positions below it are unavailable to PTR2, and thus PTR2 effectively is "stuck" at the top of the memory range with PTR1. In such cases, the pointer management logic may leave PTR1 and PTR2 at the topmost memory position, and allow additional higher and lower priority rights in that topmost location, which effectively means that there would be no write prioritization for that topmost position and subsequent higher and lower priority writes simply would successively overwrite the topmost position.<br>
 [0021]      With the above pointer pair arrangement, a microprocessor may conveniently apportion the ways of a cache set between locked and unlocked entries, for example, to reduce hardware and increase code efficiency. ("Locked" writes may be considered as a type of cache write having higher, priority than "unlocked" writes.) [0022]      More particularly, PTR1 may serve as a locked pointer and PTR2 may serve as an unlocked pointer. PTR2 would be advanced, e.g., incremented, responsive to making unlocked writes, and PTR1 would be advanced responsive to making locked writes. PTR1 would thus point to the first unlocked entry in a cache set, with all entries below it being locked. A locked write would thus overwrite the unlocked (or empty) entry currently pointed at by PTR1, and PTR1 would then advance to the next unlocked position. PTR2 would be adjusted, if necessary, to remain at or above the position of PTR1. Further, PTR2 could be made to wrap back to PTR1 after being advanced to a maximum pointer value, such that the current position of PTR1 establishes the floor for unlocked writes.<br>
[0023]      This method eliminates the need for a unique floor/ceiling register per cache set and removes the need for a locked and unlocked bit per cache line. Moreover, the method eliminates the necessity of having a programmer manage boundaries between locked and unlocked entries. Finally, grouping locked and unlocked ways in this manner eliminates the necessity of managing interleaved locked and unlocked entries <br><br>
3007/03S901-	PCT/US2006/036638<br>
in a cache—i.e., the software is not obligated to manage locked/unlocked status bits per cache entry.<br>
[0024]      With the above locked/unlocked writes as one example of higher and lower priority cache writes, Figs. 4-7 illustrate one embodiment of using a pointer pair to manage dynamic partitioning of a cache set 20 into higher and lower priority regions. [0025]      The cache set 20 illustrated in Figs. 4-7 includes sixteen ways (0-15), which may be dynamically partitioned into higher and lower priority regions according to the methods taught herein. More particularly, Figs. 4-7 illustrate providing a first write pointer (PTR1) for higher priority writes into a cache set 20, providing a second write pointer (PTR2) for lower priority writes into the cache set 20, and using PTR1 as a delimiter for the lower priority writes.<br>
[0026]       In the illustrated embodiment, using PTR1 as a delimiter for the lower priority writes comprises initializing PTR1 and PTR2 to be equal, advancing PTR1 and PTR2 responsive to making higher and lower priority writes, respectively, and additionally advancing PTR2 as needed to prevent PTR1 from passing PTR2. (Note that "passing," as used in this sense, is a relative term and simply means that PTR2 is not allowed to assume or remain at a pointer value that has been traversed by PTR1.) For example, if PTR1 is currently pointing to way 5 of the 16-way cache set 20 as the next locked write victim, PTR1 generally will have traversed through ways 0-4 of the cache set 20, meaning that PTR2 generally will be prevented from pointing to ways 0-4, to avoid overwriting the locked entries in those positions. <br>
[0027]      With this general pointer management method in mind, Fig. 4 shows an initialization state of the cache set 20, where PTR1 and PTR2 are initialized to point to way 0 of cache set 20. Thus, operations begin with way 0 being the next victim for either a higher or lower priority. Assuming that three lower priority writes are made without making any higher priority writes, Fig. 5 illustrates the advancement of PTR2 to way 3 such that ways 0-15 of cache set 20 effectively define a lower priority region 22 of cache set 20 (with ways 0-2 containing the just-written entries). Note that PTR1 still<br><br><br>
WO 2007/035904<br><br>
PCT/US2006/U36938<br><br>
points at way 0, meaning that the next victim for a locked write is way 0, such that the unlocked entry previously written into way 0 will be overwritten. [0028]      Now, assuming that a higher priority write is made to cache set 20 without making any additional lower priority writes, Fig. 6 illustrates that PTR1 has been advanced to way 1 of cache set 20, such that way 0 of cache set 20 effectively represents a higher priority region 24 of cache set 20. From this illustration, the reader will appreciate that the boundary between the lower priority region 22 and the higher priority region 24 is defined by the current position of PTR1. [0029]      Now, assuming that three additional higher priority writes are made without making any further lower priority writes, Fig. 7 illustrates that PTR1 has been advanced from way 1 to way 4, and that the higher priority region 24 now spans from way 0 to way 3. With this advancement of PTR1, the lower priority region 22 has been partially overwritten by higher priority writes, and PTR2 has been advanced along with PTR1, to prevent PTR1 from passing PTR2.<br>
[0030]      Thus, both PTR1 and PTR2 now point to way 4 of cache set 20. The current positions of PTR1 and PTR2 mean that way 4 is the next victim for either a higher priority write (PTR1) or a lower priority write (PTR2), and that ways 0-3 are locked. At this instant, then, the higher priority region 12 spans from way 0 to way 3, and the lower priority region spans from way 4 to way 15.<br>
[0031]      On this point, it should be noted that PTR1 generally is advanced linearly through the region of cache memory to which it is assigned, and allowed to stick or otherwise saturate at the top of that region—i.e., PTR1 is prevented from wrapping around—so that the locked entries below PTR1 are protected from being overwritten. Of course, PTR2 may be permitted to advance through the same region of cache memory, so long as it remains at or above the current position of PTR1, and further may be permitted to wrap back from the top of the region to the current position of PTR1. Doing so enables a "round-robin" replacement scheme, wherein newer lower priority writes replace older lower priority writes as needed, based on PTR2 repeatedly<br><br><br><br>
cycling through whatever portion of the cache memory region is left to it at or above the current position of PTR1.<br>
[0032]      In any case, one sees that advancing PTR1 responsive to making higher priority writes defines a higher priority region of the cache memory set 20 corresponding to the portion of the cache memory set 20 traversed by PTR1. By advancing PTR2 responsive to making lower priority writes and, on an as needed basis, responsive to advancing PTR1, one sees that the lower priority region exists above the higher priority region by virtue of a dynamic boundary. Further, one sees that overwrites via wrap-around of PTR2 are permitted for the lower priority region, with the location of PTR1 serving as the wrap-around floor for PTR2 to thereby prevent lower priority writes from overwriting higher priority entries. More succinctly, the value of PTR2 is controlled such that it does not traverse memory locations that have been traversed by PTR1.<br>
[0033]      Thus, although the ceiling of the lower priority region can move upward in the cache memory set 20, the floor of the lower priority region as defined by the • position of PTR1 also can move upward. This allows the higher priority region to grow at the expense of the lower priority region, and ensures that lower priority writes do not overwrite previous higher priority writes.<br>
[0034]      Figs. 8 and 9 show another embodiment, wherein PTR1 and PTR2 are initialized to opposite first and second ends of the cache set 20, and move toward each other as higher and lower priority writes are made into the cache set 20. More particularly, as shown in Fig. 8, PTR1 is initialized to a first value, which may be a bottom of the cache set 20, and PTR2 is initialized to a second value offset from the first value, which may be the top of the cache set 20. Then, PTR1 is advanced toward PTR2 responsive to making higher priority writes into cache set 20, and PTR2 is advanced toward PTR1 responsive to making lower priority writes into cache set 20. With this arrangement, the method further includes retreating PTR2, e.g., moving it "backward," as needed to prevent PTR1 from passing it. <br><br>
WO 3007/035904-	PCT/US2006/U36938<br>
[0035]       Fig. 9 illustrates subsequent positions for PTR1 and PTR2 relative to Fig. 8, assuming that three higher priority writes and two lower priority writes have been made to the cache set 20. As may be seen, ways 15-3 now comprise a lower priority region 22 of the cache set 20 (with ways 15 and 14 containing the just-written lower priority values), and PTR2 points to way 13 as the next victim for a lower priority write. Similarly, ways 0-2 now comprise a higher priority region 24 of the cache set 20, and PTR1 points to way 3 as the next victim for a higher priority write. <br>
[0036]      Also, it should be noted that PTR2 is permitted to advance toward the current position of PTR1 but not beyond PTR1, and can be permitted to wrap back from PTR1 to PTR2's starting position for round-robin replacement of lower priority cache entries. That is, PTR2 may be advanced downward to the point where it meets PTR1, and then its value may be reset or wrapped back to the top of the cache set 20 such that it is allowed to advance downward again at least to the current position of PTR1.<br>
[0037]       In general, then, Figs. 8 and 9 illustrate another approach to managing a pair of cache pointers for a given cache set (or a given region of cache memory), wherein each pointer in the pair is initialized on opposite ends of the cache region of interest, and permitted to move inward toward each other. More particularly, one sees that advancing PTR1 responsive to making higher priority writes defines a higher priority region of the cache set 20 corresponding to the portion of cache set 20 traversed by PTR1. The region of cache set 20 not traversed by PTR1 is defined as a lower priority region bounded by the minimum (or starting) position of PTR2 at one end, and by the dynamically changing position of PTR1 at the other end. Thus, PTR2 is advanced within the lower priority region as needed, responsive to lower priority writes, and is retreated as needed, to prevent PTR1 from passing it.<br>
 [0038]       Fig. 10 illustrates a further expansion of the dynamic partitioning methods taught herein, wherein the cache memory 10 is divided into a highest priority region 12, <br><br>
WO 3007/03590T	PCT/US2006/036938<br>
a next highest priority region 14, and a next highest priority region 30. (In other words, the priority hierarchy is region 12, region 14, and then region 30.)<br>
 [0039]      PTR1 acts as the floor for region 14, and PTR2 acts as the floor for region 30. PTR1 advances upward and thus grows region 12 at the expense of regions 14 and 30, and PTR2 advances upward and thus grows region 14 at the expense of region 30. Both PTR1 and PTR2 may be aliowed to advance upward to a maximum or ending position of the cache memory 10 or up to a defined offset less than that maximum position. In contrast, PTR3 may be allowed to grow upward to the maximum position and then wrap back down to PTR2, which acts as the floor (delimiter) for region 30. Thus, all or part of region 30 is subject to being overwritten by entries for region 14 and/or for region 12, and that all or part of region 14 is subject to being overwritten by entries for region 12.<br>
[0040]      Understood broadly, the above methods teach dynamically partitioning between higher and lower priority regions of cache memory, wherein, for a two-region example, advancing the first write pointer responsive to making higher priority writes defines a higher priority region of the cache memory corresponding to the portion of the cache memory traversed by the first write pointer, and defines a lower priority region of the cache memory corresponding to the portion of cache memory not traversed by the first write pointer. More particularly, the first pointer tracks higher priority writes and is not permitted to wrap; thus, the region of cache memory not traversed by the higher priority pointer represents memory locations into which higher priority writes have not been made, and are therefore locations in which lower priority writes can be made. The lower priority pointer can wrap around within the lower priority region as needed, and the lower priority region shrinks as the higher priority region grows. [0041]       Fig. 11 illustrates a microprocessor 40 that may be configured to include one or more methods of managing dynamic cache partitioning as taught herein. Those skilled in the art will appreciate that microprocessor architectures vary widely, and that a large number of circuit arrangements may be used to embody the various methods<br><br><br><br>
taught herein, it should be understood, then, that the microprocessor 40 of Fig. 11 stands as a non-limiting example of incorporating dynamic cache partitioning into a microprocessor.<br>
[0042]      The illustrated microprocessor 40 comprises an instruction pipeline 42 including a front-end unit 44, an execution unit 46, and a completion unit 48. The instruction pipeline 42 is associated with a branch control circuit 50, and with a cache controller 52 that provides cached instructions to the front-end unit 44 from a Level 1 (L1) instruction cache 54, and cached data to the execution unit 46 from a data cache 56. Of particular interest regarding the methods taught herein, the cache controller 52 may be configured to include a partition control circuit for managing partitions in the instruction cache 54 and/or in the data cache 56. The instruction cache 54 (or the data cache 56) may be set associative, or may be fully associative, and the methods taught herein apply equally to either configuration.<br>
[0043]      Fig. 12 illustrates one embodiment of a partition control circuit 60 that includes or is associated with a pair of registers 62 and 64. The registers 62 and 64 may be used to hold a pair of pointer values (i.e., values for PTR1 and PTR2). For example, assuming that the instruction cache 54 is a 16-way set associative cache, the partition control circuit 60 may maintain a register pair 62 and 64 for each set of the instruction cache 54. By way of non-limiting example, assuming that the instruction cache 54 comprises 64 sets, the partition control circuit 60 may maintain 128 pointers (two per set). For 16 ways per set, each pointer may comprise a 4-bit value allowing it to range from way 0 to way 15 in the corresponding cache set. If more than two priorities are being managed per cache set, then the partition control circuit 60 maintains as many pointers as there are priorities for each cache set—e.g., three priorities = three pointers, and so on.<br>
[0044] In at least one embodiment, the partition control circuit 60 includes a pointer selector to select PTR1 or PTR2 as a function of the type of cache write (e.g., high/low priority, locked/unlocked). That is, the pointer selector identifies the type of write, so<br><br><br><br>
that the correct one of the two pointers for the targeted cache set may be advanced responsive to making the write. The partition control circuit also may include one or more incrementers, to calculate new pointer values as successive writes are made to the cache set, and also may include one or more comparator circuits, to compare the first and second pointer values to ensure that a lower priority pointer is precluded from taking on values that would cause higher priority writes to be overwritten by lower priority writes.<br>
[0045]      In addition to integrating the partition control circuit 60 within the cache controller 52 of the microprocessor 40, those skilled in the art will recognize that the partition control circuit 60 can be physically or functionally impiemented elsewhere. For example, a Level 2 (L2) cache may be internal or external to the microprocessor 40, and can be configured to provide a secondary cache for holding a larger amount of cached instructions and/or data. In such contexts, the dynamic partition control methods taught herein may be implemented in a L2 cache controller, which typically resides wherever the L2 cache memory arrays reside.<br>
[0046]      Of course, those skilled in the art will appreciate that the present invention is not limited by the discussion herein relating to various illustrative embodiments, nor is it limited by the accompanying figures. Rather, the present invention is limited only by the following claims, and their legal equivalents.<br><br><br>
WO 2007/03S904<br><br><br><br>
WE CLAIM	PCT/US2006/06938<br>
1.	A method of managing cache memory partitioning comprising:<br>
providing a first write pointer for higher priority writes into the cache memory, and a second write pointer for lower priority writes into the cache memory; and<br>
using the first write pointer as a delimiter for the lower priority writes.<br>
2.	The method of claim 1, wherein using the first write pointer as a delimiter for the lower priority writes comprises generally precluding the second write pointer from pointing to cache memory locations to which higher priority writes have been made.<br>
3.	The method of claim 1, wherein using the first write pointer as a delimiter for the lower priority writes comprises initializing the first and second write pointers to be equal, advancing the first and second write pointers responsive to making higher and lower priority writes, respectively, and additionally advancing the second write pointer as needed to prevent the first write pointer from passing the second write pointer.<br>
4.	The method of claim 3, further comprising allowing the second write pointer to wrap back from a maximum pointer value to a current value of the first write pointer, or to a value corresponding to a defined offset from the current value of the first write pointer.<br>
5.	The method of claim 3, further comprising saturating the first write pointer at a maximum pointer value, or at a defined offset from the maximum pointer value.<br>
6.	The method of claim 3, wherein advancing the first write pointer responsive to making higher priority writes defines a higher priority region of the cache memory<br><br><br><br><br>
corresponding to the portion of the cache memory traversed by the first write pointer and defines a lower priority region of the cache memory corresponding to the portion of cache memory not traversed by the first write pointer.<br>
7.	The method of claim 1, wherein using the first write pointer as a delimiter for the lower priority writes comprises initializing the first write pointer to a first value, initializing the second write pointer to a second value offset from the first value, advancing the first write pointer toward the second write pointer responsive to making higher priority writes into the cache memory, advancing the second write pointer toward the first write pointer responsive to making lower priority writes into the cache memory, and retreating the second write pointer as needed to prevent the first write pointer from passing the second write pointer.<br>
8.	The method of claim 7, wherein advancing the first write pointer responsive to making higher priority writes defines a higher priority region of the cache memory corresponding to the portion of the cache memory traversed by the first write pointer and defines a lower priority region of the cache memory corresponding to the portion of cache memory not traversed by the first write pointer.<br>
9.	The method of claim 1, wherein using the first write pointer as a delimiter for the lower priority writes comprises configuring the first and second write pointers to move in the same direction relative to the cache memory, and moving the second write pointer as needed to prevent the first write pointer from passing the second write pointer.<br>
10.	The method of claim 1, wherein using the first write pointer as a delimiter for the lower priority writes comprises configuring the first and second write pointers to move toward each other relative to the cache memory, and moving the second write pointer as needed to prevent the first write pointer from passing the second write pointer. <br><br>
WO 2007/035904-	PCT/US20Q6/036938<br><br>
11.	The method of claim 1, wherein the first write pointer comprises a locked write<br>
pointer and the second write pointer comprises an unlocked write pointer.<br>
12.	A method of managing cache memory partitioning comprising:<br>
partitioning a cache memory into adjacent regions comprising a higher priority<br>
region addressed by a first write pointer and a lower priority region addressed by a second write pointer; using the first write pointer to delimit the lower priority region relative to the higher priority region.<br>
13.	A partition control circuit for managing partitions in a cache memory comprising:<br>
a first write pointer for making higher priority writes into a cache memory, and a<br>
second write pointer for making lower priority writes into the cache memory; and a pointer controller configured to use the first write pointer as a delimiter for the lower priority writes.<br>
14.	The partition control circuit of claim 13, wherein the partition control circuit comprises an integrated partition control circuit included in a microprocessor for managing at least a portion of a Level 1 (L1) or a Level 2 (L2) cache memory associated with the microprocessor.<br>
15.	The partition control circuit of claim 1, wherein the pointer controller is configured to generally preclude the second write pointer from pointing to cache memory locations to which higher priority writes have been made.<br><br><br><br><br>
16.	The partition control circuit of claim 13, wherein the pointer controller is configured to initialize the first and second write pointers to be equal, advance the first and second write pointers responsive to making higher and lower priority writes, respectively, and additionally advance the second write pointer as needed to prevent the first write pointer from passing the second write pointer.<br>
17.	The partition control circuit of claim 16, wherein the pointer controller is configured to wrap the second write pointer back from a maximum pointer value to a current value of the first write pointer, or to a value corresponding to a defined offset from the current value of the first write pointer.<br>
18.	The partition control circuit of claim 16, wherein the pointer controller is configured to saturate the first write pointer at a maximum pointer value, or at a defined offset from the maximum pointer value.<br>
19.	The partition control circuit of claim 13, wherein the pointer controller is configured to initialize the first write pointer to a first value, initialize the second write pointer to a second value offset from the first value, advance the first write pointer toward the second write pointer responsive to making higher priority writes into the cache memory, advance the second write pointer toward the first write pointer responsive to making lower priority writes into the cache memory, and retreat the second write pointer as needed to prevent the first write pointer from passing the second write pointer.<br>
20.	The partition control circuit of claim 13, wherein the first and second pointers are generally configured to move in the same direction relative to the cache memory, and wherein the pointer controller is configured to move the second write pointer as needed to prevent the first write pointer from passing the second write pointer.  <br>
WO 2007/035904	PCT/US2006/036938<br>
21.	The partition control circuit of claim 13, wherein the first and second write pointers are generally configured to move toward each other, and wherein the pointer controller is configured to move the second write pointer as needed to prevent the first write pointer from passing the second write pointer.<br>
22.	The partition control circuit of claim 13, wherein the first write pointer comprises a locked write pointer and the second write pointer comprises an unlocked write pointer.<br>
23.	A microprocessor including a partition control circuit configured to manage cache memory partitioning, said partition control circuit comprising:<br>
a first write pointer for making higher priority writes into a cache memory, and a second write pointer for making lower priority writes into the cache memory; and<br>
a pointer controller configured to use the first write pointer as a delimiter for the lower priority writes.<br>
24.	The microprocessor of claim 23, wherein the cache memory comprises a set<br>
associative cache memory, and wherein the partition control circuit comprises a pair of<br>
first and second write pointers for each set of the set associative cache memory,<br>
enabling the partition control circuit to manage higher and lower priority partitions in<br>
each set.<br><br><br><br><br>
ABSTRACT<br>
"METHOD AND APPARATUS FOR MANAGING CACHE PARTITIONING"<br>
A method of managing cache partitions provides a first pointer for higher priority writes and a second pointer for lower priority writes, and uses the first pointer to delimit the lower priority writes. For example, locked writes have greater priority than unlocked writes, and a first pointer may be used for locked writes, and a second pointer may be used for unlocked writes. The first pointer is advanced responsive to making locked writes, and its advancement thus defines a locked region and an unlocked region. The second pointer is advanced responsive to making unlocked writes. The second pointer also is advanced (or retreated) as needed to prevent it from pointing to locations already traversed by the first pointer. Thus, the first pointer delimits the unlocked region and allows the locked region to grow at the expense of the unlocked region.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtYWJzdHJhY3QuZG9j" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-abstract.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtQ0xBSU1TKEFNRU5ERUQpLSgxNy05LTIwMTQpLnBkZg==" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-CLAIMS(AMENDED)-(17-9-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtQ0xBSU1TKEFNRU5ERUQpLSgyNi0xMi0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-CLAIMS(AMENDED)-(26-12-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtQ0xBSU1TKE1BUktFRCBDT1BZKS0oMTctOS0yMDE0KS5wZGY=" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-CLAIMS(MARKED COPY)-(17-9-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtY2xhaW1zLmRvYw==" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-claims.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtQ09SUkVTUE9OREVOQ0UgMTItNi0yMDA4LnBkZg==" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-CORRESPONDENCE 12-6-2008.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtY29ycmVzcG9uZGVuY2UoMTItNi0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-correspondence(12-6-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtQ09SUkVTUE9OREVOQ0UoMTUtNy0yMDE0KS5wZGY=" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-CORRESPONDENCE(15-7-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtQ09SUkVTUE9OREVOQ0UoMTctOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-CORRESPONDENCE(17-9-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtQ09SUkVTUE9OREVOQ0UoMjItNy0yMDEzKS5wZGY=" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-CORRESPONDENCE(22-7-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtQ09SUkVTUE9OREVOQ0UoMjYtMTItMjAxMykucGRm" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-CORRESPONDENCE(26-12-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtQ09SUkVTUE9OREVOQ0UoNS03LTIwMTIpLnBkZg==" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-CORRESPONDENCE(5-7-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtQ09SUkVTUE9OREVOQ0UoOC04LTIwMTQpLnBkZg==" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-CORRESPONDENCE(8-8-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtY29ycmVzcG9uZGVuY2UtcmVjZWl2ZWQucGRm" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-correspondence-received.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtRFJBV0lORygyNi0xMi0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-DRAWING(26-12-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtRk9STSAxKDI2LTEyLTIwMTIpLnBkZg==" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-FORM 1(26-12-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtRk9STSAxMygyNi0xMi0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-FORM 13(26-12-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtZm9ybSAyKHRpdGxlIHBhZ2UpLSgxMC00LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-form 2(title page)-(10-4-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtRk9STSAyNigyNi0xMi0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-FORM 26(26-12-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtZm9ybSAzKDEwLTQtMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-form 3(10-4-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtRk9STSAzKDE3LTktMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-FORM 3(17-9-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtRk9STSAzKDUtNy0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-FORM 3(5-7-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtZm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtZm9ybS0xOC5wZGY=" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtZm9ybS0yLmRvYw==" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-form-2.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtZm9ybS0yLnBkZg==" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtZm9ybS0yNi5wZGY=" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtZm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtZm9ybS1wY3QtaWItMzA0LnBkZg==" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-form-pct-ib-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtUEVUSVRJT04gVU5ERVIgUlVMRS0xMzcoMjYtMTItMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-PETITION UNDER RULE-137(26-12-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtUkVQTFkgVE8gRVhBTUlOQVRJT04gUkVQT1JUKDI2LTEyLTIwMTIpLnBkZg==" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-REPLY TO EXAMINATION REPORT(26-12-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtUkVQTFkgVE8gSEVBUklORygxNy05LTIwMTQpLnBkZg==" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-REPLY TO HEARING(17-9-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLU1VTU5QLTIwMDgtVVMgRE9DVU1FTlQoMjYtMTItMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">701-MUMNP-2008-US DOCUMENT(26-12-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzAxLW11bW5wLTIwMDgtd28gaW50ZXJuYXRpb25hbCBwdWJsaWNhdGlvbiByZXBvcnQoMTAtNC0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">701-mumnp-2008-wo international publication report(10-4-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="262954-fireproof-composition.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="262956-tensioner-device.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>262955</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>701/MUMNP/2008</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>40/2014</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>03-Oct-2014</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>25-Sep-2014</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>10-Apr-2008</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 MOREHOUSE DRIVE, SAN DIEGO, CALIFORNIA 92121,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>STEMPEL, BRIAN, MICHAEL</td>
											<td>1309 WELLWATER COURT, RALEIGH, NORTH CAROLINA 27614</td>
										</tr>
										<tr>
											<td>2</td>
											<td>DIEFFENDERFER, JAMES, NORRIS</td>
											<td>4000 INKBERRY COURT, APEX, NORTH CARLOLINA 27539</td>
										</tr>
										<tr>
											<td>3</td>
											<td>BRIDGES, JEFFREY, TODD</td>
											<td>3513 TIMBERWOOD COURT, RLEIGH NORTH CAROLINA 27606</td>
										</tr>
										<tr>
											<td>4</td>
											<td>SARTORIUS, THOMAS, ANDREW</td>
											<td>1600 OLDE CHEIMNEY COURT, RALEIGH NORTH CAROLINA 27614</td>
										</tr>
										<tr>
											<td>5</td>
											<td>SMITH, RODNEY, WAYNE</td>
											<td>1400 BASCOMB DRIVE, RALEIGH, NORTH CAROLINA 27617</td>
										</tr>
										<tr>
											<td>6</td>
											<td>CLANCY, ROBERT, DOUGLAS</td>
											<td>8800 NARRON COURT, RALEIGH, NORTH CAROLINA 27617</td>
										</tr>
										<tr>
											<td>7</td>
											<td>AUGSBURG, VICTOR, ROBERTS</td>
											<td>304 VERSAILLES DRIVE, CARY, NORTH CAROLINA 27511</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F12/12</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2006/036938</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2006-09-21</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/233,575</td>
									<td>2005-09-21</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/262955-method-and-apparatus-for-managing-cache-partitioning by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 02:53:15 GMT -->
</html>
