<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/272497-method-and-device-for-performing-user-defined-clipping-in-object-space by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:46:50 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 272497:“METHOD AND DEVICE FOR PERFORMING USER-DEFINED CLIPPING IN OBJECT SPACE”</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">“METHOD AND DEVICE FOR PERFORMING USER-DEFINED CLIPPING IN OBJECT SPACE”</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method and device for performing and processing user-defined clipping in object space to reduce the number of computations needed for the clipping operation. The method and device also combine the modelview transformation of the vertex coordinates with projection transform. The user-defined clipping in object space provides a higher performance and less power consumption by avoiding generation of eye coordinates if there is no lighting. The device includes a driver for the user-defined clipping in the object space to perform dual mode user-defined clipping in object space when a lighting function is disabled and in eye space when the lighting function is enabled.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>METHOD AND DEVICE FOR PERFORMING USER-DEFINED CLIPPING IN OBJECT SPACE<br><br>
BACKGROUND OF THE INVENTION<br><br>
1. Field of the Invention<br><br>
[0001] This invention relates to three-dimensional graphics processing.<br><br>
2. Background<br><br>
[0002] In general, three-dimensional (3D) graphics applications display<br><br>
3D objects in a two-dimensional (2D) space (e.g., a display screen). The pixels in a 2-dimensional graphic have the properties of position, color, and brightness. On the other hand, a 3D pixel adds a depth property that indicates where the point lies on an imaginary Z-axis. Texture is created as 3D pixels are combined, each with its own depth value.<br><br>
[0003] Converting information about 3D objects into a bit map that can be displayed is known as rendering, and requires considerable memory and processing power. In the past, 3D graphics was available only on powerful workstations, but now 3D graphics accelerators are commonly found in personal computers (PC). The graphics accelerator contains memory and a specialized microprocessor to handle many of the 3D rendering operations. Open GL® (Open Graphics Library) for desktops defines an application programming interface (API) for writing applications that produce 3D and 2D computer graphics. The API includes hundreds of functions for drawing complex three- dimensional scenes from primitives.<br><br>
[0004] User-defined clip planes permit for efficient early culling of non- visible polygons - increasing performance and saving power. The user-defined <br><br>
clipping is usually done in hardware in the PC graphics systems. It is relatively a new feature in handheld devices. OpenGL® ES is a subset of the desktop OpenGL which creates an interface between software and graphics. Furthermore, user-defined clipping is either done in software or in hardware in mobile phones. If user-defined clipping is done in software, user-defined clipping is usually done in eye coordinates. Vertices (vertex coordinates) are first transformed from object space into eye space. The transformed vertices are tested against the user-defined clipping planes in eye space. Vertices are assembled into primitives. If a primitive partially lies in the half-space of a clipping plane, the primitive will be clipped by the clipping plane. However, numerous computations are needed to transform the numerous vertices from the object space to the eye space.<br><br>
[0005] For example, in 3D graphics applications, such as OpenGL® ES or OpenGL®, a user can specify multiple clipping planes. A clipping plane is an arbitrary plane in 3D space. Each plane defines a half-space. Any object or any portion of the object will be clipped if it does not lie in the half-space. Any object in the scene will be tested against all the clipping planes. This process is called user-defined clipping. Another type of clipping is called frustum clipping that clips objects against the eye frustum. Frustum clipping will not be described herein.<br><br>
[0006] A current challenge is to implement the user-defined clipping using a 3D software engine found in a hand-held 3D imaging device without poor performance. The hand-held 3D imaging devices have limited battery power and processing capability. A significant number of computations are needed to <br><br>
transform a lot of vertices from the object space to the eye space, these computations reduce the performance of the 3D imaging device. [0007] In a conventional user-defined clipping process in eye space shown in FIG. 1 , such as provided by the OpenGL® ES engine, the vertex object coordinates, denoted as V_obj, of step S22 are transformed using a modelview transformation process at step S24. At step S24 the vertex object coordinates V_obj are converted into eye space to form vertex eye coordinates, denoted as V_eye, where the vertex object coordinates V_obj are multiplied by the modelview matrix M for the coordinates. The vertex eye coordinates V_eye are subjected to primitive assembling at one of steps S28 (if a polygon), S30 (if a line segment) and S32 (if a point). The primitive assembling for a polygon at step S28 and for a line segment at step S30 are further subjected to a flat shading process at step S34. If the shade model is flat shading, then the color of each vertex will be replaced with the color of the last vertex of the triangle or line. The output from the flat shading process of step S34 or the point assemble process of step S32 are subjected to the user-defined clipping process in eye space at step S40, if enabled. Enabling the clipping process at step S40 will be described in detail later.<br><br>
[0008] The primitives can be a polygon, a line segment or point and can be clipped using a conventional user-defined clipping process shown in FIG. 1. These primitives can be clipped against a user clip plane at step S40. In clip coordinates, the view volume of step S44 is defined by<br><br>
-Wc = Xc = Wc<br><br>
-Wc = yc = Wc<br><br>
-Wc = Zc = Wc<br><br>
where xc, yc and zc are clip coordinates. <br><br>
[0009] The view volume can be further restricted by as many as n user- defined clip planes to generate the clip volume wherein n is an implementation dependent. Each user-defined plane specifies a half-space. The clip volume is the intersection of all such half-spaces with the view volume (Step S44). It should be noted that in ordinary OpenGL, user clipping can be done in either eye space or in the projection space. However, step S44 assumes that it is done in projection space. However, if no user-defined clip planes are enabled at step S38, the clip volume is the view volume at step S44. Hence, the output from the Flat shading process S34 (if the primitive is a polygon or a line segment) or the point assemble process of step S32 are subjected to a projection transform at step S42 without the user-defined clipping process of step S40. [0010] A user-defined clip plane is specified at step S12 with the function<br><br>
ClipPlane (plane, eqn[4] ) where the value of the first argument, plane, is a symbolic constant, CLIP_PLANEi, where i is an integer between 0 and n-1 , indicating one of n user-defined clip planes; and eqn[4] is an array of four single-precision floatingpoint values. (OpenGL® requires double precision floating points.) The four single-precision floating-point values are the coefficients of a plane equation P of step S14 in object coordinates, denoted as p1 , p2, p3 and p4. The current modelview matrix, denoted as Mc, is stored for the clip plane P at step S18. The inverse of the current modelview matrix Mc for the clip plane P is obtained or calculated at step S20 via an inverse matrix process. The resultant inverse matrix is denoted as lnv_Mc. The lnv_Mc is applied to these coefficients via <br><br>
multiplication, at the time they are specified at step S16, yielding P_eye as follows:<br><br>
P_eye = (p'i p'2 p's p'4) = (Pi P2 Ps P4) Mc"1 where Mc is the current modelview matrix; Mc"1 is the lnv_Mc; the resulting plane equation is undefined if Mc is singular and may be inaccurate if Mc is poorly-conditioned; and P_eye is the plane equation coefficients in eye coordinates at step S16 which is followed by step S40. At step S40, all points with eye coordinates (xe ye ze we)t that satisfy<br><br>
P_eyet * V_eye &gt;= 0 or<br><br>
(P'i * Xe + P'2* Ye + P's* Ze + p'4 * We ) &gt;= 0 lie in the half-space defined by the plane; points that do not satisfy this condition do not lie in the half-space where T is a transpose; and * denotes multiplication of a matrix or vector.<br><br>
[0011] At step S36, the user-defined clip planes are enabled with an<br><br>
Enable command. Alternately, the clipping could be disabled with the Disable command. At step S38, a determination is made whether the user- defined clip planes are enabled or disabled. If the determination is "YES" (meaning enabled), the output from the flat shading process S34 (if a polygon or line segment assemble of step S28 or S30) or the point assemble process S32 is subject to clipping at step S40 in eye space. The value of the argument to either command is CLIP_PLANEi where i is an integer between 0 and n; specifying a value of i enables or disables the plane equation with index i. The constants obey ClipPlane I = ClipPlaneO+i.<br><br>
[0012] Regarding step S32, if the primitive under consideration is a point, then clipping passes the primitive unchanged if the primitive lies within the clip <br><br>
volume; otherwise, the primitive is discarded. If the primitive is a line segment at step S30, then clipping does nothing to the primitive if the primitive lies entirely within the clip volume and discards the primitive if it lies entirely outside the volume. If part of the line segment lies in the volume and part lies outside, then the line segment is clipped and new vertex coordinates are computed for one or both vertices. A clipped line segment endpoint lies on both the original line segment and the boundary of the clip volume.<br><br>
[0013] The clipping process at step S40 yields a value, 0 = t = 1 , for each clipped vertex. If the coordinates of a clipped vertex are D and the original vertices' coordinates are D1 and D2, then t is given by<br><br>
D = t D1 + (1 + t)D2 where the value of t is used in color and texture coordinate clipping o o [0014] If the primitive is a polygon at step S28, then the primitive is passed if every one of its edges lies entirely inside the clip volume and is either clipped or discarded otherwise. Polygon clipping may cause polygon edges to be clipped, but because polygon connectivity must be maintained, these clipped edges are connected by new edges that lie along the clip volume's boundary. Thus, clipping may require the introduction of new vertices into a polygon. Edge flags are associated with these vertices so that edges introduced by clipping are flagged as boundaries (edge flag TRUE), and so that original edges of the polygon that become cut off at these vertices retain their original flags. [0015] If it happens that a polygon intersects an edge of the clip volume's boundary, then the clipped polygon must include a point on this boundary edge. This point must lie in the intersection of the boundary edge and the convex hull of the vertices of the original polygon. <br><br>
[0016] A line segment or polygon whose vertices have wc values of differing signs may generate multiple connected components after clipping. Some implementations are not required to handle this situation. That is, only the portion of the primitive that lies in the region of wc &gt; 0 need be produced by clipping.<br><br>
[0017] Primitives rendered with clip planes must satisfy a complementarily criterion. Suppose a single clip plane with coefficients (p'i p'2 p'3 p'4) (or a number of similarly specified clip planes) is enabled and a series of primitives are drawn. Next, suppose that the original clip plane is re-specified with coefficients (-p'i -p'2 -p'3 -p'4) (and correspondingly for any other clip planes) and the primitives are drawn again. In this case, primitives must not be missing any pixels, nor may any pixels be drawn twice in regions where those primitives are cut by the clip planes.<br><br>
[0018] Clipping requires plane equations (each consisting of four single- precision floating-point coefficients) and corresponding bits indicating which of these user-defined plane equations are enabled. In the initial state, all user- defined plane equation coefficients are zero and all planes are disabled. [0019] In view of the above description of the user-defined clipping process in eye space, there is a need to reduce the computations for user- defined clipping in 3D imaging devices having a 3D graphics software and/or hardware engine.<br><br>
[0020] There is also a need to perform the user-defined clipping in the object space to avoid transforming vertices from the object space into the eye space. Most cases in 3D gaming content processing require less computation <br><br>
to transform a few user-defined clip planes from the eye space to the object space than to transform a lot of vertices from the object space to the eye space. [0021] Furthermore, there is a need to avoiding generation of eye coordinates if lighting is disabled.<br><br>
SUMMARY OF THE INVENTION<br><br>
[0022] In view of the above, it is an object of the present invention to provide for user-defined clipping in object space which consumes less power in a mobile or hand-held communication or computing device with limited power capability.<br><br>
[0023] A further object of the present invention is to provide the user- defined clipping in the object space to avoid transforming vertices from the object space into the eye space to reduce the number of computations ordinarily required by user-defined clipping in the eye space. [0024] A further object of the present invention is to provide in most of the cases in 3D gaming contents, less computations to transform a few user- defined clip planes from the eye space to the object space than required to transform a lot of vertices from the object space to the eye space. [0025] The foregoing and other objects of the present invention are carried out by an object space user-defined clipping driver comprising: a primitive assembling module operable to primitive assemble vertex coordinates in object space; and a user-defined clipping module operable to create clipped vertex coordinates in the object space using clip planes (P_obj) in the object space and the primitive assembled vertex coordinates in the object space. <br><br>
[0026] The clipped and non-clipped vertex coordinates in the object space are transformed from the object space directly into projection space by one vector to matrix multiplication. When lighting is disabled and user-defined clipping is disabled or enabled, the two transforms (modelview and projection) can be combined into one 4x4 matrix rather than into two 4x4 matrices. [0027] The driver may be implemented in software, hardware or a combination of hardware and software.<br><br>
[0028] Alternatively, the clipped vertex coordinates in the object space are not transformed from the object space to the eye space until immediately before projection transformation.<br><br>
[0029] A further aspect of the present invention is to provide a program code executable by a processor and having program instructions which upon execution are operable to primitive assemble vertex coordinates in object space. The code is also operable to perform user-defined clipping to create clipped vertex coordinates in the object space using clip planes (P_obj) in the object space and the primitive assembled vertex coordinates in the object space.<br><br>
[0030] A further aspect of the present invention is to provide a 3D graphics engine comprising an object space user-defined clipping driver operable to perform user-defined clipping of vertex coordinates in object space when a lighting function is disabled in the 3D graphics engine. The 3D graphics engine also includes a graphics core for transforming the clipped vertex coordinates in the object space into projection space.<br><br>
[0031] A still further aspect of the present invention is to provide a program code having program instructions executable by a processor, wherein <br><br>
upon execution the program instructions are operable to perform vertex coordinate processing of vertex coordinates in eye space when lighting is enabled and perform vertex coordinate processing of vertex coordinates in object space when lighting is disabled.<br><br>
[0032] The program instructions operable to perform the vertex processing in the object space is operable to perform primitive assembling in the object space using the vertex coordinates in the object space and user- defined clipping in object space.<br><br>
[0033] The program instructions operable to perform the vertex processing in the eye space is operable to perform primitive assembling in the eye space using the vertex coordinates in the eye space and user-defined clipping in eye space.<br><br>
[0034] A still further aspect of the present invention is to provide a 3D imaging device comprising determining means for determining whether a lighting function is enabled or disabled, eye space processing means for processing vertex coordinates in eye space when the lighting function is enabled, and object space processing means for processing vertex coordinates in object space when the lighting function is disabled.<br><br>
[0035] The object space processing means performs primitive assembling in the object space using the vertex coordinates in the object space and user-defined clipping in the object space.<br><br>
[0036] The eye space processing means performs primitive assembling in the eye space using the vertex coordinates in the eye space and user-defined clipping in the eye space. <br><br>
[0037] The object space processing means includes means for transforming into projection space clipped and non-clipped vertex coordinates in the object space directly by one vector to matrix multiplication. When lighting is disabled and user-defined clipping is disabled or enabled, the two transforms (modelview and projection) can be combined into one matrix rather than into two matrices.<br><br>
[0038] A further aspect of the present is a method for processing object space user-defined clipping comprising the steps of: converting clip planes (P_eye) in eye space to clip planes (P_obj) in object space; and performing user-defined clipping to create clipped vertex coordinates in the object space using the clip planes (P_obj) in the object space and the vertex coordinates in the object space.<br><br>
[0039] A still further aspect of the present invention is a method for dual mode processing user-defined clipping comprising the steps of: determining whether a lighting function is enabled or disabled; performing object space vertex coordinate processing with object space user-defined clipping to create clipped vertex coordinates in object space when the lighting function is disabled; and performing eye space vertex coordinate processing with eye space user- defined clipping to create clipped vertex coordinates in eye space when the lighting function is enabled;<br><br>
[0040] The method for dual mode processing user-defined clipping further comprises the step of: transforming the clipped vertex coordinates in the object space and non-clipped vertex coordinates in the object space directly into projection space. <br><br>
[0041] An advantage of the present invention is higher performance and less power consumption by avoiding generation of eye coordinates if lighting is disabled.<br><br>
BRIEF DESCRIPTION OF THE DRAWINGS<br><br>
[0042] The foregoing summary, as well as the following detailed description of preferred embodiments of the invention, will be better understood when read in conjunction with the accompanying drawings. For the purpose of illustrating the invention, there is shown in the drawings embodiments which are presently preferred. It should be understood, however, that the invention is not limited to the precise arrangement shown. In the drawings: [0043] FIG. 1 illustrates a flow diagram of a conventional user-defined clipping process in eye space;<br><br>
[0044] FIG. 2 illustrates a flowchart of a conventional vertex process pipeline with user-defined clipping in eye space;<br><br>
[0045] FIG. 3 illustrates a flow diagram of a user-defined clipping process in object space according to the present invention;<br><br>
[0046] FIG. 4 illustrates a flowchart of a vertex process pipeline with user- defined clipping in object space according to the present invention; [0047] FIG. 5A illustrates a block diagram of a three-dimensional (3D) imaging device with an object space user-defined clipping driver implemented in software according to the present invention;<br><br>
[0048] FIG. 5B illustrates a block diagram of a three-dimensional (3D) imaging device with an object space user-defined clipping driver implemented in hardware according to the present invention; <br><br>
[0049] FIG. 6 illustrates a block diagram of stored items in the storage unit of the devices in FIGS. 5A or 5B;<br><br>
[0050] FIG. 7A illustrates a general block diagram of the object space user-defined clipping driver of the device in FIG. 5A;<br><br>
[0051] FIG. 7B illustrates a general block diagram of the object space user-defined clipping driver of the device in FIG. 5B; and [0052] FIG. 8 illustrates a flowchart of the dual mode user-defined clipping method according to the present invention.<br><br>
DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS [0053] While this invention is susceptible of embodiments in many different forms, this specification and the accompanying drawings disclose only some forms as examples of the use of the invention. The invention is not intended to be limited to the embodiments so described, and the scope of the invention will be pointed out in the appended claims.<br><br>
[0054] The preferred embodiment of the 3D imaging device according to the present invention is described below with a specific application to a method for user-defined clipping in object space. The 3D imaging device may be a personal computer (PC) 3D graphics system, a handheld computing device such as a personal digital assistant (PDA), or a mobile phone which employs a 3D graphics application. However, it will be appreciated by those of ordinary skill in the art that the present invention is also well adapted for other types of computing devices with 3D graphics applications such for Game applications, simulator graphics and virtual reality graphics. The present invention <br><br>
implementation is suited for a user-defined clipping process in a 3D software engine.<br><br>
[0055] Referring now to the drawings in detail, wherein like numerals are used to indicate like elements throughout, there is shown in FIG. 3 an embodiment of a method for user-defined clipping in object space, generally designated at 100, according to the present invention.<br><br>
[0056] As best shown in Fig. 4, the method for user-defined clipping in object space 100 includes a vertex process pipeline 150 with user-defined clipping in object space when lighting is disabled. The method 100 identifies data for vertex object coordinates, denoted as V_obj, at step S112. Thereafter, the vertex object coordinates V_obj are subjected to primitive assembling at one of steps S118 (if a polygon), S120 (if a line segment) and S122 (if a point). The primitive assembling for a polygon at step S118 and for a line segment at step S120 are subjected to a flat shading process at step S124. If the shade model is flat shading, then the color of each vertex will be replaced with the color of the last vertex of the triangle or line. The output from the flat shading process of step S124 or the point assemble process of step S122 is subjected to the user- defined clipping process if enabled by step S126.<br><br>
[0057] The view volume may be further limited by as many as n user- defined clip planes to generate the clip half-space in the clipping process S130 wherein n is implementation dependent. Each user-defined plane specifies a half-space. The clip volume is the intersection of all such half-spaces with the view volume (Step S134). However, if no user-defined clip planes are enabled at step S126, the clip volume is the view volume at step S134 (subject to combined modelview and projection transformation). <br><br>
[0058] Clipping requires plane equations (each consisting of four single- precision floating-point coefficients) and corresponding bits indicating which of these user-defined plane equations are enabled. In the initial state, all user- defined plane equation coefficients are zero and all planes are disabled. [0059] Step S128 is followed by step S132, if the clip plane is disabled.<br><br>
At step S132, the output from the Flat shading process S124 (if the primitive is a polygon or a line segment) or the point assemble process of step S122 are subjected to both Modelview and projection transform at step S132 without the user clipping of step S130. Step S132 is followed by step S134 where a view volume clipping process takes place defined by<br><br>
-Wc = Xc = Wc<br><br>
-Wc = yc = Wc<br><br>
-Wc = Zc = Wc<br><br>
where xc, yc and zc are clip coordinates. Step S134 ends the method 100. [0060] Referring now to FIG. 2, in the conventional vertex process pipeline 50 with user-defined clipping in eye space, the pipeline 50 includes vertex object coordinates of step S22 which is followed by step S24. At step S24, a modelview transformation process takes place where the vertex object coordinates in object space are converted to eye space. Thereafter, step S24 is followed by primitive assembling process S27 which includes, in general, steps S28, S30, S32 and S34. The primitive assembling process S27 is followed by the user clipping process S40 (assuming clipping is enabled) which in turn is followed by a projection transformation process at step S42. Step S42 is followed by step S44 where a process for view volume clipping can take place. Step S44 ends the pipeline 50. <br><br>
[0061] On the other hand, the vertex process pipeline 150 with user- defined clipping in object space is split, as best seen in FIG. 4, wherein the driver 218A (FIG. 7A) performs the primitive assembling in object space at step S117 followed by a user-defined clipping process in object space at step S131 (assuming that an enable command has been received). Step S117 includes steps S118, S120, S122 and S124 and step S131 includes steps S102, S104, S106, S108, S110, S114, S116, S126, S128 and S130. A 3D graphics engine 220 may be implemented as a software graphic engine or a hardware graphics engine and provides the Graphics Core. The 3D graphics engine 220A is shown separate from the program instructions 216A but would include suitable program instructions (not shown). In the embodiment shown in FIG. 4, FIG. 5A and FIG. 7A, the driver 218A is generally implemented as software. In the 3D graphics engine 220A, the vertex object coordinates of step S112' are still in object space but are clipped vertex object coordinates, denoted as CV_obj, and need to be transformed to projection space vertex coordinates using a combined modelview and projection transformation process of step S132, as will be described in more detail later using a single matrix such as a single 4x4 matrix. Some vertex coordinates (V_obj ) passing through the user clipping step S131 are not clipped as the result of a plane being disabled (Step S128 to S132) or if the condition in step S130 is not met. These vertex coordinates are non-clipped vertex coordinates (V_obj) in the object space. Thus, the vertex coordinates of step S112' may provide data that is both CV_obj and V_obj to step S 132<br><br>
[0062] Alternately, the combined modelview and projection transformation process S132 may include a two step process denoted at steps <br><br>
S132A (shown in phantom) which uses the same equation as step S24 of FIG. 1. The modelview transform of step S132A is the same as the modelview transformation at step S24. Step S132A converts the clipped vertex object coordinates into eye space immediately before the projection transformation process of step S132B (shown in phantom). This two step process requires two (2) separate matrices. Step S132 or S132B is followed by the view volume clipping process of step S134.<br><br>
[0063] Referring now to the combined modelview and projection transformation process of step S132, assume the following:<br><br>
V_eye = V_obj * MVT_matrix where MVTjnathx is the modelview transform matrix. Since V_eye for user clipping is not used, MVTjnatrix and Projectionjnathx are combined into one matrix, MVTPRJjnatrix. Projection coordinates can be calculated as<br><br>
V_prj = CV_obj * MVTPRJ_matrix or<br><br>
V_prj = V_obj * MVTPRJ_matrix where CV_obj is the clipped vertex coordinates in the object space; and V_obj are non-clipped vertex coordinates in object space; V_prj is the all vertex coordinates in projection space; and MVTPRJjnatrix is the combined MVTjnatrix and Projection jnatrix.<br><br>
[0064] The pipeline 150 performs the user-defined clipping in the object space to avoid transforming vertices from the object space into the eye space. In most of the cases in 3D gaming contents, pipeline 150 requires less computation to transform a few user-defined clip planes from the eye space to the object space than to transform a lot of vertices from the object space to the eye space. <br><br>
[0065] Moreover, in the pipeline 150, the modelview transform can be combined with the projection transform denoted at step S132. In this case, after the user-defined clipping process of step S131 , clipped vertex coordinates are transformed from the object space directly into the projection space by one vector to matrix multiplication rather than two. In ordinary OpenGL®, two transformations may be combined when both lighting and user-defined clipping are disabled. In the exemplary embodiment, the two transformations can be combined as long as lighting is disabled. Thus, user-defined clipping can be either disabled or enabled. As can be appreciated, using a single matrix reduces the computations to achieve the clipped vertex coordinates into projection space.<br><br>
[0066] Referring again to FIG.3, the user can specify multiple clipping planes at step S102. A clipping plane is an arbitrary plane in 3D space. Each plane defines a half-space. In the user-defined clipping, any object or any portion of the object will be clipped if it does not lie in the half-space. Any object in the scene will be tested against all the clipping planes. [0067] At step S102, a user-defined clip plane is specified by calling a function with<br><br>
ClipPlane (plane, eqn[4] ) where the value of the first argument, plane, is a symbolic constant, CLIP_PLANEi, where i is an integer between 0 and n-1 , indicating one of n user-defined clip planes; and eqn[4] is an array of four floating-point values. The four floating-point values are the coefficients of a plane equation P of step S104 in object coordinates denoted as pi, p2, P3 and p4. The current modelview matrix, denoted as Mc, is stored for a clip plane at step S108. The inverse of <br><br>
the current modelview matrix Mc for a clip plane is obtained or calculated at step S110 via an inverse matrix process. The inverse matrix is denoted as lnv_Mc. The lnv_Mc is applied to these coefficients via multiplication, at the time they are specified at step S106, yielding P_eye defined by P_eye = (p'i p'2 p's p'4) = (Pi P2 Ps P4) Mc"1 where Mc is the current modelview matrix; Mc"1 is the inverse of the matrix Mc denoted as lnv_Mc; the resulting plane equation is undefined if Mc is singular and may be inaccurate if Mc is poorly-conditioned; and P_eye is the plane equation coefficients in eye coordinates.<br><br>
[0068] The plane equation coefficients in eye space P_eye of the step<br><br>
S106 are converted to object space at step S114 using modelview matrix coordinates M. The modelview matrix coordinates M of step S116 is the same as the matrix coordinates of step S26. Furthermore, with regard to step S132A, the modelview transformation can be the same as step S26. The conversion of the plane equation coefficients in eye space to object space is defined by<br><br>
P_obj = (P' 1 p'2 p's P'4)TM or P_obj = P_eyeT*M = (poi pO2 Pos P04) where P_obj is the plane equation coefficients in object space; T represents the transpose of the matrix or vector; and * represents matrix multiplication. [0069] Step S114 is followed by step S130, where all points with vertex object coordinates V_obj = (x0 y0 z0 w0) that satisfy<br><br>
P_objt * V_obj &gt;= 0 lie in the half-space defined by the plane; points that do not satisfy this condition do not lie in the half-space. <br><br>
[0070] At step S126, the user-defined clip planes are enabled with an<br><br>
Enable command. Alternately, the user could disable clip planes with the Disable command. At step S128, a determination is made whether the user- defined clip planes are enabled or disabled. If the determination is "YES" (meaning enabled), the output from the flat shading process S124 (if a polygon or line segment assemble of step S118 or S120) or the point assemble process S122 is subject to clipping at step S130 in object space. The value of the argument to either command is CLIP_PLANEi where i is an integer between 0 and n; specifying a value of i enables or disables the plane equation with index i. The constants obey ClipPlane i = ClipPlaneO+i.<br><br>
[0071] Referring now to step S130, the user-defined clipping process is applied in the object space, rather than in the eye space. Instead of transforming all vertex coordinates from object space to eye space for clipping, the user-defined clip planes specified at step S104 are transformed from eye space to object space and clipping is applied thereto. In this way, the computations required in transforming of the multiple vertex coordinates is replaced by less computations to transform the clip planes at step S106 to object space. In the most of the cases, the amount of vertex coordinates is much larger than amount of user-defined clip planes specified. By moving user- defined clipping to the object space, many computation cycles are saved, and thus, power consumption in mobile or hand-held devices with 3D imaging capability were reduced.<br><br>
[0072] Conventional user clipping in eye space is determined by P_eye t<br><br>
* V_eye. According to following transformation, <br><br>
P_eyet * V_eye = P_eyet * (M * V_obj) = (P_eyet * M) * V_obj = P_objt* V_obj<br><br>
where P_objt = P_eyet * M.<br><br>
[0073] Thus, user clipping process of step S130 can be done with<br><br>
P_objt* V_obj, which is key to the method 100.<br><br>
[0074] Since the vertex based lighting process is based on vertices in the eye space, the method 100 to perform clipping in object space will not be applicable to save computation when lighting is enabled. Instead, the conventional method 10 should be used if lighting is enabled. In OpenGL® and OpenGL® ES have an application programming interface (API) to enable and disable lighting such as using glEnable(GLenum, array).<br><br>
[0075] Referring now to FIG. 8, the dual mode user-defined clipping method 160 is shown for use in 3D imaging device 200A or 200B of FIGS.5A or 5B, respectively, and begins with step S164 where a determination is made whether lighting has been disabled. If the determination at step S164 is "YES," the step S164 is followed by step S166 where the vertex processing with user- defined clipping takes place in object space in accordance with the flowcharts of FIG. 3 or FIG. 4. On the other hand, if the determination at step S164 is "NO," then step S164 is followed by step S168 where the vertex processing with user- defined clipping takes place in eye space as disclosed in FIGS. 1 and 2. Thus, the driver 218A or 218B only needs to be operational when lighting is enabled. [0076] Vertex based processing, of FIG. 4, is in inner loop of per-vertex operation in a graphics pipeline. By removing modelview transform per vertex, <br><br>
the system will process vertex data faster. Vertex-based processing processes the data per vertex. After the view volume clipping of step S134 and viewport on the screen, the processing is on a per-pixel level. Based on the data in each of the vertices of a polygon, all pixels within the polygon will be drawn/filled. The saved computation can be translated directly into power reduction. [0077] Since the user clipping is done earlier, i.e., it is done in the object space rather than in the eye space, it is possible to apply the user-defined clipping process as a pre-processing in software before sending vertex coordinates into a digital signal processor (DSP) or a hardware-based graphics core, as best seen in FIG. 4. By doing so, the complexity of the graphics pipeline in the DSP or hardware graphics core is reduced, and, it is possible to enable the user clipping feature in a pre-developed graphics system. Vertex coordinates are assembled in S117 and clipped by user-defined clip planes in S131. Clipped vertex coordinates in object are sent into the 3D graphics engine 220A for further processing at step S132 for transformation into projection space.<br><br>
POINT<br><br>
[0078] Referring now the primitive assembling of Step S117, if the primitive is a point, the Vertex object coordinates in object space S112 are V_obj. The vertex coordinates in eye space are V_eye, then<br><br>
V_eye = M * V_obj<br><br>
[0079] Any input clip plane in object space at S104 is P. ModelView transformation matrix for the clip plane in S108 is Mc. Then, the clip plane in eye space, P_eye, is <br><br>
P_eye = lnv_Mc * P.<br><br>
[0080] Transform the plane P from eye space to the point's object space at step S114 by the ModelView transformation matrix for the point, M. The clip plane in the point's object space, P_obj, is<br><br>
P_obj = P_eyeT * M.<br><br>
Then, perform clipping in the point's object space according to step S130 or S131. As a proof set forth below, P_objt * V_obj &gt;= 0 if and only if P_eyet * V_eye &gt;= 0. The Proof is defined by<br><br>
P_objt * V_obj<br><br>
= (P_eyet * M) * V_obj<br><br>
= P_eyet * (M * V_obj)<br><br>
= P_eyet * V_eye<br><br>
where vertex coordinates of the point in eye space, V_eye is transformed by the M from the coordinates in object space and is defined by<br><br>
V_eye = M * V_obj.<br><br>
LINE SEGMENT <br><br>
[0081] If the primitive is a line, the line can be described by two vertices at the ends. In object space, they are V_obj1 and V_obj2. To transform the line into eye space by ModelView transformation matrix M,<br><br>
V_eye1 = M * V_obj1 ; and V_eye2 = M * V_obj2.<br><br>
Any input clip plane in object space at S104 is P. ModelView transformation matrix for the clip plane in S108 is Mc. Then, the clip plane in eye space, P_eye, is defined by<br><br>
P_eye = lnv_Mc * P.<br><br>
[0082] Transform the plane P from eye space to the line's object space at step S114 by the ModelView transformation matrix for the line, M. The clip plane in the line's object space, P_obj, is defined by<br><br>
P_obj = P_eyeT * M.<br><br>
Then, perform the clipping in the line's object space according to step S130 or S131.<br><br>
[0083] It is obvious that the line segment lies entirely in or out of the clip volume in object space if and only if it lies entirely in or out of the clip volume in eye space. The proof to prove that the clip point computed in eye space is the same one transformed from the clip point computed in object space is set forth below.<br><br>
[0084] To proof the clip points are the same in both object space and eye space, define the clip point in object space as C_obj, and the clip point in eye space as C_eye. Assume t is a ratio of the clip point in the line clipped into the plane. In object space, then <br><br>
t_obj = P_objt * V_obj2 / (P_objt * V_obj2 + P_objt * V_obj2)<br><br>
and in eye space, t_eye = P_eyet * V_eye2 / (P_eyet * V_eye2 + P_eyet * V_eye2).<br><br>
[0085] The clip point in object space,<br><br>
C_obj = t_obj * V_obj1 +(1 - t_obj) * V_obj2.<br><br>
[0086] The clip point in eye space,<br><br>
C_eye = t_eye *V_eye1 + (1 - t_eye) * V_eye2.<br><br>
[0087] If t_eye = t_obj, the clip point in eye space should be the clip point in object space transformed by the line's ModelView transformation matrix, M. The Proof for C_eye is defined by C_eye:<br><br>
= t_eye *V_eye1 + (1 - t_eye) * V_eye2<br><br>
= t_ obj * (M * V_obj1 ) + (1 - t_obj) * (M * V_obj2)<br><br>
= M * (t_obj * V_obj1 + (1 - t_obj) * V_obj2)<br><br>
= M * C_obj.<br><br>
POLYGON<br><br>
[0088] Since each edge of the polygon is handled as a line segment as described above, if it is true for line, it is true for polygon.<br><br>
[0089] In view of the foregoing, there are three major differences between the conventional approach and the present invention. First, in the present <br><br>
invention, the vertex coordinates are not transformed from the object space to the eye space until just before projection transformation at step S132B or converted directly into projection space. Second, in the present invention, the user-defined clip planes are transformed from the eye space to the object space. Third, in the present invention, clipping is determined by IF (P_objt * V_obj)&gt;=0 instead of IF (P_eyeT * V_eye)&gt;=0.<br><br>
[0090] Referring again to FIGS. 5A and 6, the three-dimensional (3D) imaging device 200A will now be described in detail. The device 200A may be a mobile phone or other hand-held computing device with communication equipment (now shown) for permitting two-way wired or wireless communications such as a personal digital assistant (PDA), and a mobile, cellular or satellite telephone with video capability. The device 200A may be a PC, laptop or other wireless computing devices. The device 200A includes a processor 210 and display 212 for displaying the 2-D bitmap on the screen. The storage unit 214 provides the necessary storage for the vertex object coordinates 236, clipped vertex coordinates in object space (CV_obj) 236', clip planes 230, and modelview matrix for the planes 232 and coordinates 234, the projection transformation matrix 240, and MVTPRJjnatrix 242. The storage unit 214 also includes the volume clipping 238. The storage unit 214 includes one or more suitable computer readable storage medium for use in the type of device 200A.<br><br>
[0091] The device 200A further includes program instructions 216A with the object space user-defined clipping driver 218A or pre-processing stage and a 3D graphics application module 222 such as without limitation having game content for playing games, simulators, CAD, virtual reality graphics. The eye <br><br>
space user-defined clipping module 224 is software for the vertex processing with user-defined clipping in eye space shown in FIGS. 1 and 2 is integrated into the program instructions 216A for use in the dual mode user-defined clipping method 160. Nevertheless, for dual-mode operation, the eye space user-defined clipping module 224 may also be hardware. -based and would be removed from the program instructions of 216B.<br><br>
[0092] Referring now to FIG. 5B, the three-dimensional (3D) imaging device 200B depicts a hardware implementation of the object space user- defined clipping driver 218B. The device 200B like device 200A may be a mobile phone or other hand-held computing device with communication equipment (now shown) for permitting two-way wired or wireless communications such as a personal digital assistant (PDA), and a mobile, cellular or satellite telephone with video capability. The device 200B may be a PC or laptop. The device 200B includes a processor 210 and display 212 for displaying the 2-D bitmap on the screen and a storage unit 214. [0093] The device 200B further includes program instructions 216B with a 3D graphics application module 222 (shown in phantom) such as without limitation having game content for playing games, simulators, CAD, virtual reality graphics. The eye space user-defined clipping module 224 is software for the vertex processing with user-defined clipping in eye space shown in FIGS. 1 and 2 is integrated into the program instructions 216B for use in the dual mode user-defined clipping method 160.<br><br>
[0094] In the hardware implementation, the 3D graphics engine 220B integrates or interfaces with the hardware-based object space user-defined clipping driver 218B. Nevertheless, for dual-mode operation, the eye space <br><br>
user-defined clipping module 224 may also be hardware. -based and would be removed from the program instructions of 216B.<br><br>
[0095] With specific reference to FIG. 7A, the user clipping is done earlier as a pre-processing stage or driver 218A in software before sending vertex coordinates into a DSP or a hardware graphics core of the 3D graphics engine 220A. The software-based object space user-defined clipping driver 218A includes vertex object coordinates 240 in object space (shown in phantom). The driver 218A further includes a primitive assembling module 242A and an object space user-defined clipping module 244A. The primitive assembling module 242A includes a polygon assemble sub-module 242AA, a line segment assemble sub-module 242AB, a point assemble sub-module 242AC and a flat shading sub-module 242AD. The primitive assembling module 242A includes the program instructions for carrying out the processes of steps of S118, S120, S122 and S124. The driver 218A also includes a 3D graphics engine software interface 246A to interface the driver 218A with the 3D graphics engine 220A.. [0096] With specific reference to FIG. 7B, the user clipping is done as a pre-processing stage or driver 218B in hardware before sending vertex coordinates into a DSP or a hardware graphics core of the 3D graphics engine 220B. The hardware-based object space user-defined clipping driver 218B includes vertex object coordinates 240 in object space (shown in phantom). The driver 218B further includes a primitive assembling module 242B and an object space user-defined clipping module 244B. The primitive assembling module 242B includes a polygon assemble sub-module 242BA, a line segment assemble sub-module 242BB, a point assemble sub-module 242BC and a flat shading sub-module 242BD. The primitive assembling module 242B carries out <br><br>
the processes of steps of S118, S120, S122 and S124. The driver 218B also includes a 3D graphics engine hardware interface 246B to interface the driver 218B with the 3D graphics engine 220B.<br><br>
[0097] It will be appreciated by those of ordinary skill in the art that the method and device for performing user-defined clipping in object space according to the present invention has higher performance and requires less power consumption by avoiding generation of eye coordinates if there is no lighting.<br><br>
[0098] The foregoing description of the embodiments of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed, and modifications and variations are possible in light of the above teachings or may be acquired from practice of the invention. The embodiments were chosen and described in order to explain the principles of the invention and its practical application to enable one skilled in the art to utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto, and their equivalents. <br><br>
CLAIMS<br><br>
1. An object space user-defined clipping driver comprising: a primitive assembling module operable to primitive assemble vertex coordinates in object space; and a user-defined clipping module operable to create clipped vertex coordinates in the object space using clip planes (P_obj) in the object space and the primitive assembled vertex coordinates in the object space.<br><br>
2. The driver of claim 1 ; wherein the primitive assembling module includes at least one of a polygon assembling sub-module, a line assembling sub-module, and a point assembling sub-module .<br><br>
3. The driver of claim 1 ; wherein the primitive assembling module includes a polygon assembling sub-module, a line assembling sub-module, a point assembling sub-module, and a flat shading sub-module for processing an output from the polygon assembling sub-module and the line assembling sub- module.<br><br>
4. The driver of claim 1 ; further comprising a three-dimensional (3D) graphic engine interface for interfacing an output of the user-defined clipping module to a graphics core of a 3D graphics engine so that the clipped vertex coordinates in the object space can be transformed into projection space.<br><br>
5. The driver of claim 1 ; wherein the driver is implemented in software.<br><br>
6. The driver of claim 1 ; wherein the driver is implemented in hardware.<br><br>
7. The driver of claim 1 ; wherein the driver is operational when a lighting function is disabled.<br><br>
8. The driver of claim 1 ; wherein the user-defined clipping module converts clip planes (P_eye) in eye space to the clip planes (P_obj) in the object space defined by <br><br>
P_eye = lnv_Mc*P ; and<br><br>
P_obj = P_eyeT*M where P is an input clip plane; Mc is a modelview matrix for the clip plane; lnv_Mc is the inverse matrix of the Mc; M is a modelview matrix for coordinates; T is a transpose of a matrix or vector; and * denotes matrix multiplication.<br><br>
9. The driver of claim 8; wherein the user-defined clipping module performs clipping if<br><br>
P_objt * V_obj &gt;= 0 where P_obj is the clip plane in the object space to be clipped; V_obj is the vertex coordinates in the object space; T is a transpose of a matrix or vector; and * denotes matrix multiplication.<br><br>
10.An object space user-defined clipping driver comprising: primitive assembling means for primitive assembling vertex coordinates in object space; and user-defined clipping means for user-defined clipping to create clipped vertex coordinates in the object space using clip planes (P_obj) in the object space and the primitive assembled vertex coordinates in the object space.<br><br>
11. The driver of claim 10; wherein the primitive assembling means includes at least one of means for polygon assembling the vertex coordinates, means for line assembling the vertex coordinates, and means for point assembling the vertex coordinates.<br><br>
12. The driver of claim 10; further comprising means for interfacing an output of the user-defined clipping means to a graphics core of a 3D graphics engine so that the clipped vertex coordinates in the object space can be transformed into projection space.<br><br>
13. The driver of claim 10; wherein the driver is implemented in software. <br><br><br>
14. The driver of claim 10; wherein the driver is implemented in hardware. 15. The driver of claim 10; wherein the driver is operational when lighting is disabled.<br><br>
16. The driver of claim 10; wherein the user-defined clipping means includes means for converting clip planes (P_eye) in eye space to the clip planes (P_obj) in the object space defined by<br><br>
P_eye = lnv_Mc*P ; and<br><br>
P_obj = P_eyeT*M where P is an input clip plane; Mc is a modelview matrix for the clip plane; lnv_Mc is the inverse matrix of the Mc; M is a modelview matrix for coordinates; T is a transpose of a matrix or vector; and * denotes matrix multiplication.<br><br>
17. The driver of claim 16; wherein the user-defined clipping means includes means for performing clipping if<br><br>
P_objt * V_obj &gt;= 0 where P_obj is the clip plane in the object space to be clipped; V_obj is the vertex coordinates in the object space; T is a transpose of a matrix or vector; and * denotes matrix multiplication.<br><br>
18.A program code executable by a processor having program instructions which upon execution are operable to primitive assemble vertex coordinates in object space; and perform user-defined clipping to create clipped vertex coordinates in the object space using clip planes (P_obj) in the object space and the primitive assembled vertex coordinates in the object space. <br><br><br>
19. The program code of claim 18; wherein the program instructions operable to primitive assemble includes program instructions which upon execution are operable to selectively perform one of polygon assembling, line assembling, and point assembling.<br><br>
20. The program code of claim 18; wherein the program instructions are executed when a lighting function is disabled.<br><br>
21. The program code of claim 18; wherein the program instructions operable to perform the user-defined clipping includes program instructions which upon execution are operable to convert clip planes (P_eye) in eye space to the clip planes (P_obj) in the object space defined by<br><br>
P_eye = lnv_Mc*P ; and<br><br>
P_obj = P_eyeT*M where P is an input clip plane; Mc is a modelview matrix for the clip plane; lnv_Mc is the inverse matrix of the Mc; M is a modelview matrix for coordinates; T is a transpose of a matrix or vector; and * denotes matrix multiplication.<br><br>
22. The program code of claim 21 ; wherein the program instructions operable to perform the user-defined clipping includes program instructions are operable upon execution to clip if<br><br>
P_objt * V_obj &gt;= 0 where P_obj is the clip plane in the object space to be clipped; V_obj is the vertex coordinates in the object space; T is a transpose of a matrix or vector; and * denotes matrix multiplication.<br><br>
23. A 3D graphics engine comprising: an object space user-defined clipping driver operable to perform user-defined clipping of vertex coordinates in object space when a lighting function is disabled in the 3D graphics engine; and <br><br>
a graphics core for transforming the clipped vertex coordinates in the object space into projection space.<br><br>
24. The engine of claim 23; wherein the driver comprises a primitive assembling module operable to perform primitive assembling in the object space using the vertex coordinates in the object space.<br><br>
25. The engine of claim 24; wherein the primitive assembling module includes a polygon assembling sub-module, a line assembling sub-module, and a point assembling sub-module each of which is selectively operable in response to whether the vertex coordinate in the object space is a line, a point or a polygon, respectively.<br><br>
26. The engine of claim 25; wherein the primitive assembling module further includes a flat shading sub-module coupled to outputs of the polygon assembling sub-module and the line assembling sub-module.<br><br>
27. The engine of claim 23; wherein the graphics core transforms the vertex coordinates in the object space directly into the projection space by multiplying one vector to a matrix.<br><br>
28. The engine of claim 27; wherein the matrix is a combined matrix (MVTPRJjnathx) of a modelview matrix and a projection matrix wherein the result of the multiplication yields the vertex coordinates (V_pri) in the projection space defined by<br><br>
V_prj = CV_obj * MVTPRJ_matrix or V_prj = V_obj * MVTPRJ_matrix<br><br>
where CV_obj is the clipped vertex coordinates in the object space; and V_obj is non-clipped vertex coordinates in the object space. <br><br><br>
29. The engine of claim 23; wherein the driver comprises a user-defined clipping module operable to convert clip planes (P_eye) in eye space to clip planes (P_obj) in the object space defined by<br><br>
P_eye = lnv_Mc*P ; and<br><br>
P_obj = P_eyeT*M where P is an input clip plane; Mc is a modelview matrix for the clip plane; lnv_Mc is the inverse matrix of the Mc; M is a modelview matrix for coordinates; T is a transpose of a matrix or vector; and * denotes matrix multiplication.<br><br>
30. The engine of claim 29; wherein the user-defined clipping module is further operable to create clipped vertex coordinates in the object space using the clip planes (P_obj) in the object space if<br><br>
P_objt * V_obj &gt;= 0 wherein P_obj is the clip plane in the object space to be clipped; T is a transpose of a matrix or vector; and * denotes matrix multiplication.<br><br>
31. A 3D graphics engine comprising: user-defined clipping means for user-defined clipping of vertex coordinates in object space when a lighting function is disabled in the 3D graphics engine; and transforming means interfaced with the user-defined clipping means for transforming the clipped vertex coordinates in the object space into projection space.<br><br>
32. The engine of claim 31 ; wherein the user-defined clipping means comprising primitive assembling means for primitive assembling in the object space using the vertex coordinates in the object space.<br><br>
33. The engine of claim 32; wherein the primitive assembling means comprises means for polygon assembling, means for line assembling, and <br><br>
means for point assembling each of which is selectively operable in response to whether the vertex coordinate in the object space is a line, a point or a polygon, respectively.<br><br>
34. The engine of claim 33; wherein the primitive assembling means further includes means for flat shading coupled to outputs of the polygon assembling means and the line assembling means.<br><br>
35. The engine of claim 31 ; wherein the transforming means includes means for transforming the vertex coordinates in the object space directly into the projection space by multiplying one vector to a matrix.<br><br>
36. The engine of claim 35; wherein the matrix is a combined matrix (MVTPRJjnathx) of a modelview matrix and a projection matrix wherein the result of the multiplication yields the vertex coordinates (V_pri) in the projection space defined by<br><br>
V_prj = CV_obj * MVTPRJ_matrix or V_prj = V_obj * MVTPRJ_matrix<br><br>
where CV_obj is the clipped vertex coordinates in the object space; and V_obj is non-clipped vertex coordinates in object space.<br><br>
37. The engine of claim 31 ; wherein the user-defined clipping means comprises means for converting clip planes (P_eye) in eye space to clip planes (P_obj) in the object space defined by<br><br>
P_eye = lnv_Mc*P ; and P_obj = P_eyeT*M <br><br>
where P is an input clip plane; Mc is a modelview matrix for the clip plane; lnv_Mc is the inverse matrix of the Mc; M is a modelview matrix for coordinates; T is a transpose of a matrix or vector; and * denotes matrix multiplication.<br><br>
38. The engine of claim 37; wherein the user-defined clipping means further comprises means for creating clipped vertex coordinates in the object space using the clip planes (P_obj) in the object space if<br><br>
P_objt * V_obj &gt;= 0 wherein P_obj is the clip plane in the object space to be clipped; T is a transpose of a matrix or vector; and * denotes matrix multiplication.<br><br>
39. A program code having program instructions executable by a processor to perform vertex coordinate processing of vertex coordinates in eye space when lighting is enabled and to perform vertex coordinate processing of vertex coordinates object space when lighting is disabled.<br><br>
40. The program code of claim 39; wherein the program instructions operable to perform the vertex processing in the object space are operable to perform primitive assembling in the object space using the vertex coordinates in the object space.<br><br>
41. The program code of claim 40; wherein the program instructions operable to perform primitive assembling includes program instructions operable, upon execution by the processor, to selectively perform one of polygon assembling, line assembling and point assembling of the vertex coordinates in the object space.<br><br>
42. The program code of claim 39; wherein the program instructions operable to perform the vertex processing in the eye space are operable to <br><br>
perform primitive assembling in the eye space using the vertex coordinates in the eye space.<br><br>
43. The program code of claim 42; wherein the program instructions operable to perform primitive assembling in the eye space includes program instructions operable, upon execution by the processor, to selectively perform one of polygon assembling, line assembling and point assembling of the vertex coordinates in the eye space.<br><br>
44. The program code of claim 39; wherein the program instructions operable to perform the vertex coordinate processing in the eye space include program instructions operable, upon execution, to transform the vertex coordinates in the eye space to projection space.<br><br>
45. The program code of claim 44; wherein the program instructions operable to perform the vertex coordinate processing in the object space include program instructions operable, upon execution, to perform combined modelview and projection transformation in the object space.<br><br>
46. The program code of claim 45; wherein the program instructions operable to perform combined modelview and projection transformation includes program instruction operable, upon execution by a processor, to transform the vertex coordinates in the object space directly into the projection space by multiplying one vector to a matrix.<br><br>
47. The program code of claim 46; wherein the matrix is a combined matrix (MVTPRJjnatrix) of a modelview matrix and a projection matrix wherein the result of the multiplication yields the vertex coordinates (V_pri) in the projection space defined by<br><br>
V_prj = CV_obj * MVTPRJ_matrix or <br><br>
V_prj = V_obj * MVTPRJ_matrix<br><br>
where CV_obj is clipped vertex coordinates in the object space; and V_obj is non-clipped vertex coordinates in the object space.<br><br>
48. The program code of claim 39; wherein the program instructions operable to perform the vertex coordinate processing in the object space include program instructions operable, upon execution, to perform user-defined clipping to convert clip planes (P_eye) in the eye space to clip planes (P_obj) in the object space defined by<br><br>
P_eye = lnv_Mc*P ; and<br><br>
P_obj = P_eyeT*M where P is an input clip plane; Mc is a modelview matrix for the clip plane; lnv_Mc is the inverse matrix of the Mc; M is a modelview matrix for coordinates; T is a transpose of a matrix or vector; and * denotes matrix multiplication.<br><br>
49. The program code of claim 48; wherein the program instructions operable to perform the user-defined clipping includes program instructions upon execution to clip if<br><br>
P_objt * V_obj &gt;= 0 where P_obj is the clip plane in the object space to be clipped; V_obj is the vertex coordinates in the object space; T is a transpose of a matrix or vector; and * denotes matrix multiplication.<br><br>
50. A 3D imaging device comprising: determining means for determining whether a lighting function is enabled or disabled; <br><br>
eye space processing means for processing vertex coordinates in eye space when the lighting function is enabled; and object space processing means for processing vertex coordinates in object space when the lighting function is disabled.<br><br>
51. The device of claim 50; wherein the object space processing means includes means for primitive assembling in the object space using the vertex coordinates in the object space.<br><br>
52. The device of claim 51 ; wherein the primitive assembling means includes means for selectively performing one of polygon assembling, line assembling and point assembling of the vertex coordinates in the object space.<br><br>
53. The device of claim 50; wherein the eye space processing means includes means for primitive assembling in the eye space using the vertex coordinates in the eye space.<br><br>
54. The device of claim 53; wherein the eye space primitive assembling means includes means for selectively performing one of polygon assembling, line assembling and point assembling of the vertex coordinates in the eye space.<br><br>
55. The device of claim 50; wherein the eye space processing means includes means for transforming the vertex coordinates in the eye space to projection space.<br><br>
56. The device of claim 55; wherein the object space processing means includes means for combined modelview and projection transforming of the vertex coordinates in the object space to the projection space.<br><br>
57. The device of claim 56; wherein the combined modelview and projection transforming means includes means for transforming the vertex <br><br>
coordinates in the object space directly into the projection space by multiplying one vector to a matrix.<br><br>
58. The device of claim 57; wherein the matrix is a combined matrix (MVTPRJjnathx) of a modelview matrix and a projection matrix and the result of the multiplication yields the vertex coordinates (V_pri) in the projection space defined by<br><br>
V_prj = CV_obj * MVTPRJ_matrix or<br><br>
V_pri = V_obj MVTPRJ_matrix where CV_obj is clipped vertex coordinates in the object space; and V_obj is non-clipped vertex coordinates.<br><br>
59. The device of claim 50; wherein the object space processing means includes means for user-defined clipping to convert clip planes (P_eye) in the eye space to clip planes (P_obj) in the object space defined by<br><br>
P_eye = lnv_Mc*P ; and<br><br>
P_obj = P_eyeT*M where P is an input clip plane; Mc is a modelview matrix for the clip plane; lnv_Mc is the inverse matrix of the Mc; M is a modelview matrix for coordinates; T is a transpose of a matrix or vector; and * denotes matrix multiplication.<br><br>
60. The device of claim 59; wherein the user-defined clipping means includes means for clipping if<br><br>
P_objt * V_obj &gt;= 0 where P_obj is the clip plane in the object space to be clipped; V_obj is the vertex coordinates in the object space; T is a transpose of a matrix or vector; and * denotes matrix multiplication. <br><br><br>
61. The device of claim 50; wherein the device comprises one of: a cellular telephone with video capability, a satellite telephone with video capability, a personal computer, a laptop, a wireless communication or computing device with video capability, and a personal digital assistant.<br><br>
62. A method for processing object space user-defined clipping comprising the steps of: converting clip planes (P_eye) in eye space to clip planes (P_obj) in object space; and user-defined clipping to create clipped vertex coordinates in the object space using the clip planes (P_obj) in the object space and the vertex coordinates in the object space.<br><br>
63. The method of claim 62; further comprising the step of transforming the clipped vertex coordinates in the object space and non-clipped vertex coordinates in the object space directly into projection space.<br><br>
64. A method for dual mode processing of user-defined clipping comprising the steps of: determining whether a lighting function is enabled or disabled; performing object space vertex coordinate processing with object space user-defined clipping to create clipped vertex coordinates in object space when the lighting function is disabled; and performing eye space vertex coordinate processing with eye space user-defined clipping to create clipped vertex coordinates in eye space when the lighting function is enabled;<br><br>
65. The method of claim 64; wherein the object space vertex coordinate processing step further comprises the step of: transforming the clipped vertex coordinates in the object space and non-clipped vertex coordinates in the object space directly into projection space.<br><br>
66. The method of claim 64; wherein the eye space vertex coordinate processing step further comprises the step of: transforming the clipped vertex <br><br>
coordinates in the eye space and non-clipped vertex coordinates in the eye space into projection space.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=d9Fn8ekqatx6Lbk8LdAQ8w==&amp;amp;loc=vsnutRQWHdTHa1EUofPtPQ==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=d9Fn8ekqatx6Lbk8LdAQ8w==&amp;amp;loc=vsnutRQWHdTHa1EUofPtPQ==</a></p>
		<br>
		<div class="pull-left">
			<a href="272496-cleaning-unit-of-roads-and-the-like.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="272498-method-of-setting-the-dosing-of-the-reducing-agent-in-selective-catalytic-reduction.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>272497</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>350/MUMNP/2009</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>15/2016</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>08-Apr-2016</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>05-Apr-2016</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>16-Feb-2009</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 Morehouse Drive  San Diego  California 92121-1714  United States of America</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>BI  Ning</td>
											<td>5775 Morehouse Drive  San Diego  California 92121-1714  United States of America</td>
										</tr>
										<tr>
											<td>2</td>
											<td>CHEN  Lin</td>
											<td>5775 Morehouse Drive  San Diego  California 92121-1714  United States of America</td>
										</tr>
										<tr>
											<td>3</td>
											<td>CHEN  Lingjun Frank</td>
											<td>5775 Morehouse Drive  San Diego  California 92121-1714  United States of America</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06T 15/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2007/078237</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2007-09-12</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/531,205</td>
									<td>2006-09-12</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/272497-method-and-device-for-performing-user-defined-clipping-in-object-space by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:46:51 GMT -->
</html>
