<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/225108-method-of-searching-for-a-final-number by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:08:43 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 225108:METHOD OF SEARCHING FOR A FINAL NUMBER</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD OF SEARCHING FOR A FINAL NUMBER</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>This invention relates to methods of searching for a final number of result strings (30-33) having a partial or an exact match with a query string (34) in a database (80) comprised of many long strings or a long string, said method includes the steps of partitioning the query string in a first number of input query strings (35, 36, 37); determining a second number of neighboring strings (38-41, 42-45, 44-49, respectively) for each string in said first number of input query strings, wherein each string in said second number of neighboring strings has a predetermined first number of errors; searching the database for a third number of exact matches (50-61, 70-74) for each string in said second number of neighboring strings based on a search method; concatenating said searched exact matched strings from the database into a fourth number of intermediate strings (29, 30, 32, 33, 34) wherein said searched exact matched strings (50-61, 70-74) comprised in each of said intermediate strings are in succession to one another in said database; and determining the final number of result strings (30-33) based in said fourth number of intermediate strings, wherein each string in the final number of result strings has a maximum of predetermined second number of errors compared to said query string (34). This enables for a perfect match or a partial match containing only minor errors with respect to said query string, and for a fast search in larger databases with a relative low use of processing power.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
Method and arrangement for searching for strings<br>
This invention relates to a method of searching for a final number of result strings having a partial or an exact mach with a query string in a database comprised of many long strings or of a long string.<br>
The present invention also relates to a search engine.<br>
The present invention also relates to a tool.<br>
The present invention also relates to a computer system for performing the method.<br>
The present invention further relates to a computer program product for performing the method.<br>
Additionally, the present invention further relates to an arrangement.<br>
US 5,963,957 discloses an information processing system having a music database. Said music database stores homophonic reference sequences of music notes. The reference sequences are all normalized to the same scale degree in order to be stored lexicographically. A so called N-aiy is applied to find a match between a string of input music notes and a particular reference sequence. Hereby said information processing system provides bibliographic information associated with the matching reference sequence.<br>
In Du, D.W. and Chang, S.C. (1994), an approach to designing veiy fast approximate string matching algorithms, IEEE Transactions on Knowledge and Data Engineering, 6, 4,620-633, another kind of string matching is further disclosed.<br>
In the art, retrieval methods use algorithms for exact matching. However the known retrieval methods typically attempt an exact match, i.e. the search or the match is performed in order to find a perfect match.<br>
However, it is a problem in many practical applications that only a perfect match is searched for. As a result, it is an additional problem that no matching result(s) is/are provided even though this/these may be useful even if it/they only contained minor errors.<br>
It is a further problem that search of large database takes a long time and correspondingly requires intensive usage of processing power.<br>
In many practical applications it is sufficient to obtain a partial match (instead of the perfect match). This is the case since either a query string - as an input to the search<br><br>
attempt - or the result matching string, both may have less important errors but still it is better to obtain the partial match result than no result at all. Said errors, typically, are caused by improper data comprised either in the query string or in the database searched in.<br>
The above and other problems are solved by said method, when the method comprises the steps of:<br>
partitioning the query string in a first number of input query strings;<br>
In other words, in this step, the query string is cut into said first number of small pieces of substrings, Le. into said input query strings.<br>
determining a second number of neighboring strings for each string in said first number of input query strings, wherein each string in said second number of neighboring strings has a predetermined first number of errors;<br>
In other words, in this step, the second number of neighboring strings depends of the length of the query string, the size of different discrete symbols in the string alphabet applied and the numbers of errors allowed in the neighboring strings.<br>
In general, for each string in said first number of input query strings said second number of neighboring strings are determined. Each of these, individually has a predetermined first number of errors, which is greater than or equal to zero.<br>
searching the database for a third number of exact matches for each string in said second number of neighboring strings based on a search method;<br>
Hereby, is the database searched for a number (third) of exact matches for each string in said second number of neighboring strings based on a given search method, the search method can be a q-gram index method, a suffix tree method or a hash method.<br>
concatenating said searched exact matched strings from the database into a fourth number of intermediate strings wherein said searched exact matched strings comprised in each of said intermediate strings are in succession to one another in said database; and<br>
determining the final number of result strings based on said fourth number of intermediate strings, wherein each string in the final number of result strings has a maximum of a predetermined second number of errors compared to said query string.<br>
For the last two steps, these are explained in figure 5, i.e. step 400 and 500.<br>
As a result of the method, said final number of result strings, each is an exact or a partial match to said query string (mentioned in the opening paragraph).<br>
It is hereby achieved to obtain a perfect match or a partial match containing only minor errors.<br><br>
Further, the method can search large databases (for perfect or partial matches) fast with a relative low use of processing power.<br>
Said arrangement, tool, search engine, computer system, respectively provides the same advantages and solves the same problem(s) for the same reasons as described previously in relation to the method.<br>
The invention will be explained more fully below in connection with preferred embodiments and with reference to the drawings, in which:<br>
Fig. 1 shows a general discussion of the art;<br>
Fig. 2 shows a way of partitioning the query string;<br>
Fig. 3 shows a practical detailed example way of partitioning the query string and a subsequent search;<br>
Fig. 4 shows a general example way of partitioning and searching the query string;<br>
Fig. 5 shows a method of searching for a final number of result strings, and<br>
Fig. 6 shows an arrangement for searching.<br>
Throughout the drawings, the same reference numerals indicate similar or corresponding features, functions, strings, etc.<br>
Figure 1 shows a general discussion of the art. The figure shows a query string 'abacababc' searched for in a string database, reference numeral 80. The database positions of the four approximate matches of the query string allowing at most one error (k = 1) are indicated. The query string, reference numeral 34,'abacababc' which is composed from a 3-letter alphabet {'aVb',?c'}. If only one error (£ = 1) is allowed, an approximate match is found containing an added symbol (e.g., reference numeral 30: 'abacadabbc'), an approximate match containing a deleted symbol (e.g., reference numeral 31: 'abcababc'), an approximate match containing a substituted symbol (e.g., reference numeral 32: 'abacadcbc') and an exact match (i.e., reference numeral 33: 'abacadabc'). It is generally acknowledged in tiie art to search for a string whereby the entire queiy string is searched for at once.<br>
Figure 2 shows a way of partitioning the query string. Efficient retrieval methods, known from the literature, capitalize on the use of fast algorithms for exact matching, that is, searching without allowing any error (or, k- 0). This would only return the position for (exact) match, i.e. reference numeral 33 from figure I. Specialized index structures such as suffix trees or #-grams need to be build off-line (as a pre-processor) from the string database, reference numeral 80 to enable the implementation of fast exact matching algorithms. Essentially, these structures keep hold of all positions of each small sub-string<br><br>
that occur in the database. Effectively, this means that the retrieval process can immediately jump to the relevant spots in the database while discarding the irrelevant parts. The g-gram index method is used, since it is more space-efficient (i.e., uses less memoiy) than other methods and can be easily adapted to our purpose. The #-gram keeps all positions of all substrings of length q &gt; 0 occurring in the database. If, for instance, the database consists of the<br>
string 'abababcabcabacab	\ the q-gram with q = 4 collects the starting positions of all<br>
sub-strings of length 4 such as cabab', 'baba', 'abab', *babcJ and 'abca'. These sub-strings are indexed by using a function, listed and sorted in an easily accessible data structure. Similar sub-strings, such as 'abab' in the example, end up at the same index (called a bucket). A $r-gram allows us to obtain the database positions of all exact matches of a query of length m <x q by computing the index function and retrieve members of a bucket. queries that></x>
are longer than q need an additional check because only the prefixes of length q of the query can be in a bucket The standard way to work with ^-grains is described by Myers, 1994.<br>
As alternatives to said q-gram method, a suffix tree method or a hash method may be applied.<br>
If exact matching methods are used in approximate matching, a workaround has to be found for the errors allowed. For instance, according to the invention a set of strings can be generated that differ on a limited number of locations in the original queiy (string). These strings are called neighbors of the query. Neighbors thus represent the errors in a queiy. Formally, a ^-neighborhood of a string S is defined as the set of strings with at most k errors with respect to S. For instance, if the query 'abba9 is constructed from the two-letter alphabet {'ayb'}, the complete set of neighbors with at most one error (i.e., error level k 
However, the number of neighbors to be investigated is exponential when longer queries are investigated, a larger alphabet and a higher error level. To resolve this issue and gain retrieval speed, the query is first partitioned in smaller sub-strings and foreach sub-string its set of neighbors is generated. Then all these neighbors are searched exactly using ^-grams or the other search methods mentioned. Their exact matches in the database correspond now to partial approximate matches of the original query.<br><br>
Let the query be 'abacababc* composed from the three-letter alphabet {'a'/bYc5} and allow an error level of 3 (k = 3). Note that errors in the query can occur at any place. For instance, the errors can be<br>
all at the start (e.g., 'ccccababc' can then be the string you are actually looking for),<br>
all in the middle (e.g. 'ababbcabc'),<br>
all at the end (e.g., 'abacabbca')<br>
or uniformly distributed in the query (e.g., 'abecacabb').<br>
If the queiy is partitioned into three parts (p = 3, which results in the substrings caba\ ccab' and 'abc' for our example queiy 'abacababc'), a set of neighbors is generated for each part and each neighbor is searched individually in the database, context is lost about how the original queiy looks like. To understand this, note that the neighbors can occur anywhere in the database. Neighbors do not necessarily appear close together or in a sequence, which is required to form an approximate match of the original query. In other words, when an exact match is found for a neighbor for our example query 'abacababc', it cannot be known whether it reflect the first, second or third part of the queiy and what kind of neighbors are found for the other parts. Necessary measures have to be taken to reveal this infonnation. Former methods described in literature stop right here, that is, they consider each exact match of a neighbor as a useful candidate for resolving the queiy. In contrast, the invention of cross-cutting does an additional filter step by re-establishing the (error) context while searching the neighbors. The neighbors that can be discarded are<br>
those that do not appear in a sequence with other neighbors in the database, and<br>
those that form a sequence with other neighbors in the database that cannot be an approximate match of the original query.<br>
These observations are condensed in a central 'cross-cutting* lemma for the current invention that provides a guarantee about the successful retrieval of relevant parts if we partition a query string inp parts and search for the parts separately each with at most kf errors.<br>
Cross-cutting lemma: Let A and B be two strings such that the number of errors between them is smaller than or equal to k in edit-distance sense, or formally d(A,B)<k . let a="AXA2" apbe the partitioning in p parts for strings at and any></k>
p &gt; 1. Let K = (fc], k2 , • • ■ j kp ) be any sequence of nonnegative numbers such that<br><br><br><br>
As shown in figure 2, the query 'abacababc', reference numeral 34, is partitioned in three sub-strings (p « 3). Recall that only 3 errors are allowed (k = 3). Define<br>
k	£<br>
kt = — =1 and C = y&amp;,'+p-£ = 3. For each sub-string, a set of neighbors i.e. reference<br>
numeral 38-41, 42-45 and 46-49, respectively is generated which are sought exactly in the<br>
database. In the process of neighbor search, the positions of all neighbors found so far are<br>
kept and it is decided whether or not the concatenation of consecutive neighbors can be part<br>
of an approximate match of the query. The two matches for the neighbors 'aba' and 'cab'<br>
(see reference numeral 30 in figure 2) represent an error-free match of the first two sub-<br>
2 strings of the query string (i.e., e = 0 and ^T (kt +1) - e = 4 &gt; C = 3 ). Already it is known that<br>
z=l<br>
a valid approximate match of the query have been found; in the worst case a neighbor<br>
representing 3 errors can succeed these two matches for which our filtration condition still<br>
holds. The two matches for the neighbors *abc' and ccaa' (see 31 in figure 2) represent 2<br>
2 errors (i.e., e = 2 and ]£ (kf +1) - e = 2). This sequence can only be succeeded by a neighbor<br>
z=l<br>
representing at most 1 error to be still a valid approximate match of the query. The matches for the neighbors 'acb' and 'cbc9 (see reference numeral 32 in figure 2) represent already 4<br>
2 errors (i.e., e = 4 and) ^ (h? +1) - e = 0. It is already known that this sequence cannot be<br>
/=l<br>
part of an approximate match of the query. Even if it is succeeded by an error-free neighbor,<br>
the filtration condition does not hold.<br>
For a more detailed and general discussion of said Q-grams and said<br>
Neighboring generation, respectively; the followings sections should enable the person<br>
skilled in the art to implement the invention:<br>
Q-grams or the q-gram index method:<br>
With q-grams it is possible to find all occurrences of a string not bigger than q very fast. Those q-grams are constructed in the following way.<br>
Consider a bijection <j> of the symbols in 2 to the integers 0 to a -1.<br>
Function 0 is naturally extended to strings with the recursive definition<br><jf o where p is a string over and symbol in z for></jf><br>
be[0,<rq let bucket : that is gives the></rq>
indices of the leftmost character of each occurrence in A of the unique g-symbol string whose 0-code is b.<br>
The index is produced in the following way. First 0Z- = ^(a^a,-+i • • • fl,-+m_i) is computed for every index i. This is done in an.O(n) sweep of A using the observation that fa = afCTm" + |_0/+i /crj. With an 0(n log(n))-quick-sort the list can now be produced Indices = {i\. *2 »*"»'«)su°h^at 0/   ^ 0/ +1 • Finally, the array<br>
Header[b] = miny : (j&gt;indices[j] = ^} *s produced in an 0(n) sweep of Indices, The arrays<br>
Indices and Header provide a realization of the Bucket sets. Namely, 5MC^^[6] = {lndices[j]: j e [Header[b],Header[b +1] -1]}.<br>
If a query P is of length m 
exactly the content of Bucket(b) for b e [&gt;(P)<jq>) + l)cr*~m -1].<br>
If a query P is larger than q it is known that the occurrences of P must be a subset of those in Bucket($(Pq)) where i^ denotes the string consisting of the first q symbols<br>
ofP.<br>
Neighbor generation:<br>
A (complete) ^-neighborhood of a string P is defined as the set of all strings with a (edit-)distance less than or equal to k from P, i.e. Nk (P) = \Q\ d(Q, P) £ k}.<br>
A condensed ^-neighborhood of a string P is defined as the set of all strings in the complete ^-neighborhood of P that do not have a prefix in that neighborhood, i.e.9 Ck (P) = {g: Q s Nk (P) and no prefix of Q is in Nk (P)}.<br>
Myers9 algorithm computes a condensed k-neighborhood of a string efficiently by generating words from an alphabet and computing the corresponding rows of the dynamic programming matrix of the currently generated word and P. If a word whose last entry of the current row equals k, then a word in the condensed k-neighborhood has been reached. If all entries are larger than k, the algorithm can backtrack. The use of failure links prevents the algorithm from missing words that are in the k-neighborhood but are not in the condensed<br>
one.<br>
As the present invention needs the complete k-neighborhood of a string to find all exact matches of the partitions in the database, Myers's algorithm has been adapted.<br><br>
Figure 3 shows a practical detailed example way of partitioning the query string and a subsequent search.<br>
The queiy string, reference numeral 34, again is searched for in the database, reference numeral 80. According to the invention, said query string is partitioned into a number of input query strings, the number three is here chosen for conciseness, it may be any other number greater than one. In the example, said input query strings are represented by reference numeral 35, 36 and 37, respectively for the beginning part, the middle part and the "end part" - part.<br>
By means of said number of input query strings, a number of neighboring strings - here four - is defined for each input query string. I.e. for the input query string of reference numeral 35, corresponding four neighboring strings, reference numeral 38, 39,40 and 41 are determined.<br>
Correspondingly, for the "mid part" input query string of reference numeral<br>
36,	corresponding four neighboring strings, reference numeral 42, 43, 44 and 45 are<br>
determined.<br>
Correspondingly, for the "end part" input query string of reference numeral<br>
37,	corresponding four neighboring strings, reference numeral 46,47, 48 and 49 are<br>
determined.<br>
To the right of the dotted line, reference numeral 80, it is implied that in this section of the figure, the database - previously also indicated by the same reference numeral -is searched into, i.e. said neighboring strings, reference numeral 38 - 49, each is searched for in order to find e^act (sub string) match(es).<br>
These are indicated by following the arrows further to the right; as an example, reference numeral 38, a first part neighboring string gives the exact match of reference numeral 50; as another example, reference numeral 47, an end part neighboring string gives the match of reference numerals 58 and 61, and reference numeral 45, a mid part neighboring string gives the "none- useful" result of reference numeral 72.<br>
And in order to achieve final search results), more or less matching the query string, reference numeral 34; the arrows can be followed further to the right, i.e. reference numeral 30-33, respectively indicate each of the four final search results. As can be seen, each of said final search results is always comprised of one of the searched beginning substrings, reference numeral 50-53, one of the mid searched substrings, reference numeral 54-57 and one of the "end part" searched substrings, reference numeral 58-61. How these are put in succession and by which criterions will be explained by means of figure 5.<br><br>
Figure 4 shows a general example way of partitioning and searching the query string. Figure 4 corresponds to figure 3, however, generally the ".." 's indicate that any string of any reference numeral may comprise fewer or more letters, Le. the invention can be applied for veiy short strings and for very long sequence of letters as well.<br>
The letters of the western alphabet - as shown - may alternatively be a sequence of elements in a pitch alphabet, a sequence of elements in a musical pitch interval alphabet, a sequence of elements in a musical time interval alphabet, a sequence of binary digits, words or bytes, a sequence of amino acids or a sequence of DNA/RNA. Correspondingly, the same applies for the database searched in, since it may also be understood as one long string or of many long strings.<br>
Said sequence of elements in a musical pitch interval alphabet and sequence of elements in a musical time interval alphabet represents the essence of a musical score. In general for all strings (the query string, strings in the database, etc) this means that these can be made out of any alphabet of discrete symbols.<br>
Figure 5 shows a method of searching for a final number of result strings. The method searches for a final number of result strings as indicated by means of reference numerals 30 through 33 (in the foregoing figures). Le. each of said final number of result strings will have a partial or an exact mach with the query string, reference numeral 34 in the database, if possible. The database, reference numeral 80, is comprised of a long string. Said method comprises the following steps:<br>
In step 100, the query string is partitioned in a first number of input query strings. As indicated in the forgoing figures, said query string is partitioned in three input query strings, reference numerals 35, 36 and 37, i.e. the first number is here three. Said first number may be any number greater than or equal to one. The first number equaling exact three is only shown for illustrative purposes, i.e. any higher or lower number may be chosen as well.<br>
In other words, in this step, the queiy string is cut into (said first number) small pieces of substrings, i.e. into said input query strings.<br>
In the example, the query string, reference numeral 34, "aba.. cab., abc" is cut into said set of first number of input query strings, in the example there are three in the set, i.e. input query string 1, reference numeral 35 = "aba..", input query string 2, reference numeral 36 = "cab.." and input queiy string 3, reference numeral 37 = "abc".<br>
In step 200, a second number of neighboring strings are determined. As also indicated in the forgoing figures, said second number of neighboring strings is four, i.e.<br><br>
reference numerals 38-41 for the first input query string reference numeral 35, reference numerals 42-45 for the second or mid input query string, reference numeral 36 and reference numerals 44-49 for the third or last input query string, reference numeral 37.<br>
The second number equaling exact four is only shown for illustrative purposes, i.e. any higher or lower number than four may be chosen as well. In particular, the number of neighboring strings depends of the length of the query string, the size of different discrete symbols in the string alphabet applied and the numbers of errors allowed in the neighboring strings.<br>
This gives, as the example a total of twelve neighboring strings, i.e. it equals said first number times said second number, i.e. 3x4=12, i.e. four for each (three) input query strings; or in general: for each string in said first number of input query strings said second number of neighboring strings are determined. As indicated in the forgoing figures, these are the reference numerals 38 through 49. Each of these, individually has a predetermined first number of errors, which is greater than or equal to zero.<br>
Note that If the (first) number of errors exceeds the neighboring string length (i.e. all content of the string is then determined to be in error), consequently a subsequent search in the next step would be absolutely meaning less; therefore said first number of errors cannot exceed the string length.<br>
As the example given, on basis of the input query string "aba..", i.e. reference numeral 35, four neighboring strings are determined, i.e.:<br>
reference numeral 38 "aba.." equaling itself, .i.e. of course no errors.<br>
reference numeral 39 "aba." with one error,<br>
reference numeral 40 "abb.." with another error, and<br>
reference numeral 41 "acb.." with two errors.<br>
In the example given, the predetermined first number of errors (which is greater than or equal to zero) is here 0,1 or 2.<br>
The first number of predetermined of errors, in the example equaling zero, one or two, is only shown for illustrative purposes, i.e. any higher number may be chosen as well.<br>
In step 300, the database is searched for a third number of exact matches for each string in said second number of neighboring strings. Said search is based on a given search method.<br>
Said third number of exact matches is illustrated by means of reference numerals 50-61 and 70-74. It is important to note that there may be one or more matches, e.g.:<br><br>
firstly, reference numeral 38 "aba,." - as an example of a neighboring string -leads to the exact match of reference numeral 50 and 52, i.e. "aba..";<br>
secondly, reference numeral 39 "abc." - as another example of a neighboring string -  leads also to its exact match of reference numeral 51 "abc..",<br>
thirdly, reference numeral 40 "abb".." leads also to no match, i.e. reference numeral 70 "abd„", and<br>
finally, reference numeral 41 "acb" .." also leads to no match, i.e. reference numeral 71 "abc".<br>
The latter two is then unusable since only exact matches are considered.<br>
Correspondingly, reference numerals 53-61 and 72-74 are search results from the neighboring strings indicated by means of reference numerals 42 - 49.<br>
In all cases, the search results, reference numerals 50-61 and 70-74, with corresponding string content and corresponding positions in the database are kept for later use in the subsequent step.<br>
Also, in all cases, the given search method may be the q-gram index method or any other appropriate method known to be useful in the art, e.g. a suffix tree method or a hash method.<br>
In step 400, said searched exact matched strings from the database are concatenated into a fourth number of intermediate strings. Said searched exact matched strings (when comprised in each of said intermediate strings) are in succession to one another in said database.<br>
Said fourth number of intermediate strings is indicated by means of reference numerals 29-33, the fourth number in the example given is five. Further, said searched exact matched strings - indicated by means of reference numerals 50-61 and 70-74 - comprised in each of said intermediate strings are determined to be in succession to one another in said database: this will be explained in the following:<br>
As can be seen from the examples - during concatenation - search result from the first input query string (being the beginning of the query string), reference numeral 35 = "aba.." having corresponding beginning neighboring strings, reference numeral 38 - 41 lead to corresponding beginning substrings, reference numeral 50-53.<br>
Correspondingly, - during concatenation - search result from the second input query string (being the middle of the query string), reference numeral 36 = "cab.." having corresponding "middle" neighboring strings, reference numeral 42 - 45 lead to corresponding mid substrings, reference numeral 54-57.<br><br>
Correspondingly, - during concatenation - search result from the third input query string (being the end part of the query string), reference numeral 37 = "aba." having corresponding "end part" neighboring strings, reference numeral 46 - 49 lead to corresponding "end part" substrings, reference numeral 58-61.<br>
In other words, the exact matched strings, reference numerals 50-61 and 70-74 as corresponding part of each of said intermediate strings are in fact in succession to one another in the database, i.e. one of the beginning substrings, reference numeral 50-53, one of the mid substrings, reference numeral 54-57 and one of the end part substrings, reference numeral 58-61 are concatenated into one of said fourth number of intermediate strings, i.e. one of reference numerals 29-33.<br>
In step 500, the final number of result strings is determined. The determination is based on said fourth number of intermediate strings from the foregoing step, and here - in this step - each string in the Final number of result strings is determined to have a maximum of a predetermined second number of errors compared to said query string of reference numeral 34.<br>
In the examples given, the final number of result strings, reference numerals 30-33, is four, whereas said fourth number of intermediate strings was five. Le. in the example, one, reference numeral 29 is discarded or left out since this in particular does not satisfy the criterion of having error(s) less than or equal to said second number of errors. This is seen when compared to said query string, of reference numeral 34.<br>
In other words, reference numeral 29 is discarded for having too many errors (compared the initial query string of reference numeral 34), whereas reference numerals 30 through 33, individually had less errors and thus satisfied the criterion. That is, in the example reference numerals 30 through 33 comprise the final number of result strings.<br>
As a result of the method, said final number of result strings, reference numerals 30 - 33, each is an exact or a partial match to said query string, reference numeral 34.<br>
In the example given, four matches (exact or partial) was then the result when said query string was searched for.<br>
This step - in connection with the foregoing step - is also called "Cross-cutting", i.e. the idea of considering only those exact matches of neighbors (when searched for) that, when concatenated, can contain an approximate match with the original query string of reference numeral 34.<br><br>
In the spirit of the invention, any of said "first number", "second number of neighboring strings", "third number", "fourth number of intermediate strings" and "first and second number of errors, may be fine tuned individually or in relation to one another or in relation to the content of the query string and / or the database. Hereby either speed of search may be decreased and / or another matching (fewer/less) errors may be obtained.<br>
Correspondingly, the given examples are illustrative and may also be expanded with another string length for the queiy string, neighboring strings, intermediate strings, another sequential content (of discrete symbols) of the strings, etc.<br>
Figure 6 shows an arrangement for searching. Reference numeral 660 indicates said arrangement. The arrangement processes - according to the invention - the query string, reference numeral 34 as discussed in the foregoing figure. The arrangement processes said string as input and therefore comprises calculation means 661, e.g. a sufficient fast microprocessor. The microprocessor searches for matches in the database, reference numeral 80. As a result, if any, the final number of result strings, reference numeral 30, 31, 32 and 33 is found. The calculation means for carrying out the steps of the matching method can also be e.g. a part of a dedicated ASIC.<br>
Reference numeral 662 denotes a computer program product. Said computer program product comprising program code means stored on a computer readable medium for performing said method when the computer program is run on a computer.<br>
Generally, the present invention may be applied in various fields, such as melody retrieval for music systems ('query by humming'), finding keywords in a search engine or in a text file, finding DNA/RNA sequences in a molecular biology database, bits, bytes or word codes, error control, etc. For the melody retrieval application, it can be imagined that only a small fragment of a melody is remembered without recalling the complete melody or song. Once provided in the appropriate representation as a string of discrete symbols, this melody fragment can then be input to the search method to reveal the identity of the song or melody using said database. The search method thereby allows for errors in the input. The arrangement may be e.g. a jukebox -implemented as a stand alone audio apparatus or on a PC. It may also be a portable audio apparatus, which contains an interface enabling e.g. a jogger to quickly change his accompanying music by whistling the beginning or refrain. The arrangement may e.g. also be a service on an internet server for quickly selecting a particular MP3 from the web, or the arrangement may be a portable phone running the method, for retrieving e.g. a ring tone.<br><br>
Similarly, keywords as a query (similar to previously mentioned query string) for a search engine -e.g. for searching a particular product on Internet or a word in a software dictionary- or a software search tool can contain typos. The search or retrieval process can account for these errors in the keywords. In all applications, the number of errors one allows may be pre-defined and fixed. The database can be best seen as one very long string (e.g., a long text, all melodies in the world put into sequence, etc). Also, the strings may be constructed from a finite collection (e.g. western or pitch alphabet, binary digits, bytes, words, amino acids, DNA/RNA, words, etc). For a text application, the 26 letters from the Western alphabet may be used. Correspondingly, melodies can be constructed from a 9-element pitch interval alphabet Molecular biology applications use the twenty amino acids or the four nucleotides as the alphabet. Coding applications use the binary symbols, word, bits or bytes.<br>
Under the essence of a musical score should be understood any information which is sufficient for retrieving a melody. E.g. tone intervals, or just time intervals in case a person is not very musical or wants to search a piece of music by e.g. tapping his foot, or both. These are converted into string characters by a predetermined mapping function.<br>
A computer readable medium may be magnetic tape, optical disc, digital versatile disk (DVD), compact disc (CD record-able or CD write-able), mini-disc, hard disk, floppy disk, smart card, PCMCIA card, etc.<br>
In the claims, any reference signs placed between parentheses shall not be constructed as limiting the claim. The word "comprising" does not exclude the presence of elements or steps other than those listed in a claim. The word "a" or "an" preceding an element does not exclude the presence of a plurality of such elements.<br>
The invention can be implemented by means of hardware comprising several distinct elements, and by means of a suitably programmed computer. In the device claim enumerating several means, several of these means can be embodied Jby one and the same item of hardware. The mere fact that certain measures are recited in mutually different dependent claims does not indicate that a combination of these measures cannot be used to advantage.<br><br>
Reference:<br>
Myers, E. (1994). A sublinear algorithm for approximate keyword searching. Algorithmica, 12 (4/5), 345-374.<br><br><br>
CLAIMS:<br>
1.	A method of searching for a final number of result strings (30-33), having a<br>
partial or an exact match with a query string (34), in a database (80) comprised of many long<br>
strings or a long string, said method comprising the steps of:<br>
partitioning (100) the query string in a first number of input query strings (35, 36, 37);<br>
determining (200) a second number of neighboring strings (38-41, 42-45,44-49, respectively) for each string in said first number of input query strings, wherein each string in said second number of neighboring strings has a predetermined first number of errors;<br>
searching (300) the database for a third number of exact matches (50-61, 70-74) for each string in said second number of neighboring strings based on a search method;<br>
concatenating (400) said searched exact matched strings from the database into a fourth number of intermediate strings (29, 30, 32,33, 34) wherein said searched exact matched strings (50-61, 70-74) comprised in each of said intermediate strings are in succession to one another in said database; and<br>
determining (500) the final number of result strings (30-33) based on said fourth number of intermediate strings, wherein each string in the final number of result strings has a maximum of a predetermined second number of errors compared to said query string (34).<br>
2.	A method according to claim 1 characterized in that said search method is a q-gram index method.<br>
3.	A method according to claim 1 characterized in that said search method is a suffix tree method.<br>
4.	A method according to claim 1 characterized in that said search method is a hash method.<br><br>
5.	A method according to any one of claims 1 to 4 characterized in that said strings and said database each comprises a sequence of letters of the western alphabet.<br>
6.	A method according to any one of claims 1 to 4 characterized in that said strings and said database each represents the essence of a musical score.<br>
7.	A method according to any one of claims 1 to 4 characterized in that said strings and said database each comprises a sequence of binary digits.<br>
8.	A method according to any one of claims 1 to 4 characterized in that said strings and said database each comprises a sequence of amino acids or a sequence of DNA/RNA bases.<br>
9.	A method according to any one of claims 1 to 4 characterized in that said strings and said database each comprises a sequence of bits, bytes or words.<br>
10.	A search engine comprising calculation means (661) for carrying out the steps of the methods according to clams 1 to 9.<br>
11.	A tool comprising means for carrying out the steps of the methods according to claims 1 to 9.<br>
12.	An arrangement (660) comprising:<br>
calculation means for (661) partitioning the query string in a first number of input query strings (35, 36,37);<br>
calculation means for (661) determining a second number of neighboring strings (38-41, 42-45,44-49, respectively) for each string in said first number of input query strings, wherein each string in said second number of neighboring strings has a predetermined first number of errors;<br>
calculation means for (661) searching the database for a third number of exact matches (50-61, 70-74) for each string in said second number of neighboring strings based on a search method;<br>
calculation means for (661) concatenating said searched exact matched strings from the database into a fourth number of intermediate strings (29, 30, 32, 33, 34) wherein<br><br>
said searched exact matched strings (50-61, 70-74) comprised in each of said intermediate strings are in succession to one another in said database; and<br>
calculation means for (661) determining the final number of result strings (30-33) based on said fourth number of intermediate strings, wherein each string in the final number of result strings has a maximum of a predetermined second number of errors compared to said query string (34).<br>
13.	A computer system for performing the method according to any one of claims<br>
1 through 9.<br>
14.	A computer program product (662) comprising program code means stored on<br>
a computer readable medium for performing the method of any one of claims 1 through 9<br>
when the computer program is run on a computer.<br><br></jq></j></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
		<br>
		<div class="pull-left">
			<a href="225107-an-iron-based-corrosion-and-wear-resistant-alloy.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="225109-telecommunications-module.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>225108</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2111/CHENP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>52/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>26-Dec-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>30-Oct-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>01-Sep-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>KONINKLIJKE PHILIPS ELECTRONICS N.V</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>GROENEWOUDSEWEG 1, NL-5621 BA EINDHOVEN,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>PAUWS, STEFFEN, C</td>
											<td>PROF. HOLSTLAAN 6, NL-5656 AA EINDHOVEN,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>EGNER, SEBASTIAN</td>
											<td>C/O. PROF. HOLSTLAAN 6, NL-5656 AA, EINDHOVEN,</td>
										</tr>
										<tr>
											<td>3</td>
											<td>KORST, JOHANNES, H., M</td>
											<td>C/O. PROF. HOLSTLAAN 6, NL-5656 AA, EINDHOVEN,</td>
										</tr>
										<tr>
											<td>4</td>
											<td>VAN VUUREN, MARCEL</td>
											<td>PROF. HOLSTLAAN 6, NL-5656 AA EINDHOVEN,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 17/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/IB04/50148</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-02-25</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>03100517.6</td>
									<td>2003-03-03</td>
								    <td>EUROPEAN UNION</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/225108-method-of-searching-for-a-final-number by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:08:44 GMT -->
</html>
