<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/217423-method-and-system-for-generating-and-controlling-a-mobile-object by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 11:44:15 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 217423:&quot;METHOD AND SYSTEM FOR GENERATING AND CONTROLLING A MOBILE OBJECT&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;METHOD AND SYSTEM FOR GENERATING AND CONTROLLING A MOBILE OBJECT&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Provided is an efficient mobile agent that requires only a short processing time and that can reduce to the minimum the employment of other resources. According to the present invention, a template is provided by which complicated activities performed by a mobile agent are sorted into basic activity patterns. The template is linked to the execution of an activity that occurs at a place before any movement is initiated and to the execution of an activity that occurs after a movement causes. In accordance with its type, the template defines an instruction to be executed before and after a movement, and transmits it to the mobile agent. In response to the instruction, the mobile agent prepares a clone, moves to another place, or fuses clones. In addition, a plan object held in the mobile, agent specifies the sequential order for the execution of templates and activities.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>[0001]<br>
. Field of the Invention<br>
The present invention relates to ' a, 'data processing method, for a computer network, and more specifically to a mobile agent technique whereby a mobile agent is moved to a remote server that exists on a network in a distributed computer environment to prepare an instruction at the remote server.<br>
[0002]<br>
Description of the Background Conventionally, there is a mobile agent technique whereby a<br>
i<br>
mobile agent is moved to a server on a network in a distributed computer environment to prepare an instruction<br>
(Japanese Unexamined Patent Publication No. Hei 7-182174<br><br>
(USP 5,603,031),  "Latest) Internet Technology," Fumihiko<br>
Nishida, Susumu Fujiwara, et. al., Nikkei Communication Extra Issue, Nikkei BP Co., Ltd., pp. 104 to 117).<br>
[0003] <br>
Such a mobile agent is constituted by two essential components, a "mobile agent" and a "place." The mobile agent can move between places that exist on a network, while the internal state of the mobile agent is maintained. At a place, the mobile agent can contact another agent (another mobile agent or a non-mobile agent), and can receive necessary services. The place is provided by a server that exists on a network and that serves as a location to which the agent moves. The place supports contacts between agents, and eliminates differences in hardware and in platforms. •<br>
[0004]<br>
The mobile agent technique enables the mobile agent to execute man labor jobs, such as the dynamic adjustment of the settings for in-house meetings in accordance with<br>
attenders' schedules and the employment conditions for meeting rooms, and the acquisition of desired information that is distributed on the network.<br>
[0005]<br>
Suppose a conventional mobile agent searches for open periods in the schedules of a plurality of attenders and makes a reservation for a meeting room. The mobile agent travels sequentially from place to place where information concerning the schedules of the attenders exists and where information concerning the booking of meeting rooms exists; searches for attenders' open periods and for unoccupied time periods for a meeting room; temporarily reserves the open periods of the attenders and the unoccupied meeting room time periods; and finally searches for a time period that is acceptable for all the attenders. If such a period is found, the\temporary reservation must be reported to the attenders as a scheduled reservation and a meeting room must be reserved.<br>
[0006]<br>
However, when the number of attenders or the number of<br>
available meeting rooms is large, a time lag occurs between the making of the temporary reservation and the scheduled reservation. As a result, an agent for making a reservation for another in-house meeting must wait, or the time zone within which available periods may be found will be shortened. In such a case, if a plurality of agents perform processing in parallel, the processing time can be reduced, and the time that the mobile agent locks in for temporary reservations can also be shortened. Further, when a process must be performed in parallel because it is complicated, it is necessary for a client site to transmit a plurality of mobile objects to sequentially execute the processing, for the results that are obtained to be re-transmitted to the client site, and for a desired process to be manually performed using the results.<br>
[0007]<br>
Although there is a demand for mobile agents that can perform parallel processing, a conventional Java base mobile agent ("Java" is a trademark of Sunmicro Systems, Inc) can not be split during processing to perform the processing in parallel because this mobile agent does not support a<br>
function for moving around a network while maintaining a processing state. Although a Telescript mobile agent ("Telescript" is a trademark of General Magic Inc.) can move around a network while maintaining a proceeding state, it does not support a function for moving while maintaining management information, such as the turns of activities for the execution. As a result, the mobile agent can not be split for parallel processing.<br>
[0008]<br>
Even for a mobile agent that does not perform parallel processing and that performs normal serial processing, its preparation and employment requires a program for defining the destination and the behavior of the agent. Therefore, high level programming knowledge is required of programmers, and the development of a program involves the investment of a great deal of time and effort.<br>
[0009]<br>
•  Objectives<br>
It is one object of the present invention to provide a<br>
mobile agent that can reduce to the minimum the employment<br>
of other resources during execution.<br>
[0010]<br>
It is another object of the present invention to provide a<br>
mobile agent that can perform processing efficiently.<br>
[0011]<br>
It is an additional object of the present invention to reduce the processing time required for results to be returned after a mobile agent is emitted.<br>
[0012]<br>
It is a further object of the present invention to enable the development of a mobile agent without requiring a high level of programming knowledge.<br>
[0013]It is still another object of the present invention to reduce to the extent possible the effort and the time required to develop a mobile agent.<br>
[0014;<br>
It is a still further object of the present invention to provide a user-friendly mobile agent development program the functioning of which a developer can understand intuitively.<br>
[0015]<br>
. Summary of the Present Invention According to the present invention, provided is a template<br>
(moderator template) with which complicated activities for a mobile agent are sorted into basic activity patterns, and with which a desired activity pattern for a mobile agent can be defined using a combination of these basic patterns. The template manages activities for issuing requests at places where a mobile agent travels, as a predecessor (an activity for executing a job at a preceding place) and as a successor<br>
(an activity for executing a job at the next place).<br>
[0016]<br>
A plurality of types of templates, such as Chain, ANDSplit and ANDJoin, are prepared in accordance with the movement forms for a mobile agent. In accordance with the template types, an instruction is transmitted to the mobile agent at the former place (origin) and at the next place (destina-<br>
tion) .  In response to the instruction, the mobile agent prepares a clone, moves to another place, or fuses clones.<br>
[0017]<br>
According to one aspect of the present invention, provided<br>
is a memory meadium storing an the object being a member of <br>
a mobile object<br>
group, the group being operable to move from a first place to a second place under the control of a moderator agent and to execute a first activity at the first place and a second  activity at the second place, the memory storing an<br>
(a) a predecessor list having link information relative to the first activity; (b) a successor list having link information relative to the second activity; and (c) a moderation module for requiring the moderator agent to move from the first place to the second place. The object according to this aspect corresponds to a moderator template in the preferred embodiment *of the present invention.<br>
[0018]<br>
According to another aspect of the present invention,<br>
provided is a memory storing an object being a member of <br>
a mobile object group, the group being operable to move from a first<br>
place to a second place under the control of a moderator agent and to execute a first activity at the first place and a second activity at the second place, the (a) a predecessor list having link information relative to the first activity; (b) a successor list having link information relative to the second activity; (c) a state manager for determining whether the moderation module exists at the first place or at the second place; and (d) a moderation module for requiring the moderator agent to move from the first place to the second place. The object according to this aspect corresponds to a moderator template in the preferred embodiment of the present invention,<br>
[0019]<br>
According to an additional aspect of the present invention, provided is a object group, the group being operable to move from a first place to a second place under the control of a moderator agent and to execute a first activity at the first place and a second activity at the second<br>
place, the (a) a moderator template including (a-1) a predecessor list having link information relative to the first activity, (a-2) a successor list<br><br>
having link information relative to the second activity, (a-3) a state manager for determining whether the moderation module exists in the first place or in the second place, and (a-4) a moderation module for requiring the moderator agent to move the mobile object group from the first place to the second place; (b) a plan iterator for determining for which of the first activity, the second activity and the moderator template authority for execution currently exists; and (c) a plan object for managing turns of the first activity, the second activity and the moderator template for the execution.<br>
[0020]<br>
According to a further aspect of the present invention, provided is a method for controlling a mobile object group, the group being operable to move to a first place specified by a first" address and to a second place specified by a second address under the control of a moderator agent, and to execute a first activity at the first place and a second activity at the second place, the method comprising the steps of: (a) requesting the moderator agent to prepare a first mobile moderator agent having link information<br>
relative to the first activity and a second mobile moderator agent having link information relative to the second activity; (b) obtaining the first address; (c) obtaining the second address; (d) requesting that the first mobile moderator agent move to the first place; and (e) requesting that the second mobile moderator agent move to the second place.<br>
[0021]<br>
In claims of the specification of the invention, the request for the preparation of the first mobile moderator agent and the second mobile moderator agent includes not only the preparation of two clones that correspond to the first and to the second moderator agents, but also the idea that one of the clones that corresponds either to the first or to the second moderator agent will move to the first address or to the second -address, and a mobile moderator agent currently being processed will move to the second address or to the first address.<br>
[0022] According to still another aspect of the present invention,<br>
provided is a method for controlling a mobile object group, the group being operable to move to a first place specified by a first address, to a second place specified by a second address and to a third place specified by a third address under the control of a moderator agent, and to execute a first activity at the first place, a second activity at the second place and a third activity at the third place, the method comprises the steps of: (a) requesting that the mobile moderator agent at the first place prepare a first mobile moderator agent having link information relative to the second activity and a second mobile moderator agent having link information relative to the third activity; (b) obtaining the second address; (c) obtaining the third address; (d) requesting that the first mobile moderator agent move from the first place to the second place; (e) requesting that the second mobile moderator agent move from the first place to the third place; (f) requesting execution of the second activity at the second place; and (g) requesting execution of the third activity at the third place.<br>
[0023] According to a still further aspect of the present inven-<br>
tion, provided is a method for controlling a mobile object group, the group being operable to move to a plurality of places under the control of a moderator agent and to execute an appropriate activity at each of the places, the method comprises the steps of: (a) executing, at a first place, a first activity linked with a first mobile moderator agent to acquire first processing results; (b) requesting that the first mobile moderator agent, which exists in the first place and which holds the first processing results, move to a second place; (c) executing, at a third place, a second activity linked with a second mobile moderator agent to acquire second processing results; (d) requesting that the second mobile moderator agent, which exists in the third place and which holds the second processing results, move to the second place; (e) requesting that the second mobile moderator agent at the second place transmit the second processing -results to the first mobile moderator agent; and (f) the first mobile moderator agent at the second place holding both the first and the second processing results. In claims of the specification of the invention, the transmission of the second processing results by the second mobile moderator agent to the first mobile moderator agent<br>
includes not only the transmission of a plan node copy, but also the transmission of the contents of the Results.<br>
[0024]<br>
According to yet another aspect of the present invention, provided is a method for controlling a mobile object group, the group being operable to move to a plurality of places under the control of a moderator agent and to execute an appropriate activity at each of the places, the method comprises the steps of: (a) executing, at a first place, a first activity linked with a first mobile moderator agent having agent identification information and acquiring first processing results; (b) requesting that the first mobile moderator agent, which exists in the first place and which holds the first processing results, move to a second place; (c) executing, at a third place, a second activity linked with a second mobile moderator agent having the same agent identification information as that of the first mobile moderator agent and acquiring second processing results; (d) requesting that the second mobile moderator agent, which exists in the third place and which holds the second processing results, move to the second place; (e) requesting<br>
that the second mobile moderator agent at the second place transmit the second processing results to the first mobile moderator agent; (f) searching the second place for a mobile moderator agent having the same identification information as the agent identification information; and (g) the first mobile moderator agent at the second place holding both the first and the second processing results.<br>
[0025]<br>
According to yet an additional aspect of the present invention, provided is a mobile object group, the group being operable to move from a first place to a second place and to execute a first activity at the first place and a second activity at the second place, the mobile object group comprises: (a) a plan object for managing turns of the first activity and the second activity for the execution; and (b) a plan iterator for determining for which of the first activity and the second activity authority for execution currently exists.<br>
[0026] According to yet one further aspect of the present inven-<br>
tion, provided is a method for generating a mobile object group, the group including (i) a first activity to be executed at a first place, (ii) a second activity to be executed at a second place, and (iii) a moderator template for requiring a moderator agent to move to the second place, the moderator agent being operable to control the movement of the mobile group at the first place, the method comprises the steps of: (a) generating, during the first activity, a successor list containing link information related to the moderator template; (b) generating, by means of the moderator template, a predecessor list containing link information related to the first activity and a successor list containing link information related to the second activity; and (c) generating, during the second activity, a predecessor list containing link information related to the moderator template.<br>
[0027]<br>
According to one more aspect of the present invention, provided is a method for generating a mobile object group, the group including (i) a first activity to be executed at a first place, (ii) a second activity to be executed at a<br>
second place, and (iii) a moderator template for requiring a moderator agent to move to the second place, the moderator agent being operable to control the movement of the mobile group at the first place, the method comprises the steps of: (a) generating a list for managing turns of the first activity, the moderator template and the second activity for the execution; (b) generating, during the first activity, a successor list containing link information related to the moderator template; (c) generating, by means of the moderator template, a predecessor list containing link information related to the first activity and a successor list containing link information related to the second activity; and (d) generating, during the second activity, a predecessor list containing link information related to the moderator template.<br>
[0028]<br>
According to still one more aspect of the present invention, provided is an apparatus for generating a mobile object group, the group including (i) a first activity to be executed at a first place, (ii) a second activity to be executed at a second place, and (iii) a moderator template<br>
for requiring a moderator agent to move to the second place, the moderator agent being operable to control the movement of the mobile group at the first place, the apparatus comprises: (a) means for generating, during the first activity, a successor list containing link information related to the moderator template; (b) means for generating, by means of the moderator template, a predecessor list containing link information related to the first activity and a successor list containing link information related to the second activity; and (c) means for generating, during the second activity, a predecessor list containing link information related to the moderator template.<br>
[0029]<br>
According to yet one more aspect of the present invention, provided is a computer-readable memory medium storing a program for generating a mobile object group, the group including (i) a first activity to be executed at a first place, (ii) a second activity to be executed at a second place, and (iii) a moderator template for requiring a moderator agent to move to the second place, the moderator agent being operable to control the movement of the mobile<br>
group at the first place, the program comprises: (a) program code for instructing the computer to generate, during the first activity, a successor list containing link information related to the moderator template; (b) program code for instructing the computer to generate, by means of the moderator template, a predecessor list containing link information related to the first activity and a successor list containing link information related to the second activity; and (c) program code for instructing the computer to generate, during the second activity, a predecessor list containing link information related to the moderator template.     <br>
 Brief Description of the Drawings<br>
Fig. 1 is a diagram illustrating a distributed network environment wherein a mobile agent of the present invention moves.<br>
Fig. 2 is a diagram showing an example form wherein the mobile agent of the invention moves across the distributed network.<br>
Fig. 3 is a block diagram illustrating an example hardware arrangement for a client system or for a server system according to the present invention.<br>
Fig. 4 is a block diagram illustrating example processing components at the client site according to the present invention.<br>
Fig. 5 is a block diagram illustrating example processing components at the server site according to the present invention.<br>
Fig. 6 is a diagram showing objects according to the preferred embodiment of the present invention. Fig. 7 is a diagram showing an object according to the preferred embodiment of the present invention. Fig. 8 is a diagram showing the flow of a message exchanged between objects according to the preferred embodiment of the<br>
present invention.<br>
Fig. 9 is a diagram showing a user interface for a development support tool according to the preferred embodiment of the present invention.<br>
Fig. 10 is a diagram showing a user interface for a development support tool according to the preferred embodiment of the present invention.<br>
Fig. 11 is a diagram showing a user interface for a development support tool according to the preferred embodiment of the present invention.<br>
Fig. 12 is a diagram showing the processing according to the preferred embodiment of the present invention whereby an event is transmitted to a mobile agent and is executed. Fig. 13 a flowchart showing the processing for adding a plan node to a plan object according to the preferred embodiment of the present invention.<br>
Fig. 14 is a conceptual diagram illustrating an example condition wherein a plan object is linked with plan node objects.<br>
Fig. 15 is a conceptual diagram illustrating an example condition wherein a plan object is linked with plan node objects.<br>
Fig. 16 is a conceptual diagram illustrating an example condition wherein a plan object is linked with plan node objects.<br>
Fig. 17 is a flowchart showing the processing for executing a plan object according to the preferred embodiment of the present invention.<br>
Fig. 18 is a functional block diagram illustrating a moderator template according to the preferred embodiment of the present invention.<br>
Fig. 19 is a conceptual diagram illustrating a place according to the preferred embodiment of the present invention.<br>
Fig. 20 is a flowchart showing the outline processing for a moderator template according to the preferred embodiment of the present invention.<br>
Fig. 21 is a conceptual diagram showing the condition according to the preferred embodiment of the present invention wherein a mobile object group moves from an origin place to a destination place.<br>
Fig. 22 is a conceptual diagram showing the condition according to the preferred embodiment of the present invention wherein a mobile object group moves from an origin<br>
place to a destination place.<br>
Fig. 23 is a flowchart showing the processing at the origin of an iteration template according to the preferred embodiment of the present invention.<br>
Fig. 24 is a conceptual diagram showing the condition according to the preferred embodiment of the present invention wherein a mobile object group moves from an origin place to a destination place.<br>
Fig. 25 is a conceptual diagram showing the condition according to the preferred embodiment of the present invention wherein a mobile object group moves from an origin place to a destination place.<br>
Fig. 26 is a flowchart showing the processing at the origin for an ANDSplit template according to the preferred embodiment of the present invention.<br>
Fig. 27 is a flowchart showing the logic for determining a current node according to the preferred embodiment of the present invention.<br>
Fig. 28 is a flowchart showing the processing at the destination for an ANDJoin template according to the preferred embodiment of the present invention. Fig. 29 is a flowchart showing the processing at the desti-<br>
nation for the ANDJoin template according to the preferred embodiment of the present invention.<br>
Fig. 30 is a diagram for explaining the outline of the processing at the destination for the ANDJoin template according to the preferred embodiment of the present invention.<br>
Fig. 31 is a conceptual diagram showing the condition according to the preferred embodiment of the present invention wherein a mobile object group moves from the origin place to the destination place.<br>
Fig. 32 is a flowchart showing the processing at the origin of an ORSplit template according to the preferred embodiment of the present invention.<br>
Fig. 33 is a conceptual diagram showing the condition according to the preferred embodiment of the present invention wherein a mobile object group moves from the origin place to the destination place.<br>
Fig. 34 is a flowchart showing the processing at the destination for an ORJoin template according to the preferred embodiment of the present invention.<br>
[0030]<br>
Description of the Preferred Embodiment<br>
A. Distributed network environment and hardware arrangement for each node<br>
One embodiment of the present invention will now be described while referring to the accompanying drawings. In Fig. 1 is shown a distributed network environment 150 for executing a mobile object according to the present invention. Places 102 through 107, where services can be pro-<br>
vided for mobile agents 125, 135 and 141, are prepared in servers 112 through 117, In the distributed network environment, a group of such places is called a crowd.<br>
[0031]<br>
A planner agent 113 exists in a client system 101 to generate mobile agents. The planner agent 113 transmits a generated plan to a moderator agent 111, which executes the plan, so as to move the mobile agent to a designated place.<br>
[0032]<br>
The mobile agent 125 can contact other agents that exist at the places 102 through 107 (in particular, an agent that contacts a mobile agent and provides a service is called an actor agent), and can transmit requests and receive results obtained as a consequence of the request. The places support the contacts between the agents. The mobile agent 125 can hold Results 139, 143, 153 and 163, which are the results obtained as a consequence of the requests received from an actor agent, while continuing to move. Further, during movement, the Results can be synthesized or divided, or various other processing can be performed for the Re-<br>
suits.<br>
[0033]<br>
In this invention, the movement, the splitting and the disposal of a mobile agent are controlled by moderator templates 181 through 187. A user can combine various templates in accordance with the types of processes, and can easily define a complicated job such as is shown in Fig. 2.<br>
[0034]<br>
Fig. 3 is a schematic diagram illustrating the hardware arrangement of each node (a server or a client site) that exists in the distributed network environment shown in Fig. 1. Each node 100 includes a central processing unit (CPU) 1 and a memory 4. Across a bus 2, the CPU 1 and the memory 4 communicate with a hard disk drive 13 that serves as an auxiliary memory device. A floppy disk drive (or a memory medium driver, such as an MO or a CD-ROM) 20 is connected to the bus 2 via a floppy disk controller 19.<br>
[0035] A floppy disk (or a memory medium, such as an MO or a CD-<br>
ROM) is inserted into the floppy disk drive 20, and computer software for collaborating with an operating system when giving an instruction to the CPU 1 and for accomplishing the present invention is recorded on the floppy disk, or the hard disk drive 13, and in the ROM 14. The computer software is executed by loading it into the memory 4. The computer software can be compressed, or can be divided into a plurality of portions to be recorded on a plurality of media.<br>
[0036]<br>
The node system 100 can also include user interface hardware. Example user interface hardware components are a pointing device (a mouse, a joy stick, etc.) 7 and a keyboard 6 for data input, and a display 12 for providing visual data for a user. In addition, a printer can be connected to the system 100 at a parallel port 16. The node system 100, which can have a modem connected to a serial port 15, is connected with a network via the serial port 15 and a modem, or via a token ring or a communication adaptor 18 for communication with another computer system.<br>
[0037]<br>
It can be easily understood that the present invention can be achieved by a common personal computer (PC), a workstation, a general-purpose apparatus, or a combination of the three. It should be noted that these components are only examples and that not all of them are necessarily required for the present invention. Particularly, since a server can be remote controlled, a user interface is not required for the server, and only basic data processing functions, such as a CPU and a memory, and a communication function are required.<br>
[0038]<br>
An operating system for both a client system and a server system can be an operating system that supports a standard GUI multi-window environment, such as WindowsNT (a trademark of Microsoft Corp.), Windows95 (a trademark of Microsoft Corp.), Windows3.x (a trademark of Microsoft Corp.), OS/2 (a trademark of IBM Corp.) or X-Windows (a trademark of MIT) on AIX (a trademark of IBM Corp.); an operating system in a character based environment, such as PC-DOS (a trademark of IBM Corp.) or MS-DOS (a trademark of Microsoft Corp.); or a<br>
real time OS, such as OS/Open (a trademark of IBM Corp.) or VxWorks (a trademark of Wind River Systems Inc.), and is not limited to a specific operating system environment.<br>
[0039]<br>
B. System Configuration<br>
The system configuration of a client and of a server according to the preferred embodiment of the present invention will now be described while referring to block diagrams in figs. 4 and 5.<br>
[0040]<br>
Fig. 4 is a block diagram illustrating example processing components in a client system 210. A planner agent 211 includes a plan definer 213 and a plan ID generator 215. The plan ID generator 215 allocates a unique network plan ID to a plan.- In the preferred embodiment of the present invention, the plan ID generator 215 synthesizes a URL for the Internet, a port number, an agent ID (allocated to a planner agent) and a serial number (allocated each time a planner agent generates a plan ID) to generate a plan ID.<br>
[0041]<br>
The plan definer 213 acquires a moderator template 203 and an activity 205 from a plan node library 201, and generates a moderator agent and a plan. The plan thus generated includes a plan construction section 223 for managing information for a moderator template and an activity to be executed, and an order list 225 for defining the order for a moderator template and an activity. The plan construction section 223 has information for correlating plan node objects (the general term for moderator templates and activities) and forms a network topology 231.<br>
[0042]<br>
Fig. 5 is a functional block diagram illustrating example processing components in a server system 250. A mobile object group 270 includes a moderator agent 251, a plan object 261,- a moderator template 271 and an activity 281. The moderator agent 251 has a mobile agent life cycle controller 253 and a plan executer 255. The mobile agent life cycle controller 253 controls the movement, copying and disposal of the mobile object group 270. The plan executer 255 ascertains arrival at a new place, and instructs the<br><br>
plan object 261 to execute a plan.<br>
[0043]<br>
The plan object 261 includes a plan execution controller 263, a current node 267 and an order list 265. When the plan execution controller 263 receives from the plan exe-cuter 255, in the moderator agent 251, an instruction to execute a plan, the plan execution controller 263 refers to the current node 267 and the order list 265 and determines which plan node objects 271 and 281 are currently available to perform the execution, and then requests the plan node objects 271 and 281 to execute the plan.<br>
[0044]<br>
The current node 267 corresponds to a plan node iterator, which will be described later, and monitors which plan node object is being executed. The order list 265 is a list for specifying which plan node objects 271 and 281 are to execute the plan. When no branching occurs, in accordance with the entry order in the order list 265 the plan node objects 271 and 281 are requested to execute the plan.<br>
[0045]<br>
The moderator template 271 includes a moderator agent controller 273, a plan step executor 275 and an address referral section 277. The moderator agent controller 273 requests that the mobile agent life cycle controller 253 in the moderator agent 251 move, copy or dispose of the mobile object group 270. The plan step executor 275 is defined differently in accordance with the type of moderator templates, and manages instructions that are to be executed at places before and after the movement. The address referral section 277 acquires an address from an activity and notifies the moderator agent controller 273 of an address to which to move.<br>
[0046]<br>
The activity 281 has an activity executor 283 and a message function 285. The activity executor 283 stores instructions that are executed at respective places to which the mobile agent travels, and the Results that the mobile agent obtains at these places. The message function 285 exchanges messages with an actor agent 291.<br>
[0047]<br>
The actor agent 291 is another agent that exists at the place, and provides services as requested by the activity 281. The actor agent 291 has a message function 293 for exchanging messages with the activity 281, and a message processor 295 for ascertaining the meaning of the contents of a request and for providing service.<br>
[0048]<br>
The functional blocks in Figs. 4 and 5 have been explained. These functional blocks are logical functional blocks, and are not implemented by a set of hardware or software components. They can, however, be implemented by compound hardware or software components, or by hardware or software components used in common. In addition, not all of the functional blocks in Fig. 4 and 5 are required for the present invention. For example, the order list 265 is not particularly required because the current node manger 267 directly manages current nodes and because in the ANDJoin process, etc., only a moderator agent for obtaining other Results need be determined.<br>
[0049]<br>
C. Object configuration<br>
Figs. 6 and 7 are diagrams illustrating a mobile object.<br>
Classes for a moderator agent 303, a plan 305, a plan ID 309<br>
and a plan iterator 307 each has a method, and classes for<br>
templates 321 through 326, such as a plan node 311, an<br>
activity 313, a moderator template 315 and a Chain 321, have<br>
data and a method.<br>
[0050]<br>
In Figs. 6 and 7, triangular symbols 302, 314 and 316 indicate that data and methods of the upper classes are inherited and a black dot 312 indicates that a plurality of lower classes exist. The plan node 311, which is an abstract class, defines both the moderator template class 315 and the activity class 313 by using a common interface. Therefore, the plan 305 can handle both classes equally for the generation of a plan or during the execution of a plan.<br>
[0051]<br>
A mobile agent 301 is a function (place class) currently provided at respective places in a distributed computer<br>
environment. A user can easily create a mobile agent (moderator agent) by sending to this class an API for instructing the preparation of a mobile agent. At present, this function is supported by both the Java base mobile agent and the TeleScript mobile agent, which were described in "Description of the Background".<br>
[0052]<br>
The plan node class 311 has a successor list and a predecessor list, and manages a relationship among a plurality of plan nodes. The plan node class 311 provides methods for "setPredecessor" and "setSuccessor," and defines the relationship between nodes. A specific plan node class can identify the relationships between methods.<br>
[0053]<br>
Since the moderator template class 315 is coupled with the activity class 313 that is executed at different places, the moderator template class 315 has state information for distinguishing an origin (a place before movement) from a destination (a place after movement). In the preferred embodiment of the present invention, a moderator template<br>
can only be coupled with an activity object. Chain and other templates are provided for the moderator template, so that a basic mechanism for dividing work among a plurality of split moderator agents, etc., can be provided.<br>
[0054]<br>
Fig. 8 is a diagram showing a primary flow for messages for the classes according to the preferred embodiment of the present invention.   The moderator agent 351 transmits nextStep (an instruction for the execution of the next step) to a plan 353.  Upon receipt of this instruction, the plan 353 transmits nextStep to a plan node object (a moderator template 357 or an activity 355).  The activity 355 transmits sendMessage (a request for transmission of a message) to an actor agent 359 to execute a request designated by a user.  In accordance with the message type and the condition,  the -moderator template 357 transmits getARL  (a transmission command of an address), or isMarked (marking), to the activity 355.  In addition, the moderator template 357 transmits clone (a preparation request of a clone), dispatch (a dispatch request)  and dispose (a disposal request) to the moderator agent 351.<br>
[0055]<br>
D. Preparation of planner agent<br>
A planner agent is an instruction group to be executed by a client site. When the instructions are executed, a generation request of a moderator agent is transmitted, and a plan object for defining a series of activities to be executed is generated and transmitted to a moderator agent.<br>
[0056]<br>
As is described above, the moderator agent is generated by employing functions (place classes) that are currently provided for the respective places. In the preferred embodiment of the present invention, an API for instructing the preparation of a mobile agent is transmitted to the Aglets class of a Java base mobile agent to generate a moderator agent.<br>
[0057]<br>
The plan production process is roughly classified into a procedure for generating a plan ID, and into a procedure for establishing the linking condition relative to an object located at a position lower than a plan object.<br>
[0058]<br>
In the preferred embodiment, a unique plan ID that is specifically determined by a global network is allocated for a plan object. In the preferred embodiment, the plan ID generator 215 (Fig. 4) prepares a plan ID by synthesizing a URL for the Internet, a port number, an agent ID (allocated for a planner agent), and a serial number (allocated each time a planner agent produces a plan ID).<br>
[0059]<br>
Example coding used by the plan ID generator 215 is shown in Table 1. In the preferred embodiment of the present invention, the instruction group of the plan ID generator is provided as a program part for a user.<br>
[0060]<br>
[Table 1] (Table Removed)  <br>
[0061]<br>
Table 2 shows coding when Chain template in the plan definer 213 (Fig. 4) is employed. In one mode for the preferred embodiment of the present invention, sample code including a template type is provided for a user (a programmer). The user re-creates a desired coding by using the sample code to form this instruction group.<br>
[0062] [Table 2]     (Table Removed)  <br>
 [0063]<br>
In another mode for the preferred embodiment of the present invention, a development support tool is provided to enable a user to easily perform this coding. Figs. 9 through 11 are diagrams illustrating a user interface for a development support tool according to the preferred embodiment of the present invention. A user can easily generate the above coding for the plan definer by using the development support<br>
tool.<br>
[0064]<br>
Since the development support tool constitutes a well known method provided by Workflow Automation ("Workflow Automation" is a trademark of Ultimus LLC Corp.)/ etc. (information can be acquired at http://www.ultimusl.com, etc.), specific means for accomplishing the function will not be described and only the procedures performed by a user will be explained.<br>
[0065]<br>
First, a user selects Create 371 from a pulldown menu, and clicks on it using a pointing device. The planner agent development support tool then displays a dialogue box for inputting the name of a plan. The user can therefore manage the plan with using a name that differs from a plan ID and is easy and familiar to the user. When the user enters the name of the plan in an entry box 374 and depresses an OK button 373, a plan definition window 380 is opened.<br>
[0066]<br>
By using the pointing device, the user drags an activity plan icon 399 from a plan node box 390 and drops it in the plan definition window 380.  Then, as is shown in Fig. 10, an activity property editor window 381 is opened.<br>
[0067]<br>
Entry boxes for an activity name 382, an address name (an address for a place executing an activity) 383, an actor agent name 384, and a message 385 are prepared for the activity property editor window 381. The user inputs data as desired in the respective entry boxes, and clicks an OK button 386 to define the activity.<br>
[0068]<br>
Similarly, a Chain icon 391 is dragged from the plan node box 390 to a position to the right of or under actl in the plan definition window 380, and is dropped there. In the preferred embodiment of the present invention, when a template icon other than ORSplit is dropped, a template property editor window is not displayed. When an ORSplit icon is dropped, however, the template property editor window is displayed, and the selection conditions for an<br>
activity are input. Then, as well as actl, an act2 activity is dragged and dropped to the right of or under the Chain, thereby setting a property.<br>
[0069]<br>
Following this, the user clicks on and selects two objects (e.g., actl:375 and Chain 376) in the plan definition window 380 that are to be linked, and selects Link 379 in an edit menu. Then, the two objects are linked together (a successor list and a predecessor list are generated).<br>
[0070]<br>
When all of the objects have been linked together, the user clicks on Construction 397 in the plan definition window 380. The planner agent development support tool adds the elements to the plan object to generate a planner agent.<br>
[0071]<br>
When the user clicks on Execution 398 in the plan definition window 380, an event is transmitted to the obtained planner agent and a place class, a moderator agent is generated, and the planner agent generates a plan and transmits it to the<br>
moderator agent. The moderator agent automatically executes the received plan.<br>
[0072]<br>
This process is shown in Fig. 12. An event that has occurred in the plan definition window 380 is transmitted to a planner agent 470. The planner agent 470 analyzes the event and executes object code that corresponds to Tables 1 and 2, thereby beginning definition 472 and construction 473 of a plan. A plan 477 that is thus generated is transmitted to the moderator agent 351, which in turn executes each step of the plan.<br>
[0073]<br>
In the preferred embodiment of the present invention, after a plan object has been prepared, a plurality of plan nodes may be added by using method "addNode" in the plan class. In addition, after the plan object has been prepared, a plurality of plan nodes may be removed by using method "RemoveNode" in the plan class and the successor list may be updated.<br>
[0074]<br>
D. Generation of plan<br>
D-l. Topology of case in which Chain template is included The processing whereby the planner agent shown in Tables 1 and 2 generates a plan object will now be explained by employing, as an example, a plan object that includes a Chain template generated by the development support tool, which has been explained while referring to Figs. 9 through 11.  Fig. 13 is a flowchart for the processing for adding a plan node to a plan object, and Fig. 14 is a conceptual diagram illustrating a condition where a plan object is linked with a plan node object.<br>
[0075]<br>
The Chain template, which is the simplest template, links two activities in different places. In the origin, the Chain receives an ARL (address) for an activity of a successor, and moves a mobile object group to a destination. The origin place and the destination place may be identical.<br>
[0076]<br>
When the planner agent is executed, first a plan object is<br>
generated and a plan ID is set. Next, activity object 520 and 540, which constitute a plan, are generated. As is shown in Fig. 14, a name 521 for an agent for which service is requested, an address 523 for a server for execution, and the contents 524 of a request are stored in each activity. In the example in Fig. 14, two activity objects are prepared.<br>
[0077]<br>
Following this, the two activity objects are stored in a plan object 510. A Chain template 530, which will be described later, is employed to couple the two activities. Before the activities are stored in the plan object 510, an element after which these activities are coupled must be designated. For this reason, a predecessor index list 515 is employed. In the preferred embodiment of the present invention, the predecessor index list 515 is implemented as a list.<br>
[0078]<br>
When the predecessor index list 515 is generated in the plan<br>
object 510, the planner agent adds the first activity object<br>
(actl 520) to the plan object 510. In Fig. 13 is shown the processing for adding a plan node to the plan object 510. The planner agent examines the predecessor index list 515 to determine whether or not it is vacant (block 803). Since actl 520 is the first element and the predecessor index list 515 is empty, actl 520 is added to a plan node list 513 (block 815) . The plan object 510 returns, to the planner agent, an index in the plan node list 513 as a return value (block 817) . Thereafter, the program control is returned (block 819) . In this case, index "0" is returned as a return value.<br>
[0079]<br>
Following this, the Chain object 530 is added to the plan object 510. In this case, the processing in Fig. 13 is restarted. The planner agent examines the predecessor index list 515 to determine whether or not it is empty (block 803), and since actl 520 has been registered, program control advances to block 805. At blocks 805 and 807, a check is performed whether or not all the elements in the predecessor index list 515 have been processed.<br><br>
[0080]<br>
Then, the Chain object 530 is added to the plan object 510 (block 809). First, the return value "0," obtained when actl was added, is entered into the predecessor index list 515 in order to designate actl (520), following which the activity is coupled.<br>
predecessor index list [0]<br>
[0081]<br>
The Chain object is added after actl. The plan object 510 stores the Chain object in a successor list 529 in actl, which is designated in the predecessor index list 515 (block 809). Then, actl is stored in the predecessor list 531 of the Chain 530 (block 811) . Finally, Chain 523 is stored in the plan node list 513 of the plan object 510, and its index is returned as a return value ("1" in this case) to the planner agent.<br>
[0082]<br>
Next, act2 (540) is added to the plan object 510. First, the predecessor index list 515 is cleared (information concerning actl is cleared), and a return value (1) obtained<br>
when the Chain was added to the plan is set. predecessor index list [1]<br>
[0083]<br>
Then, act2 is added following the Chain. As well as the case of the Chain, the plan object 510 stores the act2 object in the successor list 529 for the Chain designated in the predecessor index list 515 (block 809) . Following this, the Chain is stored in a predecessor list 531 in the act2 540 (block 811). Finally, act2 is stored in the plan node list 513 of the plan object 510, and its index is returned as a return value ("2" in this case) to the planner agent.<br>
[0084]<br>
D-2. Topology of case in which Iteration template is included<br>
Fig. 15 is -a conceptual diagram illustrating the condition where the plan object 510 is linked with the plan node objects. These objects are linked in the same manner as for topology of a case in which the Chain template is included. It should be noted that, as is shown in Fig. 15, an Iteration template 570 includes a return index 575 as information<br>
for a loop return destination. In the preferred embodiment of the present invention, a value for the plan object 510 in the predecessor index list 515 that corresponds to a return destination object (Chain 550) is set in the return index 575. Table 3 shows a coding example for a planner agent for topology of a case in which the Iteration template is included.<br>
[0085] [Table 3]<br>
(Table Removed) [0086]<br>
D-3. Topology of case in which ANDSplit and ANDJoin templates are included<br>
Fig. 16 is a conceptual diagram illustrating the condition where a plan object 410 is linked with plan node objects. The object group is linked in the same manner as described in topology of a case in which Chain template is included. It should be noted that the ANDSplit template has one predecessor activity and a plurality of successor activities. The successor activities can be executed in parallel in different places by the ANDSplit template.<br>
[0087]<br>
On the other hand, the ANDJoin template has a plurality of predecessor activities and one successor activity. At a destination, a plurality of moderator agents are united to<br>
constitute one agent under the control of the ANDJoin template. Table 4 shows a coding example for a planner agent for topology of a case in which the ANDSplit template and the ANDJoin template are included.<br>
[0088]<br>
[Table 4]<br>
(Table Removed) [0089]<br>
D-4. Topology of case in which ORJoin template is included An ORJoin template, as well as the ANDJoin template, has a plurality of predecessor activities and one successor activity. It should be noted, however, that for the ORJoin template one of the predecessor activities is selected and the others are discarded. This function is employed, for example, for processing whereby reservation conditions concerning a flight between Haneda and Sapporo are examined for several local airline companies, and a first airline company for which the reservation condition is obtained is employed. •Table 5 shows a coding example for a planner agent for topology of a case in which the ORJoin template is included.<br>
[0090] [Table 5]<br>
(Table Removed) [0092]<br>
The operation of a mobile object group for topology of a case in which the Chain template is included will now be described while referring to Figs. 17 through 21. Fig. 17<br>
is a flowchart showing the processing for the execution of a plan; and Fig. 18 is a functional block diagram illustrating a moderator template.   Fig. 21 is a conceptual diagram illustrating the condition where a mobile object group moves from the origin to the destination.  First, referring to Fig. 17, when a moderator agent 351 is generated and a plan object 353 is allocated for it (block 843), the moderator agent 351 automatically executes the plan (block 845).<br>
[0093]<br>
Instruction "NextStep" is transmitted from the moderator agent 351 to the plan object 353, and in response to this, the plan object 353 first extracts a current plan node (block 847) . In the preferred embodiment of the present invention, management of a step of a plan node wherein a plan iterator object 352 is located is effected, and in response to an inquiry from the plan object 353, information for the step of the current plan node wherein the plan iterator object 352 exists is provided.<br>
[0094]<br>
When the plan iterator object 352 returns a "0" (first step) in response to the current inquiry, the plan object 353 extracts actl.  Then, the plan object 353 asks an activity defined in actl to execute a request that is managed by the activity (block 849).<br>
[0095]<br>
The activity determines whether or not the class name of an agent (agent name) internally held exists at the same place. As is shown in Fig. 19, when the moderator agent 351 reaches a place 360, it tells the place 360 its agent name, and the place 360 manages the agent name using an agent list 369. An agent that exists at the place 360 may query the place 360 by sending it a "getAgentList" instruction. Since the place 360 has a function for returning AgentList, the agent can ascertain which agents exist at the same place.<br>
[0096]<br>
The activity transmits an internally held message (a request) to the agent (actor agent) 361 that is found. Upon receipt of the request, the actor agent 361 transmits a return object to an agent 350 that issued the request. The<br>
requesting agent stores the received object in a Result record 525 (Fig. 14) .<br>
[0097]<br>
The activity notifies the plan object 353 of the termination of the requested job, and in response to this, the plan object 353 adds, to actl/ a mark indicating the processing is completed (block 855) . The plan object 353 asks the plan iterator 352 to advance a step (block 859) . The plan iterator 352 provides current information for the plan object 353.<br>
[0098]<br>
Since the current information is a "1" (second step), the plan object 353 extracts a Chain template object (blocks 845 and 847) . The plan object 353 requests that the Chain performs the execution (block 849) .<br>
[0099]<br>
A Chain moderation manager 603 asks a state manager 601 for a current state. Since by default the state of the state manager 601 is set to origin, it notifies the moderation<br>
manager 603 of this. When the moderation manager 603 acguires the state information from the state manager 601, it requests the state manager 601 to switch the states. In response to this, the state manager 601 changes its state from origin to destination.<br>
[0100]<br>
Fig. 20 is a flowchart showing the switching of the state performed by the Chain template and the processing at the origin or the destination. This flowchart shows an operation performed in common with a plurality of the types of templates that exist. The processing performed at the origin at block 827 and the processing performed at the destination at block 831 are varied, depending on the template type.<br>
[0101]<br>
The moderation manager 603 asks an origin moderation module<br>
605 to perform the processing. The origin moderation module<br>
605 and a destination moderation module 607 manage a set of<br>
instructions used for operating a template at separate<br>
places.<br>
[0102]<br>
The origin moderation module 605 queries a moderator agent reference module 599 to acquire an address for the place at which the moderator agent 351 is currently present.<br>
[0103]<br>
Further, the origin moderation module 605 requests transmission by the successor list 609 of an address for an activity registered in the successor list 609. The successor list 609 acquires the address from a registered activity (act2), and transmits it to the origin moderation module 605.<br>
[0104]<br>
The origin moderation module 605 compares the received activity address with the address of the place at which the moderator agent 351 currently exists. If the two addresses are different, the origin moderation module 605 moves the moderator agent 351 to the activity address. Specifically, the origin moderation module 605 transmits movement instruction via the moderator agent reference module 599. When the two addresses are the same, the processing is thereafter<br>
terminated.<br>
[0105]<br>
At the place to which the moderator agent 351 is moved, the moderator agent 351 requests the plan object 353 to execute one step. In a like manner, the current plan node is extracted. The plan object 353 requests the Chain to execute the next step. The Chain acknowledges the state information and performs the processing for the destination. The state information is changed to the state for origin.<br>
[0106]<br>
When the plan object 353 ascertains that the Chain has completed the destination process, the plan object 353 extracts the next current plan node (act2), and requests the act2 to execute an activity. The act2 acquires the result that the actl holds internally.<br>
[0107]<br>
In the preferred embodiment of the present invention, the destination module 607 refers to a predecessor list 591 and transmits instruction "getResult" to the Chain to request<br>
the transmission of the results. Upon receipt of the instruction, the Chain performs a search to determine whether it is holding Result. Since the Chain is not holding Result, the Chain refers to the predecessor list 591 and obtains Result from an object (actl) registered in the predecessor list 591. The Chain then transmits the Result to act2. If no object is registered in the predecessor list 591, the Chain transmits, to the act2, Dummy that indicates Result is not held. This process can be replaced with a process whereby a record for storing Result is prepared for the template.<br>
[0108]<br>
The act2 employs the internally held agent class name as a key when referring to a report agent that exists at the same place. The act2 transmits an internally held message to the report agent by using as an argument the Result obtained from actl. The plan object 353 extracts the following current node. In this case, since there is no current node, the plan object 353 detects this, and the processing is thereafter terminated. The destination moderation module 607 transmits an instruction for disposing of the moderator<br>
agent 351 via the moderator agent reference module 599 to the moderator agent 351.<br>
[0109]<br>
E-2. Topology of case in which Iteration template is included (Fig. 15)<br>
Fig. 22 is a diagram illustrating the outline of an operation for a mobile object group that is controlled by an Iteration template. The processing for topology of a case in which the Iteration template is included will now be described while referring to Fig. 18. Similar to the case involving the Chain, a moderator agent 351 is generated, and a plan object 353 is generated as an argument and is transmitted to the moderator agent 351 to enable the plan object 353 to execute each step. In addition, as well as for the case involving the Chain template, the plan object 353 extracts a current plan node (Chain), and the Chain executes the process at the origin. At the destination, the process for the destination and the activity of actl are performed, as is previously described in "E-l. Topology of case in which Chain template is included."<br><br>
[0110]<br>
When the process for actl has been completed, the plan object 353 requests the Iteration template to execute the next step. Fig. 23 is a flowchart showing the processing performed at the origin of the Iteration template. In the processing at the origin of the Iteration template, first, a check is performed to determine whether the process may advance to the next step, e.g., whether Result information for actl matches a predetermined condition (block 873).<br>
[0111]<br>
When the Result information matches the predetermined condition, successor information that is internally held is stored in the successor list (block 875). An address is extracted from the act2 in the successor list (block 877), and the moderator agent 351 is moved to the address (block 879) . When the Result information does not match the predetermined condition, the state is set to the origin (block 881) , a plan node is referred to by using a return node index and is used to replace the elements in the successor list (block 883). Program control then advances to the next step. Following this, the process for the act2<br>
is performed as was described in "E-l. Topology of case in which Chain template is included," and the processing is thereafter terminated.<br>
[0112]<br>
E-3. Topology of case in which ANDSplit and ANDJoin templates are included (Fig. 16)<br>
Figs. 24 and 25 are diagrams illustrating the outline of an operation of a mobile object group that is controlled by the ANDSplit and ANDJoin templates. The process for the case of topology of a case in which the ANDSplit and ANDJoin templates are included will now be described while referring to Fig. 18. As well as for the Chain template, a moderator agent 351 is generated, and a plan object 353 that is generated as an argument is transmitted to the moderator agent 351. The plan object 353 is executed at each step.<br>
[0113]<br>
Similarly to the case for the Chain, the plan object 353 extracts ANDSplit, which is a current plan node. The plan object 353 requests the ANDSplit to execute the next step. Fig. 26 is a flowchart showing the process performed at an<br>
origin by the ANDSplit template.<br>
[0114]<br>
A moderation manager 603 examines state information in a state manager 601 and acquires "origin" information. The moderation manager 603 requests an origin moderation module 605 to perform the processing at the origin. The moderation manager 603 requests the state manager 601 to change the state to the destination (block 893). The ANDSplit refers to the successor list (block 897), extracts the first activity from the successor list and sets "0" in a marked index 595 (block 899) .<br>
[0115]<br>
Following this, the moderation manager 603 asks the moderator agent 351, through the moderator agent reference module 599, to prepare a clone of the moderator agent 351 (block 901). In response to this, the moderator agent 351 generates not only a clone of the moderator agent 351 but also copies of all of the objects, such as the plan, the template and the activity, that are held in the moderator agent 351.<br>
[0116]<br>
In response to the completion of the clone generation, the clone moderator agent that is thus generated reports its agent ID to the moderator agent reference module 599. The moderator agent reference module 599 notifies the origin moderation module 605 of the completion of the preparation of clones.<br>
[0117]<br>
In response to this, the origin moderation module 605 acquires, from the successor list 609, an address for an activity (actl) corresponding to a marked index value (0). Through the moderator agent reference module 599, the origin moderation module 605 requests the moderator agent 351 to move the clone to the address for actl (block 903).<br>
[0118]<br>
The origin moderation module 605 refers to the successor list 609 to determine whether or not the next activity is registered. When the next activity is registered, the process for preparing another clone is performed in the same manner, and the clone is moved to the place for act2 (blocks<br>
897 through 903) . At this time, the marked index 595 of the clone to be moved to act2 should differ from that of the clone to be moved to actl, and is set to "1" (block 899).<br>
[0119]<br>
When another clone has been prepared and moved to act2, the origin moderation module 605 refers to the successor list 609 to determine whether or not the following activity is registered (block 897) . In this case, since an activity no longer exists in the successor list 609, the origin moderation module 605 ascertains that the preparation and move of the clone have been terminated.<br>
[0120]<br>
Through the moderator agent reference module 599, the origin moderation module 605 transmits to the moderator agent 351 an instruction to dispose of the moderator agent 351 that remains at the origin (block 905).<br>
[0121]<br>
The clone moderator agent executes the next plan step in the<br>
separate places.  At this time, the ANDSplit template is<br>
again extracted as a current node. The flowchart for the logic to determine the next current node is shown in Fig. 27. The moderation manager 603 refers to the state manager 601 to acquire state information, ascertains that the current state is a destination, and asks the destination moderation module 607 to execute the processing.<br>
[0122]<br>
The moderation manager 603 returns the state information to the origin condition. When the plan object 353 ascertains that the destination process has been performed by the ANDSplit, the moderation manger 603 extracts a plan node (actl or act2) corresponding to a marked index, and requests the plan node to execute the activity.<br>
[0123]<br>
The plan object 353 refers to the plan iterator 352 to extract the next current node. At this time, the plan iterator 352 refers to the successor list 609 and the marked index 595 to examine a registered value (Fig. 27).<br>
[0124]<br>
The actl and act2 acquire the Result held by the activity that was previously executed. In this example, since no activity is executed prior to the ANDSplit template, the actl and act2 do not acquire the Result held by the activity that was previously executed.<br>
[0125]<br>
First, a clone agent that corresponds to actl selects the ANDJoin as the next current node. The plan object 353 asks the moderation manager 603 in the ANDJoin template to execute the next step. The moderation manger 603 examines the information in the state manager 601 to ascertain whether the process at the current origin should be performed, and transmits an execution request to the origin moderation module 605. In addition, the moderation manager 603 requests the state manager 601 to alter the state.<br>
[0126]<br>
The origin moderation module 605 refers to the successor<br>
list 609 and acquires address information for an activity<br>
(act3) registered in the successor list 609.   Via the<br>
moderator agent reference module 599, the origin moderation<br>
module 605 instructs the moderator agent 351 to move to a place that corresponds to the obtained address information.<br>
[0127]<br>
A clone agent corresponding to act2 performs the processing in the same manner as for actl, and moves to the place for act3. Since the two moderator agents have arrived at a new place, they execute the next steps. The plan object 353 extracts the ANDJoin template as a current node and executes the next step.<br>
[0128]<br>
Figs. 28 and 29 are flowcharts showing the processing performed at the destination for the ANDJoin template. The ANDJoin moderation manager 603 refers to the state manager 601, determines that the current state is a destination, and requests the destination moderation module 607 to perform the execution.<br>
[0129]<br>
Each moderation manger 603 returns the state to the origin<br>
condition.  The destination moderation module 607 of the<br>
clone that corresponds to actl refers to the predecessor list 591 and extracts an activity (actl in this case) for which an end mark is provided (block 913) . A check is performed to determine whether or not the extracted activity has the smallest index in the predecessor index list (block 915). When the activity has the smallest index, the process for receiving the Result of another clone agent is performed.<br>
[0130]<br>
More specifically, the destination moderation module 607 asks the agent reference module 597 at the same place to acquire from the place an agent list that exists there. In response to this, the agent reference module 597 at the same place queries the place 360 by transmitting to it a "getAgentList" instruction. The place 360 returns the AgentList to the agent reference module 597, so that a list of agents existing at the same place can be ascertained.<br>
[0131]<br>
The agent reference module 597 at the same place then transmits this list to the destination moderation module 607, and<br>
the destination moderation module 607 searches the list for an agent having the same plan ID (block 921).<br>
[0132]<br>
When an agent having the same plan ID is found, the plan for that agent is acquired. A current node of the acquired plan is examined (block 929}. If the current node is the same ANDJoin, the process for receiving the Result of the agent is performed. In the preferred embodiment of the present invention, a further check is performed to determine whether or not the current node index is the same (blocks 931 and 933) . Only when the current node index is the same, is a fusion process begun. This process is performed in order to prevent a processing target for the ANDJoin from being misunderstood. At this time, the destination moderation module 607 refers to the predecessor list to ascertain the number of predecessors, and performs a process for receiving the Result in accordance with the number of the predecessors.<br>
[0133]<br>
More specifically, the destination moderation module 607<br>
refers to the predecessor list 591 of the received plan, extracts an activity to which an end mark is added, and receives the Result that the activity holds. This Result is set to the Result of a corresponding activity. A process for replacing the plan node may be performed (block 935) . Fig. 30 is a diagram illustrating the outline of the process for receiving the Result.<br>
[0134]<br>
The destination moderation agent 607 detects that the Result has been set, and transmits a disposal instruction to the moderator agent 351 via the moderator agent reference module 599 (block 937). Upon receipt of this instruction, the moderator agent 351 disposes of the moderator agent itself and the objects (a plan, a template, an activity, etc.) that it manages.<br>
[0135]<br>
On the other hand, the agent that corresponds to act2 executes the next step as soon as it has arrived at a new place. The destination moderation module 607 for the agent also refers to the predecessor list 591 and extracts an<br>
activity (act2 in this case) to which an end mark is added (block 913) . A check is performed to determine whether or not the extracted activity has the smallest index in the predecessor index list (block 915) . When the activity does not have the smallest index, program control enters the Sleep state to wait for the transmission of the Result of another clone agent (block 925).<br>
[0136]<br>
Referring back to the clone corresponding to actl, the destination moderation module 607 receives the Result in accordance with the count for the predecessor list (the number of elements in the predecessor list; one in this case) . After the process for disposing of the clone is completed, the plan object 353 extracts the next current plan node (act3), and requests act3 to execute an activity.<br>
[0137]<br>
The act3 obtains the Results that are internally held by the actl and act2. In the preferred embodiment of the present invention, the destination moderation module 607 refers to the predecessor list 591, and transmits, to the clone actl<br>
and act2, a "getResult" instruction to request the transmission of the processing result. In response to the instruction, actl and act2 output their Results.<br>
[0138]<br>
The act3 employs, as a key, the class name of an internally held agent to refer to agents (report agents in this case) that exist at the same place.   The act3 transmits an internally held message to the report agent by using, as arguments, the Results obtained from the actl and act2.<br>
[0139]<br>
The plan object 353 extracts the next current node. In this case, since no current node is present, the plan object 353 detects this and terminates the processing. The moderator agent 351 detects the termination of the processing and disposes of the moderator agent and the objects that it manages. The processing is thereafter terminated.<br>
[0140]<br>
E-4. Topology of case in which ORSplit template is included<br>
Fig. 31 is a diagram illustrating the outline of an opera-<br>
tion of a mobile object group controlled by an ORSplit template. The ORSplit template differs from the Chain and ANDSplit templates in that it performs the processing shown in Fig. 32 as the process for the origin. The ORSplit template has one predecessor activity and a plurality of successor activities. At the original place, one activity is selected from the successor list by calling a method "chooseActivity," and only the selected activity is executed.<br>
[0141]<br>
In the processing for the ORSplit origin, first, the state is changed to the destination (block 982). The function "chooseActivity" is called and an activity is selected that matches a predetermined condition (block 983). The index for the activity .is regarded as a marked index (block 984). The address for the selected activity is obtained, and the moderator agent 351 is requested to move to the address (block 985).<br>
[0142]<br>
E-5. Topology of case in which ORJoin template is included<br>
Fig. 33 is a diagram illustrating the outline of an operation by a mobile object group controlled by an ORJoin template. The ORJoin differs from the Chain and the ANDJoin templates in that it performs the processing shown in Fig. 34 as a process for a destination. The ORJoin template has a plurality of predecessor activities and one successor activity. The first mobile agent that arrives at the destination generates a Dispose agent and disposes of other mobile agents.<br>
[0143]<br>
First, an ORJoin template 694, for a first mobile object group that arrives at a destination 690, transmits the method "findDisposeAgent," and determines whether or not a Dispose agent is present at the same place (block 943) . When no Dispose agent is present, a Dispose agent for disposing of other agents is generated (block 945). At this time, the plan and the count - 1 of the activities in the predecessor list are transmitted as arguments. The Dispose agent waits for a mobile object group having the count - 1 of the activities in the predecessor list, and disposes of that group. When the object group has been disposed of, the<br>
Dispose agent disposes of itself. In the preferred embodiment of the present invention, whether or not the agent arrived first at the destination 690 is employed as the condition for selecting a survivor. However, an agent that continues the processing may be determined by employing the contents of the Result as the condition.<br>
[0144]<br>
An ORJoin template 696 of another mobile object group also transmits the method "findDisposeAgent," and determines whether or not a Dispose agent is present at the same place<br>
(block 943) . In this case, since the Dispose agent is already present, a process for disposing of the Dispose agent is begun. More specifically, a check is performed to determine whether the Dispose agent has the same plan (block 947) or whether the current node index is the same (block 949) . As a result, the Dispose agent ascertains that the Dispose agent itself should be disposed of.<br>
[0145]<br>
When it is ascertained that the Dispose agent itself should<br>
be disposed of, the message "countdown" is transmitted to<br>
the Dispose agent to reduce the number of processes it performs (block 951). Then, the ORJoin template 696 transmits a request to the moderator agent 692 to dispose of the moderator agent 692.<br>
[0146]<br>
In the preferred embodiment of the present invention, a partial Join template and others are also provided that have a plurality of predecessor activities and a plurality of successor activities that are fewer in number than the predecessor activities. Since these templates can be implemented by a combination of the above described templates, no explanation for them will be given. The partial Join template can be implemented, for example, by a combination of the ORJoin template, which links a plurality of predecessor activities with one successor activity; an activity for determining, that a desired number of ORJoin templates are executed; the Iteration template, which returns to the ORJoin template in accordance with a determination as to whether that activity cleared a predetermined condition; a dummy activity; and the ANDSplit template for splitting the activity into a desired number of segments.<br>
[0147]<br>
As is described above, according to the present invention, it is possible to reduce to the minimum the employment of other resources during execution of a mobile agent.<br>
[0148]<br>
Further, according to the present invention, it is possible to reduce, through efficient processing, the processing time required before results are returned, since a mobile agent is emitted by a user.<br>
[0149]<br>
In addition, according to the present invention, it is possible to develop a mobile agent while high level programming knowledge is not required, and the effort and the time required for developing a program is reduced.<br>
[0150]<br>
Furthermore, according to the present invention, provided is a user-friendly mobile agent development program the functioning of which a developer can understand intuitively.<br><br><br>
We claim<br>
l.A memory medium storing an object being a member of a mobile object group, said group being operable to move from a first place to a second place under the control of a moderator agent and to execute a first activity at said first place and a second activity at said second place, said memory medium storing:<br>
-	a predecessor list having link information relative to said first activity;<br>
-	a successor list having link information relative to said second activity; and<br>
-	a moderation module for requiring said moderator agent to move from said<br>
first place to said second place.<br>
2.	A memory medium storing an object being a member of a mobile object group as claimed<br>
in claim 1 wherein said group being operable to move from a first place to a second place<br>
under the control of a moderator agent and to execute a first activity at said first place and a<br>
second activity at said second place, said memory medium storing:<br>
-	a predecessor list having link information relative to said first activity;<br>
-	a successor list having link information relative to said second activity;<br>
-	a state manager for determining whether said moderation module exists at said first<br>
place or at said second place; and<br>
-	a moderation module for requiring said moderator agent to move from said first place<br>
to said second place.<br>
3.	A memory medium storing an object group as claimed in claim 1 wherein said group being<br>
operable to move from a first place to a second place under the control of a moderator agent<br>
and to execute a first activity at said first place and a second activity at said second place,<br>
said memory medium storing:<br>
-	a moderator template including<br>
-	a predecessor list having link information relative to said first activity,<br>
-	a successor list having link information relative to said second activity,<br>
a state manager for determining whether said moderation module exists in said first place or in said second place, and<br>
-	a moderation module for requiring said moderator agent to move said mobile<br>
object group from said first place to said second place;<br>
-	a plan iterator for determining for which of said first activity, said second activity and<br>
said moderator template authority for execution currently exists; and<br>
-	a plan object for managing turns of said first activity, said second activity and said<br>
moderator template for the execution.<br>
4.	A method for controlling a mobile object group, said group being operable to move to a<br>
first place specified by a first address and to a second place specified by a second address<br>
under the control of a moderator agent, and to execute a first activity at said first place and a<br>
second activity at said second place, said method comprising the steps of:<br>
-	requesting said moderator agent to prepare a first mobile moderator agent having link<br>
information relative to said first activity and a second mobile moderator agent having<br>
link information relative to said second activity;<br>
-	obtaining said first address;<br>
-	obtaining said second address;<br>
-	requesting that said first mobile moderator agent move to said first place; and<br>
-	requesting that said second mobile moderator agent move to said second place.<br>
5.	A method for controlling a mobile object group as claimed in claim 4 wherein said group<br>
being operable to move to a first place specified by a first address, to a second place specified<br>
by a second address and to a third place specified by a third address under the control of a<br>
moderator agent, and to execute a first activity at said first place, a second activity at said<br>
second place and a third activity at said third place, said method comprising the steps of:<br>
-	requesting that said mobile moderator agent at said first place prepare a first mobile<br>
moderator agent having link information relative to said second activity and a second<br>
mobile moderator agent having link information relative to said third activity;<br>
obtaining said second address;<br>
-	obtaining said third address;<br>
requesting that said first mobile moderator agent move from said first place to said second place;<br>
-	requesting that said second mobile moderator agent move from said first place to said<br>
third place;<br>
-	requesting execution of said second activity at said second place; and<br>
requesting execution of said third activity at said third place.<br>
6.	A method for controlling a mobile object group as claimed in claim 4 wherein said group<br>
eing operable to move to a plurality of places under the control of a moderator agent and to execute an appropriate activity at each of said places, said method comprising the steps of:<br>
-	executing, at a first place, a first activity linked with a first mobile moderator agent to<br>
acquire first processing results;<br>
-	requesting that said first mobile moderator agent, which exists in said first place and<br>
which holds said first processing results, move to a second place;<br>
-	executing, at a third place, a second activity linked with a second mobile moderator<br>
agent to acquire second processing results;<br>
-	requesting that said second mobile moderator agent, which exists in said third place<br>
and which holds said second processing results, move to said second place;<br>
-	requesting that said second mobile moderator agent at said second place transmit said<br>
second processing results to said first mobile moderator agent; and<br>
said first mobile moderator agent at said second place holding both said first and said second processing results.<br>
7.	A method for controlling a mobile object group as claimed in claim 4 wherein said group<br>
being operable to move to a plurality of places under the control of a moderator agent and to<br>
execute an appropriate activity at each of said places, said method comprising the steps of:<br>
-	executing, at a first place, a first activity linked with a first mobile moderator agent<br>
having agent identification information and acquiring first processing results;<br>
-	requesting that said first mobile moderator agent, which exists in said first place and<br>
which holds said first processing results, move to a second place;<br>
-	executing, at a third place, a second activity linked with a second mobile moderator<br>
agent having the same agent identification information as that of said first mobile<br>
moderator agent and acquiring second processing results;<br>
-	requesting that said second mobile moderator agent, which exists in said third place<br>
and which holds said second processing results, move to said second place;<br>
-	requesting that said second mobile moderator agent at said second place transmit said<br>
second processing results to said first mobile moderator agent;<br>
searching  said  second  place  for a  mobile  moderator agent having  the  same identification information as said agent identification information; and said first mobile moderator agent at said second place holding both said first and said second processing results.<br>
8.	A mobile object group, said group being operable to move from a first place to a second<br>
place and to execute a first activity at said first place and a second activity at said second<br>
place, said mobile object group comprising:<br>
-	a plan object for managing turns of said first activity and said second activity for the<br>
execution; and<br>
-	a plan iterator for determining for which of said first activity and said second activity<br>
authority for execution currently exists.<br>
9.	A method for generating a mobile object group, said group including a first activity to be<br>
executed at a first place, a second activity to be executed at a second place, and a moderator<br>
template for requiring a moderator agent to move to said second place, said moderator agent<br>
being operable to control the movement of said mobile group at said first place, said method<br>
comprising the steps of:<br>
-	generating, during said first activity, a successor list containing link information<br>
related to said moderator template;<br>
-	generating, by means of said moderator template, a predecessor list containing link<br>
information related to  said  first activity and  a successor list containing link<br>
information related to said second activity; and<br>
generating, during said second activity, a predecessor list containing link information related to said moderator template.<br>
10.	A method for generating a mobile object group as claimed in claim 9 wherein said group<br>
including a first activity to be executed at a first place, a second activity to be executed at a<br>
second place, and a moderator template for requiring a moderator agent to move to said<br>
second place, said moderator agent being operable to control the movement of said mobile<br>
group at said first place, said method comprising the steps of:<br>
-	generating a list for managing turns of said first activity, said moderator template and<br>
said second activity for the execution;<br>
-	generating, during said first activity, a successor list containing link information<br>
related to said moderator template;<br>
-	generating, by means of said moderator template, a predecessor list containing link<br>
information related to  said  first activity and  a successor  list containing link<br>
information related to said second activity; and<br>
-	generating, during said second activity, a predecessor list containing link information<br>
related to said moderator template.<br>
11.	An apparatus for generating a mobile object group, said group including a first activity to<br>
be executed at a first place, a second activity to be executed at a second place, and a<br>
moderator template for requiring a moderator agent to move to said second place, said<br>
moderator agent being operable to control the movement of said mobile group at said first<br>
place, said apparatus comprising:<br>
-	means for generating, during said first activity, a successor list containing link<br>
information related to said moderator template;<br>
-	means for generating, by means of said moderator template, a predecessor list<br>
containing link information related to said first activity and a successor list containing<br>
link information related to said second activity; and<br>
-	means for generating, during said second activity, a predecessor list containing link<br>
information related to said moderator template.<br>
12.	A computer-readable memory medium storing a program for generating a mobile object<br>
group, said group including<br>
(i)       a first activity to be executed at a first place,<br>
(ii)      a second activity to be executed at a second place, and<br>
(iii)     a moderator template for requiring a moderator agent to move to said second<br>
place, said moderator agent being operable to control the movement of said<br>
mobile group at said first place, said program comprising:<br>
(a)	program code for instructing said computer to generate, during said first activity, a<br>
successor list containing link information related to said moderator template;<br>
(b)	program code for instructing said computer to generate, by means of said moderator<br>
template, a predecessor list containing link information related to' said first activity and a<br>
successor list containing link information related to said second activity; and<br>
(c)	program code for instructing said computer to generate, during said second activity, a<br>
predecessor list containing link information related to said moderator template.<br>
13.	A memory medium storing an object being a member of a mobile object group<br>
substantially as herein described with reference to and as described in the accompanying<br>
drawings.<br>
14.	A method for controlling a mobile object group substantially as herein described with<br>
reference to and as described in the accompanying drawings.<br>
15.	A mobile object group substantially as herein described with reference to and as<br>
described in the accompanying drawings.<br>
16.	A method for generating a mobile object group substantially as herein described with<br>
reference to and as described in the accompanying drawings.<br>
17.	An apparatus for generating a mobile object group substantially as herein described<br>
with reference to and as described in the accompanying drawings.<br>
18.	A computer-readable memory medium storing a program for generating a mobile<br>
object group substantially as herein described with reference to and as described in the<br>
accompanying drawings.<br><br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">677-del-1998-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">677-del-1998-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">677-del-1998-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LWNvcnJlc3BvbmRlbmNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">677-del-1998-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">677-del-1998-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">677-del-1998-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">677-del-1998-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LWZvcm0tMTkucGRm" target="_blank" style="word-wrap:break-word;">677-del-1998-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">677-del-1998-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">677-del-1998-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LWZvcm0tNC5wZGY=" target="_blank" style="word-wrap:break-word;">677-del-1998-form-4.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LWZvcm0tNi5wZGY=" target="_blank" style="word-wrap:break-word;">677-del-1998-form-6.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LWdwYS5wZGY=" target="_blank" style="word-wrap:break-word;">677-del-1998-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LXBjdC0yMTAucGRm" target="_blank" style="word-wrap:break-word;">677-del-1998-pct-210.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LXBldGl0aW9uLTEzNy5wZGY=" target="_blank" style="word-wrap:break-word;">677-del-1998-petition-137.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Njc3LWRlbC0xOTk4LXBldGl0aW9uLTEzOC5wZGY=" target="_blank" style="word-wrap:break-word;">677-del-1998-petition-138.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="217422-a-percutaneous-surgical-instrument-for-de-bulking-calculi-or-drilling-bone.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="217424-a-phenyl-oxazolidinone-compound-having-anti-bactorial-activity.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>217423</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>677/DEL/1998</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>15/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>11-Apr-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>26-Mar-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>18-Mar-1998</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTERNATIONAL BUSINESS MACHINES CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>ARMONK, NEW YORK 10504, UNITED STATES OF AMERICA.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>KAZUHIRO MINAMI</td>
											<td>GREENHILLS 201, 2-33-2 FUTAMATAGAWA, ASAHI-KU, YOKOHAMA-SHI, KANAGAWA-KEN, JAPAN.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>TOSHIHIRO SUZUKI</td>
											<td>PLUM HOUSE B-101,2-9-17 KACHIDAMINAMI, TSUZUKI, YOKOHAM-SHI, KANAGAWA-KEN, JAPAN.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>9-92091</td>
									<td>1997-04-10</td>
								    <td>Japan</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/217423-method-and-system-for-generating-and-controlling-a-mobile-object by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 11:44:16 GMT -->
</html>
