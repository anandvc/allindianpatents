<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/219788-method-and-apparatus-for-concurrent-dbms-table-operations by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 11:27:56 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 219788:METHOD AND APPARATUS FOR CONCURRENT DBMS TABLE OPERATIONS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD AND APPARATUS FOR CONCURRENT DBMS TABLE OPERATIONS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method for unloading database tables, comprising the steps of: launching a number of threads to process the database tables; assigning a respective one of said database tables to a corresponding of said threads; and unloading each respective dataabase table by a process of the corresponding thread. A method for unloading database tables, comprising the steps of: launching a number of threads to process the database tables; assigning a respective one of said database tables to a corresponding of said threads; and unloading each respective database table by a process of the corresponding thread.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
Method and Apparatus for  Concurrent DBMS Table Operations<br>
Background of the Invention<br>
Field of the Invention	<br>
This invention relates to a process a£ unloading and loading a database table. The invention is more particularly related to the application of parallel processing techniques to increase the speed at which database tables are unloaded and loaded. The invention is still further related to parallel processing techniques applied to unloading and loading database tables in a Symmetrical Multi-Processing . (SMF] environment.<br>
Discusaion of the Background Modem   database   management   systems   are increasingly called upon to maintain larger stores of data.  In addition to the increased size of databases, the structure within modem databases la increasingly complex.<br>
Typically, a database maintains data in the form of tables, each table maintaining one or more rows of related data. As an example, a basic database table may maintain plural rows having, for example, name, social security number, address and telephone number of Individuals belonging to an organization.<br>
The database would be increased in size as the organization adds new members, and would Increase in both size and complexity as additional information about members is included. For example, a larger and more complex database could maintain, in addition to the above information, a map, perhaps in graphical format, showing the club members' residence.  The<br><br>
database could again be increased in size and complexity by including a work address and an additional graphical map showing the location of the work place.<br>
The database table may again be increased in complexity by maintaining pointers to other tables or rows of the database. For example, a pointer to a set of coworfcers maintained in another table, pointers to nearby organization members, or a pointer(s) to any number of items to where additional member data may be maintained.<br>
Conventional Database Management Systems (DBMS) provide space for building database tables by allocating blocks. Once a table is defined, the DBMS will allocate blocks necessary for storing rows of the related data. For example, if a table is to be built to contain 100,000 rows, and the rows of the table were defined such that 100 rows could fit per block, the DBMS would allocate 1,000 blocks to build the table.<br>
Generally, DBMS systems allocate blocks in sets of contiguous blocks. A contiguous set of allocated blocks is commonly referred to as an extent. As a general rule, extents vary in size. Using the above exanple, the DBMS may utilize a single extent of 1,000 blocks, 2 extents of 500 blocks, or any other combination of extent sizes to allocate the required 1,000 blocks to build the table. Once the required blocks are allocated, the data is then stared in rows in the table utilizing the blocks allocated.<br>
Over the course of time, additional data may be added to the table and the DBMS will allocate additional blocks as required. For example, if a user adds 250 rows to the table, using the above parameters, an additional 3 blocks would need to be allocated.<br><br>
Also over Che course of time, information in the database may be deleted. In this case, deletion of rows occurs through the use of SQL to delete tows from the table. For example, a user may delete fifty rows from block 1, 40 rowa from block 20, and 30 rows from block 60. When this occurs, it causes there to be more blocks in the table than required to maintain. the data present in the table.<br>
In addition, data within the database will be updated. For example, using the above-described database tables, a organization member who has not yet entered the workforce would have a row in the table allocated that maintained his/her name, address, social security and telephone number. Upon entering the workforce, the row would be updated to include the work address and related information. However, if a substantial amount of information is added as a result of the update, the original row may not have enough blocks of data allocated to maintain the updated information.<br>
Row migration occurs when a row gets updated and the original row does not have enough space to hold all of the updated information. When this occurs, the row is moved to a location with more space, and a pointer is placed in the block where the original row resided, the pointer being set to point to the location of the moved (migrated) row. A large amount of row migration is caused if there are substantial updates to a table and an inadequate amount of space was allocated for the original rows.<br>
More often then not, there is insufficient space within a block to hold an updated row. In this case, the row is migrated to an entirely different block than where the original row resided, and the pointer is<br><br>
placed in the original row position points to the updated row in the different hlock.<br>
Anytime a row is migrated it causes what is known as fragmentation. Fragmentation causes greatly increased retrieval time of database infozmation because in addition to reading a block, a pointer must be read and interpreted. When a row is migrated to another block, at least two blacks (the block containing the pointer, and the block containing the migrated/fragmented row) must be read to retrieve row specific information. Other structural changes within the database tables also cause fragmentation and related efficiency problems (row chaining, for example) .<br>
From time to time, the Database Adiministrator (DBA) will perform an analysis on the DBMS tables that provides information regarding the condition of the tables. For example, the database administrator may look at information regarding the number of deleted rows to ascertain efficiency information with respect to how many blocks are holding deleted rows. As another example, the Database Administrator may look to see how many rows of a table have been nigrated or fragmented by other processes.<br>
If a lot of fragmentation has occurred, it indicates that block size and row space could be more efficiently allocated and that table data is not being retrieved efficiently. When this occurs, the databaae administrator will likely decide to rebuild the tables. When creating a table, the DBA makes a decision regarding the structure of a database table by setting a percentage of blocks free (PCTFREE) or percentage of blocks used (PCTUSED). As the DBMS fills up each block with row or table information,  it will keep a<br><br>
percentage of a block free at least equal to the percentage PCTFREE.<br>
The DBA sets the PCTFHES variable depending on how the database table is to be used.  For example, if a table is to have frequent updates, additional PCTFREE would be established so that enough space is available to allow any necessary row migration to occur within the same block.  As discussed above, row migration within the same block does not cause a table to became fragmented.  Migrated, but non-fragmented rows are retrieved with a single block read rather than the cumbersome process of reading a block, interpreting a pointer, and reading a second block (or more) as occurs when migrated rows are fragmented.   Therefore, appropriate PCTFREE settings allow DBMS performance to be maintained although the database tables may be modified.<br>
PCT17SED is another parameter that allows the DBA to control the structure of a DBMS table. The DBMS prevents additional rows to be placed in a block unless the percentage of that block has fallen below PCTUSED. PCTUSED is different from PCTFREE in the sense that although a block may be used if there is an update, it will not be used to insert a new row unless the percentage used in the block is below PCTUSED,<br>
A DBMS table involved in heavy OLTP activity (inserts, updates and deletes) over time will likely experience row migration, fragmentation, row chaining, etc. Furthermore, various database tables may not necessarily have appropriate settings (PCTFREE, PCTUSED, for example) when first built, or the needs of the database table may have changed, resulting in additional migration, deletion or fragmentation of<br><br>
tables. This In turn results in a degradation or data retrieval performance and space usage.<br>
The DBA will perform an analysis to determine whether the tables are storing data efficiently. As a result, one or more of the DBMS tables may be determined to being inefficient In storing and retrieving data. Reorganization (rebuilding) of the table is a solution to this problem. In order to achieve maximum performance the table needs to be rebuilt (i.e., the data unloaded into secondary space and a fresh instance of the table rebuilt). This process gets rid of many of the imvanted effects mentioned above because the fragmented rows are unloaded and stored without fragmentation in the rebuilt table.<br>
Structurally sound databases make efficient use of disk space. They require less time to access data, reduce the time required for normal transactions, and provide better response time to the user. Even though Oracle and other modem database systems use efficient logic for data placement, normal activity over time causes the physical layout of the data on disk to degrade and space requirements to grow. This results in excessive space usage and extra time needed to perform table scans, database backups, and other functions. Partial empty pages and unused extent space contribute to the additional space usage. Also, nonsequential rows and extent interleaving seriously degrade performance if they are not resolved periodically.<br>
One method to ensure that databases stay efficient<br>
(increasing productivity) is to regularly perform<br>
reorganizations on the databases' data.  Currently,<br>
products are available to reorganiza -OBMS tables.<br><br>
However, even with automated reorganization tools, reorganization of database tables can require substantial amounts of time. The time required to perform a reorganization can have substantial effects on revenue or productivity of a shop tliat requires database access. For example, some shops can incur costs of approximately $100,000 an hour when a database is off-line {See Dec. 1997 issue of Oracle magazine, "Reorgs in a Non-Stop Shop," for example} . Therefore, any improvement in efficiency or speed at which a reorganization is performed would increase competitiveness and profitability.<br>
Summary of the Invention<br>
The present inventor has realized the need to provide fully parallel operations supporting database table unloading and loading which will increase the speed of any database operations performing either one or both of table unloading and table loading-.<br>
Accordingly, it is an object of the present invention to provide a parallel processing technique that allows for parallel database table unloads.<br>
It is another object of this invention to provide a method for unloading and loading database tables utilizing parallel processing techniques in a Symmetric Multi-Processing (SMP) environment.<br>
It is yet another object of this invention to provide a method for preventing bottlenecks in parallel unloading and loading of database cables.<br>
It is still yet another object of the present invention to increase the speed at which a. reorganization of database tables is performed by utilizing the parallel processing techniques of the present invention.<br><br>
These and other objects are accomplished by a method for performing parallel unloading of database tables, including the steps of launching a number of threads to process the database tables, assigning a respective one of the database tables to a corresponding of said threads and unloading each respective database table by a process of the corresponding thread. The method allows the table unload process to CaJce advantage of a Symmetric Multi-Processing (SMP) environment to significantly improve the speed of database table unloads.<br>
The invention includes a method o£ parallel loading of table data including the steps of loading data into database tables, including the steps of determining X threads for loading data into database tables, creating X tea^orary tables, each temporary table corresponding to a set of data stored in an export directory, launching an SQL*LOftDER™ process for loading each temporary table, and loading each temporary table with the data stored in the corresponding export directory via the corresponding SQL*LOADER™ process.<br>
Brief Degerintion of the Drawings A more complete appreciation of the invention and many of the attendant advantages thereof will be readily obtained as the same be comes better understood by reference to the fallowing detailed description when considered in connection with the accompying drawings, wherein:<br>
Figure i is a flow chart illustrating a database fast imload/load(PDL)procedur6;<br>
Figure 2 is a flowchart illustzrating the iterative nature of non-concurrent database unload procedure;<br><br>
Figure 3 is a flowchart illustrating high level processes for concurrent load and unload of database tables according to the present invention;<br>
Figure 4 is an illustration of parallel processes performed on a single export disk;<br>
Figure 5 is an illustration of parallel processes performed using multiple export disks according Co the present invention;<br>
Figure 6 is an illustration of plural storage devices maintaining database tables and export directories according to the present invention;<br>
Figure 7 is a flowchart illustrating e^^ort (unload) process according to the present invention;<br>
Figure 8 is an illustration of a Destination Tab Property Page according to the present invention;<br>
Figure 9 illustrates a Parallel Query Tab page according to the present invention;<br>
Figure 10 is a flowchart illustrating a parallel load process according to the present invention;<br>
Figure IZ illustrates a Concurrent Table Reorganization with a parallel export phase and a parallel direct load according to the present invention;<br>
Figure 12 is a flowchart illustrating a fail safe/fault recovery system for the unload/load processes according to the present invention; and<br>
Figure 13 is a flowchart illustrating high level table name and loading processes according to the present invention.<br><br>
Detailed Description of the Invention<br>
CONCURRENT UNLOAD/LOAD OPTION IN TS REORGANIZATION<br>
The present inventor has developed a new Concurrent Unload/Load methodology. This methodology will be utilized in an Unload/Load option to be introduced in Platinum TS reorg V2.1.0 to enhance the speed of tablespace reorganization. Previously, the fastest way to reorganize a tablespace in TS reorg was to use Fast Unload in conjunction with the Parallel Direct Load option.<br>
Referring now to the drawings, wherein like reference numerals designate identical or corresponding parts throughout the several views, and more particularly to Figure 1 thereof, is a flowchart illustrating a Fast Unload/Load process. At step 100, a single Fast Unload process unloads each table, and steps 100a . . 110n illustrate parallel direct loads utilized to load tables.<br>
Figure 2 is flow diagram detailing the Fast Unload process. At step 200, a Past Unload is performed on a table. The Fast Unload reads and stores data from the table. At step 210, it la determined whether a next table in the database (s) is to be unloaded and the process is repeated until each table is unloaded.<br>
As illustrated by the process in Figures 1 and 2, in Parallel Direct Load, the tables are unloaded sequentially using one single process on the unload and multiple SQL*LOADER™ (an ORACLE utility) processes on the load, while working on only one table at a time. For example, when unloading a tablespace containing a large number of tables, TS reorg must wait for one<br><br>
table to be completely unloaded before it can process the  next table.<br>
Figure 3 illustrates the Concurrent Unload/Load option of the present invention that enables a user to take advantage of multi-CPU machines to unload (step 300) and load (step 305) multiple tables concurrently. This method is particularly efficient when the tablespace contains a combination of both large and small tables. Then, while TS reorg unloads and loads one large table, it can also unload and load several small tables simultaneously. The principles of the present invention are also extended to the concurrent building of multiple indexes and/or constraints.<br>
The Concurrent Unload/Load process o£ the present invention are best practiced in a computing and database environment having the following characteristics:<br>
(1) Symmetric Multi Processing (SMP) computing environment - impropriate computing hardware contains multiple CPUs and must accommodate a symmetrical multiprocessing environment. The higher the symmetrical multiprocessing capacity of a hcst machine, the higher performance potential.<br>
One type of multiprocessor computer is a aynmetric multiprocessor (SMP) computer. An SMP computer usually has between 2 and 16 processors, all of which share the computer's single memory source and shared storage devices. The SMP capacity depends on the number of processors available. With more processors, the present invention allows more queries and loads to be performed in parallel.<br>
(2) Datafiles partitioned across multiple disks -The datafiles of the tablespace to unload reorganization must be stored on different physical<br><br>
disks. This requirement is needed to obtain full benefit from the Concurrent Unload/Load processes of the present invention.<br>
(3) Defined export directories on disks - A number of threads used for the Concurrent Unload/Load option processes will be less than or equal to the number of export directories. These directories are best utilized when residing on separate physical disks. Even with a high SMP capacity and efficient parallel operations, data movement can experience a tottlsneck, or a halting reduction in speed, because of the limited bandwidth of physical storage dis3cs. One of the few limitations of SMP occurs when physical disks cannot quickly accommodate the simultaneous read and write requests made by the numerous CPUs.<br>
Another source of interrupted data, especially in parallel processing, is disk contention. When multiple processes attempt to access and change a database, the disk head can serve the rec[uest of only one process at a time, causing the other operations to wait. This situation of two processes simultaneously trying to access the same disk is called disk contention. The result of disk contention is clogged data, or a bottleneck.<br>
Since parallel processes use multiple CPUs to move data between memory and disks, it is important to have multiple disks defined, so that the numerous CPUs can quickly move the data without interruptions or waiting. One way to eliminate bottlenecks is by partitioning the data to multiple disks. Partitioning data is the process of physically spreading the data across multiple disk drives to reduce the limiting effects of disk I/O bandwidths and disk contention. The more disks you define (partition) for data export,<br><br>
the more you reduce I/O bottlenecks, which results in faster parallel operations.<br>
Figure 4 illustrates parallel processes using only one export disk. Even though the server's query coordinator breaks the query into two separate operations, the disk head can serve the request of only one scan at a time, causing the other operations to wait, or bottleneck. In this exan^le, the single disk's I/O limitations defeat the purpose of the server's parallel process features. Resolving this problem depends on proper disk allocation.<br>
Figure 5 illustrates one embodiment of a proper disk allocation, and parallel processes using numerous export disks (partitioned data) . The parallel processes run simultaneously, rather than one process waiting for the other.<br>
Using Concurrent Threads in TS reorg<br>
The Concurrent Load/Unload processes of the present invention utilize a number of defined threads that determines a number of tables to be tmloaded/loaded at the same time. In other words, the number of concurrent threads is equal to the number of processes that TS reorg launches in the unload and load phase. Bach of these processes works on one table.<br>
The number of defined threads is limited by a number of export directories. Figure 6 illustrates an SMP computing environment having three separate disks, 310a, 310b, and 31.0c, each disk storing datafiles and each having an export directory 320a, 320b, and 320c. In the illustrated environment the Concurrent Load/Unload would define three threads (one per export directory) for unloading tables.<br><br>
Concurrent Unload Phase<br>
Figure 7 ia a flowchart illustrating the Concurrent Unload phase of the present invention. At step 400, a number of threads to be utilized in a current confuting environment is determined. The number of threads to utilize is provided by a user via a GUI or other input device. However, the number of threads is also limited to a maximum equivalent to a number of export directories residing on separate disk drives. For example, TS reorg now utilizes a destination Tab Property Page to enter, change or delete the export directory paths designating the location for the unloaded data and other export files during a tablespace reorg (see Fig. 8).<br>
During the export phase of a tablespace reorg, the reorg utility uxiloads the Data Description Language (DDL) and table data from the tablespace and exports it to a specified directory. The Host Directory Path(s) for Export is the directory path designating the location for the unloaded DDL and data during a reorg.<br>
The Destination tab property page is utilized to do the following:<br>
•	Add a host export directory.<br>
•	Delete a host export directory. .   Modify a host export directory.<br>
If insufficient space available in the export directory or the export file size reaches the ulfmit while the reorg utility is unloading data, the reorg utility aborts the remaining data to the next specified export directory. If another export directory is not specified, the TS reorg will not perform the reorganization.<br>
This removes the 2-gigabyte limit common on most UNIX platforms.  Since a compressed file cannot be<br><br>
split, this does not apply to a compressed export method (described hereinafter).<br>
At step 410, TS reorg launches a same number of Fast Unload processes as the number of defined threads. This is referred to as the first set of Feist Unload processes.<br>
At Step 420, a table is assigned to each process. Each Past Unload process is executed by the corresponding thread and unloads the assigned table into one of the separate export directories (step 430). To search for a directory on which to unload data, each thread checks all of the export directories and chooses the smallest available directory that can accommodate the created export file. Such a method is known as finding the best fit for the export directories. Once a thread finds a best fit directory, it claims that directory, so the next thread must choose  another.<br>
In the event that other applications are using space on the same file system, a thread might not load all its data into its chosen best fit directory. If this occurs, the reorg utility splits the export file into multiple export files and attempts to write it on another export directory. If there is no alternate export directory, or if the disk is full, the thread terminates and one of the remaining threads unloads the remaining data.<br>
A user may estimate the size of the user's export files in order to assign enough space in an export directory for those files. To estimate the size of an export file, divide the current allocation of an object by the number of threads to be utilized.<br>
The reorg utility utilizes a Parallel Query tab property page, as shown in Figure 9, to fill in fields<br><br>
along with amy existing parallel parameters for the object. For example, a table's parallel parameters might exist if that table was initially created or revised using parallel parameters. Those parameters are retained within the taiale' s Data Description Language (DDL) and the Data Dictionary. If parallel parameters already exist for an object, the reorg utility splits the data query automatically, and a user need not specify values in the Parallel Query tab property page. Otherwise, Che reorg utility splits the query according to the parameters set in the Parallel Query tab property page.<br>
For full advantage of the present invention, the number of export directories is equal to or greater than the number of threads. Also, each export directory should reside on a separate physical disk to avoid disk I/O bottlenecks. As discussed above, I/O bottlenecks will likely occur if more than one export directory is located on a same disk because of the possibility of more than one process writing (unloading] to the same disk at the same time.<br>
When the first Fast Unload process of the first set of threads finishes, TS reorg checks if the process was successfully terminated (step 440}, if that was the case, the next Fast Unload process to unload a next table is launched {step 470).<br>
In this manner, each table is unloaded by a process executed in it's respective thread. Each thread is independent, therefore if one thread has a process assigned to a large table, the other processes need not wait for the large process to finish before launching the process for the next table.<br>
Otherwise, if a problan occurred during the unload of the table, TS reorg displays a reason why the<br><br>
process failed (step 450), along with eventually the Fasc Unload logfile in the job logfile. The table that a problem occurred is unloaded using an internal unload program of TS reorg. This unload program is not launched as a separate process and therefore it has to be finished before TS reorg can continue with the concurrent unload of the rest of the tables.<br>
Once all the tables have been successfully unloaded, the unload process is completed, A performance meter (estimated, or interactive) may also be implemented to display the speed of unload/load operations and an amount of disk space being consumed.<br>
Once the unload process is completed, TSreorg continues with the next step of the tablespace reorganization which is the export of other objects of the tablespace (step 485).<br>
Export. o£ other objects includes the creation of a files for storing the DDL of the tablespace including all indexes, triggers, constraints, and primary or unique keys (everything except the table and clusters).<br>
Finally, TS reorganization performs a drop on the unloaded tables (step 490) , and then performs a concurrent load (step 495) loading the unloaded data into fresh tablespace.<br>
Concurrent Load Phase<br>
After dropping all of the tablespace objects, TS reorg begins the load (insert) phase of the reorganization. The concurrent load phase is illustrated in the flowchart of Figure 10. At step 600, TS reorg begins the load phase by creating tables to store the data. TS reorg sequentially creates as many tables as the number of threads specified,  The<br><br>
specified number of threads is equivalent to the number of threads in the unload phase.<br>
After the first set of tables is created, TS reorg simultaneously launches the SQL*LOADER™ processes used to load the data of each corresponding table. The number of processes launched is equal to the number of threads. Each SQL*LOADER™ process loads data for one corresponding table, reading table data from an export directory and loading that data into the corresponding table (step SIO) .<br>
The reorg utility recreates the objects, eliminating fragmentation and optimizing storage parameters, using the DDL in the export files. The reorg utility coordinates multiple CPUs in parallel threads to load the data back into the objects, resulting in a reorganized tablespace.<br>
After one of these processes is consisted, TS reorg checks if the data was successfully loaded back into the table and if the number of rows inserted was correct {Step 620) . If an error occurred during the load or the number of rows inserted by SQL*LOADER™ was not correct, TS reorg switches automatically to the internal TS reorg load function to load sequentially the data before continuing with the next table (step 630) . If there was no error with the SQL*L0ADER" process, or after the internal load terminated without error, TS reorg creates Che next table (step 650) and launches concurrently still another SQL*LOADER™ process to load this table's data (repeating step 610).<br>
As illustrated in the concurrent Table Reorganization diagram shown in Figure 11, a concurrent direct load invokes multiple CPUs, each of which executes a separate SQL+LOADER'" session to synchronously load data from the export file:3 back into<br><br>
the object's datafiles. When SQL*ljQADBR™ writes to these datafiles, the reorg utility uses the best fit method, which selects those partitioning directories that have enough space to acccanmodate the incoming data. The reorg utility then continues using the hest fit method within that selected list of directories and chooses the smallest datafile that can accommodate all of the incoming data for the thread. Each thread loads its data into as much free space in a datafile as it can.<br>
If a fatal error occurs during the load phase, or if the reorganization job is canceled or killed for any reason, the failed job becomes a job that needs recovery. As shovn in Figure 12, after a job has failed {step 1105), TS reorg automatically skips all the tables that have been already successfully created and loaded before the failure (step lllO) and only loads concurrently the non-existing tcibles or the tables that were not completely loaded (step lllS) .<br>
As shown in Figure 13, during the load phase, TS reorg first creates the tables under a temporary name (step 1300] . After the data has been reloadsd the temp table is renamed to the original name of the table (step 1320) . Finally, the primary constraints and indexes on the table are created (step 1330) . This allows TS reorg to recognize the tables that were not completely imported before the failure and to drop all tsnporary tables and restart the load for those tables (see process l11SA, Pig. 11).<br>
When using the concurrent Unload/Load option, TS reorg automatically selects the cation: Create all Indexes/Constraints after all of the Tables have been Created. The indexes and constraints of this tablespace are created after all of the tables are<br><br>
successfully created and their data reloaded into the tables.<br>
CONCURRENT INDEX CREATION IN TS REORG<br>
Concurrent index creation is an option can be used in a table or a tablespace reorganization to increase the speed of index creation during the reorganization. In a regular table or tablespace reorganization, the indexes are created one after another after the table is created and the data loaded back into Che cable.<br>
In a tablespace reorg, the user may select a concurrent index creation option. In this case, TS reorg will create Che indexes concurrently (sequential index creation is the default behavior} . This will allow TS reorg to gather all the indexes and constraints in one export file and when all the tables of the tablespace (in case of a tablespace reorganization) or the table to reorganize (in case of the table reorganization) has been created, it starts to create these indexes and constraints concurrently.<br>
When selecting this option, the user has to specify a number of threads which would be used as the number of process to launch concurrently during the index/constraint creation phase.<br>
When the import phase for indexes begins, TS reorg launches Che same number of Index creation processes as the number of specified threads. When the first index process of the first set o£ threads finishes, a next index creation process is launched and subsequent index creation processes are similarly launched upon conflation of other threads until all the indexes and constraints are created.<br><br>
If an error occurs on the creation of one index or constraint, TS reorg logs the error and writes the DDL of the failed index into a file. The user can then manually edit and fix the problem.<br>
The present invention has been described with reference and in terms consistent ' with an implementation in conjunction with a Oracle database. However, the processes described are equally applicable to other known database products and custom database installations. For example, instead of utilizing the Oracle utility, SQL*LOADER™, another program capable of reading table data stored in an export directory and loading the data into fresh table space may be utilized.<br>
The present invention may be conveniently implemented using a conventional general purpose or a specialized digital ccmputer or microprocessor programmed according to the teachings of the present disclosure, as will be apparent to those skilled in the computer art.<br>
Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to. those skilled in the software art. The invention may also be implemented by the preparation o£ application specific integrated circuits or by interconnecting an appropriate network of conventional component circuits, as will be readily apparent to those skilled in the art.<br>
The present invention includes a computer program product which is a storage medium (media) having instructions stored thereon/in which can be used to program a computer to perform any of the processes of the present invention. The storage medium can include,<br><br>
but is not limited to, any type of disk including floppy disks, optical discs, DVD, CD-ROMs, microdrive, and magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, DRAMS, VRAMs, flash memory devices, magnetic or optical cards, nanosystema (including molecular memory iCs), or any type of media or device suitable for storing instructions and/or  data.<br>
Stored on any one of the coinputer readable medium<br>
(media), the present invention includes software for<br>
controlling  both  the  hardware  of  the  general<br>
purpose/specialized computer or microprocessor, and for<br>
enabling the computer or microprocessor to interact<br>
with a human user or other mechanism utilizing the<br>
results of the present invention.  Such software may<br>
include, but is not limited to, device drivers,<br>
operating systems, database engines and products, and<br>
user applications. Ultimately, such computer readable<br>
media further includes software for performing the<br>
present invention, as described above.<br>
Included in the programming (software) of the general/specialized computer or microprocessor are software modules for imlementing the teachings of the present invention, including, but not limited to, retrieval of user inputs and the determination of a number of threads for parallel processing, launching threads,  unloading  database  tables,  determining success, initiating internal reorganization processes, exporting database objects, compressing unloaded data, monitoring the processes of the present invention, and setting up a concurrent load environment utilizing a table load utility, and the display, storage, or communication of results according to the processes of the present invention.<br><br>
Obviously, numerous modifications and variations of the present invention are possible in light of the above teachings. It is therefore to be understood that within the scope of the appended claims, Che invention may be practiced otherwise than as specifically described herein.<br><br><br>
We claim:<br>
1.	A method for unloading database tables, comprising the steps of:<br>
launching a number of threads to process the database tables;<br>
assigning a respective one of said database tables to a corresponding of said threads; and<br>
unloading each respective database table by a process of the corresponding thread.<br>
2.	The method according to Claim 1, wherein said step of launching comprises<br>
the steps of:<br>
retrieving a number X of threads input by a user;<br>
identifying a number of export directories located on separate storage devices that maintain said database tables;<br>
limiting X to the number of export directories identified; and utilizing X as said number of threads.<br>
3.	The method according to Claim 2, wherein said storage devices are disk drives.<br>
4.	The method according to Claim I, wherein said step of unloading comprises the steps of:<br>
reading blocks of data from a respective database table, and storing the data blocks read in an export directory.<br><br>
5.	The method according to Claim 4, wherein said step of unloading comprises<br>
the steps of:<br>
determining success of completion said steps of reading and storing; and<br>
(1)	stopping each of said threads, if said determining success step indicates non-completion,<br>
(2)	performing an internal TS Reorganization on the table.<br>
6.	The method according to Claim 1, comprising the step of;<br>
repeating said steps of assigning and unloading until each of the database tables is unloaded,<br>
7.	The method according to Claim 1, comprising the steps of: exporting other objects related to each of said tables; and dropping said tables.<br>
8.	A method of loading data. into database tables, comprising the steps of. determining X threads for loading data into database tables;<br>
creating X temporary tables, each temporary table corresponding to a set of data stored in an export directory;<br>
launching an SQL* Load process in conjunction with each thread for loading each temporary table;<br>
loading each temporary table with the data stored in the corresponding export directory via the conesponding SQL* Loader process.<br><br>
9.	The method according to Claim 8, comprising the steps of:<br>
determining success of the loading step for a respective database table; and<br>
if said step of loading was unsuccessful, performing the steps of:<br>
(1)	stopping each of said threads, if said determining success step indicates<br>
non-completion,<br>
(2)	performing an internal TS Reorganization on the table.<br>
10.	The method according to Claim 8, comprising the steps of creating, launching<br>
and loading until each table is loaded.<br>
11.	The method according to Claim 8, comprising the steps of:<br>
recognizing a fauU in said step of loading, and performing the steps of:<br>
(1)	recognizing unsuccessfully loaded tables; and<br>
(2)	performing an internal TS Reorganization on the unsuccessfully loaded tables.<br>
12.	The method according to Claim 8, wherein said step of determining comprises<br>
the steps of:<br>
retrieving a number of threads input by a user; determining a number of export directories; and<br>
establishing a number of threads equal to the lesser of the number of threads retrieved and the number of export directories.<br><br>
13.	The method according to Claim 12, comprising the step of:<br>
repeating said steps of assigning and unloading until each of the database tables is unloaded.<br>
14.	An apparatus for unloading database tables maintained in a system,<br>
comprising:<br>
a launching means for launching a number of threads to process the database tables;<br>
an assigning means for assigning a respective one of said database tables to a corresponding of said threads; and<br>
an unloading means for unloading each respective database table by a process of the corresponding thread.<br>
15.	The apparatus according to Claim 14, wherein said launching means for launching comprises a retrieving means for retrieving a number of threads to launch from a user.<br>
16.	The apparatus according to Claim 14, wherein said launching means for launching comprises a limiting means for limiting the number of threads launched to a number of export directories located on separate storage devices of said system.<br>
17.	The apparatus according to Claim 14, wherein said unloading means for unloading comprises:<br><br>
a reading means for reading blocks of data from a respective database table, and storing the data blocks read in an export directory associated with the corresponding thread.<br>
18.	The apparatus according to Claim  14, comprising a repeatedly- assigning means for repeatedly assigning respective database tables to corresponding threads and unloading each respective table until all of said databases tables have been unloaded.<br>
19.	An apparatus for unloading database tables, comprising:<br>
a launching device configured to initiate a number of threads to process said database<br>
tables;<br>
an assignor configured to assign each of said database tables to corresponding of said<br>
threads launched; and<br>
an unloader  installed  on  each  corresponding  thread,  each  respective  unloader<br>
configured to unload database tables assigned to the corresponding thread of the<br>
unloader.<br>
20.	The   apparatus   according   to   Claim   19,   wherein   said   launching   device<br>
comprises:<br>
a user interface configured to retrieve a number of threads to launch from a user; and<br><br>
a limit device configured to limit the number of threads to launch to a number of export directories located on separate storage devices of said system.<br>
21.	The apparatus according to Claim 19, wherein each respective unloader<br>
comprises:<br>
a read device configured to read blocks of data maintained within tables assigned to a same thread as the respective unloader is installed; and<br>
a write device configured to store the data blocks read into an export directory corresponding to the same thread as the respective unloader is installed.<br>
22.	The apparatus according to Claim 19, wherein said assignor assigns a database table to each of said threads, and, upon completion of one of said threads, assigns another of said database tables to the completed thread until each database table has been assigned.<br>
23.	The apparatus according to Claim 21, comprising:<br>
a loader, loaded and executed on each of said threads after each database table has been unloaded, each loader configured to,<br>
read data blocks stored in an export directory corresponding to the thread executing the loader, and save the datablocks in fresh tablespace.<br>
24.	A method for reorganizing database tables in a symmetrical multi- processing<br>
environment having a plurality of CPU's, comprising the steps of-<br>
launching a number of threads to process said database tables;<br><br>
assigning each of said database tables to a different corresponding thread of said<br>
threads;<br>
unloading each respective database table by a process of said corresponding thread,<br>
wherein said threads operate on different CPU's in parallel; and<br>
loading said database tables.<br>
25.	The method according to Claim 24, wherein said step of launching comprises<br>
the steps of:<br>
retrieving a number of threads input by a user;<br>
identifying a number of export directories located on separate storage devices that maintain said database tables;<br>
limiting to the number of export directories identified; and utilizing as said number of threads.<br>
26.	The method according to Claim 25, wherein said storage devices are disk drives.<br>
27.	The method according to Claim 24, wherein said step of unloading comprises the steps of:<br>
reading blocks of data from a respective database table, and storing the data blocks read in an export directory.<br>
28.	The method according to Claim 27, wherein said step of unloading comprises<br>
the steps of:<br><br>
determining success of completion said steps of reading and storing; and<br>
(1)	stopping each of said threads, if said determining success step indicates non- completion,<br>
(2)	performing an internal TS Reorganization on the table.<br><br>
29.	The method according to Claim 24, comprising the step of: repeating said steps of assigning and unloading until each of the database tables is unloaded,<br>
30.	The method according to Claim 24, comprising the steps of: exporting other objects related to each of said tables; and dropping said tables.<br>
31.	The method according to Claim 24, wherein said step of loading comprises the steps of:<br>
determining threads for loading data into database tables;<br>
creating temporary tables each temporary table corresponding to a set of data stored in an export directory;<br>
launching a loading process in conjunction with each thread for loading each temporary table;<br>
loading each temporary table with the data stored in the corresponding export directory via the corresponding loading process.<br><br>
32.	The method according to Claim 31, comprising the steps of: determining<br>
success of the loading step for a respective database table; and if said step of loading<br>
was unsuccessful, performing the steps of:<br>
(1)	stopping each of said threads, if said determining success step indicates non-completion,<br>
(2)	performing an internal TS Reorganization on the table.<br><br>
33.	The method according to Claim 31, comprising the steps of creating, launching and loading until each table is loaded.<br>
34.	The method according to Claim 31, comprising the steps of; recognizing a fault in said step of loading, and performing the steps of:<br><br>
(1)	recognizing unsuccessfully loaded tables; and<br>
(2)	performing an internal TS Reorganization on the unsuccessfully loaded tables.<br>
35.	The method according to Claim 31, wherein said step of determining comprises<br>
the steps of:<br>
retrieving a number of threads input by a user; determining a number of export directories; and<br>
establishing a number of threads equal to the lesser of the number of threads retrieved and the number of export directories.<br><br>
36.	An apparatus for reorganizing database tables maintained in a system<br>
exhibiting a symmetrical multi-processing environment having a plurality of CPU's,<br>
comprising:<br>
means for launching a number of threads to process said database tables;<br>
means for assigning each of said database tables to a different corresponding thread of said threads;<br>
means for unloading each respective database table by a process of the corresponding thread, wherein said threads operate on different CPU's in parallel; and means for loading said database tables.<br>
37.	The apparatus according to Claim 36, wherein said means for launching comprises means for retrieving a number of threads to launch from a user.<br>
38.	The apparatus according to Claim 36, wherein said means for launching comprises means for limiting the number of threads launched to a number of export directories located on separate storage devices of said system.<br>
39.	The apparatus according to Claim 36, wherein said means for unloading comprises:<br>
means for reading blocks of data from a respective database table, and storing the data blocks read in an export directory associated with the corresponding thread.<br><br>
40.	The apparatus according to Claim 36, comprising means for repeatedly assigning respective database tables to corresponding threads and unloading each respective table until all of said database tables have been unloaded.<br>
41.	An apparatus for reorganizing database tables in a symmetrical multiprocessing envirormient having a plurality of CPU's, comprising:<br>
a launching device configured to initiate a number of threads to process said database<br>
tables;<br>
an  assignor  configured  to   assign each  of said  database  tables  to  a  different<br>
corresponding thread of said threads launched;<br>
an unloader installed on each corresponding thread,  each  respective unloader<br>
configured to unload each of said database tables by a process of said corresponding<br>
thread of said unloader, wherein said threads operate on different CPU's in parallel;<br>
and<br>
a loader configured to load said database tables.<br>
42.	The apparatus according to Claim 41, wherein said launching device<br>
comprises:<br>
a user interface configured to retrieve a number of threads to launch from a user; and a limit device configured to limit the number of threads to launch to a number of export directories located on separate storage devices of said system.<br><br>
43.	The apparatus according to Claim 41, wherein each respective unloader<br>
comprises:<br>
a read device configured to read blocks of data maintained within tables assigned to a same thread as the respective unloader is installed; and<br>
a write device configured to store the data bloclis read into an export directory corresponding to the same thread as the respective unloader is installed.<br>
44.	The apparatus according to Claim 41, wherein said assignor assigns a database table to each of said threads, and, upon completion of one of said threads, assigns another of said database tables to one of said initiated threads until each database table has been assigned.<br>
45.	The apparatus according to Claim 43, wherein said loader is loaded and executed on each of said threads after each database table has been unloaded, each loader configured to,<br>
read data blocks stored in an export directory corresponding to the thread executing<br>
the loader, and<br>
save the datablocks in fresh tablespace.<br>
46.	A method for reorganizing database tables residing on different storage devices<br>
in a symmetrical multi-processing environment having a plurality of CPU's, at least<br>
one of said tables residing on a plurality of storage devices, comprising the steps of;<br>
launching a number of threads to process said database tables;<br><br>
assigning each respective portion of said database tables residing on a different storage device to a different corresponding thread of said threads; unloading each respective portion of said database tables by a process of said corresponding thread, wherein said threads operate on different CPU's in parallel; and loading said database tables.<br>
47.	An apparatus for reorganizing database tables residing on different storage<br>
devices maintained in a system exhibiting a symmetrical muhi-processing<br>
environment having a plurality of CPU's, at least one of said tables residing on a<br>
plurality of storage devices, comprising:<br>
means for launching a number of threads to process said database tables;<br>
means for assigning each respective portion of said database tables residing on a different storage device to a different corresponding thread of said threads;<br>
means for unloading each respective portion of said database tables by a process of the corresponding thread, wherein said threads operate on different CPO's in parallel; and<br>
means for loading said database tables.<br>
48.	An apparatus for reorganizing database tables residing on different storage<br>
devices in a symmetrical multi-processing enviromnent having a plurality of CPO's, at<br>
least one of said tables residing on a plurality of storage devices, comprising:<br>
a launching device configured to initiate a number of threads to process said database tables;<br><br>
an assignor configured to assign each respective portion of said database tables residing on a different storage device to a different corresponding thread of said threads launched;<br>
an unloader installed on each corresponding thread, each respective unloader configured to unload each respective portion of said database tables by a process of said corresponding thread of the unloader, wherein said threads operate on different CPU's in parallel; and<br>
a loader configured to load said database tables.<br>
49. A method for reorganizing database tables in a symmetrical muhi- processing environment having a plurality of CPU's, comprising:<br>
launching a first set of threads to unload said database tables;<br>
assigning each of said database tables to a different corresponding thread of said first set of threads;<br>
unloading each of said database tables to a separate export directory by a process of said corresponding thread, said first set of threads operate in parallel on a first set of CPU's, said database tables assigned to said export directories using a best fit method, said assignment performed by a reorganization utility running on a CPO separate from said first set of CPU's;<br>
creating temporary database tables;<br>
launching a second set of threads to load said temporary database tables; and loading each of said temporary database tables with data from at least one of said export directories, each of said temporary database tables loaded by a separate thread<br><br>
of said second set of threads, said second set of threads operate in parallel on a second set of CPU's, said data loaded using a best fit method.<br>
50.	An apparatus for reorganizing database tables maintained in a system<br>
exhibiting a symmetrical multi-processing environment having a plurality of CPU's,<br>
comprising:<br>
means for launching a first set of threads to unload said database tables;<br>
means for assigning each of said database tables to a different corresponding thread of said first set of threads;<br>
means for unloading each of said database tables to a separate export directory by a process of said corresponding thread, said first set of threads operate in parallel on a first set of CPO's, said database tables assigned to said export directories using a best fit method, said assignment performed by a reorganization utility running on a CPO separate from said first set of CPO's;<br>
means for creating temporary database tables;<br>
means for launching a second set of threads to load said temporary database tables; and means for loading each of said temporary database tables with data from at least one of said export directories, each of said temporary database tables loaded by a separate thread of said second set of threads, said second set of threads operate in parallel on a second set of CPO's, said data loaded using a best fit method.<br>
51.	An apparatus for reorganizing database tables in a symmetrical multi<br>
processing environment having a plurality of CPU's, comprising:<br><br>
a first launching device configured to initiate a first set of threads to unload said database tables;<br>
an assignor configured to assign each of said database tables to a different corresponding thread of said first set of threads launched;<br>
an unloader installed on each thread of said first set of threads, each unloader configured to unload at least one of said database tables to a separate export directory by a process of said corresponding thread of said unloader, said first set of threads operate in parallel on a first set of CPU's, said database tables assigned td 'said export directories using a best fit method, said assignment performed by a reorganization utility running on a CPU separate from said first set of CPU's;<br>
a table allocation device configured to create temporary database tables;<br>
a second launching device configured to initiate a second set of threads to load said temporary database tables; and<br>
a loader installed on each thread of said second set of threads, each loader configured to load at least one of said temporary database tables with data from at least one of said export directories, each of said temporary database tables loaded by a process of said corresponding thread of said loader, said second set of threads operate in parallel on a second set of CPU's, said loaders using a best fit method.<br>
52.      A   machine-implemented   method   for   reorganizing   database   tables   in   a symmetrical multi-processing environment haying a plurality of CPU's, comprising: launching a plurality of threads; assigning each of said threads to a database table;<br><br>
unloading said tables concurrently, wherein data of each table is unloaded to an export<br>
directory by a process of said thread assigned to said table;<br>
creating new tables; and<br>
loading said new tables concurrently, wherein data of said export directories is loaded<br>
to said new tables by a process of said thread assigned to said table.<br>
53.	The method as claimed in 52, wherein indexes for said new tables are created concurrently with said method.<br>
54.	The method as claimed in 52, wherein said threads operate concurrently on a first set of said CPU's, said export directories selected by a reorganization utility running on a CPU separate from said first set of CPU's,<br>
55.	The method as claimed in 52, wherein said unloading step comprises the steps of:<br>
verifying that said unloading step was successful; and<br>
unloading said data by an alternative unload process if said unloading step was unsuccessful.<br>
56.	The method as claimed in 52, wherein said export directories reside on separate<br>
physical disks.<br><br>
57.	The method as claimed in 52, wherein a maximum number of said threads is selected by a user,<br>
58.	The method as claimed in 52, wherein said unloading to said export directory is performed using a best fit method.<br>
59.	The method as claimed in 52, wherein said loading to said new tables is performed using a best fit method.<br>
60.	A machine-implemented method for reorganizing database tables in a symmetrical multi-processing environment having a plurality of CPU's, comprising; launching a plurality of threads; assigning each of said threads to a database table; unloading said tables concurrently, wherein data of each table is unloaded to an export directory by a process of said thread assigned to said table; and creating new tables.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgYXNzaWdubWVudC5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgY2xhaW1zLWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che claims-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgY29ycmVzcG9uZGVuY2Utb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgY29ycmVzcG9uZGVuY2UtcG8ucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgZGVzY3JpcHRpb24gKGNvbXBsZXRlKS1kdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che description (complete)-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgZHJhd2luZ3MtZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che drawings-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgZm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgZm9ybS0xOS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgZm9ybS0yNi5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgZm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgcGN0LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che pct.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDcxOS1jaGUgcGV0aXRpb24ucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-0719-che petition.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="219787-method-and-apparatus-for-transmitting-and-receiving-the-sync-channel-message-in-a-multi-carrier-communication-system.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="219789-bacteriostatic-composition-for-salmonellae.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>219788</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2001/719/CHE</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>27/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>04-Jul-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>13-May-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>24-May-2001</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>COMPUTER ASSOCIATES THINK, INC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>MIRZADEH, Rosita</td>
											<td></td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F9/46</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US1999/027835</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>1999-11-24</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/200,254</td>
									<td>1998-11-25</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/219788-method-and-apparatus-for-concurrent-dbms-table-operations by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 11:27:57 GMT -->
</html>
