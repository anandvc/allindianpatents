<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/202635-method-and-arrangement-for-forming-and-checking-a-checksum-for-digital-data-whitch-are-grouped-into-a-number-of-data-segments by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:10:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 202635:&quot;METHOD AND ARRANGEMENT FOR FORMING AND CHECKING A CHECKSUM FOR DIGITAL DATA WHITCH ARE GROUPED INTO A NUMBER OF DATA SEGMENTS&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;METHOD AND ARRANGEMENT FOR FORMING AND CHECKING A CHECKSUM FOR DIGITAL DATA WHITCH ARE GROUPED INTO A NUMBER OF DATA SEGMENTS&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Method and arrangement for forming and checking a checksum for digital data which are grouped into a number of data segments Methods and arrangements for forming a checksum and for checking a checksum for digital data which are grouped into a number of data segments are specified. In the method, a checksum is formed for each data segment. The individual checksums are combined to form a first commutative checksum by using a commutative operation. To check the first commutative checksum, a checksum is again formed for each data segment and the checksum is again combined to form a second commutative checksum using a commutative operation. The first commutative checksum and the second commutative checksum are checked for a match.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>-1A-<br>
Description<br>
Method and arrangement for forming and checking a checksum for digital data which are grouped into a number of data segments<br>
In digital communications, i.e. during the exchange of digital data, it is frequently desirable to protect the transmission of the electronic data with respect to the most varied aspects.<br>
A very significant aspect is the protection of the digital data to be transmitted against unauthorized modification, the so-called protection of the integrity of the data.<br>
As a protection against unauthorized modification of digital data, the so-called cryptographic checksum, for example the digital signature, is known from [1]. The method described in [1] is based on forming a hashing value from the digital user data and the subsequent cryptographic processing of the hashing value by means of a cryptographic key. The result is a cryptographic checksum. To check the integrity, a corresponding cryptographic key is used for performing the inverse cryptographic operation on the checksum formed and the result is compared with the hashing value again calculated from the user data. The integrity of the user data is ensured when the hashing values are matched.<br>
This previously customary procedure necessitates that the complete user data must be present on the receiver side in the identical order in which they were present when the hashing value was formed since otherwise the formation of the hashing value leads to an errored value. In digital communications, however, it is frequently customary to subdivide and to transmit the user data to be transmitted in relatively small data segments which are<br><br>
also called data packets, due to protocol boundary conditions. The data segments are frequently not tied to a defined order or it is not possible to guarantee a defined sequential arrival of the data segments. In the method from [1] , it is therefore required for the complete user data to be reassembled again on the receiver side, that is to say after the transmission of the data segments, in the order in which they were originally sent. The data to be transmitted can only be verified in this order. However, this frequently means considerable additional expenditure for the flow control of the data segments inasmuch as this is possible at all within the framework of the protocol used.<br>
From [2], commutative operations are known. In [2] , a general definition for commutative operations is also specified. Illustratively, a commutative operation can be understood to be an operation in which the order of individual operations is unimportant and each order of individual operation always leads to the same total operation. A commutative operation can be, for example, an EXOR operation, an additive operation or also a multiplicative operation.<br>
From [3] , a method and a device for generating check code segments for the occurrence of source data and for determining errors in the source data are known.<br>
The invention is thus based on the object of specifying methods and arrangements for forming and checking a first commutative checksum for digital data which are grouped into a number of data segments, in which a flow control for the individual data segments is no longer required.<br>
The object is achieved by the method according to Claim 1, by the method according to Claim 2, by the method according to Claim 3, by the arrangement according to Claim 11, by the arrangement according to Claim 12 and by the arrangement according to Claim 13.<br><br>
	3	<br>
In the method according to Claim 1, a first segment checksum is formed for each data segment for digital data which are grouped into a number of data segments. The first segment checksums formed are combined by a commutative operation to form a first commutative checksum.<br>
In the method according to Claim 2, a predetermined first commutative checksum, which is allocated to digital data which are grouped into a number of data segments, is checked. This is done by a second segment checksum being formed for each data segment and a second commutative checksum being formed by a commutative operation on the second segment checksum. The second commutative checksum and the first commutative checksum are checked for a match.<br>
In the method according to Claim 3 for forming and checking a first commutative checksum for digital data which is grouped into data segments, a first segment checksum is formed for each data segment and the first data checksums are combined by a commutative operation to form a first commutative checksum. For each data segment of the digital data to which the first commutative checksum is allocated, second segment checksums are formed and a second commutative checksum is formed by commutative operation on the second segment checksums. The second commutative checksum and the first commutative checksum are checked for a match.<br>
The arrangement according to Claim 11 exhibits an arithmetic and logic unit which is arranged in such a manner that a segment checksum is formed for each data segment and that the first commutative checksum is formed by a commutative operation on the segment checksums.<br>
The arrangement according to Claim 12 exhibits an arithmetic and logic unit which is arranged in such a manner that a second segment checksum is formed for each data segment, a second commutative checksum is formed by a commutative operation on the second segment checksums, and the second commutative checksum (KP2) is<br><br>
checked for a match with the first commutative checksum (KP1).<br>
The arrangement according to Claim 13 exhibits an arithmetic and logic unit which is arranged in such a manner that the following method steps are performed:<br>
a)	a segment checksum is formed for each data segment,<br>
b)	the  first  commutative  checksum  is  formed by  a<br>
commutative operation on the segment checksums,<br>
c)	a second segment checksum is formed for each data<br>
segment  of  the  digital  data  to  which  the  fxrst<br>
commutative checksum is allocated,<br>
d)	a  second  commutative  checksum  is  formed  by  a<br>
commutative operation on the second segment checksums,<br>
and<br>
e)	the second commutative checksum is checked for a<br>
match with the first commutative checksum.<br>
A considerable advantage of the methods and of the arrangements can be seen in the fact that, by using a commutative operation for individual checksums of the data segments, a flow control for the order of the individual data segments is no longer required.<br>
Furthermore, it is no longer required to reassemble the complete user data in the original order in which the first commutative checksums were formed. The order of the individual data segments is no longer of significance in the formation of the commutative checksum.<br>
If the digital data are transmitted between two arrangements, a further advantage of the methods can be seen in the fact that the checking of the integrity can already be begun before all data segments have been received since it is no longer required to maintain the original order in forming the first checksum. This leads to a timesaving in the checking of the integrity of the data.<br>
Illustratively, the invention can be seen in the fact that a checksum is formed in the case of a number of data segments which, together, form the data to be protected, and the individual checksums of the<br><br>
data  segments  are  commutatively  combined  with  one another.<br>
Advantageous further developments of the invention are obtained from the dependent claims.<br>
It is advantageous to protect the first commutative checksum cryptographically by using at least one cryptographic operation.<br>
The result of this further development is that the cryptographic security of the data is considerably increased. A cryptographic operation in this sense is, for example, the encrypting of the first commutative checksum with a symmetric or also with an assymetric encryption method which forms a cryptographic checksum. On the receiver side, the inverse cryptographic method to the cryptographic method is performed in order to ensure cryptographic security.<br>
To form a checksum within the context of the document, various possibilities are known:<br>
-	a checksum can be formed by forming hashing values<br>
for the individual data segments;<br>
-	the checksums can also be formed by so-called cyclic<br>
codes (Cyclic Redundancy Check, CRC);<br>
-	a cryptographic one-way function can also be used for<br>
forming the checksums for the data segments.<br>
The methods can be advantageously used in various application scenarios.<br>
The methods can be used both in the transmission of digital data for protection against manipulation of the data, and in the archiving of digital data in a computer in which the first commutative checksum is formed and stored together with the data to be archived. The first commutative checksum can be checked when the digital data are loaded from the archive memory in order to detect any manipulation of the archived data.<br>
The method can be advantageously used for protecting digital data, the data segments of which are not tied to an order. Examples of such data segments are   packet-oriented   communication  protocols,   for<br><br>
	6	<br>
example network management protocols such as the Simple Network Management protocol {SNMP) or the Common Management Information protocol (CMIP).<br>
In the text which follows, an illustrative embodiment of the invention will be explained in greater detail with reference to a Figure. Even if the illustrative embodiment is explained with reference to the Simple Network Management Protocol (SNMP) in the text which follows, this does not represent any restriction on the applicability of the method. The method can be used whenever it is of importance to ensure integrity protection for digital data which are grouped into a number of data segments.<br>
The Figure shows two arrangements, data segments being transmitted from the first arrangement to the second arrangement.<br>
In the Figure, a first computer arrangement Al, in which data segments (Di, i = 1 .. n) are stored, is shown symbolically. The data segments Di together form the digital data which are also designated as user data, for which xt is of importance to ensure their integrity.<br>
Both the first computer arrangement Al and a second computer arrangement A2 described in the text which follows in each case contain an arithmetic and logic unit R which is arranged in such a manner that the method steps described in the text which follows are performed.<br>
In the first arrangement Al, the data segments Di are arranged at positions Pi within the total data stream. For each data segment Di, a first segment checksum PSi is formed by using a checksum function PSF. The individual first segment checksums PSi are combined to form a first commutative checksum KPl by a commutative operation as defined and described in [2] . The commutative operation on the individual checksums PSi is shown symbolically by an EXOR symbol  in the Figure.<br><br>
	7	<br>
The first commutative checksum KP1 is subjected to a cryptographic method, a symmetric or asymmetric method, by using a first cryptographic key S (step 101) . The result of the cryptographic operation is a cryptographic checksum KP.<br>
Both the data segments Di and the cryptographic checksum KP are transmitted by a transmission medium, preferably a line or also a logical connection which is symbolically shown by a communication link UM in the Figure, to a second arrangement A2 where they are received.<br>
The crossing arrows of the data segments Di in the Figure indicate that, due to the transmission of the data segments Di, these are received in positions Pj (j = a . . z) which are displaced compared with the order in the first arrangement Al.<br>
Thus, a data segment D2 at the first position P1 is received as data segment Da in the second arrangement A2. Data segment D1 is received as data segment Dc in the second arrangement. Data segment Dn is received as received data segment Db at the second position P2 in the second arrangement A2.<br>
In accordance with the method used, either the first cryptographic key S is used for performing the inverse cryptographic operation on the cryptographic checksum KP if a symmetric encryption method is used, or a second cryptographic key S' is used if an asymmetric cryptographic method is used.<br>
The result of the inverse cryptographic operation (step 102) is again the first commutative checksum KP1 with correct encryption and decryption.<br>
This checksum is stored in the second arrangement A2. For the comparison of the data segments Dj, which are now received in permutated order compared with the original order during the formation of the first commutative checksum KP1, second segment checksums Psj are formed for the received data segments Dj, again using the same checksum methods PSF.<br><br>
	8	<br>
The resultant second checksums PSj are again commutatively combined with one another to form a second commutative checksum KP2.<br>
In a further step 103, a check is made whether the first commutative checksum KP1 matches the second commutative checksum KP2.<br>
If this is so, the integrity of the data segments Di, and thus the integrity of all the digital data, is ensured {step 104) if the cryptographic methods used or, respectively, the methods used for forming checksums ensure the corresponding cryptographic security.<br>
If the first cryptographic checksum KPl does not match the second cryptographic checksum KP2, the integrity of the data segments Di would be violated and a manipulation of the data is found and preferably reported to a user of the system.<br>
The protocol data units (PDU) in SNMP are structured in such a manner that the user information (so-called variable bindings) can contain a list of objects (object indicators, OID/value pairs). The order of the objects within a PDU is not specified so that it is possible for a permutation of the objects to occur during the transmission of the PDUs between the first arrangement Al and the second arrangement A2. The invention now makes it possible to form a single cryptographic checksum over all objects of an SNMP PDU without having to take into consideration the order of the objects or of the PDUs.<br>
In the text which follows, alternatives to the illustrative embodiment described above will be explained.<br>
The method for forming the checksum PSF can be, for example, a method for forming hashing values. However, methods for forming cyclic codes (Cyclic Redundancy Check, CRC) using feedback-type shift registers can also be used. In addition, cryptographic one-way functions can be used for forming the checksums PSi and, respectively, Psj.<br><br>
Furthermore, the commutative operation can have the additional property of associativity.<br>
Both the method for forming the checksum and the method for checking a checksum can be performed independently of one another. However, the method for forming the checksum and the method for checking the checksum can also be performed jointly.<br>
Furthermore, it is provided not to transmit digital data but to archive the digital data, that is to say to store them in the first arrangement Al, together with the first commutative checksum KP1. When the archived data are reused, that is to say when the data segments Di are loaded from the memory of the first arrangement Al, the method for checking the first commutative checksum KP1 as described above will then be performed. The first arrangement Al and the second arrangement A2 can thus be identical.<br>
Illustratively, the invention can be seen in that in the case of a number of data segments which, together, represent the data to be protected, a checksum is formed for each data segment and the individual checksums of the data segments are commutatively combined with one another. This makes it possible to form and to check a checksum without having to take into consideration the order of the data segments.<br>
In this document,  the following publications have been quoted: [1]  W. Stallings, Sicherheit in Netzwerk und Internet<br>
(Security in Network and Internet), Prentice Hall,<br>
ISBN 3-930436-29-9, pp. 203-223, 1995 [2]  K.-H.   Kiyek  and  F.   Schwarz,   Mathmatik  fur<br>
Informatiker     (Mathematics     for     Computer<br>
Scientists),  Teubner Verlag,  ISBN 3-519-03277-X,<br>
pp. 11-13, 1989 [3]  DE-A 2 048 365<br><br>
10<br>
WE CLAIM:<br>
1. Method for forming a cryptographic commutative checksum (KP) for digital data which are grouped into a number of data segments (Di, i = l..n), by a computer,<br>
a) in which a segment checksum (PSi) is formed for each data segment<br>
(Di),<br>
b).in which a first commutative checksum (KP1) is formed by a commutative operation (©) on the segment checksums (PSi) and<br>
c) in which the first commutative checksum (KP1) is cryptographically protected using at least one cryptographic operation, with the cryptographic commutative checksum (KP) being formed,<br>
2. Method for checking a predetermined cryptographic commutative checksum (KP) which is allocated to digital data which are grouped into a number of data segments, by a computer,<br>
a)	in which the cryptographic commutative checksum (KP) is subjected to<br>
an inverse cryptographic operation in order to form a first commutative<br>
checksum (KP1),<br>
b)	in which a second segment checksum (PSj)   is formed for each data<br>
segment (Dj,j = a ..z),<br>
c)	in which a  second  commutative   checksum   (KP2)  is  formed   by  a<br>
commutative operation () on the second segment checksums (PSj),<br>
and<br>
d)	in which the second commutative checksum (KP2) is checked for a<br>
match with the first commutative checksum (KP1).<br>
3. Method according to claim 1 and claim 2 for forming and checking a cryptographic commutative checksum (KP) for digital data which are grouped into a number of data segments (Di, i = 1 ..n), by a computer,<br>
a)	in which a segment checksum (PSi) is formed for each data segment (Di),<br>
b)	in which a first commutative checksum (KP1) is formed by a commutative<br>
operation () on the segment checksums (PSI),<br><br>
11<br>
c)	in  which  the first commutative  checksum   (KP1)  is  cryptographicaliy<br>
protected   using,   at   least   one   cryptographic   operation,   with    the<br>
cryptographic commutative checksum (KP) being formed.<br>
d)	in which the cryptographic commutative checksum (KP) is subjected to an<br>
inverse cryptographic operation in order to form a first reconstructed<br>
commutative checksum (KP1),<br>
e)	in which a second segment checksum (PSj) is formed for each data<br>
segment (Dj, j = a .. z) of the digital data to which the first commutative<br>
checksum (KP1) is allocated,<br>
f)	in   which   a   second  commutative   checksum   (KP2)   is   formed   by   a<br>
commutative operation () on the second segment checksums (PSj), and<br>
g)	in which the second commutative checksum (KP2) is checked for a match<br>
with the first reconstructed commutative checksum (KP1).<br>
4.	Method according to one of claims 1 to 3, in which the segment checksums<br>
(PSi, PSj) are formed in accordance with at least one of the following types:<br>
-	forming a hashing value,<br>
-	forming CRC codes,<br>
-	using at least one cryptographic one-way function.<br><br>
5.	Method according to one of claims  1  to 4, in which the  cryptographic<br>
operation is a symmetric cryptographic method.<br>
6.	Method according to claims 1 to 4, in which he cryptographic operation rs an<br>
asymmetric cryptographic method.<br>
7.	Method according to one of claims 1 to 6, in which the commutative operation<br>
() exhibits the property of associavity.<br><br>
12<br>
8.	Method according to one of claims I to 7, in which digital data are protected,<br>
the data segments (Di) of which are not tied to an order.<br>
9.	Method according to-one of claims 1 to 7, in which digital data are protected<br>
which are processed in accordance with a network management protocol.<br>
10.	Arrangement for forming a cryptographic commutative checksum (KP) for<br>
digital data which are grouped into a number of data segments (Di, i = 1.. n), by<br>
means of an arithmetic and logic unit which is arranged in such a manner that<br><br>
a)	a segment checksum (PSi) is formed for each data segment (Di),<br>
b)	a first commutative  checksum  (KP1)  is  formed  by  a  commutative<br>
operation () on the segment checksum (PSi). and<br>
c)	the first commutative checksum (KP1) is cryptographically protected by<br>
using at least one cryptographic operation,<br>
with the cryptographic commutative checksum (KP) being formed.<br>
11. Arrangement for checking a predetermined cryptographic commutative checksum (KP) which is allocated to digital data which are grouped into a number of data segments, by means of an arithmetic and logic unit which is arranged in such a manner that<br>
a) the cryptographic commutative checksum (KP) is subjected to an inverse cryptographic operation in order to form a first commutative checksum<br>
(KP1),<br><br>
13<br>
b)	a second segment checksum (PSj) is formed for each data segment (Dj, j<br>
= a .. z),<br>
c)	a second commutative  checksum   (KP2)  formed  by a  commutative<br>
operation () on the second segment checksum (PSj), and<br>
d)	the second commutative checksum (KP2) is checked for a match with the<br>
first commutative checksum (KP1).<br>
12.Arrangement according to claim 10 and claim 11 for forming and checking a cryptographic commutative checksum (KP) for digital data which is grouped into a number of data segments (Di, i = 1 .. n), by means of at least one arithmetic and logic unit which is arranged in such a manner that<br>
a)	a segment checksum (PSj) is formed for each data segment (Di),<br>
b)	a  first commutative  checksum  (KP1)  is  formed  by  a  commutative<br>
operation () on the segment checksums (PSi),<br>
c)	the first commutative checksum  (KP1) is cryptographicaIly protected<br>
using at least one  cryptographic  operation,  with  the   cryptographic<br>
commutative checksum (KP) being formed,<br>
d)	the cryptographic commutative checksum (KP) is subjected to an inverse<br>
cryptographic   operation   in   order   to   form   a   first   reconstructed<br>
commutative checksum (KP1),<br>
e)	a second segment checksum (PSj) is formed for each data segment (Dj, j<br>
= a .. z) of the digital data to which the first commutative checksum<br>
(KP1) is allocated,<br>
f)	a second commutative checksum (KP2) is farmed by a commutative<br>
operation () on the second segment checksums (PSj), and<br>
g)	the second commutative checksum (KP2) is checked for a match with the<br>
first reconstructed commutative checksum (KP1).<br><br>
14<br>
13. Arrangement according to one of claims 10 to 12, in which the arithmetic and logic unit is arranged in such a manner that the segment checksums (PSi,PSj) are formed in accordance with at least one of the following types :<br>
-	forming a hashing value,<br>
-	forming CRC codes,<br>
-	using at least one cryptographic one-way function.<br>
14.	Arrangement according to one of claims 10 to 13, in which the arithmetic and<br>
logic unit is arranged in such a manner that the cryptographic operation is a<br>
symmetric cryptographic method.<br>
15.	Arrangement according to one of claims 10 to 13, in which the arithmetic and<br>
logic unit is arranged in such a manner that the cryptographic operation is an<br>
asymmetric cryptographic method.<br>
16.	Arrangement according to one of claims 10 to 15, in which the arithmetic and<br>
logic unit is arranged in such a manner that the commutative operation ()<br>
exhibits the property of associativity.<br>
17.	Arrangement according to one of claims 10 to 16, in which the arithmetic and<br>
logic unit is set up in such a manner that the digital data are protected, the<br>
data segments (Di) of which are not tied to an order.<br><br>
15<br>
18.Arrangement according to one of claims 10 to 16, in which the arithmetic and logic unit is arranged in such a manner that the digital data are protected which are processed in accordance with a network management protocol.<br>
Method and arrangement for forming and checking a checksum for digital data which are grouped into a number of data segments<br>
Methods and arrangements for forming a checksum and for checking a checksum for digital data which are grouped into a number of data segments are specified. In the method, a checksum is formed for each data segment. The individual checksums are combined to form a first commutative checksum by using a commutative operation. To check the first commutative checksum, a checksum is again formed for each data segment and the checksum is again combined to form a second commutative checksum using a commutative operation. The first commutative checksum and the second commutative checksum are checked for a match.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDAzOTEtY2FsLTE5OTggYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">00391-cal-1998 abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDAzOTEtY2FsLTE5OTggY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">00391-cal-1998 claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDAzOTEtY2FsLTE5OTggY29ycmVzcG9uZGVuY2UucGRm" target="_blank" style="word-wrap:break-word;">00391-cal-1998 correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDAzOTEtY2FsLTE5OTggZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">00391-cal-1998 description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDAzOTEtY2FsLTE5OTggZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">00391-cal-1998 drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDAzOTEtY2FsLTE5OTggZm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">00391-cal-1998 form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDAzOTEtY2FsLTE5OTggZm9ybS0yLnBkZg==" target="_blank" style="word-wrap:break-word;">00391-cal-1998 form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDAzOTEtY2FsLTE5OTggZm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">00391-cal-1998 form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDAzOTEtY2FsLTE5OTggZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">00391-cal-1998 form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDAzOTEtY2FsLTE5OTggZy5wLmEucGRm" target="_blank" style="word-wrap:break-word;">00391-cal-1998 g.p.a.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDAzOTEtY2FsLTE5OTggbGV0dGVycyBwYXRlbnQucGRm" target="_blank" style="word-wrap:break-word;">00391-cal-1998 letters patent.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDAzOTEtY2FsLTE5OTggcHJpb3JpdHkgZG9jdW1lbnQgb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">00391-cal-1998 priority document others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDAzOTEtY2FsLTE5OTggcHJpb3JpdHkgZG9jdW1lbnQucGRm" target="_blank" style="word-wrap:break-word;">00391-cal-1998 priority document.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="202634-an-apparatus-and-method-for-determining-a-program-neighborhood-for-a-client-node-in-a-client-server-network.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="202636-combustion-engine-with-a-small-volume-catalytic-converter.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>202635</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>391/CAL/1998</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>09/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>02-Mar-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>02-Mar-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>10-Mar-1998</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SIEMENS AKTIENGESELLSCHAFT</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>Wittelsbacherplatz 2, 80333 Munchen,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>KIAUS LUKAS</td>
											<td>Niemoellerallee 6, 81793 Muenchen,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>MARTINA HANCK</td>
											<td>AM Grenzweg 2, 85635 Hoehenkirchen,</td>
										</tr>
										<tr>
											<td>3</td>
											<td>GERHARD HOFMANN</td>
											<td>Gozbertstr. 8/11, 81547 Muenchen,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H 04L 9/32</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>19715486.7</td>
									<td>1997-04-14</td>
								    <td>Germany</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/202635-method-and-arrangement-for-forming-and-checking-a-checksum-for-digital-data-whitch-are-grouped-into-a-number-of-data-segments by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:10:29 GMT -->
</html>
