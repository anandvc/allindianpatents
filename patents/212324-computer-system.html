<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/212324-computer-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:39:05 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 212324:COMPUTER SYSTEM</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">COMPUTER SYSTEM</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A computer system comprising-&quot; a data file having entries each of which is designed to hold data; an advanced mapping file and a completed mapping file each having entries each of which is designed to hold an entry address in said data file&#x27;, an operation window that is a buffer to hold substances of operations waiting execution; a state-modification queue that is designed to be able to hold a substance of a modification on said advanced mapping file for each clock cycle; and functional units for executing operations; wherein making a modification on said advanced mapping file, entering the substance of said modification into said state-modification queue, and entering substances of operations combined with said modification on said advanced mapping file into said operation window are each to be done in one clock cycle&quot;. each unexecuted operation held in said operation window is to be executed out of order by one of said functional units.&#x27; and after all of the operations combined with the modification on said advanced mapping file specified by the substance of the head part of said state-modification queue are terminated normally, a modification according with said substance of said head part of said state-modification queue is to be made on said completed mapping file, and said head part is to be dequeued from said statcmodification queue.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM   2<br>
THE PATENTS ACT, 1970 (39 of 1970)<br>
COMPLETE SPECIFICATION (See Section 10)<br>
COMPUTER SYSTEM<br>
SEKI,  HAJIME     of  4-38 DOUGO-KETA-MACHI, MATSUYAMA-SHI, EHIME 790-0848, JAPAN, JAPANESE national<br>
The following specification particularly describes the nature of the invention and the manner in which it is to be performed : -<br>
251/MUMNP/2003<br>
        21/02/03<br><br>
SPECIFICATION<br>
COMPUTER SYSTEM<br>
FIELD OF THE INVENTION<br>
The present invention relates to a computer system of a novel construction that can attain high performance by providing a high degree of instruction-level parallelism.<br>
DESCRIPTION OF THE PRIOR ART<br>
So far, versatile computer systems that have ever been put to practical use can be roughly classified as register-based machines or stack machines. Stack machines are superior in smallness of program code size and in quickness of interruption handling and context switching, though they have difficulty in attaining high performance. On the other hand, register-based machines can relatively easily attain high performance, but, in many other aspects, they are inferior to stack machines.<br>
There is no program compatibility between register-based machines and stack machines, and as mentioned above, neither are absolutely superior.<br>
The object of the present invention is to materialize a computer system that can harmonize itself both with the instruction system of register-baaed machines and with that of stack machines, and that can attain high performance.<br><br>
- 2 -<br>
SUMMARY OF THE INVENTION<br>
The computer system according to the present invention is basically similar to superscalar architectures capable of out-of-order execution, though it adopts an instruction format of large bit length, in which substances of operations and a substance of a state modification to be made on the virtual logical registers / operand stack are to be specified.<br>
The computer system according to the present invention comprises a data file having entries each of which is designed to hold data, a free list that is designed to hold unallocated-data-file-entry addresses, an advanced and a completed mapping file each having entries each of which is designed to hold a data-file-entry address, an operation window that is a buffer 'vto hold substances of operations waiting execution, a state-modification queue that is designed to hold substances of state modifications on mapping file indicated in instructions, and functional units for executing operations of respective kinds.<br>
The computer system of the present invention is so structured as to, in issuing one instruction per clock cycle, enter substances of the operations into the operation window, make a modification on the advanced mapping file, and enter the substance of this modification into the state-modification queue. In the case of an operation to generate result data, a data-file entry is newly allocated to hold the result data, and this makes the destination register. Besides, what makes each source register of operations is either a data-file entry whose address is obtained by accessing the advanced mapping file, or a data-file entry that is being allocated as destination register of an operation contained in the same<br><br>
-3-<br>
instruction.<br>
Each unexecuted operation held in the operation window is to be executed out of order by one of the functional units.<br>
After each operation derived from the same instruction that produced the substance of the head part of the state-modification queue is terminated normally, in accordance with the substance of the head part of the state-modification queue, contents of the completed mapping file is to be modified so as to reproduce the modification that was made on the advanced mapping file in the course of issue of the instruction, and the head part is to be dequeued from the state-modification queue.<br>
The computer system of the present invention can operate in eithfer of the two modes: the stack mode and the register mode. In the case of processing a program translated from machine language of register-based RISC/CISC processors in conformity to the instruction format for the computer system of the present invention, the system is to operate in the register mode. On the other hand, in the case of processing a program translated from machine language for stack-based processors in conformity to the instruction format for the computer system of the present invention, the system is to operate in the stack mode. It is easy to transform a plurality of instructions of a register machine / stack machine into an instruction of the computer system of the present invention, so the system can efficiently process a wide range of programs.<br>
In the register mode, each mapping file is to be used as an equivalent of register-mapping table of a register-based superscalar processor.<br><br>
- 4-<br>
In the stack mode, eacli mapping file is to be used to bold a<br>
kind of stack.    Such a state of the operand stack as { 	, word4, word3,<br>
word2, wordl } (the right end is the top of the stack) in a traditional stack machine corresponds to such a state of the stack held by mapping file as<br>
{	, d, c, b, a } (the right end is the top of the stack), with  wordl, word2,<br>
word3 and word4 respectively (to be) held in the data-file entries whose respective addresses are a, b, c and d, in the computer system of the present invention.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
Fig. 1 is a block diagram showing the basic structure of a preferred computer system according to the present invention.<br>
Fig. 2 is a conceptual drawing of the instruction format for a preferred computer system according to the present invention.<br>
Fig. 3 illustrates the structure of an entry of the data file.<br>
Fig. 4 illustrates the structure of an entry of the later-described operation queue.<br>
Fig. 5 shows the relation among the advanced mapping file, the completed mapping file, two push pointers, the bottom pointer, and the fill-flag file, each described later.<br>
Fig. 6 ■ 12 each show contents of the advanced mapping file, the completed mapping file, the state-modification queue, the operation queue, the data file, and the free list, at one of seven points in the course of an example action in the register mode.<br>
Fig. 13 ■ 19 each show contents of the advanced mapping file,<br><br>
- 5 -<br>
the completed mapping file, the state-modification queue, the operation queue, the data file, and the free list, at one of seven points in the course of an example action in the stack mode.<br>
PREFERRED EMBODIMENTS OF THE INVENTION<br>
In the following, a preferred computer system according to the present invention is described, (l) Basic Structure<br>
To begin with, the basic structure of the computer system of this embodiment is described.<br>
Fig. 1 is a block diagram of the computer system.    Shown in<br>
t<br>
Fig. 1 are an instruction cache 10, a data cache 11, a data buffer 12, an instruction-fetch unit 20, an instruction-issue unit 21, an advanced mapping file 3a, a completed mapping file 3c, a fill-flag file 3f, an advanced mapping history file 3h, a state-modification queue 4, an operation queue 5, a data file 6, a free list 7, arithmetic logic units 80 and 81, a branch unit 82, and a load/store unit 83.<br>
The computer system of the present invention needs to have an operation window, which is a buffer to hold substances of operations waiting execution. There are basically two ways to implement the operation window: centralized type and distributed type. The computer system of this embodiment is supposed to have an operation queue of centralized type.<br>
The computer system of the present invention can operate in either of the two modes: the register mode and the stack mode.    In the case<br><br>
ofproccMHinj: n pru^nini l.nniHlnU'd from mncliino lnnuiuif;o 
The computer system of the present invention has mapping files whose entries are each designed to hold a data-file-entry address, and that are to function in the same way as register-mapping tables of a register-based superscalar processor capable of out-of-order execution in the register mode. In the present invention, the mapping files are to function equivalently in the stack mode as well.<br>
(2) Instruction Format<br>
Fig. 2 is a conceptual drawing of the instruction format for the computer system of this embodiment. Both for the register mode and for the stack mode, the format of each instruction basically consists of a format-information field 101, an operations field 102, and state-modification field 103.<br>
Specified in the format-information field (FI field) are the length of the instruction, the number of operations the instruction contains, and the like.<br>
Specified in the operations field (Op field) are substances of operations^ arithmetic logic operations, branches, loads, stores, and the like.<br><br>
- 7 -<br>
In this embodiment, each operation is expressed in the form similar to the instruction format for RISC processors. In this embodiment, each instruction is supposed to contain up to 4 operations (such instructions as to contain a branch operation do not necessarily contain 4 operations).<br>
Specified in the state-modification field (SM field) is substance of a modification on mapping file, i.e. state modification on the virtual registers (in the register mode) / the virtual operand stack (in the stack mode). As described later, the register mode differs from the stack mode in format inside the state-modification field.<br>
In the case of an operation to generate result data, a data-file entry is to be newly allocated to hold the result data. The logical position of this entry is to be indicated by the content of the SM field.<br>
The computer system of this embodiment is supposed to be able to issue one instruction in the above-mentioned format per cycle.<br>
(2-1) Instruction Format for the Register Mode<br>
In the following, the instruction format for the register mode is explained.<br>
In the computer system of this embodiment, each data-file entry is supposed to be able to hold data that is to be held by a register of the virtual register machine. With rO, rl, r2, ... representing contents of mapping-file entries of address 0, 1, 2, ... respectively, data-file entries whose respective addresses are rO, rl. r2, ... are supposed to respectively hold data of register RO, Rl, R2, ... of the virtual register machine.<br>
For example, a program for the register machine to load data<br><br>
H<br>
of variables A, I? and X from memory into registers, compute (A*X-i H/X)*2, and store the result into memory as variable Y can be written as follows:<br><br>
LOAD   Rl, 100[R0] I<br>
LOAD   R4, 400[R0] ;<br>
MUL    1(5, 1(1, IM ;<br><br>
load the value at. address {the value in RO +.100}<br>
iiito register Rl<br>
load the value at address {the value in RO +400}<br>
into register .IM<br>
U5 = .IU*IM<br><br>
LOAD    R2, 200[R0] ;       load the value at address ilhe value in RO +200}<br>
into register R2<br>
DiV'\ R4, R2, R4 ;	K4 = K2/K4<br><br>
ADD   R5, R5, R4 ;<br><br>
R5 - R5+R4<br><br><br><br>
MUL   R5, R5, 2 ;<br><br>
R5 = R5*2<br><br>
STORE    500[R0], R5 I     store the value in register R5 at address {the<br>
value in 110 +500} where, the addresses of variables A, B, X and Y in memory are 100, 200, 400 and 500 added to the value in R0, respectively.<br>
Now, how to transform the above program into instructions for the register mode of the computer system of this embodiment is explained.<br>
Partitioned into groups each consisting of 4 instructions,<br><br>
- 9 -<br>
with substance of operation and that of modification to be made on mapping file expressed separately for each instruction, the above program is transformed as follows-'<br>
Instruction_la	load fl, 100[r0]	; i:fl<br>
Instruction_lb	load f2, 400[r0]	; 4:f2<br>
Instruction_lc	mul f3, fl, f2	; 5'f3<br>
Instruction_ld	load f4, 200[r0]	i 2:f4<br>
Instructional      div fl, r2, H	; 4:fl<br>
lnstruction_2b      add f2, r5, fl	; 5:f2<br>
lnstr\iction_2c       mul f3, f2, 2	; 5^f3<br>
Instruction_2d      store 500[r0], f3 where, addresses of the data-file entries to be newly allocated to hold result data are represented by fl, f2, ... in order for each group of instructions.    In this embodiment, fl, f'2, ... correspond to contents that are to be taken out of the free list in each cycle.<br>
Instruction_la implies to load the value at address {100 added to the value in the data-file entry corresponding to rO}, write it into the data-file entry corresponding to fl, and replace the content of the mapping-file entry of address 1 with the address of the data-file entry corresponding to fl. Instruction_lc implies to multiply the value in the data-file entry corresponding to fl by that corresponding to f2, write the result data into the data-file entry corresponding to f3, and replace the content of the mapping-file entry of address 5 with the address of the data-<br><br>
10<br>
file entry corresponding to f3.    The other instructions imply likewise.<br>
With four instructions put together, and with substances of operations and those of modifications to be made on mapping file expressed separately, for each of the two groups of instructions, the above program is transformed as follows^<br>
OpUoad fl, 100[r0]; load f2, 400[r0]; mul £3, fl, f2; load f4, 200[r0]} SM{i:fl, 2:f4, 4-i2, 5:f3}<br>
Op{div fl, r2, r4; add f2, r5, fl; mul f3, f2, % store 500lr0], f3} SM{4:fl, 5:f3}.<br>
These are the contents of the Op and SM fields in the case where the above program is transformed to conform to the instruction format for the register mode of the computer system of this embodiment. In transforming into the second instruction, though there were two alterations on the mapping-file entry of address 5, only the last one is held in the SM field. As above, as for the instruction format for the register mode, combinations of signs, each standing for address of a mapping-file entry on which an alteration is to be made and stuff to write, are to be listed in the SM field.<br>
Here, fl, f2, f3, ... appearing in operations in the Op field as substitutes for destination registers are to be mechanically allotted in order, so they could be omitted. In this embodiment, however, they are supposed to be explicitly indicated.<br><br>
- II -<br>
(2-2) Instruction Format for the Stack Mode<br>
Next, the instruction format for the stack mode is explained.<br>
In the computet1 system of this embodiment, each data-file entry is supposed to be able to hold data that is to be held by an entry of the operand stack of the virtual stack machine. Namely, with ..., s3, s2, si representing contents of the stack held by mapping file (the right end is the top of the stack), the operand stack of the virtual stack machine is supposed to be constructed by lining up data that are to be held in data-file entries whose respective addresses are ..., s3, s2, si in order.<br>
For example, a program for the stack machine to compute A*X+B/X, and store the result into memory as variable Y can be written as follows ' <br>
LOAD  ;<br>
DUP;<br>
LOAD  ;<br>
MUL;<br>
SWAP;<br><br>
push the value of local variable  onto the operand<br>
stack<br>
duplicate   the   top   word  on  the   stack,   and  push   the<br>
duplicate onto the stack<br>
push the value of local variable  onto the operand<br>
stack<br>
pop two words from the stack, multiply them, and push<br>
the result onto the stack<br>
swap top two words on the operand stack<br><br>
LOAD  ;       push the value of local variable  onto the operand stack<br><br>
-  12 -<br>
SWAP J	swap top two words on the operand stack<br>
D1V I	pop two words from the stack, divide by the top word, and<br>
push the result onto the stack<br>
ADD J	pop two words from the stack, add them, and push the<br>
result onto the stack STORE  ;     store the value on the top of the stack into local variable <c> where, the storage areas of variables A, B, X and Y are local variables , ,  and , respectively.<br>
Now, how to transform the above program into instructions for th§ stack mode of the computer system of this embodiment is explained.<br>
Partitioned into two groups of instructions, with substance of operation and that of modification to be made on mapping file expressed separately for each instruction, the above program is transformed as follow s'<br>
Instruction_la	load fl, 	I +1: fl<br>
Instruction_lb	add f2, fl, 0	I +2: fl, f2<br>
Instruction^	load f3, 	; +3: fl, £2, f3<br>
Instruction_ld	mul 14, f2, fj	; +2: fl, f4<br>
Instruction_le	(swap)	I +2: f4, fl<br>
Instruction_2a	load fl,        ; +1: fl<br>
Instruction_2b	(swap)	I +1' fl, si<br><br>
I'.i<br>
liiHtruction_2c	divfJ, I"I,H1      ; (): P2<br>
lnatruotion_2d	add f«J, s2, f2     ; -l: fj<br>
Instruction_2e	store , f3     ', "2-<br>
where, in the same way as for the register mode, addresses of the data-file entries to be newly allocated to hold result data are represented by fl, f2, ... in order for each group of instructions. Besides, as for each modification to be made on mapping file, the number of entries by which the stack held by mapping file is to grow and stuff to write in the vicinity of the top of the stack are indicated.<br>
Instruction_la implies to load the value of local variable , write it, into the data-file entry corresponding to fl, grow the stack held by mapping file by one entry, and make content of the new top-of-the-stack entry to be the address of the data-file entry corresponding to fl. Instruction_lb implies likewise, however, the modification to be made on mapping file is expressed with that to be made by Instruction_la involved. The other instructions imply likewise.<br>
With instructions put together, and with substances of operations and those of modifications to be made on mapping file expressed separately, for each of the two groups of instructions, the above program is transformed as follows'-<br>
Op{ load fl, ; add f2, fl, 0; load f3, ; mul f4, f2, F3 }<br>
SM{ +2: f4, fl}<br>
Op{ load fl, ; div £2, fl, si; add £3, s2, £21 store , £3 }<br><br>
M    -<br>
SM{ ■%}<br>
These are the contents of the Op and SM fields in the case where the above program is transformed to conform to the instruction format for the stack mode of the computer system of this embodiment. As above, as for the instruction format for the stack mode, the amount of stack growth and a series of signs standing for post-modification stuff in the vicinity of the top of the stack are to be specified in the SM field.<br>
Here, as stated for the register mode, fl, f2, f3, ... appearing in operations in the Op field as substitutes for destination registers are to be mechanically allotted in order, so they could be omitted. In this embodiment, however, they are supposed to be explicitly indicated.<br>
So far, how programs for a register machine / stack machine are transformed to conform to the instruction format for the computer system of this embodiment has been explained. A program to be processed by the computer system of the present invention, however, need not necessarily be a one into which a program for a register machine / stack machine is transformed.<br>
For example, a program for the stack mode to compute A+(B/2)*X+(C/3)*X*X, store the result into memory as variable Y, and pile the values of factors A, B/2 and C/3 in order on the operand stack may be such as follows-'<br>
Op{load fl, 8[s2]; load f2, 16[s2]; div f3, f2, 2; load f4, 24[s2]} SM{+3: fl, f3, f4}<br><br>
-  15<br>
Op{div fl, si, 3; load f2, 200[s4]; mul f3, f2, £2; mul f4, s2, f2} SM{+2: fl, f4, 13}<br>
Opimul fl, s3, si; add f2, s5, s2; add f3, f2, fl; store 400[s6], f3}<br>
SM{-2:} where, the addresses of variables A, B and C in memory are respectively 8, 16 and 24 added to the value in the entry under the top of the initial virtual operand stack, and the addresses of variables X and Y are respectively 200 and 400 added to the value in the entry at the top of the initial virtual operand stack.<br>
\ (3) Register Mode<br>
(3-1) Functions and Structures Required for the Action in the Register Mode Here, the function and structure of each component of the computer system of this embodiment used for the action in the register mode are described. They are the functions and structures needed in the stack mode as well.<br>
(A)	Instruction-Fetch unit<br>
The instruction-fetch unit is furnished with a program counter, which is not shown in the figures, and so structured as to fetch instructions from the instruction cache and deliver them to the instruction-issue unit.    It also carries out prediction and execution of branches.<br>
(B)	Instruction-Issue Unit<br>
The instruction-issue unit is so structured as to, in issuing<br><br>
- 1(&gt; -<br>
each hiHtruction delivered from the instruction-fetch unit, generate various signals to modify the advanced mapping file, the data file, etc., and enter substances into the operation queue and the state-modification queue. (C) Mapping files<br>
A mapping file is so structured as to have entries, each of which can  hold u dutirfilo'ontry uddroHH.     \n the register  mode, each mapping file is to he used as an equivalent of register-mapping table of register-based superscalar processors.<br>
The computer system of the present invention is furnished with two mapping files* an advanced mapping file (AMF) and a completed mapping file (CMF). These two mapping files are of the same shape, and their; respective entries correspond to each other.<br>
In the computer system of the present invention, each time an instruction is issued, a modification according with the instruction is made on the advanced mapping file (hereafter, it may be referred to as the AMF). Namely, the advanced mapping file is to reflect substances of all the instructions that have been issued.<br>
On the other hand, the completed mapping file (hereafter, it may be referred to as the CMF) is to reflect substances of all the instructions that have been completed in program-sequential order. The computer system of the present invention is capable of out-of-order execution of operations contained in the issued instructions. And, for securing precise handling of exceptions, the completed mapping file enables the system to construct the state grounded on aU the instructions completed in order.<br><br>
-   17<br>
The computer system of this embodiment is furnished with an advanced mapping history file (hereafter, it may be referred to as the AMF history filo) for incarnation of Bpoculalivo oxocution based on branch prediction. Each entry of the AMF history file is designed to bo able to hold contents of all the AMF entries and later-described register PP-A.<br>
(D)	Data file (DF)<br>
The data file (hereafter, it may be referred to as the DF) comprises physical registers: POO, P01, P02, ....<br>
Fig. 3 illustrates the structure of entry 6(i) of the DF 6 in the computer system of this embodiment. Here, "i" stands for entry address. Each entry 6(i) of the DF 6 comprises data field 61(i) and write-completion-flag (WCF) field 62(0.<br>
As for the hardware implementation, the DF is practically made of register files that respectively correspond to the fields listed above.<br>
The data field of each DF entry is designed to hold a word of data.<br>
In each DF entry, the WCF field is supposed to hold "1" in the case.where data is already written in the data field, and hold "0" otherwise.<br>
(E)	Free List (FL)<br>
The free list (hereafter, it may be referred to as the FL) is to hold addresses of free, namely, unallocated DF entries. In this embodiment, the FL is constructed as a circular FIFO queue.<br>
In the initialized state, the addresses of all DF entries are registered on the FL.    In the case where a DF entry needs to be newly<br><br>
-   18<br>
allocated, a free-DF-entry address is to be taken out of the FL.    Conversely, if a DF entry is released from allocation, the address of this entry is to be registered on the FL. (F) Operation queue (OQ)<br>
The operation queue (hereafter, it may be referred to as the OQ) is a buffer to hold substances of operations contained in instructions that are already issued but not yet completed, and is constructed as a circular FIFO queue.<br>
Fig. 4 illustrates the structure of entry 5(i) of the OQ 5 in the computer system of this embodiment. Here, "i" stands for entry address. Each entry 5(i) of the OQ 5 comprises operation field 50(0, destiriation-register field 51(0, first-operand field 52(i), first-source-register field 53(i), second-operand field 54(i), second-source-register field 55(i), instruction-border (IB) field 566), branch-tag (BT) field 57(0 and state (S) field 58(0.<br>
The operation field of each OQ entry is designed to hold an operation code.<br>
The destination-register field of each OQ entry is designed to hold an address of DF entry allocated as destination register of the operation.<br>
Each of the first- and second-operand fields of each OQ entry is designed to hold an operand value required for the operation.<br>
Each of the first" and second-source-register fields of each OQ entry is designed to hold an address of DF entry allocated as source register of the operation.<br><br>
- 19 -<br>
In each OQ entry, the IB field is supposed to hold "1" in (lie case where the entry was at the tail of the queue when the substance of operation, contained in an issued instruction, was entered into the OQ, and hold "0" otherwise.<br>
The BT field of each OQ entry is concerned with speculative execution based on branch prediction. In this embodiment, as described later, there is a certain relationship between branch tags to bo entered in BT fields and entry addresses in the AMF history file.<br>
In each OQ entry, indicated in the S field is "unexecuted", "normal termination", "occurrence of exception" or the like according to the state of the operation held in the entry.<br>
The OQ is furnished with comparators for each source-register field of each entry, and has associative functions, by which the content of each source-register field is compared with DF-entry addresses and data is written into the operand field corresponding to each matched source-register field. (G) State-Modification Queue (SMQ)<br>
The state-modification queue (hereafter, it may be referred to as the SMQ) is a buffer to hold substances of modifications on mapping file indicated in instructions that are already issued but not yet completed, and is constructed as a circular FIFO queue. In this embodiment, each entry of the SMQ is to correspond to the SM field of an instruction. (H) Functional Units<br>
As shown in Fig. 1, the computer system of this embodiment is furnished with four functional units^ arithmetic logic unit 0 and 1, a<br><br>
- 20<br>
branch unit and a load/store unit (hereafter, it may be referred to a.s the LSU).   These are to operate in parallel independently of each other.<br>
(3-2) Action in the Register Mode<br>
Next, the action in the register mode of the computer system of this embodiment is described.<br>
The    computer    system    of    this    embodiment    processes instructions through four stages: Tl] instruction-fetch, [2] instruction-issue, [3]   operations*execution,   and   [4]   instruction-completion  stage.     In  the following, the action in each stage is described, [l] Instruction-Fetch Stage<br>
In this stage, the instruction-letch unit letches an instruction from the instruction cache, and determines the address of the instruction to fetch next. Ordinarily, it is from the next address to fetch next. But, in the case where the fetched instruction includes either an unconditional branch operation or a conditional branch operation with a prediction of taking a branch, the case where a branch prediction turns out to have missed, or the case where an exception occurs, the address of the instruction to fetch next is changed. [2]- Instruction-Issue Stage<br>
In this stage, substances of operations according with the contents of the Op field of the instruction to be issued are entered into the operation queue (OQ), a modification according with the contents of the SM field is made on the advanced mapping file (AMF), and the substance of this modification is entered into the state "modification queue (SMQ).    At this<br><br>
I'.l<br>
juncture, rO, rl, r2, ... in the instruction are respectively replaced by pre-alteration contents of AMF entries of address 0, 1, 2, ..., and fl, f2, ... are respectively replaced by DF-entry addresses that are taken out of the free list (FL) in order.<br>
In the IB field of each OQ entry into which substance of an operation contained in the instruction is being entered, "1" is entered for the OQ entry getting to be at the tail of the queue, and "0" is entered for those otherwise, in the BT field of each of the OQ entries, the branch tag forwarded from the instruction-issue unit is entered.<br>
In the WCF field of each of the DF entries newly allocated in the course of issue of the instruction (in respective correspondence with fl, £2, f3, :v), "0" is entered.<br>
In the case of a load/store operation, its substance is not only entered into the OQ, but also, together with the address of the OQ entry into which the substance is being entered, delivered to the LSU.<br>
As for each writing of a DF-entry address replacing any of rO, rl, r2, ... into a source-register field on the OQ, in the next cycle, contents of the DF entry of that address will be read out. In the case of the WCF-field content being "1", the data, together with the DF-entry address, will be conveyed to the OQ. Then, on the OQ, each source-register-field content will be compared with the conveyed DF-entry address, and the data will be written into the operand field(s) corresponding to the matched source-register field(s). [3] Operations-Execution Stage<br>
Each of unexecuted operations held in the  OQ is to be<br><br>
- 22 -<br>
executed after becoming executable. Therefore, operations are executed out of order.<br>
If there is an OQ entry where each required source data is written in the appropriate operand field, and if a functional unit that has the function of executing the operation held in that OQ entry is available, the substance of the entry, together with the entry address, is to be transmitted to the functional unit, and to be processed.<br>
As for each operation to generate result data, such as load and arithmetic/logic operations, if result data is obtained normally, it is to be written into the data field of the destination DF entry, and the WCF field is to be altered to "1". Besides, on the OQ, each source-register-field content is to be compared with the address of the above destination DF entry, and the result data is to be written into the operand field(s) corresponding to the matched source-register field(s), if any.<br>
As for each OQ entry holding a substance of a load/store operation, the same substance was delivered to the LSU in the instruction-issue stage. In this embodiment, each operand data required for address ^calculation that was not arranged in the instruction-issue stage is supposed to be transmitted to the LSU right after entered into the OQ entry.<br>
The LSU executes load operations out of order. As for store operations, the LSU will perform stores in the instruction-completion stage s,6 that precise handling of exceptions may be secured, though it performs address calculations out of order in the operations-execution stage. Therefore, in the case of a store operation, when the store data and the store address are both arranged, it is taken for terminated normally as action in<br><br>
- 2\the operations-execution stage.<br>
If an operation is terminated normally, the S field of the OQ entry holding the substance of this operation is to be altered to "normal termination".<br>
In  the  case  where  an  exception  occurs  in  executing  an operation, this piece of information is to be written into the S field of the OQ entry holding the substance of that operation, and to be communicated to the instruction-fetch unit. [4] Instruction-Completion Stage<br>
Instructions are completed in program-sequential order.<br>
On the OQ, the entries ranging from the head one of the queue!\ to the first one whose IB-field content is "1" hold the whole substances of the operations contained in the instruction to be completed next. If the S-field content is/becomes "normal termination" in each of the OQ entries in the above range, the instruction gets ready to be completed. To complete the instruction, the system dequeues the OQ entries in the above range, makes a modification according with the substance of the head entry of the state-modification queue (SMQ) on the CMF, and dequeues this head entry. Here, the modification that was made on the AMF in the course of issue of the instruction is being reproduced on the CMF.<br>
Besides, in accordance with completion of the instruction, each address of DF entry to be released from allocation is to be registered on the FL. In the register mode, a set of addresses of DF entries to be released from allocation consists of the following two groups- the one(s) each being pre-alteration content of a CMF entry to be altered in the course of<br><br>
- 24  -<br>
completion of the instruction, and the one(s) each being a destination-register-field content in the OQ entries to be dequeued that is not contained in the SMQ entry to be dequeued - not to be written in the CMF -. The computer system of the present invention could be so structured that registration of addresses of DF entries to be released from allocation onto the FL is to be carried out after the completion of the instruction. In this embodiment, however, it is supposed to be carried out at the same time as the completion of the instruction.<br>
In the case of completing an instruction that includes a store operation, the system requests the LSU to perform the store. Thus, data are to be stored in program-sequential order for sure.<br>
\	In   the   case   where   content   of   the   S   field   is/becomes<br>
"occurrence of exception" in an OQ entry holding substance of an operation contained in the instruction to be completed next, as the virtual state at the point of the occurrence of exception on the assumption that the program was being executed in order can be constructed by means of the CMF and the DF at this time, precise handling of exceptions can be materialized. To cancel all the instructions that have been issued after the instruction that caused an exception, the system puts each address of DF entry allocated as destination register in the operations to be canceled back on the FL, and dequeues entries in the range that corresponds to the instructions to be canceled both on the OQ and on the SMQ.<br>
The above is the overall action in the register mode of the computer system of this embodiment.<br><br>
- 25<br>
(3-3) Example Action in the Register Mode<br>
Next, an example action is described. Now, let's consider processing, with the computer system of this embodiment, the above-mentioned program to compute Y=(A*X+B/X)*2 consisting of the following two instructions'-<br>
Instruction,.!<br>
Op'tioad fl, lOOfrO]; load £2, 400[r0]; mul f3, fl, f2; load f4, 200tr0]}<br>
SM{l:fl, 2:f4, 4:f2, 5:f3} Jnstruction_2<br>
Op{div fl, r2, r4; add f2, r5, fl; mul f3, f2, 2; store 500[r0], f3}<br>
SMU'fl, 5:f3}.<br>
Fig. 6 ■ 12 show changes in the state of the computer system of this embodiment in the course of processing of the above program in order of time. With reference to these figures, detailed action is described below. In Fig. 6 ■ 12, the structure of each entry of the DF 6 / OQ 5 is the same as in Fig. 3 / Fig. 4.<br>
Let us suppose that contents of the FL / AMF are such as those shown in Fig. 6 at the outset. Here, as for the FL 7, which is constructed as a circular FIFO queue, it is shown that the four entries from the head one of the queue downward respectively correspond to fl, V2, f'3 and f4 for the instruction to be issued next. On the AMF 3a / CMF 3c, the entries are supposed to be tagged with address 0, 1, 2, ... from the top downward, and to correspond to rO, rl, r2, ..., respectively. As for places in which p## is entered, though a DF-entry address is written, you need not pay attention in the explanation of this example action.<br><br>
- 26 -<br>
Let us suppose that lnstruction_l is to be issued when the computer system is in such a state as shown in Fig. 6.<br>
Substances of operations according with the contents of the Op field of instruction_l are entered into the OQ, a modification according with the contents of the SM field is made on the AMF, and the substance of this modification is entered into the SMQ. At this juncture, each rO in the instruction is replaced by pl2, which is the pre-alteration (Fig. 6) content of the AMF entry of address 0, and fl, f2, f3 and f4 are respectively replaced by p2G, p34, p42 and p5], which arc taken out of the free list in order. In regard to the modification on the AMF, contents of entries corresponding to rl, r2, r4 and r5 are altered to p26, p51, p34 and p42, which replace fl, f4, f2 and f3v respectively. As for the IB field of each of the four OQ entries whose contents are shown in Fig. 7, "1" is entered for the bottom OQ entry as it is at the tail of the queue at this time, and "0" is entered for the other entries. Besides, in the S field of each of these four OQ entries, "0" is entered, which stands for "unexecuted".<br>
In the WCF field of each of the newly allocated DF entries whose respective addresses are p26, p34, p42 and p51 - respectively corresponding to f 1, f2, f3 and f4 -, "0" is entered. (It is supposed that, in the DF entry of address pl2 corresponding to rO, the WCF-field content is "1" and data "1000" is already written.)<br>
Besides, in this example action, from beginning to end, as branch tag, "0" is supposed to be forwarded from the instruction-issue unit, and to be written in the BT field of each OQ entry into which substance of an operation is entered.<br><br>
- 27 -<br>
And moreover, as lnstruction_l includes 3 load operations, their substances are not only entered into the OQ, but also delivered to the LSU.<br>
Thus, the computer system in such a state as shown in Fig. 6 gets to bo in such a fltate as shown in Fig. 7.<br>
In thu next cyclo, following Instructional, liiHti.'uotion_2 is to be issued.<br>
In the same way as in the case of Instruction.^, substances of operations according with the contents of the Op field of instruction_2 are entered into the OQ, a modification according with the contents of the SM field is made on the AMF, and the substance of this modification is entered into, the SMQ.<br>
In the WCF field of each of the newly allocated DF entries whose respective addresses are pl6, pl8 and p57 - respectively corresponding to fl, f2 and f3 -, "0" is entered.<br>
And moreover, as Instruction_2 includes a store operation, its substance is not only entered into the OQ, but also delivered to the LSU.<br>
Besides, since pl2, which replaced rO, was written into source -register fields on the OQ in the course of issue of Instructional in the preceding cycle, contents of the corresponding DF entry are read out. As the WCF-field content turns out to be "1", read-out data "1000", together with DF-entry address "pl2", is conveyed to the OQ. Then, on the OQ, by means of the associative function, data "1000" is written into the operand fields that respectively correspond to the source-register fields holding "pl2".<br>
Thus, the computer system gets to be in such a state as<br><br>
- 28 -<br>
shown in Fig. 8.<br>
Unexecuted operations held in the OQ are to be executed out of order ~ each after becoming executable.<br>
Fig. 9 shows the state that the computer system is in, at the point - after some cycles have gone by - when all the instructions issued before Instruction_l have been completed and all the four operations contained in Instruction,,! have been torminatod normally. AH for each of the four OQ entries holding the substances of the operations contained in lnstruction_l, each required operand data is already written in the operand field, the S-field content is "1", which stands for normal termination, and in the DF entry indicated in the destination-register field, data is already written and WCL'Wield content is "I". And, contents of the CMK at this point are the same as contents of the AMF right before issuing of Instruction^ (Fig. 6). The system in this state is to complete Instruction_l in the following manner.<br>
As the top one of the eight OQ entries whose contents are shown in Fig. 9 is at the head of the queue at this point, four OQ entries ranging from that entry to the fourth entry, whose IB-field content is "1", are dequeued. As the top one of the two SMQ entries whose contents are shown in Fig. 9 is at the head of the queue at this point, a modification according with its substance is made on the CMF. Namely, contents of the CMF entries whose respective addresses are 1, 2, 4 and 5 are altered to p26, p51, p34 and p42, respectively. And moreover, the said head entry is dequeued on the SMQ.<br>
Besides,   in  accordance  with  completion  of Instruction_l,<br><br>
- 2\) -<br>
each address of DF entry to be released from allocation is enqueued on the FL. In this case, pro-alteration contents of the CMV entries whose respective addresses are 1, 2, 4 and 5 - p02, plO, p24 and p60, which are being altered - are read out and registered. (In this case, there is no destination-register-field content in the dequeued OQ entries that is not contained in the dequeued SMQ entry.) Thus, the computer system gets to be in such a state as shown in Fig. 10.<br>
Fig. 11 shows the state that the computer system is in, at the point - after some further cycles have gone by - when three operations contained in Instruction_2 have been terminated normally and the store data and the store address have been both arranged for the last (store) operation.<br>
The system at the point of Fig. 11 is to complete Instruction_2 in a cycle in the same manner as in the case of Instruction^. In this case, Instruction_2 includes a store operation, so the system requests the LSU to perform the store. Besides, in accordance with completion of the instruction, each address of DF entry to be released from allocation is enqueued on the FL. In this case, p34 and p42 - pre-alteration contents of CMF entries that are being altered -, and pl8 - a destination-register-field content in the dequeued OQ entries that is not contained in the dequeued SMQ entry - are registered on the FL. Thus, the computer system gets to be in such a state as shown in Fig. 12.<br>
Now, computation of Y=(A*X+B/X)*2 is concluded in the computer system of this embodiment.<br><br>
- 3U -<br>
(4) Stack Mode<br>
(<m functions and structures required for the action in stack mode></m>
The functions and structures described in section (3-1) are needed in the stack mode as well.    Here, functions and structures required additionally for the action in the stack mode are to be described.    These are mainly concerned with the mapping files and the load/store unit (LSU). (C+)   Mapping files and Fill-Flag File (FFF)<br>
In the stack mode of the computer system of this embodiment, a mapping file and the data file (DF) are supposed to virtually construct an uppermost part of the operand stack. Namely, in the stack mode, each mapping file is to be used to hold a kind of stack.    Such a state<br>
of the operand stack as {	, word4, word3, word2, wordl} (the right end is<br>
the top of the stack) in a traditional stack machine corresponds to such a<br>
state of the stack held by mapping file as {	 d, c, b, a } (the right end is<br>
the top of the stack), with wordl, word2, word3 and word4 respectively (to be) held in the data-file entries whose respective addresses are a, b, c and d, in the computer system of the present invention. When the operand stack grows so long, the remaining part is to be stored in the data buffer and the data cache.<br>
Each mapping file can function as a circular buffer. For this, they have two kinds of registers: push pointer and bottom pointer. The push pointer indicates the entry over the top one of the stack held by the mapping file. The bottom pointer indicates the bottom entry of the stack held by the mapping file. Yon can know how many entries are vacant in the mapping file by ftubtracting the value of the push pointer from<br><br>
- 32 -<br>
embodiment, while uppermost part of the operand stack is to be virtually constructed by means of a mapping file and the data file (DF), lower and even lower part are to be stored in the data buffer and in the data cache, respectively. As the LSU is supposed to be able to quickly access the data buffer, the larger proportion of variables to access the data buffer retains, the more efficiently the computation can proceed. And, by letting the data buffer retain an appropriate number of words of data, later-described spill/fill operations between the DF, the data buffer and the data cache can be streamlined.<br>
The LSU is furnished with a register to hold a pointer to first local variable' vars register, which is not shown in the figures. In the computer system of this embodiment, though the storage area of the first local variable is either in the data buffer or in the data cache, the vars register is to hold the corresponding address in the data cache. Namely, even if all or part of the local variables are practically held in the data buffer, assuming that all the local variables were spilt into the data cache, you can associate each local variable with an address in the data cache. In processing a load/store operation, the LSU may perform an address calculation referring to the value of the vars register, judge whether the storage area of the object local variable is in the data buffer or in the data cache, and access the storage area.<br>
The LSU is so structured as not only to process load/store operations specified in the program, but also to automatically perforin spills/ fills between the data buffer and the bottom of the stack constructed by means of the AMF/CMF and the DF in order to evade overflows/underflows.<br><br>
- 33 -<br>
A word of data can be spilt from the DF into the data buffer, when the following two conditions are satisfied (otherwise, the spill is to be deferred): (a) an identical content is held in the entry indicated by BP both in the AMF and in the CMF) and (b) there is no OQ entry in the queue whose source-register field holds the same DF-entry Address as said identical content. The system could be so structured that condition (b) is always satisfied, by introducing certain restrictions on cases in which an address of DF entry used as source register of an operation included in an instruction is to remain in mapping file. If such restrictions are not introduced into the instruction system, the computer system needs to be so structured as to have the following function: comparing the content of each Rource';register field on the OQ with the same Dl'^cntry address aR Raid identical content, and checking in regard to condition (b). In the case where the above two conditions are satisfied, a word of data held in the DF entry indicated by I.ho content, of the AM I'VCM K entry indicated by HI' can be spilt into the data buffer. At this juncture, the value of BP is to be increased by one, and the address of said DF entry is to be registered on the FL.<br>
Conversely, in filling the DF with a word of data from the data buffer, the system is to take a word of data to fill with out of the data buffer, assign to it a free DF entry, write the word into the data field of this entry, whose WCF-field content is set to be "1", decrease the value of BP by one, and write the address of the assigned DF entry into the entry indicated by decreased-byone BP both on the AMF and on the CMF. At this juncture,  "1" is to be entered into the FFF entry corresponding to the<br><br>
- M  -<br>
AMF/CMF entry into which the address of the DF entry is being written.<br>
Besides, between the data buffer and the data cache, spills and fills are to be performed properly in accordance with vacancies in the data buffer.<br>
The system can be so structured that, with two mapping files (the AMF and the CMF), the data buffer and the data cache each divided into interleaved banks, operations similar to the above are to be respectively performed between corresponding banks, so that a spill/fill operation of a plurality of words of data can be performed at once between the DF, the data buffer and the data cache. In tluH caac, for spill/fill ouorutionH, each of the AMF, the CMF, the data buffer and the data cache needs to have a read/write port for each bank, and the DF needs to have as many read/write ports as the interleaved divisions.<br>
The above is the basic functions and structures required additionally for the action in the stack mode<br>
(4-2) Action in the Stack Mode<br>
Next, the action in the stack mode of the computer system of this embodiment is described.<br>
In the stack mode, in the same manner as in the register mode, the computer system of this embodiment processes instructions through four stages-' [lJ instruction-fetch, [2] instruction-issue, [li\ operations-execution, and [4] instruction-completion stage. In the following, the action in each stage is described.<br><br>
- 35 -<br>
UJ Instruction-Fetch Stage<br>
In   this   stage,    the   instruction-fetch    unit   fetches   an instruction from the instruction cache, and determines the address of the instruction to fetch next. [2] Instruction-Issue Stage<br>
In this stage, substances of operations according with the contents of the Op field of the instruction to be issued are entered into the operation queue (OQ), a modification according with the contents of the SM field is made on the advanced mapping file (AMF) and its push pointer, PP-A, and the substance of this modification is entered into the state-modification queue (SMQ). At this juncture, si, s2, s3, ... in the instruction — whidh respectively correspond to top, 2nd, 3rd, ... of the stack — are respectively replaced by pre-alteration contents of corresponding AMF entries, and fl, f2, ... are respectively replaced by DF-entry addresses that are taken out of the free list (FL) in order.<br>
In each of the entries of the fill-flag file (FFF) in the range corresponding to the AMF entries that are undergoing the modification — in the vicinity of the new top of the stack -, "0" is entered.<br>
In the IB field of each OQ entry into which substance of an operation contained in the instruction is being entered, "1" is entered for the OQ entry getting to be at the tail of the queue, and "0" is entered for those otherwise. In the BT field of each of the OQ entries, the branch tag forwarded from the instruction-issue unit is entered.<br>
In the WCF field of each of the DF entries newly allocated in the course of issue of the instruction (in respective correspondence with fl,<br><br>
:)('.<br>
f2, a, ...), "0" is entered.<br>
In the case of a load/store operation, its substance is not only entered into the OQ, but also, together with tho address of tho OQ entry into which the Hubwtuhcc is being entered, delivered to the LSU.<br>
As for each writing of a DF-entry address replacing any of si, s2, s3, ... into a source-register Held on the OQ, in the next cycle, contents of the DF entry of that address will be read out. In the case of the WCF-field content being "1", the data, together with the DF-entry address, will be conveyed to the OQ. Then, on the OQ, each source-register-field content will be compared with the conveyed DF-entry address, and the data will be written into the operand field(s) corresponding to the matched source-register field(s). [3] Operations-Execution Stage<br>
Each of unexecuted operations held in the OQ is to be executed after becoming executable in the same manner as in the register mode. [4] Instruction-Completion Stage<br>
Instructions are completed in program-sequential order in the same manner as in the register mode except for the following.<br>
To begin with, it is in conformity with the format inside the SM field of instruction - namely, entry format for the state-modification queue (SMQ) - for the stack mode that the modification that was made on the AMF in the course of issue of the instruction is reproduced on the CMF.<br>
Besides, in accordance with completion of the instruction, each address of DF entry to be released from allocation is to be registered on<br><br>
- 37 -<br>
the FL. In the stack mode, a set of addresses of DF entries to be released from allocation consists of the following two groups^ the one(s) each being a DF-entry address to be eliminated from the stack by the alterations on the (JMIV and J'L'-CJ in the conn-to of completion of the instruction, and the ono(s) each being a destination-register-field content in the OQ entries to be dequeued that is not contained in the SMQ entry to be dequeued - not to be written in the CMF -.<br>
The above is the overall action in the stack mode of the computer system of this embodiment.<br>
(4*3) Example Action in the Stack Mode<br>
\	Next, an example action is described.    Now, let's consider<br>
processing, with the. computer system of this embodiment, the above-mentioned program to compute Y=A*X+B/X consisting of the following two instructions-<br>
Instruction_l Op{ load fl, ; add f2, fl, 01 load f3, ; mul f4, f2, f3 } SM{ +2: f4, fl}<br>
Instruction_2 Op{ load fl, ; div f2, fl, si; add f3, s2, f2; store , f3 } SM{-2:}.<br>
Fig. 13 - 19 show changes in the state of the computer system of this embodiment in the course of processing of the above program in order of time. With reference to these figures, detailed action is described below.    In Fig. 13 ' 19, the structure of each entry of the DF G /<br><br>
;w<br>
OQ 5 is the sanio as in Fig. 3 / Fig. 4.<br>
Let us suppose that contents of the FL / AMF are such as those shown in Fig. 13 at the outset. Here, as for the FL 7, which is constructed as a circular FIFO queue, it is shown that the four entries from (he hcml one of'Uio qutmo dowiiw/ird respectively correspond to fl, IV, f3 imtl f4 for the instruction to be issued next. As for the AMF, it is shown that the entries constituting the stack from the top downward correspond to si, s2, ..., respectively. As for places in which p## is entered, though a DF-entry address is written, you need not pay attention in the explanation of this example action. Besides, in this example action, it is supposed, for the sake of simplicity, that no spill/fill operation between the DF and the data buffer i^ to be performed.    So, the value of BP does not fluctuate.<br>
Let us suppose that Instruction_l is to be issued when the computer system is in such a state as shown in Fig. 13.<br>
Substances of operations according with the contents of the Op field of instruction_l are entered into the OQ, a modification according with the contents of the SM field is made on the AMF and PP-A, and the substance of this modification is entered into the SMQ. At this juncture, fl, f2, f3 and f4 in the instruction are respectively replaced by p26, p34, p42 and p51, which are taken out of the free list in order. In regard to the modification on the AMF, p26 and p51, replacing fl and f4, are entered in the entries at and under the top of the stack grown by two entries, respectively. As for the IB field of each of the four OQ entries whose contents are shown in Fig. 14, "1" is entered for the bottom OQ entry as it is at the tail of the queue at this time, and "0" is entered for the other entries.<br><br>
- 39 -<br>
Besides, in the S field of each of these four OQ entries, "0" is entered, which stands for "unexecuted".<br>
in the WCF field of each of the newly allocated DF entries whose respective addresses are p26, p34, p42 and p51 — respectively corresponding to fl, f2, f3 and f4 -, "0" is entered.<br>
Besides, in this example action, from beginning to end, as branch tag, "0" is supposed to be forwarded from the instruction-issue unit, and to be written in the BT field of each OQ entry into which substance of an operation is entered.<br>
And moreover, as Instruction_l includes 2 load operations, their substances are not only entered into the OQ, but also delivered to the LSU.  V<br>
Thus, the computer system in such a state as shown in Fig. 13 gets to be in such a state as shown in Fig. 14.<br>
In the next cycle, following Instructional, Instruction_2 is to be issued.<br>
In the same way as in the case of Instructional, substances of operations according with the contents of the Op field of instruction_2 are entered into the OQ, a modification according with the contents of the SM field is miido on Lhe AJV1F and l'I'-A, and (ho subHtunco of HUH modification is entered into the SMQ. At this juncture, si and s2 in the instruction are respectively replaced by p26 and p51, which are the pre_alteration (Fig. 14) contents of the corresponding AMF entries, and fl, f2 and £3 are respectively replaced by pl6, pl8 and p57, which are taken out of the free list in order.    As only a negative growth of the stack is indicated in the SM<br><br>
~ 41) -<br>
field, no alteration is required on the AMF.<br>
In the WCF field of each of the newly allocated DF entries whose respective addresses are pl6, pl8 and p57 — respectively corresponding to fl, f2 and f3 —, "0" is entered.<br>
And moreover, as Instruction_2 includes a load operation and a store operation, their substances are not only entered into the OQ, but also delivered to the LSU.<br>
Thus, the computer system gets to be in such a state as shown in Fig. 15.<br>
Unexecuted operations held in the OQ are to be executed out of order — each after becoming executable.<br>
\	Fig. 16 shows the state that the computer system is in, at<br>
the point - after some cycles have gone by - when all the instructions issued before Instructional have been completed and all the four operations contained in Instruction^ have been terminated normally. As for each of the four OQ entries holding the substances of the operations contained in lnstruction_l, each required operand data is already written in the operand field, the S-field content is "1", which stands for normal termination, and in the DF entry indicated in the destination-register field, data is already written and WCF-field content is "1". And, contents of the CMF and PP-C at this point are the same as contents of the AMF and PP-A right before issuing of Instruction_l (Fig. 13). The system in this state is to complete Instruction_l in the following manner.<br>
As the top one of the eight OQ entries whose contents are shown in Fig. 16 is at the head of the queue at this point, four OQ entries<br><br>
- 42 -<br>
enqueued on the FL. In this case, p51 and p2G - each being a DF-entry address that is eliminated from the stack by the alterations on the CMF and PP-C in the course of completion of the instruction -, and plG, pl8 and p57 -each being a destination-register-field content in the dequeued OQ entries that is not contained in the dequeued SMQ entry - are registered on the FL. Thus, the computer system gets to be in such a state as shown in Fig. 19.<br>
Now, computation of Y=A*X+B/X is concluded in the computer system of this embodiment.<br>
(5) Speculative Execution<br>
Speculative execution based on branch prediction can be incarnated in the computer system of the present invention. Furnishing with an AMF history file is for incarnation of speculative execution. Each time the instruction to be issued includes a conditional branch operation, contents of all the AMF entries and PP-A are supposed to be written into an AMF-historyfile entry. In the following, how speculative execution based on branch prediction goes on in the computer system of this embodiment is described.<br>
In the computer system of this embodiment, in the instruction-issue stage, from in the initialized state and till the first instruction including a conditional branch operation is issued, branch tag "0" is marked on each issued instruction and entered in the BT field of each OQ entry into which substance of an operation included in the instructions is entered.<br>
When the first instruction including a conditional branch<br><br>
- 43 -<br>
operation is issued, to preserve the state at the branch point, contents of all the AMF entries and PP-A are written into the AMF-historyfile entry of address 0. After this, in the course of the instruction flow grounded on the branch prediction, branch tag "1" is marked and entered in BT fields of the OQ.<br>
When the second instruction including a conditional branch operation is issued, in either the case where the first conditional branch is unsettled or the case where it has been settled and the prediction proved right, contents of all the AMF entries and PP-A are written into the AMF-historyfile entry, of address 1. In the course of the instruction flow grounded on the second branch prediction, branch tag "2" is marked and entered in BT fields of the OQ.<br>
If the branch prediction system continues to make a hit, the process is to go on in the same manner, and writing into the AMF history file is to be carried out in the order of address. Besides, after writing into the AMF-historyfile entry of address n, and till the next writing, branch tag n+1 is supposed to be marked on each issued instruction.<br>
In the case where a branch prediction turns out to have missed, all the instructions issued after the one including the conditional branch operation are to be canceled, respectively corresponding contents of the AMF history file that were written when the instruction including the conditional branch operation was issued are to be copied into the AMF entries whose respectively corresponding contents of the FFF are "0" and into PP-A, and the issue process is to be resumed from the instruction at the right place.    Here, in the register mode, the content of each FFF-entry is<br><br>
- 44 -<br>
supposed to be "0". Besides, in canceling all the instructions issued after a certain one, each address of DF entry that has been allocated as destination register in the operations to be canceled is to be put back in the FL, and all the entries in the range that corresponds to the instructions to be canceled are to be dequeued both on the OQ and on the SMQ.<br>
As above, in the computer system of the present invention, as the substance of the AMF at each point when an instruction including a conditional branch operation was issued can be reconstructed by using the AMF history file, speculative execution based on branch prediction is feasible.<br>
(G) Other Embodiments<br>
Computer systems according to the present invention are not confined  to  the  above-mentioned  embodiment.     There  may be  various embodiments   with   different   detailed   structures.      For   example,   the following can be listed. (6-1) Embodiment A<br>
A computer system according to the present invention can be so structured that, with a program that is conformed to the instruction format for a traditional register-based/stack"based processor stored in the instruction cache, the program is to be transformed on the fly right before the instruction-issue stage to conform to the instruction format prescribed in section (2). (6-2) Embodiment B<br>
A computer system according to the present invention can be<br><br>
- 45 -<br>
so structured that, in the course of issue of each instruction, addresses of DF entries to be released from allocation when the instruction is completed or pieces of information for identifying them are entered in the state-modification queue or a specialized queue in advance. (6-3) Embodiment C<br>
Such a computer system can be incarnated, as to be furnished with an advanced and a completed register-type mapping file, an advanced and a completed stack-type mapping file, two push pointers and a bottom pointer, wherein both substance of a modification on register-type mapping file and that on stack-type mapping file and push pointer are to be indicated in the state-modification field of the instruction. In this case, an advanced mapping history file having entries each of which is designed to hold contents of the register-type advanced mapping file, the stack-type advanced mapping file and its push pointer, needs to be provided. (6-4) Embodiment D<br>
Many of the variations such as those conceivable for the register-based superscalar architecture can be applied to the computer system based on the present invention. For example, the following can be listed.<br>
1.	A system implementing the operation window by providing a reservation station at the input of each functional unit, and having a reorder buffer.<br>
2.	A system having a data file, a free list, functional units, etc. for each data type: integer / floating point, 32bit/64bit or the like.<br>
3.	A  system  having  a plurality of sets  each  comprising  an  advanced<br><br>
-- 
mapping file, a completed mapping file and a fill-flag file, and being so structured as to change sets in each context switching. 4. A system having a plurality of sets each comprising an advanced mapping file, a completed mapping file, a fill-flag file, a state-modification queue, etc., and being so structured as to be able to process a plurality of threads in parallel.<br>
INDUSTRIAL UTILITY<br>
According to the present invention, high-performance computer systems can be materialized. Besides, programs described in any machine language for traditional register-based/stack-based processors can be easily transformed to conform to the instruction format for the computer system of the present invention.<br><br>
- 47-<br>
WHAT  IS CLAIMED IS:<br>
1.	A computer system comprising-"<br>
a data file having entries each of which is designed to hold data;<br>
an advanced mapping file and a completed mapping file each having entries each of which is designed to hold an entry address in said data file',<br>
an operation window that is a buffer to hold substances of operations waiting execution;<br>
a state-modification queue that is designed to be able to hold a substance of a modification on said advanced mapping file for each clock cycle; and<br>
functional units for executing operations;<br>
wherein making a modification on said advanced mapping file, entering the substance of said modification into said state-modification queue, and entering substances of operations combined with said modification on said advanced mapping file into said operation window are each to be done in one clock cycle".<br>
each unexecuted operation held in said operation window is to be executed out of order by one of said functional units.' and<br>
after all of the operations combined with the modification on said advanced mapping file specified by the substance of the head part of said state-modification queue are terminated normally, a modification according with said substance of said head part of said state-modification queue is to be made on said completed mapping file, and said head part is to<br><br>
- 48 -<br>
be dequeued from said statcmodification queue.<br>
2.	The computer system according to claim l;<br>
wherein said advanced mapping file and said completed mapping file are each to be accessed by entry addresses.<br>
3.	The computer system according to claim l;<br>
wherein said advanced mapping file and said completed mapping file are each to hold a stack, and to be accessed by displacements from the top of the stack.<br>
Dated   this   21st   day   of   February,   2003.<br>
HIRAL   CHANDRAKANT   JOSHI AGENT   FOR                           SEKI,   HAJIME</c></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtY2FuY2VsbGVkIHBhZ2VzKDIxLTItMjAwMykucGRm" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-cancelled pages(21-2-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtY2xhaW1zKGdyYW50ZWQpLSgxMi03LTIwMDQpLmRvYw==" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-claims(granted)-(12-7-2004).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtY2xhaW1zKGdyYW50ZWQpLSgxMi03LTIwMDQpLnBkZg==" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-claims(granted)-(12-7-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtY29ycmVzcG9uZGVuY2UoMTItNy0yMDA0KS5wZGY=" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-correspondence(12-7-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLU1VTU5QLTIwMDMtQ09SUkVTUE9OREVOQ0UoOS02LTIwMDkpLnBkZg==" target="_blank" style="word-wrap:break-word;">251-MUMNP-2003-CORRESPONDENCE(9-6-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtY29ycmVzcG9uZGVuY2UoaXBvKS0oMTYtMS0yMDA0KS5wZGY=" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-correspondence(ipo)-(16-1-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLU1VTU5QLTIwMDMtQ09SUkVTUE9OREVOQ0UoSVBPKS0oOS02LTIwMDkpLnBkZg==" target="_blank" style="word-wrap:break-word;">251-MUMNP-2003-CORRESPONDENCE(IPO)-(9-6-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtZHJhd2luZygxMi03LTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-drawing(12-7-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtZm9ybSAxOSgzLTEwLTIwMDMpLnBkZg==" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-form 19(3-10-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtZm9ybSAxYSgxMi03LTIwMDQpLnBkZg==" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-form 1a(12-7-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtZm9ybSAxYSgyMS0yLTIwMDMpLnBkZg==" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-form 1a(21-2-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtZm9ybSAyKGdyYW50ZWQpLSgxMi03LTIwMDQpLmRvYw==" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-form 2(granted)-(12-7-2004).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtZm9ybSAyKGdyYW50ZWQpLSgxMi03LTIwMDQpLnBkZg==" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-form 2(granted)-(12-7-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtZm9ybSAzKDEyLTctMjAwNCkucGRm" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-form 3(12-7-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtZm9ybSA1KDEyLTctMjAwNCkucGRm" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-form 5(12-7-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUxLW11bW5wLTIwMDMtZm9ybS1wY3QtaXNhLTIxMCgxMi03LTIwMDMpLnBkZg==" target="_blank" style="word-wrap:break-word;">251-mumnp-2003-form-pct-isa-210(12-7-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="212322-a-computer-system-apparatus-and-mthod-of-monitoring-performance-of-a-multithreaded-processor.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="212325-overrunning-mechanism-adapted-for-a-system-of-stored-energy-motor-operation.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>212324</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>251/MUMNP/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>28-Mar-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>30-Nov-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>21-Feb-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SEKI HAJIME</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>4-38 DOUGO-KITA-MACHI, MATSUYAMA-SHI, EHIME, 790-0848 JAPAN.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>SEKI HAJIME</td>
											<td>4-38, DOUGO KETA-MACHI, MATSUYAMA-SHI, EHIME 790-0848, JAPAN.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 9/38</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/JP01/07442</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2001-08-29</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>2000-263170</td>
									<td>2000-08-31</td>
								    <td>Japan</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/212324-computer-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:39:06 GMT -->
</html>
