<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/233021-a-wireless-communiction-device-and-a-bi-directional-system-and-method-for-sending-and-receiving-operation-codes-between-a-wireless-communication-device-and-a-server-computer by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:28:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 233021:A WIRELESS COMMUNICTION DEVICE AND A BI-DIRECTIONAL SYSTEM AND METHOD FOR SENDING AND RECEIVING OPERATION CODES BETWEEN A WIRELESS COMMUNICATION DEVICE AND A SERVER COMPUTER</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A WIRELESS COMMUNICTION DEVICE AND A BI-DIRECTIONAL SYSTEM AND METHOD FOR SENDING AND RECEIVING OPERATION CODES BETWEEN A WIRELESS COMMUNICATION DEVICE AND A SERVER COMPUTER</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A wireless communication device and a bi-directional system and method for sending and receiving operational codes between a wireless communication device and a server computer are disclosed. The wireless communication device (10) comprises: a library of server operation codes (70); a library of remote operation codes (60); a set of executable instructions (80) and a runtime engine (50). The method for sending and receiving operational codes between a wireless communication device (10) and a server computer (30) comprises: compiling (522) a set of server operation codes from a library of server operational codes (70) within a runtime engine of the wireless communication device; attaching (528) a data payload to the compiled set of server operation codes, wherein the data payload corresponds to the compiled set of server operation codes; sending (530) the compiled set of server operation codes and data payload to the server computer for execution thereon; receiving (500) a set of remote operation codes from the server computer; and executing (510) a set of executable instructions, each executable instruction from this set corresponding to an operation code in the received set of remote operation codes.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>A WIRELESS COMMUNICATION DEVICE AND A BI-<br>
DIRECTIONAL SYSTEM AND METHOD FOR SENDING AND<br>
RECEIVING OPERATIONAL CODES BETWEEN A WIRELESS<br>
COMMUNICATION DEVICE AND A SERVER COMPUTER<br>
Background<br>
1. Field of the Invention<br>
[01] The present invention relates to a wireless communication device and a bi-<br>
directional system and method for sending and receiving operational codes between a<br>
wireless communication device and a server computer and, generally relates to the<br>
filed of wireless communications and more particularly relates to two way<br>
communication of dynamic instruction sets between a handset and a wireless<br>
communication network<br>
2. . Related Art<br>
[02] Conventional wireless communication devices typically become isolated<br>
computing platforms once they are deployed, i.e. sold to a consumer. These conventional<br>
wireless communication devices have extremely limited or no ability to communicate<br>
data such as operational or maintenance data with a parent network. This lack of data<br>
communication ability presents significant challenges for the provider of the wireless<br>
communication device with respect to updating the software that executes on the device<br>
and obtaining operationalor maintenance data from the device. For example, in order to<br>
upgrade the operating system of a cell phone, the consumer must physically bring the<br>
phone into a service center where a technician must plug the phone into a computer in<br>
order to update the phone. The same is true for performing comprehensive or in-depth<br>
diagnostics on a cell phone.<br>
[03] The conventional solutions for updating a wireless communication device or<br>
obtaining inlbrmation from such a device generally require that the device be brought<br>
into a service station where a technician can interact with the device to update its<br>
software programs or obtain data from the device. This is extremely costly for both the<br>
consumer and the provider of the device.<br>
[04] Additionally, conventional methods for updating a wireless communication<br>
device or obtaining information from such a device generally require a hard-wired<br>
connection with the device. This further complicates the updating and maintenance<br>
needs for a wireless communication device, requiring special cables and even requiring<br>
the device itself to have a hard-wired interface. These necessities drive up both the<br>
production and maintenance costs of a wireless communication device while also<br>
decreasing the life span of the device.<br>
[05] Finally, conventional methods for data communication with a wireless<br>
communication device are unidirectional. Conventional networks may have the ability to<br>
provide the wireless communication device with application software and data.<br>
Additionally; conventional wireless communication devices may have the ability to<br>
respond to such communications with limited configuration data and status information.<br>
However, this limited master-slave communication ability found in the conventional<br>
systems suffers from the inability of the wireless communication device to initiate<br>
communications with the network.<br>
[06] Therefore, what is needed is a system and method that overcomes these<br>
significant problems found in the conventional systems as described above.<br>
Summary<br>
[07j Once deployed, conventional wireless communication devices become isolated<br>
computing platforms with extremely limited or no ability to maintain data<br>
communications with a parent network. This lack of data communication ability presents<br>
significant challenges with respect to updating the software that executes on the wireless<br>
communication device and deriving operational data from the device. Additionally,<br>
conventional wireless communication devices lack the ability to initiate requests for<br>
information or software updates that may improve their ability to interact with then-<br>
environment.<br>
[08] The present invention provides systems and methods for bi-directional<br>
communication of dynamic instruction sets between a handset and a wireless<br>
communication network. A dynamic instruction set, e.g. one or more Patch Manager<br>
Run Time Instructions ("PMRTIs"), represents a discrete function or a discrete action<br>
thatlis to be carried out by the recipient device. The wireless communication network can<br>
send a dynamic instruction set to a handset in order to instruct the handset to perform<br>
certain oparitions such as reporting status back to the network. Similarly, the present<br>
invention pnvides for the handset to compile a dynamic instruction set, e.g. one or more<br>
Reverse Patch Manager Run Time Instructions ("RPMRTIs"), and send the instruction<br>
set to the network for execution. This ability allows the handset to provide or request<br>
information, software, or other data that allows the handset to perform desirable<br>
functions.<br>
Brief Description of the Accompanying Drawings<br>
{09] The details of the present invention, both as to its structure and operation, may be<br>
gleaned in part by study of the accompanying drawings, in which like reference numerals<br>
refer to like parts, and in which:<br>
[10] Figure 1 is a schematic block diagram of the overall wireless device software<br>
maintenance system;<br>
[11] Figure 2 is a schematic block diagram of the software maintenance system,<br>
highlighting the installation of instruction sets via the airlink interface;<br>
[12] Figure 3 is a schematic block diagram illustrating the present invention system<br>
for executing dynamic instruction sets in a wireless communications device;<br>
[13] Figure 4 is a schematic block diagram of the wireless device memory;<br>
[14] Figure 5 is a table representing the code section address table of Fig. 3;<br>
[15] Figure 6 is a detailed depiction of symbol library one of Fig. 3, with symbols;<br>
[16] Figure 7 is a table representing the symbol offset address table of Fig. 3;<br>
[17] Figure 8 is a depiction of the operation code ("opcode") being accessed by the<br>
run-time engine;<br>
[18] Figure 9 is a more detailed depiction of the first operation code of Fig. 8;<br>
[19] Figure 10 is a flowchart illustrating the present invention method for<br>
executing dynamic instruction sets in a wireless communications device;<br>
[20] Figure 11 is a flowchart illustrating an exemplary dynamic instruction set<br>
operation;<br>
[21] Figure 12 is a flowchart illustrating another exemplary dynamic instruction set<br>
ope ration;<br>
[22] Figure 13 is a flowchart illustrating a third exemplary dynamic instruction set<br>
ope-ation; ;<br>
[23] Figure 14 is a flowchart illustrating a fourth exemplary dynamic instruction set<br>
operation;<br>
[24] Figure 15 is a flowchart illustrating a fifth exemplary dynamic instruction set<br>
operation;<br>
[25] Figure 16 is a high level network diagram illustrating an example wireless<br>
communication network;<br>
[26] Figure 17A is block diagram illustrating an example wireless communication<br>
device;<br>
[27] Figure 17B is block diagram illustrating an example remote runtime instructions<br>
code section;<br>
[28] Figure 18A is a block diagram illustrating an example PMRTI server;<br>
[29] Figure 18B is a block diagram illustrating an example server runtime instructions<br>
cods section; <br>
[30] Figure 19 is a flow diagram illustrating an example process for executing<br>
dynamic instruction sets on a wireless communication device;<br>
[31] Figure 20 is a flow diagram illustrating an example process for compiling<br>
dynamic instruction sets on a wireless communication device;<br>
[32] Figure 21 is a flow diagram illustrating an example process for executing<br>
dynamic instruction sets on a PMRTI server;<br>
[33] Figure 22 is a flow diagram illustrating an example process for synchronizing<br>
operation code libraries; and<br>
[34] Figure 23 is a block diagram illustrating an exemplary computer system that may<br>
be used in connection with various embodiments described herein.<br>
Detailed Description<br>
[35] Systems and methods for bi-directional communication of dynamic instruction<br>
sets between a wireless communication' device and a wireless communication network<br>
are disclosed. For example, one method as disclosed herein allows for a wireless<br>
communication device to dynamically construct an instruction set and send that<br>
instruction set to the network for execution and processing.<br>
[36] After reading this description it will become apparent to one skilled in the art how<br>
to implement the invention in various alternative embodiments and alternative<br>
applications. However, although various embodiments of the present invention will be<br>
described herein, it is understood that these embodiments are presented by way of<br>
example only, and not limitation. As such, this detailed description of various alternative<br>
embodiments should not be construed to limit the scope or breadth of the present<br>
invention as set forth in the appended claims.<br>
[37] Some portions of the detailed descriptions that follow are presented in terms of<br>
procedures, steps, logic blocks, codes, processing, and other symbolic representations of<br>
operations on data bits within a wireless device microprocessor or memory. These<br>
descriptions and representations are the means used by those skilled in the data<br>
processing arts to most effectively convey the substance of their work to others skilled in<br>
the art. A procedure, microprocessor executed step, application, logic block, process,<br>
etc. is here, and generally, conceived to be a self-consistent sequence of steps or<br>
instructions leading to a desired result. The steps are those requiring physical<br>
manipulations of physical quantities. Usually, though not necessarily, these quantities<br>
take the form of electrical or magnetic signals capable of being stored, transferred,<br>
combined, compared, and otherwise manipulated in a microprocessor based wireless<br>
devibe. It has proven convenient at times, principally for reasons of common usage, to<br>
refer to these, signals as bits, values, elements, symbols, characters, terms, numbers, or the<br>
like. Where physical devices, such as a memory are mentioned, they are connected to<br>
other physical devices through a bus or other electrical connection. These physical<br>
devipes can be considered to interact with logical processes or applications and, therefore,<br>
are "connected" to logical operations. For example, a memory can store or access code<br>
to further a logical operation, or an application can call a code section from memory for<br>
execution.<br>
[38] It should be borne in mind, however, that all of these and similar terms are to be<br>
associated with the appropriate physical quantities and are merely convenient labels<br>
applied to these quantities. Unless specifically stated otherwise as apparent from the<br>
following discussions, it is appreciated that throughout the present invention, discussions<br>
utilizing terms such as "processing" or "connecting" or "translating" or "displaying" or<br>
"prompting" or "determining" or "displaying" or "recognizing" or the like, refer to the<br>
action and processes of in a wireless device microprocessor system that manipulates and<br>
transforms data represented as physical (electronic) quantities within the computer<br>
system's registers and memories into other data similarly represented as physical<br>
quantities within the wireless device memories or registers or other such information<br>
storage, transmission or display devices.<br>
[39] Fig. 1 is a schematic block diagram of the overall wireless device software<br>
maintenance system 100. The present invention system software organization is<br>
presented in detail below, following a general overview of the software maintenance<br>
system 100. The general system 100 describes a process of delivering system software<br>
updates and instruction sets (programs), and installing the delivered software in a<br>
wireless device. System software updates and patch manager run time instructions<br>
(PMRTI), that are more generally known as instruction sets or dynamic instruction sets,<br>
are created by the manufacturer of the handsets. The system software is organized into<br>
symbol libraries. The symbol libraries are arranged into code sections. When symbol<br>
libraries are to be updated, the software update 102 is transported as one or more code<br>
sections. The software update is broadcast to wireless devices in the field, of which<br>
wireless communications device 104 is representative, or transmitted in separate<br>
communications from a base station 106 using well known, conventional air, data or<br>
message transport protocols. The invention is not limited to any particular transportation<br>
format, as the wireless communications device can be easily modified to process any<br>
available over-the-air transport protocol for the purpose of receiving system software and<br>
PMRTI updates.<br>
[40] The system software can be viewed as a collection of different subsystems. Code<br>
objects can tightly coupled into one of these abstract subsystems and the resulting<br>
collection can be labeled as a symbol library. This provides a logical breakdown of the<br>
code base and software patches and fixes can be associated with one of these symbol<br>
libraries. In most cases, a single update is associated with one, or at most two, symbol<br>
libraries. The rest of the code base, the other symbol libraries, remains unchanged.<br>
[41] The notion of symbol libraries provides a mechanism to deal with code and<br>
constants. The read-write (RW) data, on the other hand, fits into a unique individual RW<br>
library that contains RAM based data for all libraries.<br>
[42] Once received by the wireless device 104, the transported code section must be<br>
processed. This wireless device over-writes a specific code section of nonvolatile<br>
memory 108. The nonvolatile memory 108 includes a file system section (FSS) 110 and<br>
a code storage section 112. The code section is typically compressed before transport in<br>
order to minimize occupancy in the FSS 110. Often the updated code section will be<br>
accompanied by its RW data, which is another kind of symbol library that contains all the<br>
RW data for each symbol library. Although loaded in random access volatile read-write<br>
memory 114 when the system software is executing, the RW data always needs to be<br>
stored in the nonvolatile memory 108, so it can be loaded into random access volatile<br>
read-write memory 114 each time the wireless device is reset. This includes the first time<br>
RW data is loaded into random access volatile read-write memory. As explained in more<br>
detail below, the RW data is typically arranged with a patch manager code section.<br>
[43] The system 100 includes the concept of virtual tables. Using such tables, symbol<br>
libraries in one code section can be patched (replaced), without breaking (replacing) other<br>
parts of the system software (other code sections). Virtual tables execute from random<br>
access volatile read-write memory 114 for efficiency purposes. A code section address<br>
table and symbol offset address table are virtual tables.<br>
[44] The updated code sections are received by the wireless device 104 and stored in<br>
the FSS 110. A wireless device user interface (UI) will typically notify the user that new<br>
software is available. ;In response to UI prompts the user acknowledges the notification<br>
and signals the patching or updating operation. Alternately, the updating operation is<br>
performed automatically. The wireless device may be unable to perform standard<br>
communication tasks as the updating process is performed. The patch manager code<br>
section includes a non-volatile read-write driver symbol library that is also loaded into<br>
random access volatile read-write memory 114. The non-volatile read-write driver<br>
symbol library causes code sections to be overwritten with updated code sections. The<br>
patch manager code section includes the read-write data, code section address table, and<br>
symbol offset address table, as well a symbol accessor code and the symbol accessor<br>
cod e address (discussed below). Portions of this data are invalid when updated code<br>
sections are introduced, and an updated patch manager code sections includes read-write<br>
data, a code section address table, and a symbol offset address table valid for the updated<br>
code sections. Once the updated code sections are loaded into the code storage section<br>
112, the wireless device is reset. Following the reset operation, the wireless device can<br>
execute the updated system software. It should also be understood that the patch<br>
manager code section may include other symbol libraries that have not been discussed<br>
above. These other symbol libraries need not be loaded into read-write volatile memory<br>
114.<br>
[45] Fig. 2 is a schematic block diagram of the software maintenance system 100,<br>
highlighting the installation of instruction sets via the airlink interface. In addition to<br>
updating system software code sections, the maintenance system 100 can download and<br>
install dynamic instructions sets, programs, or patch manager instruction sets (PMIS),<br>
referred to herein as patch manager run time instructions (PMRTI). The PMRTI code<br>
section 200 is transported to the wireless device 104 in the same manner as the above-<br>
described system software code sections. PMRTI code sections are initially stored in the<br>
FSS 110. A PMRTI code section is typically a binary file that may be visualized as<br>
compiled instructions to the handset. A PMRTI code section is comprehensive enough to<br>
provide tor the performance of basic mathematical operations and the performance of<br>
conditionally executed operations. For example, an RF calibration PMRTI could perform<br>
the following operations:<br>
IF RF CAL ITEM IS LESS THAN X<br>
EXECUTE INSTRUCTION<br>
ELSE<br>
EXECUTE INSTRUCTION<br>
[46] A PMRTI can support basic mathematical operations, such as: addition,<br>
subtraction, multiplication, and division.1 As with the system software code sections, the<br>
PMRTI code section may be loaded in response to UI prompts, and the wireless device<br>
must be reset after the PMRTI is loaded into code storage section 112. Then the PMRTI<br>
section can be executed. If the PMRTI code section is associated with any virtual tables<br>
or read-write data, an updated patch manager code section will be transported with the<br>
PMRTI for installation in the code storage section 112. Alternately, the PMRTI can be<br>
kept and processed from the FSS 110. After the handset 104 has executed all the<br>
instructions in the PMRTI section, the PMRTI section can be deleted from the FSS 110.<br>
Alternately, the PMRTI is maintained for future operations. For example, the PMRTI<br>
may be executed every time the wireless device is energized.<br>
[47] PMRTI is a very powerful runtime instruction engine. The handset can execute<br>
any instruction delivered to it through the PMRTI environment. This mechanism may be<br>
used to support RF calibrations. More generally, PMRTI can be used to remote debug<br>
wireless device software when software problems are recognized by the manufacturer or<br>
service provider, typically as the result of user complaints. PMRTI can also record data<br>
needed to diagnose software problems. PMRTI can launch newly downloaded system<br>
applications for data analysis, debugging, and fixes. PMRTI can provide RW data based<br>
updates for analysis and possible short term fix to a problem in lieu of an updated system<br>
software code section. PMRTI can provide memory compaction algorithms for use by<br>
the wireless device.<br>
[48] In some aspects of the invention, the organization of the system software into<br>
symbol libraries may impact the size of the volatile memory 114 and nonvolatile memory<br>
108 required for execution. This is due to the fact that the code sections are typically<br>
larger than the symbol libraries arranged in the code sections. These larger code sections<br>
exist to accommodate updated code sections. Organizing the system software as a<br>
collection of libraries impacts the nonvolatile memory size requirement. For the same<br>
code size, the amount of nonvolatile memory used will be higher due to the fact that code<br>
sections can be sized to be larger than the symbol libraries arranged within.<br>
[49] Once software updates have been delivered to the wireless device, the software<br>
maintenance system 100 supports memory compaction. Memory compaction is similar<br>
to disk de-fragmentation applications in desktop computers. The compaction mechanism<br>
ensures that memory is optimally used and is well balanced for future code section<br>
updates, where the size of the updated code sections are unpredictable. The system 100<br>
analyzes the code storage section as it is being patched (updated). The system 100<br>
attempts to fit updated code sections into the memory space occupied by the code section<br>
being replaced. If the updated code section is larger than the code section being replaced,<br>
the system 100 compacts the code sections in memory 112. Alternately, the compaction<br>
can be calculated by the manufacturer or service provider, and compaction instructions<br>
can be transported to the wireless device 104.<br>
[50] Compaction can be a time consuming process owing to the complexity of the<br>
algorithm and also the vast volume of data movement. The compaction algorithm<br>
predicts feasibility before it begins any processing. UI prompts can be used to apply for<br>
permission from the user before the compaction is attempted.<br>
[51] In some aspects of the invention, all the system software code sections can be<br>
updated simultaneously. A complete system software upgrade, however, would require a<br>
larger FSS 110.<br>
[52] Fig. 3 is a schematic block diagram illustrating the present invention dynamic<br>
instruction set execution in a wireless communications device. The system 300<br>
comprises a code storage section 112 in memory 108 including executable wireless<br>
device system software differentiated into a plurality of current code sections. Code<br>
section one (302), code section two (304), code section n (306), and a patch manager<br>
code section 308 are shown. However, the invention is not limited to any particular<br>
number of code sections. Further, the system 300 further comprises a first plurality of<br>
symbol libraries arranged into the second plurality of code sections. Shown are symbol<br>
library one (310) arranged in code section one (302), symbol libraries two (312) and three<br>
(314) arranged in code section two (304), and symbol library m (316) arranged in code<br>
section n (306). Each library comprises symbols having related functionality. For<br>
example, symbol library one (310) may be involved in the operation of the wireless<br>
device liquid crystal display (LCD). Then, the symbols would be associated with display<br>
functions. As explained in detail below, additional symbol libraries are arranged in the<br>
patch manger code section 308.<br>
[53] Fig. 4 is a schematic block diagram of the wireless device memory. As shown,<br>
the memory is the code storage section 112 of Fig. 1. The memory is a writeable,<br>
nonvolatile memory, such as Flash memory. It should be understood that the code<br>
sections need not necessarily be stored in the same memory as the FSS 110. It should<br>
also be understood that the present invention system software structure could be enabled<br>
with code sections stored in a plurality of cooperating memories. The code storage<br>
section 112 includes a second plurality of contiguously addressed memory blocks, where<br>
each memory block stores a corresponding code section from the second plurality of code<br>
sections. Thus, code section one (302) is stored in a first memory block 400, code<br>
section two (304) in the second memory block 402, code section n (306) in the nth<br>
memory block 404, and the patch, manager code section (308) in the pth memory block<br>
406.<br>
[54] Contrasting Figs. 3 and 4, the start of each code section is stored at corresponding<br>
start addressees in memory, and symbol libraries are arranged to start at the start of code<br>
sectons. That is, each symbol library begins at a first address and runs through a range<br>
of addresses in sequence from the first address. For example, code section one (302)<br>
starts at the first start address 408 (marked with "S") in code storage section memory 112.<br>
In Fig. 3, symbol library one (310) starts at the start 318 of the first code section.<br>
Likewise code section two (304) starts at a second start address 410 (Fig. 4), and symbol<br>
library two starts at the start 320 of code section two (Fig. 3). Code section n (306) starts<br>
at a third start address 412 in code storage section memory 112 (Fig. 4), and symbol<br>
library m (316) starts at the start of code section n 322 (Fig. 3). The patch manager code<br>
section starts at pth start address 414 in code storage section memory 112, and the first<br>
symbol library in the patch manager code section 308 starts at the start 324 of the patch<br>
manager code section. Thus, symbol library one (310) is ultimately stored in the first<br>
memory block 400. If a code section includes a plurality of symbol libraries, such as<br>
code section two (304), the plurality of symbol libraries are stored in the corresponding<br>
memory block, in this case the second memory block 402.<br>
[55] In Fig. 3, the system 300 further comprises a code section address table 326 as a<br>
type of symbol included in a symbol library arranged inthe patch manager code section<br>
308. The code section address table cross-references code section identifiers with<br>
corresponding code section start addresses in memory.<br>
[56] Fig. 5 is a table representing the code section address table 326 of Fig. 3. The<br>
code section address table 326 is consulted to find the code section start address for a<br>
symbol library. For example, the system 300 seeks code section one when a symbol in<br>
symbol library one is required for execution. To find the start address of code section<br>
one, and therefore locate the symbol in symbol library one, the code section address table<br>
326 is consulted. The arrangement of symbol libraries in code sections, and the tracking<br>
of code sections with a table permits the code sections to be moved or expanded. The<br>
expansion or movement operations may be needed to install upgraded code sections (with<br>
upgraded symbol libraries).<br>
[57] Returning to Fig. 3, it should be noted that not every symbol library necessarily<br>
starts at the start of a code section. As shown, symbol library three (314) is arranged in<br>
code section two (304), but does not start of the code section start address 320. Thus, if a<br>
symbol in symbol library three (314) is required for execution, the system 300 consults<br>
the code section address table 326 for the start address of code section two (304). As<br>
explained below, a symbol offset address table permits the symbols in symbol library<br>
three (314) to be located. It does not matter that the symbols are spread across multiple<br>
libraries, as long as they are retained with the same code section.<br>
[58] As noted above, each symbol library includes functionally related symbols. A<br>
symbol is a programmer-defined name for locating and using a routine body, variable, or<br>
data structure. Thus, a symbol can be an address or a value. Symbols can be internal or<br>
external. Internal symbols are not visible beyond the scope of the current code section.<br>
More specifically, they are not sought by other symbol libraries, in other code sections.<br>
External symbols are used and invoked across code sections and are sought by libraries in<br>
different code sections. The symbol offset address table typically includes a list of all<br>
external symbols.<br>
[59] For example, symbol library one (310) may generate characters on a wireless<br>
device display. Symbols in this library would, in turn, generate telephone numbers,<br>
names, the time, or other display features. Each feature is generated with routines,<br>
referred to herein as a symbol. For example, one symbol in symbol library one (310)<br>
generates telephone numbers on the display. This symbol is represented by an "X", and<br>
is external.' When the! wireless device receives a phone call and the caller ID service is<br>
activated, the system must execute the "X" symbol to generate the number on the display.<br>
Therefore, the system must locate the "X" symbol.<br>
(60] Fig. 6 is a detailed depiction of symbol library one (310) of Fig. 3, with symbols.<br>
Symbols are arranged to be offset from respective code section start addresses. In many<br>
circumstances, the start of the symbol library is the start of a code section, but this is not<br>
true if a code section includes more than one symbol library. Symbol library one (310)<br>
starts at the start of code section one (see Fig. 3). As shown in Fig. 6, the "X" symbol is<br>
located at an offset of (03) from the start of the symbol library and the "Y" symbol is<br>
located at an offset of (15). The symbol offset addresses are stored in a symbol offset<br>
address table 328 in the patch manager code section (see Fig. 3).<br>
[61] Fig. 7 is a table representing the symbol offset address table 328 of Fig. 3. The<br>
symbol offset address, table 328 cross-references symbol identifiers with corresponding<br>
offset addresses, and with corresponding code section identifiers in memory. Thus, when<br>
the system seeks to execute the "X" symbol in symbol library one, the symbol offset<br>
address table 328 is consulted to locate the exact address of the symbol, with respect to<br>
the code section in which it is arranged.<br>
[62] Returning to Fig. 3, the first plurality of symbol libraries typically all include<br>
read-write data that must be consulted or set in the execution of these symbol libraries.<br>
For example, a symbol library may include an operation dependent upon a conditional<br>
statement. The read-write data section is consulted to determine the status required to<br>
complete the conditional statement. The present invention groups the read-write data<br>
from all the symbol libraries into a shared read-write section. In some aspects of the<br>
invention, the read-write data 330 is arranged in the patch manager code section 308.<br>
Altemately (not shown), the read-write data can be arranged in a different code section,<br>
code section n (306), for example.<br>
[63] The first plurality of symbol libraries also includes symbol accessor code<br>
arranged in a code section to calculate the address of a sought symbol. The symbol<br>
accessor code can be arranged and stored at an address in a separate code section, code<br>
section two (304), for example. However, as shown, the symbol accessor code 332 is<br>
arranged and stored at an address in the patch manager code section 308. The system 300<br>
further comprises a first location for storage of the symbol accessor code address. The<br>
first location can be a code section in the code storage section 112, or in a separate<br>
memory section of the wireless device (not shown). The first location can also be<br>
arranged in the same code section as the read-write data. As shown, the first location 334<br>
is stored in the patch manager code section 308 with the read-write data 330, the symbol<br>
offset address table 328, the code section address table 326, and the symbol accessor code<br>
332, and the patch library (patch symbol library) 336.<br>
[64] The symbol accessor, code accesses the code section address table and symbol<br>
offset address tables to calculate, or find the address of a sought symbol in memory. That<br>
is, the symbol accessor code calculates the address of the sought symbol using a<br>
corresponding symbol identifier and a corresponding code section identifier. For<br>
example, if the "X" symbol in symbol library one is sought, the symbol accessor is<br>
invoked to seek the symbol identifier (symbol ID) "X l", corresponding to the "X"<br>
symbol (see Fig. 7). The symbol accessor code consults the symbol offset address table<br>
to determine that the "X_l" symbol identifier has an offset of (03) from the start of code<br>
section one (see Fig. 6). The symbol accessor code is invoked to seek the code section<br>
identifier "CS_1", corresponding to code section one. The symbol accessor code consults<br>
the code section address table to determine the start address associated with code section<br>
identifier (code section ED) "CS_1". In this manner, the symbol accessor code<br>
determines that the symbol identifier "X_l" is offset (03) from the address of (00100), or<br>
is located at address (00103).<br>
[65] The symbol "X" is a reserved name since it is a part of the actual code. In other<br>
words, it has an absolute data associated with it. The data may be an address or a value.<br>
The symbol identifier is an alias created to track the symbol. The symbol offset address<br>
table and the code section address table both work with identifiers to avoid confusion<br>
with reserved symbol and code section names. It is also possible that the same symbol<br>
name is used across many symbol libraries. The use of identifiers prevents confusion<br>
between these symbols.<br>
[66] Returning to Fig. 1, the system 300. further comprises a read-write volatile<br>
memory 114, typically random access memory (RAM). The read-write data 330, code<br>
section address table 326, the symbol offset address table 328, the symbol accessor code<br>
332, and the symbol accessor code address 334 are loaded into the read-write volatile<br>
memory 114 from the patch manager code section for access during execution of the<br>
system software. As is well known, the access times for code stored in RAM is<br>
significantly less than the access to a nonvolatile memory such as Flash.<br>
[67] Returning to Fig. 3, it can be noted that the symbol libraries need not necessarily<br>
fill the code sections into which they are arranged, although the memory blocks are sized<br>
to exactly accommodate the corresponding code sections stored within. Alternately<br>
stated, each of the second plurality of code sections has a size in bytes that accommodates<br>
the arranged symbol libraries, and each of the contiguously addressed memory blocks<br>
have a size in bytes that accommodates corresponding code sections. For example, code<br>
section one (302) may be a 100 byte section to accommodate a symbol library having a<br>
length of 100 bytes. The first memory block would be 100 bytes to match the byte size<br>
of code section one. However, the symbol library loaded into code section 1 may be<br>
smaller than 100 bytes. As shown in Fig. 3., code section one (302) has an unused section<br>
340, as symbol library one (310) is less than 100 bytes. Thus, each of the second<br>
plurality of code sections may have a size larger than the size needed to accommodate the<br>
arranged symbol libraries. By "oversizing" the code sections, larger updated symbol<br>
libraries can be accommodated.<br>
[68] Contiguously addressed memory blocks refers to partitioning the physical<br>
memory space into logical blocks of variable size. Code sections and memory blocks are<br>
terms that are essentially interchangeable when the code section is stored in memory.<br>
The concept of a code section is used to identify a section of code that is perhaps larger<br>
than the symbol library, or the collection of symbol libraries in the code section as it is<br>
moved and manipulated,<br>
[69] As seen in Fig. 3, the system 300 includes a patch symbol library, which will be<br>
referred to herein as patch library 336, to arrange new code sections in the code storage<br>
section with the current code sections. The arrangement of new code sections with<br>
current code sections in the code storage section forms updated executable system<br>
software. The patch manager 336 not only arranges new code sections in with the current<br>
code sections, it also replaces code sections with updated code sections.<br>
[70] Returning to Fig. 4, the file system section 110 of memory 108 receives new code<br>
sections, such as new code section 450 and updated patch manager code section 452.<br>
The file system section also receives a first patch manager run time instruction (PMRTI)<br>
454 including instructions for arranging the new code sections with the current code<br>
sections. As seen in Fig. 1, an airlink interface 150 receives new, or updated code<br>
sections, as well as the first PMRTI. Although the airlink interface 150 is being<br>
represented by an antenna, it should be understood that the airlink interface would also<br>
include an RF transceiver, baseband circuitry, and demodulation circuitry (not shown).<br>
The file system section 110 stores the new code sections received via the airlink interface<br>
150. The patch library 336, executing from read-write volatile memory 114, replaces a<br>
first code section in the code storage section, code section n (306) for example, with the<br>
new, or updated code section 450, in response to the first PMRTI 454. Typically, the<br>
patch manager code section 308 is replaced with the updated patch manager code section<br>
452. When code sections are being replaced, the patch library 336 over-writes the first<br>
code section, code section n (306) for example, in the code storage section 112 with the<br>
updated code sections, code section 450 for example, in the file system section 110. In<br>
the extreme case, all the code sections in code storage section 112 are replaced with<br>
updated code sections. That is, the FSS 110 receives a second plurality of updated code<br>
sections (not shown), and the patch library 336 replaces the second plurality of code<br>
sections in the code storage section 112 with the second plurality of updated code<br>
sections. Of course, the FSS 110 must be large enough to accommodate the second<br>
plirality off updated code sections received via the airlink interface.<br>
[71] As noted above, the updated code sections being received may include read-write<br>
data code sections, code section address table code sections, symbol libraries, symbol<br>
offset address table code sections, symbol accessor code sections, or a code section with a<br>
new patch library. All these code sections, with their associated symbol libraries and<br>
symbols, may be stored as distinct and independent code sections. Then each of these<br>
code sections would be replaced with a unique updated code section. That is, an updated<br>
read-write code section would be received and would replace the read-write code section<br>
in the code storage section. An updated code section address table code section would be<br>
received and would replace the code section address table code section in the code<br>
storage section. An updated symbol offset address table code section would be received<br>
and would replace the symbol offset address table code section in the code storage<br>
sec ion. An updated symbol accessor code section would be received and would replace<br>
the symbol 'accessor code section in the code storage section. Likewise,, an updated patch<br>
manager code section (with a patch library) would be received and would replace the<br>
patch manager code section in the code storage section.<br>
[72] However, the above-mentioned code sections are typically bundled together in the<br>
â€¢ patch manager code section. Thus, the read-write code section in the code storage section<br>
is replaced with the updated read-write code section from the file system section 110<br>
when the p atch manager code section 308 is replaced with the updated patch manger code<br>
section 450. Likewise, the code section address table, the symbol offset address table, the<br>
symbol accessor code sections, as well as the patch library are replaced when the updated<br>
patch manager code section 450 is installed. The arrangement of the new read-write data,<br>
the new code section address table, the new symbol offset address table, the new symbol<br>
accessor code, and the new patch library as the updated patch manager code section 450,<br>
together with the current code sections in the code storage section, forms updated<br>
executable system software.<br>
[73] When the file system section 110 receives an updated symbol accessor code<br>
address, the patch manager replaces the symbol accessor code address in the first location<br>
in memory with updated symbol accessor code address. As noted above, the first<br>
location in memory 334 is typically in the patch manager code section (see Fig. 3).<br>
[74] As seen in Fig. 3, the patch library 308 is also includes a compactor, or a<br>
compactor symbol library 342. The compactor 342 can also be enabled as a distinct and<br>
independent code section, however as noted above, it is useful and efficient to bundle the<br>
functions associated with system software upgrades into a single patch manager code<br>
section. Generally, the compactor 342 can be said to resize code sections, so that new<br>
sections can be arranged with current code sections in the code storage section 112.<br>
[75] With the organization, downloading, and compaction aspects of the invention now<br>
established, the following discussion will center on the wireless communications device<br>
dynamic instruction set execution system 300. The system 300 comprises executable<br>
system software and system data differentiated into code sections, as discussed in great<br>
detail, above. Further, the system 300 comprises dynamic instruction sets for operating<br>
on the system data and the system software, and controlling the execution of the system<br>
software. As seen in Fig. 4, a dynamic instruction set 470 is organized into the first<br>
PMRTI 454. As seen in Fig. 3, the system also comprises a run-time engine for<br>
processing the dynamic instruction sets, enabled as run-time library 370. As with the<br>
compactor library 342 and patch library 336 mentioned above, the run-time library 370 is<br>
typically located in the patch manager code section 308. However, the run-time library<br>
370 could alternately be located in another code section, for example the first code<br>
section 304.<br>
[76] The dynamic instruction sets are a single, or multiple sets of instructions that<br>
include conditional operation code, and generally include data items. The run-time<br>
engine reads the operation code and determines what operations need to be performed.<br>
Operation code can be conditional, mathematical, procedural, or logical. The run-time<br>
engine, or run-time library 370 processes the dynamic instruction sets to perform<br>
operations such as mathematical or logical operations. That is, the run-time engine reads<br>
the dynamic linstruction set 470 and performs a sequence of operations in response to the<br>
operation code. Although the dynamic instruction sets are not limited to any particular<br>
language, the operation code is typically a form of machine code, as the wireless device<br>
memory is limited and execution speed is important. The operation code is considered<br>
conditional in that it analyzes a data item and makes a decision as a result of the analysis.<br>
The run-time"engine may also determine that an operation be performed on data before it<br>
is analyzed.<br>
[77] For example, the operation code may specify that a data item from a wireless<br>
device memory be compared to a predetermined value. If the data item is less than the<br>
predetermined value, the data item is left alone, and if the data item is greater than the<br>
predetermined value, it is replaced with the predetermined value. Alternately, the<br>
operation code may add a second predetermined value to a data item from the wireless<br>
device memory, before the above-mentioned comparison operation is performed.<br>
[78] As mentioned above, the file system section nonvolatile memory 110 receives the<br>
dynamic instruction sets through an interface such as the airlink 150. As shown in Fig. 1,<br>
the interface can also be radio frequency (RF) hardline 160. Then, the PMRTI can be<br>
received by the FSS 110 without the system software being operational, such as in a<br>
factory calibration environment. The PMRTI can also be received via a logic port<br><br>
interface 162 or an installable memory module 164. The memory module 164 can be<br>
installed in the wireless device 104 at initial calibration, installed in the field, or installed<br>
during factory recalibration. Although not specially shown, the PMRTI can be received<br>
via an infrared or Bluetooth interfaces.<br>
[79] Fig. 8 is a depiction of instructions being accessed by the run-time engine 370.<br>
Shown is a first instruction 800, a second instruction 802, and a jth instruction 804,<br>
however, the dynamic instruction set is not limited to any particular number of<br>
instructions. The length of the operation code in each instruction is fixed. The run-time<br>
engine 370 captures the length of the instruction, as a measure of bytes or bits, determine<br>
if the instruction includes data items. The remaining length of the instruction, after the<br>
operation code is subtracted, includes the data items. The run-time engine extracts the<br>
data items from the instruction. As shown, the length 806 of the first instruction 800 is<br>
measured and data items 808 are extracted. Note that not all instructions necessary<br>
include data items to be extracted. The run-time engine 370 uses the extracted data 808<br>
in, performing the sequence of operations responsive to the operation code 810 in<br>
instruction 800.<br>
[80] Fig. 9 is a more detailed depiction of the first instruction 800 of Fig. 8. Using the<br>
first instruction 800 as an example, the instruction includes operation code 810 and data<br>
808. The instruction, and more specifically, the data item section 808 includes symbol<br>
identifiers,! which act! as a link to symbols in the wireless device code sections. As<br>
explained in detail above, the symbol identifiers are used with the code section address<br>
table 326 (see Fig. 5) and the symbol offset address table 328 (see Fig. 7) to locate the<br>
symbol corresponding to the symbol identifier. As shown, a symbol identifier "X_l" is<br>
shown in the first instruction 800. The symbol offset address table 328 locates the<br>
corresponding symbol in a code section with the "CS_1" identifier and an offset of "3".<br>
The code section address table 326 gives the start address of code section one (302). In<br>
this manner, the symbol "X" is found (see Fig. 6).<br>
[81] After the run-time engine locates symbols corresponding to the received symbol<br>
identifiers using the code section address table and symbol offset address table, it extracts<br>
data when (the located symbols are data items. For example, if the symbol "X" is a data<br>
ite:n in symbol library one (310), the run-time engine extracts it. Alternately, the "X"<br>
symbol can! be operation code, and the run-time engine executes the symbol "X" when it<br>
is located.<br>
[82] PMRTI can be used to update system data, or system data items. In some aspects<br>
of jthe invention system data is stored in a code section in the file system section 110,<br>
code section 472 for example, see Fig. 4. The run-time engine accesses system data from<br>
code section 472 and analyzes the system data. The run-time engine processes the<br>
operation code of the dynamic instruction sets to perform mathematical or logical<br>
operation on data items, as described above. After the operation, the run-time engine<br>
processes the instructions to create updated system data. Note that the updated system<br>
data may include unchanged data items in some circumstances. The system data in the<br>
second code section 472 is replaced with the updated system data in response to the<br>
operation code. Thus, by the processing of instruction by the run-time engine, the system<br>
sof ware is controlled 'to execute using the updated system data in code section 472. In<br>
this manner, specifically targeted symbols in the system software can be updated, without<br>
replacing entire code sections. By the same process, the system data can be replaced in a<br>
code section in the code storage section 112. For example, the system data can be stored<br>
in the third code section 344, and the run-time engine can replace the system data in the<br>
third code section with updated system data in response to the operation code.<br>
[83] PMRTI can also be used to update data items in volatile memory 114. As an<br>
example, the volatile memory 114 accept read-write data 330, see Fig. 1. The read-write<br>
data can be from one, or from a plurality of code sections in the code storage section 112<br>
and/or the FSS 110. The run-time engine accesses the read-write data, analyzes the read-<br>
write data 330, creates updated read-write data, and replaces the read-write data 330 in<br>
the volatile memory 114 with the updated read-write data in response to the operation<br>
cod;. Then, the system software is controlled to execute using the updated read-write<br>
data in volatile memory 114.<br>
(84] In some aspects of the invention, the run-time engine monitors the execution of<br>
the'system software, Performance monitoring is broadly defined to include a great<br>
number of wireless device activities. For example, data such as channel parameters,<br>
channel characteristics, system stack, error conditions, or a record of data items in RAM<br>
through a sequence of operations leading to a specific failure condition or reduced<br>
performance condition can be collected. It is also possible to use dynamic instructions<br>
sets to analyze collected performance data, provide updated data variants, and recapture<br>
data. to study possible solutions to the problem. Temporary fixes can also be provisioned<br>
usir.g PMRTI processes.<br>
[85] Mors specifically, the run-time engine collects performance data, and stores the<br>
performance data in the file system section in response to the operation code. Then, the<br>
system software is controlled to execute by collecting the performance data for evaluation<br>
of the system software. Evaluation can occur as a form of analysis performed by<br>
dynamic instruction set operation code, or it can be performed outside the wireless<br>
device. In some aspects of the invention, the run-time engine accesses the performance<br>
data that has been collected from the file system section and transmits the performance<br>
data via an airlink interface in response to the operation code. Collecting performance<br>
data from wireless devices in the field permits a manufacturer to thoroughly analyze<br>
problems, either locally or globally, without recalling the devices.<br>
[861 In some aspects of the invention, file system section 110 receives a patch manager<br>
run time instruction including a new code section. For example, a new code section 474<br>
is shown in Fig. 4. Alternately, the new code section can be independent of the PMRTI,<br>
such as new code section n (450). For example, the new code section n (450) may have<br>
been received in earlier airlink communications, or have been installed during factory<br>
calibration. The run-time engine adds the new code section 474 (450) to the code storage<br>
section in response to the operation code. In some aspects of the invention, the new code<br>
section is added to an unused block in the code storage section 112. Alternately, a<br>
compaction operation is required. Then, the system software is controlled to execute<br>
using the new code section 474 (450). In other aspects of the invention, the PMRTI 454<br>
includes an updated code section 474. Alternately, the new code section 450 is an<br>
updated code section independent of the PMRTI. The run-time engine replaces a code<br>
section in the code storage section, code section two (304) for an example, with the<br>
updated code section 474 (450) in response to the operation code. The system software is<br>
controlled to execute using the updated code section 474 (450). In some aspects of the<br>
invention al compaction operation is required to accommodate the updated code section.<br>
Alternately, the updated code section is added to an unused or vacant section of the code<br>
storage section.<br>
[87] As explained above, the addition of a new code section or the updating of a code<br>
section typically requires the generation of a new code section address table, as these<br>
operation involve either new and/or changed code section start addresses. Further, a<br>
compaction operation also requires a new code section address table. The compaction<br>
operations may be a result of the operation of the compactor 342, explained above, or the<br>
result of PMRTI instructions that supply details as to how the compaction is to occur.<br>
When the 'PMRTI includes downloading and compaction instructions, the PMRTI<br>
typically also includes a new code section address table that becomes valid after the<br>
downloading and compaction operations have been completed.<br>
[88] Figs.j 10a and 10b are flowcharts illustrating the present invention method for<br>
executing dynamic instruction sets in a wireless communications device. Although<br>
depicted as a sequence of numbered steps for clarity, no order should be inferred from the<br>
numbering (and the numbering in the methods presented below) unless explicitly stated.<br>
The method starts at Step 1000. Step 1001a forms the system software into symbol<br>
libraries, each symbol library comprising symbols having related functionality. Step<br>
1001b arranges the symbol libraries into code sections. Step 1002 executes system<br>
software. Step 1003 receives the dynamic instruction sets. Receiving the dynamic<br>
instruction sets in Step 1003 includes receiving the dynamic instruction sets through an<br>
interface selected from the group including airlink, radio frequenqy (RF) hardline,<br>
installable memory module, infrared, and logic port interfaces. In some aspects of the<br>
invention, receiving the dynamic instruction set in Step 1003 includes receiving a patch<br>
manager run time instruction (PMRTI) in a file system section nonvolatile memory.<br>
[89] Step 1004 launches a run-time engine. Typically, launching a run-time engine<br>
includes invoking- a run-time library from a first code section. The run-time engine can<br>
be launched from either volatile or nonvolatile memory. Step 1006 processes dynamic<br>
instruction sets. Processing dynamic instruction sets includes processing instructions in<br>
response to mathematical and logical operations. In some aspects of the invention, Step<br>
1007 (not shown), following the processing of the dynamic instruction sets, deletes<br>
dynamic instruction sets. Step 1008 operates on system data and system software. Step<br>
1010, in response to operating on the system data and system software, controls the<br>
execution of the system software.<br>
[9C] Typically, receiving the patch manager run time instructions in Step 1003<br>
includes receiving conditional operation code and data items. Then, processing dynamic<br>
instruction sets in Step 1006 includes substeps. Step 1006al uses the run-time engine to<br>
read the patch manager run time instruction operation code. Step 1006b performs a<br>
sequence of operations in response to the operation code.<br>
[91] In some aspects, arranging the symbol libraries into code sections in Step 1001b -<br>
includes starting symbol libraries at the start of code sections and arranging symbols to be<br>
offset from their respective code section start addresses. Then the method comprises<br>
further steps. Step 1001c stores the start of code sections at corresponding start<br>
addresses. Step 1001d maintains a code section address table (CSAT) cross-referencing<br>
code section identifiers with corresponding start addresses. Step 1OO1e maintains a<br>
symbol offset address table (SOAT) cross-referencing symbol identifiers with<br>
corresponding offset addresses, and corresponding code section identifiers.<br>
[92] In some aspects of the invention, receiving the patch manager run time instruction<br>
in Step 1003 includes receiving symbol identifiers. Then, the method comprises a further<br>
step. Step 1006a2 locates symbols corresponding to the received symbol identifiers by<br>
using the code section address table and symbol offset address table. Performing a<br>
sequence of operations in response to the operation code in Step 1006b includes substeps.<br>
Step 1006bl extracts the data when the located symbols are data items. Step 1006b2<br>
executes the symbols when the located symbols are instructions.<br>
[93] In some aspects of the invention, processing dynamic instruction sets in Step<br>
1006bl includes additional substeps. Step 1006bla uses the run-time engine to capture<br>
the length of the patch manager run time instruction. Step 1006blb extracts the data<br>
items from the patch manager run time instruction, in response to the operation code.<br>
Step 1006blc uses the extracted data in performing the sequence of operations responsive<br>
to the operation code.<br>
[94] Fig. 11 is a flowchart illustrating an exemplary dynamic instruction set operation.<br>
Several of the Steps in Fig. 11 are the same as in Fig. 10, and are not repeated here in the<br>
interest of brevity. Processing dynamic instruction sets in Step 1106 includes substeps.<br>
Step 1106a accesses system data stored in a second code section in the file system<br>
section. Step 1106b analyzes the system data. Step 1106c creates updated system data.<br>
Then, operating on system data and system software in Step 1108 includes replacing the<br>
system data in the second section with the updated system data, and controlling the<br>
execution of the system software in Step 1010 includes using the updated system data in<br>
the execution.of the system software.<br>
[95] Fig.12 is a flowchart illustrating another exemplary dynamic instruction set<br>
operation. Several of the Steps in Fig. 12 are the same as in Fig. 10, and are not repeated<br>
here in the interest of brevity. Step 1201c stores a plurality of code sections in a code<br>
storage section nonvolatile memory. Processing dynamic instruction sets in Step 1206<br>
includes substeps. Step 1206a accesses system data stored in a third code section in the<br>
code storage section (CSS). Step 1206b analyzes the system data. Step 1206c creates<br>
updated system data. Operating on the system data and system software in Step 1208<br>
includes replacing the system data in the third code section with the updated system data.<br>
Controlling the execution of the system software in Step 1210 includes using the updated<br>
system data in the execution of the system software.<br>
[96] Fig. 13 is a flowchart illustrating a third exemplary dynamic instruction set<br>
operation. Several of the Steps in Fig. 13 are the same as in Fig. 10, and are not repeated<br>
here in the interest of brevity. Step 1301c stores a plurality of code sections in a code<br>
storage section nonvolatile memory. Step 1301d loads read-write data into volatile<br>
memory. Processing dynamic instruction sets in Step 1306 includes substeps. Step<br>
1306a accesses the read-write data in volatile memory. Step 1306b analyzes the read-<br>
write data. Step 1306c creates updated read-write data. Operating on the system data<br>
and system software in Step 1308 includes replacing the read-write data in volatile<br>
memory with the updated read-write data. Controlling the execution of the system<br>
software includes using the updated read-write data in the execution of the system<br>
software.<br>
[97] Fig. 14 is a flowchart illustrating a fourth exemplary dynamic instruction set<br>
operation. Several of the Steps in Fig. 14 are the same as in Fig. 10, and are not repeated<br>
here in the interest of brevity. Processing dynamic instruction sets includes substeps.<br>
Step 1406a, in response to the operation code, monitors the execution of the system<br>
software. S;tep 1406b collects performance data. Step 1406c stores the performance data.<br>
Step 1406d transmits the stored data via an airlink interface. Operating on the system<br>
data and system software in Step 1408 includes using the performance data in the<br>
evaluation of system software. <br>
[98] Fig. 15 is a flowchart illustrating a fifth exemplary dynamic instruction set<br>
operation. Several of the Steps in Fig. 15 are the same as in Fig. 10, and are not repeated<br>
here in the interest of brevity. Step 1501c stores a plurality of code sections in a code<br>
storage section nonvolatile memory. Receiving patch manager run time instructions in<br>
Step 1503 includes receiving a new code section. Operating on the system data and<br>
system software in Step 1508 includes adding the new code section to the code storage<br>
section, and controlling the execution of the system software in Step 1510 includes using<br>
the new code section in the execution of the system software.<br>
[99] Alternately, receiving a new code section in Step 1503 includes receiving an<br>
updated code section. Then, operating on the system data and system software in Step<br>
1508 includes replacing a fourth code section in the code storage section with the updated<br>
code section.<br>
[100] A system and method have been provided for executing dynamic instruction sets<br>
in a wireless communications device, so as to aid in the process of updating the software<br>
and monitoring the performance of the software. The system is easily updateable because<br>
of the arrangement of symbol libraries in code sections, with tables to access the start<br>
addresses of the code sections in memory and the offset addresses of symbols in the<br>
symbol libraries. The use on dynamic instruction sets permits custom modifications to be<br>
performed to each wireless device, based upon specific characteristics of that device. A<br>
few general examples have been given illustrating possible uses for the dynamic<br>
instructions sets. However, the present invention is not limited to just these examples.<br>
Other variations and embodiments of the invention will occur to those skilled in the art.<br>
[101] Fig. 16 is a high level network diagram illustrating an example wireless/<br>
communication network. The illustrated wireless communication network comprises a<br>
plurality of wireless communication devices 10, 12, and 14; a plurality of base stations 20<br>
and 22; and a PMRTI server 30 that is connected to the wireless communication devices j<br>
10, 12, and 14 via a network 40.<br>
[102] Wireless communication device 10 can be any sort of device with the ability to<br>
communicate, within the wireless communication network 100. For example, wireless<br>
communication device 10 may be a cell phone, a personal digital assistant ("PDA"), a<br>
laptop computer, wristwatch, or any other device configured for wireless communication.<br>
Wireless communication devices may also be referred to herein as "handsets" or "mobile<br>
phones" or "mobile devices".<br>
[103] Base station 20 is preferably configured to communicate over-the-air with a<br>
plurality of wireless communication devices and includes a transceiver (not shown) that<br>
converts the over-the-air communications to wired communications that travel over<br>
network 40. Preferably, network 40 is aiprivate network operated by the wireless carrier.<br>
Network 40 preferably provides the infrastructure for handoffs between base stations<br>
such as base station 20 and 22. Additionally, network 40 preferably provides the<br>
communication link between various application, services, and other computer based<br>
servers such as PMRTI server 30.<br>
[104] Network 40 may also serve as the conduit for connections to other networks (not<br>
pictured) such as an Integrated Services Digital Network ("ISDN"), Public Switched<br>
Telephone Network ("PSTN"), Public Land Mobile Network ("PLMN"), Packet<br>
Switched Public Data Network ("PSPDN"), and the Internet, just to name a few.<br>
[105] PMRTI server 30 can be implemented as a single computer or as a plurality of<br>
servers logically arranged to provide dynamic instruction sets to mobile devices and to<br>
execute dynamic instruction sets received from mobile devices.<br>
[106] Fig. 17A is block diagram illustrating an example wireless communication device<br>
10. The general features of wireless communication device 10 that allow it to function as<br>
such are well known in the art and are therefore not illustrated or described herein.<br>
[107] Wireless communication device 10 includes runtime engine 50, remote operation<br>
code ("opcode") library 60, server opcode library 70, and remote runtime instructions<br>
code section 80. Runtime engine 50 is preferably configured to process dynamic<br>
instructions sets. One example of a dynamic instruction set is a PMRTI instruction set.<br>
Another example of a dynamic instruction set is an RPMRTI instruction set. The<br>
difference between these two instruction sets is that the PMRTI set includes those<br>
functions that can be executed by the wireless device while the RPMRTI instruction set<br>
includes those functions that can be executed by the PMRTI server 30 that resides on the<br>
network 40:<br>
[108] The, processing of dynamic instruction sets includes execution of PMRTI sets that<br>
are received from the PMRTI server 30 and the compilation of RPMRTI sets and<br>
corresponding data for delivery to the PMRTI server 30. Preferably, runtime engine 50<br>
can be launched by wireless communication device 10 when needed so that it runs only<br>
when necessary and consumes a minimal amount of system resources (e.g. memory, CPU<br>
cycles, etc.) on the device 10.<br>
[109] Remote opcode library 60 preferably includes the universe of operation codes that<br>
represent each PMRTI function or executable code segment. Advantageously, remote<br>
opcode library 60 includes the operation codes that serve as place holders for the actual<br>
executable machine code functions or code segments. As such, the remote opcode library<br>
60 contains a list of all available operation codes that correspond to each and every<br>
PMRTI function that can be executed by the wireless communications device 10.<br>
[110] Similarly, the server opcode library 70 preferably includes the universe of<br>
operation codes that represent each RPMRTI function or executable code segment.<br>
Advantageously, server opcode library 70 only includes the operation codes for the actual<br>
executable machine code functions or code segments, which do not reside on the wireless<br>
communication device 10. As such, the server opcode library 70 contains a list of all the<br>
operation codes for each available RPMRTI function that can be executed by the PMRTI<br>
server 30 on behalf of the wireless communication device 10.<br>
[111] In the preferred embodiment, the number of available RPMRTI functions can well<br>
exceed the number of available PMRTI functions because the PMRTI server 30 does not<br>
suffer from the minimal resources typically found on mobile devices such as, for<br>
example, ceil phones and PDAs.<br>
[112] Additionally, wireless communication device 10 includes remote runtime<br>
instructions bode section 80. The code section 80 is where the actual machine code or<br>
executable instructions reside in persistent memory on the device 10. These executable<br>
instructions or code segments preferably correspond in a one-to-one relationship with the<br>
opcodes contained in the remote opcode library 60. Fig. 17B is block diagram illustrating<br>
an example code section 80. As shown, any number of PMRTI functions can be included<br>
in code section 80, from instruction 01 through instruction n. Optimally, a large number<br>
of functions are available in code section 80 and yet consume very little resources (e.g.<br>
persistent memory) of the device 10.<br>
[113] Advantageously, the server opcode library 70, the remote opcode library 60, and<br>
the corresponding code section 80 can be installed in persistent memory on the wireless<br>
comnunication device 10 during manufacture of the device 10 and prior to its<br>
deployment in. the field (i.e., prior to being sold to the consumer). Future updates to the<br>
set c f opcodes contained in either library or to the set of executable instructions in the<br>
code section 80 can be provided by the PMRTI server 30 implementing the process later<br>
described with respect to Fig. 22.<br>
[114] Finally, in the illustrated embodiment, wireless communication device includes an<br>
over-the-air communication link 90. Implementation of the communication link 90 is<br>
well known in the art and provides the wireless communication device 10 with the ability<br>
to communicate within the wireless communication network 100 via a radio or other<br>
over-the-air connection. Advantageously, over-the-air communication link 90 can<br>
provide the means for PMRTI server 30 to update remote opcode library 60, server<br>
opcode library 70, and remote runtime instructions codes section 80.<br>
[115] Fig. 18A is a block diagram illustrating an example PMRTI server 30. The<br>
features of a general purpose computer that may implement the PMRTI server are later<br>
described with respect to Fig. 23.<br>
[116] In 'the illustrated embodiment, PMRTI server 30 includes control module 95,<br>
remote opcode library 60, server opcode library 70, and server runtime instructions code<br>
section 82. The remote opcode library 60 and server opcode library 70 preferably contain<br>
the same list of opcodes as the libraries that are present on the wireless communication<br>
device 10. The control module 95 is preferably configured to process dynamic<br>
instructions sets and manage a network of PMRTI communications between the PMRTI<br>
server 30 and a plurality of wireless communication devices available via the wireless<br>
communication network.<br>
[117] For example, the control module 95 may compile various dynamic PMRTI sets<br>
and send those instruction sets to a variety of discrete wireless communication devices.<br>
Similarly, the control module 95 may also receive a plurality of dynamic RPMRTI sets<br>
and execujte those instruction sets on behalf of the sending wireless communication<br>
device.<br>
[118] Remote opcode library 60 preferably includes the universe of operation codes<br>
corresponding to each available PMRTI function or executable code segment.<br>
Advantageously, remote opcode library 60 comprises a list of the operation codes that<br>
serve as place holders for the actual executable machine code functions or code segments<br>
in the remote runtime instructions code section 80 (on the wireless communication<br>
device). As such, the remote opcode library 60 contains a list ot all available opcodes tor<br>
all available PMRTI functions that can be executed by a wireless communications device.<br>
[119] Similarly, the server opcode library 70 preferably includes the universe of<br>
operation codes corresponding to each RPMRTI function or executable code segment.<br>
Advantageously, server opcode library 70 only includes the operation codes for the actual<br>
executable machine code functions or code segments that can be carried out the PMRTI<br>
server 30. Preferably, the number of available RPMRTI functions well exceeds the<br>
number of available PMRTI functions because the PMRTI server 30 does not suffer from<br>
the minimal resources typically found on mobile devices such as, for example, cell<br>
phones and PDAs.<br>
[120] Additionally, PMRTI server 30 includes the server runtime instructions code<br>
section 82. The code section 82 is where the actual machine code or executable<br>
instructions reside in persistent memory on the server 30. These executable instructions<br>
or code segments preferably correspond in a one-to-one relationship with the operation<br>
codes contained in the server opcode library 70, which resides both on the server 30 and<br>
the wireless communication device 10. Fig. 18B is a block diagram illustrating an<br>
example server runtime instructions code section.<br>
[121] Fig. 19 is a flow diagram illustrating an example process for executing dynamic<br>
instpction sets on a wireless communication device. Initially, in step 500, the wireless<br>
device receives a set of remote opcodes. The set of remote opcodes can be received via<br>
an over-the-air communication link, for example a link with a wireless communication<br>
network. Preferably, the opcodes are optimized to minimize the amount of data sent<br>
over-the-air. Additionally, a data payload may be included with the set of opcodes<br>
received by the wireless device.<br>
[122] In step 502, the wireless device launches its runtime engine to process the remote<br>
opcode set. As illustrated in step 504, the runtime engine parses the remote opcode set<br>
and then extracts the data payload in step 506. If no data payload exists, then this step<br>
can be skipped. If a data payload does exist, then the resulting data can be stored in an<br>
available portion of volatile memory for later use. Next, the runtime engine obtains the<br>
executable instructions that correspond to the opcodes in the remote opcode set as shown<br>
in step 508. These instructions can be obtained from the remote runtime instructions<br>
code section of the wireless device.<br>
[123] Once the executable instructions corresponding to the opcodes in the remote<br>
opcode set have been obtained, the runtime engine executes the instructions, as illustrated<br>
in step 510. When the instructions are being executed, any necessary data to be operated<br>
on can be obtained from volatile memory where the data payload is stored. Alternatively,<br>
or additionally, any necessary data to be operated on may be obtained as the result of an<br>
executed instruction.<br>
[124] For example, the data payload may include an updated software module for the<br>
wreless device. Additionally, one of the opcodes in the remote opcode set may<br>
correspond to an executable instruction for replacing a section of persistent memory with<br>
a portion of the data payload. In this! example, the portion of persistent memory being<br>
replaced is the outdated software module and as a result the updated software module is<br>
loaded into persistent memory by the instruction. Thus, the remote opcode set and data<br>
payload operate on the wireless device to update a software module.<br>
[125] Once the instruction set has been executed in its entirety by the runtime engine,<br>
the runtime engine can be terminated, as shown in step 512. Advantageously, the<br>
runtime engine may be launched and terminated so that it only runs when necessary.<br>
This saves system resources on the wireless device, for example it may save volatile<br>
memory space and CPU cycles.<br>
[126] Fig. 20 is a flow diagram illustrating an example process for compiling dynamic<br>
instruction sets on a wireless communication device. Initially, the runtime engine is<br>
launched, as illustrated in step 520. Once the runtime engine is running, the engine can<br>
compile a set of server opcodes, as shown in step 522. The set of server opcodes may be<br>
obtained from a background process running on the wireless device. Alternatively, the<br>
server opcode set may be obtained from a process running on the wireless device under<br>
the direction of a user.<br>
[127] For example, the wireless device may include a set of routines that are<br>
periodically and automatically run by the operating system in order to perform system<br>
maintenance or other desirable functions. These procedures may, as a result of their<br>
execution, cause a server opcode set to be generated by the runtime engine.<br>
Alternatively, a user may initiate a particular set of routines that are only executed when<br>
requested by a user. This set of routines may also cause a server opcode set to be<br>
generated by the runtime engine. In both cases, the result is a server opcode set generated<br>
by the runtime engine; as shown in step 522.<br>
[128] Once the server opcode set has been generated, the runtime engine determines in<br>
step 524 if a data payload should accompany the server opcode set. If there is data that<br>
needs to go along with the server opcode set, in step 526 the runtime engine fetches the<br>
data from persistent or volatile memory, or executes an instruction that returns the data<br>
needed. Once the data has been obtained, the run time engine next inserts the data into<br>
the server opcode set, as illustrated in step 528. One simple way to achieve this is to<br>
append the data payload to the server opcode set in a single data packet.<br>
[129] Once the data payload has been combined with the server opcode set, or if no data<br>
payload is required, then the runtime engine sends the server opcode set (with or without<br>
a data payload) to the server, as shown in step 530. After the server opcode set has been<br>
sent, the runtime engine may be terminated to free up resources on the wireless device, as<br>
illustrated in step 532.<br>
[130] Fig. 121 is a flow diagram illustrating an example process for executing dynamic<br>
instruction sets on a PMRTI server. Initially, in step 540 the server receives the server<br>
opcode set. The opcode set is preferably a list of monikers that represent a series of<br>
executable instructions, with each opcode representing a discrete executable instruction<br>
or a discrete set of executable instructions. Once the set of server opcodes has been<br>
received, the server then parses the server opcode set in step 542 and extracts any data<br>
payload included with the server opcode set, as illustrated in step 544. When the data<br>
payload is extracted, it may be temporarily stored in volatile memory on the server for<br>
later use.<br>
[131] Next, the server obtains the corresponding instruction set, as shown in step 546.<br>
Preferably] the corresponding instruction set is stored in a server runtime instructions<br>
code section that resides in persistent memory on the PMRTI server machine. Once the<br>
instruction set has been obtained, the server then executes the instruction set, as seen in<br>
step 548. When the instruction set is being executed, the executing routines may use the<br>
data payload that came with the server opcode set. Preferably, the data payload is stored<br>
in memory on the server for this purpose. Alternatively, the executing routines may<br>
include instructions that generate the data necessary for the instruction set to carry out its<br>
function.<br>
[132] Fig. 22 is a flow diagram illustrating an example process for synchronizing<br>
opcode libraries. Initially, in step 580 the wireless device obtains a list of server opcodes.<br>
This may be done most easily by consulting the server opcode library. Alternatively, an<br>
routine may be called or a program may be run, the result of which is the desired list of<br>
server opcodes. In a general sense, the process for synchronizing opcode libraries may be<br>
periodically and automatically initiated by the wireless device or it may be initiated by<br>
input from a user.<br>
[133] Once a list of server opcodes has been obtained, the list is included as the data<br>
payload in a server opcode set and sent to the server for processing, as shown in step 582.<br>
The server executes the instructions corresponding to the opcode and thereby processes<br>
the data payload, which is the list of all available server opcodes according to the wireless<br>
device. In response, the wireless device receives a remote opcode set and data payload,<br>
as illustrated in step 584. The data payload received from the server advantageously<br>
includes any updated or modified opcodes and the corresponding executable instruction.<br>
Additionally, the data payload also includes any new opcodes and the corresponding<br>
executable instruction.<br>
[134] The wireless device next extracts this data payload in step 586 and preferably<br>
stores the data payload in an available memory of the wireless device, fpr example a free<br>
segment oflvolatile memory. Once the data payload has been extracted, the wireless<br>
device obtains the executable instructions corresponding to the remote opcode set, as<br>
illustrated in step 588. Once the set of executable instructions corresponding to the<br>
remote opcode set have been obtained, the wireless device then executes those<br>
instructions, as shown in step 590. When the instructions are executed, the data from the<br>
data payload can be accessed from the temporary storage location within the wireless<br>
device.<br>
[135] For example, a first executable instruction may cause the wireless device to<br>
replace a first portion of persistent memory with a first portion of the data payload. After<br>
, doing so, the result is preferably an updated server opcode in the server opcode library.<br>
Correspondingly, a second executable instruction may cause the wireless device to<br>
replace a second portion of persistent memory with a second portion of the data payload.<br>
After doing so, the result is preferably an updated executable instruction in the server<br>
runtime instructions c;ode section. This advantageously allows the wireless device to<br>
periodically query the PMRTI server for updates to its functionality suite.<br>
[136] Additional applications of the ability of a handset to construct a server opcode set<br>
and corresponding data payload and send them to the PMRTI server 30 for processing<br>
include providing location updates (e.g., GPS information), saving a voice memo on the<br>
network, sending files to the network or other users. In the general sense, sending files to<br>
the network or other users encompasses an extremely broad range of desirable<br>
applications such as sending custom rings to a friend or family member, sending photos<br>
or digital images captured by the wireless device, sending emails, documents, or any<br>
other desirable data to be stored on the network or sent to another user.<br>
[137] Fig. 23 is a block diagram illustrating an exemplary computer system 550 that<br>
may be used in connection with the various examples described herein. For example, the<br>
computer system 550 may be employed as the PMRTI server that resides within the<br>
wireless communication network. Computer system 550 may also be employed as any of<br>
the various other general or specific purpose computer systems that comprise the wireless<br>
communication network and its constituent components. However,, other computer<br>
systems and computer architectures may be used, as will be clear to those skilled in the<br>
art.<br>
[138] The computer system 550 preferably includes one or more processors, such as<br>
processor 552. Additional processors may be provided, such as an auxiliary processor to<br>
manage input and output, an auxiliary processor to perform floating point mathematical<br>
operations, a special-purpose microprocessor having an architecture suitable for fast<br>
execution of signal processing algorithms (e.g., digital signal processor), a slave<br>
processor subordinate to the main processing system (e.g., back-end processor), an<br>
additional microprocessor or controller for dual or multiple processor systems, or a<br>
coprocessor. Such auxiliary processors may be discrete processors or may be integrated<br>
with the processor 552.<br>
[139] The processor 552 is preferably connected to a communication bus 554. The<br>
communication bus 554 may include a data channel for facilitating information transfer<br>
between storage and other peripheral components of the computer system 550. The<br>
communication bus 554 further may provide a set of signals used for communication<br>
with the processor 552, including a data bus, address bus, and control bus (not shown).<br>
The. communication bus 554 may comprise any standard or non-standard bus architecture<br>
such as, for example, bus architectures compliant with industry standard architecture<br>
("ISA"), extended industry standard architecture ("EISA"), Micro Channel Architecture<br>
("MCA"), peripheral component interconnect ("PCI") local bus, or standards<br>
promulgated by the Institute of Electrical and Electronics Engineers ("IEEE") including<br>
IEEE 488 general-purpose interface bus ("GPIB"), IEEE 696/S-100, and the like.<br>
[140] Computer system 550 preferably includes a main memory 556 and may also<br>
include a secondary memory 558. The main memory 556 provides storage of instructions<br>
and data for programs executing on the processor 552. The main memory 556 is<br>
typically semiconductor-based memory such as dynamic random access memory<br>
("DRAM") and/or static random access memory ("SRAM"). Other semiconductor-based<br>
memory types include, for example, synchronous dynamic random access memory<br>
("SDRAM"), Rambus dynamic random access memory ("RDRAM"), ferroelectric<br>
random access memory ("FRAM"), and the like, including read only memory ("ROM").<br>
[141] The secondary memory 558 may optionally include a hard disk drive 560 and/or a<br>
removable storage drive 562, for example a floppy disk drive, a magnetic tape drive, a<br>
compact disc ("CD") drive, a digital versatile disc ("DVD") drive, etc. The removable<br>
storage drive 562 reads from and/or writes to a removable storage medium 564 in a well-<br>
known manner. Removable storage medium 564 may be, for example, a floppy disk,<br>
magnetic tape, CD, DVD, etc.<br>
[142] The removable storage medium 564 is preferably a computer readable medium<br>
having stored thereon computer executable code (i.e., software) and/or data. The<br>
computer software or data stored on the removable storage medium 564 is read into the<br>
computer system 550 as electrical communication signals 578.<br>
[143] In alternative embodiments, secondary memory 558 may include other similar<br>
means for allowing computer programs or other data or instructions to be loaded into the<br>
computer system 550. Such means may include, for example, an external storage<br>
medium 572 and an interface 570. Examples of external storage medium 572 may<br>
include an external hard disk drive or an external optical drive, or and external magneto-<br>
optical drive.<br>
[144] Other examples of secondary memory 558 may include semiconductor-based<br>
memory such as programmable read-only memory ("PROM"), erasable programmable<br>
read-only memory ("EPROM"), electrically erasable read-only memory ("EEPROM"), or<br>
flash memory (block oriented memory similar to EEPROM). Also included are any other<br>
removable storage units 572 and interfaces 570, which allow software and data to be<br>
transferred from the removable storage unit 572 to the computer system 550.<br>
[145] Computer system 550 may also include a communication interface 574. The<br>
communication interface 574 allows software and data to be transferred between<br>
computer system 550 and external devices (e.g. printers), networks, or information<br>
sources. For example, computer software or executable code may be transferred to<br>
computer system 550 from a network server via communication interface 574. Examples<br>
of communication interface 574 include a modem, a network interface card ("NIC"), a<br>
communications port, a PCMCIA slot and card, an infrared interface, and an IEEE 1394<br>
fire-wire, just to name a few.<br>
[146] Communication interface 574 preferably implements industry promulgated<br>
protocol standards, such as Ethernet IEEE 802 standards, Fiber Channel, digital<br>
subscriber line ("DSL"), asynchronous digital subscriber line ("ADSL"), frame relay,<br>
asynchronous transfer mode ("ATM"), integrated digital services network ("ISDN"),<br>
personal communications services ("PCS"), transmission control protocol/Internet<br>
protocol ("TCP/IP"), serial line Internet protocol/point to point protocol ("SLIP/PPP"),<br>
and so on[ but may also implement customized or non-standard interface protocols as<br>
well.<br>
[147] Software and data transferred via communication interface 574 are generally in<br>
the form of electrical communication signals 578. These signals 578 are preferably<br>
provided to communication interface 574 via a communication channel 576.<br>
Communication channel 576 carries signals 578 and can be implemented using a variety<br>
of communication means including wire or cable, fiber optics, conventional phone line,<br>
cellular phone link, radio frequency (RP) link, or infrared link, just to name a few.<br>
[148] Computer executable code (i.e., computer programs or software) is stored in the<br>
main memory 556 and/or the secondary memory 558. Computer programs can also be<br>
received via communication interface 574 and stored in the main memory 556 and/or the<br>
secondary memory 558. Such computer programs, when executed, enable the computer<br>
system 550 to perform the various functions of the present invention as previously<br>
described.<br>
[149] In this description, the term "computer readable medium" is used to refer to any<br>
media used to provide computer executable code (e.g., software and computer programs)<br>
to the computer system 550. Examples of these media include main memory 556,<br>
secondary memory 558 (including hard disk drive 560, removable storage medium 564,<br>
and external storage medium 572), and any peripheral device communicatively coupled<br>
with communication interface 574 (including a network information server or other<br>
network device). These computer readable mediums are means for providing executable<br>
code, programming instructions, and software to the computer system 550.<br>
[150] In an embodiment that is implemented using software, the software may be stored<br>
on a computer readable medium and loaded into computer system 550 by way of<br>
removable storage drive 562, interface 570, or communication interface 574. In such an<br>
embodiment, the software is loaded into the computer system 550 in the form of<br>
electrical communication signals 578. The software, when executed by the processor<br>
552, preferably causes the processor 552 to perform the inventive features and functions<br>
previously described herein.<br>
[151] Various embodiments may also be implemented primarily in hardware using, for<br>
example, components such as application specific integrated circuits ("ASICs"), or field<br>
programmable gate arrays ("FPGAs"). Implementation of a hardware state machine<br>
capable of performing the functions described herein will also be apparent to those<br>
skilled in ,the relevant art. Various embodiments may also be implemented using a<br>
combination of both hardware and software.<br>
[152] While the particular systems and methods herein shown and described in detail<br>
are fully capable of attaining the above described objects of this invention, it is to be<br>
understood that the description and drawings presented herein represent a presently<br>
preferred embodiment of the invention and are therefore representative of the subject<br>
matter which is broadly contemplated by the present invention. It is further understood<br>
that the scope of the present invention fully encompasses other embodiments that may<br>
become obvious to those skilled in the art and that the scope of the present invention is<br>
accordingly limited by nothing other than the appended claims.<br><br>
WE CLAIM :<br>
1. A wireless communication device (10) comprising:<br>
a library of server operation codes (70);<br>
a library of remote operation codes (60);<br>
a set of executable instructions (80), each executable instruction<br>
corresponding to an operation code in the library of remote operation codes (60);<br>
a runtime engine (50) configured to compile a set of server operation<br>
codes from the library of server operation codes (70) and send the set of<br>
compiled server operation codes to a server computer (30) communicatively<br>
coupled with the wireless communication device (10) via a wireless<br>
communication network (40), the runtime engine (50) configured to receive a set<br>
of remote operation codes and execute a second set of executable instructions<br>
from the first set of executable instructions (80), each executable instruction of<br>
the second set corresponding to an operation code in the received set of remote<br>
operation codes.<br>
2. The wireless communication device as claimed in claim 1, wherein the<br>
compiled set of server operation codes comprises a data payload (808).<br>
3. The wireless communication device as claimed in claim 1, wherein the<br>
runtime engine is configured to automatically compile the set of server operation<br>
codes and send the compiled set of server operation codes at a predetermined<br>
time.<br>
4. The wireless communication device as claimed in claim 1, wherein the<br>
runtime engine is configured to compile the set of server operation codes and<br>
send the compiled set of server operation codes in response to input from a user<br>
of the wireless communication device.<br>
5. A bi-directional system for sending and receiving operational codes<br>
between a wireless communication device (10) and a server computer (30),<br>
wherein the wireless communication device and the server computer are<br>
communicatively coupled via a wireless communication network (40), the system<br>
comprising:<br>
a wireless communication device (10) having<br>
a runtime engine (50),<br>
a library of server operation codes (70),<br>
a library of remote operation codes (60), and<br>
a first set of executable instructions (80), each executable<br>
instruction in said first set corresponding to an operation code in<br>
the library of remote operation codes (60); and<br>
a server computer having<br>
a control module (95),<br>
a library of server operation codes (70),<br>
a library of remote operation codes (60), and<br>
a second set of executable instructions (82), each executable<br>
instruction in said second set corresponding to an operation code<br>
in the library of server operation codes (70) of the server computer;<br>
wherein the runtime engine (50) is configured to compile a set of server<br>
operation codes from the library of server operation codes (70) and send the<br>
compiled set of server operation codes to the server computer (30),<br>
wherein the server computer (30) is configured to receive the compiled set<br>
of server operation codes from the wireless communication device and execute a<br>
third set of executable instructions from the second set of executable<br>
instructions, each executable instruction of the third set corresponding to an<br>
operation code in the received set of server operation codes,<br>
wherein the server computer is further configured to compile a set of<br>
remote operation codes from the library of remote operation codes (60) and send<br>
the compiled set of remote operation codes to the wireless communication<br>
device (10), and<br>
wherein the runtime engine (50) is further configured to receive the<br>
compiled set of remote operation codes and execute a fourth set of executable<br>
instructions from the first set of executable instructions (80), each executable<br>
instruction of the fourth set corresponding to an operation code in the received<br>
set of remote operation codes..<br>
6. The system as claimed in claim 5, wherein the compiled set of server<br>
operation codes comprises a data payload (808).<br>
7. The system as claimed in claim 5, wherein the runtime engine is<br>
configured to automatically compile the set of server operation codes and send<br>
the compiled set of server operation codes at a predetermined time.<br>
8. The system as claimed in claim 5, wherein the runtime engine is<br>
configured to compile the set of operation codes and send the compiled set of<br>
server operation codes in response to input from a user of the wireless<br>
communication device.<br>
9. A method for sending and receiving operational codes between a wireless<br>
communication device (10) and a server computer (30), wherein the wireless<br>
communication device (10) and the server computer (30) are communicatively<br>
coupled via a wireless communication network (40), the method comprising:<br>
compiling (522) a set of server operation codes from a library of server<br>
operational codes (70) within a runtime engine of the wireless communication<br>
device;<br><br>
attaching (528) a data payload to the compiled set of server operation<br>
codes, wherein the data payload corresponds to the compiled set of server<br>
operation codes;<br>
sending (530) the compiled set of server operation codes and data<br>
payload to the server computer for execution thereon;<br>
receiving (500) a set of remote operation codes from the server computer;<br>
and<br>
executing (510) a set of executable instructions, each executable<br>
instruction from this set corresponding to an operation code in the received set of<br>
remote operation codes.<br>
10. The method as claimed in claim 9, wherein the attaching step (528)<br>
comprises the steps of:<br>
determining whether corresponding data is required for each operation<br>
code included in the compiled set of operational codes;<br>
fetching (526) the required corresponding data for each operation code;<br>
and<br>
compiling the corresponding data fetched for each operation code into a<br>
data payload (808).<br>
11. The method as claimed in claim 9, wherein the compiling step comprises<br>
the steps of:<br>
fetching an operation code from the library of server operation codes; and<br>
storing the operation code in a temporary memory location housing the set<br>
of-server operation codes.<br>
12. The method as claimed in claim 9, wherein the data payload comprises<br>
diagnostic information.<br>
A wireless communication device and a bi-directional system and method<br>
for sending and receiving operational codes between a wireless communication<br>
device and a server computer are disclosed. The wireless communication device<br>
(10) comprises: a library of server operation codes (70); a library of remote<br>
operation codes (60); a set of executable instructions (80) and a runtime engine<br>
(50). The method for sending and receiving operational codes between a<br>
wireless communication device (10) and a server computer (30) comprises:<br>
compiling (522) a set of server operation codes from a library of server<br>
operational codes (70) within a runtime engine of the wireless communication<br>
device; attaching (528) a data payload to the compiled set of server operation<br>
codes, wherein the data payload corresponds to the compiled set of server<br>
operation codes; sending (530) the compiled set of server operation codes and<br>
data payload to the server computer for execution thereon; receiving (500) a set<br>
of remote operation codes from the server computer; and executing (510) a set<br>
of executable instructions, each executable instruction from this set<br>
corresponding to an operation code in the received set of remote operation<br>
codes.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLUtPTE5QLTIwMDQtQ09SUkVTUE9OREVOQ0UucGRm" target="_blank" style="word-wrap:break-word;">140-KOLNP-2004-CORRESPONDENCE.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLUtPTE5QLTIwMDQtRk9STSAyNy5wZGY=" target="_blank" style="word-wrap:break-word;">140-KOLNP-2004-FORM 27.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLUtPTE5QLTIwMDQtRk9STS0yNy5wZGY=" target="_blank" style="word-wrap:break-word;">140-KOLNP-2004-FORM-27.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1hc3NpZ25tZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1jb3JyZXNwb25kZW5jZS5wZGY=" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1leGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1mb3JtIDEucGRm" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1mb3JtIDE4LnBkZg==" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1mb3JtIDMucGRm" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1mb3JtIDUucGRm" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1wYS5wZGY=" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-pa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1yZXBseSB0byBleGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwLWtvbG5wLTIwMDQtZ3JhbnRlZC1zcGVjaWZpY2F0aW9uLnBkZg==" target="_blank" style="word-wrap:break-word;">140-kolnp-2004-granted-specification.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="233020-active-antenna-system-of-a-radio-communication-terminal.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="233022-method-for-detecting-chlamydia-pneumoniae.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>233021</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>140/KOLNP/2004</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>27-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>25-Mar-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>04-Feb-2004</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>KYOCERA WIRELESS CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>10300 CAMPUS POINT DRIVE, SAN DIEGO, CA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>RAJARAM GOWRI</td>
											<td>3520 LEBON DRIVE, APT. 5330, SAN DIEGO, CA 92122</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04L 29/06</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>H04L 29/06</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-07-25</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/916900</td>
									<td>2001-07-26</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>09/927131</td>
									<td>2001-08-10</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>3</td>
									<td>09/969,305</td>
									<td>2001-10-02</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>4</td>
									<td>09/916460</td>
									<td>2001-07-26</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>5</td>
									<td>09/917026</td>
									<td>2001-07-26</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/233021-a-wireless-communiction-device-and-a-bi-directional-system-and-method-for-sending-and-receiving-operation-codes-between-a-wireless-communication-device-and-a-server-computer by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:28:46 GMT -->
</html>
