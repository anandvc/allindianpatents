<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/207300-a-method-of-processing-multidimensional-data-in-a-computer-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:34:11 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 207300:A METHOD OF PROCESSING MULTIDIMENSIONAL DATA IN A COMPUTER SYSTEM</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD OF PROCESSING MULTIDIMENSIONAL DATA IN A COMPUTER SYSTEM</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A computer-based method of processing multidimensional data is disclosed .which comprises the steps of: (i) obtaining categorical attributes associated with the multidimensional data; (ii) automatically ordering at least a portion of the categorical attributes associated with the multidimensional data wherein the automatic ordering step arranges the attributes to provide a substantially optimized visualization of the categorical attributes; and (iii) making results of the automatic ordering step available.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
Field of the Invention<br>
The present invention generally relates to data exploration and analysis techniques and, in particular, to systems and methods for visualizing multidimensional data for use in such data exploration and analysis techniques.<br>
Background of the Invention<br>
Visualization techniques are becoming increasingly important for the analysis and exploration of multidimensional data sets. A major advantage of visualization techniques over other non-visual approaches, such as data mining, statistics, and machine learning techniques, is that visualizations allow a direct interaction with the user and provide an immediate feedback, as well as user steering. Because of this, visualization is typically the core of an exploratory system for analysis multidimensional data. Examples of such systems include both general purpose software, such as Diamond, Data Explorer, and specialized systems, such as EventBrowser for event data, all available from IBM Corporation. The EventBrowser is described in "EventBrowser: A flexible tool for scaleable analysis of event data," S. Ma and J.L. Hellerstein, DSOM, 1999 and in the U.S patent application identified by Serial No. 09/359,874, filed on July 27, 1999, and entitled "Systems and Methods for Exploratory Analysis of Data for Event Management," the disclosures of which are incorporated herein by reference. Visualization techniques are also incorporated by most data mining products, such as the Intelligent miner from IBM Corporation, MineSet from SGI, etc.<br>
While a great deal of work has addressed visualization of numeric data, many domains require visualization of a large amount of categorical data. Examples of such data are: city names in census data, equipment manufacturers in inventory data, and host names in network management data.<br><br>
When visualization techniques are applied to categorical data, a key issue not yet addressed systematically by the prior art is how to order the values of categorical data for better visualization. In this invention, we provide solutions to address this and other issues.<br>
Unlike numeric data, categorical values provide information about which category an object belongs to, and thus does not provide any information about distance and ranking of objects. This is problematic for commonly-used visualization techniques, such as scatter plots and parallel coordinate plots, since categorical values typically need to be mapped to axis coordinates. Technically, any order of the categorical values is valid. However, properly ordering the data can greatly improve the quality of the visualizations, and is crucial for visually exploring categorical data.<br>
To illustrate how visualizations can be improved by properly ordering categorical data, we use event data collected from a production network containing hundreds of elements (e.g., routers, hubs, and servers). We focus on three categorical attributes: host name, which is the source of the event; event type, which specifies what happened (e.g., a connection was lost); and the time stamp of when the event occurred. The specific data set used herein to illustrate the invention contains over 10,000 events generated by 160 hosts with 20 event types in a three-day period. We are interested in: (1) when hosts generate events; (2) whether events are correlated temporally and spatially; and (3) how hosts relate to the types of events generated. In our experience (e.g., in the course of developing the above-mentioned EventBrowser system), a scatter plot is suitable for items (1) and (2), while a parallel coordinate plot works well for (3). We first address the ordering issue for two-dimensional scatter plots.<br>
FIG. 1 shows a scatter plot of the aforementioned data. The x-axis is time, and the y-axis is the host name. An event is represented by a dot for a specific time and host. Since host names are categorical, they must be mapped into a unique number on the y-axis. That is, a total order is imposed on the categorical values. One key issue addressed in accordance with the invention is how to determine the total order of<br><br>
categorical values. One approach is to order categorical values in an arbitrary way. This approach will serve as a baseline for comparison.<br>
The approach shown in FIG. 1 orders host names on the y-axis in an arbitrary or random way. Since points are spread fairly "uniformly" across the plot, FIG. 1 provides little insight into the data.<br>
From the above example, we can conclude that proper ordering of categorical values is crucial for visualizing categorical data. Without it, information embedded in data can hardly be visualized.<br>
In the prior art, two approaches have been offered to resolve the ordering issue. The first approach orders categorical values manually. In this approach, a user can explicitly change the order of categorical data through operations such as dragging-and-dropping. The second approach orders values by an auxiliary numerical attribute, see "XmdvTool: Integrating multiple methods for visualizing multivariate data," M.O. Ward, Visualization, 1994; and Diamond software from IBM Corporation. For example, categorical attribute values can be sorted by their counts or by the corresponding time attribute. Needless to say, these two approaches can be effective for small data sets with few categorical attributes and values. However, they are cumbersome for large data sets because:<br>
(1)	Both approaches tune the order manually, and thus are not easy to scale up. To understand this, we note the fact that the number of possible orders grows exponentially as the number of attributes and their values increases. As a result, it becomes difficult and time-consuming to explore manually all possible combinations for large data.<br>
(2)	Both approaches depend on inputs from a knowledgeable end-user. This creates a so-called knowledge acquisition bottleneck. In addition, because a proper order of categorical data depends on applications and what a user looks for, this makes it more difficult to find a knowledgeable end-user.<br>
(3)	Both approaches are not related to a visual task, and therefore can not, in general, ensure the best visualization quality.<br><br>
To summarize, the prior art teaches to order categorical data manually. As a result, it is difficult to scale up, and is inadequate to support visually exploratory analysis of large categorical data.<br>
Therefore, it would be highly desirable to provide systems and methods which can automatically and optimally order categorical data, and thus provide a user with high quality visualization to explore and analyze large amounts of categorical data.<br>
Summary of the Invention<br>
The present invention provides methods and systems for automatically ordering categorical data for improved visualization. In one broad aspect, the invention provides a computer-based method of processing multidimensional data which comprises the steps of: (i) obtaining categorical attributes associated with the multidimensional data; (ii) automatically ordering at least a portion of the categorical attributes associated with the multidimensional data wherein the automatic ordering step arranges the attributes to provide a substantially optimized visualization of the categorical attributes; and (iii) making results of the automatic ordering step available for use in accordance with a data visualization system.<br>
Specifically, the present invention preferably provides three different ordering methodologies or algorithms. The algorithms are described in the context of three different exemplary systems that may use the ordering algorithms, and two specific exemplary applications: scatter plots and parallel coordinate plots. Each of the algorithms of the invention automatically finds an optimal order of categorical values or attributes based on a visual task. Advantageously, this is accomplished without requiring domain knowledge.<br>
We address the issue of how categorical values should be ordered to provide good visualizations by focusing on visual tasks. Specifically, we describe two visual tasks: (i) identifying groups of similar values within a categorical attribute; and (ii) visualizing relationships (e.g., temporal relationship) between values of different categorical attributes, i.e., finding data clusters.<br><br>
These two visual tasks can further translate into objective functions, respectively, as follows: (i) Objective 1: arranging objects with similar behaviors in adjacent positions so that similar objects are visually similar — in this way, similar objects can be identified and compared easily; (ii) Objective 2: arranging objects in a data cluster together so that these objects can be viewed as a group and the data patterns can be more pronounced.<br>
To optimize these objective functions, one may develop ad-hoc algorithms directly or translate these objectives further into an optimization problem that in turn determines the order of the categorical values. The first two algorithms of the invention address the first objective. The third algorithm of the invention relates to the second objective.<br>
The first algorithm of the invention is a sequential ordering algorithm (SOA) which orders categorical values one by one. For convenience, we refer to a categorical value as an object. In one embodiment, SOA operates as follows. First, the methodology adds a random object into an initially empty list called an ordered list (o-list). O-list records the ordered objects at the current step and is also the output of the algorithm. Then, SOA repeatedly finds the object that is the most similar to the current o-list based on certain similarity measures, and inserts this object into o-list until the o-list collects all objects. The complexity of SOA is linear with respect to the number of objects to be ordered.<br>
The second algorithm of the invention is a hierarchical ordering algorithm (HOA) designed to take the advantage of the hierarchical clustering algorithm, a well-known algorithm for the clustering task in pattern recognition. The hierarchical clustering algorithm is described in R.O. Duda and P.E. Hard, "Pattern classification and scene analysis/' Wiley, New York, 1973, the disclosure of which is incorporated by reference herein. The hierarchical clustering algorithm computes the hierarchical relationships among objects as its outputs. However, it does not fully determine the order of the objects. HOA provides an optimal total order of the hierarchical organized objects produced by the hierarchical clustering algorithm.     HOA is a recursive<br><br>
top-down algorithm. It has the same computational complexity as that of the hierarchical clustering algorithm.<br>
Often, visualization is used to visualize and identify possible data clusters. This leads to the second objective for ordering: arranging objects so that data patterns are more pronounced. We formulate this problem as a graph optimization problem, and develop an ordering algorithm, the third algorithm of the invention, which we refer to as a minimizing order conflicts (MOC) algorithm.<br>
We now describe how to preferably integrate the aforementioned ordering algorithms with a visualization system. From the system perspective, data visualization usually has three main components: (i) data preprocessing; (ii) data management; and (iii) data viewer (or data visualization). One example of a visualization system with which the ordering algorithms of the invention may be integrated with is described in the above-incorporated U.S patent application identified by Serial No. 09/359,874 and entitled "Systems and Methods for Exploratory Analysis of Data for Event Management." However, it is to be appreciated that the methodologies of the invention may be implemented in other conventional visualization systems.<br>
The ordering mechanism of the invention may be incorporated with a visualization system in various different ways. By way of a first example, ordering of categorical data can be used as a part of the preprocessing component. This approach is very simple, and does not require any modification to the visualization systems. In addition, this approach is transparent to users. This makes the first approach suitable for applications where the visualization system can not be modified and/or the data and its analysis are relatively stable. By way of a second example, an ordering mechanism can be embedded in the data management component. Doing so allows the user to interactively explore different ordering algorithms. By way of a third example, an ordering mechanism can be incorporated into the data viewer. The advantage of this approach is its flexibility for building an ordering mechanism specific to a visual task. In  summary,  there are a variety of different ways to incorporate the ordering<br><br>
mechanism into a visualization system. The choice of these methods largely depends on the application, and how a user wants to interact with the ordering mechanism.<br>
The problem for ordering categorical data for better visualization is generic. Any technique for visualizing categorical data needs to address this problem. Our automatic algorithms can be used by almost all visualization approaches. In this invention, we focus on two popular visualization techniques: scatter plots and parallel coordinate plots to illustrate how our methods and systems are used to improve visual quality.<br>
To summarize, this invention describes methods systems for automatically ordering categorical data to achieve better visualization. We describe three different algorithms to support two different visual objectives (or visual tasks). We illustrate three different system architectures, which incorporate the ordering mechanism. We further describe how to apply our method and system for scatter plots and parallel coordinate plots.<br>
Mathematical optimization has been used by Anerst et. al. (see "Similarity clustering of dimensions for an enhanced visualization of multidimensional data," M. Ankerst, S. Berchtold, and D.A. Keim, Info Vis, 1998) to rearrange the dimensions (or variables) of data for visualizations. However, the specifics of our algorithms differ considerably from Anerst et. al., and we are interested in ordering categorical values rather than the dimensions of a plot.<br>
Many extensions are possible to the systems and methods of our invention. First, although only two-dimensional scatter plots and parallel coordinate plots are described, our approach can be generalized into multidimensional plots. Second, the methods and systems developed are generic. They can be adapted to any visualization method designed for categorical data. Third, systems described are based on a generic system model such as the above-mentioned EventBrowser system. However, our methods can be applied to other generic system models. Fourth, our methods can be easily generalized to incorporate interactions with end users.<br><br>
These and other objects, features and advantages of the present invention will become apparent from the following detailed description of illustrative embodiments thereof, which is to be read in connection with the accompanying drawings.<br>
Brief Description of the Drawings<br>
FIG. 1 illustrates a scatter plot for an exemplary event data with random order;<br>
FIG. 2 illustrates a scatter plot using HOA;<br>
FIG. 3 illustrates a scatter plot using SOA;<br>
FIG. 4 illustrates a scatter plot using MOC;<br>
FIG. 5 illustrates a parallel coordinate plot for an exemplary event data with random order;<br>
FIG. 6 illustrates a parallel coordinate plot using MOC;<br>
FIG. 7 illustrates a generic visualization system;<br>
FIG. 8 illustrates a system using the ordering mechanism as a part of data preprocessing;<br>
FIG. 9 illustrates a system using the ordering mechanism as a part of data management;<br>
FIG. 10 illustrates a system using the ordering mechanism as a part of a viewer;<br>
FIG. 11 illustrates a generic subsystem of the ordering mechanism;<br>
FIG. 12 illustrates a process flow of SOA;<br>
FIG. 13 illustrates a pseudo-code of SOA;<br>
FIG. 14 illustrates a process flow of HOA;<br>
FIG. 15 illustrates method steps of HOA;<br>
FIG. 16 illustrates the agglomaritive hierarchical clustering algorithm, and the hierarchical structure of objects;<br>
FIG. 17 illustrates the pseudo-code of HOA;<br>
FIG. 18 illustrates the pseudo-code of ordering called by HOA;<br>
FIG. 19 illustrates an exemplary scatter plot;<br>
FIG. 20 illustrates an optimal scatter plot of FIG. 21;<br><br>
FIG. 21 illustrates steps of a MOC algorithm for a scatter plot; FIG. 22 illustrates a corresponding graph problem of FIG. 21; FIG. 23 illustrates a greedy algorithm for ordering clusters; and FIG. 24 illustrates MOC for parallel coordinate plots; and FIG. 25 illustrates an exemplary hardware implementation for use with one or more ordering algorithms according to the invention.<br>
Detailed Description of Preferred Embodiments<br>
The following detailed description is organized as follows. First, we provide examples to illustrate the ordering problem, and compare our results of different ordering algorithms for scatter plots (FIGs. 1 through 4), and parallel coordinate plots (FIGs. 5 and 6). Second, we discuss the systems that may use our ordering algorithms in the context of FIGs. 7 through 11. Third, we describe our algorithms in detail in the context of FIGs. 12 through 24.<br>
FIGs. 1 through 4 show different scatter plots of the event data described in background section above. The x-axis is time and the y-axis is the host name. An event is represented by a dot for a specific time and host. Since host names are categorical, they must be mapped into a unique number on the y-axis. That is, a total order is imposed on the categorical values.<br>
As previously discussed, FIG. 1 illustrates ordering of host names on the y-axis in an arbitrary or random way. Since points are spread fairly "uniformly'5 across the plot, FIG. 1 provides little insight into the data. This approach serves as a baseline for comparison.<br>
According to the invention, three algorithms are provided for ordering categorical values based on different goals. These algorithms include: (i) a sequential ordering algorithm (SOA); (ii) a hierarchical ordering algorithm (HOA); and (iii) greedy ordering by minimizing ordering conflicts (MOC),. FIGs. 2 through 4 respectively show results associated with these algorithms.<br><br>
FIG. 2 illustrates a scatter plot where hosts are ordered as a result of executing a a hierarchical ordering algorithm (HOA) according to one embodiment of the invention. From FIG. 2, we see many patterns of interest: (a) a group of hosts that generate events continuously (at the top of the plot); (b) a repeated cloud-like pattern; and (c) a repeated spike-like pattern. These patterns and their implications for network administrators in a communications network are described in "EventBrowser: A flexible tool for scaleable analysis of event data," S. Ma and J.L. Hellerstein, DSOM, 1999. For example, consider pattern 1 (Pat 1). This pattern, which is a horizontal line, indicates that a small set of hosts generate events persistently. To leam more, we zoom-in, and find that one host in this pattern generates "tcpConnectionClose" events every 300 seconds. A second host periodically alternates between an "Arm threshold" (i.e., threshold exceeded) event and a "re-Arm threshold" (i.e., threshold no longer exceeded) event. It turns out that the first host is a router that was incorrectly configured. The second host was near a critical level for a key metric. The line patterns (Pat 3, 4) indicate that a sequence of events occurred on different hosts in close time proximity. Again, we may use the combination of the Plot Viewer and the Attribute Viewer of the EventBrowser to learn more about the patterns. The line patterns may represent such things as: the result of an early morning "cold start," which is a normal event pattern; a series of "link up" and "link down" events in the morning; or hundreds of SNMP events, either an "SNMP request" or "authentication failure," which may happen every day at a particular time. The latter pattern description may indicate a scan of a sequence of hosts, and may suggest a possible security intrusion. Pattern 2 (Pat 2) has a cloud-like appearance as the events in this pattern are clustered in a limited time window. It turns out that these are either "port up" or "port down" events generated as a result of mobile users connecting to and disconnecting from hubs. This happens only during normal working hours, and results in the limited time window for the pattern.<br>
Figure 3 and 4 illustrate ordering of hosts based on sequential ordering algorithm (SOA) and algorithm for minimizing order conflicts (MOC), respectively.<br><br>
FIGs. 3 and 4 show that different ordering algorithms usually result in different orders of hosts and thus visually different plots. However, all of the inventive algorithms capture the main patterns in the data that can not be shown by random ordering.<br>
The issue of ordering categorical data is important for a parallel coordinate plot (PCP) as well. FIGs. 5 and 6 are parallel coordinate plots of the same event data. The left axis is host name, and the right axis is event type. A line between a host and an event type indicates that at least one event is generated by this host with the associated event type. Note that the situation here differs from that in the scatter plot in that there are two categorical attributes — host name and event type. FIG. 5 illustrates random ordering of both host names and event types. As a result, there are a large number of lines that cross over one another. This makes it difficult to identify relationships between hosts and event types. Indeed, an ideal PCP avoids crossovers as much as possible. FIG. 6 applies one of the ordering algorithms of the invention referred to as a minimizing ordering conflict (MOC) algorithm. The algorithm generally minimizes ordering conflicts for host names and event types. By reducing the number of crossovers, JFIG. 6 provides considerably more insight than a random ordering of categorical values. For example, we can see that hosts emitting the "port up" or "interface up" event also respectively emit the "port down" or "interface down" event. That is, FIG. 6 shows that a set of hosts along the left-side vertical axis (labeled Host name) has links connecting to "port up" in the right-side vertical axis, while the same set of hosts connect to "port down." This indicates that hosts emitting the "port up" events also emit the "port down" events. The same can be seen for "interface up" and "interface down" events.<br>
Now, we describe exemplary visualization systems that may incorporate the ordering mechanism of the invention. It is to be appreciated that by "ordering mechanism," we refer to an ordering engine that implements one or more of the three ordering algorithms (HOA, SOA, MOC) of the invention.<br>
FIG. 7 depicts a generic visualization system such as, for example, the above-mentioned EventBrowser. The visualization system has three main components:<br><br>
a data source (710), a data management module (720), and viewers (730). The data source stores data to be visualized. The data management module provides basic data query operations, maintenance in-memory data, and provides correspondence among viewers. A viewer provides a means to visualize data using a predefined approach, such as visualization techniques (e.g., scatter plot), summarization techniques, etc. A viewer is also responsible for interacting with an end-user.<br>
FIGs. 8, 9, and 10 show three visualization systems which implement the inventive algorithms in different ways.<br>
FIG. 8 illustrates that the ordering mechanism or ordering engine 810 of the invention may be used as a part of the data preprocessing phase of the visualization system. That is, the ordering engine operates on the data in the data source 710 prior to use by the data management module 720 and viewer 730. One advantage of such a system is that the ordering mechanism is transparent to the visualization system so that an existing visualization system does not need to be changed to use the ordering mechanism. This implementation is well suited to those applications in which data is well-understood and relatively stable. That is, the process for analyzing the data is fixed so that similar reports may be generated and use the same ordering algorithms every time.<br>
FIG. 9 illustrates a system in which the ordering engine 810 of the invention is incorporated as a part of the data management module 720 of the visualization system. This implementation adds more flexibility to use ordering algorithms because multiple ordering algorithms can be supported for multiple viewers, and ordering can be done on-the-fly.<br>
FIG. 10 illustrates a system in which the ordering engine 810 is implemented as part of a viewer 730. This implementation does not require any change of the data management module 720. In addition, this system makes it easy to tailor an ordering algorithm to meet specific needs of a user (or an application) by simply creating a special viewer.<br><br>
In summary, FIGs. 8, 9, and 10 show three different ways to implement the ordering mechanism of the invention with a conventional visualization system. It is to be appreciated that choosing which system implementation to use largely depends on the application.<br>
FIG. 11 depicts a generic subsystem of the ordering mechanism or ordering engine 810. Input data store 1110 contains generic data, either in memory or in database. The store 1110 typically contains the whole data set being processed for a given application. From the input data, a data selection module 1120 selects data and attributes to be used for calculating feature vectors and a similarity measure, and for determining which attribute the ordering algorithm will apply. Selected data and attributes are fed into the ordering processor 1130, the core part of the ordering engine. The ordering processor 1130 takes in additional user-specific parameters, such as the definitions of feature vectors 1140 and a similarity measure 1150. The ordering processor generally performs feature calculations, similarity calculations, and execution of the ordering algorithms. We will further describe the ordering processor for each ordering algorithm. The output of ordering processor is called the ordered values 1170, which are merged with the input data 1110 to get final output data 1180 for visualization. Two methods can be used in the merge module. One is to replace the unordered objects with the ordered one. The other is to create new attributes for the ordered objects. An end-user can control the ordering process through an authoring user interface 1160, which controls data selection 1120, defines feature vectors 1140, and defines a similarity measure 1150. Feature vectors 1140 can be defined in many ways. Examples of feature vectors are counts by time, distribution by time, etc. Likewise, similarity can be measured in different ways, such as minimum, maximum and average measures. Typically, the choice of the feature vector and similarity measure is application-specific, and can therefore be adjusted by a user.<br>
FIG. 12 details the process flow of the ordering processor 1130 for the sequential ordering algorithm (SOA). The process flow includes three main blocks. First, in step 1210, feature vectors of selected data (1120) are calculated based on the<br><br>
definition of the feature vectors (1140). Second, in step 1220, a similarity measure is calculated based on the feature vectors and the definition of the similarity. For example, a similarity measure can be defined as Euclidean distance of feature vectors, e.g., compute distance between each pair of hosts. Third, in step 1230, SOA is executed to produce ordered objects. The details of SOA will now be explained.<br>
FIG. 13 illustrates a pseudo-code representation of an SOA according to one embodiment of the invention. The inputs of SOA are a list of K objects represented by H={xl, ..., xk}, and a distance (or similarity) measure between objects denoted as dist(xi, xj). The output of SOA is a list of the ordered objects denoted by o. The first step (or initial step) of the algorithm is to randomly pick a host in H, assign it to o, and delete the host from H. Step 2 finds a host, xj, in H who has the smallest distance to o. Step 3 removes xj from H. Step 4 adds xj into either the right or left-side of o depending on which side xj is closer to. Steps 2, 3, and 4 are then repeated until H is empty. To better understand the o-list, we give the following example. Assume o-list = {1, 3, 5,4}. That is, the ordered list (o-list) has host 1, 3, 5, 4 in order. Host 1 is called the most left element of o-list, while host 4 is the most right. When host 6 needs to be added into the o-list, we check to see whether host 6 is close to host 1 or host 4 by comparing the corresponding similarity measures. If, for example, host 6 is closer to host 1, the new o-list will be o-list = {6, o-list} = {6,1,3,5,4}.<br>
FIG. 14 details the process flow of the ordering processor 1130 for the hierarchical ordering algorithm (HOA). HOA. Steps 1410 and 1420 are the same as steps 1210 and 1220 of FIG. 12, respectively, and therefore are not described again. The difference here is that, instead of the SOA being run, the HOA is executed in step 1430. The choice of which algorithm (SOA, HOA, MOC) to execute is made by the end-user.<br>
FIG. 15 shows two main steps of a HOA according to one embodiment of the invention. The first step 1502 is to apply a hierarchical clustering algorithm to find the hierarchical relationships of objects. FIG. 16 illustrates this hierarchical structure of objects.    One key observation is that objects are only partially ordered through a<br><br>
hierarchical clustering algorithm. Therefore, a second step, step 1504, is needed to find the optimal total order of the objects based on the hierarchical structure.<br>
FIG. 16 illustrates the well-known agglomerative hierarchical clustering algorithm. As the clustering algorithm is not a focus of the invention, we will not describe it in detail. For the sake of understanding of our third algorithm, we will briefly describe the output of the clustering algorithm. The output of the clustering algorithm is the hierarchical structure of objects, in which a leaf node represents an object, and a non-leaf node always has two offsprings, as illustrated in FIG. 16. As shown, node xr is referred to as the root node, while nodes xl through x6 are referred to as leaf nodes. All other nodes in between the root node and leaf nodes are referred to as non-leaf nodes. The first step of the agglomerative hierarchical clustering algorithm is to initialize so that every sample is in a cluster. Then, the two closest clusters are merged. The merging step is repeated until all samples are in one cluster. Through this hierarchical structure, objects have a partial order, but not a total order. For example, objects xl and x2 can exchange their orders without breaking the established hierarchical structure. Likewise, {xl, x2} can exchange order with {x3, x4}.<br>
FIG. 17 provides a pseudo-code representation of a HOA according to one embodiment of the invention. The HOA takes a list of unordered objects as its input, and produces a list of ordered objects as its output. The HOA function starts with running the hierarchical clustering algorithm, which produces the hierarchical structure for H as illustrated in FIG. 16. Step (2) uses the root node (called last merge) in the hierarchy to separate H into IS, a set of objects on the left side of the root node (left offspring of the root node), and rS, a set of objects on the right side of the root node (right offspring of the root node). For the example in FIG. 16, IS = {xl, x2, x3, x4}, and rS={x5, x6}. Step (3) identifies 1H, an object in IS, who is the most similar to rS. This object will be put into the most right position among objects in IS. Likewise, rH in rS is identified. Step (4) calls function HOrdering to provide the order denoted as lO for IS. HOrdering will be explained in the context of FIG. 18. Likewise, step (5) calls<br><br>
HOrdering to obtain rO: the ordered rS.  Finally, 10 and rO are merged to produce O, the ordered objects for H.<br>
FIG. 18 provides a pseudo-code representation of one embodiment of Hordering, a function called by HO A. The inputs to the HOrdering algorithm are: S, a set of unordered objects with hierarchical structure, h, the most left or right objects in S depending on a parameter called "direction," where direction determines whether h is the most left or right object in S. The output of HOrdering is the ordered objects for S. HOrdering has seven steps as follows. Step (1) initializes O to h. Step (2) tests whether S has one object. If the test is positive, the program terminates and returns O. Otherwise, the algorithm continues. Step (3) finds fS, which represents the set of objects merged with O in the tree hierarchy of S. For examples, if 0={xl}, in FIG. 16, fS = {x2}; if 0={xl, x2}, then fS = {x3, x4}. Since fS represents a set of unordered objects, it needs to be ordered. We denote fO as the ordered objects of fS. Two situations are handled separately depending on whether fS has one or more objects. If fS has more than one object, step (4) first finds the closest object fh in fS to O, and then calls HOrdering recursively to order fS. If fS has only one host, fO is set to fS directly. Step (6) adds fO into O depending on the direction parameter. Step (7) tests whether O contains all objects in S. If so, the program stops and returns the list of ordered objects O; otherwise the program loops back to Step (3).<br>
The third algorithm of the invention serves to minimize the order conflicts. Hence, we refer to the algorithm as the minimizing order conflicts (MOC) algorithm. The concept of minimizing order conflicts is introduced to account for the situation that an object is required to be placed in multiple positions in order to satisfy multiple ordering conditions. We will first describe the MOC algorithm for a scatter plot, and then for a parallel coordinate plot.<br>
FIG. 19 depicts an illustrative example of a two-dimensional scatter plot in which the y-axis is host name (a categorical variable) and the x-axis is time. Natural clusters are defined based on events that occur close in time. This results in the clusters CI, C2 and C3 such that: hosts B, D, E, G, and I belong to CI; hosts A, B, E,<br><br>
The third step (2130) orders the clusters found in the first step. This is preferably done in a way that minimizes order conflicts or, equivalently, maximizes resolved potential conflicts. This optimization problem can be further translated into a graph problem as illustrated in FIG. 22 for the illustrative example. In FIG. 22, nodes represent clusters, and arc weights specify the number of potential conflicts between clusters (i.e., |d_{i,j}|). Therefore, ordering clusters to maximize resolved potential conflicts is the same as finding a path that traverses each node exactly once and maximizes the sum of the weights of the arcs traversed. This is the Hamilton path problem, which is NP-complete. Many heuristic algorithms have been developed for this problem. We use a simple, greedy algorithm as described by FIG. 23.<br>
The fourth step (2140) orders hosts within each cluster. The algorithm for ordering hosts within a cluster has the following four steps:<br>
1.	Order the values in $h_{l}-a_{l,2} so that they are sequenced before those in h_{2}.<br>
2.	Order the categorical values in h_{2}-a_{l,2} so that they are sequenced after those in h_{l}.<br>
3.	Position the values in a_{l,2} between those in h_{2}-a_{ 1,2} and h_{ 1 }-a__{ 1,2}.<br>
4.	Within the sets a_{ 1,2}, h__{2}-a_{ 1,2} and h_{ 1 }-a_{ 1,2}, categorical values are ordered arbitrarily.<br>
FIG. 23 details a greedy algorithm for ordering clusters. It is equivalent to the shortest-path algorithm for the well-known Halmilton path problem. The inputs of the algorithm are a list of clusters and a matrix of conflicts between each two clusters. We use cj to represent the j-th cluster, and D(j,k) to represent the conflicts between the j-th and k-th clusters. The output of the algorithm is the ordered list of clusters denoted as oc. In the algorithm, we first initialize the ordered cluster oc. Step 2 then finds two clusters having the smallest number of conflicts. Step 3 sets oc to be {j?k}, and lets the most right element be k and the most left element be j. Step 4 finds cluster j, which has the smallest number of conflicts to the most left element of oc. Step 5 finds cluster k, which has the smallest number of conflicts to the most right element of oc.   Step 6<br><br>
further determines which one, between k and j, to add into oc based on the distance (or conflicts). Steps 4 to 6 are repeated until all elements in c are in oc.<br>
Now, we describe the MOC algorithm for PCP. As we discussed in the context of FIGs. 5 and 6, visual quality of PCP can be improved by ordering categorical values so as to minimize crossovers. The algorithm is very similar to that for a scatter plot as described in FIG. 21, except that, for PCP, we cluster one attribute value based on the associated values of a second attribute value. For example, hosts that emit the same event type are placed into the same cluster. As before, this means that a host can be in many clusters. FIG. 24 describes the procedure of the MOC algorithm for PCP. Step 2410 computes the conflicts between clusters. Steps 2420 and 2430 are applied in the same manner as steps 2130 and 2140 in FIG. 21, respectively.<br>
Referring now to FIG. 25, a block diagram illustrating an exemplary computer system for implementing one or more of the ordering algorithms of the invention is shown. The computer system may comprise a processor 2502 operatively coupled to memory 2504 and I/O devices 2506. It is to be appreciated that the term "processor" as used herein is intended to include any processing device, such as, for example, one that includes a CPU (central processing unit). The term "memory" as used herein is intended to include memory associated with a processor or CPU, such as, for example, RAM, ROM, a fixed memory device (e.g., hard drive), a removable memory device (e.g., diskette), flash memory, etc. In addition, the term "input/output devices" or "I/O devices" as used herein is intended to include, for example, one or more input devices, e.g., keyboard, for inputting data to the processing unit, and/or one or more output devices, e.g., CRT display and/or printer, for presenting results associated with the processing unit and/or a graphical user interface for a end-user. It is also to be understood that "processor" may refer to more than one processing device and that various elements associated with a processing device may be shared by other processing devices. Accordingly, software components including instructions or code for performing the methodologies of the invention, as described herein, may be stored in one or more of the associated memory devices (e.g., ROM, fixed or removable<br><br>
memory) and, when ready to be utilized, loaded in part or in whole (e.g., into RAM) and executed by a CPU. Thus, it is to be understood that the hardware implementation shown in FIG. 25 may preferably be used to implement the ordering engine 810 (and its constituent parts shown in FIG. 11), as well as the elements of a visualization system as shown in FIGs. 7 through 10.<br>
Although illustrative embodiments of the present invention have been described herein with reference to the accompanying drawings, it is to be understood that the invention is not limited to those precise embodiments, and that various other changes and modifications may be affected therein by one skilled in the art without departing from the scope or spirit of the invention.<br><br><br>
Claims<br>
What is claimed is:<br>
1.	A computer-based method of processing multidimensional data, the method<br>
comprising the steps of:<br>
obtaining categorical attributes associated with the multidimensional data;<br>
automatically ordering at least a portion of the categorical attributes associated with the multidimensional data wherein the automatic ordering step arranges the attributes to provide a substantially optimized visualization of the categorical attributes; and<br>
making results of the automatic ordering step available for use in accordance with a data visualization system.<br>
2.	The method of claim 1, wherein the categorical attributes are sequentially ordered based on one or more similarities associated with the categorical attributes.<br>
3.	The method of claim 1, wherein the categorical attributes are hierarchically ordered based on one or more similarities associated with the categorical attributes.<br>
4.	The method of claim 1, wherein the categorical attributes are ordered to substantially minimize ordering conflicts associated with the categorical attributes.<br>
5.	The method of claim 1, wherein the automatic ordering step is performed in association with a preprocessing operation of the data visualization system.<br>
6.	The method of claim 1, wherein the automatic ordering step is performed in association with a data management module of the data visualization system.<br>
7.	The method of claim 1, wherein the automatic ordering step is performed in association with a data viewer module of the data visualization system.<br><br>
8.	The method of claim 1, wherein the substantially optimized visualization includes a scatter plot.<br>
9.	The method of claim-1, wherein the substantially optimized visualization includes a parallel coordinate plot.<br>
10.	The method of claim 2, wherein the sequential ordering step comprises:<br>
calculating feature vectors for the categorical attributes to be ordered;<br>
calculating similarity measures between the feature vectors; and<br>
sequentially  arranging the  categorical  attributes  based on the  similarity<br>
measures.<br>
11.	The method of claim 10, wherein the similarity measure is a distance<br>
measure between feature vectors.<br>
12.	The method of claim 10, wherein the result of the ordering step is a list of sequentially ordered categorical attributes.<br>
13.	The method of claim 3, wherein the hierarchical ordering step comprises:<br>
calculating feature vectors for the categorical attributes to be ordered; calculating similarity measures between the feature vectors; and hierarchically arranging the categorical attributes  based on the  similarity measures.<br>
14.	The method of claim 13, wherein the hierarchical arranging step further<br>
comprises:<br><br>
applying a hierarchical clustering algorithm to the categorical attributes to generate a hierarchical structure representing a partial ordering of the attributes based on similarity; and<br>
applying a recursive algorithm to the hierarchical structure to determine a total ordering of the attributes based on similarity.<br>
15.	The method of claim 14, wherein the recursive algorithm comprises;<br>
separating the hierarchical structure into a first set of attributes including<br>
attributes represented by nodes to the left of a root node and a second set of attributes including attributes represented by nodes to the right of the root node; and<br>
arranging the attributes in one set based on their similarity to the attributes in the other set.<br>
16.	The method of claim 15, wherein the arranging step further comprises:<br>
arranging the attributes in each set based on a direction parameter; and<br>
merging the sets to form a set of totally ordered attributes.<br>
17.	The method of claim 13, wherein the result of the ordering step is a list of hierarchically ordered categorical attributes.<br>
18.	The method of claim 4, wherein the ordering step to substantially minimize ordering conflicts comprises:<br>
calculating clusters of categorical attributes;<br>
generating conflicts matrixes between clusters;<br>
ordering the clusters in accordance with the conflicts matrixes; and<br>
ordering the categorical attributes within each cluster.<br>
19.	The method of claim 18, wherein the result of the ordering step is a list of<br>
categorical attributes ordered to substantially minimize ordering conflicts.<br><br>
20.	Apparatus for processing multidimensional data, the apparatus comprising:<br>
at least one processor operative to: (i) obtain categorical attributes associated<br>
with the multidimensional data; (ii) automatically order at least a portion of the categorical attributes associated with the multidimensional data wherein the automatic ordering operation arranges the attributes to provide a substantially optimized visualization of the categorical attributes; and (iii) make results of the automatic ordering step available for use in accordance with a data visualization system.<br>
21.	The apparatus of claim 20, wherein the categorical attributes are sequentially ordered based on one or more similarities associated with the categorical attributes.<br>
22.	The apparatus of claim 20, wherein the categorical attributes are hierarchically ordered based on one or more similarities associated with the categorical attributes.<br>
23.	The apparatus of claim 20, wherein the categorical attributes are ordered to<br>
substantially minimize ordering conflicts associated with the categorical attributes.<br>
24.	The apparatus of claim 20, wherein the automatic ordering operation is performed in association with a preprocessing operation of the data visualization system.<br>
25.	The apparatus of claim 20, wherein the automatic ordering operation is performed in association with a data management module of the data visualization system.<br><br>
26.	The apparatus of claim 20, wherein the automatic ordering operation is<br>
performed in association with a data viewer module of the data visualization system.<br>
27.	The apparatus of claim 20, wherein the substantially optimized visualization includes a scatter plot.<br>
28.	The apparatus of claim 20, wherein the substantially optimized visualization includes a parallel coordinate plot.<br><br>
29.	The apparatus of claim 21, wherein the sequential ordering operation comprises: (i) calculating feature vectors for the categorical attributes to be ordered; (ii) calculating similarity measures between the feature vectors; and (iii) sequentially arranging the categorical attributes based on the similarity measures.<br>
30.	The apparatus of claim 29, wherein the similarity measure is a distance measure between feature vectors.<br>
31.	The apparatus of claim 29, wherein the result of the ordering operation is a<br>
list of sequentially ordered categorical attributes.<br>
32.	The apparatus of claim 22, wherein the hierarchical ordering operation comprises: (i) calculating feature vectors for the categorical attributes to be ordered; (ii) calculating similarity measures between the feature vectors; and (iii) hierarchically arranging the categorical attributes based on the similarity measures.<br>
33.	The apparatus of claim 32, wherein the hierarchical arranging operation further comprises: (i) applying a hierarchical clustering algorithm to the categorical attributes to generate a hierarchical structure representing a partial ordering of the<br><br>
attributes based on similarity; and (ii) applying a recursive algorithm to the hierarchical structure to determine a total ordering of the attributes based on similarity.<br>
34.	The apparatus of claim 33, wherein the recursive algorithm comprises: (i)<br>
separating the hierarchical structure into a first set of attributes including attributes<br>
represented by nodes to the left of a root node and a second set of attributes including<br>
attributes represented by nodes to the right of the root node; and (ii) arranging the<br>
attributes in one set based on their similarity to the attributes in the other set.<br>
35.	The apparatus of claim 34, wherein the arranging operation further<br>
comprises: (i) arranging the attributes in each set based on a direction parameter; and<br>
(ii) merging the sets to form a set of totally ordered attributes.<br>
36.	The apparatus of claim 32, wherein the result of the ordering operation is a list of hierarchically ordered categorical attributes.<br>
37.	The apparatus of claim 23, wherein the ordering operation to substantially minimize ordering conflicts comprises: (i) calculating clusters of categorical attributes; (ii) generating conflicts matrixes between clusters; (iii) ordering the clusters in accordance with the conflicts matrixes; and (iv) ordering the categorical attributes within each cluster.<br>
38.	The apparatus of claim 37, wherein the result of the ordering operation is a list of categorical attributes ordered to substantially minimize ordering conflicts.<br>
39.	An article of manufacture for processing multidimensional data,<br>
comprising a machine readable medium containing one or more programs which when<br>
executed implement the steps of:<br>
obtaining categorical attributes associated with the multidimensional data;<br><br>
automatically ordering at least a portion of the categorical attributes associated with the multidimensional data wherein the automatic ordering step arranges the attributes to provide a substantially optimized visualization of the categorical attributes;<br>
and<br>
making results of the automatic ordering step available for use in accordance with a data visualization system.<br>
40.	A computer-based method of processing multidimensional data<br>
substantially as herein described with reference to the accompanying drawings.<br>
41.	Apparatus for processing multidimensional data substantially as<br>
herein described with reference to the accompanying drawings.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDA4OC1tYXMtMjAwMCBhYnN0cmFjdCBncmFudGVkLnBkZg==" target="_blank" style="word-wrap:break-word;">0088-mas-2000 abstract granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDA4OC1tYXMtMjAwMCBjbGFpbXMgZ3JhbnRlZC5wZGY=" target="_blank" style="word-wrap:break-word;">0088-mas-2000 claims granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDA4OC1tYXMtMjAwMCBkZXNjcmlwdGlvbiAoY29tcGxldGUpIGdyYW50ZWQucGRm" target="_blank" style="word-wrap:break-word;">0088-mas-2000 description (complete) granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDA4OC1tYXMtMjAwMCBkcmF3aW5ncyBncmFudGVkLnBkZg==" target="_blank" style="word-wrap:break-word;">0088-mas-2000 drawings granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODg4LW1hcy0yMDAwLWFzc2lnbm1lbnQucGRm" target="_blank" style="word-wrap:break-word;">888-mas-2000-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODg4LW1hcy0yMDAwLWNsYWltcyBkdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">888-mas-2000-claims duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODg4LW1hcy0yMDAwLWNsYWltcyBvcmlnaW5hbC5wZGY=" target="_blank" style="word-wrap:break-word;">888-mas-2000-claims original.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODg4LW1hcy0yMDAwLWNvcnJlc3BvbmRhbmNlIG90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">888-mas-2000-correspondance others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODg4LW1hcy0yMDAwLWNvcnJlc3BvbmRhbmNlIHBvLnBkZg==" target="_blank" style="word-wrap:break-word;">888-mas-2000-correspondance po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODg4LW1hcy0yMDAwLWRlc2NyaXB0aW9uIGNvbXBsZXRlIGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">888-mas-2000-description complete duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODg4LW1hcy0yMDAwLWRlc2NyaXB0aW9uIGNvbXBsZXRlIG9yaWdpbmFsLnBkZg==" target="_blank" style="word-wrap:break-word;">888-mas-2000-description complete original.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODg4LW1hcy0yMDAwLWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">888-mas-2000-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODg4LW1hcy0yMDAwLWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">888-mas-2000-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODg4LW1hcy0yMDAwLWZvcm0gMTkucGRm" target="_blank" style="word-wrap:break-word;">888-mas-2000-form 19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODg4LW1hcy0yMDAwLWZvcm0gMjYucGRm" target="_blank" style="word-wrap:break-word;">888-mas-2000-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODg4LW1hcy0yMDAwLWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">888-mas-2000-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODg4LW1hcy0yMDAwLWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">888-mas-2000-form 5.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="207299-a-process-for-synthesising-a-hydroxy-terminated-glycidyl-azide-polymer.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="207301-an-improved-anti-theft-device-for-vehicles.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>207300</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>888/MAS/2000</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>26/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>29-Jun-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>04-Jun-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>18-Oct-2000</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>M/.S INTERNATIONAL BUSINESS MACHINES CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>AMERICA OF ARMONK,NEW YORK 10504.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>JOSEPH L HELLERSTEIN</td>
											<td>41 WOLDEN ROAD,OSSINING, NEW YORK 10562.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06T11/20</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/422,708</td>
									<td>1999-10-21</td>
								    <td>Russia</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/207300-a-method-of-processing-multidimensional-data-in-a-computer-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:34:12 GMT -->
</html>
