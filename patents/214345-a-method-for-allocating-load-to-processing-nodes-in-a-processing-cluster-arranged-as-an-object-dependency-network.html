<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/214345-a-method-for-allocating-load-to-processing-nodes-in-a-processing-cluster-arranged-as-an-object-dependency-network by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:08:04 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 214345:A METHOD FOR ALLOCATING LOAD TO PROCESSING NODES IN A PROCESSING CLUSTER ARRANGED AS AN OBJECT DEPENDENCY NETWORK</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD FOR ALLOCATING LOAD TO PROCESSING NODES IN A PROCESSING CLUSTER ARRANGED AS AN OBJECT DEPENDENCY NETWORK</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method for allocating load to processing nodes in a processing cluster arranged as an object dependency network, the method comprising: establishing at a load allocation function a plurality of load allocation function attributes whose values are dependant on the values of attributes of the processing nodes; receiving requests for processing; determining to which of the processing nodes to allocate the requests for processing based on the load allocation function attributes; and allocating requests for processing to the processing nodes in accordance with that determination.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>CONTROLLING PROCESSING NETWORKS<br>
This invention relates to controlling processing networks, for example to achieve load balancing between multiple processors.<br>
Disthbuted data processing systems are becoming widely used for complex processing tasks. By distributing processing between a number of processors such systems are capable of performing complex tasks rapidly. However, to optimize their performance software that is allocated to a distributed system must be split efficiently between the available processors. Some software is specially written for multiÂ¬processor systems and includes instructions indicating which parts of the software are to be performed in parallel by which processors. However, this does not take account of other tasks that the processors may have to interleave with the software, and it cannot account for configurations of processors that were unknown to the software designer or that have arisen because of partial failure or upgrading of a standard multi-processor system. There is therefore a need for an effective and more generic system of load balancing.<br>
A sophisticated multi-processor data processing system may be considered as cluster of processing nodes (CPUs) and a load balancer function. The load balancer function allocates tasks to the processors according to pre-defined rules. When software for providing a certain service is to be run by the cluster, the processes involved in the software may be divided so that a number of processing nodes are participating in the providing of the service in a load sharing fashion. Those processing nodes are termed a load sharing group. The nodes are not restricted to participating in the providing of only one service; instead multiple software functions can be allocated to a node. In addition a node will always be spending some time executing software related to the maintenance of the cluster and the node itself (i.e. the platform). Therefore the processing node requires some processing capacity just to perform its normal maintenance duties.<br><br>
For each service allocated to a node there will typically be a number of processing entities (processes) executing, each of which provides some part of the service. In some cases there will even be multiple instances of the same process executing to increase parallelism and fault isolation.<br>
The overall performance of the cluster is very dependant on the principle used by the load balancer to allocate load to the available nodes. If a node is overloaded then the results of its processing is likely to be delayed. This can be especially serious when those results are to be used by another processor because serial delays can then build up.<br>
Aspects of the present invention are set out below and in the accompanying independent claims. Preferred aspects of the invention are set out below and in the dependant claims.<br>
Accordingly the present invention provides a method for allocating load to processing nodes in a processing cluster arranged as an object dependency network, the method comprising establishing at a load allocation function a plurality of load allocation function attributes whose values are dependant on the values of attributes of the processing nodes; receiving requests for processing; determining to which of the processing nodes to allocate the requests for processing based on the load allocation function attributes; and allocating requests for processing to the processing nodes in accordance with that determination.<br>
The present invention will now be described by way of example with reference to the accompanying drawings, in which:<br><br>
Figure 1 illustrates the action of dependency in an object dependency network;<br>
Figure 2 illustrates node, process group and process objects, having attributes in an object dependency network;<br>
Figure 3 illustrates correlator, node, process group and process objects, having attributes in an object dependency network;<br>
Figures 4 to 7 illustrate the operation of load balancing functions in a multi- processor cluster; and<br>
Figures 8 and 9 illustrate the propagation of shutdown-related status information through an object dependency network.<br>
The following description explains the application of an object dependency network to implement the controlling function of an adaptive load balancing function in a multi-processor cluster. This provides a feedback mechanism to the allocation of load.<br><br>
A state management subsystem (SM) maintains all the managed objects of the cluster. Each managed object can have various attributes. Each attribute is defined by a name and a value. An attribute value can either be a simple value, or a derived value that is calculated based on some inputs. The dependencies of a derived attribute value can be taken to describe how that value depends on the value of another attribute that Is attached to the same managed object or to another managed object. An attribute value can depend on multiple values and a dependency function describes how the value is calculated based on the values it depends on. The dependency network automatically invokes the dependency function to recalculate the attribute value when any of the values the attribute depends on changes. The managed objects are organized into a hierarchical network using the order of dependencies of their attribute values. This arrangement is illustrated in figure 1.<br>
The managed objects maintained in an object dependency network within the SM have attributes that correspond to the administrative state, operational state, and usage state defined in the CCITT Recommendation X.731 | International Standard ISO/IEC 10164-2. The value of an administrative state attribute can set by the operator via an O&amp;M interface to one of the following: unlocked, shutting down, and locked. An administrative state attribute value set to unlocked means that the software or hardware entity represented by the managed object can perform its normal duties freely. A locked value means that the entity is administratively prohibited to perform its normal duties. A shutting down value means that the entity can process whatever ongoing service requests it has, but not take on any new work, and when the ongoing service requests are finished, the administrative state automatically transitions to the locked value.<br>
The operational state attribute of a managed object can have either the enabled or disabled value and it is controlled by the system (i.e. the object itself or the management system by some means, e.g. supervision). An enabled value means that the entity represented by the managed object is functioning properly and is able to perform its duties normally. A disabled value means that the entity is not functioning properly and is not able to perform its duties (i.e. it is considered faulty).<br><br>
Ultimately the providing of a sen/ice can be reduced to the processing of service requests by processes. Each process has the ability to count the number of service requests it processes, map the number against time, and thus construct a service request rate for itself. The service request rate can be expressed as messages per second, transactions per second, or something similar. In SM each process is represented as a managed object that has a rate attribute which corresponds to the rate of sen/ice requests it is processing and whose value is controlled by that process itself. This arrangement is illustrated in figure 2.<br>
The processes that participate in the providing of a given sen/ice on a given node are grouped into a larger entity that aggregates their work. The service is represented as a process group managed object with its own aggregate rate attribute in the SM. Dependencies between the process group and the processes are defined so that the group determines that aggregate rate attribute by adding together the values of the rate attributes of the processes into a total rate attribute value.<br>
Each node is able to measure the current CPU load that is generated by the processing of the various service requests it is handling. It can be assumed that an increase in the rate of service requests will eventually be reflected as an increase in the CPU load, and a decrease in the rate of service requests will decrease the load. The CPU load can be expressed as the percentage of CPU cycles that are not allocated to the system idle process during a given interval (e.g. over a second). Each node is represented in SM as a managed object with a load attribute.<br>
A load balancing function divides the external load coming to the cluster to the load sharing nodes according to a predefined principle. The load balancer can be programmed to give a certain proportion of the external load to a given node. This proportion can be expressed with a share value (W) which can, for instance, be expressed as an integer. The sum total of share values for all the available nodes (denoted by Wtotai) would then represent the total load that is to be processed by the nodes in the load sharing group.<br><br>
The dependency network described herein comprises a set of nodes, process groups, and the processes themselves. In applying the object dependency network to control load balancing it is useful to add a correlator object whose value depends both on the values of the node load attribute and the process group rate attribute. The correlator object has a nominal load attribute, a nominal rate attribute, and a load share attribute. The nominal load attribute describes what percentage of the CPU should boo used in typical load situation. It should always be significantly less than 100% so that the system can deal with short bursts of heavy load without problems.<br>
The dependency function of the correlator"s load share attribute value is defined so that it will recalculate the load share value when the observed load and observed service rates change in the following manner. Let r, be the ratio of observed rate and the nominal rate, and ri the ratio of observed load and the nominal load. Then a delta function is defined<br><br>
where D is a large decrease (a predetermined negative number), d is a small decrease (a predetermined negative number of smaller magnitude), i is an increase (a predetermined positive number), High is an upper threshold for the load, emw is a lower threshold for the load, 5iow is a iower threshold for the rate, and Sigh is an upper limit for the rate. The thresholds and limits can be expressed as percentages since the ratios are conveniently normalized to one. Other rationales for calculating whether to apply an increase or decrease could be employed.<br><br>
As an altsrnativs, a similar arrangement can be established when the load balancer is not dividing the load based on the nodes, but also between multiple processes in a single node or in multiple nodes. The behaviour of the delta function could be modified accordingly, for example by mapping a proportion of the node"s total CPU usage to a process group.<br>
Then the load share value at a given time t is calculated using the share function based on the previous share value<br>
xhare{l +1)- sliare{t) + delta{rr, n)<br>
Wwtal	1<br>
i-hareiO)<br>
N<br>
where N is the number of nodes in the load sharing group and share(O) represents the initial allocation of work to the nodes.<br>
The setup for the operation of this system is illustrated in figure 3.<br>
The initial allocation can be made more elaborate it needed. However, the effect of the latter equation is that the sum total of all share values represents the total amount of work that can be allocated to the load sharing group.<br>
The rationale behind the above delta function is as follows. If the load ratio is larger than the upper threshold, the node is overloaded and the load balancer should assign less work for it. Thus the load share value should be decreased quite a bit to make a significant reduction in the load. If the load ratio is below the upper threshold, but the rate ratio is above the upper limit, the node is processing more load than allowed, and balancer should assign less work for it, so the load share value should be decreased slightly. If the load ratio is below the lower threshold, and also the rate ratio between the lower threshold and the upper linnit, the node is processing work more efficiently than assumed, and the load balancer can assign more work for it, Thus the load share value can be increased a little. Otherwise the processing of the service requests generates the desired load, and the load balancer should keep<br><br>
sending approximately the same amount of work to the node. Thus the share value should be kept the same. The load share value must then be communicated to the load balancer at suitable, preferably regular, intervals.<br>
The selection of the D, d, and i values, the thresholds and limits, as well as the communication interval determine how quickly the load balancer will react to the changes in the processing capability of a node. The idea behind the large decrease and small incroaso is to implement behaviour similar to the TCP slow start and congestion avoidance algorithrns (see IETF RFC 793, "Transport Control Protocol", September 1981) which will back off rapidly and then increase slowly until the steady state is reached. There should also be lower and upper limits for the share value that correspond to the maximum and minimum portions of the load that the load balancer can assign to a node. The values can be selected so as to achieve a desired performance.<br>
in comparison wlh prior art arrangements, this approach offers the advantage that each correlator can be arranged to recalculate the load share value automatically as the observed load and rate values change. Another advantage is that the calculation is based solely on node local information, which means that the calculation of the load share values can be distributed to each node thus increasing the scalability of the overall system. Also, the system can allocate a suitable amount of work to the nodes regardless of their processing capacity, thus enabling the load sharing group to be constructed from heterogeneous nodes. This means that it is simple to add a new powerful node to the load sharing group, or to allocate some other software functions into an existing node, and the node will automatically take an appropriate share of the load to itself without the load balancer having to be configured in an elaborate way. Similarly, the arrangement can handle the situation where a node is withdrawn from a group due to a fault.<br>
The system described above can provide feedback to and can control the load balancing function to adapt the load imposed on individual nodes to their processing<br><br>
jability v;hile maintaining a very high degree of flexibility. This is illustrated b with reference to figures 4 and 5.<br><br>
elcw<br><br>
Load share values that have been calculated as described above can be aggregated to provide input to an overload control function of the system. To achieve this the dependency network can be augmented with a service aggregation object that has a total work attribute whose value depends on the load share values of all correlators related to a given service in the system. The dependency function of the total work attribute simply sums all load share values together:<br>
where N is the number of active nodes in the load sharing group and sharei(t) denotes the load share value of the ith correlator (i.e. node) at a given time.<br>
If W(t) is less than the load balancer"s sum total of share values (i.e. Wtoiai), then the load sharing group cannot process the load it is exposed to and overload control should be invoked. If, on the other hand, W(t) is more than Wtotai, it means that there is spare capacity in the system. The overload control can be implemented in many ways, but the idea is that through the overload control the number of service requests delivered to a node is somehow reduced.<br>
The principles described above are illustrated in figures 4 to 6.<br>
Figure 4 illustrates a load balancer that receives tasks is the form of an external load and distributes those tasks to nodes 1, 2 and 3, Initially the share values of all the nodes are equal, so sharei(O) = Wtotai / N.<br>
After some time, the share values are recalculated and communicated to the load balancer. (See figure 5). Node1 is operating at the desired load level, so there is no change in its share.   Node2 has spare capacity and its share value is therefore<br><br>
Node3 is overloaded and its share value is decreased. The lead balancer distributes the load in proportion to the shares. The sum of shares is still greater than or equal to Wtotal. so the system is performing correctly.<br>
Figure 6 illustrates a cluster overload situation. The shares for nodes 1 and 2 are decreased, with the result that the sum of the shares is less than Wtotai. Therefore, the cluster as a whole is overloaded. Overload control is invoked to reduce the load.<br>
The aggregation of the load share values can be used as an indication of the need to increase overall processing capacity to meet the increased load. This is a direct consequence of a prolonged need to apply overload control and can be implemented by adding an attribute to the service aggregation object that depends on the total work attribute of the service aggregation object, and time. If a prolonged need to apply overload control is detected, the system can inform the operator of the need to add more processing capacity (i.e. nodes) to the load sharing group.<br>
The nominal load value can be used in conjunction with the overload control to reach the desired level of overall processing capability (i.e. to limit the allow/ed overall processing capability). Over time, the system can in effect learn the correct nominal rate for a correlator In a given node; the nominal rate can be set to be equal to the observed rate if the load share value has not been changed for some period of time. The service aggregation object can also aggregate the rate attributes of the process groups. If the aggregation of the rate attributes is larger than the service request rate the system is designed to meet, and the overload control is not in use, then the system is able to process more work than intended. If there is a need to limit the amount of work the system can handle, the nominal load attributes can be decreased which will automatically start decreasing the share values. If the aggregation of the share values falls below the limit defined above, overload control is invoked and the system will automatically start limiting the amount of work processed by the nodes.<br>
In comparison to overload control mechanisms that have been implemented in the past, this approach uses information calculated by an adaptive load balancing<br><br>
mscicaniSiii to implement ovsrload coritrcl and dimensioning. One advantage of this is that the same simple information that can be used to control the adaptive load balancing function can be used as input to overload control. The computation of the information can be done in parallel in a distributed system.<br>
The arrangement described above also provides a mechanism whereby an operator can intervene to limit the total amount of processing done by the system. This can conveniently be done by reducing the set value of the nominal load. This will have the effect of reducing the processing rate. This might be useful if another party had paid for a set amount of processing on the system: if the system were processing at a higher rate than the other party had paid for then the operator might want to curb the system. To test whether the processing rate was too high the operator could aggregate the rate attributes of the processors and compare that aggregate with the total rate agreed with the other party.<br>
The arrangement described above can address the problems of how to make an indication to the system"s overload control of the need to start reducing the load, how to make an indication to the system {and eventually, to the operator) of the need to increase processing capacity to meet the increased load, how to dimension the system so that a desired level of overall capacity is reached and how to implement all of the above in a distributed fashion to increase the performance and scalability of the system<br>
Simple overall values can be used to control the capacity of the system as a whole and yet allow flexible configuration of the individual nodes (both software and hardware). Detailed hardware information is not needed to control the load balancing function and the system will automatically adjust itself to the current software and hardware configuration.<br>
The load share value can be used as an indication of a possible problem in the node, in the configuration of software executing on the node, or in the load balancing function itself. Should the load share value become and remain less than a pre-set<br><br>
lO"vVsr liiiiii. ii can uS taKsn as sn inuicstion that a node is not able to process evsn the minimum amount of work that the load balancer can assign to it. This can happen if the hardware of the node is simply not powerful enough, the hardware is not functioning properly, the software processing the requests is inefficient or buggy, there is some other software on the node that is consuming the processing capacity, or if the load balancer is not working properly. The probable cause of the problem can be deduced if the system also collects CPU usage data into a CPU usage attribute of the processes and aggregates it to a GPU usage attribute of the process group using the dependency network. If the load share value of the correlator linked to the process group falls below the threshold but the aggregated CPU usage of the group is close to zero, it may mean that there are some other processes not belonging to the process group in question that are using up the CPU and reconfiguration of the software may be in order, if, however, the CPU usage value of the process group is large but the load share value is small it means that a small amount of work burns a lot of CPU cycles. This may be because of problems in the software processing the requests which can be suspected if tfie aggregated rate of the process group is small. On the other hand, if the aggregated rate is large, the processes get a lot of service requests from the load balancer although their load share should be small, which may indicate a problem in the load balancing algorithm. If none of the previous conditions apply, then hardware problems may be the possible cause of the problem.<br>
This arrangement can be used to address the problems of how to notice that a node cannot process the minimum load that can be assigned to it, how to utilise this as an indication of a possible problem in the node or in the load balancing function and how to implement it in a distributed fashion to increase the performance and scalability of the system<br>
Figure 7 illustrates a node overload situation. The sum of the shares is greater than Wtotai but the share for node 3 has fallen below the pre-set lower limit, which in this example Is taken to be 1. In diagnosis of this problem, if the CPU usage for node 3"s process group is low then the overload might be due to a problem in the node itself<br><br>
(for instance due to the malfunction of hardware or othsr software); if the CPU usage for node 3 is high then the overload might be due to a problem in the process group itself (if its rate attribute is small) or in the load balancer algorithm (if the rate attribute is large).<br>
The object dependency network can also be applied to implement administrative control at an appropriate and desired level. This also includes the implementation of graceful shutdown behaviour for various entities in the system.<br>
The values of the administrative state attributes of a node, process group, and a process are linked together using the dependency network so that the administrative state of the process group follows that of the node, and the administrative state of a process follows that of the process group. This set-up allows the operator to control the system at an appropriate level. For example, an operator may not be interested in controlling directly the processes that participate in the providing of a service, but he or she might want to control whether the whole service in a given node is available for use. This is made possible by the fact that if the operator changes the administrative state of the process group to locked, the dependency network automatically sets the administrative states of the processes depending on the process group to locked, and the processes can stop providing the service. Another example is a maintenance operation to the node, where an operator might want to take the physical hardware out of use and replace it with new hardware. This requires that the software running on the node and also on other nodes be informed of the fact. This is made possible by the fact that the administrative states of all process groups on the node depend on the administrative state of the node, and as soon as the administrative state of the node is changed, so are the administrative states of all objects that depend on it.<br>
The graceful shutdown of an entity in the system can also be implemented using the dependency network. For example, an operator might want to express that a node should be taken out for maintenance gracefully, i.e. so that ongoing services on the node are allowed to be finalised before removing power from the node. The shutting down value of the administrative state attribute is propagated from the node to the<br><br>
process group, anu linaiiy lO me processss themssiveo. As soon as the processes have processed all sen/ice requests to completion, they will change their administrative states- to the locked value. A reversed dependency is constructed between the processes and the process group such that if the value of the administrative state of the process group is shutting down, and if the values of the administrative states of all processes belonging to the process group are changed to locked, the value of the administrative state of the process group will also become locked. A similar dependency is constructed between the process groups and the node, so that the value of the administrative state attribute of the node will automatically be changed to locked when all process groups become locked, which means that all service requests have been processed to completion and it is now safe to turn off power without losing any service instances.<br>
This is illustrated in figures 8 and 9. In figure 8, the operator can lock the process group and all processes whose administrative state depends on the process group are automatically locked. Likewise, the operator can take node X out of operation for maintenance by shutting it down and all processes will follow. In figure 9 the operator can take node X out of operation for maintenance by shutting it down gracefully and all processes will follow without interrupting service. When processes become locked, so will the process group, and ultimately the node.<br>
The node may be configured to propagate to a control unit a message indicating that its administrative state has been changed to locked. In response to this message power to the node can be shut off safely.<br>
It should be noted that the hierarchies and dependencies described above are only examples, and the actual system can have more levels of hierarchies. Also, the dependencies can be defined in much more sophisticated ways thus allowing very complex relations to be expressed. The dependency network is a very powerful concept and lends itself to many other uses.<br><br>
I I ic  aysLCiJio  UCOCUL"CU  auuvx:; V^QM  US iiiipldiid iicu in   sOTtvvaic  ui   iiaiuwaic      i i ic<br>
calculations are mainly carried out by the dependency network. It is preferred that implementation is done in a distributed fashion to make the system more scalable. The objects that aggregate attributes of or depend on objects in different nodes are most naturally to be placed into a centralised manager node because they make observations of and deductions regarding the overall system.<br>
The load balancing and the control functions described above are independent of each other.<br>
One potential implementation of the invention is in a server platform that could be used for hosting control and service layer applications (for instance CPS, HSS, SIP application server or IP RAN controllers) in a telecommunication network, especially an all IP network. The server hardware architecture could be based on a loosely coupled network of individual processing entities, for example individual computers. This can afford a high level of reliability and a high degree of flexibility in configuring the platform for different applications and capacity/performance needs. Preferably the hardware of each computer node can be based on de facto open industry standards, components and building blocks. The software can be based on an operating system such as Linux, supporting an object oriented development technology such as C++, Java or Corba. The processing entities are preferably coupled by a network connection, for example Ethernet, rather than via a bus. This facilitates loose interconnection of the processing entities. The architecture suitably comprises two computer pools: the front end IP Directors and the server cluster. The IP Director terminates IPsec (when needed) and distributes service requests further to server cluster (load balancing). The number of IP Directors can be scaled up to tens of computers and server nodes to a much larger number per installation. The IP Director load balances the signalling traffic coming in, typically SIP and SCTP. For SIP, load balancing is done based on call ids. For SCTP: load balancing is done by streams inside one connection. Other load balancing criteria can be used as well (for example based on source or destination addresses).<br><br>
herein either implicitly or explicitly or any generalization thereof, irrespective of whether it relates to the presently claimed invention. In view of the foregoing description it will be evident to a person skilled in the art that various modifications may be made within the scope of the invention.<br><br><br>
1. A method for allocating load to processing nodes in a processing cluster arranged as an object dependency network, the method comprising:<br><br>
4.	A method as claimed in any preceding claim, wherein the load allocation function attributes include rate ratio attributes, each rate ratio attribute corresponding to a respective node and having a value indicating the rate of requests for processing that have been processed by that node in a predetermined time period as a proportion of a nominal rate of requests for processing to be processed.<br>
5.	A method as claimed in any preceding claim, wherein the load allocation function attributes include load ratio attributes, each load ratio attribute corresponding to a respective node and having a value indicating the load that has been processed by<br><br>
that node in a predetermined time period as a proportion   processed.<br>
6.	A method as claimed in claim 5 as dependant on claims 3 and 4, wherein the said step of determining comprises decreasing the load share attribute corresponding to a node by a first amount when the load ratio attribute for the node indicates that the rate of requests for processing that have been processed by that node in a predetermined time period as a proportion of a nominal rate of requests for processing to be processed is less than a first threshold.<br>
7.	A method as claimed in claim 6, wherein the said step of determining comprises decreasing the load share attribute corresponding to a node by a second amount when the load ratio attribute for the node indicates that the rate of requests for processing that have been processed in a predetermined time period as a proportion of a nominal rate of requests for processing to be processed by that node is greater than the first threshold and the rate ratio attribute for the node indicates that the rate of requests for processing that have been processed by that node in a predetermined time period as a proportion of a nominal rate of requests for processing to be processed is less than a second threshold.<br>
8.	A method as claimed in claim 7, wherein the first threshold is greater than the second threshold and the first amount is greater than the second amount.<br>
9.	A method as claimed in any of claims 6 to 8 or claim 5 as dependant on claims 3 and 4, wherein the said step of determining comprises increasing the load share attribute corresponding to a node by a third amount when the load ratio attribute for the node indicates that the rate of requests for processing that have been processed by that node in a predetermined time period as a proportion of a nominal rate of requests for processing to be processed is greater than a third threshold and the rate ratio attribute for the node indicates that the rate of requests for processing that have been processed by that node in a predetermined time period as a proportion of a<br><br>
nominal rats of requests for processing to bs processed is between the third threshold and a fourth threshold.<br>
10.	A method as claimed in claim 9 as dependant on claim 7, wherein otherwise the load share attribute corresponding to the node is unchanged.<br>
11.	A method as claimed in claim 2 or any of claims 3 to 10 as dependant on claim 2, comprising the step of adjusting the value of the nominal rate towards the currently observed rate if the load share attributes have remained substantially unchanged over a predetermined time period.<br>
12.	A method as claimed in claim 5 or any of claims 6 to 11 as dependant on claim 5, comprising the step of reducing the nominal load if the aggregate rate of processing of the nodes of the cluster is determined to greater than a pre-set threshold.<br>
13.	A method as claimed in claim 5 or any of claims 6 to 12 as dependant on claim 5, comprising the step of declaring an error state if the load share attribute corresponding to a node remains less than the first threshold over a predetermined time period.<br>
14.	A processing cluster arranged as an object dependency network, comprising:<br>
a plurality of processing nodes; and<br>
a load allocation function having a plurality of load allocation function attributes whose values are dependant on the values of attributes of the processing nodes and arranged to receive requests for processing, determine to which of the processing nodes to allocate the requests tor processing based on the load allocation function attributes; and allocate requests for processing to the processing nodes in accordance with that determination.<br><br>
15. A method for allocating load to processing nodes in a processing cluster arranged as an object dependency network, substantially as herein described with reference to the accompanying drawings.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDIzMi1jaGVucC0yMDA0LWNsYWltcy1kdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">0232-chenp-2004-claims-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDIzMi1jaGVucC0yMDA0LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">0232-chenp-2004-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDIzMi1jaGVucC0yMDA0LWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">0232-chenp-2004-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDIzMi1jaGVucC0yMDA0LWNvcnJlc3BvbmRlbmNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">0232-chenp-2004-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDIzMi1jaGVucC0yMDA0LWRlc2NyaXB0aW9uLShjb21wbGV0ZSktZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">0232-chenp-2004-description-(complete)-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDIzMi1jaGVucC0yMDA0LWRlc2NyaXB0aW9uLShjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">0232-chenp-2004-description-(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDIzMi1jaGVucC0yMDA0LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">0232-chenp-2004-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDIzMi1jaGVucC0yMDA0LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">0232-chenp-2004-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDIzMi1jaGVucC0yMDA0LWZvcm0tMTkucGRm" target="_blank" style="word-wrap:break-word;">0232-chenp-2004-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDIzMi1jaGVucC0yMDA0LWZvcm0tMjYucGRm" target="_blank" style="word-wrap:break-word;">0232-chenp-2004-form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDIzMi1jaGVucC0yMDA0LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">0232-chenp-2004-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDIzMi1jaGVucC0yMDA0LWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">0232-chenp-2004-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDIzMi1jaGVucC0yMDA0LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">0232-chenp-2004-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="214344-a-novel-compound-of-formula-i-and-pharmaceutical-composition-thereof.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="214346-stabilized-bivalent-hepatitis-a-typhoid-fever-immunization-composition.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>214345</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>232/CHENP/2004</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>31-Mar-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>11-Feb-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>05-Feb-2004</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>NOKIA CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>Keilalahdentie 4, FIN-02150 Espoo,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>PARTANEN, Jukka, T</td>
											<td>Nokia Corporation, Keilalahdentie 4, FIN-02150 Espoo,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 9/50</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/IB2002/003533</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-08-05</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>0119145.1</td>
									<td>2001-08-06</td>
								    <td>U.K.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/214345-a-method-for-allocating-load-to-processing-nodes-in-a-processing-cluster-arranged-as-an-object-dependency-network by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:08:05 GMT -->
</html>
