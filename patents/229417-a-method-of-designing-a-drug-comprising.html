<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/229417-a-method-of-designing-a-drug-comprising by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:06:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 229417:A METHOD OF DESIGNING A DRUG COMPRISING</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD OF DESIGNING A DRUG COMPRISING</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The present invention relates to a method of designing a drug comprising: generating a tree structure for a multibody simulation, wherein the tree structure comprises a plurality of nodes, wherein at least one node has one or more child nodes, wherein each node represents a protein rigid body; -providing a unique numerical identifier for each node such that each child node has a larger numerical identifier than the node from which it depends and the sum of the differences between the numerical identifier for each node and the numerical identifiers for the one or more child nodes corresponding to the node is substantially minimized; determining a reaction load for each node in order from the node having the highest numerical identifier to the node having the lowest numerical identifier; initiating a molecular dynamics simulation or a normal mode calculation of the molecule in Cartesian coordinates, wherein the molecule comprises N atoms; determining the derivative of the dynamic residual, Po, in internal coordinates, in order N2 operations, wherein Pu = Mil, wherein M is mass and iI is the time- derivative of generalized speeds; determining the positions and speeds of the atoms in the molecule using the derivative of the dynamic residual; and outputting the positions and speeds of the atoms in the molecule.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
EFFICIENT METHODS FOR MULTIBODY SIMULATIONS<br>
CROSS-REFERENCES TO RELATED APPLICATIONS<br>
This application is entitled to the benefit of the priority filing date of Provisional Patent Application No. 60/477,237, by Dan Rosenthal, filed 9 June 2003; and Provisional Patent Application No. 60/552,222, by Dan Rosenthal, filed 10 March 2004; both of which are hereby incorporated by reference in their entirety.<br>
BACKGROUND OF THE INVENTION<br>
The present invention is related to the field of numerical methods and, more particularly, to numerical methods used in connection with solving equations of motion for mechanical systems, e.g., multibody mechanical system, particularly mechanical systems used in molecular modeling applications. All of the references cited herein are incorporated by reference for all purposes.<br>
Molecular modeling includes a number of techniques which can be used to simulate various aspects of molecules, including their conformations, dynamic behavior and the like. Typical molecular modeling applications have included enzyme-ligand docking, molecular diffusion, reaction pathways, phase transitions, and protein folding studies. Researchers in the biological sciences and the pharmaceutical, poymer, and chemical industries are starting to use such techniques to understand the nature of chemical processes in complex molecules and to design new drugs and materials accordingly. Naturally, the acceptance of these tools is based on several factors, including the accuracy of the results in representing reality, the size and complexity of the molecular systems that can be modeled, and the speed by which the solutions are obtained.<br>
Molecular or other mechanical system simulations are generally conducted using numerical methods to solve sets of differential equations. The speed of such simulations is therefore limited in part by the speed of the numerical methods employed, and the speed of the calculations and algorithms solved using the numerical methods. The computational speed of a mechanical (e.g., molecular) simulation may be characterized in terms of the order of dependence on the number of degrees of freedom ("DOF") in the system, where the number of DOF is generally proportional to the number of bodies (e.g., atoms) in the system. For example, the computation time of an "order (N)" algorithm scales linearly with the number of DOF in the system, whereas that of an "order (N squared)" (order (N )) algorithm<br><br>
has a quadratic dependence (i.e., it increa. s proportionally to the square of the number of DOF), an "order (N )" algorithm has a cubic dependence, and so-on. As the size of the system (and therefore the number of DOF) grows, algorithms with higher order (N) dependencies can rapidly become prohibitive in terms of computational cost. Accordingly, it is highly desirable to develop algorithms that have the lowest possible order (N) dependence.<br>
Molecular simulations have generally been carried out using either Cartesian coordinates (x,y,z coordinates for each atom or body in the system, each expressed relative to an absolute reference frame) or internal coordinates (typically dihedral or torsion angle coordinates). An advantage of using internal coordinates is that the number of DOF in the system is substantially reduced (e.g., to between about 1/6 and 1/8 of that for Cartesian coordinates), at the cost of increased complexity in at least some of the algorithms used (see, e.g., Rosenthal, WO02/061662, August 8, 2002, "Method for Analytical Jacobian Computation in Molecular Modeling"; or Rosenthal, US 2003/0018455 Al, January 23, 2003, "Method for Analytical Jacobian Computation in Molecular Modeling")<br>
Two exemplary types of molecular modeling techniques are molecular dynamics ("MD") approaches, which simulate the motion of a molecular system through time, and Monte Carlo methods, which generate different states of a molecule or molecular system by making random changes to the atoms or bodies which make up the system, and evaluate the energy of each successive state (see, e.g., Leach, A.R., Molecular Modeling - Principles and Applications 2nd Ed., 2001, Dorset Press, Dorchester, Dorset).<br>
These, as well as other molecular and mechanical modeling techniques, are often formulated so as to make use of the first (gradient, or Jacobian) and/or second (Hessian) derivative matrixes of the conformational energy functions (potential and/or kinetic energy). These derivatives can be readily computed in Cartesian coordinates, but are very difficult to calculate from first principles in intemal coordinates. Accordingly, if one wishes to find the Jacobian or Hessian of the energy (E) or force (F) functions in intemal coordinates, one generally needs to convert the Cartesian Jacobian or Hessian into the corresponding intemal coordinate (e.g., torsion angle coordinate) Jacobian or Hessian.<br>
Although the computational cost of a Cartesian Jacobian is as low as order (N ), generally-applicable prior art methods for converting a Cartesian Jacobian to an intemal coordinate Jacobian have a cubic dependence on N (i.e.,. order (N )). The conversion calculation can thus become a bottleneck when working with large systems. Several methods for speeding up Jacobian computation in the context of molecular modeling (to as low as order N ) have been described (e.g., Gibrat, 1997, "Fast Calculation of first and second<br><br>
derivatives of conformational energy of oligomeric proteins with respect to a set of variables mixing dihedral angles and rigid body variables", J. Chem Phys 94:1234-1256; Noguti &amp; Go, 1983, /. Phys. Soc, Jap. 52:3685), but they suffer from certain limitations as detailed below. Many techniques for calculating the force or energy Jacobian employ the chain rule;<br><br>
where Cartesian coordinates are represented as r and intemal coordinates are represented as<br>
dF q,  —is typically the Cartesian Hessian whenever F itself is obtained as the gradient of a<br>
dr<br><br>
to as the torsion displacement gradient. In the "explicit matrix multiplication method" (see, e.g., Rosenthal, WO02/061662, August 8, 2002, "Method for Analytical Jacobian Computation in Molecular Modeling"; or Rosenthal, US 2003/0018455 Al, January 23, 2003, "Method for Analytical Jacobian Computation in Molecular Modeling", both incorporated herein by reference for all purposes), both the Cartesian Jacobian and the displacement gradient are formed and an explicit matrix multiplication is perfonned. Because of the inordinate memory requirement to store the Cartesian Jacobian for large molecular systems, some special provision is generally made to partially form the Jacobian in blocks. The cost of the matrix multiplication is cubic (order (N )) in the number of atoms. Depending on the force field used, the cost of forming the Cartesian Jacobian can be quadratic (order (N )), The cost of forming the displacement gradient is also quadratic, so this method is eventually dominated by the cubic cost of the matrix multiply.<br>
Methods based on numerical perturbation (see, e.g., Lyness &amp; Moler, 1967, "Numerical differentiation of analytic functions", SIAMJ. Numer. Anal. 4:202-210) have also been described. If the simulation engine employed is able to compute atomic forces, the atomic forces can be viewed as implicit functions of the generalized<br>
finite differences. The overall cost of this scheme is cubic, since each colunm of the Jacobian requires at least one force evaluation. The accuracy of the numerical scheme may also suffer due to round off and truncation artifacts. Complexification techniques (see, e.g., Martins, et al, 2000, "An automated method for sensitivity analysis using complex variables", AIAA 2000-0689) can be used to restore accuracy of the obtained results, but this requires rewriting<br><br>
the entire force field to use complex arithmetic, an impractical requ. ement for many<br>
applications.<br>
Also described in the prior art are methods based on forward mode differentiation<br>
(see, e.g., Bischof, et al, 1992, "ADIFOR: Generating Derivative Codes from Fortran<br>
Programs", Scientific Progranuning 1:11-29), which arise from application of program<br>
augmentation techniques. The application of these methods can be done either with a code<br>
generation program such as Adifor (Argonne National Laboratory and Rice University), or<br>
manually. Application of such a method results in a program that can compute the matrix<br>
dF vector product —z, for a passed-in data vector z. A good use of such a program is to form<br>
dr<br>
the displacement gradient and pass it into the forward mode derivative routine. This still<br>
results in cubic overall cost, but is about three times faster than a numerical finite difference<br>
method, and obtains full accuracy.<br>
hi the method of Gibrat (Gibrat, 1997, "Fast Calculation of first and second derivatives of conformational energy of oligomeric proteins with respect to a set of variables mixing dihedral angles and rigid body variables", J. Chem Phys 94:1234-1256), adapted from Noguti &amp; Go, 1983, (/. Phys. Soc. Jap. 52:3685), the Jacobian or Torsion Hessian is generated in quadratic cost, but is restricted to energy functions expressible as pair potentials. Thus, it is not applicable to simple energy functions such as the 1-4 torsion potential (because the torsion potential is expressed as an additive sum of 4-atom terms), the 1-3 bond angle pair, and other energy functions which are not expressible exclusively as pair potentials. It is also not applicable to a number of other tools used in molecular modeling not expressible exclusively as pair potentials, such as the Generalized Bom Solvent Accessibility ("GBSA") solvent model, which is expressed as a true many-body potential, and is often used m molecular simulations utilizing an implicit solvent model.<br>
The present invention overcomes the aforementioned and other limitations in the prior art, and provides a fast and generally-applicable method to calculate an internal coordinate (e.g., torsion angle) Jacobian at quadratic (order(N )) cost, which can, among other applications, be used to dramatically speed up molecular modeling methods.<br>
SUMMARY OF THE INVENTION<br>
In one embodiment, the present invention provides methods and algorithms useful for converting a Cartesian Hessian into a Torsion Jacobian without limitation to pair-potential<br><br>
energy 1 rms, and for performing such calculation with highly-efficient usage of computer memory. Such methods and algorithms can do the conversion in computation time quadratic in the number of internal coordinates used to model any multibody system, e.g., a molecular system. In a related embodiment, the present mvention provides methods and algorithms useful for computing the stiffness matrix without limitation to pair-potential energy temis, and for performing such calculation with highly-efficient usage of computer memory.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
Fig. 1 illustrates the tree structure of a multibody system.<br>
Fig. 2 is the matrix 	ε for the multibody system shown in Fig. 1.<br>
Fig. 3 A shows symbolically the interaction between two frozen bodies.<br>
Figs. 3B-3F illustrate steps in the calculation of interactions between the two frozen bodies of Fig. 3 A.<br>
Fig. 4 is diagram of a computer system useful for executing methods of the present invention.<br>
DETAILED DESCRIPTION<br>
I.  DEFINITIONS<br>
Unless indicated otherwise, "about" means the stated value + 30%.<br>
Unless indicated otherwise, a "body", in the context of a component of a representation of a molecule, is defined as a unit of the representation which is treated as a single mass or geometric structure for purposes of modeling the molecule. Accordingly, a body can be a representation of an individual atom of the molecule, a collection of atoms, or other abstract system of masses. A "rigid body" is a body that is modeled as rigid (i.e., it does not deform in response to forces exerted on it).<br>
Unless indicated otherwise, a "fast operator implementation" means a method of evaluating matrix multiplication in which elements of the product matrix are computed, used and released "on-the-fly", without the necessity of computing and storing the entire product matrix. A fast order implementation can thus be substantially more efficient (as high as order (N2)) than standard matrix multiplication (order (N3), both in temis of execution speed and memory storage requirements.<br>
Unless indicated otherwise, a "joint" is a connection between two bodies. Common joint types include pin joints, slider joints, and ball joints, but many other joint types are<br><br>
possible, including, but not limited to, free joints, J-joints, cylindrical joints, bearing joints, and combinations of any of the foregoing. For instance, a free joint consists of three orthogonal slider joints combined with a ball joint, and has the full 6 degrees of freedom. A more detailed discussions of joint types and their uses can be found, e.g., in Rosenthal, supra.<br>
Unless indicated otherwise, a "frozen body" at a particular joint or pivot consists of all bodies outboard of the pivot, where the bodies move together as a rigid body.<br>
Unless indicated otherwise, a "computationally-feasible order" refers to any order in wliich a particular sequence of tasks can be executed without altering the ultimate result. This concept is invoked, because in some methods, the order of certain steps is not important, so long as the steps are executed and the result is substantially the same as if they were executed in the order originally presented.<br>
Unless indicated otherwise, the term "in silico' refers to any method or process performed using a computer.<br>
Unless indicated otherwise, a "molecule" is any microscopic structure formed of two or more atoms that are connected by chemical bonds. Non-limiting examples of molecules include proteins (e.g., antibodies, receptors, etc), peptides, lipids, nucleic acids (e.g, natural or synthetic DNA, RNA, gDNA, cDNA,mRNA, tRNA, etc.), lectins, sugars (e.g. forming a lectin/sugar complex), glycoproteins, small molecules, organic compounds, monatomic or polyatomic structures such as salts, metals, etc.<br>
Unless indicated otherwise, a "representation", when applied to a molecule or molecular structure, refers to an abstract description of the molecule or molecular structure for use by a machine, e.g., in a computer simulation. For example, one representation of a molecule is a set of coordinates which collectively defines the positions of atoms or bodies, or some abstract proxy thereof, constituting the molecule. Non-limiting examples of representations of a molecule include X-ray coordinates, "pdb" (Protein Data Bank) files, and the like.<br>
Unless indicated otherwise, the term "significant", when used with reference to "significantly different", "significantly inhibits" or "significantly stimulates", refers to a difference in a quantifiable parameter between the two groups being compared that is statistically-significant using standard statistical tests.<br>
Unless indicated otherwise, a "solvent" refers to any medium which can contain a solute molecule. Non-limiting examples of a solvent include water &amp; other aqueous solvents, as well as organic solvents (e.g., DMSO, lipids, alcohol, etc.). The solvent may be uniform or non-uniform, and may be in solid, liquid or gaseous form.<br><br>
Unless indicated otherwise, a "target molecule" is the primary molecule that is the subject of a molecular simulation. A simulation may have more than one target molecule, e.g., in simulations of 2 or more proteins interacting with one another.<br>
Unless indicated otherwise, a "universally-applicable method" is any method suitable for use with a molecular simulation that is not limited to use with pair potentials.<br>
11.  MULTI-BODY SYSTEMS<br>
In one embodiment, methods of the present invention are used in connection with a multibody system (MBS) implementation of a mechanical system (e.g., an MBS molecular simulation; see, e.g., Rosenthal, supra). The basic abstraction of MBS is that of a collection of joint-connected rigid bodies. One of the bodies, called the base, has special status in that its kinematics is referenced directly to ground. The system graph may contain loops. A loop-breaking algorithm reduces a cyclic graph to a tree, plus a set of cuts. The cuts can occur at joints or bodies. This places all joints in the tree system. A body that was cut by the loop breaking algorithm is recovered by imposing a weld joint. This joint is itself decomposed into a set of six distance constraints. The weld joint reassembles the two pieces of the original body.<br>
An important property of a tree is that the path from any body to any other body is unique. The bodies in the tree are n in number, with the base body typically assigned the label 1. This means that the body labels do not decrease on any path from the base body to any leaf body. A leaf body is one that is connected to a single body. A regular labeling can be achieved by assigning the label n to one of the leaf bodies (there must be at least one). If this body is removed from the graph, there remains a tree with n -1 bodies. Assign the label n- 1 to one of its leaf bodies, and repeat the process until all the bodies have been labeled. The details of MBS implementations of general mechanical systems have been described previously (see, e.g., Rodriguez and Kreutz in Recursive Mass Matrix Factorization and Inversion. JPL Publication 88-11, 1988). The details of MBS implementations of a molecular system, as well as relevant notation, have also been described (see, e.g., Rosenthal, supra).<br>
III.  COMPUTATION OF THE RESIDUAL<br>
In an exemplary embodiment, methods of the invention are applied to a simulation of a system (e.g., a molecular system) represented as a multi-body system having equations of motion in the form Mu = p . The right hand side of this equation is p, the residual, and<br><br>
contains contributions from inertial fore . s, and active forces from the force field. The<br>
Jacobian of the residual is —. Methods of the invention are applicable to calculating<br>
dq<br>
contributions to the residual from the force field representing the active force component. A multibody system embodies a collection of data processing methods that can trigger computation of atomic forces and gather them into elements of the residual vector. These data processing steps can have a high level representation in terms of certain matrix operations, but in fact the actual implementation of these operations is typically in terms of algorithms whose run time scales linearly with problem size. These are the so-called 0{n)<br>
methods, and are taught in the prior art (see, e.g., Rosenthal, supra). According to one aspect of the present invention, however, these 0(n) methods can be applied to the Jacobian<br>
formation step:<br>
For example, the residual is formed from the operator equation<br>
p = HPF	(1)<br>
F is typically a 3nu by 1 vector. Each entry preferably consists of the global Cartesian<br>
components of the total atomic force exerted on a given atom. Matrix operators H,  and P are described by Rodriguez and Kreutz in Recursive Mass Matrix Factorization and Inversion, JPL Publication 88-11, 1988. The force distribution matrix P generates multibody spatial loads acting at the pivots of the multibody system from atomic forces. Thus, one can write:<br>
T = PF	(2)<br>
where T is typically a 6nu by 1 vector. A given force acting upon a particular atom is mapped<br>
to a force and torque acting on the pivot point of the body upon which the atom resides. Thus, a given row of the matrix P corresponds to the spatial load acting on a particular body. The given row has nonzero blocks only for entries corresponding to atoms residing on the particular body. In many multibody formulations of molecular systems, each body typically contains or represents about three atoms. Accordingly, the matrix P is large and sparse, and it does not need to be explicitly formed (see, e.g., Rosenthal, supra). Rather, an algorithm that computes the matrix vector product PF may be used. The runtime of such a computation is linear in the number of atoms (Rosenthal, supra).<br>
It is common in multibody dynamics that the transpose of an operator is also a useftil quantity. In this case the operator PT propagates spatial velocity (linear and angular ) from<br><br>
each body pivot to the atom stations located on the body. An exemplary use of this matri: is for the purpose of computing differential spatial displacements of the atoms in a molecular system.<br>
The matrix  is known as the multibody transition operator. This matrix, acting upon a data vector, has the effect of shifting and accumulating the elements of the data vector from the leaf bodies of the tree down to the base body. For instance, the product T generates R , a 6nb by 1 vector of reaction loads. For a given body, the reaction load element represents the<br>
resultant force and torque about the body inboard pivot of those forces acting on bodies kinematically affected by motion of the body in question about its joint. The evaluation of T is linear in the number of bodies.<br>
To understand , it is useful to first introduce the matrix ε. This (block) matrix is<br>
sparse and super-diagonal, In the ith row, it is filled in only in those columns corresponding to children of body i. For the body diagram shown in Fig. 1, the matrix s. is shown in Fig. 2.<br>
Each non-zero element of є, is a 6x6 matrix. The elements '' shift spatial loads from the<br>
pivot of a child to the pivot of its parent. The transposed elements shift spatial velocity from a parent pivot to the child pivot.<br>
Now, the relationship between  and є can be stated:<br>
t <br>
The meaning of this equation may be better appreciated upon reference to the following illustration, which describes the computation of the spatial reaction load at each pivot, given the spatial load applied to each pivot, with reference to the system shown in Fig. 1. The reaction loads can be computed by the following 0{n) sweep (code sequence):<br><br><br>
These equations accumulate the reaction at each pivot. The sweep starts at the leaf bodies and traverses the tree to the base body. Each body shifts its reaction to its parent body, where it is added to the contribution from its brothers. Notice that the equations make backwards references to previously computed quantities. For instance, R(6) refers to R(7),<br>
which refers to R(8) and i?(12), etc. However, if the algorithm is arranged as presented, no<br>
unsatisfied references are encountered. The correspondence between the operator equation R = 
 <br>
If one wishes to expose the elements of , one can, for example, eliminate the backwards references in the computation of R by performing repeated substitutions, and then identify the matrix elements of . Alternatively, one may employ an algorithmic alternative.<br><br><br>
operator is needed. Therefore, all algorithms which indicate multiplication by  (a dense upper triangular matrix) may proceed in terms ofε a sparse super-diagonal matrix.<br>
To finish the residual computation, the matrix vector product HR projects the elements of the vector R onto the joint freedoms. The matrix H is a block diagonal. Each block is filled with the joint map for a particular joint. The map for a pin joint is a 1x6 vector [/I   O], where the<br>
unit vector X specifies the pin geometry. The matrix vector product HR is easily computed in linear cost, since it represents a sequence of non-recursive dot-products. The operator H has<br>
the following shape, where n is the number of bodies and nu is the number of generalized<br><br>
In view of the foregoing, it can be appreciated that the computation of the residual can be seen as a sequence of 0(n) methods applied to the elements of the atomic forces<br>
computed by the force field. These include, for example, vacuum terms, solvent terms (polar and non-polar), and velocity related terms. Several of these items require quadratic compute time. For example, in many implementations, electrostatics and the GBSA solvent model generally consume the majority of the computational time for force evaluation. Thus, the residual cost is quadratic in the number of atoms. This means that the Jacobian of the residual is of quadratic cost at best, and possibly worse.<br><br><br>
The atomic force vector F   )pears in both the first and second terms. However, the second term only requires the numeric values of the force vector, not knowledge of its analytic form. Thus, this term represents the derivative of a term whose original cost is 0{n), because no new force evaluations are needed during evaluation of this term. One can<br>
thus demonstrate that this term can only give rise to quadratic cost in the Jacobian. This can<br>
be appreciated by noting that that the residual computation can be differentiated using<br>
forward mode differentiation, treating the force vector as a known constant, thereby resulting<br>
in a program whose cost is bounded by a constant times the original program cost (per call),<br>
as described in, e.g., Bischof, et al, 1994, ("Automatic differentiation: obtaining fast and<br>
reliable derivatives - fast" Proc. SIAM Symposium on Control Problems in Industry<br>
Argonne, Preprint MCS-P484-1194). The constant depends on the nature of the intrinsic<br>
functions appearing in the program. The multibody system contains only trigonometric,<br>
single argument functions, in addition to arithmetic operations. Thus, in general, the constant<br>
is typically on the order 1-2 times the original program cost or less, and the second term may<br>
be easily computed in at most quadratic cost for the whole Jacobian. Computation of the first<br>
dF term m the Jacobian (which involves —) is described below.<br>
dq<br><br>
In one embodiment, particularly applicable to multibody system implementations, these operators are used to form the displacement gradient in quadratic cost. Without the use of these operators, the cost would be cubic. This approach makes use of the fact that the displacement gradient is not needed explicitly; only the matrix product with the Cartesian Jacobian is needed. The product can be formed in terms of 0(n) operators since<br>
This is the same operator discussed above in connection with computation of the residual. .Thus, this method yields the internal coordinate (e.g., torsion) Jacobian in linear<br><br>
ost per column, or quadratic cost overall, provided the Cartesian Jacobian is computable in quadratic cost.<br>
The above relations may be combined to yield<br><br>
system, Wj, a generic element of the matrix, reflects the disposition of the bodies of the<br>
multibody system in space. The element is used to compute the derivative of spatial load acting on body j due to a spatial displacement of the pivot of bodyj. The computation of the elements of W is where the connection to the Cartesian Hessian is made, and we have the equation:<br>
  (9)<br>
Some features of this approach bear pointing out: (i) this equation uses Hessian elements. It is guided by the atom list of body i against the atom hst of body j; (ii) since each body typically consists of roughly three atoms, this is a simple computation; (iii) since each atom belongs to only one body, each element of the Cartesian Hessian will contribute to only one element W,j; and unlike prior art methods (e.g., Gibrat, J.F. (1997) "Fast calculation of<br>
the first and second derivatives of the conformational energy of oligomeric proteins with respect to a set of variables mixing dihedral angles and rigid-body variables", J Chem Phys 94,1234-1256), the method described above uses Hessian elements directly. Therefore, there is no restriction to pair potentials. The corresponding quantity Lj in the paper by Gibrat<br>
(supra) is built directly from the atoms of body i against the atoms of bodyj, but in general.<br><br><br>
In a fast operator implementation, the overall computation represents two composed down-loops. The term HW is computed by the following recursive algorithm. First, let Y = W,   Z=HY, This yields<br><br>
As described above, the matrix ε is subdiagonal and is populated with the elements ε(k). One may then find the 'stacked' equations<br><br>
In these equations W1 represents the first (logical) row and W, represents the last (logical) row of W. This is a 6 by 6πb block. Each row of W is computed in terms of prior<br>
rows. The computation Z = HY is trivial, since H has a block-diagonal structure. The second recursion can now be expressed as follows:<br><br>
The operator H can be seen to be operating on the rows of Z . This dovetails nicely with the first recursion, which generated Z in row order. The second recursion only needs to compute elements in a given column up to the diagonal, since the destination matrix is symmetric.<br>
In view of the foregoing, it can be appreciated that the atomic force Jacobian can be contracted to form W. The overall algorithm only requires row (or column access) to the Force Jacobian, and it is not necessary to access the entire matrix at once. It will also be appreciated that the first and second recursions can be interspersed if desired. In this way an element of Y or Z can be released as soon as it has been computed. It is thus not necessai*y to form all of Y or Z in one step.<br>
V. MEMORY-EFFICIENT C OMPUTATION<br>
The above-described method may be implemented in a manner that minimizes the amount of memory necessary to perform the calculations, by more fully exploiting the symmetry of W. One approach to decreasing memory requirements is to use a 'slicing'<br><br>
technique that produces the Cartesia. Hessian in large blocks, and then processing each block. Such a method would be viable, in the sense that it would decrease memory usage, but execution time might suffer. Methods described hereunder were designed to provide a processing scheme that could substantially reduce memory requirements without sacrificing execution speed.<br>
In one embodiment, the method is based on expressing the Torsion Jacobian as<br><br>
The new matrix Ω bears the same relationship to W that the reaction R bears to the applied load T . The matrix W is a, spatial Hessian for the bodies of a multibody system. It is the Hessian that would be relevant for the bodies floating in space, but not connected by joints. Elements of the matrix Ω couple 'nests' of frozen bodies. At each pivot, the frozen body is composed of all bodies outboard of the pivot, the bodies moving together as a rigid body.<br>
A differential spatial displacement at the pivot of each frozen body causes a differential spatial load at the pivot of all the other frozen bodies. Considering a displaced body as the 'source' body, and a body experiencing the load as the 'receiver', it can be appreciated that each source body interacts with each receiver body. However, the spatial moves in a source body originate from the pivot of the frozen body and propagate out through<br>
the action of  to the other bodies m the source system. Each source body produces a differential spatial load on each body of the receiver system through the coupling matrix R^.<br>
The spatial loads are given by W  . The spatial loads of the receiver system are aggregated to the receiver pivot through the action of the operator  acting on (WT)<br>
In a fast operator implementation, Ω can be efficiently computed as follows:<br><br><br>
The final equation provides a basis for computing Ω. Sinceε  is super diagonal (nonzero only above the main diagonal), the term Ωcouples low numbered rows of Ω to<br>
higher numbered rows, but not vice versa. That is, in a given column elements move up the column when Ω is pre-multiplied by ε. Similarly, the term Ω only couples low<br>
numbered columns to higher numbered columns. Elements move left across a given row. The third term couples both early rows and early columns to higher rows and higher columns, but coupling does not occur in the other direction. Elements move either up, left, or up and to the left. The net result is that Ω can always be evaluated in reverse column order, as long as the tree system is regularly labeled.<br>
A desirable labeling is one that minimizes the bandwidth of ε,. The bandwidth of<br>
ε limits the 'reach' of the matrix and determines how far 'back' the backwards references<br>
can extend during the computation of Ω.<br>
By way of example, the above algorithm can be applied to a subset of the system shown in Fig. 1 by evaluating the following equations:<br><br>
The first two equations pick up only the direct contribution of the bodies through the coupling matrix W. The (12,10) element computes the spatial load on frozen body 12 due to spatial displacement of frozen body 10. Frozen body 10 consists of actual bodies 10 and 11. The displacement at the pivot of 10 propagates to 11 through k(l 1) • This displacement produces a spatial load on 12 through the coupling element Ω(12,l 1) . The (12,7) element is<br>
slightly more complicated. Frozen body 7 consists of body 7, plus frozen bodies 8 and 12. These are frozen bodies corresponding to the children of body 7. A displacement at the pivot of body 7 propagates out to its children, couples to the already computed elements of Ω, and generates a load on the pivot of body 12.<br><br>
Without recursion, it would  be necessary to compute over the nest of bodies comprising the frozen bodies of the children. This would become an ever growing list as the computation progressed. With recursion, it is necessary to only visit frozen bodies of children. Also, since each body actually has a small number of children (usually 2 or 3, but in some cases more) the cost per element is relatively small.<br>
The approach described below and illustrated in Figs. 3A - 3F shows a calculation of the interactions between two frozen bodies. The operations described are in fact performed "automatically", in the course of the computing the equations described above, and are shown to allow better appreciation and implementation of the methods. To facilitate keeping track of bodies under consideration and their children, a table, such as Tablel below, may be constructed.<br>
Table 1<br><br>
Turning now to Fig 3 A, the drawing shows an interaction 310 between frozen body 312 and frozen body 314. In this example, a &gt;b; frozen body 312 (the "receiving body") contains body a, its children k, and one grandchild of a; and frozen body 314 (the "sourcing body") contains body b, its children r, and two grandchildren of 6. Interaction 310 may be determined by decomposition via the steps shown in Figs. 3B-3D, performed in any computationally-feasible order: For example, first, direct term 316 between the two individual bodies a and b as shown in Fig. 3B is detemined. Term 318 (obtained from<br>
ΩεT ), produced by frozen body a 320 interacting with the frozen children of b 322 as shown<br>
in Fig. 3C, is then added. The final interaction needed (324) is that between body b 326 against k (328), the frozen children of a, as shown in Fig. 3D. This term is preferably computed indirectly, because body b by itself is not a frozen body. In one embodiment, the interaction of body b against the frozen children of a is computed by subtraction: first, as illustrated in Fig. 3E, the interaction 330 between frozen body b 314 against the frozen children of a 328 is computed, giving rise to terms obtained from є Ω. Then, as shown in<br>
Fig. 3F, interaction 332 between frozen children of a against frozen children є Ω<br>
(term є Ω єT) is subtracted. This leaves the interaction b against the frozen children of a as<br>
shown in Fig. 3D.<br><br>
By way of example, the above-described operations may be applied to the analysis of a portion of the multi-body system shown in Fig. 1. First, any element in which both bodies have children will be a generic case. An example of such an element is Ω(8,6) :<br><br>
Guided by the tabular construction, the matrix can be computed in reverse order. At each step, a particular element of W is accessed. This is the only point at which access to that element of W will be needed. Therefore, W is preferably computed by a method that provides element-by-element access. It is not necessary to store any elements of W. Similar considerations apply to the Cartesian Hessian, since W is built from the Cartesian Hessian.<br>
The situation is a bit different for the matrix Ω. As soon as an element Ωb(i)b(i) has been computed one can generate the (i.j) element of the torsion Jacobian:<br><br><br>
Note that the storage used for this element of Ω is preferably not automatically released until it is known that there will not be any baclkwards references to it later in the algorithm. This can be determined from the known bandwidth of εd, which bounds the<br>
maximum reference possible. For instance, in the multibody system of Fig. 1, body 7 is the parent for body 12. This means that storing 5 columns of Ω will be enough. Similarly, the (7,2) element references elements (7,3), (7,4), (8,2), (12,2), (8,3), (8,4), (12,3), and (12,4). These elements all lie within a band five columns away from (7,2). In practice, storing a small number of columns is generally sufficient to avoid re-computation.<br>
Vn.     COMPUTER SYSTEM<br>
To carry out the calculations described above, a computer system may be used with at least one processor and associated memory subsystem for holding the computer code to instruct the processor to perform the operations described above. Fig. 4 illustrates the basic architecture of such a computer system having a processor 401, a memory subsystem 402, peripherals 403 such as input/output devices (keyboard, mouse, display, etc.), perhaps a coprocessor 404 to aid in the computations, and network interface devices 405, all interconnected by a bus 400. The memory subsystem optimally includes, in increasing order of access latency, cache memory, main memory and permanent storage memory, such as hard disk drives. Given the amount of intensity of computation, it should be understood that the computer system could include multiple processors with multiple associated memory subsystems to perform the computations in parallel; or, rather than having the various computer elements connected by a bus in conventional computer architecture as illustrated by Fig. 4, the computer system might formed by multiple processors and multiple memory subsystems interconnected by a network.<br>
The following examples illustrate but in no way are intended to limit the present invention.<br><br>
EXAMPLE 1 COMPUTATIONAL SPEED COMPARISON OF PREVIOUS METHODS AND METHODS OF THE PRESENT<br>
INVENTION The dynamic residual pu is computed from the atomic forces F as follows:<br>
pu =H 	P F	(20)<br>
The derivatives of pu can be obtained using previous methods by using:<br><br><br><br>
2,   Computation of pu', using the following sequence of operators:<br><br>
The Low-memory Algorithm The low-memory algorithm only stores 0{N) intermediate memory. The expression for the<br>
dynamic residual q-derivative can be written as follows:<br>
  (27)<br>
The matrices W and Ω can be computed in an efficient, element-by-element method: Reorder bodies to minimize the difference m between child and parent index Reserve memory for m columns of matrix Ω for body i=n to 1 for body j=i to 1<br>
) )<br>
  )<br><br>
k	is equal to k mod(;m)<br>
c-	is the set of children of body i<br>
q-	is the set of q-indices for body i<br>
u-	is the set of u-indices for body i<br>
In the above, Einstein summation convention is used. The elements of matrix W are<br>
computed from —- as needed.<br>
dr<br>
EXAMPLE 2 COMPUTATION OF THE JACQBIAN MATRIX The Jacobian matrix consists of 4 blocks<br><br><br>
EXAMPLE 3 COMPUTATION OF THE STIFFNESS MATRIX<br>
Let the system possess nq generalized coordinates and nq generalized speeds. If there are no constraints or quaternion joints, then nq = nu. In this case, the full-rank (non-singular)<br>
stiffness matrix with respect to the independent set of generalized coordinates can be computed directly:<br>
  (33)<br>
However, in the presence of quaternions and/or constraints, nq &gt; u. In this case, the<br>
stiffness matrix can be computed in two steps, the first of which is a subset of the Jacobian computation:<br>
1.	The singular stiffness matrix with respect to the full set of (dependent) generalized<br>
coordinates, is computed as the derivative of the dynamic residual pu:<br>
  (34)<br>
2.	The non-singular stiffness matrix is then computed from this matrix, by elimination of<br>
the dependent generalized coordinates. This can be done using any of a number of<br>
standard approaches. For example, one can use singular-value decomposition of the<br>
constraint matrix. If G represent the constraint matrix, one computes its null space<br>
Z of G , by solving GZ = 0. Then the full-rank stiffness matrix can be computed as:<br><br>
One application of the stiffness matrix is in the computation of normal modes, as is well-known in the art.<br><br>
Results<br>
The above implementation was used to compute —p of lysozyme (-l-/-omegas) and<br>
dq<br>
trypsin (+omegas) using the existing methods and methods of the present invention. The results are summarized in Table 1, below.<br><br>
Speed (PA) is the computational speed (in seconds) using the previous methods described above; speed (MI) is the computational speed (in seconds) using methods of the invention. It can be appreciated that methods of the invention can substantially increase the<br>
computation speed of —p, relative to previously-used methods.<br>
dq<br>
The Table 2 shows the results from the basic algorithm, and the low-memory (LM) implementations of the Fast Jacobian algorithm.<br><br><br>
LM	100	14.6	13.2        5.4       1.6       2.7       3.5<br>
HIV                                                    B	150	15.9	14.5         6.7        1.6       2.7       3.5<br>
Protease                                                                                                                      19<br>
monomer             99         1565       Change	33%	8%                            %<br>
LM	155	23.3	20.9	8.6       2.6       4.2       5.6<br>
10.<br>
Basic	250	25.4	23.0	7        2.6        4.2        5.6<br>
20<br>
Lysozyme	129	1969       Change	38%	8%	%<br>
11.<br>
LM	196	31.6	28.2	9        3.4        5.6        7.3<br>
14.<br>
Basic	320	34.2	30.7	4        3.4        5.6        7.3<br>
17<br>
Caimoduiin	144	2209       Change	39%	8%	%<br>
24.	11.	13.<br>
LM                      380             63.3            56.4            2	7.0           3	9<br>
30.	11.	13.<br>
HIV Basic 626 69.5 62.6 3	7.0 4	9<br>
Protease                                                                                                                            20<br>
dimer	198	3130        Change	39%	9%	%<br>
26.	12.	15.<br>
LM                      405             69.2            61.4            4	7.3           2	5<br>
31.	12.	15.<br>
Basic                  724             74.2            66.1             2	7.3           2	4<br>
15<br>
Trypsin	223	3223        Change	44%	7%	%<br>
64. 16. 27. 37.<br>
P38 subset	LM	867	163.3	145.3	7	3	12<br>
(300	Basic	N/A<br>
residues)	300	4851        Change<br><br>
Scalability<br>
The Cartesian Hessian matrix —F can be large, and may eventually exceed the 32-<br>
dr<br>
bit address space. To resolve this issue, the matrix can be constructed in parts. The<br>
algorithm can be made scalable by operating on a row of the Hessian matrix, constructing<br>
W row-by-row, and construct the corresponding colunms of px'.<br>
While the foregoing is a complete description of the embodiments of the invention, it should be evident that various modifications, alternatives and equivalents may be made and used. Accordingly, the above description should not be taken as limiting the scope of the invention which is defined by the metes and bounds of the appended claims.<br><br><br><br>
WrAT IS CLAIMED IS:<br>
1.	A universally-applicable method of performing a multibody simulation,<br>
comprising<br>
computing a derivative of a dynamic residual (DDR) with respect to a generalized coordinate in order (N ), and<br>
using said derivative in said multibody simulation.<br>
2.	A method of claim 1, wherein said computing comprises<br>
(i) breaking up the DDR into a first term and one or more additional terms, said first term containing a multibody operator and its transpose, and<br>
(ii) evaluating said first term using a fast operator implementation.<br>
3.	A method of claim 2, wherein said DDR takes the form<br><br>
9.        A method of claim 2, wherein said first term is used in the computation of a stiffness matrix.<br><br>
10.	A method of claim 2, wherein said first term is used in the computation of a<br>
Jacobian matrix<br>
11.	A method of claiml, wherein said multibody simulation is a molecular<br>
simulation.<br>
12.	A method of claiml, wherein said multibody simulation is performed using a<br>
computer.<br>
13.	A method of claiml, wherein said generalized coordinate is a torsion angle<br>
coordinate.<br>
14.	A method of performing a simulation with a multibody system, comprising<br><br>
using said torsion Jacobian matrix to detennine characteristics of bodies of said multibody system m space.<br>
15.	A method of claim 14, wherein said characteristics include position and<br>
velocity of said bodies.<br>
16.	A method of claim 14, wherein said simulation is a molecular simulation.<br><br><br>
19        A method of claim 18, wherein said multibody system represents one or more molecule(s) in a molecular simulation.<br>
20.      A method of claim 18, wherein said characteristics include normal modes of said system.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDc1LWNoZW5wLTIwMDYtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">075-chenp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDc1LWNoZW5wLTIwMDYtYXNzaWduZW1lbnQucGRm" target="_blank" style="word-wrap:break-word;">075-chenp-2006-assignement.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDc1LWNoZW5wLTIwMDYtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">075-chenp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDc1LWNoZW5wLTIwMDYtY29ycmVzcG9uZG5lY2Utb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">075-chenp-2006-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDc1LWNoZW5wLTIwMDYtY29ycmVzcG9uZG5lY2UtcG8ucGRm" target="_blank" style="word-wrap:break-word;">075-chenp-2006-correspondnece-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDc1LWNoZW5wLTIwMDYtZGVzY3JpcHRpb24oY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">075-chenp-2006-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDc1LWNoZW5wLTIwMDYtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">075-chenp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDc1LWNoZW5wLTIwMDYtZm9ybSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">075-chenp-2006-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDc1LWNoZW5wLTIwMDYtZm9ybSAzLnBkZg==" target="_blank" style="word-wrap:break-word;">075-chenp-2006-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDc1LWNoZW5wLTIwMDYtZm9ybSA1LnBkZg==" target="_blank" style="word-wrap:break-word;">075-chenp-2006-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDc1LWNoZW5wLTIwMDYtcGN0LnBkZg==" target="_blank" style="word-wrap:break-word;">075-chenp-2006-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="229416-process-for-preparing-an-alpha-1-antitrypsin-solution.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="229418-a-chelating-agent-and-a-method-for-the-preparation-of-radiolabeled-biomolecule-with-the-same.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>229417</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>75/CHENP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>12/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>20-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>17-Feb-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>06-Jan-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>LOCUS PHARMACEUTICALS, INC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>Four Valley Square, 512 Township Line Road, Blue Bell, PA 19422,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>ROSENTHAL, Dan, E</td>
											<td>718 Edge Lane, Los Altos, CA 94024,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>MESHKAT, Siavash, N</td>
											<td>1184 Eagle Valley Court, San Jose, CA 95120,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06G</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2004/018368</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-12-23</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/477,237</td>
									<td>2003-06-09</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/552,222</td>
									<td>2004-03-10</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/229417-a-method-of-designing-a-drug-comprising by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:06:31 GMT -->
</html>
