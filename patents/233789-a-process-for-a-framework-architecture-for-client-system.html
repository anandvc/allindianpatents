<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/233789-a-process-for-a-framework-architecture-for-client-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:53:58 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 233789:A PROCESS FOR A FRAMEWORK ARCHITECTURE FOR CLIENT SYSTEM</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A PROCESS FOR A FRAMEWORK ARCHITECTURE FOR CLIENT SYSTEM</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A handheld client framework system provides a server proxy client (509) that services client requests for network accessible information and determines the server that is most appropriate to supply the requested information and sends information requests packets to that server across the Internet and/or internet. Server responses to information requests are received by the server proxy client. The server proxy client separates the response information into the appropriate data components. Data components are sent to the appropriate client. Presentation and logic components are temporarily stored in a one-behind cache on the client (501). A client will continue to use the presentation and logic components already installed or in the one-behind cache to serve the current user request. Any updates sent by the server proxy client (509) and stored in the one-behind cache are retrieved by the client upon subsequent use by the user.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>A PROCESS FOR A FRAMEWORK ARCHITECTURE<br>
FOR CLIENT SYSTEMS<br>
BACKGROUND OF THE INVENTION<br>
TECHNICAL FIELD<br>
The present invention relates to a process for a framework architecture for<br>
clients systems. More particularly, the invention relates to retrieving and<br>
transmitting data available across a network to personal devices using an<br>
adaptable protocol and server proxy client.<br>
DESCRIPTION OF THE PRIOR ART<br>
Personal data devices have become common accessories in today's technology<br>
driven society. When PDAs, text pagers, cell phones, and personal computers<br>
first came into the marketplace, each device had to have its own custom<br>
architecture. The initial systems paved the way for a multitude of communication<br>
and operating system standards.<br>
However, the wide variety of devices have caused problems in the software<br>
industry. Application programmers must port their programs to each device's<br>
operating system and display capabilities. For example, one PDA may have a<br>
160 x 160 pixel black and white display using the Palm OS while another uses a<br>
180 x 240 color display using WinCE.<br>
An application programmer must take into account the limitations of each device<br>
when creating the user interface for his program. Differing graphics capabilities<br>
between devices make it very difficult to achieve the same look and feel of a GUI<br>
across the varied platforms, for example. The application programmer must take<br>
into account that something that is easily displayed on one device may not be<br>
displayed on another or may not look the same between two devices.<br>
CPU speeds also affect application programs. The efficiency of an application<br>
program must be tweaked for each platform in order for the program to be<br>
viable. Users do not want to use slow programs on their personal data devices.<br>
Additionally, personal devices vary greatly in the available memory and whether<br>
the client software is stored in ROM. Small amounts of RAM make it difficult to<br>
manage data. While having a client software stored in ROM makes it difficult, if<br>
not impossible for the normal consumer, to upgrade.<br>
All of these limitations create problems for application programmers.<br>
A consequence of creating many different versions of a program to support<br>
different personal data devices is that it causes huge headaches in terms of<br>
supporting different code bases. Each code version must be debugged,<br>
updated and supported. When a data packet protocol or operating system<br>
changes, then so must the code base for that system.<br>
One example is Microsoft Corporation's .NET framework which attempts to link<br>
together XML Web services in servers and clients. The .NET framework<br>
requires that all servers and clients communicate using XML and transfer<br>
information in XML. The result is a tightly woven network of XML services. This<br>
approach, however, requires that client devices process all aspects of the data<br>
being requested by users and displayed. It also requires application programs<br>
to be provided and supported for each differing platform. Additionally, the<br>
processing demand on the client systems require more powerful processors as<br>
the complexity of application programs increases.<br>
It would be advantageous to provide a handheld client framework system that<br>
provides a client framework that is easily updateable from a host system and<br>
reduces processing demands on client systems. It would further be<br>
advantageous to provide a handheld client framework system that provides a<br>
programming language that is easily supported across multiple client platforms.<br>
SUMMARY OF THE INVENTION<br>
The invention provides a handheld client framework system. The system<br>
provides a client framework that is easily updateable from a host system and<br>
reduces processing demands on client systems. In addition, the invention<br>
provides a programming language that is easily supported across multiple client<br>
platforms.<br>
A preferred embodiment of the invention provides a server proxy client that<br>
services client requests for network accessible information. The server proxy<br>
client determines the server that is most appropriate to supply the requested<br>
information and sends information requests to that server across the Internet<br>
and/or intranet:<br>
Server responses to information requests are received by the server proxy<br>
client The server proxy client separates the response information into the<br>
appropriate data components. Data components are sent to the appropriate<br>
client Presentation and logic components are temporarily stored in a one-behind<br>
cache on the client. Clients verify with the server proxy client that the client is<br>
using the latest version of presentation and togic components for the particular<br>
task at hand. If the client is not using the latest versions, then it requests an<br>
update from the server proxy client. A client will continue to use the presentation<br>
and logic components lhat currently exist in the one-behind cache to service the<br>
current user request. Any updates sent by the server proxy dient and stored in<br>
the one-behind cache are retrieved by the client upon subsequent use by the<br>
user.<br>
The state of the dient is saved by the server proxy client so that the client is not<br>
dropped when a user, for example, changes from a wired connection to a<br>
wireless connection. The user will not have to reauthenticate the client with the<br>
server proxy client and the user's session will continue as if there were no<br>
interruption.<br>
The invention includes a scripting language that gives the client unlimited flexibility<br>
by allowing the host to modify the client's behavior or add new features at any<br>
time. The feature set can be deployed in stages from the server proxy client<br>
after the client has shipped. Client script updates are sent by the server proxy<br>
client to a client.<br>
Accordingly, the present invention provides a process for a framework<br>
architecture for client systems, comprising the steps of: providing a server proxy<br>
client; providing means on said server proxy client for receiving a client<br>
information request from a client system; providing server determination means<br>
on said server proxy client for determining the proper server to service said client<br>
request; sending said client request to said proper server; receiving said proper<br>
server's response to said client request; wherein said server proxy client act's as a<br>
proxy client for said client system, performing the bulk of data processing for said<br>
client system; wherein said server proxy client updates said client system with<br>
data, presentation, and logic components using a universal data format; wherein<br>
said server proxy client separates raw data from presentation aspects of said<br>
response and places said data into said universal data format; sending said data<br>
to said client system; wherein said server proxy client receives presentation and<br>
logic component updates; and wherein said presentation components updates<br>
are for a specific client device type.<br>
Other aspects and advantages of the invention will become apparent from the<br>
following detailed description in combination with the accompanying drawings,<br>
illustrating, by way of example, the principles of the invention.<br>
BRIEF DESCRIPTION OF THE ACCOMPANYING DRAWINGS<br>
Fig. 1 is a block schematic diagram of the invention's server proxy client<br>
communicating with client devices across different communication media according<br>
to the invention;<br>
Fig. 2 is a schematic diagram of a stream object containing a stock price response<br>
according to the invention;<br>
Fig. 3 is a schematic diagram of a button object according to the invention;<br>
Fig. 4 is a block schematic diagram showing the five layers of a preferred<br>
embodiment of the invention according to the invention;<br>
Fig. 5 is a block schematic diagram of an interface perspective of a preferred<br>
embodiment of the invention's client device and server proxy client according to<br>
the invention;<br>
Fig. 6 is an exemplary hierarchical object tree representing the derivation of<br>
objects according to the invention;<br>
Fig. 7 is a schematic diagram of a form object according to the invention;<br>
Fig. 8 is a schematic diagram of a button object according to the invention;<br>
Fig. 9 is a schematic diagram of a form object containing a button object according<br>
to the invention;<br>
Fig. 10 is a schematic diagram of a stream object containing a stock price<br>
response according to the invention;<br>
Fig. 11 is a schematic diagram of a root object according to the invention; and<br>
Fig. 12 is a schematic diagram of a form object containing data and logic objects<br>
according to the invention.<br>
DETAILED DESCRIPTION OF THE INVENTION<br>
The invention is embodied in a handheld client framework system. A system<br>
according to the invention provides a client framework that is easily updateable<br>
from a host system and reduces processing demands on client systems. In<br>
addition, the invention provides a programming language that is easily supported<br>
across multiple client platforms.<br>
The invention provides a scripting language and client engine that gives a host<br>
system the flexibility to dynamically change the behavior and appearance of a<br>
client system. The client engine is easily adaptable to different client architectures<br>
and user interfaces. The host system includes a proxy client that performs the<br>
bulk of the data processing of the data accessed by a client system.<br>
Referring to Fig. 1, the invention provides a host-controllable architecture for<br>
applications to run on portable (and non-portable) devices such as PDAs, text<br>
pagers, cell phones, and personal computers 102, 103, 104. A server proxy<br>
client 101 is also provided that separates the data and presentation aspects of a<br>
session, each of which is sent independently to a client 102, 103, 104, such that<br>
the data are available without the presentation, e.g., for use independent of the<br>
presentation. The client devices 102, 103, 104, can be connected to the server<br>
proxy client 101 through a wired network 105, phone line 106, or<br>
satellite/wireless connection 107.<br>
The server proxy client 101 obtains data for client requests through the Internet<br>
and/or intranet 108. Data are received by the server proxy client 101 and are<br>
processed into the basic data needed by the client before being sent to the<br>
client 102,103,104. The presentation aspects of displaying data are separately<br>
stored on the server proxy client and represent display properties that are<br>
specific to a particular client application. The separation of data and presentation<br>
components allows the client 102, 103, 104, to reuse the data for other display<br>
forms or to reinterpret the data for other applications.<br>
The invention also provides a persistent proxy client {i.e., the proxy client<br>
component of the server proxy client) at the server proxy client 101 that<br>
maintains state for the client 102, 103, 104, which improves availability, for<br>
example, by allowing a user to switch from one transport, such as Ethernet, to<br>
another transport, such as Ricochet, without losing state or having to<br>
reauthenticate the user.<br>
The invention consists of a client framework and a server proxy client 101 as<br>
noted above. The goal of the client framework is to provide maximum flexibility<br>
by having the client's behavior modifiable by the host. This allows rapid addition<br>
of new features to platforms that might not have a feasible means of updating the<br>
client code directly, such as a PDA with its client code burned in.<br>
The invention accomplishes this flexibility by separating the presentation, logic,<br>
and the data components. This enables each component to be updated<br>
independently, thereby reducing network traffic and superfluous requests to the<br>
i server. Additionally, this framework can be leveraged across several platforms<br>
reducing development time and bug counts for new clients by having a common,<br>
optimized, and tested code base.<br>
The server proxy client 101 handles all requests from clients 102, 103, 104, and<br>
returns the responses in a uniform protocol. This greatly simplifies the<br>
responsibility of the client 102, 103, 104, which no longer has to understand<br>
multiple desktop-centric protocols such as HTTP, IMAP, and SMTP. Additional<br>
features are deployed from the server proxy client 101 as they are developed<br>
and received by the client 102,103,104, on demand.<br>
The invention provides a common framework for building host controlled clients<br>
on various platforms such as the Palm OS, WinCE, Linux, Macintosh, and<br>
Windows. Once a device that has the client code burned into ROM has been<br>
released to customers, it is difficult, at best, to update the client. The invention's<br>
framework addresses this issue and several other difficulties involved with<br>
creating clients on portable devices.<br>
The main goal of the framework is to allow the server proxy client to control and<br>
modify the behavior and feature set of the client without having to update the<br>
client code. Also, a common framework can be leveraged by client<br>
development to reduce bug counts and development time by sharing a<br>
common, optimized, and tested code path.<br>
The invention's fundamental architecture separates client data, presentation, and<br>
logic into distinct components using an XML data model. When a client makes a<br>
request to the server proxy client, the response from the server proxy client<br>
comes down as a binary serialized XML data stream that preserves the semantic<br>
information of its contents. This allows the client logic, defined by scripts, to<br>
identify specific components of the response, make modifications, and utilize the<br>
data in any fashion. Additionally, the data sent to the client can be cached<br>
independent of the presentation, which means that it can be reused by other<br>
forms and displayed or reinterpreted in any fashion by the client logic at a later<br>
time.<br>
With respect to Fig. 2, the response to a stock quote request 201 comes back<br>
as a tree of values 202, each tagged with a name. This information 202 can be<br>
used by the logic on the clients to extract only the desired components of the<br>
request for display.<br>
The presentation component of the client is also an XML data stream consisting<br>
of objects and properties. Properties can be simple, such as integers, strings,<br>
and Boolean values, or complex, such as scripts, or binaries that may contain the<br>
pixel data for an image, or rich text of a news story. Objects can be Ul widgets<br>
such as a button, text field, or pop up menu, which have built in integer<br>
properties such as top, left, height and width. Additional built in properties might<br>
include a string for a caption or contents.<br>
A native application can add built-in properties that make sense in view of the<br>
specific platform in order to better utilize native features such as font, size, color,<br>
and style. This flexibility is inherent in the invention's design in its uniform<br>
treatment of data streams.<br>
Referring to Fig. 3, the data model represents these objects and properties 301<br>
as a simple tree 302 that expresses the layout of individual widgets contained in<br>
the current form.<br>
When the user pushes a button on the form, it can activate a script that sends a<br>
request to the server proxy client, such as a stock quote, and has the logic to deal<br>
with the contents of the server proxy client's response to extract the company<br>
name and current price and use those values to populate the text field<br>
properties. However, the pristine form will be cached by the client so future<br>
requests for that service will display the form immediately, but still allow the user<br>
to make interactive requests such as specifying a different symbol for the stock<br>
quote or a different address to obtain a map. These forms or features are not<br>
burned into the client, rather, they are made available to the client by the server<br>
proxy client.<br>
The invention's architecture includes a scripting language, described below, which<br>
supplies the logic component of the client A script appears as just another<br>
property in the form, but it provides the client with intelligent action. When a user<br>
presses a button in a presentation, a script property associated with the button<br>
executes (as described below). A script can perform many tasks, from validating<br>
input on the form, to making a request to the server proxy client, to being<br>
invoked by an object to extract the desired pieces from a response and insert<br>
them into the appropriate places in the presentation. It might also modify<br>
locations of Ul components to adjust for a specific response from the server<br>
proxy client, or it could modify the data in the response to meet the particular<br>
client's display limitations.<br>
The scripting language gives the client unlimited flexibility by allowing the server<br>
proxy client to modify the client's behavior or add new features at any time. The<br>
feature set is no longer a development issue for the client but instead can be<br>
deployed in stages from the server proxy client after the client has shipped.<br>
Another benefit of having active client-side logic manifests itself in the client's<br>
ability to provide much of its functionality without having a connection to the server<br>
proxy client. Hence, the client can still perform during intermittent or lost coverage<br>
and having a server proxy client connection further enriches the user experience<br>
by allowing the user to pick up where he left off during the intermittent or lost<br>
coverage. Lastly, the ability to update the client from the server proxy client<br>
enhances the clients durability and robustness by allowing certain bugs to be<br>
addressed by scripts when updating the client code directly would not be<br>
feasible.<br>
The strength of the invention is that it offers a means of developing clients that can<br>
be modified and updated after their release. This point cannot be understated. It<br>
may appear as if the invention is a presentation package, but that results from the<br>
fact that the invention must compartmentalize the presentation, data, and logic. In<br>
doing so, the functions and features of the client are defined by the invention's<br>
forms made available to the client from the server proxy client. The active logic<br>
on the client allows that feature set to be much richer than simple HTML and yet<br>
tailored to that particular client. Additionally, the internal structure of the invention<br>
means that the developer instantiates only the portions needed and appropriate<br>
for the specific client, producing lightweight and robust clients quickly and<br>
efficiently.<br>
Building a client that utilizes the invention's framework involves two major facets.<br>
First, the system's kernel must be given a means to access certain common<br>
features of the device, which must usually be routed through the operating<br>
system (OS). Secondly, the native implementation of the client must define the<br>
user interface widgets that are available on the device if support for the<br>
presentation layer is desired.<br>
With respect to Fig. 4, the invention's framework is divided into five layers 401.<br>
The presentation layer 402, an object layer containing the invention's Nachos<br>
objects 404 and the system objects 403, an object runtime layer 405, an<br>
abstraction containing a transport abstraction 407 and a storage abstraction 406,<br>
and a bootstrap application layer 408.<br>
The bootstrap application 408 contains a native implementation of the invention's<br>
kernel, and implements the hooks necessary for operation on the device such as<br>
transport and storage. The bootstrap application 408 can install objects into the<br>
runtime to expose services specific to the device. This layer 408 can host<br>
additional functionality not related to the invention or incorporate other features not<br>
yet supported by the invention. Alternatively, it can act as a simple "glue" layer<br>
to handle device specific issues, such as communications, and implement the<br>
bulk of the user experience by deriving classes from the invention's presentation<br>
layer 402.<br>
The invention defines an abstract base class called NachosSystemlnterface. The<br>
client must derive a class from this base class and define all the virtual functions<br>
that provide the glue between the invention's framework and the native OS of<br>
the device. The virtual functions in this class include access to storage functions<br>
that define a rudimentary file system, a means of sending packets to AOL, image<br>
representation for that device, and the current time in UTC. Through these<br>
mechanisms, the invention provides essential functions such as caching and<br>
persistent storage in a database. This storage could be implemented in the form<br>
of RAM, flash memory, or even a hard drive on a desktop client. The invention<br>
makes no assumptions about the implementation that the native code supplies,<br>
only that it behaves in the fashion described in the NachosSytemlnterface base<br>
class. Although the client can function without these, it would make the client much<br>
slower to respond to requests and preferences or other information could not be<br>
saved between sessions.<br>
The second part of developing a native implementation of the invention requires<br>
integration of the user interface (Ul) components. The invention defines a set of<br>
presentation objects 402 that are abstract representations of common Ul widgets<br>
such as buttons, edit and static text fields, images, checkboxes, popup menus,<br>
etc. The native client is not required to implement ail the widgets that the<br>
invention defines, but any widgets that are implemented must be registered with<br>
the runtime object 405 via the registerClass() method. This allows the client the<br>
flexibility to support only the widgets that make sense on that particular device<br>
without hard-coding any mandates into the invention's kernel.<br>
The native code must derive a class from the invention's base class for each<br>
widget it implements and provide a means of displaying that widget. The<br>
invention does not perform any hit testing, drawing, or changes to the native<br>
widget on the screen. Instead, the derived class must handle events such as the<br>
creation and destruction of the system peer, notification that a property of the<br>
widget has changed due to user input, and the ability to notify the base class that<br>
the widget was clicked or selected. The notification of changes and actions that<br>
the invention receives from the derived classes in the native client code provides<br>
the means of receiving events and input on that particular device.<br>
The invention's architecture also specifies a server proxy client to simplify the<br>
responsibilities of the client application by unifying all of the communications with<br>
the client to a single protocol. This reduces the size and complexity of the client<br>
by eliminating the need to parse multiple protocols. It also means that new<br>
protocols can be addressed by making changes to the server proxy client<br>
instead of having to update client code.<br>
The invention has been designed to make it intrinsically robust. No native<br>
operation on the invention's hierarchy can corrupt the client. Similarly, the<br>
invention's virtual machine (VM) will simply abort the current script if it finds any<br>
unexpected data, byte codes, or illegal access. Still, it is difficult, if not impossible<br>
to test all conditions for such a complex environment. There are several compiler<br>
switches which log statistics and debugging information relevant to most aspects<br>
of the invention, including, but not limited to the script compiler, the script runtime<br>
VM, and the Message Center.<br>
The client can optionally maintain a local database accessible through the<br>
invention. This database will act as persistent storage between sessions to<br>
maintain state information, user preferences, and a local cache.<br>
The server proxy client will be the sole point of communication for all clients. Its<br>
architecture must be robust and scalable. The server proxy client will<br>
communicate with any number of other servers on the back end to create the data<br>
streams that it sends to the clients. However, many clients will not have a direct<br>
connection to the server, but instead will communicate over some wireless<br>
network. Both client and server account for such issues as significant latency and<br>
lack of or intermittent coverage.<br>
The server proxy client becomes the central point of maintenance for the<br>
invention. Once the client has been deployed, it is dependent upon the server<br>
proxy client for much of its functionality. Development of content for clients<br>
requires the definition of request and response data stream formats, server<br>
components to handle the individual requests, and forms for device specific<br>
presentation.<br>
The invention addresses many of the constraints that apply to micro clients by<br>
being a lightweight, cross-platform, client framework. The separation of data,<br>
presentation, and logic allow each component to be independently maintained<br>
and modified. The bulk of the client's features move from native client code to the<br>
VM. Because of this, the end user's experience on the client can be enhanced<br>
and modified without updating the client itself.<br>
Referring to Fig. 5, an interface perspective of the invention's client device 501<br>
and server proxy client 509 is shown. Data requests are sent from the client 501<br>
eitherthrough connectivity medium 1 510 to the connectivity 1 gateway module<br>
502, through direct connection 503, or through connectivity medium 2 511 to the<br>
connectivity 2 gateway module 504 to the protocol handler module 505. The<br>
connectivity gateway modules convert from whatever specific protocol is<br>
required for the connectivity medium to an Internet protocol and is then forwarded<br>
to the protocol handler module 505 in the server proxy client 509. The protocol<br>
handler module 505 interprets the request message and either makes requests<br>
of the Proxy System module 506 or if the request is for system content (such as<br>
presentation or logic components), retrieves system content from the content<br>
storage device 507.<br>
The protocol handler module 505 and the Proxy System module 506 in the<br>
server proxy client 509, contain the current state of the client session between<br>
the network hosts module 508 and the client 501. This client session state is<br>
independent of the state of the connectivity between the client 501 and the<br>
protocol handler module 505. The client session state can freely transition<br>
between the connectivity medium 1 510, connectivity medium 2 511, or the<br>
direct connection 503 without requiring re-authentication, so to other users, the<br>
session is uninterrupted.<br>
The Proxy System module 506 manages the multiple connections to the<br>
network hosts module 508. The Proxy System module 506 provides an<br>
application interface that the protocol handler module 505 uses and implements.<br>
The requests for data are correlated with the responses from the Proxy System<br>
module 506 by the protocol handler module 505 and the data is then formatted<br>
in accordance with the invention's protocol, and a response is sent either through<br>
connectivity gateway 1 module 502 through connectivity medium 1 510, through<br>
direct connection 503, or through connectivity gateway 2 module 504 through<br>
connectivity medium 2 511 to the client 501.<br>
Requests for content to the protocol handler module 505 are handled by loading<br>
the content stream from the content storage device 507. The request contains<br>
information about the state of the content cached on the client device 501, if<br>
applicable. If the cached data is current, then a simple response is sent which<br>
causes the client to reset the expiration date of the cached data. If the cached<br>
data is not current, then this data is then formatted in accordance with the<br>
invention's protocol and a response is sent either through connectivity gateway 1<br>
module 502 through connectivity medium 1 510, through direct connection 503,<br>
or through connectivity gateway 2 module 504 through connectivity medium 2<br>
511 to the client 501. before the data is formatted, it is either compiled before<br>
the formatting (on demand) or precompiled and stored on the storage device<br>
507, which option is chosen is dependent upon whether compiling on demand<br>
becomes a bottleneck in the Proxy System module 506.<br>
Content can be updated on the client 501 by the cache spoiling mechanism<br>
described above. A new version of the content is published to the content<br>
storage device 507 and when requests for the content are made by the client<br>
501, the new version is automatically retrieved from the content storage device<br>
507 and sent to the client 501. Content can be a data, presentation, logic, or any<br>
combination of the three. Although the new version is sent to the client 501, the<br>
old version of the presentation and/or logic will be used by the client 501 to<br>
eliminate latency that might be experienced by the end user.<br>
The new version of the presentation and/or logic are placed in a one-behind<br>
cache on the client 501. The next time the user requests the content, the client<br>
501 will check the one-behind cache to see if a version exists for that particular<br>
content. When the client 501 retrieves content from the one-behind cache, it first<br>
checks whether the content has expired. The client 501 will always use the<br>
currently cached version of the presentation and/or logic from the cache. If the<br>
content has expired, the client 501 will check with the Proxy System module 506<br>
to see if a new version is available. If the Proxy System module 506 determines<br>
that the client 501 has the newest version, an acknowledgement will be sent to<br>
the client 501 to reset the expiration date of the cached content. If the Proxy<br>
System module 506 determines that a newer version is available, the new<br>
version of the presentation and/or logic is sent to the client 501 and placed in a<br>
one-behind cache on the client 501. The version request process described<br>
above repeats if a new version is published to the content storage device 507.<br>
The client architecture is designed to be efficient, portable and flexible. It is<br>
intended to allow for a common code base to leverage many different platforms.<br>
Given the design of the invention's kernel, a developer starting on a new client<br>
has much less to do than on a usual client development. The invention's kernel<br>
itself will take care of most logic and functionality of the application. The<br>
developer will mainly just need to focus on two areas: Ul integration and system<br>
"glue".<br>
For the Ul integration, the invention provides a set of presentation objects that<br>
are abstract representations of common Ul widgets. These include such widgets<br>
as button, rectangle, image, checkbox, etc. However, these are logical entities<br>
only. It is up to the client developer to extend these with versions that will hook<br>
into the Ul layer on the target platform.<br>
The presentation objects are based on the concept of utilizing a native peer.<br>
That is, for each NachosButton, the kernel expects that the client developer<br>
provided the code to create a button in the target platform's desired Ul toolkit. It<br>
is also required that the native button will both accept changes from the<br>
NachosButton to the peer and pass user interactions from the peer to the<br>
NachosButton.<br>
A client developer is not required to implement classes for all presentation<br>
objects. Only those necessary to support desired applications on the target<br>
platform must be present. However, developers are encouraged to implement<br>
as many objects as reasonable. Any classes created by the client developer in<br>
the presentation objects should be registered with the runtime's registerClass()<br>
method. This is how the kernel knows to hook into the classes present for a<br>
given version of a client program, and will not try to utilize unsupported objects.<br>
The main ancestor class is NachosUIObject. This provides support for gluing to<br>
a native peer. The two more important methods are _createSystemPeer() and<br>
_destroySystemPeer(). These functions must handle a call properly at any time<br>
(including calls to _destroySystemPeer before _createSystemPeer).<br>
_createSystemPeer() must be sure to get Its initial state from the properties of<br>
the object to which it is attached. The kernel will call these as needed in order to<br>
maintain a presence in the target platform's Ul. In general, any data and state<br>
should be stored in the subclass of the object in order to free the kernel to<br>
destroy and recreate the native peer as needed.<br>
Subclasses of NachosUIObject include NachosForm and NachosWidget. In<br>
Nachos a NachosForm is the main container in which a Ul may be constructed.<br>
NachosWidget is the base class for all widgets such as buttons, images,<br>
rectangles, etc. Non-widget subclasses of NachosUIObject include NachosTimer<br>
and NachosltemsObject.<br>
Each object may have both built-in and run-time properties. Built-in properties<br>
cannot be deleted nor renamed, and are guaranteed to be present in any<br>
instances. Any additional properties of an object will be its children. These could<br>
be Ul objects, data objects or other properties such as scripts, binaries, integers,<br>
booleans, or strings.<br>
With respect to Fig. 6, an exemplary hierarchical object tree 601 representing the<br>
derivation of objects in the invention is shown.<br>
i NachosForm has the following built-in properties:<br>
caption - the string title of the form to display in the caption area<br>
modal - a boolean to tag the form as modal or non-modal<br>
keepWhiteboard - a flag for preserving data on the whiteboard when the<br>
form is loaded<br>
frozen - the Ul should not draw the form while this is true<br>
persistent - this form and its data will be saved even after it is undisplayed<br>
NachosWidget has the following built-in properties:<br>
left - the placement of the left edge of the widget in the Ul<br>
top - the placement of the top edge of the widget in the Ul<br>
width - the width of the widget<br>
height - the height of the widget<br>
visible - true if the widget is currently visible<br>
enabled - true if the widget is 'active' and will respond to user input<br>
Other objects that derive from NachosWidget may have additional built-in<br>
properties. For instance, a button has a caption property that acts as a label the<br>
button, or a rect widget, which as an integer to denote the fill color of the rectangle.<br>
The coordinates for left and top are absolute coordinates in the display area. Any<br>
part of the display that is reserved for the form's caption does not count for<br>
coordinates in the display area. For example, if the form caption area was at the<br>
top of the form, top=0 would place a widget at the first pixel below the form<br>
caption area.<br>
Some Ul toolkits place native widgets in absolute space and some place them<br>
relative to their parents. It is the job of the client developer to ensure that any<br>
needed transformations of coordinates are done between the NachosWidget<br>
and its native peer.<br>
The other important part for a client developer to implement is the code to "glue"<br>
the invention to the target platform. An implementation of<br>
NachosSystemlnterface needs to be provided to the NachosRuntime upon<br>
initialization. The kernel will then use this implementation to perform its interactions<br>
with the target platform. This includes local storage and network access.<br>
If storage is supported on the target platform, an implementation of<br>
NachosDataStreamlnterface should be supplied, plus the additional needed<br>
methods implemented from NachosSystemlnterface.<br>
An exemplary specification of the invention's scripting language is shown below.<br>
Introduction<br>
The invention's client framework provides a host-controlled, intelligent client. The<br>
concept of host controllability offers distinct advantages over a static client. It<br>
allows the rapid addition of new features to clients on platforms that might not<br>
have a feasible means of updating the client code directly, e.g., devices that<br>
have their client code burned in. Also, unexpected problems with the client can<br>
be circumvented or eliminated by modifying the client's behavior from the host.<br>
Additionally, since a client is more than a dumb terminal that simply displays<br>
information from the host, it maintains much of its functionality even when not<br>
connected to the host. This is particularly valuable on clients that have high<br>
latency connections or that need to function well offline.<br>
The invention achieves this flexibility by separating the presentation, logic, and<br>
the data from each other using an XML data model, which enables each<br>
component to be modified or updated by the host independently of each other.<br>
This document will explain some of the fundamental principles of the invention<br>
while focusing on the invention's scripts. In order to use the scripting language<br>
effectively, the scriptwriter will need to understand the data model in terms of the<br>
invention's properties, the presentation component in terms of the invention's<br>
widgets, and lastly the capabilities of the scripting language itself.<br>
Scripting Properties<br>
The fundamental building block of the scripting language is a property. Every<br>
property has a name and a value. The name acts as a label that can be used<br>
when referring to the property. Names of properties can be of arbitrary length<br>
and consist of any printable character. However, names that start with a letter or<br>
underscore and are followed by any series of letters, numbers, or underscores<br>
are the most easily accessed name from the scripting language. The names of<br>
properties are not case sensitive. Examples of property names are:<br>
The value of the property can be one of several types. Simple value types are<br>
integer, string, and Boolean. These are the most commonly used and properties<br>
that will be directly examined or modified from a script<br><br>
There are more complex properties such as scripts and binaries. In general, the<br>
contents of complex properties cannot be modified from a script, but the<br>
complex property itself can be moved, copied, or deleted. Binary properties<br>
are used for images, large bodies of text, and anywhere you have large "blobs"<br>
of data.<br>
The last kind of property deserves special consideration. It is the object<br>
property.<br>
Objects<br>
An object is unique because it acts as a container for other properties. Like all<br>
properties, an object has a property name, but is also has a "class". The class of<br>
the object designated by the class name defines certain attributes about the<br>
object such as what properties it contains by default and what types of additional<br>
properties that it can contain.<br>
With respect to Fig. 7, an editor tool has been used to create a "form" object 701<br>
named "untitled" 702. When the framework creates a form object 701, it<br>
appends certain built-in properties, which cannot be removed or reordered. A<br>
form will always have a string property named caption 703, and Boolean<br>
properties named modal 704, keepWhiteboard 70S, frozen 706, and persistent<br>
707. Each of these properties governs the characteristics and behavior of the<br>
form such as whether is should maintain its state once it has been displayed (if<br>
persistent 707 is true), or whether it should clear the global area for inter-form<br>
communication (if keepWhiteboard 705 is false). A "form" is one example of an<br>
object class, but many classes exist. Another common class is a "button"<br>
Referring to Fig. 8, all Ul widgets in are actually just objects with certain built-in<br>
properties to control its appearance. The button 801 has a script 802 which will<br>
be called anytime the button object 801 receives an "action" message 803,<br>
described below.<br>
With respect to Fig. 9, a button object 902 created in the form 901 is shown. B y<br>
creating an object inside of another object, the properties can no longer be<br>
expressed as a simple list Instead the form 901 now appears as a hierarchy<br>
where each property is owned by a parent object. The button, myButton 902,<br>
owns the integer property named left 908 and everything below it, while the<br>
form owns the properties named caption 903, modal 904, keepWhiteboard<br>
905, frozen 906, persistent 907, and myButton 902.<br>
The other responsibility of an object besides containment is message handling.<br>
Messages<br>
The unit of communication is a "message" class object. The message has a<br>
source object and a destination object to which it is sent and usually contains<br>
some additional information in an object of class "stream" called parameters. The<br>
parameters object acts as the container for information required for a request or<br>
response. For instance, if a script sends a message requesting a stock quote for<br>
"AOL" the parameters object of the message it sends would have a property<br>
called "sym" with a string value of "aoP.<br>
Referring to Fig. 10, an exemplary response from the server 1001 is shown. In<br>
this case parameters 1002 contains another "data" class object called stream<br>
1003 that holds the stock quote. The script can access each of these properties<br>
individually by name or index.<br>
A message also has an echo object of class "stream", which contains any<br>
properties that were specifically included in the original message that the sender<br>
wants to receive in the reply. This might be used to copy data that generated<br>
the request to the recipient of the reply. For example, in a mail application, a<br>
script might send a "fetchBody" message to the host carrying along the message<br>
ID as an echo, so that when the reply comes back it can associate the response<br>
with the mail without needing a map of ID's to transactions.<br>
Many messages have a corresponding reply message. For instance, a load<br>
message request will return the results in a reply message. Similarly, a save<br>
message sends a notification of completion with a reply message. Most scripts<br>
use blocking calls to wait for the response so the name of the reply isn't generally<br>
needed. However, there are times when the sender might wish to override the<br>
default reply name for asynchronous requests which might require specific reply<br>
names so the appropriate script can process the response. This can be<br>
accomplished by setting the replyName property to the desired message<br>
name. This is used to demultiplex responses coming back to an object much like<br>
the echo parameters are, but in a way that is less general, and often easier to<br>
use.<br>
The Runtime Root<br>
With respect to Fig. 11, in order for a form to be displayed or an object to<br>
receive messages it must by owned by an object known as the runtime 1101.<br>
The runtime is an object of class "roof that serves as the origin of the hierarchy for<br>
all active objects.<br>
The first object of interest is the form stack, forms 1102. When the runtime<br>
displays a "form" object, it takes ownership of the new form by placing it in the<br>
form stack. The form's Ul widgets will be created and displayed (if the Boolean<br>
property, visible, is true). After all the widgets have been created, the runtime<br>
will send the form a "displayed" message so the form can perform any actions<br>
immediately after being displayed. From this point on, the form has the ability to<br>
send and receive messages as long as it is owned by the runtime.<br>
The services object 1103 provides access to a many features that can be<br>
registered at runtime. One service that it provides by default is the database<br>
object 1104, which offers persistent storage. The database can be used to save<br>
preferences, high scores, or other data that should be kept from session to<br>
session like the user's portfolio or address book.<br>
The aol object 1105 under services 1103 acts as the connection to the host.<br>
Messages requesting data from the server will all be sent to the aol object 1105<br>
with the appropriate message name corresponding to the request. For instance,<br>
the stock quote in Fig. 10 was a response to a message named<br>
"getStockQuote" sent to aoA<br>
The trash object 1106 acts as a temporary resting place for deleted properties<br>
and locally created objects. The contents of the trash object 1106 will not be<br>
deleted until all scripts have completed execution because deleted properties<br>
might be referenced by another suspended or blocked script.<br>
The whiteboard object 1107 also acts as temporary storage for communication<br>
between forms, but the lifetime of its contents is governed by a different<br>
mechanism. One of the built-in properties of a form object is a Boolean called<br>
keepWhiteboard. The runtime deletes the contents of the whiteboard object<br>
1007 any time the runtime displays a form that has keepWhiteboard set to false.<br>
This allows data to be passed from form to form as long as the next form is<br>
expecting it. (i.e. keepWhiteboard is true.)<br>
Script Overview<br>
On the client device, the application presents features and services to the user<br>
by using forms. As discussed above, the forms contain Ul widgets, such as text<br>
fields, check boxes, pop-up menus, and buttons. Once the user interacts with a<br>
widget by clicking a button, changing text, or selecting an item in a list, the form<br>
needs to act on that event. It does so by sending a message to the appropriate<br>
widget, but that doesn't accomplish anything in itself. The widget needs to have<br>
a script that corresponds to the message that is being received. For example, a<br>
button receives an "action" message when the user clicks it. If the button widget<br>
has a script property called acton, that script will be executed to handle the<br>
"action" message. Similarly, if that script sent a "load" message to aol to get a<br>
stock quote, then a reply message called "reply" will be sent back to the button<br>
which can handle the response with a script called reply which might display<br>
selected properties from the quote such as the current price.<br>
The scripts are the form's logic component which give the client intelligent<br>
behavior. By creating new forms on the server, the client can get new or<br>
updated functionality simply by loading the form and displaying it. This type of<br>
flexibility shortens the development cycle of the client and increases its longevity<br>
by adding to its feature set after the client has been released.<br>
Script Basics<br>
In order to begin programming Script, the scriptwriter must be familiar with the<br>
conventions of representing data, variables, and expressions. The next few<br>
sections will define the constructs of the language and show simple examples of<br>
how to use them.<br>
Being able to reuse scripts will increase reliability and shorten the time required to<br>
develop new features. However, not all code is written elegantly, so Script<br>
allows you to comment your script using the double slash, as in C++.<br><br>
There are also C style block comments. The notable difference is that block<br>
comments nest in Script. This is a significant change from C.<br><br>
Literal values for integers, Booleans, and strings are represented as follows:<br><br>
The newiine keyword can be used to append a carriage return onto a string<br>
value.<br><br>
It is also possible to use escape sequences in strings with the back slash<br>
'\' followed by 'n' for new line, f for tab, or 'x" followed by a two digit<br>
hexadecimal value.<br><br>
The statements in Script are terminated by carriage returns. There are no<br>
semicolons in the language. In fact, the lexer will gag on the first errant punctuation<br>
it runs across. However, if the statement gets too long, it can be continued on the<br>
next line by putting the backslash as the last character on that line.<br>
.homer.profile = "Springfield Nuclear Power Plant safety inspector" &amp;.", bowler"<br>
", beer drinker" &amp; ™, astronaut" // that was just too much for one line to take<br>
That should be enough for starters, but in order to access data we need to know<br>
how to follow a path in the hierarchy to a given property.<br>
Identifiers and Paths<br>
Scripts allow access to values such as strings, integers, and Booleans that can be<br>
stored in properties, which exist in the form, database, or whiteboard.<br>
Alternatively, values can be placed in temporary variables that only exist during<br>
the execution of the script. Temporary variables must begin with a letter or<br>
underscore and can be followed by any sequence of letters, underscores, or<br>
digits.<br><br>
Path are the means of specifying a location of a property in the hierarchy. The<br>
period is the path separator similar to a slash being the directory separator h<br>
Unix. The basic path components are explicit names, indices, or name<br>
expressions.<br>
Referring to Fig. 12, Barfs age 1204 could be set with the following expression<br><br>
Each of these expressions set Barfs age property to a value of 10. The first<br>
expression starts with me, which begins the path in the same object that contains<br>
the script. In this case the form object, theSimpsons 1201 contains the script.<br>
Following from there, the form owns the simpsons data object 1202, which owns<br>
Bart 1203 Which Owns age 1204.<br>
The second expression uses a shorthand form of me by beginning the path<br>
expression with a period. The third expression shows that paths are not case-<br>
sensitive. The last path is not relative to the script, but starts with at the top of the<br>
form, thesimpsons 1201.<br>
Now consider the annoy 1205 script in Bart 1203. In order to change a property<br>
in Lisa 1206 relative to Bart 1203 the path needs to move up the hierarchy. It<br>
can do so in the following ways:<br><br>
Everything is the same as before, but the parent (or "..") path component<br>
causes the path to ascend the hierarchy one level from the current position, or<br>
from the object that contains the script if it appears as the first part of a path.<br>
Another way to access elements of a path is to use the index of the property. In<br>
a path, the square bracket operator is used to reference properties by index.<br><br>
Another convenient way to access a property is by name using an expression.<br>
This allows the script to operate on different properties at runtime without having<br>
to directly modify the script. Use the parenthesis preceded by a period or the<br>
curly braces to use an expression as a path name. For example, from<br>
Bart.annoy:<br><br>
Expressions and Operators<br>
The most common operation in Script is computing the value of an expression.<br>
Expressions are written using operators familiar to most programmers and<br>
scriptwriters. The operators "*", "/", "+", and "-", are used for multiplication,<br>
division, addition, and subtraction, respectively. The "=" operator pulls double<br>
duty in the language, acting as both the assignment operator and the equality<br>
operator.<br><br><br>
Unlike C and C++, Script is not a strongly typed language. When an integer is<br>
assigned to a string property, Script promotes the integer to a string. If a string<br>
value that represents an integer is assigned to an integer property, the string will<br>
be converted to an integer before the assignment. If a string does not represent<br>
a base ten number, then it will be treated as an integer value of zero. When<br>
converting from Boolean, string values are "True" and "False" and integer values<br>
are 1 and 0. When converting to a Boolean, only the case-insensitive string<br>
value "false" and the integer value 0 will be treated as false. All other values for<br>
strings or integers are true.<br><br>
If the left hand side of an assignment is a property that doesn't exist, that<br>
property will be created as the apparent type of the expression and assigned<br>
the value of the expression.<br>
 or !<br>
The string concatenation operator, "&amp;" is particular to Script, it can be used to<br>
append on string to another.<br><br>
The logical operators are words, rather than symbols, with the exception of the<br>
logical not, which can be written as either "not" or "!".<br><br>
The comparison operator "=" will try to convert its operands to integers, but if<br>
both left and right operands are strings, it will perform a case-insensitive compare.<br>
Certain operators may be used in conjunction with the assignment operator to<br>
simplify expressions.<br><br>
Also, increment and decrement operators can be used as statements, but not on<br>
an expression level.<br><br>
An else clause might also be added to the if statement before the keyword end<br>
as follows:<br><br>
One significant different between conditional statements in Script and C/C++ is<br>
that multiple Boolean expressions will not be short-circuited. The bytecodes<br>
generated by evaluating the entire expression are much smaller than inserting a<br>
check after each Boolean operator followed by a conditional jump. This means<br>
that:<br><br>
Also, any number of conditional statements may be chained together using the<br>
following syntax:<br><br><br>
Loops<br>
Script offers several constructs to facilitate iteration over a block of statements.<br>
The first form of iterator executes the loop a fixed number of times with the<br>
following syntax:<br><br>
The second type of loop statement will continue executing as long as an<br>
expression is true or as long as it is false.<br><br><br>
Perhaps the most familiar form of loop statement is one that uses an iteration<br>
variable and sets a beginning and ending limit as follows:<br><br>
The boundary expressions will only be evaluated once, at the beginning of the<br>
loop. This can either count from a lower bound to an upper bound or from an<br>
upper bound to a lower bound if the down keyword is used.<br><br>
Similar to C or C++ there are also statements to continue on to the next iteration<br>
of the loop or break out of the loop completely. As fate would have it, these are<br>
the "continue" and "break" statements, respectively. They can appear<br>
inside any loop statement.<br><br>
The last type of loop statement touches all the properties owned by a given<br>
object and all of the children below it to an optionally specified depth. If the<br>
depth option is not specified then only the immediate children of the object will<br>
be visited. Alternatively, if all nested properties at arbitrary depths need to be<br>
visited this can be accomplished by using the infinity keyword. Lastly, the<br>
properties can be filtered using the objects Only keyword. This will skip other<br>
properties and only iterate ov&amp;r objects.<br><br>
If the script was intended to set all the .busy properties of the simpsons to<br>
"sleeping" in Figure 6. it could be done with the following loop.<br><br>
This can be simplified by noting that all the properties contained in<br>
forms.simpsons are object, so the objectsOnly filter is not necessary. Also,<br>
because the default iteration depth only visits the immediate children of the<br>
starting object, the depth does not need to be set to a value of one.<br><br>
The invention provides an array property that allows for efficient handling of large<br>
blocks of homogeneous data. The type of information that can be stored in an<br>
array is limited to string, integer, or Boolean values. The array can be created<br>
using the following syntax:<br><br>
The path can be a local variable or a path to the desired location in the hierarchy<br>
including the name of the array property to be created.<br><br>
Now that the array has been created, there needs to be a means of adding<br>
elements to the array. Creating new elements in an array is accomplished with<br>
the insert statement that has the following syntax:<br>
insert expression in path at int_expression<br>
The insert statement will create a new element of the same type of the array, with<br>
a value specified by expression at the index given by int_expression.<br>
The array is one based, rather than C/C++ style zero based arrays. Hence, if<br>
zero is given as the index for the insertion, it will result in an append operation.<br><br>
Individual elements of the array can be removed with the delete statement as<br>
detailed below.<br>
Dealing with Properties and Objects<br>
Accessing the contents of individual properties can be accomplished by<br>
evaluating a path to that property, but what happens if you want to move or<br>
delete a property, or even duplicate an entire object? Script has statements<br>
specifically for those kinds of operations.<br>
In order to delete an object, property, or array element use the delete<br>
statement. In the case of a property, this will actually move the property or<br>
object specified by path to the trash object until all scripts have completed<br>
execution. This is necessary to prevent a script from holding on to a reference to<br>
a property that no longer exists, or even worse, to prevent disaster when the<br>
script deletes itself or the object in which it is contained.<br><br>
The delete operator can also be used with elements in an array. Unlike deleting<br>
a property, the array element will be removed immediately without being placed<br>
in the trash. Use the bracket"[]" operator to specify which element of the array<br>
should be deleted.<br><br>
Use the copy statement to copy a property or object from one location to<br>
another by specifying the source path and a destination path. Optional<br>
parameters to the copy instruction are destination name, which is a string<br>
expression that will be used to rename the property in the new location, and a<br>
destination index, an integer expression that can be used as the index at which<br>
the property should be inserted into the hierarchy. The original property name<br>
will be used if a destination argument isn't supplied. Similarly, the property will<br>
be copied to the object after all properties that currently contained by the object.<br>
Either of these optional parameters may be omitted, but if both occur they must<br>
be used in the order shown.<br><br><br>
The copy statement will not overwrite a property or object if it already exists in<br>
the destination object. In that case, the script must delete the property at the<br>
destination path before copying the new property.<br>
Use the move statement to place a property somewhere else in the hierarchy.<br>
The syntax and function is similar to the copy statement except that the original<br>
property or object will no longer exist in its former location.<br><br>
Each of the previous three statements will work with either simple properties<br>
(strings, integers, Boolean, scripts, or aliases) or objects. Making an assignment<br>
to a path that has a final property that does not exist will create a simple<br>
property, but an object cannot be automatically generated by the same means.<br>
Objects are created via the create statement by supplying the class name of the<br>
desired object and a path and name of the object to be created.<br><br>
Dealing with long paths might be cumbersome and prone to errors so one final<br>
feature of Script provides the scriptwriter with the ability to make a shortcut of<br>
complex paths. By assigning a path of an object to a local variable, the variable<br>
becomes a means of accessing the properties contained in the path. This<br>
improves performance by not re-evaluating the path every time the variable is<br>
used.<br><br>
Shortcuts display a unique quality in that they will follow an object even if that<br>
object is moved to another point in the hierarchy.<br><br>
Calling Scripts and Sending Messages<br>
Many times a script will handle a message that it receives from a widget, such as<br>
an action script handling the message that a button was clicked or a timer expired,<br>
but often those scripts will rely upon other scripts to perform some of the work.<br>
Also, requests to the server for data and forms are often written in the form of a<br>
function call. A function call uses the following syntax:<br>
SCript_path( [parameters] [echo echoParameters] [options optionParameters])<br>
The act of calling a script actually constructs a NACHOS message with the name<br>
of the call and sends it to the object specified by the path.<br><br>
The last component of this function call, annoy, is actually the name of the script or<br>
the message being sent.<br>
Many calls will only have parameters without the additional echo parameters or<br>
message options. The recipient of the message can examine these parameters.<br>
For instance, in order to get a stock quote we can make the call:<br>
quote = aol.getStockQuote(sym:"aol")<br>
In the example above, aol is object that handles the message "getStockQuote".<br>
Additionally, we see the first example of naming parameters. The parameter list<br>
to a function is a comma-separated list of expressions. Each expression may be<br>
preceded by a name then a colon. In this case sym is the parameter name and<br>
"aol" is the value of the parameter. Actually, each parameter is created and<br>
copied by value as a property of the message object "getStockQuote", which<br>
is why the parameters should be named. This allows the handler of the<br>
message on the other side to refer to the parameters by name, rather than<br>
relying upon the order of appearance in the parameter list. If a name is not<br>
supplied, the parameter will be created as a property called "param".<br>
Another example is:<br><br>
This saves the homer object in the database as homerSimpson. The save<br>
message to the database requires two parameters: path, the path in the<br>
database to save the property, and stream: a path to an object or property<br>
which will be saved. Because these parameters are named, the order can be<br>
reversed without consequence.<br><br>
Some message will need to define additional options to specify things such as<br>
whether the message should be encrypted, or how long the system should wait<br>
before it times out the message due to not receiving a response. These<br>
parameters can be put in the options block of the message.<br><br>
This will allow the native implementation a chance to deal with options before<br>
sending the message. The only option handled by the kernel is "timeout" which<br>
specifies in milliseconds how long the kernel should wait for a response before<br>
throwing an exception. The echo parameters are used for asynchronous<br>
messages as discussed below.<br>
All simple properties (e.g., string, integer, Boolean, binary, script) are passed b y<br>
value rather than by reference. Objects are usually passed aliases, which acts as<br>
an implicit reference. Modifying properties contained in the object received as a<br>
parameter will modify the original object. If a message containing aliases leaves<br>
the local hierarchy, such as a request sent to the host, then aliases in the message<br>
will be replaced with a copy of the object referenced by the alias. Most of the<br>
time this is the desired behavior, but this can still be overridden by using the @<br>
operator.<br><br>
Sometimes an object may already have code to respond to a message. If the<br>
object has such native code, which can respond to a given message, but also<br>
contains a script handler for the same message, the script handler will override the<br>
native code. Hypothetically, a native application might have code to handle a<br>
message called shutdown(), but a script might be used to intercept that message<br>
and determine if the caller has privileges to issue such a command. In this case,<br>
after confirming the privileges of the caller, the script may call the utility function,<br>
passMessage(), which will abort the script at the point of the call and allow the<br>
object to handle the message with its native code.<br>
Aliases have a special behavior when used as parameters in a message. If the<br>
recipient object of the message is local {i.e., the object lives somewhere under<br>
the same runtime root as the sender) then an alias property will be sent as an<br>
alias in the message. This happens because the recipient can resolve the alias<br>
to the object to obtain any properties owned by the object referenced by the<br>
alias. However, if the message is sent off the local environment, the alias<br>
property will be replaced by the object that it references. This can cause a<br>
dramatic increase in size of the message because the underlying object and all of<br>
the properties it contains will be copied to the message. In many cases, this is<br>
the desired effect, but if an alias should not be resolved when sent over the wire,<br>
it can be marked as a persistent airs with the @ operator.<br><br>
Blocking calls<br>
The default behavior of a function call is to block until the function that has been<br>
called returns. This allows the calling script to process the result directly rather than<br>
have another script handle the response. Referring back to Fig. 9. the last value<br>
of a stock quote can be displayed using the library routine debug () as follows:<br><br>
There is a lot going on in that last statement. First, a getStockQuote message is<br>
sent to the services. aol object. The script will wait until the response comes<br>
back before executing any more statements. Once the reply message returns,<br>
the suffix path, . stream, aol. lastvalue, gets the desired data from the<br>
parameter object of the message. This is displayed using the library routine<br>
debug().<br>
Asynchronous calls<br>
By placing the reserved word async in front of a function call, the script will send<br>
the message to the object and continue executing without waiting for a response.<br>
This is more like posting a message than calling a function. Generally this means<br>
that another script will handle the response to the message as well. The<br>
example above can be recreated using two scripts that send the message<br>
asynchronously and handles the response in another script.<br><br>
Notice that the first script displays "finished" instead of waiting for the response<br>
message.<br>
Asynchronous calls present a problem not found with a blocking calls: the script<br>
handling the response is different from the script that initiated the request.<br>
Sometimes the script handling the response must know certain information<br>
pertaining to the original request in order to handle the response properly. In<br>
such a case, echo parameters facilitate the passing of information from the request<br>
to the response. Any parameters passed in the echo block will be moved to the<br>
message response and sent back. The echo keyword is used before the block<br>
or echo parameters as below:<br><br>
Echo parameters should be used judiciously because all echo parameters are<br>
sent round trip across the network.<br>
Return Values<br>
The return statement allows the script to terminate execution before reaching<br>
the end or pass a value back to the caller. Any expression following a return<br>
statement will be evaluated and its result will be returned to the script that called<br>
the one currently executing.<br><br>
Exception Handling<br>
Script allows the scriptwriter to handle runtime errors in the script with try/catch<br>
blocks. The syntax is as follows:<br><br>
Any errors that occur between the try and the catch statement will cause the<br>
script to jump to the beginning of the statement list following the catch<br>
statement. Inside the catch block the script can reference a special object by<br>
specifying the path error. This object has an integer property, type, and a<br>
string property, message, which give the error number and a short description of<br>
the error, respectively.<br><br><br>
Library Functions<br>
The VM provides a set of built in functions for commonly used features such as<br>
string manipulation and random number generation. The names of these<br>
functions are case insensitive. However, unlike when sending messages or<br>
calling scripts, the parameters to these library functions aren't named, but rely<br>
upon the order of appearance in the argument list. Some of the parameters<br>
have default values as listed in the specification below. The default value can be<br>
overridden by including that parameter when calling that particular function. When<br>
two default parameters exist, the apparent type of the parameter is used to<br>
distinguish which value is being overridden. An example of this would be the<br>
find () function with has a source string, a search pattern, a default starting<br>
position, and a default Boolean to ignore case. If only three parameters are listed<br>
in the call, then an integer value would specify the starting position while a<br>
Boolean would indicate case sensitivity.<br><br>
String Functions<br>
Unlike the C/C++ library functions, the functions in this library do not modify the<br>
source string and all indices are 1 based rather than 0 based. Functions return the<br>
result of the operation, but the original arguments are left untouched. In many<br>
cases it will be necessary to assign the result back to the source string.<br>
(e.g. .foo = replace(.foo, " apples", " oranges")<br>
Although the invention is described herein with reference to the preferred<br>
embodiment, one skilled in the art will readily appreciate that other applications<br>
may be substituted for those set forth herein without departing from the spirit and<br>
scope of the present invention. Accordingly, the invention should only be<br>
limited by the Claims included below.<br>
WE CLAIM:<br>
1. A process for a framework architecture for client systems, comprising the<br>
steps of:<br>
providing a server proxy client;<br>
providing means on said server proxy client for receiving a client<br>
information request from a client system;<br>
providing server determination means on said server proxy client for<br>
determining the proper server to service said client request;<br>
sending said client request to said proper server;<br>
receiving said proper server's response to said client request;<br>
wherein said server proxy client acts as a proxy client for said client<br>
system, performing the bulk of data processing for said client system;<br>
wherein said server proxy client updates said client system with data,<br>
presentation, and logic components using a universal data format;<br>
wherein said server proxy client separates raw data from presentation<br>
aspects of said response and places said data into said universal data format;<br>
sending said data to said client system;<br>
wherein said server proxy client receives presentation and logic<br>
component updates; and<br>
wherein said presentation component updates are for a specific client<br>
device type.<br>
2. A process as claimed in Claim 1, wherein said logic component updates<br>
are shared between different client device types.<br>
3. A process as claimed in Claim 1, comprising the step of:<br>
providing a one-behind cache on said client system; and<br>
wherein said client system checks said one-behind cache for any<br>
presentation or logic components relating to a user's request;<br>
wherein if any components relating to a user's request exist in said one-<br>
behind cache, said client system checks if said components have expired;<br>
wherein said client system uses said components to service the user's<br>
request.<br>
4. A process as claimed in Claim 3, wherein if said components have expired,<br>
said client system requests any current versions of the expired components from<br>
said server proxy client, wherein said server proxy client checks the current<br>
version of a requesting client's presentation and logic components, if any of the<br>
presentation and logic components requires updating, then said server proxy<br>
client retrieves the latest version of any of the presentation and logic components<br>
and sends it to the requesting client, and wherein the requesting client stores the<br>
latest version of any of the presentation and logic components in said one-behind<br>
cache.<br>
5. A process as claimed in f Claim 1, comprising the step of:<br>
sending said presentation and logic component updates to a client system.<br>
6. A process as claimed in Claim 1, wherein said client system uses said<br>
data and presentation components to create displays to a user.<br>
7. A process as claimed in Claim 1, wherein said client system reuses said<br>
data component for other display purposes.<br>
8. A process as claimed in Claim 1, comprising the step of:<br>
providing means on said server proxy client for saving a client system's<br>
state on storage device; and<br>
wherein the saved client system's state allows said server proxy client to<br>
continue a client system's session when the client system changes connection<br>
methods to or loses coverage with said server proxy client.<br>
9. A process as claimed in Claim 1, comprising the step of:<br>
providing a scripting language;<br>
wherein said logic component updates are written in said scripting<br>
language;<br>
wherein said server proxy client compiles scripts written in said scripting<br>
language into executable bytecodes;<br>
wherein said server proxy client updates said client system's features by<br>
sending said client system said executable bytecodes; and<br>
wherein said client system executes said executable bytecodes in<br>
response to a user's input.<br>
10. A process as claimed in Claim 9, wherein a client system's presentation<br>
aspects are controlled using said scripting language.<br>
11. A process as claimed in Claim 1, wherein communication between said<br>
server proxy client and said client system is via a binary encoding of an XML<br>
data stream.<br>
12. A process for dynamically configuring client systems, comprising the steps<br>
of:<br>
providing a host server;<br>
providing a scripting language;<br>
wherein said host server compiles scripts written in said scripting<br>
language into executable bytecodes;<br>
wherein said host server, upon receipt of a request for specific up to date<br>
presentation components and/or executable bytecodes from a client system,<br>
checks if the client system's original presentation components and/or executable<br>
bytecodes have expired;<br>
wherein said host server updates the client system's features by sending<br>
the client system updated presentation components and/or executable bytecodes<br>
if the original presentation components and/or executable bytecodes on the client<br>
system have expired; and<br>
wherein a client system executes presentation components and/or<br>
executable bytecodes in response to a user's input.<br>
13. A process as claimed in Claim 12, wherein said scripts define program •<br>
logic.<br>
14. A process as claimed in Claim 12, wherein said scripts create and control<br>
user interface displays.<br>
15. A process as claimed in Claim 12, wherein said client system receives<br>
requested network information from said host server separated into data and<br>
presentation components.<br>
16. An apparatus for a framework architecture for client systems, comprising:<br>
" a server proxy client;<br>
means on said server proxy client for receiving a client information request<br>
from a client system;<br>
server determination means on said server proxy client for determining the<br>
proper server to service said client request;<br>
a module for sending said client request to said proper server;<br>
a module for receiving said proper server's response to said client<br>
request;<br>
wherein said server proxy client acts as a proxy client for said client<br>
system, performing the bulk of data processing for said client system;<br>
wherein said server proxy client updates said client system with data,<br>
presentation, and logic components using a universal data format;<br>
wherein said server proxy client separates raw data from presentation<br>
aspects of said response and places said data into said universal data format;<br>
a module for sending said data to said client system;<br>
wherein said server proxy client receives presentation and logic<br>
component updates; and<br>
wherein said presentation updates are for a specific client device type.<br>
17. An apparatus as claimed in Claim 16, wherein said logic component<br>
updates are shared between different client device types.<br>
18. An apparatus as claimed in Claim 16, comprising:<br>
a one-behind cache on said client system; and<br>
wherein said client system checks said one-behind cache for any<br>
presentation or logic components relating to a user's request;<br>
wherein if any components relating to a user's request exist in said one-<br>
behind cache, said client system checks if said components have expired;<br>
wherein said client system uses said components to service the user's<br>
request.<br>
19. An apparatus as claimed in Claim 18, wherein if said components have<br>
expired, said client system requests any current versions of the expired<br>
components from said server proxy client, wherein said server proxy client<br>
checks the current version of a requesting client's presentation and logic<br>
components, if any of the presentation and logic components requires updating,<br>
then said server proxy client retrieves the latest version of any of the presentation<br>
and logic components and sends it to the requesting client, and wherein the<br>
requesting client stores the latest version of any of the presentation and logic<br>
components in said one-behind cache.<br>
20. An apparatus as claimed in Claim 16, comprising:<br>
a module for sending said presentation and logic component updates to a<br>
client system.<br>
21. An apparatus as claimed in Claim 16, wherein said client system uses<br>
said data and presentation components to create displays to a user.<br>
22. An apparatus as claimed in Claim 16, wherein said client system reuses<br>
said data component for other display purposes.<br>
23. An apparatus as claimed in Claim 16, comprising:<br>
means on said server proxy client for saving a client system's state on<br>
storage device; and<br>
wherein the saved client system's state allows said server proxy client to<br>
continue a client system's session when the client system changes connection<br>
methods to or loses coverage with said server proxy client.<br>
24. An apparatus as claimed in Claim 16, comprising:<br>
a scripting language;<br>
wherein said logic component updates are written in said scripting<br>
language;<br>
wherein said server proxy client compiles scripts written in said scripting<br>
language into executable bytecodes;<br>
wherein said server proxy client updates said client system's features by<br>
sending said client system said executable bytecodes; and<br>
wherein said client system executes said executable bytecodes in<br>
response to a user's input.<br>
25. An apparatus as claimed in Claim 24, wherein a client system's<br>
presentation aspects are controlled using said scripting language.<br>
26. An apparatus as claimed in 16, wherein communication between said<br>
server proxy client and said client system is via a binary encoding of an XML<br>
data stream.<br>
27. An apparatus for dynamically configuring client systems, comprising:<br>
a host server;<br>
a scripting language;<br>
wherein said host server compiles scripts written in said scripting<br>
language into executable bytecodes;<br>
wherein said host server, upon receipt of a request for specific up to date<br>
presentation components and/or executable bytecodes from a client system,<br>
checks if the client system's original presentation components and/or executable<br>
bytecodes have expired;<br>
wherein said host server updates the client system's features by sending<br>
the client system updated presentation components and/or executable bytecodes<br>
if the original presentation components and/or executable bytecodes on the client<br>
system have expired; and<br>
wherein a client system executes presentation components and/or<br>
executable bytecodes in response to a user's input.<br>
28. An apparatus as claimed in Claim 27, wherein said scripts define program<br>
logic.<br>
29. An apparatus as claimed in Claim 27, wherein said scripts create and<br>
control user interface displays.<br>
30. An apparatus as claimed in, wherein said client system receives<br>
requested network information from said host server separated into data and<br>
presentation components.<br>
r<br>
A handheld client framework system provides a server proxy client (509)<br>
that services client requests for network accessible information and determines<br>
the server that is most appropriate to supply the requested information and sends<br>
information requests packets to that server across the Internet and/or internet.<br>
Server responses to information requests are received by the server proxy client.<br>
The server proxy client separates the response information into the appropriate<br>
data components. Data components are sent to the appropriate client.<br>
Presentation and logic components are temporarily stored in a one-behind cache<br>
on the client (501). A client will continue to use the presentation and logic<br>
components already installed or in the one-behind cache to serve the current<br>
user request. Any updates sent by the server proxy client (509) and stored in the<br>
one-behind cache are retrieved by the client upon subsequent use by the user.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkzNC1rb2xucC0yMDA0LWdyYW50ZWQtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">1934-kolnp-2004-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkzNC1rb2xucC0yMDA0LWdyYW50ZWQtYXNzaWdubWVudC5wZGY=" target="_blank" style="word-wrap:break-word;">1934-kolnp-2004-granted-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkzNC1rb2xucC0yMDA0LWdyYW50ZWQtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">1934-kolnp-2004-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkzNC1rb2xucC0yMDA0LWdyYW50ZWQtY29ycmVzcG9uZGVuY2UucGRm" target="_blank" style="word-wrap:break-word;">1934-kolnp-2004-granted-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkzNC1rb2xucC0yMDA0LWdyYW50ZWQtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">1934-kolnp-2004-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkzNC1rb2xucC0yMDA0LWdyYW50ZWQtZXhhbWluYXRpb24gcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">1934-kolnp-2004-granted-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkzNC1rb2xucC0yMDA0LWdyYW50ZWQtZm9ybSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">1934-kolnp-2004-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkzNC1rb2xucC0yMDA0LWdyYW50ZWQtZm9ybSAxOC5wZGY=" target="_blank" style="word-wrap:break-word;">1934-kolnp-2004-granted-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkzNC1rb2xucC0yMDA0LWdyYW50ZWQtZm9ybSAzLnBkZg==" target="_blank" style="word-wrap:break-word;">1934-kolnp-2004-granted-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkzNC1rb2xucC0yMDA0LWdyYW50ZWQtZm9ybSA1LnBkZg==" target="_blank" style="word-wrap:break-word;">1934-kolnp-2004-granted-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkzNC1rb2xucC0yMDA0LWdyYW50ZWQtZ3BhLnBkZg==" target="_blank" style="word-wrap:break-word;">1934-kolnp-2004-granted-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkzNC1rb2xucC0yMDA0LWdyYW50ZWQtcmVwbHkgdG8gZXhhbWluYXRpb24gcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">1934-kolnp-2004-granted-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkzNC1rb2xucC0yMDA0LWdyYW50ZWQtc3BlY2lmaWNhdGlvbi5wZGY=" target="_blank" style="word-wrap:break-word;">1934-kolnp-2004-granted-specification.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="233788-process-for-producing-reduced-coenzyme-q10.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="233790-a-surgical-instrument.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>233789</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1934/KOLNP/2004</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>15/2099</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>10-Apr-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>08-Apr-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>15-Dec-2004</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>AMERICA ONLINE INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>22000 AOL WAY, DULLES, VA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>BESBRIS DAVID</td>
											<td>10 ELDORADO, FOOTHILL RANCH, CA 92610</td>
										</tr>
										<tr>
											<td>2</td>
											<td>DOERKSEN RICHARD</td>
											<td>90 MILLBROOK, IRVINE, CA 92618</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 15/16</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2003/018942</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2003-06-16</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/195,903</td>
									<td>2002-07-15</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/233789-a-process-for-a-framework-architecture-for-client-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:53:59 GMT -->
</html>
