<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/250902-port-type-agnostic-proxy-support-for-web-services-intermediaries by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:11:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 250902:PORT TYPE AGNOSTIC PROXY SUPPORT FOR WEB SERVICES INTERMEDIARIES</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">PORT TYPE AGNOSTIC PROXY SUPPORT FOR WEB SERVICES INTERMEDIARIES</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Abstract Methods, systems, and products are disclosed in which port type agnostic proxy support for web services intermediaries is typically provided by receiving in a web services intermediary a request for execution of a web services operation, wherein the request includes parametric information from which an endpoint for a target service that supports the operation can be identified; identifying, in dependence upon the parametric data, the endpoint for a target service that supports the operation; creating a target service request for execution of the operation on the target service; and issuing the target service request to the target service. Exemplary embodiments typically also include the return path of request-response processing: receiving in the intermediary a response from the target service; creating in the intermediary, in dependence upon the response from the target service, a response from the intermediary; and retxirning the response from the intermediary to the requesting client.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
Description<br>
PORT TYPE AGNOSTIC PROXY SUPPORT FOR WEB SERVICES<br>
INTERMEDIARIES Technical field<br>
The field of the invention is data processing, or, more specifically, methods, systems, and products for port type agnostic proxy support for web services intermediaries. Background art<br>
The term "web services" refers to a standardized way of integrating web-based applications.<br>
Web services typically provide business services upon request though data communications in standardized formats called bindings. A binding is a specification of a data encoding method and a data communications protocol. The most common binding in use for web services is data encoding in XML according to the SOAP protocol and data communications with HTTP.<br>
Unlike traditional client/server models, such as an HTTP server that provides HTML documents in response to requests from browser clients, web services are not concerned with display. Web services instead share business logic, data, and processes through a programmatic interface across a network. Web services applications interface with one another, not with users. Because all data communications among web services are carried out according to standardized bindings, Web services are not tied to any one operating system or programming language. A Java client running in a Windows™ platform can call web service operations written in Perl and running under Unix. A Windows application written in C++ can call operations in a web service implemented as a Java servlet.<br>
Today web services are growing across many industries. As web services grow in importance, web services intermediaries are increasingly recognized as means to provide many value-added services.    A web services intermediary, generally referred to in this<br>
specification as an "intermediary," is a web services component that lies between a web<br>
services client and a web services provider. Intermediaries operate generally by intercepting a request from a client, providing intermediary services, and then forwarding the client request to a web services provider. Similarly, responses from the web services provider are intercepted, operated upon, and then returned to the client. Examples of commercially available products with which web services intermediaries may be implemented include<br>
IBM's Web Services Gateway™ and IBM's Web Services BUSTM-<br>
Services provided by intermediaries include authentication of sources of requests for target services, message validation for content and for form, and message logging for auditing purposes. Intermediaries may provide management reporting services, number of web service hits, quantity and timing of services used by individual clients, and so on. Intermediaries can be used as caches in support of improved performance by storing<br><br>
frequently changing but frequently requested data such as news stories, for example. Intermediaries can be used for performance improvement in the sense of load balancing, storing requests for services from several clients and forwarding them to a target service during off-peak service hours. Intermediaries may aggregate services, as, for example, an accounting intermediary that accepts requests for account postings that are then forwarded to separate target services for accounts payable, accounts receivable, and general ledger services.<br>
It is common in prior art to implement web services intermediaries so that they are tightly coupled to their target services. That is, a particular intermediary provides intermediary services only to particular target web services. The need for this is clear when, for example, the intermediary provides message validation and must therefore have precise knowledge of proper message content and form. In the terminology of web services, a group of operations<br>
is referred to as a "port type." In this terminology, the restriction of tight coupling means that<br>
commonly in prior art, an intermediary service and all target services served by the intermediary service would have the same port type. There are situations, however, where it is useful for an intermediary service to function across port types, such as, for example, a client identity authentication function intended to provide exactly the same authentication function on messages directed to any target service, regardless of port type. Prior art forces additional configuration complexity in such cases, and there is an ongoing need for improvement in web services intermediaries. Disclosure of the invention<br>
According to a first aspect, there is provided a method of port type agnostic proxy support for web services intermediaries, the method comprising: receiving in a web services intermediary a request for execution of a web services operation, wherein the request includes parametric information from which an endpoint for a target service that supports the operation can be identified; identifying, in dependence upon the parametric data, the endpoint for a target service that supports the operation; creating a target service request for execution of the operation on the target service; and issuing the target service request to the target service.<br>
In one embodiment, it is determined whether the request requires a synchronous response; and a response from the target service is waited for if the request requires a synchronous response.<br>
In typical embodiments, determining whether the request requires a synchronous response is carried out by determining in dependence upon the parametric information whether the request requires a synchronous response. In typical embodiments, creating a target service request for execution of the operation on the target service includes creating the target service request in dependence upon a determination whether the request requires a synchronous response.   For a request that does not require a synchronous response, some embodiments<br><br>
include receiving from the target service an acknowledgment of the target service request and returning the acknowledgement to a requester without waiting for a response message. For a request that does require a response, some embodiments implement waiting for a response from the target service by receiving synchronously in the intermediary a response from the target service; creating in the intermediary, in dependence upon the response from the target service, a response from the intermediary; and returning the response from the intermediary to a requester. In typical embodiments, receiving synchronously in an intermediary a response from a target service is carried out by invoking a blocking receive function on a data communications connection between the intermediary and the target service.<br>
In many embodiments the target service request as created and issued to the target service bears unexamined and unmodified message contents of the request received in the web services intermediary. Exemplary embodiments typically also include the return path of request-response processing: receiving in the intermediary a response from the target service; creating in the intermediary, in dependence upon the response from the target service, a response from the intermediary; and returning the response from the intermediary to the requesting client.<br>
Typical embodiments of the present invention also include identifying to a requester an endpoint of the web services intermediary as an endpoint that supports the operation. In such embodiments, parametric information often includes a port type for the operation. In addition, identifying an endpoint for a target service that supports an operation often also includes identifying, in dependence upon the parametric information, a multiplicity of endpoints of target services that support the operation and selecting one endpoint from the multiplicity of endpoints in accordance with selection rules. Identifying a multiplicity of endpoints of target services that support an operation may be carried out by identifying from a registry, in dependence upon a port type, a multiplicity of target services for the port type. Selecting one endpoint from the multiplicity of endpoints may include selecting one endpoint from the multiplicity of endpoints in accordance with selection rules for load balancing among target services.<br>
Creating a target service request for execution of the operation on the target service may be carried out by composing the request in a data structure useful in a binding-neutral interface and calling the binding-neutral interface, passing the request as a call parameter. Issuing the target service request to the target service may include calling one or more member methods in a binding-neutral interface.<br>
According to a second aspect, the invention provides a system for port type agnostic proxy support for web services intermediaries, the system comprising: means for receiving in a web services intermediary a request for execution of a web services operation, wherein the request includes parametric information from which an endpoint for a target service that supports the operation can be identified;   means for identifying, in dependence upon the<br><br>
parametric data, the endpoint for a target service that supports the operation; means for<br>
creating a target service request for execution of the operation on the target service; and<br>
means for issuing the target service request to the target service.<br>
According to a third aspect, there is provided a computer program product for port type<br>
agnostic proxy support for web services intermediaries, the computer program product<br>
comprising: a recording medium; means, recorded on the recording medium, for receiving in<br>
a web services intermediary a request for execution of a web services operation, wherein the<br>
request includes parametric information from which an endpoint for a target service that<br>
supports the operation can be identified;   means, recorded on the recording medium, for<br>
identifying, in dependence upon the parametric data, the endpoint for a target service that<br>
supports the operation; means, recorded on the recording medium, for creating a target<br>
service request for execution of the operation on the target service; and means, recorded on<br>
the recording medium, for issuing the target service request to the target service.<br>
The invention may be implemented in computer software.<br>
Brief description of the drawings<br>
Preferred embodiments of the present invention will now be described, by way of example<br>
only, and with reference to the following drawings:<br>
Figure 1A and IB set forth line drawings of exemplary architectures for web services in<br>
which port type agnostic proxy support for web services intermediaries may be implemented<br>
according to embodiments of the present invention.<br>
Figure 2A sets forth a line drawing of a block diagram of an exemplary intermediary<br>
according to embodiments of the present invention.<br>
Figure 2B sets forth a line drawing of a block diagram of an exemplary intermediary (202)<br>
implementing a SOAP-HTTP channel according to embodiments of the present invention.<br>
Figure 3 sets forth a flow chart illustrating, in accordance with a first embodiment, a method<br>
of port type agnostic proxy support for web services intermediaries.<br>
Figure 4 sets forth a flow chart illustrating, in accordance with a second embodiment, a<br>
method of port type agnostic proxy support for web services intermediaries.<br>
Figure 5 sets forth a flow chart illustrating, in accordance with the second embodiment, a<br>
method of waiting (361) for a response from a target service when a request requires a<br>
synchronous response.<br>
Mode(s) for carrying out the invention<br>
The present invention is described to a large extent in this specification in terms of methods for port type agnostic proxy support for web services intermediaries. Persons skilled in the art, however, will recognize that any computer system that includes suitable programming means for operating in accordance with the disclosed methods also falls well within the scope of the present invention. Suitable programming means include any means for directing a computer system to execute the steps of the method of the invention* including for example,<br><br>
systems comprised of processing units and arithmetic-logic circuits coupled to computer memory, which systems have the capability of storing in computer memory, which computer memory includes electronic circuits configured to store data and program instructions, programmed steps of the method of the invention for execution by a processing unit. The invention also may be embodied in a computer program product, such as a diskette or other recording medium, for use with any suitable data processing system. Embodiments of a computer program product may be implemented by use of any recording medium for machine-readable information, including magnetic media, optical media, or other suitable media. Persons skilled in the art will immediately recognize that any computer system having suitable programming means will be capable of executing the steps of the method of the invention as embodied in a program product. Persons skilled in the art will recognize immediately that, although most of the exemplary embodiments described in this specification are oriented to software installed and executing on computer hardware, nevertheless, alternative embodiments implemented as firmware or as hardware are well within the scope of the present invention. Definitions<br>
A "business registry," as the term is used in this specification, is an Internet directory of web<br>
services containing listings of businesses and the web services offered by the businesses. The listings of the web services include supported operations, port types, endpoints, bindings, and so on. Some business registries are based on open standards such as ebXML, and some are based on industry consortium-led specifications such as UDDI. Businesses can register themselves with a registry. Businesses can submit material to be shared through a registry, and registry clients can search for material that others have submitted. Business registries may be accessed and searched manually through browsers or programmatically through APIs which themselves may be web services. Registries are becoming an increasingly important component of Web services because they allow businesses to collaborate with one another dynamically in a loosely coupled way.<br>
HTTP means "HyperText Transfer Protocol, the most common data communications protocol<br>
on the web.    In this specification, the term "web," however, is not limited to HTTP<br>
communications, but also may include communications with other protocols that support similar modes of communication such as HDTP, the Handheld Device Transfer Protocol, or WAP, the Wireless Access Protocol, and others as will occur to those of skill in the art.<br>
"SOAP" means "Simple Object Access Protocol," a lightweight XML-based messaging<br>
protocol used to encode the information in Web service request and response messages before sending them over a network. SOAP messages are independent of any operating system or protocol and may be transported using a variety of Internet protocols, including SMTP, MIME, and HTTP.<br><br>
"UDDI" means "Universal Description, Discovery and Integration," a web-based distributed<br>
directory that enables businesses to list themselves on the Internet and discover each other, similar to a traditional phone book's yellow and white pages.<br>
"WSDL" means "Web Services Description Language."    WSDL is an XML-formatted<br>
language that was developed jointly by Microsoft and IBM and is used to describe a Web service's capabilities as collections of communication endpoints capable of exchanging messages.   WSDL is an integral part of UDDI in that UDDI uses WSDL to describe web<br>
services' capabilities.<br>
"ebXML" means "electronic business Extensible Markup Language," a modular suite of<br>
specifications for standardizing descriptions of web services in XML to facilitate trade electronic commerce. Like UDDI, the ebXML specification gives businesses a standard method to define and register web services.<br>
This specification generally describes components of web services with a terminology similar to that of WSDL. Web services are described as collections of network endpoints, endpoints of data communications, capable of exchanging messages. Endpoints are sometimes referred<br>
to as "ports." In this specification generally, however, the term "endpoint" is preferred to "port," to reduce the risk of confusion with the term "port type." A port type is not a type of<br>
port or a type of endpoint. A port type is a collection of "operations," that is, software actions<br>
or functions, supported by a service.<br>
A particular communications protocol and a data format specification for a port type<br>
constitute a "binding." An example of a binding is SOAP/HTTP, with message data encoded<br>
according to SOAP and messages communicated among endpoints according to HTTP. Another example of a binding is GET/POST/HTTP, with message data encoded in GET or POST messages and data communications carried out according to HTTP. Each port type may have more than one binding. An endpoint is defined by associating a network address with a binding, and, as mentioned, a collection of endpoints define a service. Communication of data and requests for operations in web services is carried out through<br>
data structures called "messages," which in turn are composed of "parts." The terms "request"<br>
and "response" are generally indications of the direction of message flow. Request messages<br>
and response messages for a particular binding may have the same structure.<br>
Port Type Agnostic Proxy Support For Web Services Intermediaries<br>
With reference to the accompanying drawings, methods, systems, and products are described<br>
for port type agnostic proxy support for web services intermediaries, beginning with Figures<br><br>
1A and IB. Figure 1A sets forth a line drawing of an exemplary architecture for web services in which port type agnostic proxy support for web services intermediaries may be implemented according to embodiments of the present invention. In the architecture of Figure 1A, intermediary (202) is capable of connecting for data communications through a protocol to requester (102) and target service (118). A web services component in the position of requester (102) is sometimes referred to as a client. Similarly, a component in the position of intermediary (202), particular when viewed from the point of view of a requester, is sometimes referred to as a server.<br>
The client/server distinction must be used carefully in the context of web services. In the architecture of Figure IB, for example, target service (118), in the process of preparing a response to a request from requester (102), may in turn request web services from target service (119) through intermediary (203). In doing so, target service (118) is acting as a client. Intermediary (202) in forwarding requests to target service (118) is acting as a client. Whether a particular component is considered a client or a server at any particular time depends upon the particular function being performed by the component at the time. That is, a web services component can be a client one moment and a server the next. To reduce the risk of confusion from terminology, therefore, web services components  are usually<br>
described in this specification by using the terms "requester," "intermediary," and "target<br>
service" rather than "client" or "server."<br>
In order for intermediary (202) to provide intermediary services on behalf of target service (118), intermediary (202) must know an endpoint on target service (118).   As mentioned<br>
above, in prior art, a service, called a "proxy," running on intermediary (202) would support<br>
the same port type as the target service (118) and would have in its configuration data an<br>
endpoint for target service (118). In the architecture of Figure 1, however, the proxy is 'port<br>
type agnostic/ meaning that no configuration data available to the proxy describes an<br>
endpoint of the target service and that requester (102) may submit requests for operations in<br>
port types completely unknown to the intermediary.<br>
Figure 2A sets forth a line drawing of a block diagram of an exemplary intermediary (202)<br>
according to embodiments of the present invention. Intermediary (202) comprises automated<br>
computing machinery, a computer system, including at least one central processing unit,<br>
computer memory, a system bus, and so on.  The blocks in the block diagram of Figure 2A<br>
represent software application modules operable in a computer system of intermediary (202).<br>
The arrows in Figure 2A represent data flow among software modules.<br>
Intermediary (202) includes an inbound engine (208) capable of receiving from a requester<br>
(102) a request (106), including parametric information (107), for execution of a web services<br>
operation. Here is an example of such a request for the SOAP-HTTP binding:<br><br><br>
This exemplary POST message includes a SOAP envelope requesting the 'myOp' operation<br>
from the intermediary. That is, the name of the operation to be executed on a target service (118) is identified internally within the soap message. The myOp operation, its port type, and it endpoint are all unknown to the intermediary before the request is received. In this example, the parametric information (107) from which an endpoint for a target service (118) that supports the operation can be identified is set forth in a name-value pair in the URI-<br>
encoded query string in the first line of the POST: "portType=A."<br>
In a second embodiment, the first line of the exemplary request should read:<br>
POST /Channel/proxy?portType=A&amp;synchRespReqd=True HTTP/1.1<br>
In this second embodiment, the parametric information includes a name value pair<br>
"synchRespReqd^True" from which a port type agnostic proxy according to an embodiment<br>
of the present invention may determine whether the request requires a synchronous response. In addition to receiving from a requester (102) a request (106), including parametric information (107), for web services, inbound engine (208) also has a capability of providing the request, including its parametric data, to port type agnostic proxy (212). Consider as an example of inbound engine operation, the exemplary request set forth just above. That exemplary request is bound as SOAP-HTTP. For this exemplary request, therefore, inbound engine may be a SOAP-enabled HTTP server that hands off an incoming request to a proxy (212) implemented as any kind of server-type application, including for example, a Java Bean, a Java servlet or a CGI (Common Gateway Interface) script written in Perl. Java servlets and CGI scripts are mentioned only for explanation, not for limitation. Within the scope of the present invention, any kind of server-side functionality as will occur to those of skill in the art may be used to implement port type agnostic proxy functions for web services intermediaries.<br><br>
Port type agnostic proxy (212) may be hard coded to operate exclusively as a port type agnostic proxy, or, alternatively, port type agnostic proxy (212) may operate modally in dependence upon configuration parameters (223). A configuration parameter may be provided to indicate whether port type agnostic proxy (212) is to operate as a traditional intermediary service or in port type agnostic mode. Such a configuration parameter advantageously promotes efficient program coding including particularly reuse of code segments that might be utilized in both modes. Another configuration parameter supporting<br>
efficient use of program code is a parameter identifying a binding or 'channel type1 for a<br>
proxy. As explained in more detail below, port type agnostic proxies may operate with any binding supported by web services, SOAP, MIME, GET/POST/HTTP, and so on. Port type agnostic proxy may be coded to operate with any binding or channel type and then configured with a parameter advising the proxy of its binding or channel type for run time operations. In addition, a configuration parameter may be provided to turn on or off any intermediary services in the proxy that would require parsing the contents of a request or response message. Such a parameter advantageously may be used to optimize performance because parsing message contents has a tendency to slow intermediary performance. Many port type agnostic, proxies as well as other intermediary services may operate simultaneously in intermediary (202), and names for each may be assigned as configuration parameters. Messages handlers and filters may be assigned to proxies in configuration parameters. This paragraph describes several configuration parameters for port type agnostic proxies by way of explanation, not limitation. The use of any configuration parameters as will occur to those of skill in the art is well within the scope of the present invention.<br>
Figure 2B sets forth a line drawing of a block diagram of an exemplary intermediary (202) implementing a SOAP-HTTP channel according to embodiments of the present invention. As mentioned, an inbound engine (208) capable of providing the request, including its parametric data, to port type agnostic proxy (212) for a request with a SOAP binding may be implemented as a SOAP-enabled HTTP server. Such an inbound engine may be configured with a number of references to SOAPHandler objects (210) for the proxy, where each SOAPHandler object (210) is configured to provide some data processing task on the request for the proxy. Such an inbound engine typically operates by encapsulating the incoming request along with its parametric information in a SOAPContext object (209), passing a reference to the SOAPContext object in turn to each SOAPHandler (210) configured for the proxy, and then passing the SOAPContext (209) in its entirety to the proxy (212). In a general sense, it is a port type agnostic proxy that identifies the endpoint, but a detailed implementation level may include proxy functionality in handlers, as is the case for SOAP. That is, the incoming engine may establish a property in a SOAPContext that may be set to an endpoint of a target service, a URL in the case of SOAP/HTTP. In such an embodiment,<br><br>
one of the SOAPHander objects (210) usefully may be programmed to extract the parametric information from the request and place it in name-value pairs in the SOAPContext so that the proxy can use it to identify an endpoint for a target service (118) that supports a requested web services operation.<br>
Alternatively, an incoming request may be bound with GET/HTTP rather than SOAP. In such an example, proxy (212 on Figure 2 A) may be implemented as a Java servlet Inbound engine (208) may be implemented as a Java-enabled HTTP server that encapsulates the request, including its parametric information, in an HTTPServletRequest object and provides to the proxy a reference to that HTTPServletRequest object. The proxy can then obtain the parametric information through a call to HTTPServletRequestgetQueiyStringO, which returns the query string from the request URL, that is, everything in the request URL after the question mark.   Having the entire query string, such an exemplary proxy is programmed to<br>
extract the parametric data from the query string, that is, in this example, "portType^A," and<br>
use the information so extracted to identify an endpoint for a target service (118) that supports a requested web services operation. One way that the proxy may identify an endpoint for a target service that supports a requested web services operation is to retrieve an endpoint description from a business registry (211) such as a UDDI registry or a ebXML registry. Target services (118) typically make such descriptions, including, for example, descriptions expressed as WSDL documents, by registering (224) them in a business registry (211).<br>
In SOAP based web services, the SOAP message itself contains the name of the operation and the parameters for the operation; they are not in the endpoint URL. It is useful for the intermediary to receive parametric information such as the portType parameter. That parameter may be something as simply as the name of the portType.   If such a case, then<br>
some 'business logic' that runs in the server (in a handler, for example, or even in the proxy<br>
function itself) must choose the actual endpoint URL for the target service (118) based on the port type or other parametric information.  The parametric information may even include an<br>
actual endpoint URL.  In that case, the 'business logic' could ultimately send the request to<br>
that URL. Both port type and endpoint URL could be present in the parametric information,<br>
and the 'business logic1 may then attempt to determine an endpoint URL and use the one in<br>
the request as a default if nothing better is found. The invention preferably allows all three scenarios as well as any variants that can be controlled by the business logic.  Always there<br>
may be other parameters that help control the 'business logic.'<br>
Although this specification tends to discuss exemplary bindings in terms of the SOAP/HTTP binding and sometimes in terms of the GET/POST/HTTP binding, the discussion of these exemplary bindings is for convenience of explanation and not as a limitation.   Alternative<br><br>
exemplary bindings useful according to various embodiments of the invention include MIME/SMTP  (Multipart Internet Mail Extensions over the  Small  Message Transport<br>
Protocol) and RMI/HOP (Java's Remote Method Invocation over the Common Object<br>
Request Broker Architecture's Internet Inter-ORB Protocol).  In fact, an arbitrary Java class<br>
may be treated as a Web service, with native Java invocations as the access protocol, and the use in port type agnostic proxies of any other binding as will occur to those of skill in the art is well within the scope of the present invention in accordance with preferred embodiments.. In the exemplary intermediary (202) of Figure 2A, proxy (212) is a port type agnostic proxy that performs whatever intermediary services it is designed for, requester authentication, message validation, message logging, management reporting services, and so on, identifies an endpoint of a target service (118) that supports a requested operation, and then transmits the request to the target service through binding-neutral interface (218). As explained in more detail below, binding-neutral interface (218) is an interface whose form of usage does not depend upon request binding.<br>
In the exemplary intermediary (202) of Figure 2A, binding-neutral interface (218) operates a provider (220) which in turn calls an outbound engine (222) to forward the request (106) to a target service (118). It is possible for the interface (218) to operate in a binding-neutral fashion because it is backed up by code in the provider (220) that is protocol-specific. The provider (220) carries out the actual message exchanges according to the specifics of a particular protocol, SOAP, HTTP, and so on. Decoupling the binding-neutral interface from the provider that carries out the actual data communications supports dynamic registration of new providers, so that an intermediary may enhance its data communications ability with no need to recompile or redeploy. A provider may be implemented as an object, often provided<br>
by a target service supported by the provider's protocols, with a reference to the provider<br>
dynamically installed in a binding-neutral interface. The outbound engine (222) is the actual data communications engine for the protocol implemented by the provider (222). When the protocol is taken as SOAP/HTTP, for example, the outbound engine is a SOAP/HTTP engine capable of sending and receiving SOAP/HTTP request and response message to and from target web services. When the protocol is HTTP, for example, the outbound engine is an HTTP data communications client module, similar to the data communications module of a web browser.<br>
In order to provide its intermediary services, the intermediary advantageously is capable of identifying an endpoint for a request A method for doing so is discussed with reference to Figure 3. Figure 3 sets forth a flow chart illustrating a method of port type agnostic proxy support for web services intermediaries that includes receiving (104) in a web services intermediary a request (106) for execution of a web services operation, wherein the request<br><br><br>
This exemplary POST message includes a SOAP envelope requesting the 'myOp' operation<br>
from the intermediary. The myOp operation, its port type, and its endpoint are all unknown to the intermediary before the request is received. In this example, the message is taken as the SOAP envelope, and the parametric information (107) from which an endpoint for a target  service that  supports the  operation  can be  identified is the HTTP parameter<br>
"portType=A."   In this example, because the name of the operation on the target service is<br>
already encoded in the SOAP envelope, the only parametric data to be added is the port type<br>
"A," a port type that includes the operation on the target service.<br>
The method of Figure 3 also includes identifying (108), in dependence upon the parametric data, the endpoint (110) of a target service that supports the operation. In this SOAP-HTTP example, identifying (108) the endpoint (110) of a target service that supports the operation is carried out by retrieving an endpoint description from a business registry such as a UDDI registry or a ebXML registry. In this example, the intermediary retrieves from a registry an endpoint of port type A described as bound by SOAP-HTTP at network address http://www.myTarget.com/ SOAP-HTTP/servlets/.<br>
The illustrated method includes creating (112) a target service request (114) for execution of the operation on the target service. In this example, the intermediary is programmed to create a target service request as an HTTP POST message using the endpoint on the target service. The parametric data for identifying an endpoint is deleted, and the request is directed to a<br><br><br>
The method of Figure 3 also includes issuing (116) the target service request (114) to the target service (118). In this example, issuing the target service request includes opening a TCP/IP connection to the target service endpoint at http://www.myTarget.com/ and sending the HTTP POST message through the TCP/IP connection to the target service. It is useful to note, that in at least some embodiments of the present invention, in methods of port type agnostic proxy support such as the one illustrated in Figure 3 the target service request as created and issued to the target service bears unexamined and unmodified message contents of the request received in the web services intermediary. In the example under discussion just above, the proxy service on the intermediary identified an endpoint of a target<br>
service from the parametric data "portType=Aw and redirected the message to the endpoint so<br>
identified, all without touching, opening, examining, parsing, or in other any way disturbing<br>
the message body, the SOAP envelope, which remained unexamined and unchanged<br>
throughout the entire process of delivery from its requester to its target service.   In the<br>
process, the proxy service provided one or more of the intermediary services, authentication,<br>
management reporting, load balancing, service aggregation, and so on.<br>
By way of further explanation, an exemplary request is presented for the GET/HTTP binding,<br>
directed       to       an       endpoint       at       http://www.myIntermediary/channelApps/GET-<br>
HTTP/servlets/proxy. The exemplary incoming request message has this form:<br>
GET/servlets/proxy?message=:messageContentString&amp;<br>
operation=myOp&amp;portType=A HTTP/1.1<br>
And in URI space, the exemplary request may be shown as:<br><br>
http ://www.myIntermediary.com/servlets/<br>
proxy?message=messageContentString&amp;operation==myOp&amp;portType=A<br>
In    this    example,    the    message    is    taken    as    the    URI-encoded    query    data<br>
"message=messageContentString" encoded as a name-value pair.   The message content is a<br>
URI-encoded string. In this example, the parametric information (107) from which an endpoint for a target service that supports the operation can be identified is all the query data following the message content string. In this example, the query data includes both port type<br>
of "A" and the name of an operation on a target service.<br>
In this example, identifying (108) the endpoint (110) of a target service that supports the<br>
operation is carried out by retrieving an endpoint description from a business registry such as<br>
a UDDI registry or a ebXML registry.   In this example, the intermediary retrieves from a<br>
registry an endpoint of port type A described as bound by GET/HTTP at network address<br>
http://www.myTarget.com.<br>
The method of Figure 3 also includes creating (112) a target service request (114) for<br>
execution of the operation on the target service.    In this example, the intermediary is<br>
programmed to create a target service request as an HTTP GET message by concatenating the<br>
endpoint address for the target service request with the operation name and the message parts.<br>
The resulting target service request, expressed in URI space is:<br>
http://www.my Target.com/servlets/myOp?message=messageContentString<br>
The method of Figure 3 also includes issuing (116) the target service request (114) to the<br>
target service (118).   In this example, issuing the target service request includes opening a<br>
TCP/IP connection to the target service endpoint at http://www.myTarget.com/ and sending<br>
the HTTP GET message:<br>
GET /servlets/myOp?message=messageContentString HTTP/1.1<br>
Readers of skill in the art are wondering how the requester knows to send to the intermediary<br>
a request for an operation on the target service.   The answer is that the intermediary or a<br>
developer of the intermediary identifies to the requester an endpoint of the web services<br>
intermediary as  an endpoint that supports the operation on the target service.     An<br>
identification of an endpoint of the intermediary as an endpoint that supports the operation on<br>
the target service can be implemented in a WSDL document that is registered in a business<br>
directory for discovery by the requester.    Alternatively, such an identification can be<br>
downloaded from the intermediary to the requester - or even simply emailed to the requester,<br>
or to the requester's administrator, for installation by an administrator in the requester's web<br>
services configuration data.<br>
Consider an example in which a target service is described by the following segment of<br>
WSDL pseudocode:<br>
definitions targetNamespace=... &gt;<br><br><br>
An intermediary for that target service may identify to a requester an endpoint of the web services intermediary as an endpoint that supports the operation on the target service by replacing the location attribute of the address extension element in the target service description follows:<br><address location="http://www.myIntermediary.com/&lt;br/&gt;
 &lt;br/&gt;
 &lt;br/&gt;
&lt;br/&gt;
 &lt;br/&gt;
which identifies an endpoint of a web services intermediary as an endpoint that supports the&lt;br/&gt;
" getquote operation on the target service. providing wsdl of kind exemplified by this></address>
latter segment to a requester, through a registry, a download, email, or by other means as will occur to those of skill in the art, identifies to the requester an endpoint of the web services intermediary as an endpoint that supports the operation on the target service. In the method of Figure 3 identifying (108), in dependence upon the parametric information (107), the endpoint for a target service that supports the operation often may include identifying not just one endpoint for a target service, but two or more endpoints of target services that support the operation. Consider an example in which a port type agnostic proxy according to an embodiment of the present invention method receives as parametric information (107) a port type for an operation, queries a business registry with the port type as a query parameter, and thereby identifies a two or more endpoints of target services that support the operation. Such an identification of two or more endpoints may be carried out, for example, by querying a UDDI registry with the port type and receiving in response two or more WSDL documents that describe target services for the port type.<br>
When two or more endpoints are so identified, methods for port type agnostic proxy support for web services intermediaries according to embodiments of the present invention typically include selecting one of the endpoints in accordance with selection rules. In a trivial case, a selection rule may be to select the first of the endpoints so identified and disregard the others. Selection rules may be more complex, including, for example, selection rules for load balancing. Rules for load balancing may be implemented by use of a data structure similar to that shown in Table 1.<br><br><br><br>
Each row in Table 1 represents a latency measurement for a request-response round trip in web services data communications between an intermediary and a target service. Table 1 provides columns for the port type and the endpoint URI for each round of request and response. The Send Time column records the time when a request message is issued from the intermediary to an endpoint on a target service for an operation of a port type. The Receive Time column records the time when a corresponding response message is received from the target service. Trip Latency is the difference between the Receive Time and the Send Time. Cumulative Latency is a running sum of Trip Latencies for each endpoint represented in the table. With a structure similar to Table 1, selection rules for use when more than one endpoint for a request is identified may be implemented as the following exemplary rules:<br>
as more requests for operations in the same port type arrive in the intermediary,<br>
use   each   of  the   more   than   one   identified   endpoints   once   in   turn,<br>
record	latency	data	for	each	such	usage,<br>
for subsequent requests for operations of the same port type, select from the<br>
latency table the endpoint having the lowest cumulative latency, send the request<br>
to that endpoint, and record pertinent latency data when the message is sent to<br>
the target service and when the corresponding response is received in the<br>
intermediary.<br>
The exemplary data in Table 1 shows cumulative latency for requests recently sent for port<br>
type A to two endpoints, a first endpoint at URI http://www.ibm.com/aTargetService and a<br>
second  endpoint  at  URI  http://www.ibm.com/anotherTargetService.      The  first  has  a<br>
cumulative request latency of 250 milliseconds, and the second has a cumulative request<br>
latency of 100 milliseconds.  Using the exemplary selection rules set forth above, a current<br>
request for an operation on port type A would be routed to the second endpoint, the one at<br>
URI http://www.ibm.com/anotherTargetService.<br>
In the method of Figure 3, creating (112) a target service request (114) for execution of the operation on the target service comprises may be carried out by composing the request in a data structure useful in a binding-neutral interface and calling the binding-neutral interface, passing the request as a call parameter. Similarly, issuing (116) the target service request (114) to the target service comprises calling one or more member methods in a binding-neutral interface.<br><br>
A binding-neutral interface is one in which the use of the interface does not depend upon request or message binding. That is, the data structures and calling methods used to implement the interface and to carry out data communications through it, do not depend upon type of data encoding used in a message nor do they depend upon the data communications protocol used for a message. Developers of port type agnostic proxies for intermediaries according to embodiments of the present invention will often build their own binding-neutral interfaces.   There is an open standard for a binding-neutral interface, however, known as<br>
"WSEF," the Web Service Invocation Framework.   WSIF is now supported as part of the<br>
Apache Software Foundation's Web Services Project.<br>
The use of a binding-neutral interface provides advantages for embodiments of the present invention. The SOAP-HTTP binding is so common in current art that users and developers sometimes forget that any other bindings exist. This results in development of systems that are very difficult if not impossible to use with other bindings or to adapt for use with other bindings. As web services grow, however, other bindings will become more useful and more common. Using a binding-neutral interface for the back end of embodiments of the present invention, moreover, also means that available bindings can be determined at run time, thereby providing a flexible, powerful, and more generally useful web services intermediary. One way to implement a binding-neutral interface is to provide endpoint objects that are capable of invoking services in target services given a port type and an endpoint. One way to provide such endpoint objects is by use of an endpoint factory similar to the one illustrated in the following pseudocode segment:<br><br><br><br>
The endpoint classes Endpoint 1, Endpoint2, Endpoint3, and so on, are concrete classes that<br>
inherit an abstract endpoint class (or implement it as an interface) that provides member<br>
methods for creating message objects to contain message parts. Such an endpoint factor and<br>
other elements in such a binding-neutral interface may be used to cany out the steps of<br>
creating (112) a target service request (114) and issuing (116) the target service request (114)<br>
to the target service as illustrated in the following pseudocode segment:<br>
// Get endpoint object from endpoint factory<br>
Endpoint ep = endPointFactory.createEndPoint(portType, networkAddress);<br>
// Prepare an input message<br>
Message input = ep.createInputMessage();<br>
// use message accessor function to insert contents of message<br>
input.setPart("symbor, "IBM");<br>
// Prepare a placeholder for a response value Message output = ep.createOutputMessageO; // execute the operation<br>
ep.executeRequestResponseOperation("getQuote",<br>
input, output); // return the result return output;<br>
This exemplary pseudocode segment, given a port type and a network address for an endpoint, calls an endpoint factory to create an endpoint object. The segment then creates a target service request by loading messages parts into the endpoint object, and issues the target service request to the target service by calling the member method<br>
executeRequestResponseOperationO. The method of Figure 3 includes receiving (120) in the intermediary a response (122) from the target service; creating (124) in the intermediary, in dependence upon the response (122) from the target service, a response (126) from the intermediary; and returning (128) the response (126) from the intermediary to the requesting client. In this exemplary pseudocode segment, the steps of receiving (120) a response (122) from the target service and creating (124) a response (126) from the intermediary are implemented by the call to executeRequestResponseOperationQ, typically a blocking call that<br><br>
waits for a response from the target service and makes the response available through the Message reference to 'output.'<br>
The example pseudocode segments above illustrate the use of a binding-neutral interface with ports referred to as endpoints.   WSIF interface syntax, however, uses the term "port" when<br>
referring to endpoints.    By way of further explanation regarding use of binding-neutral interfaces, therefore, a further exemplary pseudocode segment is presented, more closely<br>
adhering to the WSIF standard.  In this example, "port" is used to mean "endpoint," and for consistency of explanation, the name of the factory is changed to "portFactory."<br>
// get a port (an endpoint) from the factory<br>
WSIFPort port = portFactory.getPort(portType, networkAddress);<br>
// Prepare an input message<br>
WSIFMessage input = port.createInputMessage();<br>
// insert message contents<br>
input. setPart("symbol",<br>
new WSIFJavaPart(String.class, symbol)); // Prepare a placeholder for a response value WSIFMessage output = port.createOutputMessage(); // execute the operation port.executeRequestResponseOperation("getQuote",<br>
input, output, null); // extract and return the result return output;<br>
Although this specification discusses exemplary methods of port type agnostic proxy support in web services intermediaries primarily in terms of processing a request on its way from a requester to a target service, it is useful to note that intermediaries according to embodiments of the present invention also typically are capable of processing response messages making their way back from a target service through the intermediary to the original requester. The method of Figure 3, for example, includes receiving (120) in the intermediary a response (122) from the target service; creating (124) in the intermediary, in dependence upon the response (122) from the target service, a response (126) from the intermediary; and returning (128) the response (126) from the intermediary to the requesting client.<br>
Figure 4 sets forth a flow chart illustrating a method of port type agnostic proxy support for web services intermediaries that includes receiving (304) in a web services intermediary a request (106) for execution of a web services operation, wherein the request includes parametric information (107) from which an endpoint for a target service that supports the operation can be identified.<br><br><br>
This exemplary POST message includes a SOAP envelope requesting the 'myOp' operation<br>
from the intermediary. The myOp operation, its port type, and its endpoint are all unknown to the intermediary before the request is received. In this example, the message is taken as the SOAP envelope, and the parametric information (107) from which an endpoint for a target service that supports the  operation can be  identified is the HTTP parameter<br>
"portType=A."   In this example, because the name of the operation on the target service is<br>
already encoded in the SOAP envelope, the only parametric data to be added is the port type<br>
"A," a port type that includes the operation on the target service.<br>
The method of Figure 4 also includes identifying (308), in dependence upon the parametric data, the endpoint (110) of a target service that supports the operation. In this SOAP-HTTP example, identifying (308) the endpoint (110) of a target service that supports the operation is carried out by retrieving an endpoint description from a business registry such as a UDDI registry or a ebXML registry. In this example, the intermediary retrieves from a registry an endpoint of port type A described as bound by SOAP-HTTP at network address http://www.myTarget.com/SOAP-HTTP/servlets/.<br>
The method illustrated in Figure 4 also includes determining (350) whether the request (106) requires a synchronous response. Determining (350) whether the request (106) requires a synchronous response may be carried out by examining the query data in the first line of a received request message. In the exemplary POST message set forth above, the query data in<br>
its first line is all the data between the '?' and the HTTP version code, that is: portType=A&amp;synchRespReqd=True<br><br>
In this example, "synchRespReqd=True" is taken by the intermediary to mean that a<br>
synchronous response is required.   Similarly, "synchRespReqd=FalseH may indicate that a<br>
synchronous response is not required. These are exemplary encodings only, of course, not limitations of the invention. Any means for encoding within parametric information an indication whether a synchronous response is required from an intermediary is well within the scope of the present invention in accordance with preferred embodiments. In this example, determining (350) whether a request requires a synchronous response is carried out by making that determination in dependence upon parametric information (107), the<br>
parametric information being the name-value pair asynchRespReqd=True".<br>
The illustrated method includes creating (312) a target service request (114) for execution of the operation on the target service. In this example, the intermediary is programmed to create a target service request as an HTTP POST message using the endpoint on the target service. More particularly, the following POST message represents an example of an input message or input data for a requested web services operation. The parametric data is deleted, the parametric data for identifying an endpoint as well as any parametric data for determining whether synchronous response is required, and the request is directed to a script, servlet, or other functionality for handing SOAP messages that will itself identify the operation from the operation name in the SOAP envelope.<br><br>
In the method of Figure 4, creating (312) a target service request (114) for execution of the operation on the target service further may include creating (312) the target service request (114) in dependence upon a determination (152) whether the request requires a synchronous response. Just as the intermediary may create an input message bearing input data for a requested web service operation, so also may an intermediary create a output message. Such<br><br>
an output message is typically a place-holding object for use in storing and communicating any response message from a target service. An exemplary method of creating a response message object for a request that requires a synchronous response is for the intermediary to create an object of the proper class, leave it empty, and pass a reference to it as a parameter in one or more calls to downstream interfaces (such as a provider or an outbound engine, references (220) and (222) on Figure 2A and 2B) for communicating requests to a target service. An exemplary method of creating a response message object for a request that does not require a synchronous response is for the intermediary to pass a null reference (not merely a reference to an empty output object, but a completely null reference) as a parameter in one or more calls to downstream interfaces for communicating requests to a target service. In such embodiments, the downstream interface is programmed to interpret such a null<br>
reference as an indication to wait only for an 'acknowledgment' before returning control to its<br>
caller.<br>
The method of Figure 4 also includes issuing (316) the target service request (114) to the target service (118). In this example, issuing the target service request includes opening a TCP/IP connection to the target service endpoint at http://www.myTarget.com/ and sending the HTTP POST message through the TCP/IP connection to the target service.<br>
It is useful to note, that in at least some embodiments of the present invention, in methods of port type agnostic proxy support such as the one illustrated in Figure 4, the target service request as created and issued to the target service bears unexamined and unmodified message contents of the request received in the web services intermediary. In the example under discussion just above, the proxy service on the intermediary identified an endpoint of a target<br>
service from the parametric data "portType=A" and redirected the message to the endpoint so<br>
identified, all without touching, opening, examining, parsing, or in other any way disturbing the message body, the SOAP envelope, which remained unexamined and unchanged throughout the entire process of delivery from its requester to its target service. In the process, the proxy service provided one or more of the intermediary services, authentication, management reporting, load balancing, service aggregation, and so on. By way of further explanation, an exemplary request is presented for the GET/HTTP binding, directed       to       an       endpoint       at       htlp://www.myIntermediary/channelApps/GET-<br><br><br>
In    this    example,    the    message    is    taken    as    the    URI-encoded    query    data<br>
"message=messageContentString" encoded as a name-value pair.   The message content is a<br>
URI-encoded string. In this example, the parametric information (107) from which an endpoint for a target service that supports the operation can be identified is all the query data following the message content string. In this example, the query data includes both port type<br>
of "A" and the name of an operation on a target service.<br>
In this example, identifying the endpoint (110) of a target service that supports the operation is carried out by retrieving an endpoint description from a business registry such as a UDDI registry or a ebXML registry. In this example, the intermediary retrieves from a registry an endpoint of port type A described as bound by GET/HTTP at network address http ://www.myTarget.com.<br>
The method of Figure 4 also includes creating (312) a target service request (114) for execution of the operation on the target service.    In this example, the intermediary is programmed to create a target service request as an HTTP GET message by concatenating the endpoint address for the target service request with the operation name and the message parts. The resulting target service request, expressed in URI space is: http://www.myTargetxom/servlets/myOp?message=messageContentString As mentioned earlier, the method of Figure 4 also includes issuing (316) the target service request (114) to the target service (118).  In this example, issuing the target service request includes    opening    a    TCP/IP    connection    to    the    target    service    endpoint    at http://www.myTarget.com/ and sending the HTTP GET message: GET /servlets/myOp?message=messageContentString HTTP/1.1<br>
The method of Figure 4 also includes waiting (361) for a response from the target service if the request requires a synchronous response (360). Figure 5 sets forth a flow chart illustrating a method of waiting (361) for a response from a target service that includes receiving (320) synchronously in the intermediary a response (122) from the target service; creating (324) in the intermediary, in dependence upon the response from the target service, a response (126) from the intermediary; and returning (328) the response (126) from the intermediary to a requester (102). In the method of Figure 5, receiving (320) synchronously in the intermediary a response from the target service may be carried out by invoking a blocking receive function on a data communications connection between the intermediary and the target service.<br>
The following segment of pseudocode is an example, for an HTTP binding, of transmitting a request from an intermediary to a target service and waiting for a response from the target service if the request requires a synchronous response. The following segment exemplifies client operation for an HTTP binding such as is often provided according to embodiments of the present invention through a provider or in an outbound engine (220, 222 on Figure 2) of a web services intermediary:<br><br><br>
This exemplary pseudocode segment creates a Java URL object and uses the URL object to open a TCP/IP connection named 'connection' to a target service identified as having network<br>
address "targetURL."   The segment also opens a buffered stream on the connection named<br>
"out," and an input stream on the connection named "in." The segment transmits the request<br>
through the connection as "outprintln(request)n and then, if a synchronous response is required, makes a blocking call to receive a response message through the same connection, "Message responseMessage = in.readLine()," and returns the response message to its caller. This example is for an HTTP binding. By way of further explanation, a further example is presented below for a 'JMS' binding, that<br>
is, a binding to the Java Message Service. JMS provides two messaging 'domains,1 one for<br>
point-to-point messaging and one for publish-subscribe messaging. This example discusses point-to-point messaging between an intermediary and a target service using a JMS message queue. In JMS point-to-point messaging, a data communications connection such as a socket<br>
is encapsulated by a JMS 'connection' object. A JMS connection is created through an administrative object called a 'connection factory.' JMS connections are used to create one or<br>
more JMS 'sessions.'  A session is a single-threaded context for producing and consuming<br>
messages. A session is used to create message producers, message consumers, and messages. A message producer is an object used for sending messages to a queue.  The point-to-point<br><br>
form of a message producer implements the JMS 'queueSender' interface, which includes a<br>
sendO method. A message consumer is an object used for receiving messages from a queue.<br>
The point-to-point form of a message producer implements the JMS  'queueReceiver'<br>
interface, which includes a blocking receiveO method that can be called with or without a timeout period.<br>
The following segment of pseudocode is an example, for a JMS binding, of transmitting a request from an intermediary to a target service and waiting for a response from the target service if the request requires a synchronous response.<br><br>
This exemplary JMS segment creates a connection named queueConnection, creates a session named queueSession, creates a sender named queueSender, sends the request message to the target service through a JMS queue, and, if a synchronous request is required, creates a receiver named queueReceiver, and issues a blocking receiveO on queueReceiver to wait for a response message.<br>
If the request does not require (362) a synchronous response, then methods of port type agnostic proxy support for web services intermediaries according to embodiments of the present invention may include doing absolutely nothing beyond issuing the request to the target service. That is, if a request does not require (362) a synchronous response, it is well within the scope of the present invention in accordance with preferred embodiments to do<br><br>
nothing at all regarding acknowledgments, asynchronous responses, and the like. Alternatively, as shown in Figure 4, methods according to the second embodiment of present invention may include receiving (354) from a target service (156) an acknowledgment of the target service request and returning (358) the acknowledgement (156) to a requester (102) without waiting for a response message.<br>
Here is an exemplary pseudocode segment that returns an acknowledgment to a requester without waiting for a response message:<br><br>
This exemplary pseudocode segment creates a Java URL object and opens for the URL object, in the form of an HTTPURLConnection object, a TCP/IP connection named<br>
'connection1 to a target service identified as having network address "targetURL." The segment also opens a buffered output stream on the connection named "out" and an input stream on the socket named "in." The segment transmits the request through the connection as "out.println(request)n and then makes a blocking call to receive an acknowledgment through the same connection, "int acknowledgment = connection.getResponseCode().M  The<br>
segment either returns an acknowledgment to its caller (HTTP response code '200' in this<br>
example) or returns an error message. The acknowledgment is a procedural acknowledgement from the target service that the request was received. The segment does not wait for a substantive response to the request.<br>
The exemplary pseudocode segment just above is an example of transmitting a request from an intermediary to a target service and providing an acknowledgment without waiting for a substantive response message. This segment exemplifies client operation for an HTTP binding such as is often provided according to embodiments of the present invention through a provider or in an outbound engine (220, 222 on Figure 2) of a web services intermediary.<br><br>
Readers of skill in the art by now are wondering how the requester knows to send to the intermediary a request for an operation on the target service. The answer is that the intermediary or a developer of the intermediary identifies to the requester an endpoint of the web services intermediary as an endpoint that supports the operation on the target service. An identification of an endpoint of the intermediary as an endpoint that supports the operation on the target service can be implemented in a WSDL document that is registered in a business directory for discovery by the requester. Alternatively, such an identification can<br>
be downloaded from the intermediary to the requester - or even simply emailed to the requester, or to the requester's administrator, for installation by an administrator in the<br>
requester's web services configuration data.<br><br>
An intermediary for that target service may identify to a requester an endpoint of the web services intermediary as an endpoint that supports the operation on the target service by replacing the location attribute of the address extension element in the target service description follows:<br>
Consider an example in which a target service is described by the following segment of WSDL pseudocode:<br><br><br>
which identifies an endpoint of a web services intermediary as an endpoint that supports the "getQuote" operation on the target service. Providing WSDL of the kind exemplified by this<br>
latter segment to a requester, through a registry, a download, email, or by other means as will occur to those of skill in the art, identifies to the requester an endpoint of the web services intermediary as an endpoint that supports the operation on the target service. In the method of Figure 4, identifying (308), in dependence upon the parametric information (107), the endpoint for a target service that supports the operation often may include identifying not just one endpoint for a target service, but two or more endpoints of target services that support the operation. Consider an example in which a port type agnostic proxy according to an embodiment of the present invention method receives as parametric information (107) a port type for an operation, queries a business registry with the port type as a query parameter, and thereby identifies a two or more endpoints of target services that support the operation. Such an identification of two or more endpoints may be carried out, for example, by querying a UDDI registry with the port type and receiving in response two or more WSDL documents that describe target services for the port type.<br>
When two or more endpoints are so identified, methods for port type agnostic proxy support for web services intermediaries according to embodiments of the present invention typically include selecting one of the endpoints in accordance with selection rules. In a trivial case, a selection rule may be to select the first of the endpoints so identified and disregard the others. Selection rules may be more complex, including, for example, selection rules for load<br><br><br>
Each row in Table 1 represents a latency measurement for a request-response round trip in web services data communications between an intermediary and a target service. Table 1 provides columns for the port type and the endpoint URI for each round of request and response. The Send Time column records the time when a request message is issued from the intermediary to an endpoint on a target service for an operation of a port type. The Receive Time column records the time when a corresponding response message is received from the target service. Trip Latency is the difference between the Receive Time and the Send Time. Cumulative Latency is a running sum of Trip Latencies for each endpoint represented in the table. With a structure similar to Table 1, selection rules for use when more than one endpoint for a request is identified may be implemented as the following exemplary rules:<br>
as more requests for operations in the same port type arrive in the intermediary,<br>
use each of the more than one identified endpoints once in turn,<br>
record	latency	data	for	each	such	usage,<br>
for subsequent requests for operations of the same port type, select from the latency table the endpoint having the lowest cumulative latency, send the request to that endpoint, and record pertinent latency data when the message is sent to<br><br>
the target service and when the corresponding response is received in the<br>
intermediary. The exemplary data in Table 1 shows cumulative latency for requests recently sent for port type A to two endpoints, a first endpoint at URI http://www.ibm.com/aTargetService and a second endpoint at URI http://www.ibm.com/anotherTargetService. The first has a cumulative request latency of 250 milliseconds, and the second has a cumulative request latency of 100 milliseconds. Using the exemplary selection rules set forth above, a current request for an operation on port type A would be routed to the second endpoint, the one at URI http://www.ibm.com/anotherTargetService.<br>
In the method of Figure 4, creating (312) a target service request (114) for execution of the operation on the target service comprises may be carried out by composing the request in a data structure useful in a binding-neutral interface and calling the binding-neutral interface, passing the request as a call parameter. Similarly, issuing (316) the target service request (114) to the target service comprises calling one or more member methods in a binding-neutral interface.<br>
A binding-neutral interface is one in which the use of the interface does not depend upon request or message binding. That is, the data structures and calling methods used to implement the interface and to carry out data communications through it, do not depend upon type of data encoding used in a message nor do they depend upon the data communications protocol used for a message. Developers of port type agnostic proxies for intermediaries according to embodiments of the present invention will often build their own binding-neutral interfaces.   There is an open standard for a binding-neutral interface, however, known as<br>
"WSIF," the Web Service Invocation Framework.   WSIF is now supported as part of the<br>
Apache Software Foundation's Web Services Project.<br>
The use of a binding-neutral interface provides advantages for embodiments of the present invention.  The SOAP-HTTP binding is so common in current art that users and developers sometimes forget that any other bindings exist  This results in development of systems that are very difficult if not impossible to use with other bindings or to adapt for use with other bindings. As web services grow, however, other bindings will become more useful and more common.  Using a binding-neutral interface for the back end of embodiments of the present invention, moreover, also means that available bindings can be determined at run time, thereby providing a flexible, powerful, and more generally useful web services intermediary. One way to implement a binding-neutral interface is to provide endpoint objects that are capable of invoking services in target services given a port type and an endpoint. One way to provide such endpoint objects is by use of an endpoint factory similar to the one illustrated in the following pseudocode segment: //  Endpoint Factory Class //  Defines a parameterized factory method for creating endpoint objects<br><br><br>
The endpoint classes Endpointl, Endpoint2, Endpoint3, and so on, are concrete classes that inherit an abstract endpoint class (or implement it as an interface) that provides member methods for creating message objects to contain message parts. Such an endpoint factor and other elements in such a binding-neutral interface may be used to carry out the steps of creating (312) a target service request (114) and issuing (316) the target service request (114) to the target service as illustrated in the following pseudocode segment:<br><br><br><br>
This exemplary pseudocode segment, given a port type and a network address for an endpoint, calls an endpoint factory to create an endpoint object. The segment then creates a target service request by loading messages parts into the endpoint object, and issues the target service request to the target service by calling the member method executeRequestResponseOperationO- The method of Figure 5, if the request requires a synchronous response, includes receiving (320) in the intermediary a response (122) from the target service; creating (324) in the intermediary, in dependence upon the response (122) from the target service, a response (126) from the intermediary; and returning (328) the response (126) from the intermediary to the requesting client<br>
In this exemplary pseudocode segment, the steps of receiving (320) a response (122) from the target service and creating (324) a response (126) from the intermediary are implemented by the call to executeRequestResponseOperationO- In this example, value of the reference to the<br>
output message is left null if the request requires a synchronous response.  The null 'output1<br>
parameter in this kind of embodiment is taken by a provider (220 on Figure 2A) to mean that a synchronous response is not required. The provider therefore issues the request to a target service and returns immediately without waiting for a response, Similarly, if the request requires a synchronous response, the value of the reference to the<br>
response message 'output' is set non-null by: output = ep.createOutputMessageO- The fact that the parameter reference to the response message, here named 'output,' in the call:<br>
ep.executeRequestResponseOperation("getQuote", input, output)<br>
is non-null is taken by a provider (220 on Figure 2A) to mean that a synchronous response is required. Such a provider is programmed then to effect a blocking receive call on its outbound engine (222 on Figure 2) and wait for a corresponding response message from the target service. In terms of the method of Figure 5 then, this segment represents an exemplary method of creating (312) a target service request (114) for execution of an operation on a target service in dependence upon a determination (152) whether the request requires a synchronous response. The example pseudocode segments above illustrate the use of a binding-neutral interface with<br>
ports referred to as endpoints.   WSIF interface syntax, however, uses the term "port" when<br>
referring to endpoints. By way of further explanation regarding use of binding-neutral interfaces, therefore, a further exemplary pseudocode segment is presented, more closely<br><br><br>
Although this specification discusses exemplary methods of port type agnostic proxy support in web services intermediaries primarily in terms of processing a request on its way from a requester to a target service, it is useful to note that intermediaries according to embodiments of the present invention also typically are capable of processing response messages making their way back from a target service through the intermediary to the original requester. The method of Figure 5, for example, includes receiving (320) in the intermediary, when a request requires a synchronous response,a response (122) from the target service; creating (324) in the intermediary, in dependence upon the response (122) from the target service, a response (126) from the intermediary; and returning (328) the response (126) from the intermediary to the requesting client.<br>
It will be understood from the foregoing description that modifications and changes may be made in various embodiments of the present invention without departing from its true spirit. The descriptions in this specification are for purposes of illustration only and are not to be construed in a limiting sense. The scope of the present invention is limited only by the language of the following claims.<br><br>
Claims<br>
1.	A method of port type agnostic proxy support for web services intermediaries, the method comprising: receiving in a web services intermediary a request for execution of a web services operation, wherein the request includes parametric information from which an endpoint for a target service that supports the operation can be identified; identifying, in dependence upon the parametric data, the endpoint for a target service that supports the operation; creating a target service request for execution of the operation on the target service; and issuing the target service request to the target service.<br>
2.	The method of claim 1, wherein the request does not require a synchronous response, and the method further comprises: receiving from the target service an acknowledgment of the target service request; and returning the acknowledgement to a requester without waiting for a response message.<br>
3.	The method of claim 1, wherein receiving synchronously in the intermediary a response from the target service further comprises invoking a blocking receive function on a data communications connection between the intermediary and the target service.<br>
4.	The method of claim any preceding claim wherein the target service request as created and issued to the target service bears unexamined and unmodified message contents of the request received in the web services intermediary.<br>
5.	A system for port type agnostic proxy support for web services intermediaries, the system comprising: means for receiving in a web services intermediary a request for execution of a web services operation, wherein the request includes parametric information from which an endpoint for a target service that supports the operation can be identified; means for identifying, in dependence upon the parametric data, the endpoint for a target service that supports the operation; means for creating a target service request for execution of the operation on the target service; and means for issuing the target service request to the target service.<br>
6.	The system of claim 5, wherein the request does not require a synchronous response, and the system further comprises: means for receiving from the target service an acknowledgment of the target service request; and means for returning the acknowledgement to a requester without waiting for a response message.<br>
7.	The system of claim 5, wherein means for receiving synchronously in the intermediary a response from the target service further comprises means for invoking a blocking receive<br><br>
function on a data communications connection between the intermediary and the target service.<br>
8.	The system of any of claims 5 to 7, wherein the target service request as created and issued to the target service bears unexamined and unmodified message contents of the request received in the web services intermediary.<br>
9.	A computer program product for port type agnostic proxy support for web services intermediaries, the computer program product comprising: a recording medium; means, recorded on the recording medium, for receiving in a web services intermediary a request for execution of a web services operation, wherein the request includes parametric information from which an endpoint for a target service that supports the operation can be identified; means, recorded on the recording medium, for identifying, in dependence upon the parametric data, the endpoint for a target service that supports the operation; means, recorded on the recording medium, for creating a target service request for execution of the operation on the target service; and means, recorded on the recording medium, for issuing the target service request to the target service.<br>
10.	The computer program product of claim 9, wherein the request does not require a synchronous response, and the system further comprises: means, recorded on the recording medium, for receiving from the target service an acknowledgment of the target service request; and means, recorded on the recording medium, for returning the acknowledgement to a requester without waiting for a response message.<br>
11.	The computer program product of claim 8, wherein means for receiving synchronously in the intermediary a response from the target service further comprises means, recorded on the recording medium, for invoking a blocking receive function on a data communications connection between the intermediary and the target service.<br>
12.	The computer program product of any of claims 8 to 11, wherein the target service request as created and issued to the target service bears unexamined and unmodified message contents of the request received in the web services intermediary.<br>
Dated this 12 day of July 2006 <br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1DSEVOUC0yMDA2ICAgIENPUlJFU1BPTkRFTkNFIE9USEVSUyAgMTQtMDMtMjAxMS5wZGY=" target="_blank" style="word-wrap:break-word;">2545-CHENP-2006    CORRESPONDENCE OTHERS  14-03-2011.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1DSEVOUC0yMDA2ICAgQU1FTkRFRCAgUEFHRVMgT0YgU1BFQ0lGSUNBVElPTiAgMTgtMDQtMjAxMS5wZGY=" target="_blank" style="word-wrap:break-word;">2545-CHENP-2006   AMENDED  PAGES OF SPECIFICATION  18-04-2011.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1DSEVOUC0yMDA2ICAgQU1FTkRFRCBDTEFJTVMgIDE4LTA0LTIwMTEucGRm" target="_blank" style="word-wrap:break-word;">2545-CHENP-2006   AMENDED CLAIMS  18-04-2011.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1DSEVOUC0yMDA2ICAgRk9STS0xMyAgMTgtMDQtMjAxMS5wZGY=" target="_blank" style="word-wrap:break-word;">2545-CHENP-2006   FORM-13  18-04-2011.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1jaGVucC0yMDA2ICAgZm9ybS0zICAxOC0wNC0yMDExLnBkZg==" target="_blank" style="word-wrap:break-word;">2545-chenp-2006   form-3  18-04-2011.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1jaGVucC0yMDA2ICAgb3RoZXIgcGF0ZW50IGRvY3VtZW50ICAxOC0wNC0yMDExLnBkZg==" target="_blank" style="word-wrap:break-word;">2545-chenp-2006   other patent document  18-04-2011.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1DSEVOUC0yMDA2ICAgT1RIRVIgUEFURU5UIERPQ1VNRU5ULiAgMTgtMDQtMjAxMS5wZGY=" target="_blank" style="word-wrap:break-word;">2545-CHENP-2006   OTHER PATENT DOCUMENT.  18-04-2011.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1DSEVOUC0yMDA2ICBDT1JSRVNQT05ERU5DRSBPVEhFUlMucGRm" target="_blank" style="word-wrap:break-word;">2545-CHENP-2006  CORRESPONDENCE OTHERS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1DSEVOUC0yMDA2ICBDT1JSRVNQT05ERU5DRSBQTy5wZGY=" target="_blank" style="word-wrap:break-word;">2545-CHENP-2006  CORRESPONDENCE PO.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1DSEVOUC0yMDA2ICBFWEFNSU5BVElPTiBSRVBPUlQgUkVQTFkgUkVDSUVWRUQgIDE4LTA0LTIwMTEucGRm" target="_blank" style="word-wrap:break-word;">2545-CHENP-2006  EXAMINATION REPORT REPLY RECIEVED  18-04-2011.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1DSEVOUC0yMDA2ICBGT1JNLTE4LnBkZg==" target="_blank" style="word-wrap:break-word;">2545-CHENP-2006  FORM-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1jaGVucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">2545-chenp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1jaGVucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">2545-chenp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1jaGVucC0yMDA2LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">2545-chenp-2006-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1jaGVucC0yMDA2LWRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">2545-chenp-2006-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1jaGVucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">2545-chenp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1jaGVucC0yMDA2LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">2545-chenp-2006-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1jaGVucC0yMDA2LWZvcm0gMjYucGRm" target="_blank" style="word-wrap:break-word;">2545-chenp-2006-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1jaGVucC0yMDA2LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">2545-chenp-2006-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1jaGVucC0yMDA2LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">2545-chenp-2006-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjU0NS1jaGVucC0yMDA2LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">2545-chenp-2006-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="250900-device-for-controlling-supply-of-current-and-static-capacitance-to-compressor.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="250903-pyrazolo-1-5-a-pyridines-and-medicines-containing-the-same.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>250902</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2545/CHENP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>06/2012</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>10-Feb-2012</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>06-Feb-2012</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>12-Jul-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTERNATIONAL BUSINESS MACHINES CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>Armonk,New York 10504.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>FLURRY, Gregory, Alan</td>
											<td>9821 Mandeville Circle, Austin, Texas 78750-2854</td>
										</tr>
										<tr>
											<td>2</td>
											<td>HOLDSWORTH, Simon, Antony, James</td>
											<td>&quot;Lostwithiel&quot; Four Hillbury Avenue, Andover Hampshire SP10 2LZ.</td>
										</tr>
										<tr>
											<td>3</td>
											<td>SNELL, James, Michael</td>
											<td>2174 Cottonwood Court, Hanford, California 93230</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04L29/08</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/EP2004/053382</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-12-09</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/734,773</td>
									<td>2003-12-12</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>10/734,770</td>
									<td>2003-12-12</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/250902-port-type-agnostic-proxy-support-for-web-services-intermediaries by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:11:02 GMT -->
</html>
