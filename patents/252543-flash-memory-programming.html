<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/252543-flash-memory-programming by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:18:43 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 252543:FLASH MEMORY PROGRAMMING</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">FLASH MEMORY PROGRAMMING</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Disclosed is a method for updating program code stored in a memory, which memory comprises a plurality of memory sectors. The method comprises transforming an updated input code into an updated program code version to be stored in a memory, which memory has stored thereon a current program code version occupying a first set of the memory sectors of the memory, wherein the updated program code version occupies a second set of memory sectors when stored in the memory. The transforming step further comprises receiving a representation of the current program code version; and performing at least one optimisation step adapted to decrease the number of memory sectors of the second set of memory sectors occupied by the updated code version that are different from the corresponding memory sectors of the first set of memory sectors occupied by the current program code version.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT, 1970<br>
(39 of 1970)<br>
&amp;<br>
THE PATENTS RULES, 2003<br>
COMPLETE SPECIFICATION<br>
(See section 10, rule 13)<br>
FLASH MEMORY PROGRAMMING<br>
TELEFONAKTIEBOLAGET LM ERICSSON (publ) of SE-164 83  Stockholm, Sweden<br>
The following specification particularly describes and ascertains the invention and the manner in which it is to be performed.<br><br>
fW0 2005/085996	PCT/EP2005/000190<br><br><br><br>
Flash  memory  programming<br><br><br>
This invention relates to the updating of program code stored in a memory<br>
which memory comprises a plurality of memory sectors. <br>
5<br>
Many modern electronic devices, e.g. embedded devices, are controlled by software stored on flash memory. Flash memory is a popular type of memory in electronic devices, because it allows multiple rewrites. However, the write operations are limited to entire memory sectors, so-called pages, at a time. A <br>
10     	typical page size of current flash memories is 64 kbyte.<br>
When the software stored in a flash memory of an electronic device is updated, e.g. in order to add new features to the software and/or to correct errors in the current version of the software, some or all of the memory <br>
15     	sectors of the flash memory are re-written or "re-flashed". In general, it is desirable to minimize the number of flash pages that are re-written during a software update, in order to minimize the time required for installing the software update.<br>
20       In particular, an application where update times are of great concern is the over-the-air (OTA) update of mobile terminals. In such applications, it is known to distribute only modifications to the current image to the mobile terminal rather than the entire updated image. The modifications are generally referred to as delta-files. In such systems, an update agent running<br>
25       on the mobile terminal applies the received modifications to the current<br>
image which is thereby transformed to the updated version. It is a particular problem of such update systems that the terminal is not functional during the update process. Hence, it is desirable to reduce the time required for reflashing the memory and, thus, the downtime of the system.<br>
30<br>
2<br><br>
WO 2005/085996	PCT/EP2005/000190<br>
However, due to the constraints of the flash memory mentioned above, even small updates of the source code of the software may cause a large portion of the flash pages to be updated, since changing even a single byte requires an entire page to be completely rewritten. <br>
5<br>
Published US application 2003/0142556 discloses a method of flash memory programming, wherein volatile information or volatile software components are stored at least near the end of the respective flash memory address space of the flash memory device to keep the need of changing or adjusting <br>
10   	  flash sectors as slight as possible.<br>
However, the above prior art method requires information about the anticipated likelihood of changing the respective information components. Hence, the above prior art does not address the problem of reducing the <br>
15      number of required re-writes when updating program code in a memory with a plurality of memory sectors, without requiring information about the anticipated likelihood of future changes in the respective software components.<br>
20      The above and other problems are solved by a method for updating program code stored in a memory, which memory comprises a plurality of memory sectors, the method comprising<br>
-	transforming an updated input code into an updated program code<br>
version to be stored in a memory, which memory has stored thereon a<br>
25		current program code version occupying a first set of the memory<br>
sectors of the memory, wherein the updated program code version occupies a second set of memory sectors when stored in the memory; wherein the transforming further comprises<br>
           -         receiving a representation of the current program code version; and<br>
30       -    	    performing at least one optimisation step adapted to decrease the<br>
           number of memory sectors of the second set of memory sectors<br>
3<br><br>
WO 2005/085996	PCT/EP2005/000190<br>
occupied by the updated code version that are different from the corresponding memory sectors of the first set of memory sectors occupied by the current program code version.<br>
5  	  In particular, by receiving a representation of the current program code version; and performing at least one optimisation process adapted to decrease the number of memory sectors of the second set of memory sectors occupied by the updated code version that are different from the corresponding memory sectors of the first set of memory sectors occupied by <br>
10       the current program code version, the number of required re-writes is reduced.<br>
As the current program code version stored in the memory is generally known to the process that generates a software update, the above 15     optimisation is based on information that is readily available to the updating process. In particular, the process is based on information about the currently installed version and the current update, whereas no information about the likelihood of any future updates is required.<br>
20       In a preferred embodiment, the representation of the current program code version comprises a current image of the first set of memory sectors and/or a map file description of the current image of the first set of memory sectors. Consequently, the representation comprises information about the layout of the program code components in the memory, thereby allowing the<br>
25       optimisation process to adapt the layout of the updated components as to reduce the differences between both versions.<br>
Typically, a code generation system comprises a compiler which compiles a source code and generates a number of object code modules, and a linker <br>
30      which generates the executable code. The linker resolves dependencies between the set of object code modules that constitute a software<br>
4<br><br>
WO 2005/085996	PCT/EP2005/000190<br>
development project. The tasks of the linker generally include laying out the object modules in memory, i.e. assigning relative addresses to the different object modules in a corresponding address space. Hence, at the linker stage, the necessary information about the layout of the code in the memory <br>
5     	space is available. The object module is typically represented as an object file in a low-level file format that is hardware and/or platform specific. The object file is generated by a compiler and serves as an input to the linker. An object module is typically relocatable	 and contains unresolved references.<br>
10       Here the term layout of the code in memory comprises the respective start or base addresses of the different object modules, i.e. their respective relative addresses within the address space occupied by the program code.<br>
Consequently, in a preferred embodiment of the invention, the optimisation <br>
15       process is performed at the linker stage. Hence, the input code comprises a number of object modules and the transforming comprises linking the number of object modules. Preferably, the optimisation process comprises determining the layout of said object modules in memory.<br>
20      In another preferred embodiment, the input code comprises at least one source code module; the transforming comprises<br>
-	compiling the at least one source code module resulting in a number of object modules; and<br>
-	linking the number of object modules;<br>
25		and performing at least one optimisation step comprises<br>
                -     generating feedback data during the linking step; and<br>
                -    re-compiling at least a subset of the source code modules based on the   feedback data and resulting in a number of modified object modules; and<br>
30                       -     performing the linking step based on the number of modified object<br>
                      modules.<br>
5<br><br>
WO 2005/085996<br><br>
PCT/EP2005/000190<br><br>
-5-*<br>
Consequently, according to this embodiment, the linker generates feedback to the compiler stage causing the compiler to re-compile at least a part of the source code. This has the advantage that the linker controls the resulting set<br>
5     	of object modules, thereby increasing the degrees of freedom of re-arranging object code modules by the linker.<br>
In yet another preferred embodiment, the transforming further comprises controlling the optimisation process by at least one optimisation parameter.<br>
10      Hence, a mechanism for controlling the optimisation process is provided. In some embodiments the optimisation parameters determine one or more limitations for the optimisation process. For example, one or more of the optimisation parameters may determine a maximum allowed increase in size caused by the optimisation process such as a maximum size of padding<br>
15       space allowed to be added by the optimisation process. Alternatively or additionally, at least one optimisation parameter may include a parameter determining a maximum allowed number of relays introduced by the optimisation process.<br>
20       It is an advantage of the invention that the trade-off between the benefits - in terms of the required number of re-writes - and the costs - in terms of memory size, execution time, etc. -of the optimisation process may easily be controlled.<br>
25       Accordingly, in a preferred embodiment, determining the layout of said object modules in memory comprises<br>
-   detecting an updated first object module having a different size than a<br>
                      corresponding first current object module, and an updated second<br>
                     object module equal to a corresponding second current object module,<br>
30	                           which updated second object module has a base address larger than<br>
the base address of the updated first object module; and<br>
6<br><br>
\V0 2005/085996	PCT/EP2005/000190<br>
           -   padding the detected updated first object module with a predetermined<br>
memory content of a predetermined padding  size resulting  in   a<br>
padded updated first object module; wherein the padding size   is<br>
selected to cause the base address of the updated second object<br>
5		module to be equal to the base address of the corresponding second<br>
    current object module.<br>
In another preferred embodiment, determining the layout of said object<br>
modules in memory comprises<br>
10	          -   detecting  an  updated first object  module that  is larger than   a<br>
     corresponding first current object module;<br>
-   moving a predetermined part of the updated first object module to a<br>
    different memory sector resulting in a reduced updated first object<br>
     module and a moved part of the updated first object module;<br>
15	-   inserting a relay to the moved part of the updated first object module in<br>
               the reduced first updated memory sector.<br>
In yet another preferred embodiment, the method further comprises generating a delta file representative of differences between the current<br>
20       program code version and the updated program code version. Hence, the resulting delta file includes the differences between the current and updated versions, i.e. the information required for the device to generate the updated version from the current version stored in the device and the delta file. It is an advantage of this embodiment, that the size of the file that needs to be<br>
25       uploaded to the device is reduced, thereby further reducing the time required to perform a software update.<br>
Further preferred embodiments are disclosed in the dependant claims.<br>
30       It is noted that the features of the method described above and in the following  may be  implemented in software and  carried out on  a  data<br>
7<br><br>
WO 2005/085996	PCT/EP2005/000190<br>
processing system or other processing means caused by the execution of program code means such as computer-executable instructions. Here, and in the following, the term processing means comprises any circuit and/or device suitably adapted to perform the above functions. In particular, the term<br>
 5        processing means comprises general- or special-purpose programmable microprocessors,   Digital  Signal   Processors  (DSP),  Application   Specific Integrated   Circuits   (ASIC),   Programmable   Logic   Arrays   (PLA),   Field Programmable Gate Arrays (FPGA), special purpose electronic circuits, etc., or a combination thereof. <br>
10<br>
For example, the program code means may be loaded in a memory, such as a RAM, from a storage medium or from another computer via a computer network. Alternatively, the described features may be implemented by hardwired circuitry instead of software or in combination with software.<br>
15<br>
The present invention can be implemented in different ways including the method described above and in the following, a data processing system, and further product means, each yielding one or more of the benefits and advantages described in connection with the first-mentioned method, and <br>
20   each having one or more preferred embodiments corresponding to the preferred embodiments described in connection with the first-mentioned method.<br>
In particular, the invention relates to a data processing system for updating <br>
25       program code stored in a memory, the memory comprising a plurality of memory sectors, the data processing system being suitably programmed to perform the steps of the method described above and in the following.<br>
The invention further relates to a computer program product comprising<br>
30       program code means adapted to cause a data processing system to perform<br>
the method described above and in the following, when said program code<br>
means are executed on the data processing system. The computer program<br>
8<br><br>
WO 2005/085996	PCT/EP2005/000190<br>
product may be embodied as a computer-readable medium having stored thereon said program code means.<br>
For the purpose of the present description, the term electronic device <br>
5	 comprises any device comprising a memory such as a flash memory for storing program code. Examples of such devices include portable radio communications equipment and other handheld or portable devices. The term portable radio communications equipment includes all equipment such as! mobile telephones, pagers, communicators, i.e. electronic organisers, <br>
10	 smart phones, personal digital assistants (PDAs), handheld computers, or the like.<br>
The above and other aspects of the invention will be apparent and elucidated from the embodiments described in the following with reference to the <br>
15        drawing in which:<br>
fig. 1 schematically shows a block diagram of an embodiment of a system for updating software in a mobile terminal;<br>
20      fig 2 schematically shows a block diagram of a mobile terminal according to an embodiment of the invention;<br>
fig. 3 shows a block diagram of an embodiment of a software update process;<br>
25<br>
fig. 4 schematically illustrates the memory layout of a flash memory before and after a software update where the layout is optimised via an introduction of padding space;<br>
30    	  fig. 5 schematically illustrates the memory layout of a flash memory before and after a software update where the layout is optimised via an introduction of a relay;<br>
9<br><br>
WO 2005/085996<br><br>
PCT/EP2005/000190<br><br>
9<br>
fig. 6 shows a block diagram of another	 embodiment of a software update process;<br>
5<br>
Fig. 1 schematically shows a block diagram of an embodiment of a system for updating software in an electronic device such as a mobile terminal. The system comprises a mobile terminal 101, e.g. a mobile telephone or the like, a software updating system 102, and a communications interface 103.<br>
10<br>
The software updating system 102 may comprise a server computer having access to the communications network. In some embodiments, the functionality of the server computer may be distributed among a plurality of computers, e.g. computers connected via a computer network, e.g. a local<br>
15      area network, a wide area network, an Internet, or the like. The software<br>
updating system 102 comprises an interface circuit 104 allowing the software updating system to communicate data via the communications interface 103. For example, the interface circuit may comprise a serial port, a parallel port, a short range wireless communications interface, e.g. an infrared port, a<br>
20      Bluetooth transceiver, or the like. Further examples of interface circuits include a network card, a DSL modem, a gateway computer, or the like.<br>
The software updating system further comprises a processing unit 105, e.g. the CPU of a server computer, suitably programmed to control and perform<br>
25      the update process including the generation of the updated program code as described herein. The processing unit further comprises a version database 106 having stored therein memory images of at least a base version and an updated version of the software to be updated. In some embodiments, the version database may further comprise additional information, e.g. a plurality<br>
30      of base versions and/or updated versions, e.g. for different models of mobile terminals, for different groups of customers, and/or the like.<br>
10<br><br>
WO 2005/085996	PCT/EP2005/000190<br>
The communications interface 103 may be any suitable wired or wireless communications interface for communicating data between the software updating system 102 and the mobile terminal 101. For example, in the case<br>
 5       of a mobile telephone adapted to communicate via a cellular communications<br>
i<br>
network, e.g. a GSM network, a UMTS network, a GPRS network, or the like, the communication between the software updating system and the mobile terminal in connection with a software update may be performed via that cellular communications network, thereby avoiding the need for additional<br>
10       communications interfaces in the mobile terminal. It is further understood that the communication between the mobile terminal and the software updating system may involve more than one communications networks. For example, the mobile phone may communicate via a base station and a cellular telecom network with a gateway system that, in turn, provides communication with the<br>
15       software updating system via the Internet.<br>
Hence, in order to update software on the mobile terminal 101, e.g. the firmware or operating system of the mobile terminal, the mobile terminal connects to the software updating system 102. Alternatively, the software<br>
20        updating system may connect to the mobile terminal once an updated software version is available. Once connected to the software updating system, the mobile terminal sends information to the software updating system about its current software version. The communication is performed via a suitable updating protocol, e.g. a protocol built on top of a TCI/IP<br>
25        protocol. Based on the information received from the mobile terminal, the software updating system generates a dedicated updating message comprising updating instructions to the mobile terminal. In some embodiments, the updating instructions include the images of the memory sectors to be rewritten. In a differential updating system using delta files, the<br>
30        updating instructions are generated such that they enable the mobile terminal to generate the updated software version from the existing version already<br>
11<br><br>
WO 2005/085996	PCT7EP2005/000190<br>
11<br>
stored in the mobile terminal and from additional information included in the updating instructions.<br>
In one embodiment, the update process is initiated by an update agent <br>
5 	running on the mobile terminal. The update agent controls the reception and verification of the delta file. Subsequently, the update agent causes the mobile terminal to be disconnected from the network and rebooted in a patch mode. In patch mode, the changes in the delta file are applied incrementally until the new memory image is complete. <br>
10<br>
The generation of the delta file generation may schematically be illustrated by the following operations<br>
filenew – filebase   → ∆file <br>
15<br>
Correspondingly, the actual generation of the new version may then be performed by the mobile terminal according to the following operation<br>
filebase + ∆file →  filenew<br>
20<br>
It is understood that the above operations of generating the delta file (denoted as "-" in the above notation) and generating the new version on the mobile terminal (denoted as "+” operation in the above notation) may comprise more or less complex operations.<br>
25<br>
The delta file may be applied in-place, i.e. the changes are made by the mobile terminal on the existing image, thereby requiring little additional -  storage. Furthermore, since only the delta file needs to be loaded and since the delta file typically is considerably smaller than the new version, the<br>
30      loading time is reduced by the above method.<br>
12<br><br>
WO 2005/085996	PCT/EP2005/000190<br>
Embodiments of the code generation process will be described in greater detail below.<br>
Fig. 2 schematically shows a block diagram of an electronic device such as a<br>
 5       mobile terminal. The mobile terminal 101 comprises a communications block 210, a processing unit 211, and s memory unit 212.<br>
The communications block 210 comprises circuitry and/or devices allowing radio-based communication of data via a cellular communications network.<br>
10       Hence, for the purpose of the present description, the communications block 210 comprises receiver circuitry and transmitter circuitry for receiving and transmitting data signals. The communications block may further comprise circuitry for suitably processing the signals, e.g. modulating, coding, amplifying, etc., the signals by suitable techniques well known in the art of<br>
15       radio communications.<br>
The mobile terminal further comprises a processing unit 211, e.g. a suitably programmed microprocessor. The processing unit is adapted to determine the version of the software stored in the mobile terminal, to calculate <br>
20       checksums of the stored software, and to generate an updated version of the software upon receipt of corresponding update instructions.<br>
The memory unit 212 has stored thereon the software and/or other data in a predetermined version. For example, the memory 212 may comprise the<br>
25       firmware of the mobile terminal that implements the basic functions of the mobile terminal when loaded into and executed by the processing unit 210. The firmware may further comprise an operating system allowing application software to be executed. Accordingly, the memory 212 may further have stored thereon application software providing additional functionality. The<br>
30       memory 212 is addressed using a suitable address space, thereby allowing the processing unit to access selected parts of the memory. In some<br>
13<br><br>
WO 2005/085996	PCT/EP2005/000190<br>
embodiments the memory 212 may be logically or physically divided in a plurality of memory sectors. For example, the memory 212 may comprise flash memory allowing data to be written in sectors of a predetermined size.<br>
5	 In the following, it will be assumed that the memory 212 is divided in a number of sectors of a predetermined size denoted P1, P2, P3, .... PN. However, it is understood that any other addressing of the memory may be used, instead. It is further understood that the updating process described herein may be applied to the entire memory 212, e.g. if the entire image of <br>
10	 the flash memory of a mobile phone is to be updated, or to only predetermined parts of the memory, e.g. if one or more software applications are to be updated.<br>
Fig. 3 shows a block diagram of an embodiment of a software update <br>
15      process. The linker module 302 receives a number of object files 301. Each of the object files 301 is compiled by a compiler (not shown), wherein some or all of the object files may be compiled separately from each other. The linker module 302 combines the object modules into an absolute file 305 ready for execution. One of the tasks performed by the linker module 302 is 20 the resolution of cross-references among separately compiled object modules and the assigning of final addresses to create a single executable program 305. Hence, the output 305 from the linker is a file that can directly be loaded into the flash memory. The output 305 will also be referred to as a build file.<br>
25<br>
The linker module 302 further receives information about a previous build file 303, e.g. in the form of an image of the corresponding address space in a flash memory where the current build is stored. In another embodiment, the linker 302 may also generate a text-file representation of the memory layout<br>
30       of the current build, a so-called map file. For example, the map file may comprise a list of functions, the addresses assigned to them, their input<br>
14<br><br>
' WO 2005/085996	PCT/EP2005/000190<br>
44-<br>
parameters, etc. In such an embodiment, the information 303 about the<br>
previous build may comprise the corresponding map file of the previous build.<br>
In yet another embodiment, the linker module receives both the map file and<br>
the memory image of the previous build.<br>
5<br>
The linker module 302 is adapted to generate the memory image of the new<br>
build 305 such that the new image resembles the memory image of the<br>
previous build 303 as much as possible. Hence, the linker is adapted to<br>
perform a number of optimisation steps in order to reduce the differences i <br>
10     between the memory images. Examples of such optimisation steps include:<br>
-	The introduction of extra padding space between modules in order to<br>
avoid the need to move modules around relative to their location in the<br>
previous build. This will be illustrated in connection with fig. 4.<br>
15		-   Splitting up an object module into two or more sub-modules with<br>
references between them, i.e. introducing so-called relays, as will be illustrated in connection with fig. 5.<br>
-	Combinations of the above.<br>
20 	The linker module 302 further receives one or more optimisation parameters 304 for controlling the optimisation steps. For example, the optimisation parameters may determine which optimisation steps the linker should perform. Furthermore, the optimisation parameters may determine a number of limitations or boundary conditions for one or more of the optimisation<br>
25     steps. Hence, the linker may be configured to reduce, preferably to minimize, the difference between the new build and the previous build within a number of limitations or boundary conditions determined by the optimisation parameters.<br>
30      Example of optimisation parameters include<br>
15<br><br>
WO 2005/085996	PCT/EP2005/000190<br>
XT<br>
-	a maximum bound on the allowed padding space that the linker is allowed to introduce,<br>
-	a maximum number of relays that the linker is allowed to introduce.<br>
5     	It is understood that, in some embodiments, one or more of the above optimisation parameters may be pre-set to predetermined default values. Fig. 4 schematically illustrates the memory layout of a flash memory before and after a software update where the layout is optimised via an introduction of padding space.<br>
10<br>
Fig. 4a illustrates the structure of a part of the address space of a flash memory. The address space 401 is divided into a number of pages denoted P1, P2, P3, P4, P5, P6, P7, and P8. The pages have a predetermined size S; in a typical conventional flash memory the page size is 64 kbyte.<br>
15<br>
Fig. 4b illustrates an example of the memory layout of a program code version V1, generally referred to by reference numeral 402, stored in the address space 401. The program code version in this example comprises five object modules designated A, B, C. D, and E. The object modules have<br>
20       different sizes and are sequentially arranged in the address space 401. This layout is also referred to as a monolith.<br>
Fig. 4c illustrates an updated version V2 of the program code, generally designated 403. In this example, it is assumed that the only change between<br>
25       version V1 and version V2 is the replacement of module A by module A', where the module A' is assumed to be larger than the previous module A as illustrated by the additional memory space 405 required for A*. The remaining modules B, C, D, and E are assumed to be unchanged, i.e. identical to the corresponding portion of version V1. However, as is illustrated by reference<br>
30       numeral 406 in fig. 4c, when sequentially arranging the updated version V2, the entire content of memory pages P1 through P7 need to be rewritten.<br><br><br>
' WO 2005/085996	PCT/EP2005/000190<br>
Pages P1, P2, and P3 need to be rewritten, because the content of module A has changed to A', and the remaining pages need to be rewritten because the location of the modules B, C, D, and E is changed between versions V1 and V2. <br>
5<br>
Fig. 4d illustrates an optimised memory layout of the updated program version V2, generally designated 404. In the example of fig. 4d, the linker has moved module B to the end of the monolith. Furthermore, the linker has inserted a padding space of unused memory 407 between modules A' and C. <br>
10       The size of the padding space 407 is determined as to allow the start<br>
address of module C in version V2 to be the same as in the previous version VI. Consequently, the memory image of modules C, D, and E is unchanged, assuming that they do not reference entities in module B, i.e. that no references are changed. Hence, when updating the memory with the <br>
15       optimised updated version V2 to replace the previous version V1, i.e. by re-flashing the relevant pages of a flash memory, only pages P1, P2, P3, P7, and P8 need to be re-written, as illustrated by reference numeral 408. The remaining pages, i.e. pages P4, P5, and P6 need not be re-written.<br>
20      It is understood that, in a situation where A' is smaller than A, the layout may be optimised by merely adding a suitable padding space ensuring an unchanged base address of module B, i.e. without moving B.<br>
It is further understood that the above optimisation of the memory layout by <br>
25	adding a padding space reduces the number of necessary re-writes at the cost of an increased size of the memory image corresponding to the size of the additional padding space. As mentioned above, this trade-off can be controlled by a optimisation parameter that determines the maximum size of padding space allowed to be inserted by the linker.<br>
30<br>
17<br><br>
WO 2005/085996	PCT/EP2005/000190<br><br>
It is further noted that the relocation of memory module B in the above example may induce changes in one or more of the modules C, D, and E, if they include references to functions in module B. Such references would be affected by a re-addressing of module B. Modules which no other functions in <br>
5         the unchanged modules refer to, may be freely moved, while a movement of a module that is reference by an otherwise unchanged module increases the cost in terms of the number of required re-writes. Consequently, it is preferred that the linker is configured to determine the total effect/cost of the movement of an object module in order to determine whether and which <br>
10       modules to move.<br>
Hence, in one embodiment, the determination of the layout of the object modules in memory comprises<br>
-	detecting an updated first object module having a different size than a<br>
15	corresponding first current object module, and an updated second<br>
object module equal to a corresponding second current object module, which updated second object module has a base address larger than the base address of the updated first object module; and<br>
-	padding the detected updated first object module with a predetermined<br>
20                             memory content of a predetermined  padding size resulting in  a<br>
padded updated first object module; wherein the padding size is selected to cause the base address of the updated second object module to be equal to the base address of the corresponding second current object module. <br>
25<br>
Fig. 5 schematically illustrates the memory layout of a flash memory before<br>
and after a software update where the layout is optimised via an introduction<br>
of a relay.<br>
18 <br>
"WO 2005/085996	PCT/EP2005/000190<br>
Fig. 5a illustrates the structure of a part of the address space of a flash memory. The address space 501 is divided into a number of pages denoted P1, P2, P3, P4, P5, P6, P7, and P8. The pages have a predetermined size S<br>
5         Fig. 5b illustrates an example of the memory layout of a program code version V1, generally referred to by reference numeral 502, stored in the address space 501. As in the previous example, the program code version comprises five object modules designated A, B, C, D, and E. The object modules have different sizes and are sequentially arranged in the address <br>
10        space 501.<br>
Fig. 5c illustrates an updated version V2 of the program code, generally designated 503. Again, it is assumed that the only change between version V1 and version V2 is that module A is replaced by module A', where the<br>
15       module A' is assumed to be larger than the previous module A as illustrated by the additional memory space 505 required for A'. The remaining modules B, C, D, and E are assumed to be unchanged, i.e. identical to the corresponding portion of version V1. However, as is illustrated by reference numeral 506 in fig. 5c, when sequentially arranging the updated version V2,<br>
20      the entire content of memory pages P1 through P7 need to be rewritten.<br>
Pages P1, P2, and P3 need to be rewritten, because the content of module A has changed to A', and the remaining pages need to be rewritten because the location of the modules B, C, D, and E is changed between versions V1 and V2.<br>
25<br>
Fig. 5d illustrates an optimised memory layout of the updated program version V2, generally designated 504. In the example of fig. 5, it is assumed that a part of the object module A' is only referenced from within A', i.e. not from any of the other modules. This.part of A' is denoted A2". The remaining<br>
30       part of A', denoted AV, is referenced from one or more of the other modules. Consequently, as illustrated in fig. 5d, the linker module may split up module<br>
19<br><br>
WO 2005/085996	PCT/EP2005/000190<br>
A' into Ai' and A2', and move module A2' to the end of the monolith and change the internal references in A-T to A2' accordingly, i.e. by introducing a relay. Furthermore, the linker inserts a padding space 507 such that the start address of module B remains unchanged compared to the previous version <br>
5    	 V1. Consequently, the memory image of modules B, C, D, and E is<br>
unchanged. Hence, when uploading the optimised updated version V2 to replace the previous version V1, only pages P1, P2, P7, and P8 need to be re-written, as illustrated by reference numeral 508. The remaining pages, I.e. pages P3, P4, P5, and P6 need not be re-written. <br>
10<br>
Hence, in this embodiment, the determination of the layout of the object modules in memory comprises<br>
-	detecting  an  updated  first object module  that is  larger than  a<br>
corresponding first current object module;<br>
15 		-   moving a predetermined part of the updated first object module to a<br>
different memory sector resulting in a reduced updated first object module and a moved part of the updated First object module;<br>
-	inserting a relay to the moved part of the updated first object module in<br>
the reduced first updated memory sector.<br>
20<br>
It is understood that the above optimisation of the memory layout by relaying reduces the number of necessary re-writes at the cost of an execution time penalty due to the relay. As mentioned above, this trade-off can be controlled by a optimisation parameter that determines the maximum number of relays<br>
25       allowed to be inserted by the linker.<br>
It is further noted that in the example of fig. 5, the introduction of a relay is combined with the insertion of padding space.<br>
30      It is further understood that, in other embodiments, the splitting up of a<br>
module in two separate modules is performed by a compiler rather than the	 <br>
20<br><br>
WO 2005/085996	PCT/EP2005/000190<br>
linker itself. Such an embodiment, in which the linker sends a feedback signal to the compiler, will be described in the following:<br>
Fig. 6 shows a block diagram of another embodiment of a software update <br>
5         process. This embodiment is similar to the embodiment described in connection with fig. 3, where like reference numerals refer to the same components. In the embodiment of fig. 6, the linker 302 further generates a feedback signal 608 to the compiler 606 that has generated the object files 301 from a corresponding set of source files 607. The feedback signal<br>
10       causes the compiler to re-compile one or more of the source files resulting in modified object files that are more suitable for the generation of the optimised memory layout by the linker. In the situation illustrated in fig. 5 for example, the linker 302 may request the compiler 606 to generate object modules A-T and A2' instead of A*. In one embodiment, the feedback signal 608 may even<br>
15       include information about which functions to include in each of the sub-modules.<br>
Hence, in the above, a linker is disclosed that is configured to reduce the number of rewrites required when updating program code in a flash memory. <br>
20<br>
The invention can be implemented by means of hardware comprising several<br>
distinct elements, and by means of a suitably programmed computer. In the<br>
device claims enumerating several means, several of these means can be<br>
embodied   by  one   and   the  same  item  of hardware,   e.g.   a  suitably<br>
25       programmed    microprocessor    or    computer,    and/or    one    or    more<br>
communications interfaces as described herein. The mere fact that certain<br>
measures are recited.in mutually different dependent claims or described in<br>
different  embodiments  does not indicate that a  combination of these<br>
measures cannot be used to advantage. <br>
30<br>
It should be emphasized that the term "comprises/comprising" when used in this specification is taken to specify the presence of stated features, integers,<br>
21<br><br>
WO 2005/085996	PCT/EP2005/000190<br>
steps or components but does not preclude the presence or addition of one or more other features, integers, steps, components or groups thereof.<br><br>
i<br><br>
22<br><br>
1<br>
CLAIMS:<br>
1.	A method for updating program code stored in a memory (212), which memory comprises a plurality of memory sectors (P1, P2, P3, P4, P5, P6, <br>
5      		P7, P8), the method comprising transforming (606, 302) at least one updated source code module (607) into an updated program code version (305) to be stored in a memory (212), which memory has stored thereon a current program code version occupying a first set of the memory sectors of the memory, wherein the updated program code version occupies a second set<br>
10                 of memory sectors when stored in the memory;<br>
wherein the transforming further comprises<br>
-	compiling (606) the at least one source code module resulting in a<br>
number of object modules (301);<br>
15		-   receiving a representation (303) of the current program code version;<br>
and<br>
-	performing (302) at least one optimisation step adapted to decrease<br>
the number of memory sectors of the second set of memory sectors<br>
occupied by the updated code version that are different from the<br>
20		corresponding memory sectors of the first set of memory sectors<br>
occupied by the current program code version;<br>
characterised in that performing at least one optimisation step comprises<br>
-	generating feedback data (608) during a linking step (302) for<br>
25	linking the number of object modules;<br>
-	re-compiling (606) at least a subset of the source code modules<br>
based on the feedback data and resulting in a number of modified<br>
object modules; and<br>
-	performing a linking step (302) based on the number of modified<br>
30                                 object modules.<br>
23<br><br>
2<br>
2.	A method according to claim 1, wherein the representation of the current<br>
program code version comprises at least one of a current image of the first<br>
set of memory sectors and a map file description of the current image of the<br>
first set of memory sectors.<br>
5<br>
3.	A method according to claim 1 or 2, wherein the optimisation step<br>
comprises determining a layout of said object modules in memory.<br>
4.	A method according to claim 3, wherein determining the layout of said<br>
10                 object modules in memory comprises<br>
-	detecting an updated first object module having a different size than a<br>
corresponding first current object module, and an updated second<br>
object module equal to a corresponding second current object module,<br>
which updated second object module has a base address larger than<br>
15		the base address of the updated first object module; and<br>
-	padding the detected updated first object module with a predetermined<br>
memory content of a predetermined padding size resulting in a<br>
padded updated first object module; wherein the padding size is<br>
selected to cause the base address of the updated second object<br>
20		module to be equal to the base address of the corresponding second<br>
current object module.<br>
5.	A method according to claim 3 or 4, wherein determining the layout of said<br>
object modules in memory comprises<br>
25		-   detecting an updated first object module that is larger than a<br>
corresponding first current object module;<br>
-	moving a predetermined part of the updated first object module to a<br>
different memory sector resulting in a reduced updated first object<br>
module and a moved part of the updated first object module;<br>
30		-   inserting a reference to the moved part of the updated first object<br>
module in the reduced first updated memory sector.<br>
24<br><br>
3<br>
6.	A method according to any one of claims 1 through 5, wherein the<br>
transforming further comprises controlling the optimisation step by at least<br>
one optimisation parameter (304).<br>
5<br>
7.	A method according to claim 6, wherein the at least one optimisation<br>
parameter includes a parameter determining a maximum allowed increase in<br>
size caused by the optimisation step.<br>
10                  8. A method according to claim 6 or 7, wherein the at least one optimisation parameter includes a parameter determining a maximum allowed number of references introduced by the optimisation step.<br>
9.	A method according to any one of claims 1 through 8, further comprising<br>
15                 generating a delta file representative of differences between the current<br>
program code version and the updated program code version.<br>
10.	A method according to any one of claims 1 through 9, wherein the<br>
memory is a flash memory.<br>
20<br>
11.	A method according to any one of claims 1 through 12, wherein the<br>
memory is a memory of a portable radio communications equipment (101).<br>
12.	A data processing system (102) for updating program code stored in a<br>
25                 memory (212), the memory comprising a plurality of memory sectors, the<br>
data processing system being suitably programmed to perform the steps of the method according to any one of claims 1 through 11.<br>
13.	A computer program product comprising program code means adapted to<br>
30                  cause a data processing system (102) to perform the method according to<br>
25<br><br>
any one of claims 1 through 11, when said program code means are executed on the data processing system.<br>
14.	A computer program product according to claim 13, wherein the computer program product comprises a linker module.<br>
15.	A system for updating program code stored in a memory (212), the said system comprising:<br>
a memory comprises a plurality of sectors (P1, P2, P3, P4, P5, P6, P7, P8) having a current program code version occupying a first set of the memory sectors pf the memory<br>
means for transforming (606, 302) at least one updated source code module (607) into an updated program code version (305) to be stored in a memory (212), the said updated program code version occupies a second set of memory sectors when stored in the said memory;<br>
characterized in that the said memory is operatively coupled to the means for transforming for performing at least one optimization step of generating feedback data during a linking step for linking the number of object modules; re-compiling at least a subset of the source code modules based on the feedback data and resulting in a number of modified object modules; and performing a linking step based on the number of modified object modules.<br>
16.	The system as claimed in claim 1, wherein the means for transforming comprises of a compiler (606) for compiling the at least one source code module resulting in a number of object modules.<br>
17.	The system as claimed in claim 1, wherein the means for transforming receives a representation of the current program code version.<br>
26<br><br>
18.	The system as claimed in claim 1, wherein the means for transforming<br>
 comprises of a linker (302) for performing at least one optimisation step adapted<br>
to decrease the number of memory sectors of the second set of memory sectors occupied by the updated code version that are different from the corresponding memory sectors of the first set of memory sectors occupied by the current program code version.<br>
19.	A system for updating program code, a data processing system, a<br>
computer program product and a method for updating program code stored in a<br>
memory substantially as herein described with reference to accompanying<br>
drawings.<br><br><br>
Dated this   21st day of September 2006<br><br>
ANUPAM TRIVEDI<br>
OF K &amp; S PARTNERS<br>
AGENT FOR THE APPLICANT(S)<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
27<br><br>
FLASH MEMORY PROGRAMMING<br>
Abstract<br>
Disclosed is a method for updating program code stored in a memory, which memory comprises a plurality of memory sectors. The method comprises transforming an updated input code into an updated program code version to be stored in a memory, which memory has stored thereon a current program code version occupying a first set of the memory sectors of the memory, wherein the updated program code version occupies a second set of memory sectors when stored in the memory. The transforming step further comprises receiving a representation of the current program code version; and performing at least one optimisation step adapted to decrease the number of memory sectors of the second set of memory sectors occupied by the updated code version that are different from the corresponding memory sectors of the first set of memory sectors occupied by the current program code version.<br>
28<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LUFCU1RSQUNUKDItNS0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-ABSTRACT(2-5-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWFic3RyYWN0LmRvYw==" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-abstract.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LUFOTkVYVVJFIFRPIEZPUk0gMygyLTUtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-ANNEXURE TO FORM 3(2-5-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LUNMQUlNUyhBTUVOREVEKS0oMi01LTIwMTIpLnBkZg==" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-CLAIMS(AMENDED)-(2-5-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LUNMQUlNUyhNQVJLRUQgQ09QWSktKDItNS0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-CLAIMS(MARKED COPY)-(2-5-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWNsYWltcy5kb2M=" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-claims.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWNvcnJlc3BvbmRlbmNlKDEyLTItMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-correspondence(12-2-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LURSQVdJTkcoMi01LTIwMTIpLnBkZg==" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-DRAWING(2-5-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LUVQIERPQ1VNRU5UKDItNS0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-EP DOCUMENT(2-5-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LUZPUk0gMSgyLTUtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-FORM 1(2-5-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWZvcm0gMSg1LTQtMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-form 1(5-4-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LUZPUk0gMTMoMi01LTIwMTIpLnBkZg==" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-FORM 13(2-5-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWZvcm0gMTMoMjUtOS0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-form 13(25-9-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWZvcm0gMTgoMTMtMi0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-form 18(13-2-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWZvcm0gMih0aXRsZSBwYWdlKS0oMjUtOS0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-form 2(title page)-(25-9-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LUZPUk0gMjYoMi01LTIwMTIpLnBkZg==" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-FORM 26(2-5-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWZvcm0gMyg1LTQtMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-form 3(5-4-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LUZPUk0gNSgyLTUtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-FORM 5(2-5-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWZvcm0tMTMucGRm" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWZvcm0tMi5kb2M=" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-form-2.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWZvcm0tMjYucGRm" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LWZvcm0tcGN0LXJvLTEwMS5wZGY=" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-form-pct-ro-101.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LUpBUEFORVNFIERPQ1VNRU5UKDEyLTktMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-JAPANESE DOCUMENT(12-9-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LXBjdC1zZWFyY2ggcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-pct-search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LVBFVElUSU9OIFVOREVSIFJVTEUgMTM3KDItNS0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-PETITION UNDER RULE 137(2-5-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LVBFVElUSU9OIFVOREVSIFJVTEUgMTM3LSgyLTUtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-PETITION UNDER RULE 137-(2-5-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LVJFUExZIFRPIEVYQU1JTkFUSU9OIFJFUE9SVCgxMi05LTIwMTEpLnBkZg==" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-REPLY TO EXAMINATION REPORT(12-9-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1NVU1OUC0yMDA2LVJFUExZIFRPIEVYQU1JTkFUSU9OIFJFUE9SVCgyLTUtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">1133-MUMNP-2006-REPLY TO EXAMINATION REPORT(2-5-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzMy1tdW1ucC0yMDA2LXdvIGludGVybmF0aW9uYWwgcHVibGljYXRpb24gcmVwb3J0KDI1LTktMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">1133-mumnp-2006-wo international publication report(25-9-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTEzOS1tdW1ucC0yMDA2LWNvcnJlc3BvbmRhbmNlLXJlY2VpdmVkLnBkZg==" target="_blank" style="word-wrap:break-word;">1139-mumnp-2006-correspondance-received.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="252542-a-process-for-preparing-an-ecteinaschidin-compound.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="252544-process-for-producing-high-purity-terephthalic-acid.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>252543</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1133/MUMNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>21/2012</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>25-May-2012</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>22-May-2012</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>25-Sep-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>TELEFONAKTIEBOLAGET L M ERICSSON (PUBL)</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>SE-164 83 STOCKHOLM</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>EKER JOHAN</td>
											<td>KATTESUND 6E, SE-222 23 LUND</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 9/445</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/EP2005/000190</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-01-07</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/573,275</td>
									<td>2004-05-20</td>
								    <td>EUROPEAN UNION</td>
								</tr>
								<tr>
									<td>2</td>
									<td>04 388 033.5</td>
									<td>2004-05-11</td>
								    <td>EUROPEAN UNION</td>
								</tr>
								<tr>
									<td>3</td>
									<td>60/548,841</td>
									<td>2004-02-27</td>
								    <td>EUROPEAN UNION</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/252543-flash-memory-programming by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:18:44 GMT -->
</html>
