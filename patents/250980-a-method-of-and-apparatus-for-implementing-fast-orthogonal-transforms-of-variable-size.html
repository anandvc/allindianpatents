<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/250980-a-method-of-and-apparatus-for-implementing-fast-orthogonal-transforms-of-variable-size by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:08:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 250980:A METHOD OF AND APPARATUS FOR IMPLEMENTING FAST ORTHOGONAL TRANSFORMS OF VARIABLE SIZE</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD OF AND APPARATUS FOR IMPLEMENTING FAST ORTHOGONAL TRANSFORMS OF VARIABLE SIZE</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A reconfigurable architecture for and method of performing a fast orthogonal transform of vectors in multiple stages, the size of a vector being N, wherein N can vary and the number of stages is a function of N, the architecture including: a computational unit (182) configured and arranged so as to include one or more butterfly units; a block including one or more multipliers (184) coupled to the output of the computational unit, configured and arranged so as to perform all of the butterfly computations for at least one stage of the transform; a storage unit (180) configured and arranged so as to store the intermediate results of the butterfly computations and predetermined coefficients for use by the computational unit for performing each butterfly computation, the storage unit including memory and multiplexing architecture (180).</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
A METHOD OF AND APPARATUS FOR IMPLEMENTING FAST ORTHOGONAL TRANSFORMS OF VARIABLE SIZE<br>
Related Applications<br>
[0001]      The present application claims priority from US Provisional Applications, Serial Nos.:<br>
[0002]      60/586,390, filed July 8, 2004 and entitled Low-Power Reconfigurable Architecture for Simultaneous Implementation of Distinct Communication Standards (Attorney's. Docket 66940-016);<br>
[0003]      60/586,391, filed July 8, 2004 and entitled Method and Architecture for Implementation of Reconfigurable Matrix-Vector Computations (Attorney's Docket 66940-017);<br>
[0004]      60/586,389, filed July 8, 2004 and entitled Method and Architecture for Implementation of Reconfigurable Orthogonal Transformations (Attorney's Docket No. 66940-018); and<br>
[0005] 60/586,353, filed July 8, 2004 and entitled Method and Architecture for Implementation of Reconfigurable Trellis-Type Coding (Attorney's Docket 66940-019);<br>
[0006]      60/604,258, filed August 25, 2004 and entitled A Method And Device For On-line Reconfigurable Vitter Decoding Of Recursive And Non-recursive Systematic Convolution Codes With Varying Parameters (Attorney's Docket 66940-020); and<br>
[0007]      the following non-provisional U.S. Application Serial No.<br>
[0008] 11/071,340, filed March 3, 2005 and entitled Low-Power Reconfigurable Architecture For Simultaneous Implementation Of Distinct Communication Standards (Attorney's Docket 66940-021).<br><br>
Field of the Disclosure<br>
[0009] The disclosure relates to a system for and method of providing on-line reconfigurability of hardware so as to allow implementation of orthogonal transforms of vectors of varying size, such as FFT/IFFT (Inverse FFT) transforms, Walsh-Hadamard transforms, etc. including combinations of more than one type of such transform. The system and method are particularly useful in communication devices using such transforms.<br>
Background of the Disclosure<br>
[0010]      Common orthogonal transforms provide a powerful tool in encoding information transmitted in wireless communication systems, and various ones of such transforms are used depending on the protocol used to transmit information. The FFT (Fast Fourier Transform)/IFFT (Inverse FFT), for example, is a critical computational block e.g. in OFDM systems and filter banks. See, for example, N. West, and D. J. Skellern, "VLSI for OFDM," IEEE Communications Magazine, pp. 127-31, vol.36, (no.10), Oct. 1998, and R.van Nee and R. Prasad, OFDM for Wireless Multimedia Communications, Artech House Publishers,2000.<br>
[0011] An attractive feature of FFT/IFFT is that IFFT can be performed using a FFT block, by conjugating the input and output of the FFT and dividing the output by the size of the processed vectors. Hence the same hardware can be used for both FFT and IFFT. Several standard implementations of performing FFT/IFFT are known, some of which provide reconfigurability. One standard FFT/EFFT implementation is using FFT kernel arithmetic.<br>
(0012]      FFT kernel arithmetic:<br>
[0013]      The digital computation of the Appoint DFT (discrete Fourier transform) (see, for example, A. V. Oppenheim and R, W. Schafer, Discrete-Time Signal Processing, Prentice Hill, New Jersey, 1989) is:<br><br><br>
where the complex exponential coefficients are: <br>
[0014] Direct computation of DFT (for all k) requires NxN multiplications and Nx(N-I) additions. FFT algorithms are more efficient implementations that reduce the number of multiplications to Nlog^N. The basic idea is to divide the FFT of length N into two FFT components of length N/2, each of which is then further divided into two FFT components of length N/2, etc. This process continues until the length of each FFT component is reduced to 2, which can be computed directly by a so-called "butterfly" unit. The trellis of such a butterfly unit is illustrated in Figure 1.<br>
[0015] Two other commonly used FFT algorithms are decimation-in-frequency (DEF) and decimation-in-time (DIT) algorithm, which are similar in nature. The DIF algorithm is used to illustrate the architectural implementations where the FFT intermediate results are divided into even and odd parts with:<br><br><br>
[0016]      Standard implementation:<br>
[0017] In the standard prior art approach, to provide function-specific re-configurability it is first necessary to analyze the computational structure. The FFT can be viewed as a shuffle-exchange interconnecting network of butterfly blocks, which varies with the size of the FFT, thus making it difficult to support flexibility of the most energy-efficient fully-Darallel implementation. In the fully parallel implementation the signal flow graph can be directly mapped onto hardware. For instance, for a 16-point FFT there are total of 32 butterfly units and they are interconnected in the manner as shown by the trellis in Figure 2.   In<br>
N general, the N-point FFT requires  â€”Log2N butterfly units. This maximally<br>
parallel architecture has the potential for high performance and low power consumption, however it bears a high cost of large silicon area especially for large FFT sizes.<br>
[0018] The outputs generated by DEF FFT are bit-reversed. For example, X[10]-X[10102]-Y[01012]=Y[5].<br>
[0019] When the implementation is done in fixed-point arithmetic the scaling and overflow handling are crucial for the correct behavior of the transformer. The butterfly operation at each stage of the FFT involves both complex addition and complex multiplication. Each complex addition is composed of two real additions, which expand the input word-length by 1 bit. Each complex multiplication is composed of four real multiplications and two real additions. A real multiplication doubles the input word-length. Thus to ensure the correct behavior, the output word-length is either increased to (M+l)b\tsy or the output needs to be truncated or rounded to M bits. If truncation is performed, the most significant bit of the output is simply discarded, by truncating the values to the maximum values that can be described by M bits. If rounding is performed, a "1" is added tothe positive outputs first before the output is shifted to the right by 1 bit, and the least significant bit is discarded. Rounding will not cause adder overflow since the biggest and smallest numbers (a+b) have their least significant<br><br>
bit, after the addition, to be zero (even numbers). After rounding, the output will be in the same range as that of a and b, e.g., M bits.<br>
[0020]      Column based approach:<br>
[0021] In a column-based FFT architecture, the computations are rearranged such that the interconnections are kept identical in every stage as shown by the trellis in Figure 3. Since the inputs to a butterfly are no longer needed once the outputs are computed, the outputs can be routed to the inputs of the same butterflies, with the same butterflies thus being reused for the next and successive stages in iterative way (in-place computation). As a result, only a single column of butterflies is needed, the column being reused (time-multiplexed) by the different stages of computation. The FFT coefficients, however, need to be changed from stage to stage. In general, an TV-point FFT needs N/2 butterfly units, e.g. 8 butterflies are needed for a 16-point FFT. Its power consumption is very close to the a fully parallel architecture, but it requires less area. Still to convert it to a reconfigurable design is a complicated task, since the simple iterative structure is optimized for a specific size. The transition from a parallel to a column based implementation requires more clocks for processing an FFT frame. Indeed the parallel approach allows processing of a full FFT frame in one clock cycle, while the column approach needs \0g2N (when using a radix-2 based butterfly architecture) clock cycles due to the iterative time-multiplexed structure.<br>
[0022]      Reconfigurable design:<br>
[0023] By choosing a regular pipelined architecture to run an FFT algorithm, it is possible to implement a reconfigurable design with very low energy overhead even compared with the one provided by the standard lower boundary of the complexity of a FFT transform.<br>
[0024]      Pipelined approach:<br>
[0025] In the regular pipelined architecture, only one butterfly unit is used for each stage, yielding the total complexity log2./V, compared to N/2x\ogiN in the<br><br>
fully-parallel approach and N/2 in the column-based approach. An example of the pipeline approach is illustrated in Figure 4 for the length of a 16-point FFT. The multiplier 40 of each stage 42a, 42b and 42c is distinguished from the butterfly unit 44a, 44b and 44c to distinguish between hardware requirements. Each of the butterfly units 44a, 44b, 44c and 44d is time-multiplexed among the N/2 butterfly computations for each stage. For the stage including the butterfly unit 44c, the multiplier 40c is "j". No multiplier is necessary for the out of the final butterfly unit 44d. The pipelined-based implementation needs more clock cycles per FFT frame than the column-based approach since the pipelined-based approach can implement a full FFT frame in N (when using radix-2 based butterfly architecture) clock cycles, while the column approach needs log2N (when using radix-2 based butterfly architecture) clock, cycles due to the iterative time-multiplexed structure. In hardware implementation of all stages the clock number for processing an FFT frame is not an obstacle since the data is inserted in a serial manner, frame by frame, and the number of clock cycles per frame is transformed into a constant initial delay, while the throughput remains high.<br>
[0026]      The single-path delay feedback (SDF) implementation, see, for example, E. H. Wold and A. M. Despain, "Pipelined and parallel-pipeline FFT processors for VLSI implementation," IEEE Trans. Comput., p. 414-426, May 1984, uses memory more efficiently by storing the butterfly outputs in feedback shift registers or FIFO's 46 (their sizes are given in Figure 4, in the example the lengths of the registers are 8,4, 2, and 1, correspondingly). A single data stream passes the multiplier at every stage.<br>
[0027]      Hybrid approach<br>
[0028]      The hybrid approach combines benefits of the column and feedback approaches. It uses elements of the feedback approach to save memory, and the column stages are used for better hardware utilization. Use of the column stage butterfly units of 4 bits' width can be combined with employing a greater BUS width and proper reconfigurable multipliers. The architecture can also be<br><br>
converted to one with an exact BUS width necessary for high space utilization and algorithmic efficiency.<br>
[0029]      A popular architecture for running an iterative process is shown in Figure 5. This FFT implementation utilizes a single butterfly unit 50. The single butterfly unit design is mainly focused on optimizing a scheduling and memory access scheme, i.e., providing a pipeline approach when implementing each of the stages by reusing the same butterfly unit, time-multiplexed in an iterative way. The Spiffee processor, see for example, B. M. Baas, "A Low-power, high-performance, 1024-point FFT processor," IEEE Journal of Solid-State Circuits, March 1999, is an example of using cached memory architecture, including RAM 52 and multiplier 56, to exploit the regular memory access pattern of a FFT algorithm in order to achieve low power consumption. The processor, shown as controller 54, can be programmed to perform any length of FFT, but certain features, such as cache sizes provided by RAM 52, are optimized only for a certain FFT size, and this approach operates at very low speeds because the N clock cycles needed for the computation of a FFT frame through the full implementation of the pipeline algorithm, yielding a constant initial delay. This means that due to the iterative time-multiplexing of the stages by the reused butterfly unit 50, the full frame needs to be computed (needs A'clock cycles when using a radix-2 based butterfly unit) before it can begin to handle the next FFT frame.<br>
[0030]      One can make a more efficient FFT processor by using a larger radix-based butterfly unit, e.g. the Radix-4 based architecture. This reduces the computation clock cycle that is needed for processing a full FFT frame to N/2. Most of the FFT accelerators that are implemented in advanced DSPs and chips are based on the Radix-2 or Radix-4 FFT processors. They have a limited usage (only for FFTs transforms), very low speed utilization and suffer from the need of high clock rate design.<br><br>
[0031]      Filter implementation based on Multiplex Pipelined approach:<br>
[0032] Using reconfigurable iterative schemes, such as the one shown in Figure 6, one can implement any kind of filter or con-elation function with high efficiency. It is achieved by using the multiplier of the last stage of a FFT transform for multiplication by a filter coefficient (time domain multiplication) followed by an IFFT as best seen in Figure 6 at 60. It is also efficient in implementing any sub-product of a FFT / IFFT, e.g..Discrete Cosine / Sine Transforms (DCT and DST), and any algorithms which are a combination of the above-mentioned algorithms, like filtering using cascaded FFT and IFFT algorithms (which can be used also for equalization, prediction, interpolation and computing correlations).<br>
(0033]      FFT with different radixes:<br>
[0034]      The radix-22 algorithm is of particular interest. It has the same multiplicative complexity as radix-4 and split-radix algorithms respectively, while retaining a regular radix-2 butterfly structure. This spatial regularity provides a great structural advantage over other algorithms for VLSI implementation. The basic idea behind the radix-22 algorithm is in taking two stages of the regular DIF FFT algorithm and maximizing the number of trivial<br>
multiplications by which involves only real-imaginary swapping and<br>
sign inversion. In other words, the FFT coefficients are rearranged and non-trivial multiplications are lumped into one stage so that only one complex multiplier is needed in every two stages (reduces the overall logic area). Figure 7 illustrates a trellis representing such a coefficient rearrangement (in parallel<br>
form): for any two butterfly coefficients and is  factored out<br>
and forwarded to the next stage, which leaves the coefficients 1 and -j in the corresponding positions. After performing this coefficient rearrangement over all the coefficient pairs, one stage is left without non-trivial multiplication.<br><br>
[0035]      Hybrid pipeline / Multiplex approach:<br>
[0036] A number of pipelined FFT architectures have been proposed over the last decade. Since the spatial regularity of the signal flow graph is preserved in pipelined architectures, they are highly modular and scalable. The shuffle network 80 is implemented through a single-path delay feedback depicted in Figure 8A, where the data is processed between stages 82 in a single path and feedback. FIFO registers 84 are used to store new inputs and intermediate results. The basic idea behind this scheme is to store the data and scramble it so that the next stage can receive data in the correct order. When the FIFO registers 84 are filled with the first half of the inputs, the last half of the previous results are shifted out to the next stage. During this time, the operational elements are bypassed. When the first half of the inputs are shifted out of the FIFO registers, they are fed into the processing elements along with the arriving second half of inputs. During this time, the operational elements are working and generating two outputs, one directly fed to the next stage 82 and the other shifted into the corresponding FIFO registers. Multipliers (not shown) are inserted between stages when necessary according to either the radix-22 or the radix-2 algorithm. A trellis and data packets for use in such an implementation is illustrated in Figures 8B and 8C, respectively.<br>
[0037]      Brief Description of the Drawings<br>
[0038] Reference is made to the attached drawings, wherein elements having the same reference character designations represent like elements throughout, and wherein:<br>
[0039]	Figure 1 is an illustration of a FFT butterfly computation trellis;<br>
[0040]	Figure 2 is an illustration of a decimation-in-frequency 16-point FFT<br>
trellis;<br>
[0041]	Figure 3 is an illustration of a Column-based 16-point FFT trellis;<br><br>
[0042]      Figure 4 is an illustration of a block diagram of an architecture for implementing a pipeline-based Radix-2 (N = 16) 16-point FFT;<br>
[0043]      Figure 5 is an illustration of a block diagram of an architecture for implementing a simple Radix-2 FFT processor;<br>
[0044]      Figure 6 is an illustration of a block diagram of an architecture of a pipeline-based Radix-2 (N=16) 16-point filter;<br>
[0045]      Figure 7 is an illustration of a trellis of a multiplication elimination technique through coefficient rearrangement;<br>
[0046]     Figure 8 is an illustration of a trellis, block diagram and packet diagram of a pipelined implementation of a shuffle-exchange interconnect transformer;<br>
[0047]      Figure 9 is an illustration of a matrix operation for use in a radix-4 butterfly architecture in accordance with one aspect of the method and system of the present disclosure;<br>
[0048]     Figure 10 is an illustration of a radix-22 stage trellis in accordance with one aspect of the method and system of the present disclosure;<br>
[0049]      Figure 11 is an illustration of a block diagram of an architecture of a reconfigurable Radix-22 stage butterfly arrangement in accordance with one aspect of the method and system of the present disclosure;<br>
[0050]      Figure 12 is an illustration of a pipeline-based Radix-2 (N=16) 16-point filter in accordance with one aspect of the method and system of the present disclosure;<br>
[0051]      Figure 13 is an illustration of a semi pipeline/iterative Radix-22 (N=16) based implementation of 16-point FFT in accordance with one aspect of the method and system of the present disclosure;<br><br>
[0052]      Figure 14 is an illustration of a pipelined Radix-22 (N=16) based implementation of a 16 point filter in accordance with one aspect of the method and system of the present disclosure;<br>
[0053]      Figure 15 is an illustration of a trellis of a parallel Radix-22 (N=16) based implementation of a 16 point Walsh spreading/dispreading function in accordance with one aspect of the method and system of the present disclosure;<br>
[0054] Figure 16 is an illustration of a trellis of a parallel Radix-2 (N=16) based implementation of a 16 point Walsh spreading/dispreading function in accordance with one aspect of the method and system of the present disclosure;<br>
[0055]      Figure 17 is an illustration of a block diagram of an architecture of providing a reconfigurable MF-I core processor in accordance with one aspect of the method and system of the present disclosure; and<br>
 [0056]     Figure 18 is an illustration of a block diagram of an architecture of providing a reconfigurable MF-I core processor in accordance with one aspect of the method and system of the present disclosure;<br>
[0057]      Figure 19 is a block diagram of a communication system configured to comprise a transformer of any of the type described herein.<br>
Detailed Description of the Drawings<br>
[0058] The following disclosure describes a method of and system for implementing orthogonal transforms, such as Fast Fourier Transforms (FFTs) of vectors having varying size (real and complex vectors). Adaptive algorithms are implemented where the size of the transform can be determined on line and is dependent on the input to the algorithm. Examples of such adaptive algorithms are (1) FFTs, (2) inverse FFT (IFFTs), (3) any sub-products of FFTs and IFFTs, e.g. Discrete Cosine/Sine Transforms (DCT and DST), (4) Walsh-Hadamard transforms and any its' sub-products, e.g. CDMA, DSSS, Spreading/De-spreading core algorithms, and any combination of the algorithms mentioned above. The method and system can also be used for filtering and other functions, such as<br><br>
achieved when cascading FFT and EFFT algorithms (which in turn can be used also for equalization, Hilbert transforms, predictions and interpolations and correlations). The method and system allows implementation of FFT/IFFT and all the above-mentioned algorithms with high efficiency and in a wide range of parameters by fast on-line reconfiguration of hardware. It provides a significant decrease in the amount of hardware in devices which are intended for parallel or serial implementation of several FFT transforms or algorithms mentioned above of different sizes.<br>
[0059] The disclosed approach is to modify an orthogonal transform processor so as to provide a simplified interconnection structure that makes it easy to achieve flexibility by adapting to the length of the FFT vectors and sizing the memory accordingly, e.g., changing the length of the shift registers (or FIFO's), modifying the interconnecting buses as needed, and providing simple multiplexing of I/O blocks. With a clock frequency at the input sample rate the entire range of FFT's can be accommodated by either direct mapping to hardware and disabling unnecessary blocks for the shorter length FFT's or by folding the processing stages and time-sharing the hardware for the longer (but lower symbol rate) cases. This architecture does not need buffering or serial-to-parallel conversion.<br>
[0060]      The architecture can be implemented using according to Radix2, Radix22, Radix23, Radix4, Radix 8, or similar format.   The radix-4 (without the Twiddle coefficients' multipliers) can be represented also as a matrix operation as shown in Figure 9, and implemented as shown by the trellis in Figure 10 .<br>
[0061] An embodiment of a reconfigurable radix 2i stage implementation, illustrated in Figure 11, comprises in input multiplexer 111, two stages of butterfly units 110a and 110b, two feedback memories 112a and 112b with only one general multiplier 114 and one cross junction (with sign inversion capability) block 116, and a controller 118. The block 116 is used to switch between IFFT and FFT processing, thus eliminating the need for a multiplier at the output of the butterfly unit 110a .   In implementation, the size of the usable memory of<br><br>
memories 112a and 112b can be modified by the controller 118 to accommodate the length of the FFT being processed. The length of the transform vectors can be detected by detector 117 and determined by controller 118. In addition memory 119 is provided for storing coefficients for use by the multiplier 114 for each stage of calculation..<br>
[0062] Figure 12 illustrates an embodiment of a pipelined Radix--22 (N = 16) based implementation of a 16 point FFT. In this embodiment, the controller 128 provides an input to set the size of each of the memories, in this case shift registers 124 for each stage. The multiplexer 121 is also set to provide the desired sequential inputs to the input the butterfly unit 122a of the first stage. The multipliers 126a, 126b and 126c are separately positioned at the output of each of the first three stages, with the final stage not requiring one. As seen the multipliers 126a and 126c convert the output of the stages to which the are coupled to an imaginary complex "j", by multiplying by "j".<br>
[0063]      An alternative embodiment is shown in Figure 13 which incorporates an architecture for carrying out an iterative process. Specifically, Figure 13 shows an example of a semi-pipeline/iterative Radix-22 (N = 16) based implementation of processing a 16 point FFT. In this embodiment, only two butterfly stages 130a and 130b are required with the output of the multiplier 130b providing feedback, as well as the output of the transformation processor. Specifically, the output of the multiplexer 131 is provided to the input of the butterfly unit 132a. The latter provides feedback to the memory (e.g. shift register 134a, and an output to the "j" multiplier 136a. The output of the "j" multiplier 136a is applied to the input of the butterfly unit 132b. The latter provides feedback to the memory (e.g., shift register 134b), and an output to the multiplier 136b. The output 136b is connected through a feedback path to the input of the butterfly unit 132a. In operation, controller 138 controls the size of the memories 134 depending to the stage of the processing. In the first instance when the signal vectors are first received, the registers 134a and 134b are set at "8" and "4" respectively, and the signals processed through the two stages. The output of the processor is disabled and the output of the second stage butterfly<br><br>
unit 132b is applied through the feedback path to the input of the butterfly unit 132a. During the next iteration, the memories are set by the controller to "2" and "1". The signals are then serially processed through to the output of the second butterfly unit 132b. The output of the processor is then enabled, and the feedback path disabled so that the output of the processor is provided at 139.<br>
[0064]      Figure 14 illlustrates an embodiment of an example of a Pipeline Radix-22 (N = 16) based implementation of a 16 point filter. Again the sizes of memories are set for each stage by the controller 148.   The filter coefficients are applied to the multiplier 140. The architecture can be iterative or a mixture of pipeline / iterative or parallel.<br>
[0065] Again the architecture of Figure 14 can be modified to be interative or a mixture of pipeline/iterative or parallel architecture.<br>
[0066]      Walsh - Hadamard transformations enabling:<br>
[0067] From the previous discussion regarding a radix-4 transform as a matrix operation, it is easy to see that the architecture can be easily changed to process other orthogonal signaling, such as Walsh Spreading/Despreading functions The latter can be easily implemented with the existing architecture by simply substituting multiplier coefficients by trivial ones of Â±1, Further examination shows that only the non-trivial coefficients and the coefficients which are multiplied with -j, need to be changed. Moreover, the non-trivial multiplier coefficients have already all that is necessary for implementation of the trivial multipliers needed for the Walsh Spreading/De-spreading function, the ability to change between FFTâ†” IFFT and multiplication by -j. The only extra requirement for the hardware is in managing the controller 148..<br>
[0068] As an example, the "Radix 4" Walsh Spreading/De-spreading butterfly unit can be represented as a matrix operation as follows:<br><br><br>
One can see the relation between the two transforms by comparing the two matrix presentations:<br><br>
[0069] Since the radix-4 transform is a complex operation, one obtains two independent Walsh spreading/de-spreading processes for the real vectors since the trivial multipliers by Â±1 do not interchange between the I and the Q signals. Therefore, this feature can be used for implementing, for example, a two fingers' RAKE receiver or a complex Walsh spreading/de-spreading function as in the new WCDMA standards. One can also use the second independent Walsh Spreading/De-spreading function as an extra stage, or alternatively, use them for greater Walsh Spreading / De-spreading by conjured I and Q at the proper place (this possibility is already implemented in the reconfigurable Radix 22 architecture shown in Figures 9-14).<br>
[0070] The implementation presented in Figure 14, for example, requires a FFT algorithm which is earned out with only Nlog(N) operations, and, thus is very efficient for such operations as CDMA modulation/demodulation of several codes together, i.e., for a heavy data load.<br>
[0071] The complex multipliers now can be used in implementation of filters in the frequency domain for randomizing/de-randomizing the Walsh sequence with quasi-random sequences with very high efficiency (when dealing with CDMA modulation /demodulation of several codes together, i.e. for a heavy data load (as can be seen in CDMA / WCDMA standards). The efficiency is achieved<br><br>
due to the fact that one needs to multiply the modulated data only once (for all the codes) and not every code is multiplied separately A<br>
[0072]      Figure 15 illustrates a trellis of an example of an embodiment of the transformation of a radix-4 stage to Walsh spreading/de-spreading function when Twiddle multipliers for randomizing Walsh codes are used in the beginning and the end of a parallel architecture. Figure 15 specifically shows an example of a parallel Radix-22 (N=16) based implementation of a 16 point Walsh spreading/dispreading function.<br>
[0073]      Implementing a radix-2 base FFT using Twiddles multipliers, the multipliers can be changed to 'T's only. Figure 16 shows an example of a trellis of parallel Radix-2 (N = 16) based implementation of 16 points, Walsh spreading/de-spreading sequence, i.e., an example of a sequence of 16 chips of a Walsh Spreading / De-spreading sequence during modulation/demodulation.<br>
[0074]      Again, complex multipliers can be used as explained above, e.g. for implementation of filters in the frequency domain, or for randomization/de-randomization of the Walsh sequences with quasi-random sequences. Efficiency is achieved due to the fact that one needs to multiply the modulated data only once (for all the codes), and thus each code need not be multiplied separately.<br>
[0075]      Reconfigurable Hybrid pipeline column Multiplex approach:<br>
[0076]     As shown in Figure 17, A "bank" of small radix22 butterfly units of 4 bits' width can be combined to form wider BUS radix21, with each of the small Radixes connected to a reconfigurable controlled "Bank" of RAMs that can be combined /split. Reconfigurable multipliers for BUS splitting can also be implemented based on the above methodology using a reconfigurable "processing" core with very high utilization and low power consumption of any length of IFFT/FFT/ filter / correlator and Walsh -Hadamard transformations or any sub product of it e.g., a CDMA DSSS core or even a DDS frequency filter, with any BUS width necessary when several algorithms can run in any configuration, including a variety of parallel/pipeline/iterative algorithmic<br><br>
architecture schemes. Since the implementation of the core in silicon has a maximum clock rate, reconfiguration according to the needs can result in any number of parallel/pipeline/iterative algorithmic architecture schemes, each optimized for the algorithms and the silicon implementation resources at any time, and for any standard of modem implementation, thus resulting in a very compact reconfiguration architecture with high utilization performance. Figure 17 shows an example of a reconfigurable MF-I core for processing FFT/IFFT vectors.<br>
[0077]      Summarizing the disclosure, the current approach includes modification of the basic FFT processor by using a simplified interconnection structure. This allows flexibility in adjusting for the size of the FFT simply by changing the length of the shift registers (or FIFO's) of the memory, changing the bus sizes as needed, and simple multiplexing of the I/O blocks. With a clock frequency at the input sample rate, the entire range of the FFT's can be accommodated by either direct mapping to hardware and disabling unnecessary blocks for the shorter length FFT's, or by folding the processing stages and timesharing the hardware for the longer (but slower symbol rate) cases. This architecture does not require buffering or serial-to- parallel conversion.<br>
[0078]      Using a Radix22 architecture as an example, the radix-4 (without the twiddle coefficients' multipliers) can be represented also as a matrix operation as seen in Figure 9.   The corresponding butterfly structure is presented in Figure 10. Thus, as shown in the above example, a radix 22 stage implementation will need two stages of butterfly units with only one general multiplier and one cross junction (also needed for IFFT/FFT changing) with sign multiplication, and thus eliminating the need for a multiplier. The corresponding structure is presented in Figure 11. The corresponding multistage implementation (cf. with Figure 4) of Radix22 implementation of the a 16 point FFT is given in Figure 12. The same transform, but implemented using iterative reconfigurable switch mechanism is presented in Figure 13 (one stage) and Figure 14 (multistage).<br><br>
[0079] Walsh - Hadamard transformations enabling: The processor and method thus described in connection with FFT/IFFT can also be used to implement a processor and method for other transforms. From the above presentation of a radix-4 transform as a matrix operation, in order to change the operation to Walsh spreading/despreading function, all that is required is to substitute the multipliers used for the FFTs by trivial multipliers of Â±1. Further examination shows that only the non-trivial and the ones which are multiply with -j, need to be changed. Moreover, the non-trivial multipliers are all that is necessary for implementation of the trivial multipliers needed for Walsh spreading/despreading, with the ability to change between FFT/IFFT and multiply with -j. The only extra requirement for the hardware is in a controller for managing and controlling the operation of the processor.<br>
[0080] The "Radix 4" Walsh spreading/despreading butterfly can be also represented as a matrix operation as shown below:<br><br>
One can see the relation between the two transforms by comparing the two matrix presentations:<br><br>
Since the radix-4 transform is a complex operation, one gets two independent Walsh spreading/despreading processes for real vectors spreading/despreading (since the trivial multipliers by Â±1 do not interchange between the I and the Q signals). This aspect is useful in implementing a two fingers' RAKE receiver or a<br><br>
complex Walsh Spreading/De-spreading processor as is provided for in the new WCDMA standards. One can also use the second independent Walsh spreading/despreading processor as extra stages and use them for greater Walsh spreading/despreading by conjured I and Q at the proper place (this possibility can easily be implemented in the reconfigurable Radix 2i architecture).<br>
[0081] The implementation presented in Figure 17 requires only NLog(N) operations, and is very efficient for CDMA modulation/demodulation of several codes together, i.e., for a heavy data load.<br>
[0082] The complex multipliers now can be used for implementing such configurations as filters in the frequency domain for randomizing/de-randomizing the Walsh sequence with quasi-random sequences with very high efficiency (when dealing with CDMA modulation /demodulation of several codes together, i.e. for a heavy data load (as can be seen in CDMA / WCDMA standards). The efficiency is achieved due to the fact that one needs to multiply the modulated data only once (for all the codes), and not every code is multiplied separately.<br>
[0083] Figure 15 presents a transformation of radix-4 stage to a Walsh spreading/de-spreading function when Twiddle multipliers for randomizing the Walsh codes are needed (beginning/end) in a parallel architecture. For the example of a Radix-2 based FFT, the twiddle multipliers need to be changed to "l"s only. The example of 16 chips' Walsh spreading/despreading sequences for modulation/demodulation processing is shown in Figure 16. The complex multipliers can be used as explained above, e.g. for implementing filters in the frequency domain, or for randomization/de-randomization of the Walsh sequences with quasi-random sequences. The efficiency is achieved due to the fact that one needs to multiply the modulated data only once (for all the codes). Each code is not required to be multiplied separately.<br>
[0084]     Reconfigurable hybrid pipeline column multiplex approach:<br>
[0085]      Finally, the general architecture of the reconfigurable device for implementing the general orthogonal transforms is summarily shown in Figure 18<br><br>
for the case of Radix2,-/x butterfly transforms. The computation unit can be implemented by use of Radix2, Radix22, Radix23, Radix 4, Radix 8, etc, butterfly units. The device preferably comprises a reconfigurable RAM cluster and a reconfigurable BUS multiplexer block 180, computation unit 182 comprising one or more butterfly units, reconfigurable multipliers block 184, controlling and storage unit 186 and detector 188. At each stage of the transform the unit 186 modifies the coefficients of the multipliers in the butterfly units of 2 according to the transform (the corresponding coefficients may take on the values {-l,l,j,-j}). The result of the operation by unit 182 is stored in the registers of the unit 180 (which is also controlled by unit 186). The size of the registers is changed from stage to stage. A part of the stored data is inserted into the reconfigurable multipliers block 184, data is multiplied by coefficients established by the controlling and storage unit 186, according to the stage and the algorithm. The result of the multiplication is stored in block 180. A multiplexer of block 180 is used for multiplexing the stored data.   It will be evident that as few as one butterfly unit and one multiplexer can be used for each stage, and that the one butterfly unit and multiplier can be reused for each stage by simply reconfiguring the hardware.<br>
[0086]      A specific application of the foregoing is described in our co-pending application, 11/071,340, filed March 3, 2005 and entitled Low-Power Reconfigurable Architecture For Simultaneous Implementation Of Distinct Communication Standards (Attorney's Docket 66940-021), which is incorporated by reference. Figure 18 shows a block diagram of a system described and claimed in this co-pending application.<br>
[0087]      Accordingly, as illustrated in Figure 19, an embodiment of an integrated chip made to comply with the foregoing chip architecture requirements will comprise the following basic functional components:<br>
[0088]      CPU 190 is preferably a relatively small computer processing unit needed for (a) controlling the configure part of the device i.e., net busl92, I/O block 194, RAM block 196, mega function block(s) 198, interconnect block 200,<br><br>
flash memory block 202 and clock 204; and (b) fixing the configuration of the mega functions block(s) 198, as well as the bus 192, I/O block 194, RAM block 196, interconnect block 200, flash memory block 202 and clock 204, depending upon the protocol of the signals be processed by the chip. CPU 190 can also help by computing minor and simple assignments or tasks, and configuring the bus that is used to interconnect the mega functions and the I/O block.<br>
[0089]      The net bus 192 is reconfigurable depending on the protocol. I/O block 194 is preferably a configurable I/O block that connects the chip with the outside world. Its tasks include receiving the "compiled software" of the application algorithm, and receiving input data and delivering output-processed data. RAM 196 is a random access memory preferably configured to store the "compiled software instructions", and to cache and buffer data. Mega functions block 198 is preferably configured to include the major application functions of two or more applications, i.e., protocols, which are processed by computing each domain of the application functions as one function with extraordinary efficiency. In the present case, the mega function block 198 is configured to include one or more of the orthogonal transforms, or any combination thereof, described herein. Interconnect block 200 preferably includes the reconfigurable net bus, which connects all the components of the chip including the CPU 190, I/O block 194, RAM 196, Mega functions block 198, and Flash Memory 202 and Clock block 204. The interconnect block can also be configured to perform minor and simple assignments or tasks, preferably in extra memory. Finally, flash memory 200 preferably serves to store data as the chip runs through its programs. Flash memory is preferably in the form of EEPROM that allows multiple memory locations to be erased or written in one programming operation, so that it can operate at higher effective speeds when the systems using it read and write to different locations at the same time. It should be appreciated that for less complex operations, other types of memory could be used. Information is preferably stored in the flash memory by storing the information on a silicon chip in a way that does not need power to maintain the information in the chip. Consequently, power to the chip can be withdrawn and the information retained<br><br>
in flash memory without consuming any power. In addition, flash memory offers fast read access times and solid-state shock resistance, making flash memory particularly desirable in applications such as data storage on battery-powered devices like cellular phones and PDAs.<br>
[0090]     The architecture thus described, thus can be implemented as an integrated circuit. The architecture is believed adaptable for any type of orthogonal signaling, in which the vectors can vary in size (both real and complex vectors). Such orthogonal signaling can contain, but not restricted to FFT transforms, inverse FFT transforms (IFFT) or any its sub-product like Discrete Cosine/Sine Transforms (DCT and DST), Walsh-Hadamard transforms or any its sub-product like CDMA DSSS Spreading / De-spreading, and any algorithm which is a combination of two or more of these algorithms, and such other functionality, for example, filtering by using concatenation of FFT and IFFT transforms, which can be used also for equalization, Hilbert transforms, predictions, interpolations, correlations, etc.<br>
[0091]      The architecture of the present disclosure as disclosed herein, and all elements thereof, are contained within the scope of at least one of the following claims. No elements of the presently disclosed chip architecture are meant to be disclaimed, nor are they intended to necessarily restrict the interpretation of the claims.<br>
What is claimed is:<br>
1.	A reconfigurable architecture for performing a fast orthogonal transform<br>
of vectors in multiple stages, the size of a vector being N, wherein N can vary<br>
and the number of stages is a function of N, the architecture comprising:<br>
a computational unit configured and arranged so as to include one or more butterfly units;<br>
a block including one or more multipliers coupled to the output of the computational unit, configured and arranged so as to perform all of the butterfly computations for at least one stage of the transform;<br>
a storage unit configured and arranged so as to store the intermediate<br>
results of the butterfly computations and predetermined coefficients for use by<br>
the computational unit for performing each butterfly computation, the storage<br>
unit including memory and multiplexing architecture;	a multiplexer unit<br>
configured and arranged so as to time multiplex all of the butterfly computations of the transform using said computation unit for the one stage so that only one computation unit is required for the stage; and<br>
a controller configured and arranged so as to provide coefficients to the computational unit, and control the sizes of memory and multiplexing architecture in the storage unit;<br>
wherein the multipliers' coefficients, the coefficients of the computational unit, the sizes of memories, and multiplexing architecture, for each stage are modified as a function of the value of N.<br>
2.	A reconfigurable architecture according to claim 1, wherein the butterfly<br>
units are configured in one of the following architectures: Radix2, Radix22,<br>
Radix23, Radix 4, or Radix 8.<br>
3.	A reconfigurable architecture according to claim 1, wherein the memory<br>
registers are FIFO shift registers.<br><br>
4.	A reconfigurable architecture according to claim 1, wherein the length of<br>
the memory registers are a function of the stage of the transform.<br>
5.	A reconfigurable architecture according to claim 1, wherein the length of<br>
the memory registers decreases with each successive stage.<br>
6.	A reconfigurable architecture according to claim 5, wherein the length of<br>
the memory registers is adjusted for each stage as a function of the value of N.<br>
7.	A reconfigurable architecture according to claim 6, wherein the<br>
multiplexer unit includes an input/output block to the computational unit.<br>
8.	A reconfigurable architecture according to claim 1, wherein N varies<br>
within a predefined range, further including a clock unit configured and arranged<br>
so as to provide a clocking frequency at the input sample rate for the entire<br>
predefined range.<br>
9.	A reconfigurable architecture according to claim 8, wherein the<br>
architecture includes multiple computational units arranged as hardware so that<br>
the entire predefined range M is accommodated by mapping the transform of<br>
predefined range on the hardware, and disabling those computational units that<br>
are unnecessary when the transform is less than M.<br>
10.	A reconfigurable architecture according to claim 8, wherein the<br>
architecture includes multiple computational units arranged as hardware so that<br>
less "m" than the entire predefined range M is accommodated, and the stages are<br>
at least partially shared hardware for transforms greater that "m".<br>
11.	A reconfigurable architecture according to claim 1, wherein each stage<br>
requires N/2 computations.<br><br>
12.	A reconfigurable architecture according to claim 1, further including a<br>
plurality of computational units, one for each of said stages, and said<br>
computational units are implemented so as to provide a pipelined architecture.<br>
13.	A reconfigurable architecture according to claim 1, further including a<br>
plurality of computational units, one for each of said stages, and said<br>
computational units are implemented so as to provide an architecture configured<br>
in one or more of the following types: pipelined, iterative and parallel.<br>
14.	A reconfigurable architecture according to claim 1, wherein a full frame<br>
of said transform is implemented in N clock cycles.<br>
15.	A reconfigurable architecture according to claim 1, wherein the butterfly<br>
unit includes a Radix 2 architecture.<br>
16.	A reconfigurable architecture according to claim 1, wherein the butterfly<br>
unit includes a Radix 4 architecture.<br>
17.	A reconfigurable architecture according to claim 16, wherein a full frame<br>
of said transform is implemented in N/2 clock cycles.<br>
18.	A reconfigurable architecture according to claim 1, further including a<br>
transform accelerator, wherein the accelerator includes the computational unit,<br>
storage unit, and multiplexer unit, wherein the accelerator is configured and<br>
arranged to perform each butterfly computation for all of the stages in an iterative<br>
process.<br>
19.	A reconfigurable architecture according to claim 1, wherein the storage<br>
unit is configured and arranged to include filter coefficients, and the multiplier of<br>
the computational unit of the last stage of the transform is adapted to multiply the<br>
output of the last stage by one or more of the filter coefficients so as to produce a<br>
filtered output.<br><br>
20.	A reconfigurable architecture according to claim 19, wherein the filtered<br>
output is applied to the input of multiple stages of a transform that is the inverse<br>
of the orthogonal transform, wherein each of the stages includes a computation<br>
unit and said units form a pipelined architecture.<br>
21.	A reconfigurable architecture according to claim 1, wherein the transform<br>
is a fast Fourier transform.<br>
22.	A reconfigurable architecture according to claim 21, wherein the fast<br>
Fourier transform includes different radixes.<br>
23.	A reconfigurable architecture according to claim 1, wherein the vectors<br>
include both real and complex vectors.<br>
24.	A reconfigurable architecture according to claim 1, wherein the<br>
transformation includes a Walsh orthogonal transformation.<br>
25.	An integrated chip comprising a reconfigurable architecture for<br>
performing a fast orthogonal transform of vectors in multiple stages, the size of a<br>
vector being N, wherein N can vary and the number of stages is a function of N,<br>
the architecture comprising:<br>
a computational unit configured and arranged so as to include one or more butterfly units;<br>
a block including one or more multipliers coupled to the output of the computational unit, configured and arranged so as to perform all of the butterfly computations for at least one stage of the transform;<br>
a storage unit configured and arranged so as to store the intermediate results of the butterfly computations and predetermined coefficients for use by the computational unit for performing each butterfly computation, the storage<br>
unit including memory and multiplexing architecture; V<br>
the storage unit including memory and multiplexing architecture;<br><br>
a multiplexer unit configured and arranged so as to time multiplex all of the butterfly computations of the transform using said computation unit for the one stage so that only one computation unit is required for the stage; and<br>
a controller configured and arranged so as to provide coefficients to the computational unit, and control the sizes of memory and multiplexing architecture in the storage unit;<br>
wherein the multipliers' coefficients, the coefficients of the computational unit, the sizes of memories, and multiplexing architecture, for each stage are modified as a function of the value of N.<br>
26.	A communication system including the integrated chip of claim 25.<br>
27.	A communication system according to claim 26, further comprising a<br>
detector for determining the size of the vector.<br>
28.      A method of performing a fast orthogonal transform of vectors in multiple stages, the size of a vector being N, wherein N can vary and the number of stages is a function of N, the method comprising:<br>
configuring and arranging a computational unit so as to include one or more butterfly units; a block so as to include one or more multipliers coupled to the output of the computational unit, configuring and arranging the one or more butterfly units and one or more multipliers so as to perform all of the butterfly computations for at least one stage of the transform;<br>
storing the intermediate results of the butterfly computations and predetermined coefficients in a storage unit for use by the computational unit for performing each butterfly computation, the storage unit including memory and multiplexing architecture;<br>
time multiplexing all of the butterfly computations of the transform using the computation unit for the one stage so that only one computation unit is required for the stage; and<br>
providing coefficients to the computational unit, and controlling the sizes of memory and multiplexing architecture in the storage unit;<br><br>
wherein the multipliers' coefficients, the coefficients of the computational unit, the sizes of memories, and multiplexing architecture, for each stage are modified as a function of the value of N.<br>
29,	A method of performing a fast orthogonal transform of vectors in<br>
multiple stages, the size of a vector being N, wherein N can vary and the number<br>
of stages is a function of N, the method comprising:<br>
utilizing a reconfigurable group of butterfly units and a reconfigurable set of multipliers configured and arranged so that at least one computational unit can be configured and arranged to include at least one butterfly unit and a multiplier coupled to the output of the butterfly unit so that the computational unit can perform all of the butterfly computations for at least one stage of the transform, and reconfigurable memory coupled to the computational unit so as to store the intermediate results of the butterfly computations and predetermined coefficients for use in performing each butterfly computation;.<br>
wherein coefficients and sizes of memories, for each stage are modified as a function of the value of N.<br>
30.	A system of performing a fast orthogonal transform of vectors in<br>
multiple stages, the size of a vector being N, wherein N can vary and the number<br>
of stages is a function of N, the method comprising:<br>
a reconfigurable group of butterfly units and a reconfigurable set of multipliers configured and arranged so that at least one computational unit can be configured and arranged to include at least one butterfly unit and a multiplier coupled to the output of the butterfly unit so that the computational unit can perform all of the butterfly computations for at least one stage of the transform, and reconfigurable memory coupled to the computational unit so as to store the intermediate results of the butterfly computations and predetermined coefficients for use in performing each butterfly computation;.<br>
wherein coefficients and sizes of memories, for each stage are modified as<br>
a function of the value of N. <br>
Dated this 8 day of January 2007<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtQ0hFTlAtMjAwNyAgICBBTUVOREVEICBQQUdFUyBPRiBTUEVDSUZJQ0FUSU9OICAwMS0wMi0yMDEyLnBkZg==" target="_blank" style="word-wrap:break-word;">86-CHENP-2007    AMENDED  PAGES OF SPECIFICATION  01-02-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtQ0hFTlAtMjAwNyAgICBBTUVOREVEIENMQUlNUyAgMDEtMDItMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">86-CHENP-2007    AMENDED CLAIMS  01-02-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtQ0hFTlAtMjAwNyAgICBPVEhFUiBQQVRFTlQgRE9DVU1FTlQgIDAxLTAyLTIwMTIucGRm" target="_blank" style="word-wrap:break-word;">86-CHENP-2007    OTHER PATENT DOCUMENT  01-02-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtQ0hFTlAtMjAwNyAgIENPUlJFU1BPTkRFTkNFIE9USEVSUyAgMTctMDItMjAxMS5wZGY=" target="_blank" style="word-wrap:break-word;">86-CHENP-2007   CORRESPONDENCE OTHERS  17-02-2011.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtQ0hFTlAtMjAwNyAgIEZPUk0tMyAgMDEtMDItMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">86-CHENP-2007   FORM-3  01-02-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtQ0hFTlAtMjAwNyAgIFBPV0VSIE9GIEFUVE9STkVZICAwMS0wMi0yMDEyLnBkZg==" target="_blank" style="word-wrap:break-word;">86-CHENP-2007   POWER OF ATTORNEY  01-02-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtQ0hFTlAtMjAwNyAgRVhBTUlOQVRJT04gUkVQT1JUIFJFUExZIFJFQ0VJVkVEICAwMS0wMi0yMDEyLnBkZg==" target="_blank" style="word-wrap:break-word;">86-CHENP-2007  EXAMINATION REPORT REPLY RECEIVED  01-02-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtY2hlbnAtMjAwNy1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">86-chenp-2007-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtY2hlbnAtMjAwNy1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">86-chenp-2007-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtY2hlbnAtMjAwNy1jb3JyZXNwb25kbmVjZS1vdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">86-chenp-2007-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtY2hlbnAtMjAwNy1kZXNjcmlwdGlvbihjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">86-chenp-2007-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtY2hlbnAtMjAwNy1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">86-chenp-2007-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtY2hlbnAtMjAwNy1mb3JtIDEucGRm" target="_blank" style="word-wrap:break-word;">86-chenp-2007-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtY2hlbnAtMjAwNy1mb3JtIDMucGRm" target="_blank" style="word-wrap:break-word;">86-chenp-2007-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtY2hlbnAtMjAwNy1mb3JtIDUucGRm" target="_blank" style="word-wrap:break-word;">86-chenp-2007-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODYtY2hlbnAtMjAwNy1wY3QucGRm" target="_blank" style="word-wrap:break-word;">86-chenp-2007-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="250979-a-device-and-method-for-a-communication-service.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="250981-high-torque-dual-chamber-turbine-rotor-for-hand-held-or-spindle-mounted-pneumatic-tool.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>250980</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>86/CHENP/2007</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>07/2012</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>17-Feb-2012</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>14-Feb-2012</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>08-Jan-2007</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>ASOCS LTD.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>ROOM 220, KIRYAT HATISKSORET, NEVE-ILLAN, HARAY-YEHUDA,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>SOLOMON, DORON,</td>
											<td>4 HATAVS STREET, HOLON,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 17/14</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US05/24063</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-07-08</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/071,340</td>
									<td>2005-03-03</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/250980-a-method-of-and-apparatus-for-implementing-fast-orthogonal-transforms-of-variable-size by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:08:26 GMT -->
</html>
