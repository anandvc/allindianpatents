<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/260339-a-method-of-switching-applications-and-a-device-thereof by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:42:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 260339:A METHOD OF SWITCHING APPLICATIONS AND A DEVICE THEREOF</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD OF SWITCHING APPLICATIONS AND A DEVICE THEREOF</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A system for saving application state history information, containing an historical snap-shot of dynamic application state information associated with execution of a first application on a computing device. The application state history information is saved for use in a subsequent re-launch of the first application.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>METHOD, SOFTWARE AND APPARATUS FOR USING APPLICATION STATE HISTORY INFORMATION WHEN RE-LAUCHING APPLICATIONS<br>
BACKGROUND<br>
Field<br>
[0001]	The present invention relates  generally to the re-launching of software<br>
application, and more specifically, to the controlled re-launching of multiple software applications.<br>
Background<br>
[0002]	Advances in technology have resulted in smaller and more powerful personal<br>
computing devices. For example, there currently exist a variety of portable wireless telephones, personal digital assistants (PDAs), and paging devices that are small, lightweight, and can be easily carried hy users. Typically, these devices are severely resource constrained. For example, the screen size, amount of available memory and file system space, amount of input and output capabilities and processing capability may be each limited by the small size of the device.<br>
[0003J	Some devices or platforms allow only for a single instance of an application. In<br>
. such cases, only one version of the application may be executing at any one time. This limits the number of instances that can be running at any one time. Thus, in response to an attempt to re-execute a currently running application that is restricted to one instance, either the current version of the application must be terminated and an new one initiated, or the request for the re-execution must be denied where the current executing version is allowed to continue execution.<br>
[0004]	Some devices are multiple frame and allow for the windowing of different<br>
applications as displayed to a user. Such devices do not typically restrict applications to a single instance. As such, as long as the application itself does not restrict itself to one instance, the device allows the system to allow for the execution of multiple instances of such application. In such systems, the simultaneous active state of at least two instances of any one particular application, requires all the system resources needed to keep each such application in a currently executing state. Other systems are single frame systems where only one application is considered to the current application, or hi other words, only one application is considered to have current focus. The current application<br>
generally receives and provides all user input and output interaction. Typically, such systems are characterized by having only a single application visible on an associated display at any one point in time. When there is a traversal between the application considered the current application and a new application targeted to be the new current application, the new target application becomes the current application and such target application fills the corresponding frame.<br>
[0005]	Applications often have different modes where a mode defines what is visible in<br>
a given frame. Some applications may be initiated in any one of a number of modes (multi-modal) while other applications may only be initiated in a single mode (single-modal). As such, a single-modal application always begins execution in the same single pre-defined state. That is, whenever, the application is launched the application displays the same user-interface (U/I) screen(s) to the user and provides the user with the same functional operation. For example, computer games are often designed to be of a single-modal type, and when launched, such applications display to the user the same start-up view of the game, typically a standard beginning point of the game. A multi-modal application, in contrast, is an application that can begin execution in any one of a multiple number of pre-defined states. As such, when such applications are launched, depending on the desired mode, such applications both display to the user the one particular desired mode and functionality of the application. For example, some email programs are designed as multi-modal applications where, for example, one mode is a "composition" mode, while, for example, another mode is a "reading new mail" mode. As such, when launched, the email program must be initiated to execute in one of the given modes.<br>
[0006]	When multi-modal applications are launched in a single-instance environment,<br>
as in any environment, such applications must begin execution in one of their given multiple modes. However, when the switch to a different mode is desired hi a single instance environment, the multi-modal application must be re-launched to begin execution in the new mode. When re-launched, the previous mode information is lost and therefore cannot be retrieved upon any re-execution or re-launching of such application. As such, each of the different modes of the application must be presented as separate applications requiring consumption of their own memory, file systems, and title like. Therefore, even though the desired application may be executing before a switch between different modes, the same application must be re-executed as a separate application in the new mode. The process of shutting down and starting up applications<br>
each require significant use of the limited resources particularly in severely resource constrained devices.<br>
10007]	Some applications are known to have multiple states where certain dynamic<br>
application state information may influence the usefulness of such application. Rather<br>
f<br>
than application modes, such information may be referred to as user interface data information. Such user interface data information can include, for example, programs forward and back link information from browser applications which are useful to a user operating such applications. Where a browser is being used and a collection of forward and back links have been generated, and where then a new browser application is then executed from within the initial browser application, the operation within the new browser begins without any forward and backward links, and if the user wished to go to a previous link on the initial browser application, the user would not be presented with the option to perform such operation.<br>
[0008]	Applications that launch other applications typically have limited operational<br>
capabilities. For example, such systems do not provide for the back tracking (or relaunching) to a previously current application when an application called by the previously current application is terminated. Similarly, current systems do not provide for the passing of historical information for any re-launch of a previously current application. Currently, for example, in at least one email application, where the email application is currently executing as the current application in a "composition" mode, and while in such mode the device receives notification of the receipt of a new email message, a new email application is then executed where the new email displayed. In addition, in at least one email application, and under the same circumstances, the application, instead of executing the application in the new mode, instead keeps the - current application as current and ignores the email notification message.<br>
[0009]	There is therefore a need in the art for a device or platform that supports re-<br>
launching of applications such that the re-launch includes the execution of the application using the same mode and/or state information associated with a previous launch of such application. There is also a need in the art for a device or platform that supports re-launching of multi-mode applications without the need to initiate any additional instances of the application.<br>
SUMMARY<br>
[0010]	Embodiments disclosed herein address the above stated needs including, for<br>
example, one or more embodiments, in which methods, software and apparatus, are used to control and execute applications on a computing device including the saving of application state history information. The application state history information contains an historical snap-shot of dynamic application state information associated with execution of a first application. Further, such saved application state history information is saved for subsequent use hi a re-launch of the first application. In addition, also included in such embodiments) is a launching of a second application on the computing device.<br>
[0011]	In at least one embodiment, methods, software and apparatus are used to retrieve<br>
saved application state history information. The application state history information contains an historical snap-shot of dynamic application state information associated with a previous first application previously executing on a computing device. In addition, the embodiments) re-launches the previous first application on the computing device using the retrieved application state history information.<br>
[0012]	hi at least one embodiment, methods, software and apparatus are used to exit a<br>
first application executing on a computing device while saving application state history information associated with the first application. A second application is launched in response to exiting the first application, hi addition, the second application is exited. Saved application state history information associated with the first application is retrieved. The first application on the computing device is re-launched in response to exiting the second application. The first application is re-launched using the retrieved application state history information.<br>
[0013]	At least one embodiment includes methods, software and apparatus used to<br>
execute a first application on a computing device. A call is generated to a second application from the first application. The first application is exited in response to detecting the call to the second application. The application state history information associated with the first application is saved in response to the call to the second application. Also, the second application is launched hi response to the call to the second application. The embodiment detects the termination of the second application. The saved application state history information associated with the first application is retrieved in response to detecting the termination of the second application. The<br>
embodiments) re-launches the first application, in response to detecting the termination of the second application, using the retrieved application state history information.<br>
[0014]	In at least one embodiment is included methods, software and apparatus using a<br>
memory, an application stored in the memory and operable to generate dynamic application state information, a runtime environment stored in the memory from which the application executes, and a processor coupled to the memory and operable to execute code to save application state history information, wherein the application state history information contains an historical snap-shot of dynamic application state information. The dynamic application state information is associated with an application currently executing on a computing device. In the embodiment(s) the application state history information is used in a subsequent re-launch of the currently running application on the computing device.<br>
[0015]	At least one embodiment includes methods, software and apparatus using a<br>
memory, an application that is stored in the memory and is operable to generate the dynamic application state information; a runtime environment from which the application executes, and a processor coupled to the memory and operable to execute code to retrieve saved application state history information. The application state history information contains an historical snap-shot of dynamic application state information associated with a previous target application wherein the previous target application was previously executing on a computing device.<br>
At least one advantage of at least one embodiment includes providing the ability for a to support the function of exiting back to a previously running application in its pervious mode and/or state. Further, at least one advantage of at least one embodiment includes providing the ability to retain the active execution currently running program when attempting a re-launch the same application. At least one advantage of at least one embodiment includes providing the ability to maintain only a single instance of a multi-mode application on a after subsequent calls to the same application using different modes. At least one advantage of at least one embodiment includes the saving of memory and processor resources, as well as providing a better user experience, with the ability of a device having a to exit back to a previous executing application without initiating the execution of an application.<br>
[0016]	Other aspects, advantages, and features of the present invention will become<br>
apparent after review of the entire application, including the following sections: Brief Description of the Drawings, Detailed Description, and the Claims.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0017]	The foregoing aspects and the attendant advantages of the embodiments<br>
described herein will become more readily apparent by reference to the following<br>
detailed description when taken in conjunction with the accompanying drawings<br>
wherein:<br>
[0018]	FIG. 1 shows one embodiment of a computing device fer executing applications<br>
using application state history information<br>
[0019]	FIG. 2 shows one embodiment of a flow chart reflecting a method of executing<br>
applications on a computing device using application state history information;<br>
[0020]	FIG. 3 shows one embodiment of a data table reflecting a method of executing<br>
applications on a computing device including the step-by-step contents of exemplary<br>
dynamic application state information<br>
[0021]	FIG. 4 shows one embodiment of a method of executing applications on a<br>
computing device including the saving of application state history information and<br>
launching a second application;<br>
[0022]	FIG. 5 shows one embodiment of a method of executing applications on a<br>
computing device including the retrieving of application state history information and<br>
re-launching a previous first application;<br>
[0023]	FIG. 6 shows one embodiment of a method of executing applications on a<br>
computing device using application state history information; and<br>
[0024]	FIG. 7 shows one embodiment of a method of executing applications on a<br>
computing device using application state history information;<br>
DETAILED DESCRIPTION<br>
[0025]	The word "exemplary" is used herein to mean "serving as an example, instance,<br>
or illustration." Any embodiment described herein as "exemplary" is not necessarily to be construed as preferred or advantageous over other embodiments.<br>
[0026]	The following detailed description describes methods, software and apparatus<br>
used to execute applications on a computing device, including methods, software and apparatus, for controlling the execution of applications on a computing device using application state history information, hi one or more embodiments, the computing device has an embedded controller and limited resources (i.e., limited memory capacity, a display area and file system space), and the computing device operates to utilize<br>
application state history information in controlling the execution of resident applications.<br>
[0027]	In one or more embodiments, the system used to execute applications on the<br>
computing device interacts with a runtime environment executing on the computing device that is used to simplify operation of the device, such as by providing generalized calls for device specific resources. One such runtime environment is the Binary Runtime Environment for Wireless® (BREW™) software platform developed by QUALCOMM, Inc., of San Diego, California. In the following description, it will be assumed that the system used to execute applications on the computing device is implemented on a portable device executing a runtime environment, such as the BREW software platform. However, one or more embodiments of the system used to execute applications on the computing device are suitable for use with other types of runtime environments to control the execution of applications on computing devices.<br>
[0028]	FIG. 1 illustrates one exemplary embodiment of a computing device 100.   As<br>
used herein "computing device" includes: one or more processing circuits executing software modules stored in memory, such as microprocessors, digital signal processors (DSPs), microcontrollers, portable wireless telephones, personal digital assistants (PDAs), and paging devices, or any suitable combination of hardware, software stored in memory and/or firmware wherein an application is maintained. The device includes a memory 102, network I/O interface 104, user I/O interface 106, processor 108 and bus 110. Although the memory 102 is shown as one contiguous unit of RAM, other embodiments use multiple locations and multiple types of memory as memory 102. The network I/O interface 104 provides input and output to all devices connected to the network via the bus 110. The User I/O interface 106 provides input and output to the user of the computing device 100. The processor 108 operates on instructions and data provided via the bus 110.<br>
[0029]	Located within memory 102 is a first application 112, second application 114,<br>
runtime environment 116, dynamic application state information 118 and application state historical information 120. The first application 112 and second application 114 represent any applications that are compatible with computing device 100 and are capable of interaction with the runtime environment 116. As mentioned above, the runtime environment 116 executes on the computing device to simplify operation of the device, such as by providing generalized calls for device specific resources. Although<br>
he runtime environment shown is BREW™, other runtime environments 116 providing similar functionality are used in oner exemplary embodiments.<br>
[0030]	The dynamic application state information 118 includes all or part of the<br>
information used when executing applications on such a device. The dynamic application state information 118 is data that is capable of being updated or changed during the execution of an application. Such dynamic application state information 118 may include any one or more of: a specific application identifier, application mode information, user interface data information, and other like information that may be stored in variables, registers as well as other storage data structures.<br>
[0031]	The application identifier includes information uniquely identifying a specific<br>
application. Therefore, typically each application identifier would represent a unique set of application code. However, in one exemplary embodiment, applications with the same code are given separate application identifiers such that the applications are treated as being wholly unrelated to one another by the system.<br>
[0032]	The application mode information represents, for example, different and distinct<br>
functional aspects of the same application, (e.g., a compose mode, and a read new mail mode of an email program), where display and/or the functional operation of the application differs significantly between different parts of the same application. A previous application mode is an application mode that has been previously suspended due to, or in anticipation of, for example, a call from a first application 112 to a second application 114. Typically, the previous mode contents are stored to application history for'use on a subsequent re-launch of the first application upon return from the second application.<br>
[0033]	The user interface data information represents, for example, almost any data<br>
generated or used by the application that impacts the potential execution thereof. One example of relatively important user interface data information includes the information stored in conjunction with a browser application which includes a list of links representing web pages that were previously visited by the browser application. Such information is relatively important in that it significantly impacts the use of the program, e.g., forward and backward links are generally known to be a relatively heavily used, and relatively invaluable feature attributed to most browsers. Another example of user interface data information includes a list location marker such that an application may be restarted displaying the same list, and at the same location within the list. As such, user interface data information may include any variety of information<br>
that would otherwise be lost upon exiting an application and that may be deemed worthwhile to have automatically loaded upon a re-execution of the corresponding application.<br>
[0034]	The application state historical information 120 contains the type of information<br>
available in the dynamic application state information 118. As such, the application state history information 120 represents the dynamic application state information 118 as were present at specific earlier point in time. As such the application state history information 118 reflects stale dynamic application state information 118 from a previous point in time. Although such information is historical, that does not mean that such information is not equal to the current state of the device, but rather simply represents an historical snap-shot reflecting the state of the dynamic application state information 118 at a prior time after which the device has been generally free to change such values.<br>
[0035]	As shown, the first application 112, the second application 114 and the runtime<br>
environment 116 each contain an optional set of code including both code 122 to save application state history information 120 and code 124 to retrieve application state history information 120. Although such code is shown to optionally exist in each of such applications and the run time environment, multiple exemplary embodiments include locating such code in any combination across such applications and the runtime environment. For example, in one embodiment the runtime environment 116 contains a module that is called by both code 122 to save application state history information 120 and code 124 to retrieve application state history information 120 from both the first and second applications 112 and 114. What is typically important is that code exists in at • least one location and that such code perform both the saving and the retrieving such that the application state history information 120 can be used to control the re-execution of a previously running application.<br>
[0036]	Finally, also shown are current application indicator 126 and previous current<br>
application indicator 127. At the corresponding time frame, for example, the second application 114 is current while the first application 112 is the previously current application. As discussed above, because the computing device 100 only allows one application to be current at any point in time, only one application (i.e., the second application 114) can be correctly indicated as being the current application at any one point in time.<br>
[0037]	FIG. 2 illustrates one exemplary embodiment 200 of a flowchart for executing<br>
applications on a computing device. Specifically, FIG. 2 describes the use of application state history information 120 in executing such applications. The process begins at step 202 where initial execution of the application begins. Generally the initial execution of an application may be considered to be the detection of an upcoming call to such application or the actual execution of instructions within the application itself.<br>
10038]	Following the initial execution of the application at step 202 is the detection of<br>
the type of execution at step 206. Here, a determination is made as to whether the execution is a "launch" or a "re-launch," where a "launch" represents an initial call to an application that has not yet been exited, and a "re-launch" represents a subsequent call to an application based on the a return from an exit from a subsequently exited program. In other words, if a call to an application occurs due to a backward return from a previous application, such action is a "re-launch" while a forward call from another application represents a "launch."<br>
[0039]	If a launch is detected then the process continues to set dynamic application state<br>
information 118 to initial default settings at step 208. Here the data application is set to start from an initial state that does not reflect any previous state history of such application. If however, a re-launch is detected then the process instead continues to set dynamic application state information 118 to the corresponding application state history information 120 at step 210 such that the application is initialized to a previous state of the application reflecting settings present when the application was previously exited. However, other embodiments, on re-launch, assign or set dynamic application state information 118 to data other than that present upon the earlier exiting of the application, such as when an application is always initialized to initial settings. Following launch or re-launch steps 208 and 210 is the step of continuing execution of the application at step 212.<br>
[0040]	The application continues to execute in step 212 while the application is<br>
monitored to either detect the impending loss of running status of the application at step 214 or to detect the termination of the application at step 218. Similar to the detection of launch or re-launch, such detections can occur either within the application itself or outside thereof. In one embodiment the detection of the impending loss of running status is detected via computer instructions associated with a call-type command that invokes a call to another application. In another embodiment the detection occurs<br><br>
outside of the current application such as the runtime environment or the called application or other like location. Further, one embodiment detects the termination of the application via code associated with an exit-type instruction within the application. However, other embodiments detect such termination in the runtime environment or in a returned-to application or other like location. In one embodiment the system notifies the application of the impending loss of running status.<br>
[0041]	If there is a detection of the impending loss of running status at step 214, then<br>
the dynamic application state information 118 is saved to the application state history information 120 at step 216. Following such a save of the dynamic application state information 118 in step 216 or the detection of the termination of the application in step 218, is the end of the process at step 220.<br>
[0042]	FIG. 3 illustrates one exemplary embodiment 300 of the computing device 100<br>
in the form of a table displaying the inter-relationships between application calls and system related information. The system related information is shown in four columns: in col. 1 is an application execution sequence 302 with associated application modes 304, in col. 2 is the currently running application 306 and corresponding application mode 304, in col. 3 are the active instances 308 and in col. 4 is the application state history information 120 including previous target application 312, earlier target applications, previous mode information and previous user interface data information 318. Further, the rows of the table reflect the different states corresponding to the different application calls and returns (320, 322, 324, 326, 328, 330, 332, 334, 336 and 338), or launches and re-launches, to and from the different target application 340, 342, 344 and 346.<br>
[0043]	As shown, the process begins at node 348 where the call to the email application<br>
340 is initiated in the "composition" mode 350. As a result, the currently running application 306 becomes the email application 340 and the current application mode 304 becomes the "composition" mode 350. The active instances 308 now includes email application 340 while application state history information 120 remains empty.<br>
[0044]	Next, the currently running application 306 (email 34) makes a call 322 to<br>
launch as the same target application of the email application 340, but with the new mode of "read new mail" 352. This would occur, for example, when a user is attempting to compose a new email to send, but while in such process then receives a new mail message. In one embodiment, the system detects a call to the same application, and in response, maintains the email application 340 as the current running<br>
application 306. As a result, the only active instance 308 remains as the previous email application 340. However, with the exiting of the email application 340 in the "composition" mode 350, the system updates application state history information 120 with the application identifier (email application 340) as well as with the application mode ("composition" 350).<br>
[0045]	Next, currently running application 306, (email application 340) makes a call<br>
324 to launch the target application (game application 342). This may occur, for example, where the email application 340, while in the read new mail mode 352, displays an email message containing a link to the game application 342, and where the user then chooses to execute the game application 342. In response, a new active instance for the game application 342 is added to the already active instance for the email application 340. In addition, the application state history information 120 is populated with a previous target application 312 (email application 340) as well as the previous mode information ("read new mail" 352).<br>
[0046]	While running the game application 342, the user, for example, requests to<br>
cancel the execution of the current game application 342, as a result, the call 326 is executed to re-launch the previous target application 312, (email application 340) using the previous mode information 316, ("read new mail" mode 352). The currently running application 306 is set to the email application 340 with the current mode of "read new mail" 352. The game application 342 is removed as an active instance 308 leaving the email application 340 as the only currently active instance 308. Also, the application state history information 120 is updated by removing of the previous target application 312 (email) including previous mode information 316 ("read new mail).<br>
[0047]	Next, back in the email application 340 in the "read new mail" mode 352, the<br>
user, for example, might choose to read an email including an executable icon for a browser application 344. The user then, for example, might execute the link to the browser application 344 to begin its execution. In one embodiment, for example, upon execution, the browser initializes itself with a default home application of a browser email page. The currently running application 306 becomes the browser application 344 and the active instances 308 is expanded to include the browser application 344. Also, the application state history information 120 is updated to include a new entry for the email application 340 along with the application mode of "read new mail" 352.<br>
[0048]	In one embodiment, the browser application 344 executes an email page, where<br>
a user reads an email containing a word processor document. The user might then open<br>
the document, and in so doing, initiate a launch to a target application 330 where the associated word processor application 346 may begin execution. When initiated, the active instances 308 receive a new entry of the word processor application 346. Also, the application state history information 120 is updated to include a new entry for the browser application 344 along with user interface data information including information identifying the browser email page 354 and any backward and forward links 356 associated with the browser application 344.<br>
[0049]	Operating from within the word processor application 346, an exit is detected by<br>
the system. Detecting the exit, the system executes return call 332 which re-launches the previous target application 312 (containing a reference to the browser application 344) using the previous user interface data information 318 such mat the browser application 344 is executed and initialized to a web page that is the browser email page 354, and where the associated browser links are set to the corresponding backward and forward links 356 saved earlier. The currently running application 306 becomes the browser application 344. The currently active instances 308 has the word processing application 346 removed. Also, the application state history information 120 is updated with the removal of the previous target application 312 (browser) including previous U/I data information 318 (browser email page &amp; backward and forward links).<br>
[0050]	Now executing the browser application 344 the system may detect an exit<br>
therefrom. Detecting the exit, the system executes return call 334 which re-launches the previous target application 312 (currently containing a reference to the email application 340) using the previous mode information 316 such that the email application 340 is executed in the "read new mail" mode 352. The currently running application 306 becomes the email application 340. The currently active instances 308 then experience the removal of the browser application 346. Also, the application state history information 120 is updated with the removal of the previous target application 312.<br>
[0051]	Executing the email application 340 the system may detect an exit therefrom.<br>
Detecting the exit, the system executes return call 336 which re-launches the previous target application 312 (currently containing a reference to the email application 340) using the previous mode information 316 such that the email application 340 is relaunched in the "composition" mode 352. In one embodiment, the system detects the email application as the currently running application when a re-launch of the same application is attempted, and in response, maintains such application as current while simply passing new mode information to the application. The currently running<br>
application 306 remains the email application 340 but now has an application mode of "composition" 3SO. The currently active instances remain unchanged. The application state history information 120 is updated with the removal of its last previous target application 312 entry.<br>
[OOS2J	Finally, while executing the email application 340 the system may detect a final<br>
exit therefiom. Detecting the exit, the system executes exit 338 which ends the series of nested application calls at node 358. The system is aware of the end of the nested calls, at least, because the application state history information is absent any additional entries. Upon exiting the final application there is not currently running application 306, nor are there any active instances 308.<br>
[0053]	Although not shown in FIG. 3, one exemplary embodiment provides for<br>
application launches and re-launches that are not limited to simply previous or simply next applications. For example, in one embodiment an entire list of the applications and corresponding application state history information 120 is available to the user to be selected without regard to the location within the list in which the application appears.<br>
[0054]	FIG. 4 illustrates one exemplary embodiment 400 of a method for executing<br>
applications on a computing device 100. Specifically, FIG. 4 describes a method where after a starting at node 402, step 404 is executed wherein the method saves application state history information 120, containing an historical snap-shot of dynamic application state information 118 associated with execution of a first application 112 on a computing device 100, for use in a subsequent re-launch of the first application 112. Following step 404 is shown step 406 in which the method launches a second application 114 on the computing device 100. Following the second step is the end of the method indicated with end node 408.<br>
[0055f	In addition FIG. 4 also shows a number of optional criteria and steps 408, 410,<br>
412,414,416,418,420,422,424,426 and 428. Specifically optional criteria and steps 408, 410, 412, 414 and 416 each modify step 404 and the remaining optional criteria and steps modify step 406. First step 404 is optionally modified (408) to save dependent on the launch of the second application 114. Step 404 is also optionally modified (410) such mat application state history information 120 includes mode information 416 containing an historical snap-shot of unique functional mode related information. Step 404 is also optionally modified (412) such that application state history information 120 includes user interface data information 418 containing an historical snap-shot of dynamic user interface data related information 118. Step 404 is<br>
also optionally modified (414) such that application state history information 120 indicates a sequential order of the associated application with respect to other applications. Step 404 is also optionally modified (416) wherein the computing device 100 is a wireless device<br>
[0056]	Step 406 is also optionally modified (418) to further exclude initiating execution<br>
of an application. Step 406 is also optionally modified (420) to selectively maintain execution of the first application on the computing device 100. Step 406 is also optionally modified (420 &amp; 422) to detect matching information between the application state history information 120 associated with the first application 112 and information associated with the second application 114. Step 406 is also optionally modified (420, 422 &amp; 424) wherein the matching information is application identification information. Step 406 is also optionally modified (426) to launch dependent on detecting an upcoming loss of a running status for the first application 112. Step 406 is also optionally modified (428) wherein the launch is initiated by the first application.<br>
[0057]	FIG. 5 illustrates one exemplary embodiment 500 of a method for executing<br>
applications on a computing device 100. Specifically, FIG. 5 describes a method where after a starting at node 502, step 504 is executed to retrieve saved application state history information 120 containing an historical snap-shot of dynamic application state information 118 associated with a previous first application 112 previously executing on a computing device 100. Following step 504 is step 506 in which the method relaunches the previous first application 112 on the computing device 100 using the retrieved application state history information 118. Following the second step is the end of the method indicated with end node 508.<br>
[0058]	m addition FIG. 5 also shows a number of optional criteria and steps 508, 510,<br>
512, 514, 516, 518, 520, 522, 524, 526 and 528. Specifically optional criteria and steps 508, 510, 512, 514, 516 and 518 each modify step 504 and the remaining optional criteria and steps modify step 506. First step 504 is optionally modified (510) such that application state history information 120 includes mode information 304 containing an historical snap-shot of unique functional mode related information. Step 504 is also optionally modified (510 &amp; 512) to use the mode information 304 to re-initialize the dynamic application state information 118. Step 504 is also optionally modified (514) such that application state history information includes application user interface data information containing an historical snap-shot of dynamic user interface data related<br>
information. Step 504 is also optionally modified (514 &amp; 516) to use the application user interface data information to re-initialize the dynamic application state information. Step 504 is also optionally modified (518) such that the computing device 100 is a wireless device.<br>
[0059]	Step 506 is optionally modified (520) to exclude initiating execution of any<br>
application. Step 506 is also optionally modified (522) to selectively maintain the application currently executing on the computing device 100 as the previous first application 112. Step 506 is also optionally modified (522 &amp; 524) to detect matching information between the dynamic application state information associated with the application currently executing and the retrieved application state history information associated with the previous second application. Step 506 is also optionally modified (522, 524 &amp; 526) wherein matching information is application identification information. Step 506 is also optionally modified (528) to use application state history information 120 to re-initialize dynamic application state information 118.<br>
[0060]	FIG. 6 illustrates one exemplary embodiment 600 of a method for executing<br>
applications on a computing device 100. Specifically, FIG. 6 describes a method where after a starting at node 602, step 604 is executed to exit a first application 112 executing on a computing device 100. Following step 604 is step 606 in which the method saves application state history information 120 associated with the first application 112.<br>
[0061]	Li one embodiment, its only when a first application 112 calls a second<br>
application 114 that the application state history information 120 is actually saved (i.e., no "back" history is needed until a nested call has occurred). However, in other embodiments, an application can anticipate the need to save such information (i.e., not waiting until the first application 112 has called a second application 114 before populating the application state history information 120 with previous target application information 312), before a call is made to the second application 114 - although such a scenario represents is a less efficient approach, as it requires the use of memory and processing time that may have been unnecessary.<br>
[0062]	Following step 606 is step 608 in which the method launches a second<br>
application 114 in response to exiting the first application 112. Following step 608 is step 610 in which the method exits the second application 114. Following step 610 is step 612 in which the method retrieves the saved application state history information 120 associated with the first application 112. Following step 612 is step 614 in which the method re-launches the first application 112 on the computing device 100, in<br>
response to exiting the second application 114, using the retrieved application state history information 120. Following step 614 is end node 616 which represents the end of the method.<br>
[0063]	Three of the steps 604, 608 and 614 are optionally modified by four additional<br>
limitations 618, 620, 622 and 624. Step 604 is optionally modified (618) such that the computing device 100 is a wireless device. Step 608 is optionally modified (620) to selectively maintain execution of the first application 112 in response to detecting matching application identification information between the first application 112 and the second application 114. Step 614 is optionally modified (622) to selectively maintain execution of the second application 112 in response to detecting matching application identification information between the first application 112 and the second application 114. Step 614 is also optionally modified (624) to use application state history information 120 to re-initialize the first application 112 with previous application state history information 312 associated with the previously exited first application 112.<br>
[0064]	FIG. 7 illustrates one exemplary embodiment 700 of a method for executing<br>
applications on a computing device 100. Specifically, FIG. 7 describes a method where after a starting at node 702, step 704 is executed to execute a first application 112 on a computing device 100. Following step 704 is step 706 in which the method generates a call to a second application 114 from the first application 112. Following step 706 is step 708 in which the method exits the first application 112 in response to detecting the call to the second application 114. Following step 708 is step 710 in which the method saves application state history information 120 associated with the first application 112 in response to the call to the second application 114. Following step 710 is step 712 in which the method launches the second application 114 in response to the call to the second application 114. Following step 712 is step 714 in which the method detects termination of the second application 114. Following step 714 is step 716 in which the method retrieves the saved application state history information 120 associated with the first application 112 in response to detecting the termination of the second application 114. Following step 716 is step 718 in which the method re-launches the first application 112, in response to detecting the termination of the second application 114, using the retrieved application state history information 120. Following step 718 is end node 720 which represents the end of the method.<br>
[0065J	Three of the steps 704, 712 and 718 are optionally modified by three additional<br>
limitations 722, 724 and 726. Step 704 is optionally modified (722) such that the computing device 100 is a wireless device. Step 712 is optionally modified (724) to selectively maintain execution of the first application 112 in response to detecting matching application identification infonnation between the first application 112 and the second application 114. Step 718 is optionally modified (726) to selectively maintain execution of the second application 114 hi response to detecting matching application identification information between the first application 112 and the second application 114.<br>
[0066]	Those of skill would further appreciate that the various illustrative logical<br>
blocks, modules, circuits, and algorithm steps described in connection with the embodiments disclosed herein may be implemented as electronic hardware, computer software, or combinations of both. To clearly illustrate this interchangeability of hardware and software, various illustrative components, blocks, modules, circuits, and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application, but such implementation decisions should not be interpreted as causing a departure from the scope of the present invention.<br>
[0067]	The steps of a method or algorithm described in connection with the<br>
embodiments disclosed herein may be embodied directly in hardware, hi a software module executed by a processor, or in a combination of the two. A software module may reside in RAM memory, flash memory, ROM memory, EPROM memory, EEPROM memory, registers, hard disk, a removable disk, a CD-ROM, or any other form of storage medium known in the art. An exemplary storage medium is coupled to the processor such the processor can read information from, and write information to, the storage medium, hi the alternative, the storage medium may be integral to the processor. The processor and the storage medium may reside hi an ASIC. The ASIC may reside in a user terminal, hi the alternative, the processor and the storage medium may reside as discrete components hi a user terminal.<br>
[0068]	The previous description of the disclosed embodiments is provided to enable any<br>
person skilled in the art to make or use the present invention. Various modifications to these embodiments will be readily apparent to those skilled hi the art, and the generic<br>
principles defined herein may be applied to other embodiments without departing from the spirit or scope of the invention. Thus, the present invention is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.<br>
WHAT IS CLAIMED IS:<br><br><br><br><br><br><br><br>
We claim:<br>
1.	A method of executing applications on a computing device, comprising:<br>
saving application state history information, containing an historical snap-shot of dynamic application state information associated with execution of a first application on a computing device, for use in a subsequent re-launch of the first application; and<br>
launching a second application on the computing device.<br>
2.	The method as claimed in claim 1 wherein the step of launching a second application selectively excludes initiating execution of an application.<br>
3.	The method as claimed in claim 1 wherein the step of launching a second application further includes the step of selectively maintaining execution of the first application on the computing device.<br>
4.	The method as claimed in claim 3 wherein the step of selectively maintaining the execution of the first application further includes the step of detecting matching information between the application state history information associated with the first application and information associated with the second application.<br>
5.	The method as claimed in claim 4 wherein the matching information is application identification information.<br>
6.	The method as claimed in claim 1 wherein the step of saving application state history information is dependent on the step of launching the second application.<br>
7.	The method as claimed in claim 1 wherein the step of launching the second application is dependent on a step of detecting an upcoming loss of a running status for the first application.<br>
21<br><br>
8.	The method as claimed in claim 1 wherein the application state history information includes mode information containing an historical snap-shot of unique functional mode related information.<br>
9.	The method as claimed in claim 1 wherein the application state history information includes user interface data information containing an historical snap-shot of dynamic user interface data related information.<br>
10.	The method as claimed in claim 1 wherein the application state history information indicates a sequential order of the associated application with respect to other applications.<br>
11.	The method as claimed in claim 1 wherein the launching of the second application is initiated by the first application.<br>
12.	The method as claimed in claim 1 wherein the computing device is a wireless device.<br>
13.	A method of executing applications on a computing device, comprising:<br>
retrieving saved application state history information containing an historical snap-shot of dynamic application state information associated with a previous first application previously executing on a computing device; and<br>
re-launching the previous first application on the computing device using the retrieved application state history information.<br>
14.	The method as claimed in claim 13 wherein the step of re-launching the previous first application excludes initiating execution of any application.<br>
15.	The method as claimed in claim 13 wherein the step of re-launching the previous first application further includes the step of selectively maintaining the application currently executing on the computing device as the previous first application.<br>
16.	The method as claimed in claim 15 wherein the step of selectively maintaining the application currently executing on the computing device as<br>
the previous second application further includes the step of detecting matching information between the dynamic application state information associated with the application currently executing and the retrieved application state history information associated with the previous second application.<br>
17.	The method as claimed in claim 16 wherein the matching information is application identification information.<br>
18.	The method as claimed in claim 13 wherein the step of re-launching the previous first application further comprises the step of using application state history information to re-initialize dynamic application state information.<br>
19.	The method as claimed in claim 13 wherein the application state history information includes mode information containing an historical snap-shot of unique functional mode related information.<br>
20.	The method as claimed in claim 19 further comprising the step of using the mode information to re-initialize the dynamic application state information.<br>
21.	The method as claimed in claim 13 wherein the application state history information includes application user interface data information containing an historical snap-shot of dynamic user interface data related information.<br>
22.	The method as claimed in claim 21 further comprising the step of using the application user interface data information to re-initialize the dynamic application state information.<br>
23.	The method as claimed in claim 13 wherein the computing device is a wireless device.<br>
24.	A method as claimed in executing applications on a computing device, comprising:<br>
exiting a first application executing on a computing device;<br>
saving application state history information associated with the first application;<br>
launching a second application in response to exiting the first application;<br>
exiting the second application;<br>
retrieving the saved application state history information associated with the first application; and<br>
re-launching the first application on the computing device, in response to exiting the second application, using the retrieved application state history information.<br>
25.	The method as claimed in claim 24 wherein the step of launching a second application further includes the step of selectively maintaining execution of the first application in response to detecting matching application identification information between the first application and the second application.<br>
26.	The method as claimed in claim 24 wherein the step of re-launching the first application further includes the step of selectively maintaining execution of the second application in response to detecting matching application identification information between the first application and the second application.<br>
27.	The method as claimed in claim 24 wherein the step of re-launching the first application further comprises the step of using application state history information to re-initialize the first application with previous state history information associated with the previously exited first application.<br>
28.	The method as claimed in claim 24 wherein the computing device is a wireless device.<br>
29.	A method of executing applications on a computing device, comprising:<br>
executing a first application on a computing device;<br>
generating a call to a second application from the first application;<br>
exiting the first application in response to detecting the call to the second application;<br>
saving application state history information associated with the first application in response to the call to the second application;<br>
launching the second application in response to the call to the second application;<br>
detecting termination of the second application;<br>
retrieving the saved application state history information associated with the first application in response to detecting the termination of the second application; and<br>
re-launching the first application, in response to detecting the termination of the second application, using the retrieved application state history information.<br>
30.	The method as claimed in claim 29 wherein the step of launching the second application further includes the step of selectively maintaining execution of the first application in response to detecting matching application identification information between the first application and the second application.<br>
31.	The method as claimed in claim 29 wherein the step of re-launching the first application further includes the step of selectively maintaining execution of the second application in response to detecting matching application identification information between the first application and the second application.<br>
32.	The method as claimed in claim 29 wherein the computing device is a wireless device.<br>
33.	A computing device comprising:<br>
a memory;<br>
an application stored in the memory and operable to generate the dynamic application state information;<br>
a runtime environment stored in the memory from which the application executes; and<br>
 processor coupled to the memory and operable to execute code to save application state history information, containing an historical snap-shot of dynamic application state information associated with an application currently executing on a computing device, for use in a subsequent re-launch of the currently running application on the computing device.<br>
34.	The computing device as claimed in claim 33 wherein the code to save application state history information is located in at least one of the following: the application and the runtime environment.<br>
35.	The computing device as claimed in claim 33 wherein the computing device is a wireless device.<br>
36.	A computing device comprising:<br>
a memory;<br>
an application stored in the memory and operable to generate the dynamic application state information; and<br>
a runtime environment from which the application executes; and<br>
a processor coupled to the memory and operable to execute code to retrieve saved application state history information containing an historical snap-shot of dynamic application state information associated with an application previously executing on a computing device.<br>
37.	The computing device as claimed in claim 36 wherein the code to retrieve application state history information is located in at least one of the following: the application and the runtime environment.<br>
38.	The computing device as claimed in claim 36 wherein the computing device is a wireless device.<br>
39.	A computing device, comprising:<br>
means for saving application state history information, containing an historical snap-shot of dynamic application state information associated with execution of a first application on a computing device, for use in a subsequent re-launch of the first application; and<br>
means for launching a second application on the computing device.<br>
40. A computing device, comprising:<br>
means for retrieving saved application state history information containing an historical snap-shot of dynamic application state information associated with a previous first application previously executing on a computing device; and<br>
means for re-launching the previous first application on the computing device using the retrieved application state history information.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LUFic3RyYWN0LSgwMS0wNC0yMDE0KS5wZGY=" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-Abstract-(01-04-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1ERUxOUC0yMDA2LUFic3RyYWN0LSgxNC0wNi0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">6933-DELNP-2006-Abstract-(14-06-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1ERUxOUC0yMDA2LUFzc2lnbm1lbnRzLnBkZg==" target="_blank" style="word-wrap:break-word;">6933-DELNP-2006-Assignments.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LUNsYWltcy0oMDEtMDQtMjAxNCkucGRm" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-Claims-(01-04-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1ERUxOUC0yMDA2LUNsYWltcy0oMTQtMDYtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">6933-DELNP-2006-Claims-(14-06-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMDgtMDYtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-Correspondence Others-(08-06-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMTQtMDYtMjAxMSkuLnBkZg==" target="_blank" style="word-wrap:break-word;">6933-DELNP-2006-Correspondence Others-(14-06-2011)..pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMTQtMDYtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">6933-DELNP-2006-Correspondence Others-(14-06-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMjItMDgtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-Correspondence Others-(22-08-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlLU90aGVycy0oMDEtMDMtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">6933-DELNP-2006-Correspondence-Others-(01-03-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1ERUxOUC0yMDA2LURyYXdpbmdzLSgxNC0wNi0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">6933-DELNP-2006-Drawings-(14-06-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LWZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LUZvcm0tMi0oMDEtMDQtMjAxNCkucGRm" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-Form-2-(01-04-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1ERUxOUC0yMDA2LUZvcm0tMy0oMDEtMDMtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">6933-DELNP-2006-Form-3-(01-03-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LUZvcm0tMy0oMDgtMDYtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-Form-3-(08-06-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LUZvcm0tMy0oMjItMDgtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-Form-3-(22-08-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1ERUxOUC0yMDA2LUZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">6933-DELNP-2006-Form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LUdQQS0oMDEtMDQtMjAxNCkucGRm" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-GPA-(01-04-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1ERUxOUC0yMDA2LUdQQS0oMTQtMDYtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">6933-DELNP-2006-GPA-(14-06-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LXBjdC0zMDQucGRm" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-pct-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1kZWxucC0yMDA2LXBjdC1zZWFyY2ggcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">6933-delnp-2006-pct-search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1ERUxOUC0yMDA2LVBldGl0aW9uLTEzNy0oMTQtMDYtMjAxMSkuLnBkZg==" target="_blank" style="word-wrap:break-word;">6933-DELNP-2006-Petition-137-(14-06-2011)..pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjkzMy1ERUxOUC0yMDA2LVBldGl0aW9uLTEzNy0oMTQtMDYtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">6933-DELNP-2006-Petition-137-(14-06-2011).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="260338-preparation-of-2-hydroxy-4-methylthiobutyric-acid.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="260340-a-heating-type-balloon-catheter-device.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>260339</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>6933/DELNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>17/2014</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>25-Apr-2014</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>24-Apr-2014</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>20-Nov-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 MOREHOUSE DRIVE, SAN DIEGO, CALIFORNIA 92121 USA.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>KELLEY BRIAN HAROLD</td>
											<td>10917 CLOVERHURST WAY, SAN DIEGO, CA 92130 USA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>WALKER ROBERT</td>
											<td>12692 SANDY CREST COURT, SAN DIEGO, CA 92130 USA</td>
										</tr>
										<tr>
											<td>3</td>
											<td>NIJDAM MARC EDWARD</td>
											<td>4971 KENSINGTON DRIVE, SAN DIEGO, CA 92116 USA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06N</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2005/018672</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-05-26</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/854,982</td>
									<td>2004-05-26</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/260339-a-method-of-switching-applications-and-a-device-thereof by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:42:02 GMT -->
</html>
