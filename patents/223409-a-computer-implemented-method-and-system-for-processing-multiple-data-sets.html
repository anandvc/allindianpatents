<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/223409-a-computer-implemented-method-and-system-for-processing-multiple-data-sets by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:57:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 223409:A COMPUTER-IMPLEMENTED METHOD AND SYSTEM FOR PROCESSING MULTIPLE DATA SETS.</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A COMPUTER-IMPLEMENTED METHOD AND SYSTEM FOR PROCESSING MULTIPLE DATA SETS.</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A system and method for enhancing knowledge discovery from data using multiple learning machines in general and multiple support vector machines in particular. Training data for a learning machine is pre - processed (103, 203), in order to add meaning thereto. Pre - processing data may involve transforming the data points and/or expanding the data points. By adding meaning to the data, the learning machine is provided with a greater amount of information for processing. With regard to support vector machines in particular, the greater the amount of information that is processed, the better generalizations about the data that may be derived. Multiple support vector machines, each comprising distinct kernels, are trained with the pre-processed training data and are tested (112, 218, 220) with test data that is pre - processed (110, 214) in the same manner. The test outputs from multiple support vector machines are compared (222,1312) in order to determine which of the test outputs if any represents an optimal solution. Selection of one or more kernels may be adjusted and one or more support vector machines may be retrained and retested. Optimal solutions based on distinct input data sets may be combined to form a new input data set to be input into one or more additional support vector machine.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>MULTIPLE DATA<br>
Technical Field<br>
The present invention relates to the use of learning machines to<br>
discover knowledge from data. More particularly, the present invention relates to<br>
optimizations for learning machines and associated input and output data, in<br>
order to enhance the knowledge discovered from multiple data sets.<br>
Background of the Invention<br>
Knowledge discovery is the most desirable end product of data<br>
collection. Recent advancements in database technology have lead to an<br>
explosive growth in systems and methods for generating, collecting and storing<br>
vast amounts of data. While database technology enables efficient collection and<br>
storage of large data sets, the challenge of facilitating human comprehension of<br>
the information in this data is growing ever more difficult. With many existing<br>
techniques the problem has become unapproachable. Thus, there remains a need<br>
for a new generation of automated knowledge discovery tools.<br>
As a specific example, the Human Genome Project is populating a<br>
multi-gigabyte database describing the human genetic code. Before this mapping<br>
of the human genome is complete (expected in 2003), the size of the database is<br>
expected to grow significantly. The vast amount of data in such a database<br>
overwhelms traditional tools for data analysis, such as spreadsheets and ad hoc<br>
queries. Traditional methods of data analysis may be used to create informative<br>
reports from data, but do not have the ability to intelligently and automatically<br>
assist humans in analyzing and finding patterns of useful knowledge in vast<br>
amounts of data. Likewise, using traditionally accepted reference ranges and<br>
standards for interpretation, it is often impossible for humans to identify patterns<br>
of useful knowledge even with very small amounts of data.<br>
One recent development that has been shown to be effective in<br>
some examples of machine learning is the back-propagation neural network..<br>
Back-propagation neural networks are learning machines that may be trained to<br>
discover knowledge in a data set that is not readily apparent to a human.<br>
However, there are various problems with back-propagation neural network<br>
approaches that prevent neural networks from being well-controlled learning<br>
machines. For example, a significant drawback of back-propagation neural<br>
networks is that the empirical risk function may have many local minimums, a<br>
case that can easily obscure the optimal solution from discovery by this<br>
technique. Standard optimization procedures employed by back-propagation<br>
neural networks may convergence to a minimum, but the neural network method<br>
cannot guarantee that even a localized minimum is attained much less the desired<br>
global minimum. The quality of the solution obtained from a neural network<br>
depends on many factors. In particular the skill of the practitioner implementing<br>
the neural network determines the ultimate benefit, but even factors as seemingly<br>
benign as the random selection of initial weights can lead to poor results.<br>
Furthermore, the convergence of the gradient based method used in neural<br>
network learning is inherently slow. A further drawback is that the sigmoid<br>
function has a scaling factor, which affects the quality of approximation. Possibly<br>
the largest limiting factor of neural networks as related to knowledge discovery is<br>
the "curse of dimensionality" associated with the disproportionate growth in<br>
required computational time and power for each additional feature or dimension<br>
in the training data.<br>
The shortcomings of neural networks are overcome using support<br>
vector machines. In general terms, a support vector machine maps input vectors<br>
into high dimensional feature space through non-linear mapping function, chosen<br>
a priori. In this high dimensional feature space, an optimal separating hyperplane<br>
is constructed. The optimal hyperplane is then used to determine things such as<br>
class separations, regression fit, or accuracy in density estimation.<br>
Within a support vector machine, the dimensionally of the feature<br>
space may be huge. For example, a fourth degree polynomial mapping function<br>
causes a 200 dimensional input space to be mapped into a 1.6 billionth<br>
dimensional feature space. The kernel trick and the Vapnik-Chervonenkis<br>
dimension allow the support vector machine to thwart the "curse of<br>
dimensionality" limiting other methods and effectively derive generalizable<br>
answers from this very high dimensional feature space.<br>
If the training vectors are separated by the optimal hyperplane (or<br>
generalized optimal hyperplane), then the expectation value of the probability of<br>
committing an error on a test example is bounded by the examples in the training<br>
set. This bound depends neither on the dimensionality of the feature space, nor<br>
on the norm of the vector of coefficients, nor on the bound of the number of the<br>
input vectors. Therefore, if the optimal hyperplane can be constructed from a<br>
small number of support vectors relative to the training set size, the<br>
generalization ability will be high, even in infinite dimensional space.<br>
As such, support vector machines provide a desirable solution for<br>
the problem of discovering knowledge from vast amounts of input data.<br>
However, the ability of a support vector machine to discover knowledge from a<br>
data set is limited in proportion to the information included within the training<br>
data set. Accordingly, there exists a need for a system and method for pre-<br>
processing data so as to augment the training data to maximize the knowledge<br>
discovery by the support vector machine.<br>
Furthermore, the raw output from a support vector machine may<br>
not fully disclose the knowledge in the most readily interpretable form. Thus,<br>
there further remains a need for a system and method for post-processing data<br>
output from a support vector machine in order to maximize the value of the<br>
information delivered for human or further automated processing.<br>
In addition, a the ability of a support vector machine to discover<br>
knowledge from data is limited by the selection of a kernel. Accordingly, there<br>
remains a need for an improved system and method for selecting and/or creating<br>
a desired kernel for a support vector machine.<br>
Summary of the Invention<br>
The present invention meets the above described needs by<br>
providing a system and method for enhancing knowledge discovered from<br>
multiple data sets using a multiple learning machines in general and multiple<br>
support vector machines in particular. One or more training data sets are pre-<br>
processed in order to allow the most advantageous application of the learning<br>
machine. Each training data point comprises a vector having one or more<br>
coordinates. Pre-processing the training data set may comprise identifying<br>
missing or erroneous data points and taking appropriate steps to correct the<br>
flawed data or as appropriate remove the observation or the entire field from the<br>
scope of the problem. Pre-processing the training data set may also comprise<br>
adding dimensionality to each training data point by adding one or more new<br>
coordinates to the vector. The new coordinates added to the vector may be<br>
derived by applying a transformation to one or more of the original coordinates.<br>
The transformation may be based on expert knowledge, or may be<br>
computationally derived. In a situation where the training data set comprises a<br>
continuous variable, the transformation may comprise optimally categorizing the<br>
continuous variable of the training data set.<br>
In this manner, the additional representations of the training data<br>
provided by the preprocessing may enhance the learning machine's ability to<br>
discover knowledge therefrom. In the particular context of support vector<br>
machines, the greater the dimensionality of the training set, the higher the quality<br>
of the generalizations that may be derived therefrom. When the knowledge to be<br>
discovered from the data relates to a regression or density estimation or where<br>
the training output comprises a continuous variable, the training output may be<br>
post-processed by optimally categorizing the training output to derive<br>
categorizations from the continuous variable.<br>
A test data set is pre-processed in the same manner as was the<br>
training data set. Then, the trained learning machine is tested using the pre-<br>
processed test data set. A test output of the trained learning machine may be<br>
post-processing to determine if the test output is an optimal solution. Post-<br>
processing the test output may comprise interpreting the test output into a format<br>
that may be compared with the test data set. Alternative postprocessing steps<br>
may enhance the human interpretability or suitability for additional processing of<br>
the output data.<br>
In the context of a support vector machine, the present invention<br>
also provides for the selection of a kernel prior to training the support vector<br>
machine. The selection of a kernel may be based on prior knowledge of the<br>
specific problem being addressed or analysis of the properties of any available<br>
data to be used with the learning machine and is typically dependant on the<br>
nature of the knowledge to be discovered from the data. Optionally, an iterative<br>
process comparing postprocessed training outputs or test outputs can be applied<br>
to make a determination as to which configuration provides the optimal solution.<br>
If the test output is not the optimal solution, the selection of the kernel may be<br>
adjusted and the support vector machine may be retrained and retested. When it<br>
is determined that the optimal solution has been identified, a live data set may be<br>
collected and pre-processed in the same manner as was the training data set. The<br>
pre-processed live data set is input into the learning machine for processing. The<br>
live output of the learning machine may then be post-processed by interpreting<br>
the live output into a computationally derived alphanumeric classifier.<br>
In an exemplary embodiment a system is provided enhancing<br>
knowledge discovered from data using a support vector machine. The exemplary<br>
system comprises a storage device for storing a training data set and a test data<br>
set, and a processor for executing a support vector machine. The processor is<br>
also operable for collecting the training data set from the database, pre-<br>
processing the training data set to enhance each of a plurality of training data<br>
points, training the support vector machine using the pre-processed training data<br>
set, collecting the test data set from the database, pre-processing the test data set<br>
in the same manner as was the training data set, testing the trained support vector<br>
machine using the pre-processed test data set, and in response to receiving the<br>
test output of the trained support vector machine, post-processing the test output<br>
to determine if the test output is an optimal solution. The exemplary system may<br>
also comprise a communications device for receiving the test data set and the<br>
training data set from a remote source. In such a case, the processor may be<br>
operable to store the training data set in the storage device prior pre-processing of<br>
the training data set and to store the test data set in the storage device prior pre-<br>
processing of the test data set. The exemplary system may also comprise a<br>
display device for displaying the post-processed test data. The processor of the<br>
exemplary system may further be operable for performing each additional<br>
function described above. The communications device may be further operable<br>
to send a computationally derived alphanumeric classifier to a remote source.<br>
In an exemplary embodiment, a system and method are provided<br>
for enhancing knowledge discovery from data using multiple learning machines<br>
in general and multiple support vector machines in particular. Training data for a<br>
learning machine is pre-processed in order to add meaning thereto. Pre-<br>
processing data may involve transforming the data points and/or expanding the<br>
data points. By adding meaning to the data, the learning machine is provided<br>
with a greater amount of information for processing. With regard to support<br>
vector machines in particular, the greater the amount of information that is<br>
processed, the better generalizations about the data that may be derived.<br>
Multiple support vector machines, each comprising distinct kernels, are trained<br>
with the pre-processed training data and are tested with test data that is pre-<br>
processed in the same manner. The test outputs from multiple support vector<br>
machines are compared in order to determine which of the test outputs if any<br>
represents a optimal solution. Selection of one or more kernels may be adjusted<br>
and one or more support vector machines may be retrained and retested. When it<br>
is determined that an optimal solution has been achieved, live data is pre-<br>
processed and input into the support vector machine comprising the kernel that<br>
produced the optimal solution. The live output from the learning machine may<br>
then be post-processed into a computationally derived alphanumerical classifier<br>
for interpretation by a human or computer automated process.<br>
In another exemplary embodiment, a system and method are provided for<br>
optimally categorizing a continuous variable. A data set representing a<br>
continuous variable comprises data points that each comprise a sample from the<br>
continuous variable and a class identifier. A number of distinct class identifiers<br>
within the data set is determined and a number of candidate bins is determined<br>
based on the range of the samples and a level of precision of the samples within<br>
the data set. Each candidate bin represents a sub-range of the samples. For each<br>
candidate bin, the entropy of the data points falling within the candidate bin is<br>
calculated. Then, for each sequence of candidate bins that have a minimized<br>
collective entropy, a cutoff point in the range of samples is defined to be at the<br>
boundary of the last candidate bin in the sequence of candidate bins. As an<br>
iterative process, the collective entropy for different combinations of sequential<br>
candidate bins may be calculated. Also the number of defined cutoff points<br>
may be adjusted in order to determine the optimal number of cutoff point, which<br>
is based on a calculation of minimal entropy. As mentioned, the exemplary<br>
system and method for optimally categorizing a continuous variable may be used<br>
for pre-processing data to be input into a learning machine and for post-<br>
processing output of a learning machine.<br>
In still another exemplary embodiment, a system and method are<br>
provided for for enhancing knowledge discovery from data using a learning<br>
machine in general and a support vector machine in particular in a distributed<br>
network environment. A customer may transmit training data, test data and live<br>
data to a vendor's server from a remote source, via a distributed network. The<br>
customer may also transmit to the server identification information such as a user<br>
name, a password and a financial account identifier. The training data, test data<br>
and live data may be stored in a storage device. Training data may then be pre-<br>
processed in order to add meaning thereto. Pre-processing data may involve<br>
transforming the data points and/or expanding the data points. By adding<br>
meaning to the data, the learning machine is provided with a greater amount of<br>
information for processing. With regard to support vector machines in particular,<br>
the greater the amount of information that is processed, the better generalizations<br>
about the data that may be derived. The learning machine is therefore trained<br>
with the pre-processed training data and is tested with test data that is pre-<br>
processed in the same manner. The test output from the learning machine is<br>
post-processed in order to determine if the knowledge discovered from the test<br>
data is desirable. Post-processing involves interpreting the test output into a<br>
format that may be compared with the test data. Live data is pre-processed and<br>
input into the trained and tested learning machine. The live output from the<br>
learning machine may then be post-processed into a computationally derived<br>
alphanumerical classifier for interpretation by a human or computer automated<br>
process. Prior to transmitting the alpha numerical classifier to the customer via<br>
the distributed network, the server is operable to communicate with a financial<br>
institution for the purpose of receiving funds from a financial account of the<br>
customer identified by the financial account identifier.<br>
In yet another exemplary embodiment, one or more support vector<br>
machines are trained using a first pre-processed training data set and one or more<br>
second support vector machine are trained using a second pre-processed training<br>
data set. The optimal outputs from like support vector machines may then be<br>
combined to form a new input data set for one or more additional support vector<br>
machines.<br>
Brief Description of the Accompanying Drawings<br>
FIG. 1 is a flow chart illustrating an exemplary general method for<br>
increasing knowledge that may be discovered from data using a learning<br>
machine.<br>
FIG. 2 is a flowchart illustrating an exemplary method for<br>
increasing knowledge that may be discovered from data using a support vector<br>
machine.<br>
FIG. 3 is a flowchart illustrating an exemplary optimal<br>
categorization method that may be used in a stand-alone configuration or in<br>
conjunction with a learning machine for pre-processing or post-processing<br>
techniques in accordance with an exemplary embodiment of the present<br>
invention.<br>
FIG. 4 illustrates an exemplary unexpanded data set that may be<br>
input into a support vector machine.<br>
FIG. 5 illustrates an exemplary post-processed output generated<br>
by a support vector machine using the data set of FIG. 4.<br>
FIG. 6 illustrates an exemplary expanded data set that may be<br>
input into a support vector machine.<br><br>
FIG. 7 illustrates an exemplary post-processed output generated<br>
by a support vector machine using the data set of FIG. 6.<br>
FIG. 8 illustrates exemplary input and output for a standalone<br>
application of the optimal categorization method of FIG. 3.<br>
FIG. 9 is a comparison of exemplary post-processed output from a<br>
first support vector machine comprising a linear kernel and a second support<br>
vector machine comprising a polynomial kernel.<br>
FIG. 10 is a functional block diagram illustrating an exemplary<br>
operating environment for an exemplary embodiment of the present invention.<br>
FIG. 11 is a functional block diagram illustrating an alternate<br>
exemplary operating environment for an alternate embodiment of the present<br>
invention.<br>
FIG. 12 is a functional block diagram illustrating an exemplary<br>
network operating environment for implementation of a further alternate<br>
embodiment of the present invention.<br>
FIG. 13 is a functional block diagram illustrating a hierarchical<br>
system of multiple support vector machine.<br>
Detailed Description of Exemplary Embodiments<br>
The present invention provides improved methods for discovering<br>
knowledge from data using learning machines. While several examples of<br>
learning machines exist and advancements are expected in this field, the<br>
exemplary embodiments of the present invention focus on the support vector<br>
machine. As is known in the art, learning machines comprise algorithms that may<br>
be trained to generalize using data with known outcomes. Trained learning<br>
machine algorithms may then applied to cases of unknown outcome for<br>
prediction. For example, a learning machine may be trained to recognize<br>
patterns in data, estimate regression in data or estimate probability density within<br>
data. Learning machines may be trained to solve a wide variety of problems as<br>
known to those of ordinary skill in the art. A trained learning machine may<br>
optionally be tested using test data to ensure that its output is validated within an<br>
acceptable margin of error. Once a learning machine is trained and tested, live<br>
data may be input therein. The live output of a learning machine comprises<br>
knowledge discovered from all of the training data as applied to the live data.<br>
A first aspect of the present invention seeks to enhance knowledge<br>
discovery by optionally pre-processing data prior to using the data to train a<br>
learning machine and/or optionally post-processing the output from a learning<br>
machine. Generally stated, pre-processing data comprises reformatting or<br>
augmenting the data in order to allow the learning machine to be applied most<br>
advantageously. Similarly, post-processing involves interpreting the output of a<br>
learning machine in order to discover meaningful characteristics thereof. The<br>
meaningful characteristics to be ascertained from the output may be problem or<br>
data specific. Post-processing involves interpreting the output into a form that<br>
comprehendible by a human or one that is comprehendible by a computer.<br>
Exemplary embodiments of the present invention will hereinafter<br>
be described with reference to the drawing, in which like numerals indicate like<br>
elements throughout the several figures. FIG. 1 is a flowchart illustrating a<br>
general method 100 for enhancing knowledge discovery using learning<br>
machines. The method 100 begins at starting block 101 and progresses to step<br>
102 where a specific problem is formalized for application of knowledge<br>
discovery through machine learning. Particularly important is a proper<br>
formulation of the desired output of the learning machine. For instance, in<br>
predicting future performance of an individual equity instrument, or a market<br>
index, a learning machine is likely to achieve better performance when predicting<br>
the expected future change rather than predicting the future price level. The<br>
future price expectation can later be derived in a post-processing step as will be<br>
discussed later in this specification.<br>
After problem formalization, step 103 addresses training data<br>
collection. Training data comprises a set of data points having known<br>
characteristics. Training data may be collected from one or more local and/or<br>
remote sources. The collection of training data may be accomplished manually<br>
or by way of an automated process, such as known electronic data transfer<br>
methods. Accordingly, an exemplary embodiment of the present invention may<br>
be implemented in a networked computer environment. Exemplary operating<br><br>
environments for implementing various embodiments of the present invention<br>
will be described in detail with respect to FIGS. 10-12.<br>
Next, at step 104 the collected training data is optionally pre-<br>
processed in order to allow the learning machine to be applied most<br>
advantageously toward extraction of the knowledge inherent to the training data.<br>
During this preprocessing stage the training data can optionally be expanded<br>
through transformations, combinations or manipulation of individual or multiple<br>
measures within the records of the training data. As used herein, expanding data<br>
is meant to refer to altering the dimensionality of the input data by changing the<br>
number of observations available to determine each input point (alternatively,<br>
this could be described as adding or deleting columns within a database table).<br>
By way of illustration, a data point may comprise the coordinates (1,4,9). An<br>
expanded version of this data point may result in the coordinates (1,1,4,2,9,3). In<br>
this example, it may be seen that the coordinates added to the expanded data<br>
point are based on a square-root transformation of the original coordinates. By<br>
adding dimensionality to the data point, this expanded data point provides a<br>
varied representation of the input data that is potentially more meaningful for<br>
knowledge discovery by a learning machine. Data expansion in this sense<br>
affords opportunities for learning machines to discover knowledge not readily<br>
apparent in the unexpanded training data.<br>
Expanding data may comprise applying any type of meaningful<br>
transformation to the data and adding those transformations to the original data.<br>
The criteria for determining whether a transformation is meaningful may depend<br>
on the input data itself and/or the type of knowledge that is sought from the data.<br>
Illustrative types of data transformations include: addition of expert information;<br>
labeling; binary conversion; sine, cosine, tangent, cotangent, and other<br>
trigonometric transformation; clustering; scaling; probabilistic and statistical<br>
analysis; significance testing; strength testing; searching for 2-D regularities;<br>
Hidden Markov Modeling; identification of equivalence relations; application of<br>
contingency tables; application of graph theory principles; creation of vector<br>
maps; addition, subtraction, multiplication, division, application of polynomial<br>
equations and other algebraic transformations; identification of proportionality;<br><br>
determination of discriminatory power; etc. In the context of medical data,<br>
potentially meaningful transformations include: association with known standard<br>
medical reference ranges; physiologic truncation; physiologic combinations;<br>
biochemical combinations; application of heuristic rules; diagnostic criteria<br>
determinations; clinical weighting systems; diagnostic transformations; clinical<br>
transformations; application of expert knowledge; labeling techniques;<br>
application of other domain knowledge; Bayesian network knowledge; etc.<br>
These and other transformations, as well as combinations thereof, will occur to<br>
those of ordinary skill in the art.<br>
Those skilled in the art should also recognize that data<br>
transformations may be performed without adding dimensionality to the data<br>
points. For example a data point may comprise the coordinate (A, B, C). A<br>
transformed version of this data point may result in the coordinates (1,2, 3),<br>
where the coordinate "1" has some known relationship with the coordinate "A,"<br>
the coordinate "2" has some known relationship with the coordinate "B," and the<br>
coordinate "3" has some known "relationship with the coordinate "C." A<br>
transformation from letters to numbers may be required, for example, if letters<br>
are not understood by a learning machine. Other types of transformations are<br>
possible without adding dimensionality to the data points, even with respect to<br>
data that is originally in numeric form. Furthermore, it should be appreciated<br>
that pre-processing data to add meaning thereto may involve analyzing<br>
incomplete, corrupted or otherwise "dirty" data. A learning machine cannot<br>
process "dirty" data in a meaningful manner. Thus, a pre-processing step may<br>
involve cleaning up a data set in order to remove, repair or replace dirty data<br>
points.<br>
Returning to FIG. 1, the exemplary method 100 continues at step<br>
106, where the learning machine is trained using the pre-processed data. As is<br>
known in the art, a learning machine is trained by adjusting its operating<br>
parameters until a desirable training output is achieved. The determination of<br>
whether a training output is desirable may be accomplished either manually or<br>
automatically by comparing the training output to the known characteristics of<br>
the training data. A learning machine is considered to be trained when its<br><br>
training output is within a predetermined error threshold from the known<br>
characteristics of the training data. In certain situations, it may be desirable, if<br>
not necessary, to post-process the training output of the learning machine at step<br>
107. As mentioned, post-processing the output of a learning machine involves<br>
interpreting the output into a meaningful form. In the context of a regression<br>
problem, for example, it may be necessary to determine range categorizations for<br>
the output of a learning machine in order to determine if the input data points<br>
were correctly categorized. In the example of a pattern recognition problem, it is<br>
often not necessary to post-process the training output of a learning machine.<br>
At step 108, test data is optionally collected in preparation for<br>
testing the trained learning machine. Test data may be collected from one or<br>
more local and/or remote sources. In practice, test data and training data may be<br>
collected from the same source(s) at the same time. Thus, test data and training<br>
data sets can be divided out of a common data set and stored in a local storage<br>
medium for use as different input data sets for a learning machine. Regardless of<br>
how the test data is collected, any test data used must be pre-processed at step<br>
110 in the same manner as was the training data. As should be apparent to those<br>
skilled in the art, a proper test of the learning may only be accomplished by using<br>
testing data of the same format as the training data. Then, at step 112 the<br>
learning machine is tested using the pre-processed test data, if any. The test<br>
output of the learning machine is optionally post-processed at step 114 in order to<br>
determine if the results are desirable. Again, the post processing step involves<br>
interpreting the test output into a meaningful form. The meaningful form may be<br>
one that is comprehendible by a human or one that is comprehendible by a<br>
computer. Regardless, the test output must be post-processed into a form which<br>
may be compared to the test data to determine whether the results were desirable.<br>
Examples of post-processing steps include but are not limited of the following:<br>
optimal categorization determinations, scaling techniques (linear and non-linear),<br>
transformations (linear and non-linear), and probability estimations. The method<br>
100 ends at step 116.<br>
FIG. 2 is a flow chart illustrating an exemplary method 200 for<br>
enhancing knowledge that may be discovered from data using a specific type of<br><br>
learning machine known as a support vector machine (SVM). A SVM<br>
implements a specialized algorithm for providing generalization when estimating<br>
a multi-dimensional function from a limited collection of data. A SVM may be<br>
particularly useful in solving dependency estimation problems. More<br>
specifically, a SVM may be used accurately in estimating indicator functions<br>
(e.g. pattern recognition problems) and real-valued functions (e.g. function<br>
approximation problems, regression estimation problems, density estimation<br>
problems, and solving inverse problems). The SMV was originally developed by<br>
Vladimir N. Vapnik. The concepts underlying the SVM are explained in detail in<br>
his book, entitled Statistical Leaning Theory (John Wiley &amp; Sons, Inc. 1998),<br>
which is herein incorporated by reference in its entirety. Accordingly, a<br>
familiarity with SVMs and the terminology used therewith are presumed<br>
throughout this specification.<br>
The exemplary method 200 begins at starting block 201 and<br>
advances to step 202, where a problem is formulated and then to step 203, where<br>
a training data set is collected. As was described with reference to FIG. 1,<br>
training data may be collected from one or more local and/or remote sources,<br>
through a manual or automated process. At step 204 the training data is<br>
optionally pre-processed. Again, pre-processing data comprises enhancing<br>
meaning within the training data by cleaning the data, transforming the data<br>
and/or expanding the data. Those skilled in the art should appreciate that SVMs<br>
are capable of processing input data having extremely large dimensionality. In<br>
fact, the larger the dimensionality of the input data, the better generalizations a<br>
SVM is able to calculate. Therefore, while training data transformations are<br>
possible that do not expand the training data, in the specific context of SVMs it is<br>
preferable that training data be expanded by adding meaningful information<br>
thereto.<br>
At step 206 a kernel is selected for the SVM. As is known in the<br>
art, different kernels will cause a SVM to produce varying degrees of quality in<br>
the output for a given set of input data. Therefore, the selection of an appropriate<br>
kernel may be essential to the desired quality of the output of the SVM. In one<br>
embodiment of the present invention, a kernel may be chosen based on prior<br><br>
performance knowledge. As is known in the art, exemplary kernels include<br>
polynomial kernels, radial basis classifier kernels, linear kernels, etc. In an<br>
alternate embodiment, a customized kernel may be created that is specific to a<br>
particular problem or type of data set. In yet another embodiment, the multiple<br>
SVMs may be trained and tested simultaneously, each using a different kernel.<br>
The quality of the outputs for each simultaneously trained and tested SVM may<br>
be compared using a variety of selectable or weighted metrics (see step 222) to<br>
determine the most desirable kernel.<br>
Next, at step 208 the pre-processed training data is input into the<br>
SVM. At step 210, the SVM is trained using the pre-processed training data to<br>
generate an optimal hyperplane. Optionally, the training output of the SVM may<br>
then be post-processed at step 211. Again, post-processing of training output<br>
may be desirable, or even necessary, at this point in order to properly calculate<br>
ranges or categories for the output. At step 212 test data is collected similarly to<br>
previous descriptions of data collection. The test data is pre-processed at step<br>
214 in the same manner as was the training data above. Then, at step 216 the<br>
pre-processed test data is input into the SVM for processing in order to determine<br>
whether the SVM was trained in a desirable manner. The test output is received<br>
from the SVM at step 218 and is optionally post-processed at step 220.<br>
Based on the post-processed test output, it is determined at step<br>
222 whether an optimal minimum was achieved by the SVM. Those skilled in<br>
the art should appreciate that a SVM is operable to ascertain an output having a<br>
global minimum error. However, as mentioned above output results of a SVM<br>
for a given data set will typically vary in relation to the selection of a kernel.<br>
Therefore, there are in fact multiple global minimums that may be ascertained by<br>
a SVM for a given set of data. As used herein, the term "optimal minimum" or<br>
"optimal solution" refers to a selected global minimum that is considered to be<br>
optimal (e.g. the optimal solution for a given set of problem specific, pre-<br>
established criteria) when compared to other global minimums ascertained by a<br>
SVM. Accordingly, at step 222 determining whether the optimal minimum has<br>
been ascertained may involve comparing the output of a SVM with a historical or<br>
predetermined value. Such a predetermined value may be dependant on the test<br><br>
data set. For example, in the context of a pattern recognition problem where a<br>
data point are classified by a SVM as either having a certain characteristic or not<br>
having the characteristic, a global minimum error of 50% would not be optimal.<br>
In this example, a global minimum of 50% is no better than the result that would<br>
be achieved by flipping a coin to determine whether the data point had the certain<br>
characteristic. As another example, in the case where multiple SVMs are trained<br>
and tested simultaneously with varying kernels, the outputs for each SVM may<br>
be compared with each other SVM's outputs to determine the practical optimal<br>
solution for that particular set of kernels. The determination of whether an<br>
optimal solution has been ascertained may be performed manually or through an<br>
automated comparison process.<br>
If it is determined that the optimal minimum has not been<br>
achieved by the trained SVM, the method advances to step 224, where the kernel<br>
selection is adjusted. Adjustment of the kernel selection may comprise selecting<br>
one or more new kernels or adjusting kernel parameters. Furthermore, in the<br>
case where multiple SVMs were trained and tested simultaneously, selected<br>
kernels may be replaced or modified while other kernels may be re-used for<br>
control purposes. After the kernel selection is adjusted, the method 200 is<br>
repeated from step 208, where the pre-processed training data is input into the<br>
SVM for training purposes. When it is determined at step 222 that the optimal<br>
minimum has been achieved, the method advances to step 226, where live data is<br>
collected similarly as described above. The desired output characteristics that<br>
were known with respect to the training data and the test data are not known with<br>
respect to the live data.<br>
At step 228 the live data is pre-processed in the same manner as<br>
was the training data and the test data. At step 230, the live pre-processed data is<br>
input into the SVM for processing. The live output of the SVM is received at<br>
step 232 and is post-processed at step 234. In one embodiment of the present<br>
invention, post-processing comprises converting the output of the SVM into a<br>
computationally derived alpha-numerical classifier, for interpretation by a human<br>
or computer. Preferably, the alphanumerical classifier comprises a single value<br><br>
that is easily comprehended by the human or computer. The method 200 ends at<br>
step 236.<br>
FIG. 3 is a flow chart illustrating an exemplary optimal<br>
categorization method 300 that may be used for pre-processing data or post-<br>
processing output from a learning machine in accordance with an exemplary<br>
embodiment of the present invention. Additionally, as will be described below,<br>
the exemplary optimal categorization method may be used as a stand-alone<br>
categorization technique, independent from learning machines. The exemplary<br>
optimal categorization method 300 begins at starting block 301 and progresses to<br>
step 302, where an input data set is received. The input data set comprises a<br>
sequence of data samples from a continuous variable. The data samples fall<br>
within two or more classification categories. Next, at step 304 the bin and class-<br>
tracking variables are initialized. As is known in the art, bin variables relate to<br>
resolution and class-tracking variables relate to the number of classifications<br>
within the data set. Determining the values for initialization of the bin and class-<br>
tracking variables may be performed manually or through an automated process,<br>
such as a computer program from analyzing the input data set. At step 306, the<br>
data entropy for each bin is calculated. Entropy is a mathematical quantity that<br>
measures the uncertainty of a random distribution. In the exemplary method 300,<br>
entropy is used to gauge the gradations of the input variable so that maximum<br>
classification capability is achieved.<br>
The method 300 produces a series of "cuts" on the continuous<br>
variable, such that the continuous variable may be divided into discrete<br>
categories. The cuts selected by the exemplary method 300 are optimal in the<br>
sense that the average entropy of each resulting discrete category is minimized.<br>
At step 308, a determination is made as to whether all cuts have been placed<br>
within input data set comprising the continuous variable. If all cuts have not<br>
been placed, sequential bin combinations are tested for cutoff determination at<br>
step 310. From step 310, the exemplary method 300 loops back through step 306<br>
and returns to step 308 where it is again determined whether all cuts have been<br>
placed within input data set comprising the continuous variable. When all cuts<br>
have been placed, the entropy for the entire system is evaluated at step 309 and<br><br>
compared to previous results from testing more or fewer cuts. If it cannot be<br>
concluded that a minimum entropy state has been determined, then other possible<br>
cut selections must be evaluated and the method proceeds to step 311. From step<br>
311 a heretofore untested selection for number of cuts is chosen and the above<br>
process is repeated from step 304. When either the limits of the resolution<br>
determined by the bin width has been tested or the convergence to a minimum<br>
solution has been identified, the optimal classification criteria is output at step<br>
312 and the exemplary optimal categorization method 300 ends at step 314.<br>
The optimal categorization method 300 takes advantage of<br>
dynamic programming techniques. As is known in the art, dynamic<br>
programming techniques may be used to significantly improve the efficiency of<br>
solving certain complex problems through carefully structuring an algorithm to<br>
reduce redundant calculations. In the optimal categorization problem, the<br>
straightforward approach of exhaustively searching through all possible cuts in<br>
the continuous variable data would result in an algorithm of exponential<br>
complexity and would render the problem intractable for even moderate sized<br>
inputs. By taking advantage of the additive property of the target function, in<br>
this problem the average entropy, the problem may be divide into a series of<br>
sub-problems. By properly formulating algorithmic sub-structures for solving<br>
each sub-problem and storing the solutions of the sub-problems, a great amount<br>
of redundant computation may be identified and avoided. As a result of using the<br>
dynamic programming approach, the exemplary optimal categorization method<br>
300 may be implemented as an algorithm having a polynomial complexity,<br>
which may be used to solve large sized problems.<br>
As mentioned above, the exemplary optimal categorization<br>
method 300 may be used in pre-processing data and/or post-processing the output<br>
of a learning machine. For example, as a pre-processing transformation step, the<br>
exemplary optimal categorization method 300 may be used to extract<br>
classification information from raw data. As a post-processing technique, the<br>
exemplary optimal range categorization method may be used to determine the<br>
optimal cut-off values for markers objectively based on data, rather than relying<br>
on ad hoc approaches. As should be apparent, the exemplary optimal<br><br>
categorization method 300 has applications in pattern recognition, classification,<br>
regression problems, etc. The exemplary optimal categorization method 300<br>
may also be used as a stand-alone categorization technique, independent from<br>
SVMs and other learning machines. An exemplary stand-alone application of the<br>
optimal categorization method 300 will be described with reference to FIG. 8.<br>
FIG. 4 illustrates an exemplary unexpanded data set 400 that may<br>
be used as input for a support vector machine. This data set 400 is referred to as<br>
"unexpanded" because no additional information has been added thereto. As<br>
shown, the unexpanded data set comprises a training data set 402 and a test data<br>
set 404. Both the unexpanded training data set 402 and the unexpanded test data<br>
set 404 comprise data points, such as exemplary data point 406, relating to<br>
historical clinical data from sampled medical patients. The data set 400 may be<br>
used to train a SVM to determine whether a breast cancer patient will experience<br>
a recurrence or not.<br>
Each data point includes five input coordinates, or dimensions,<br>
and an output classification shown as 406a-f which represent medical data<br>
collected for each patient. In particular, the first coordinate 406a represents<br>
"Age," the second coordinate 406b represents "Estrogen Receptor Level," the<br>
third coordinate 406c represents "Progesterone Receptor Level," the fourth<br>
coordinate 406d represents "Total Lymph Nodes Extracted," the fifth coordinate<br>
406e represents "Positive (Cancerous) Lymph Nodes Extracted," and the output<br>
classification 406f, represents the "Recurrence Classification." The important<br>
known characteristic of the data 400 is the output classification 406f<br>
(Recurrence Classification), which, in this example, indicates whether the<br>
sampled medical patient responded to treatment favorably without recurrence of<br>
cancer ("-1") or responded to treatment negatively with recurrence of cancer<br>
("1"). This known characteristic will be used for learning while processing the<br>
training data in the SVM, will be used in an evaluative fashion after the test data<br>
is input into the SVM thus creating a "blind" test, and will obviously be unknown<br>
in the live data of current medical patients.<br>
FIG. 5 illustrates an exemplary test output 502 from a SVM<br>
trained with the unexpanded training data set 402 and tested with the unexpanded<br><br>
data set 404 shown in FIG. 4. The test output 502 has been post-processed to be<br>
comprehensible by a human or computer. As indicated, the test output 502<br>
shows that 24 total samples (data points) were examined by the SVM and that the<br>
SVM incorrectly identified four of eight positive samples (50%) and incorrectly<br>
identified 6 of sixteen negative samples (37.5%).<br>
FIG. 6 illustrates an exemplary expanded data set 600 that may be<br>
used as input for a support vector machine. This data set 600 is referred to as<br>
"expanded" because additional information has been added thereto. Note that<br>
aside from the added information, the expanded data set 600 is identical to the<br>
unexpanded data set 400 shown in FIG. 4. The additional information supplied<br>
to the expanded data set has been supplied using the exemplary optimal range<br>
categorization method 300 described with reference to FIG. 3. As shown, the<br>
expanded data set comprises a training data set 602 and a test data set 604. Both<br>
the expanded training data set 602 and the expanded test data set 604 comprise<br>
data points, such as exemplary data point 606, relating to historical data from<br>
sampled medical patients. Again, the data set 600 may be used to train a SVM to<br>
learn whether a breast cancer patient will experience a recurrence of the disease.<br>
Through application of the exemplary optimal categorization<br>
method 300, each expanded data point includes twenty coordinates (or<br>
dimensions) 606al-3 through 606el-3, and an output classification 606f, which<br>
collectively represent medical data and categorization transformations thereof for<br>
each patient. In particular, the first coordinate 606a represents "Age," the second<br>
coordinate through the fourth coordinate 606al - 606a3 are variables that<br>
combine to represent a category of age. For example, a range of ages may be<br>
categorized, for example, into "young" "middle-aged" and "old" categories<br>
respective to the range of ages present in the data. As shown, a string of<br>
variables "0" (606a1), "0" (606a2), "1" (606a3) may be used to indicate that a<br>
certain age value is categorized as "old." Similarly, a string of variables "0"<br>
(606a1), "1" (606a2), "0" (606a3) may be used to indicate that a certain age<br>
value is categorized as "middle-aged." Also, a string of variables "1" (606a1),<br>
"0" (606a2), "0" (606a1) may be used to indicate that a certain age value is<br>
categorized as "young." From an inspection of FIG. 6, it may be seen that the<br><br>
optimal categorization of the range of "Age" 606a values, using the exemplary<br>
method 300, was determined to be 31-33 = "young," 34 = "middle-aged" and 35-<br>
49 = "old." The other coordinates, namely coordinate 606b "Estrogen Receptors<br>
Level," coordinate 606c "Progesterone Receptor Level," coordinate 606d "Total<br>
Lymph Nodes Extracted," and coordinate 606e "Positive (Cancerous) Lymph<br>
Nodes Extracted," have each been optimally categorized in a similar manner.<br>
FIG. 7 illustrates an exemplary expanded test output 702 from a<br>
SVM trained with the expanded training data set 602 and tested with the<br>
expanded data set 604 shown in FIG. 6. The expanded test output 702 has been<br>
post-processed to be comprehensible by a human or computer. As indicated, the<br>
expanded test output 702 shows that 24 total samples (data points) were<br>
examined by the SVM and that the SVM incorrectly identified four of eight<br>
positive samples (50%) and incorrectly identified four of sixteen negative<br>
samples (25%). Accordingly, by comparing this expanded test output 702 with<br>
the unexpanded test output 502 of FIG. 5, it may be seen that the expansion of the<br>
data points leads to improved results (i.e. a lower global minimum error),<br>
specifically a reduced instance of patients who would unnecessarily be subjected<br>
to follow-up cancer treatments.<br>
FIG. 8 illustrates an exemplary input and output for a stand alone<br>
application of the optimal categorization method 300 described in FIG. 3. In the<br>
example of FIG. 8, the input data set 801 comprises a "Number of Positive<br>
Lymph Nodes" 802 and a corresponding "Recurrence Classification" 804. In this<br>
example, the optimal categorization method 300 has been applied to the input<br>
data set 801 in order to locate the optimal cutoff point for determination of<br>
treatment for cancer recurrence, based solely upon the number of positive lymph<br>
nodes collected in a post-surgical tissue sample. The well-known clinical<br>
standard is to prescribe treatment for any patient with at least three positive<br>
nodes. However, the optimal categorization method 300 demonstrates that the<br>
optimal cutoff 806, based upon the input data 801, should be at the higher value<br>
of 5.5 lymph nodes, which corresponds to a clinical rule prescribing follow-up<br>
treatments in patients with at least six positive lymph nodes.<br><br>
As shown in the comparison table 808, the prior art accepted<br>
clinical cutoff point (= 3.0) resulted in 47% correctly classified recurrences and<br>
71% correctly classified non-recurrences. Accordingly, 53% of the recurrences<br>
were incorrectly classified (further treatment was improperly not recommended)<br>
and 29% of the non-recurrences were incorrectly classified (further treatment was<br>
incorrectly recommended). By contrast, the cutoff point determined by the<br>
optimal categorization method 300 (= 5.5) resulted in 33% correctly classified<br>
recurrences and 97% correctly classified non-recurrences. Accordingly, 67% of<br>
the recurrences were incorrectly classified (further treatment was improperly not<br>
recommended) and 3% of the non-recurrences were incorrectly classified (further<br>
treatment was incorrectly recommended).<br>
As shown by this example, it may be feasible to attain a higher<br>
instance of correctly identifying those patients who can avoid the post-surgical<br>
cancer treatment regimes, using the exemplary optimal categorization method<br>
300. Even though the cutoff point determined by the optimal categorization<br>
method 300 yielded a moderately "higher percentage of incorrectly classified<br>
recurrences, it yielded a significantly lower percentage of incorrectly classified<br>
non-recurrences. Thus, considering the trade-off, and realizing that the goal of<br>
the optimization problem was the avoidance of unnecessary treatment, the results<br>
of the cutoff point determined by the optimal categorization method 300 are<br>
mathematically superior to those of the prior art clinical cutoff point. This type<br>
of information is potentially extremely useful in providing additional insight to<br>
patients weighing the choice between undergoing treatments such as<br>
chemotherapy or risking a recurrence of breast cancer.<br>
FIG. 9 is a comparison of exemplary post-processed output from a<br>
first support vector machine comprising a linear kernel and a second support<br>
vector machine comprising a polynomial kernel. FIG. 9 demonstrates that a<br>
variation in the selection of a kernel may affect the level of quality of the output<br>
of a SVM. As shown, the post-processed output of a first SVM 902 comprising a<br>
linear dot product kernel indicates that for a given test set of twenty four sample,<br>
six of eight positive samples were incorrectly identified and three of sixteen<br>
negative samples were incorrectly identified. By way of comparison, the post-<br>
processed output for a second SVM 904 comprising a polynomial kernel<br>
indicates that for the same test set only two of eight positive samples were<br>
incorrectly identified and four of sixteen negative samples were identified. By<br>
way of comparison, the polynomial kernel yielded significantly improved results<br>
pertaining to the identification of positive samples and yielded only slightly<br>
worse results pertaining to the identification of negative samples. Thus, as will<br>
be apparent to those of skill in the art, the global minimum error for the<br>
polynomial kernel is lower than the global minimum error for the linear kernel<br>
for this data set.<br>
FIG. 10 and the following discussion are intended to provide a<br>
brief and general description of a suitable computing environment for<br>
implementing the present invention. Although the system shown in FIG. 10 is a<br>
conventional personal computer 1000, those skilled in the art will recognize that<br>
the invention also may be implemented using other types of computer system<br>
configurations. The computer 1000 includes a central processing unit 1022, a<br>
system memory 1020, and an Input/Output ("I/O") bus 1026. A system bus 1021<br>
couples the central processing unit 1022 to the system memory 1020. A bus<br>
controller 1023 controls the flow of data on the I/O bus 1026 and between the<br>
central processing unit 1022 and a variety of internal and external I/O devices.<br>
The I/O devices connected to the I/O bus 1026 may have direct access to the<br>
system memory 1020 using a Direct Memory Access ("DMA") controller 1024.<br>
The I/O devices are connected to the I/O bus 1026 via a set of<br>
device interfaces. The device interfaces may include both hardware components<br>
and software components. For instance, a hard disk drive 1030 and a floppy disk<br>
drive 1032 for reading or writing removable media 1050 may be connected to the<br>
I/O bus 1026 through disk drive controllers 1040. An optical disk drive 1034 for<br>
reading or writing optical media 1052 may be connected to the I/O bus 1026<br>
using a Small Computer System Interface ("SCSI") 1041. Alternatively, an IDE<br>
(ATAPI) or EIDE interface may be associated with an optical drive such as a<br>
may be the case with a CD-ROM drive. The drives and their associated<br>
computer-readable media provide nonvolatile storage for the computer 1000. In<br><br>
addition to the computer-readable media described above, other types of<br>
computer-readable media may also be used, such as ZIP drives, or the like.<br>
A display device 1053, such as a monitor, is connected to the I/O<br>
bus 1026 via another interface, such as a video adapter 1042. A parallel interface<br>
1043 connects synchronous peripheral devices, such as a laser printer 1056, to the<br>
I/O bus 1026. A serial interface 1044 connects communication devices to the I/O<br>
bus 1026. A user may enter commands and information into the computer 1000<br>
via the serial interface 1044 or by using an input device, such as a keyboard<br>
1038, a mouse 1036 or a modem 1057. Other peripheral devices (not shown)<br>
may also be connected to the computer 1000, such as audio input/output devices<br>
or image capture devices.<br>
A number of program modules may be stored on the drives and in<br>
the system memory 1020. The system memory 1020 can include both Random<br>
Access Memory ("RAM") and Read Only Memory ("ROM"). The program<br>
modules control how the computer 1000 functions and interacts with the user,<br>
with I/O devices or with other computers. Program modules include routines,<br>
operating systems 1065, application programs, data structures, and other software<br>
or firmware components. In an illustrative embodiment, the present invention<br>
may comprise one or more pre-processing program modules 1075A, one or more<br>
post-processing program modules 1075B, and/or one or more optimal<br>
categorization program modules 1077 and one or more SVM program modules<br>
1070 stored on the drives or in the system memory 1020 of the computer 1000.<br>
Specifically, pre-processing program modules 1075A, post-processing program<br>
modules 1075B, together with the SVM program modules 1070 may comprise<br>
computer-executable instructions for pre-processing data and post-processing<br>
output from a learning machine and implementing the learning algorithm<br>
according to the exemplary methods described with reference to FIGS. 1 and 2.<br>
Furthermore, optimal categorization program modules 1077 may comprise<br>
computer-executable instructions for optimally categorizing a data set according<br>
to the exemplary methods described with reference to FIG. 3.<br>
The computer 1000 may operate in a networked environment<br>
using logical connections to one or more remote computers, such as remote<br><br>
computer 1060. The remote computer 1060 may be a server, a router, a peer<br>
device or other common network node, and typically includes many or all of the<br>
elements described in connection with the computer 1000. In a networked<br>
environment, program modules and data may be stored on the remote computer<br>
1060. The logical connections depicted in FIG. 10 include a local area network<br>
("LAN") 1054 and a wide area network ("WAN") 1055. In a LAN environment,<br>
a network interface 1045, such as an Ethernet adapter card, can be used to<br>
connect the computer 1000 to the remote computer 1060. In a WAN<br>
environment, the computer 1000 may use a telecommunications device, such as a<br>
modem 1057, to establish a connection. It will be appreciated that the network<br>
connections shown are illustrative and other devices of establishing a<br>
communications link between the computers may be used.<br>
FIG. 11 is a functional block diagram illustrating an alternate<br>
exemplary operating environment for implementation of the present invention.<br>
The present invention may be implemented in a specialized configuration of<br>
multiple computer systems. An example of a specialized configuration of<br>
multiple computer systems is referred to herein as the BIOWulfTM Support<br>
Vector Processor (BSVP). The BSVP combines the latest advances in parallel<br>
computing hardware technology with the latest mathematical advances in pattern<br>
recognition, regression estimation, and density estimation. While the<br>
combination of these technologies is a unique and novel implementation, the<br>
hardware configuration is based upon Beowulf supercomputer implementations<br>
pioneered by the NASA Goddard Space Flight Center.<br>
The BSVP provides the massively parallel computational power<br>
necessary to expedite SVM training and evaluation on large-scale data sets. The<br>
BSVP includes a dual parallel hardware architecture and custom parallelized<br>
software to enable efficient utilization of both multithreading and message<br>
passing to efficiently identify support vectors in practical applications.<br>
Optimization of both hardware and software enables the BSVP to significantly<br>
outperform typical SVM implementations. Furthermore, as commodity<br>
computing technology progresses the upgradability of the BSVP is ensured by its<br>
foundation in open source software and standardized interfacing technology.<br><br>
Future computing platforms and networking technology can be assimilated into<br>
the BSVP as they become cost effective with no effect on the software<br>
implementation.<br>
As shown in FIG. 11, the BSVP comprises a Beowulf class<br>
supercomputing cluster with twenty processing nodes 1104a-t and one host node<br>
1112. The processing nodes 1104a-j are interconnected via switch 1102a, while<br>
the processing nodes 1104k-t are interconnected via switch 1102b. Host node<br>
1112 is connected to either one of the network switches 1102a or 1102b (1102a<br>
shown) via an appropriate Ethernet cable 1114. Also, switch 1102a and switch<br>
1102b are connected to each other via an appropriate Ethernet cable 1114 so that<br>
all twenty processing nodes 1104a-t and the host node 1112 are effectively in<br>
communication with each other. Switches 1102a and 1102b preferably comprise<br>
Fast Ethernet interconnections. The dual parallel architecture of the BSVP is<br>
accomplished through implementation of the Beowulf supercomputer's message<br>
passing multiple machine parallel configuration and utilizing a high performance<br>
dual processor SMP computer as the host node 1112.<br>
In this exemplary configuration, the host node 1112 contains<br>
glueless multi-processor SMP technology and consists of a dual 450Mhz<br>
Pentium II Xeon based machine with 18GB of Ultra SCSI storage, 256MB<br>
memory, two 100Mbit/sec NIC's, and a 24GB DAT network backup tape device.<br>
The host node 1112 executes NIS, MPL and/or PMV under Linux to manage the<br>
activity of the BSVP. The host node 1112 also provides the gateway between the<br>
BSVP and the outside world. As such, the internal network of the BSVP is<br>
isolated from outside interaction, which allows the entire cluster to appear to<br>
function as a single machine.<br>
The twenty processing nodes 1104a-t are identically configured<br>
computers containing 150MHz Pentium processors, 32MB RAM, 850MB HDD,<br>
1.44MB FDD, and a Fast Ethernet mb100Mb/s NIC. The processing nodes<br>
1104a-t are interconnected with each other and the host node through NFS<br>
connections over TCP/IP. In addition to BSVP computations, the processing<br>
nodes are configured to provide demonstration capabilities through an attached<br>
bank of monitors with each node's keyboard and mouse routed to a single<br><br>
keyboard device and a single mouse device through the KVM switches<br>
1108a. and 1108b.<br>
Software customization and development allow optimization of<br>
activities on the BSVP. Concurrency in sections of SVM processes is exploited<br>
in the most advantageous manner through the hybrid parallelization provided by<br>
the BSVP hardware. The software implements full cycle support from raw data<br>
to implemented solution. A database engine provides the storage and flexibility<br>
required for pre-processing raw data. Custom developed routines automate the<br>
pre-processing of the data prior to SVM training. Multiple transformations and<br>
data manipulations are performed within the database environment to generate<br>
candidate training data.<br>
The peak theoretical processing capability of the BSVP is<br>
3.90GFLOPS. Based upon the benchmarks performed by NASA Goddard Space<br>
Flight Center on their Beowulf class machines, the expected actual performance<br>
should be about 1.56GFLOPS. Thus the performance attained using commodity<br>
component computing power in this'Beowulf class cluster machine is in line with<br>
that of supercomputers such as the Cray J932/8. Further Beowulf testing at<br>
research and academic institutions indicates that a performance on the order of<br>
18 times a single processor can generally be attained on a twenty node Beowulf<br>
cluster. For example, an optimization problem requiring 17 minutes and 45<br>
seconds of clock time on a single Pentium processor computer was solved in 59<br>
seconds on a Beowulf with 20 nodes. Therefore, the high performance nature of<br>
the BSVP enables practical analysis of data sets currently considered too<br>
cumbersome to handle by conventional computer systems.<br>
The massive computing power of the BSVP renders it particularly<br>
useful for implementing multiple SVMs in parallel to solve real-life problems<br>
that involve a vast number of inputs. Examples of the usefulness of SVMs in<br>
general and the BSVP in particular comprise: genetic research, in particular the<br>
Human Genome Project; evaluation of managed care efficiency; therapeutic<br>
decisions and follow up; appropriate therapeutic triage; pharmaceutical<br>
development techniques; discovery of molecular structures; prognostic<br>
evaluations; medical informatics; billing fraud detection; inventory control; stock<br><br>
evaluations and predictions; commodity evaluations and predictions; and<br>
insurance probability estimates.<br>
Those skilled in the art should appreciate that the BSVP<br>
architecture described above is illustrative in nature and is not meant to limit the<br>
scope of the present invention. For example, the choice of twenty processing<br>
nodes was based on the well known Beowulf architecture. However, the BSVP<br>
may alternately be implemented using more or less than twenty processing<br>
nodes. Furthermore the specific hardware and software components recited<br>
above are by way of example only. As mentioned, the BSVP embodiment of the<br>
present invention is configured to be compatible with alternate and/or future<br>
hardware and software components.<br>
FIG. 12 is a functional block diagram illustrating an exemplary<br>
network operating environment for implementation of a further alternate<br>
embodiment of the present invention. In the exemplary network operating<br>
environment, a customer 1202 or other entity may transmit data via a distributed<br>
computer network, such as the Internet 1204, to a vendor 1212. Those skilled in<br>
the art should appreciate that the customer 1202 may transmit data from any type<br>
of computer or lab instrument that includes or is in communication with a<br>
communications device and a data storage device. The data transmitted from the<br>
customer 1202 may be training data, test data and/or live data to be processed by<br>
a learning machine. The data transmitted by the customer is received at the<br>
vendor's web server 1206, which may transmit the data to one or more learning<br>
machines via an internal network 1214a-b. As previously described, learning<br>
machines may comprise SVMs, BSVPs 1100, neural networks, other learning<br>
machines or combinations thereof. Preferable, the web server 1206 is isolated<br>
from the learning machine(s) by way of a firewall 1208 or other security system.<br>
The vendor 1212 may also be in communication with one or more financial<br>
institutions 1210, via the Internet 1204 or any dedicated or on-demand<br>
communications link. The web server 1206 or other communications device may<br>
handle communications with the one or more financial institutions. The financial<br>
institution(s) may comprise banks, Internet banks, clearing houses, credit or debit<br>
card companies, or the like.<br><br>
In operation, the vendor may offer learning machine processing<br>
services via a web-site hosted at the web-server 1206 or another server in<br>
communication with the web-server 1206. A customer 1202 may transmit data to<br>
the web server 1206 to be processed by a learning machine. The customer 1202<br>
may also transmit identification information, such as a username, a password<br>
and/or a financial account identifier, to the web-server. In response to receiving<br>
the data and the identification information, the web server 1206 may<br>
electronically withdraw a pre-determined amount of funds from a financial<br>
account maintained or authorized by the customer 1202 at a financial institution<br>
1210. In addition, the web server may transmit the customer's data to the BSVP<br>
1100 or other learning machine. When the BSVP 1100 has completed processing<br>
of the data and post-processing of the output, the post-processed output is<br>
returned to the web-server 1206. As previously described, the output from a<br>
learning machine may be post-processed in order to generate a single-valued or<br>
multi-valued, computationally derived alpha-numerical classifier, for human or<br>
automated interpretation. The web server 1206 may then ensure that payment<br>
from the customer has been secured before the post-processed output is<br>
transmitted back to the customer 1202 via the Internet 1204.<br>
SVMs may be used to solve a wide variety of real-life problems.<br>
For example, SVMs may have applicability in analyzing accounting and<br>
inventory data, stock and commodity market data, insurance data, medical data,<br>
etc. As such, the above-described network environment has wide applicability<br>
across many industries and market segments. In the context of inventory data<br>
analysis, for example, a customer may be a retailer. The retailer may supply<br>
inventory and audit data to the web server 1206 at predetermined times. The<br>
inventory and audit data may be processed by the BSVP and/or one or more<br>
other learning machine in order to evaluate the inventory requirements of the<br>
retailer. Similarly, in the context of medical data analysis, the customer may be a<br>
medical laboratory and may transmit live data collected from a patient to the web<br>
server 1206 while the patient is present in the medical laboratory. The output<br>
generated by processing the medical data with the BSVP or other learning<br><br>
machine may be transmitted back to the medical laboratory and presented to the<br>
patient.<br>
In another embodiment, the present invention contemplates that a<br>
plurality of support vector machines may be configured to hierarchically process<br>
multiple data sets in parallel or in sequence. In particular, one or more first-level<br>
support vector machines may be trained and tested to process a first type of data<br>
and one or more first-level support vector machines may be trained and tested to<br>
process a second type of data. Additional types of data may be processed by<br>
other first-level support vector machines as well. The output from some or all of<br>
the first-level support vector machines may be combined in a logical manner so<br>
as to produce an input data set for one or more second-level support vector<br>
machines. In a similar fashion, output from a plurality of second-level support<br>
vector machines may be combined in a logical manner to produce input data for<br>
one or more third-level support vector machine. The hierarchy of support vector<br>
machines may be expanded to any number of levels as may be appropriate. In<br>
this manner, lower hierarchical level support vector machines may be used to<br>
pre-process data that is to be input into higher hierarchical level support vector<br>
machines. Also, higher hierarchical level support vector machines may be used<br>
to post-process data that is output from lower hierarchical level support vector<br>
machines.<br>
Each support vector machine in the hierarchy or each hierarchical<br>
level of support vector machines may be configured with a distinct kernel. For<br>
example, support vector machines used to process a first type of data may be<br>
configured with a first type of kernel, whereas support vector machines used to<br>
process a second type of data may be configured with a second type of kernel. In<br>
addition, multiple support vector machines in the same or different hierarchical<br>
level may be configured to process the same type of data using distinct kernels.<br>
FIG. 13 is presented by way of example only to illustrate a<br>
hierarchical system of support vector machines. As shown, one or more first-<br>
level support vector machines 1302A1 and 1302A2 may be trained and tested to<br>
process a first type of input data 1304A, such as mamography data, pertaining to<br>
a sample of medical patients. One or more of these support vector machines may<br><br>
comprise a distinct kernel (shown as kernel 1 and kernel 2). Also one or more<br>
additional first-level support vector machines 1302B1 and 1302B2 may be<br>
trained and tested to process a second type of data 1304B, such as genomic data,<br>
for the same or a different sample of medical patients. Again one or more of the<br>
additional support vector machines may comprise a distinct kernel (shown as<br>
kernel 1 and kernel 3). The output from each of the like first level support vector<br>
machines may be compared with each other (i.e., output A1 1306A compared<br>
with output A2 1306B; output B1 1306C compared with output B2 1306D) in<br>
order to determine optimal outputs (1308A and 1308B). Then, the optimal<br>
outputs from the two types of first-level support vector machines 1308A and<br>
1308B may be combined to form a new multi-dimensional input data set 1310,<br>
for example relating to mamography and genomic data. The new data set may<br>
then be processed by one or more appropriately trained and tested second-level<br>
support vector machines 1312A and 1312B. The resulting outputs 1314A and<br>
1314B from the second-level support vector machines 1312A and 1312B may be<br>
compared to determine an optimal output 1316. The optimal output 1316 may<br>
identify causal relationships between the mamography and genomic data points.<br>
As should be apparent to those of ordinary skill in the art, the contemplated<br>
hierarchy of support vector machines may have applications in any field or<br>
industry in which analysis of data by a learning machine is desired.<br>
The hierarchical processing of multiple data sets using multiple<br>
support vector machines may be used as a method for pre-processing or post-<br>
processing data that is to be input to or output from still other support vector<br>
machines or learning machines. In addition, pre-processing or post-processing of<br>
data may be performed to the input data and/or output of the above-described<br>
hierarchical architecture of support vector machines.<br>
Alternative embodiments of the present invention will become<br>
apparent to those having ordinary skill in the art to which the present invention<br>
pertains. Such alternate embodiments are considered to be encompassed within<br>
the spirit and scope of the present invention. Accordingly, the scope of the<br>
present invention is described by the appended claims and is supported by the<br>
foregoing description.<br><br>
We Claim<br>
--------------<br>
1. A computer - implemented method for processing multiple data sets using<br>
multiple support vector machines comprising:<br>
receiving a training input (103; 203) comprising a plurality of<br>
training data sets containing a plurality of training data points of<br>
different data types;<br>
pre-processing (104; 204) each of a first training data set<br>
comprising a first data type and a second training data set<br>
comprising a second data type to add dimensionality to each of the<br>
training data points within the first and second training data sets;<br>
training (105; 210) a first one or more first - level support<br>
vector machines (1302A; 1302B) using the first pre-processed<br>
training data set (1304A), each first one or more first - level<br>
support vector machines comprising a first distinct kernel;<br>
training (105; 210) a second one or more first - level<br>
support vector machines (1302C; 1302D) using the second pre-<br>
processed training data set (1304B), each second one or more first<br>
- level support vector machine comprising a second distinct kernel;<br>
receiving test input (108; 212) comprising a plurality of test<br>
data sets containing a plurality of test data points of the different<br>
data types;<br>
pre-processing (110; 214) each of a first data set comprising<br>
the first data type and a second test data set comprising the<br>
second data type to add dimensionality to each of the test data<br>
points within the first and second test data sets;<br>
testing (112; 218; 220) the trained first level support vector<br>
machines using the pre-processed first and second test data sets to<br>
generate one or more first and second test outputs (1306A, 1306B,<br>
1306C, 13060);<br>
identifying (222) a first optimal solution (1308A), if any,<br>
from the one or more first test outputs;<br>
identifying (222) a second optimal solution (13088), if any,<br>
from the one or more second test outputs;<br>
combining the first optimal solution with the second optimal<br>
solution to create a second - level input data set (1310) to be input<br>
into one or more second - level support vector machines (1312A,<br>
1312B);<br>
generating a second - level output (1314A, 1314B) for each<br>
one or more second - level support vector machine; and<br>
identifying an optimal second-level solution (1316).<br>
2. The method as claimed in claim 1, wherein each pre-processing step<br>
comprises:<br>
determining that at least one of the data points is dirty; and<br>
in response to determining that the data point is dirty,<br>
cleaning the dirty data point by deleting, repairing or replacing the<br>
data point.<br>
3. The method as claimed in either claim 1 or claim 2, comprising the steps<br>
of: receiving live input comprising one or more live data sets containing a<br>
plurality of live data points of the different data types;<br>
pre-processing the plurality of live data sets to add<br>
dimensionality to each live data point;<br>
processing the pre-processed plurality of live data sets using<br>
the first - level support vector machines that produced the first and<br>
second optimal solutions and the second - level support vector<br>
machine that produced the optimal second - level solution.<br>
4. The method as claimed in any one of claims 1 to 3, wherein each training<br>
data point comprises a vector having at least one original coordinate; and<br>
wherein pre - processing the training data set comprises adding at<br>
least one new coordinate to the vector.<br>
5. The method as claimed in claim 4, wherein the at least one new<br>
coordinate is derived by applying a transformation to the at least one<br>
original coordinate.<br>
6. The method as claimed in any one of claims 4 to 5, wherein the training<br>
data set comprises a continuous variable; and wherein the transformation<br>
comprises optimally categorizing the continuous variable of the training<br>
data set<br>
7. The method as claimed in any one of claims 5 to 7, wherein the step of<br>
identifying a first optimal solution comprises:<br>
post - processing each of the first test outputs by<br>
interpreting the one or more first test outputs into a common<br>
format; and<br>
comparing each of the post - processed first test outputs<br>
with each other to determine which of the one or more first test<br>
outputs represents a first lowest global minimum error.<br>
8. The method as claimed in any one of claims 1 to 7, wherein the step of<br>
identifying a second optimal solution comprises:<br>
post - processing each of the one or more second test<br>
outputs by interpreting each of the second test outputs into a<br>
common format; and<br>
comparing each of the post - processed second test outputs<br>
with each other to determine which of the one or more second test<br>
outputs represents a second lowest global minimum error.<br>
9. The method as claimed in any one of claims 1 to 7, wherein each first -<br>
level support vector machine produces a training output comprising a<br>
continuous variable; and<br>
wherein the method comprises the step of post - processing<br>
each of the training outputs by optimally categorizing the training<br>
output to derive cutoff points in the continuous variable.<br>
10.The method as claimed in any one of claims 5 to 9, comprising the steps<br>
of:<br>
if no first optimal solution is identified, selecting different<br>
kernels for the first one or more first - level support vector<br>
machines;<br>
repeating the steps of training and testing the first one or<br>
more first - level support vector machines; and<br>
identifying the first optimal solution, if any, from the first<br>
one or more test outputs.<br>
11. The method as claimed in any one of claims 5 to 9, comprising the steps<br>
of:<br>
if no second optimal solution is identified, selecting different<br>
kernels for the second one or more first - level support vector<br>
machines;<br>
repeating the steps of training and testing the second one or<br>
more first - level support vector machines; and<br>
identifying the second optimal solution, if any, from the<br>
second one or more test outputs.<br>
12.The method as claimed in either of claim 10 or claim 11, wherein the step<br>
of selecting different kernels is performed based on prior performance or<br>
historical data and is dependent on the nature of the data.<br>
13. A computer system for processing multiple data sets containing a plurality<br>
of data types, the computer system comprising a processor (1022); an<br>
input device for receiving input data to be processed (1026); a memory<br>
device (1020) in communication with the processor having a plurality of<br>
program modules stored therein, the plurality of program modules<br>
comprising a pre - processing module (1075A) for adding dimensionality<br>
to input data and a support vector module; and an output device,<br>
characterized in that:<br>
the support vector module (1075B) executes a plurality of<br>
first - level support vector machines (1302A, 1302B, 1302C,<br>
1302D) and one or more second - level support vector machines<br>
(1312A, 1312B) wherein the plurality of first - level support vector<br>
machines comprises at least a first one or more first - level support<br>
vector machine (1302A, 1302B) and a second one or more first -<br>
level support vector machine (1302C, 1302D), each comprising one<br>
or more distinct kernels, wherein the first one or more first - level<br>
support vector machines are trained and tested using pre-<br>
processed data of a first data type (1304A) to generate one or<br>
more first outputs (1306A, 1306B) for identifying a first optimal<br>
solution (1308A), and the second one or more first - level support<br>
vector machines are trained using pre-processed data of a second<br>
data type (1304B) to generate one or more second outputs (1306C,<br>
1306D) to identify a second optimal solution (13088), and wherein<br>
the first and second optimal solutions are combined as a second -<br>
level input (1310) to the one or more second - level support vector<br>
machines (1312A, 1312B); and<br>
the output device generates a second - level output (1314A,<br>
1314B) comprising an optimal second - level solution (1316)<br>
generated by the one or more second - level support vector<br>
machines.<br>
14.The computer system as claimed in claim 13, wherein the plurality of<br>
program modules comprises a post - processing module (1075B) for<br>
interpreting one or more first test outputs from the first one or more first<br>
- level support vector machines into a common format and identifying a<br>
first lowest global minimum error.<br>
15.The computer system as claimed in claim 13, wherein the plurality of<br>
program modules comprises a post - processing module (1075B) for<br>
interpreting one or more second test outputs from the second one or<br>
more first - level support vector machines into a common format and<br>
identifying a second lowest global minimum error.<br>
16.The computer system as claimed in claim 13, wherein the one of more<br>
first outputs comprise a continuous variable and the plurality of program<br>
modules comprises an optimal categorization module (1077) for deriving<br>
cut - off points in the continuous variable.<br>
17.The computer system as claimed in claim 13, wherein the one of more<br>
second outputs comprise a continuous variable and the plurality of<br>
program modules comprises an optimal categorization module (1077) for<br>
deriving cut - off points in the continuous variable.<br>
A system and method for enhancing knowledge discovery from data using<br>
multiple learning machines in general and multiple support vector machines in<br>
particular. Training data for a learning machine is pre - processed (103, 203), in<br>
order to add meaning thereto. Pre - processing data may involve transforming<br>
the data points and/or expanding the data points. By adding meaning to the<br>
data, the learning machine is provided with a greater amount of information for<br>
processing. With regard to support vector machines in particular, the greater the<br>
amount of information that is processed, the better generalizations about the<br>
data that may be derived. Multiple support vector machines, each comprising<br>
distinct kernels, are trained with the pre-processed training data and are tested<br>
(112, 218, 220) with test data that is pre - processed (110, 214) in the same<br>
manner. The test outputs from multiple support vector machines are compared<br>
(222,1312) in order to determine which of the test outputs if any represents an<br>
optimal solution. Selection of one or more kernels may be adjusted and one or<br>
more support vector machines may be retrained and retested. Optimal solutions<br>
based on distinct input data sets may be combined to form a new input data set<br>
to be input into one or more additional support vector machine.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1hc3NpZ25tZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1jb3JyZXNwb25kZW5jZS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1leGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1mb3JtIDEucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1mb3JtIDE4LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1mb3JtIDIucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-form 2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1mb3JtIDI2LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1mb3JtIDMucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1mb3JtIDUucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1mb3JtIDYucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-form 6.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1yZXBseSB0byBleGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC1zcGVjaWZpY2F0aW9uLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-specification.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMTIzOS1rb2wtZ3JhbnRlZC10cmFuc2xhdGVkIGNvcHkgb2YgcHJpb3JpdHkgZG9jdW1lbnQucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-1239-kol-granted-translated copy of priority document.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="223408-substituted-3-pyridyl-4-arylpyrroles-and-related-therapeutic-and-prophylactic-methods.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="223410-system-for-purchasing-goods-services-and-content-using-a-virtual-payment-account.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>223409</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2001/1239/KOL</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>37/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>12-Sep-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>10-Sep-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>23-Nov-2001</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>HEALTH DISCOVERY CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5501, 1/2 ABERCORN STREET, SAVANNAH, GEORGIA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>STEPHEN D BARNHILL</td>
											<td>19 MAD TURKEY CROSSLING, SAVANNAH, GA 31411</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06N</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US00/14326</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-05-24</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/135715</td>
									<td>1999-05-25</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/223409-a-computer-implemented-method-and-system-for-processing-multiple-data-sets by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:57:26 GMT -->
</html>
