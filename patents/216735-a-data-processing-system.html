<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/216735-a-data-processing-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:58:34 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 216735:&quot;A DATA PROCESSING SYSTEM&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;A DATA PROCESSING SYSTEM&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Systems, methods and computer program products automatically order database transaction by an object-oriented transaction system. The objects in the completed transaction are clustered into groups of objects to be inserted into the relational database, objects to be deleted from the relational database and objects to be updated in the relational database. The objects to be inserted into the relational database are ordered according to an insert precedence of the objects into the relational database to thereby define an insert order. The objects to be deleted from the relational database are ordered according to a delete precedence of the objects from the relational database are ordered according to a delete precedence of the objects from the relational database to thereby define a delete order. The objects to be inserted into the relational database are inserted into the relational database in the insert order. Then, the objects to be updated in the relational database are updated in an arbitrary order. Finally, the objects to be deleted from the relational database are deleted from the relational database in the delete order.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>Field of the Invention<br>
This invention relates to data processing systems, methods and computer -program products and more particularly to data pasc systoms, methods and computer-program products.<br>
Background of the Invention<br>
Relational databases are widely used to store data in data processing environments. As is well known to those having skill in the art, in a relational database, data is addressed based on its relationship to other data rather than its actual location in the database. The relationships among data in the relational database may be indicated using relationship keys. For example, each data element of an owner class may have a primary key associated therewith, and each data element of a member class may include a foreign key that points to the primary key of the data element that owns the member element. The design and operation of relational databases are well known to those having skill in the art and need not be described in detail herein.<br>
Object-oriented programming systems, methods and computer program products are also widely used in data processing environments. As is well known to those having skill in the art, object-oriented programming systems, methods and computer program products are composed of a large number of "objects". An object is a data structure, and a set of operations or functions that can access the data structure. Objects having identical data structures and common behavior can be grouped together into, and collectively identified as, a class, in an object-oriented computing environment, the data is processed by requesting an object to perform one of its methods. Inheritance relationships also may exist between two or more classes such<br>
that a first class may be considered a parent of a second class and the second class may be considered a child of the first class. The data structure of the child class includes all of the attributes of the parent class. The design and operation of object- oriented programming systems, methods and computer program products are well known to those having skill in the art and need not be described in detail herein.<br>
Object-oriented computing environments are now being used to form object-oriented transaction systems that can be flexible and user-friendly. As is well known to those having skill in the art, a transaction generally refers to a logical group exchanges to one or more objects that are performed in an atomic manner. In other words, either all operations within the transaction are performed, or none of them are performed. By using a transactional approach, all changes to an object by a user within the scope of a transaction are made first to an internal copy of the object, without actually updating the persistent, stored object itself. The user may eventually decide whether to permanently commit the changes encompassed by the transaction, or whether to discard them. If the user chooses to commit, then the objects in persistent storage are updated. If the user chooses to discard the changes, the persistent storage is left unchanged.<br>
Object-oriented transaction systems may be used in enterprise applications that reflect complex business processes, so that users can navigate freely between different elements of the user interface. For example, the user may wish to have multiple windows for one application open on a display at the same time. Users of such applications may expect that they can switch from processing information in one window to processing information in a different window without having to take special precautions to ensure consistency of the data between the different windows.<br>
Relational databases generally include referential integrity constraints for maintaining consistency of the database. These constraints generally require database store and delete operations to be executed in a specific order. Unfortunately, this order<br>
may not match the order in which objects are created, modified or deleted within an object-oriented transaction. Moreover, the database referential integrity constraints generally do not map to the logical object relationships in a consistent manner. Referential integrity constraints generally are enforced based on the key information, such as which entity is referring and which entity is being referred to with a relational foreign key. This key information may have more than one possible transformation when mapped to object relationships. Therefore, it may be difficult to deduce an ordei in which trees of objects need to be stored to or deleted from the relational database, based upon the application event flow or the object relationship logical directions. Accordingly, it may be difficult to interface an object-oriented transaction system to a relational database such that database operations are properly ordered or sequenced upon completion of a transaction by the object-oriented transaction system. In order to interface an object-oriented transaction system to a relational database, while maintaining the relational database referential integrity constraints, customized coding of operation ordering may be provided in the object-oriented transaction system. However, such custom coding may be time-consuming and may consume up to 30% or more of a project's resources. See the publication entitled "Scalable Object-Persistence Frameworks ", Journal of Object-Oriented Programming, Nov./Dec. 1998, pages 18-24 by the present inventors and Hill. Alternatively, referential integrity constraint enforcement may be disabled in the relational database. Unfortunately, if the referential integrity constraints are disabled in the relational database, the entire relational database may become corrupted and internally inconsistent.<br>
Summary of the Invention<br>
It is therefore an object of the present invention/to provide systems, methods and computer program products that can interface an object-oriented transaction system with a relational database.<br>
It is another object of the present invention to provide systems, methods and computer program products that can interface an object-oriented transaction system with a relational database while preserving the relational database referential integrity constraints.<br>
These and other objects are provided, according to the present invention by systems, methods and computer program products that automatically order objects corresponding to database operations that are performed on a relational database upon completion of a transaction by an object-oriented transaction system. The objects in the completed transaction are clustered into groups of objects to be inserted into the relational database, objects to be deleted from the relational database and objects to be updated in the relational database. The objects to be inserted into the relational database are ordered according to an insert precedence of the objects into the relational database to thereby define an insert order. The objects to be deleted from the relational database are ordered according to a delete precedence of the objects from the relational database to thereby define a delete order. The objects to be inserted into the relational database are inserted into the relational database in the insert order. Then, the objects to be updated in the relational database are updated in an arbitrary order. Finally, the objects to be deleted from the relational database are deleted from the relational database in the delete order.<br>
The precedences between different database operations form complex prerequisite trees. However, it has been found according to the present invention, that these prerequisites need not be completely resolved in order to be able to determine the correct order for operation execution. Rather, the prerequisites need only be resolved among the insert operations and among the delete operations, but not across different operation types. The operations can then be executed in three phases: first the insert operations, then the update operations and last, the delete operations.<br>
According to another aspect of the present invention, the same operations may be used to resolve the precedences for insert and update operations. For example, to order the objects to be deleted from the relational database, associations among the objects to be deleted are identified. A current object to be deleted is defined and it is determined if the current object to be deleted has delete precedence over an associated object to be deleted. The current object to be deleted is ordered ahead of the associated object to be deleted if the current object to be deleted has delete precedence over the associated object to be deleted. The current object to be deleted is deleted behind the associated object to be deleted if the current object to be deleted does not have delete precedence over the associated object to be deleted. These operations may be repeatedly performed for remaining objects associated with the current object to be deleted. These operations also may be recursively performed for each object that is associated with the current object to be deleted that is ordered ahead of the associated object to be deleted.<br>
Associations among the objects to be deleted may be identified by identifying current and associated objects in the objects to be deleted, identifying foreign keys and primary keys in the objects to be deleted and identifying constraints in the relational database between pairs of foreign keys and primary keys. Delete precedence may be determined by determining if a foreign key of the current object to be deleted refers to a primary key of an associated object to be deleted. If there is a constraint identified between the foreign key of the current object to be deleted and the primary key of the associated object to be deleted, then the current object to be deleted has delete precedence over the associated object to be deleted. In contrast, if no constraints are identified between the foreign key of the current object to be deleted and the primary key of the associated object to be deleted, then the current object to be deleted does not have delete precedence over the associated object to be deleted. The same operations may be performed for objects to be inserted.<br>
Upon completion of these operations, the order of insert and delete operations to be performed on the relational database automatically corresponds to the referential integrity constraints for the relational database. Accordingly, upon completion of a transaction by an object-oriented transaction system, database operations are automatically performed on a relational database in an order that will maintain the relational database referential integrity constraints. Custom coding of operation ordering for each specific application need not be provided, and the database need not be corrupted by the sequence of operations that were performed by the object-oriented transaction system during a transaction.<br>
Brief Description of theDrawings<br>
Figure 1 is a block diagram of systems, methods and computer program products for ordering database operations that are performed on a relational database upon completion of a transaction by an object-oriented transaction system according to the invention.<br>
Figure 2 illustrates relationships in a relational database.<br>
Figure 3 illustrates logical object associations in an object-oriented transaction.<br>
Figures 4-8 are flowcharts illustrating database operation ordering according to the present invention.<br>
Figure 9 illustrates lists of objects according to the present invention.<br>
Figure 10 illustrates example associations for the object-oriented transaction of Figure 3.<br>
Detailed Description of Preferred Embodiments<br>
The present invention now will be described more fully hereinafter with reference to the accompanying drawings, in which preferred embodiments of the invention are shown. This invention may, however, be embodied in many different forms and should not be construed as limited to the embodiments set forth herein; rather, these embodiments are provided so that this disclosure will be thorough and complete, and will fully convey the scope of the invention to those skilled in the art. Like numbers refer to like elements throughout.<br>
Referring now to Figure 1, systems, methods and computer program products for ordering database operations that are performed on a relational database upon completion of a transaction by an object-oriented transaction system according to the invention are illustrated. As shown in Figure 1, a relational database system 100 includes a relational database 110. The relational database system 100 may include one or more mainframe, midrange and/or personal computers and the relational database 110 may be a single relational database or multiple relational databases that reside on one or more data processors. Example relational databases include the DB2 and SQL computer program products of IBM Corp., the assignee of the present invention.<br>
Still referring to Figure 1, an object-oriented transaction system 120 also can execute on one or more data processing systems including one or more mainframe, midrange and/or personal computers. The object-oriented transaction system 120 includes a transaction processing system 130 that is used by one or more users to perform a transaction. The transaction processing system 130 may include appropriate user interfaces such as graphical user interfaces, to allow flexible transactions to be<br>
performed. The design of an object-oriented transaction processing system 130 is well known to those having skill in the art and need not be described further herein.<br>
As also shown in Figure 1, the transaction processing system 130 interfaces with the relational database system 100 over an interface 140. Since the relational database system 100 and the transaction processing system 130 may execute on different, overlapping or the same data processing system(s), the communication network 140 may include wired and wireless communication networks, local area networks, the Internet, buses that connect two or more computers, application interfaces that connect two or more applications in a single computer and combinations thereof.<br>
Still referring to Figure 1, the object-oriented transaction system 120 also includes a database operation ordering system, method and/or computer program product 150. Database operation ordering 150 orders database operations that are performed on the relational database 110 upon completion of a transaction by the object-oriented transaction processing system 130. It will be understood that database operation ordering 150 may reside on one or more mainframe, midrange and/or personal computers that are different, overlapping or the same as the transaction processing system 130 and the relational database system 100. Database operation ordering 150 communicates with the relational database 110 using a second interface 160. The second interface 160 may be different, overlapping or the same interface as the first interface 140 and may include wired and wireless communication networks, local area networks, the Internet, buses that connect two or more data processors, application interfaces and combinations thereof.<br>
The database operation ordering 150 may be embodied as methods, systems (apparatus) and/or computer program products. Accordingly, the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment or an embodiment combining software and hardware aspects. Furthermore, the present invention may take the form of a computer program product on a computer-readable storage medium having computer-readable program code means embodied in the medium. Any suitable computer readable medium may be utilized including hard disks, CD-ROMs, optical storage devices, or magnetic storage devices.<br>
Figure 2 illustrates relationships in a conventional relational database. For ease of illustration, the relational database is assumed to include three tables denoted Table A, Table B and Table C. Moreover, in order to provide a specific example, it will be assumed that Table A includes a listing of departments in an organization, Table B includes a list of employees in an organization and Table C includes a list of employee addresses in an organization. It will be understood that relational databases may be represented using techniques other than tables. It will also be understood that relational databases generally include many more tables and data entries than are illustrated in Figure 2.<br>
As shown in Figure 2, the department Table A includes departments dl-dn. The employee Table B includes employees el-en, and the address Table C includes addresses al-an. The relationship between department Table A to employee Table B is an "owner-member" relationship. Since the relationship between departments and employees is one to many, the department Table A includes a primary key and the employee Table B includes a foreign key that refers to the appropriate primary key of department Table A. Stated differently, the relationship between Table A and Table B is owner to member so that the foreign key in the member table refers to the appropriate primary key in the owner table. In contrast, the relationship between employee Table B and address Table C is one to one so that the relationship may be defined using a foreign key in the employee Table B that refers to the address Table C as shown by a solid arrow, or a foreign key in the address Table C that refers to the employee Table B as shown by the dotted arrow.<br>
Relational databases generally include referential integrity constraints for maintaining the consistency of the database. These constraints generally require database store and delete operations to be executed in a specific order or sequence. For example, a referential constraint for Figure 2 might be that an employee cannot be added unless the employee's department is already present. Conversely, a department cannot be deleted until all its employees have been deleted or updated to refer to another department.<br>
Unfortunately, these orders of operations do not necessarily match to the order in which objects are created or deleted within an object-oriented transaction processing system 130. For example, referring to Figure 3, an object-oriented transaction processing<br>
system may include a transaction object that refers to a department object that refers to a collection object that refers to a group of employee objects, all of which are affected during a transaction. Comparing Figure 3 to Figure 2, the objects, pointers and directions of pointers generally are different.<br><br>
The database referential integrity constraints do not generally map to the logical parent-child object relationships in a consistent manner, because referential integrity rules are generally enforced based on the key information and not based on logical relationships. For example, association pointing from employee to address may be implemented in the database as a foreign key reference from employee to address or from address to employee. Furthermore, the relationships between objects generally are independent of the order in which the objects are stored to or deleted from the database. Therefore, the order in which trees of objects need to be stored to or deleted from the relational database generally cannot be deduced either from the event flow in the transaction processing system 130, or from the object relationship logical directions.<br>
Accordingly, at the end of an object-oriented transaction by transaction processing system 130, the objects generally are known, the operations that were performed are generally known and the data that results is generally known. However, the order or sequence in which changes should be made to the relational database 110 in order to preserve the referential integrity constraints are not known. There are generally three kinds of relational operations that can be performed on persistent objects: insert, update and delete. The dependency between these operation types are generally as follows:<br>
(1)       Insert operations can be dependent on other inserts, but not on any other<br>
kind of operations. For example, data to be inserted can refer to other<br>
data to be inserted.<br>
(2)	Update operations are not dependent upon other updates, but they can be<br>
dependent on inserts. For example, data is to be updated to refer to data to be inserted.<br>
(3)	Delete operations can be dependent upon other deletes. For example, data to be<br>
deleted refers to other data to be deleted. Delete operations also can be dependent on<br>
updates. For examples, data is to be updated to de-reference data to be deleted.<br><br>
When inserting data for the objects, the data being referred must be inserted before the referring data. When updating data, the data being referred must be inserted before updating the referring data. When deleting data, the referring data must either be deleted or updated to de-reference the referenced data, before deleting the referenced data.<br>
The precedences between different database operations form complex trees of prerequisites. Due to the nature of relational referential integrity constraints, there generally are no circular constraints defined in the database. Database operation ordering 150 according to the present invention provides a mechanism for automatically ordering the relational insert and delete operations according to the referential integrity constraints defined for the relational database 110 when trees of objects are to be stored to or deleted from the database. The ordering mechanism preferably utilizes the information of how the relationships between the objects are mapped to the primary-key/foreign-key pairs in the database and integrity rules for the pairs.<br>
Figures 4-8 are flowcharts that illustrate database operation ordering according to the invention. It will be understood that each block of the flowchart illustrations, and combinations of blocks in the flowchart illustrations, can be implemented by computer program instructions. These computer program instructions may be provided to a processor or other programmable data processing apparatus to produce a machine, such that the instructions which execute on the processor or other programmable data processing apparatus create means for implementing the functions specified in the flowchart block or blocks. These computer program instructions may also be stored in a computer-readable memory that can direct a processor or other programmable data processing apparatus to function in a particular manner, such that the instructions stored in the computer-readable memory produce an article of manufacture including instruction means which implement the functions specified in the flowchart block or blocks.<br>
Accordingly, blocks of the flowchart illustrations support combinations of means for performing the specified functions, combinations of steps for performing the specified functions and program instruction means for performing the specified functions. It will also be understood that each block of the flowchart illustrations, and combinations of<br>
blocks in the flowchart illustrations, can be implemented by special purpose hardware-based computer systems which perform the specified functions or steps, or by combinations of special purpose hardware and computer instructions. Referring to Figure 4, it has been realized, according to the invention, that prerequisites do not need to be resolved completely in order to be able to determine a proper order for operation execution in the relational database. Rather, the prerequisites need to be resolved in detail only among the insert operations and among the delete operations. The prerequisites need not be resolved in detail across different operation types. Accordingly, as shown in Figure 4, database operation ordering 150 begins by clustering the objects in the completed transaction into groups of objects to be inserted into the relational database, objects to be deleted from the relational database and objects to be updated in the relational database, at Block 410. Detailed operations for clustering will be described below.<br>
Still referring to Figure 4, the objects to be inserted into the relational database are ordered according to an insert precedence of the objects into the relational database to thereby define an insert order in an insert-list at Block 420. At Block 430, the objects j to be deleted from the relational database are ordered according to a delete precedence j of the objects from the relational database to thereby define a delete order in a delete-list. It will be understood that the operations of Blocks 420 and 430 may be performed in a reverse sequence from that shown. Details of performing these operations will be described below.<br>
Still referring to Figure 4, the relational database operations can then be executed in three phases. First, the insert operations are performed at Block 440 by inserting into the relational database, the objects to be inserted into the relational database, in the insert order. Then, at Block 450, update operations are performed by updating the relational database with the objects to be updated in the relational database. Finally, at Block 460, delete operations are performed by deleting from the relational database, the objects to be deleted from the relational database, in the delete order. As shown in Figure 4, it is safe to execute the update operations after executing the insert operations, because all the objects that possibly could be referred to by the updated objects have already been inserted into the relational database. The delete<br>
operations can be executed after the update operations, because any possible de-referencing would have taken place during the update phase. Figure 5 illustrates clustering of objects according to the database operation types (Block 410 of Figure 4). These operations are performed on an unclustered object list, referred to herein as a UC-list, using a Current Object Pointer referred to herein as a "COP", that points to a current object referred to herein as a "CO". As shown in Figure 5 at Block 510, the COP is set to the first position in the unclustered object list. A test is made at Block 515 as whether the CO is new. 11 yes, then the CO is added to an insert-list at Block 535. If not, a test is made at Block 520 as to whether the CO is to be deleted. If yes, then the CO is added to a delete-list at Block 540. If not, the CO is added to the update-list at Block 525. These operations are repeatedly performed until the end of the unclustered object list is reached at Block 545. Once the end of the unclustered object list is reached, the insert-list has been populated with the objects to be inserted into the relational database, the delete- list has been populated with the objects to be deleted from the database, and the update-list has been populated with the objects to be updated in the relational database. The same operations can be performed for resolving the detailed prerequisites for insert and update operations. Accordingly, these operations are described genetically in Figure 6. However, it will be understood that these operations are performed separately for ordering the objects to be inserted into the relational database according to an insert precedent of the objects into the relational database to thereby define an insert order, and separately for ordering the objects to be deleted from the relational database according to a delete precedence of the object from the relational database to thereby define a delete order.<br>
It will also be understood that ordering the objects to be inserted may be performed prior to ordering the objects to be deleted. Alternatively, ordering the objects to be deleted may be performed prior to ordering the objects to be inserted. Moreover, ordering the objects to be inserted may be performed simultaneously with ordering the objects to be deleted in two independent processes.<br>
Finally, it will be understood that ordering of objects to be updated in the relational database need not be performed. Stated differently, the objects to be updated in the relational database may be updated in an arbitrary order. Ordering is not<br>
required because it is safe to execute the update operations in any arbitrary order after executing the insert operations, because all the objects that possibly could be referred by the updated objects have already been inserted in the relational database.<br>
Referring to Figure 9, the operations of Figure 6 use two lists of objects that participate in the transaction: a list of unsorted objects referred to as an unsorted object , list or a "US-list", and a list of sorted objects referred to as a sorted object list or an 'S-list". The sorted object list is initially empty and the unsorted object list initially contains all of the objects to be inserted in the relational database or all of the objects to be deleted from the relational database. The operations for ordering objects operate on a Current Object (CO) in the unsorted object list using a Current Object Pointer (COP).Still referring to Figure 9, an associations list or "A-list" includes a listing of associations from the Current Object to its associated objects. A Current Association Pointer (CAP) points to a Current Association (CA).<br>
The concept of associations between objects, in general, is well known in the art. An association may also be thought of a relationship; in fact, while the term "association" is commonly used in object modeling when designing applications that will use objects, the term "relationship" is used in data modeling when discussing how tie data is stored in a database. One technique for object modeling is the Unified Modeling Language ("UML"), which defines a notation that can be used to diagrammatically represent associations between objects. UML is a standard of the Object Management Group, and is described in "UML Toolkit", H. Eriksson, M. Penker (published by John Wiley and Sons, 1997).<br>
According to the UML model, an association model is composed of associations, which are known by a name and contain one or more association ends. An association end has the following properties: a type, which specifies the class to which this end of the association refers; a role name, which is unique for all of the association ends which refer to a class; and a multiplicity, which defines the number of members in the association end.<br>
Referring again to Figure 6, ordering of objects is performed by iterating the objects over the unsorted object list. Thus, Block 602 sets the Current Object Pointer (COP) to the first position in the US-list so that the first position in the US-list becomes the Current Object (CO). The Current Object also is added to the end of the S-list at Block 604. The operations then iterate over the associations that the Current Object has with other objects. Thus, at Block 606 the Current Association Pointer (CAP) is set to the first position in the A-list. For each association, the operations test if the Current Object has either insert precedence (if the object is to be inserted into the database) or delete precedence (if the object is to be deleted from the database) over the Current Association at Block 612, If the Current Object has precedence over the Current Association and the Associated Object or objects are already included in the S-list in a position before the Current Object (Block 614), then the Associated Object and its lower precedence Associated Objects are recursively moved to the end of the S-list of Block 616.<br>
At Block 618 if the Associated Object includes other Associated Objects, then the Associated Object becomes the temporary Current Object at Block 608 and the precedence testing and moving Associated Objects to the end of the S-list are performed recursively. When all Associated Objects have been tested at Block 618 and the end of the A-list is not reached at Block 620, then the CAP is advanced in the A-list at Block 622 and the recursive operations are again performed. At the end of the A-list at Block 620, the COP is advanced in the US-list by one increment at Block 610 if the end of the US-list has not yet been reached at Block 624. Accordingly, upon completion of the processing of Figure 6, the order of either insert or delete operations to be performed for the objects in the clustered list corresponds to the referential integrity rules defined in the relational database.<br>
Figures 7 and 8 describe detailed operations for determining the insert precedence between an association's Current Object and Associated Objects and for determining the delete precedence between an association's Current Object and Associated Objects, respectively. The operations of Figure 7 or 8 will be performed<br>
depending on whether ordering of objects to be inserted (Block 612a) or deleted (Block 612b) is being performed at Block 612 of Figure 6.<br>
As shown in Figure 7, the Current Object has insert precedence over an association if the table holding the Associated Object or objects has a foreign key column, which refers to the primary key column in the table holding the Current Object, and there is a constraint defined for this primary-key/foreign-key column pair. As shown in Figure 8, the Current Object has delete precedence over an association if the table holding the Current Object as a foreign key column, which refers to the primary key column in the table holding the Associated Object/objects, and there is a constraint defined for this primary-key/foreign-key column pair.<br>
Thus, at Block 702/802 a test is made as to whether an association has a constraint. If no, then at Block 708/808, the Current Object does not have precedence. If yes, then at Block 704, a test is made as to whether the Associated Object has a foreign key and at Block 804, a test is made as to whether the Current Object has a foreign key. If yes, then at Block 710/810, the Current Object has precedence. If not, then at Block 706/806, the Current Object does not have precedence. It will be understood that once the precedence has been determined, many other sorting operations may be performed to order the objects.<br>
Accordingly, associations are used to determine the relative position of objects to be inserted and deleted from a relational database upon completion of a transaction by an object-oriented transaction system. Operation ordering may be performed automatically without the need to generate a custom programming and without the need to artificially constrain usability of the object-oriented transaction processing system.<br>
In the drawings and specification, there have been disclosed typical preferred embodiments of the invention and, although specific terms are employed, they are used in a generic and descriptive sense only and not for purposes of limitation, the scope of the invention being set forth in the following claims.<br><br><br><br>
We claim<br>
1.	A method of ordering database operations that are performed on a relational<br>
database upon completion of a transaction by an object-oriented transaction<br>
system, the method comprising the steps of:<br>
-	clustering the objects in the completed transaction into groups of objects<br>
to be inserted into the relational database, objects to be deleted from the<br>
relational database and objects to be updated in the relational database;<br>
-	ordering the objects to be inserted into the relational database according to<br>
an insert precedence of the objects into the relational database to thereby<br>
define an insert order;<br>
ordering the objects to be deleted from the relational database according to a delete precedence of the objects from the relational database to thereby define a delete order;<br>
-	inserting into the relational database, the objects to be inserted into the<br>
relational database, in the insert order; then<br>
-	updating the relational database with the objects to be updated in the<br>
relational database; and then<br>
-	deleting from the relational database, the objects to be deleted from the<br>
relational database, in  the  delete  order.<br>
2.	A method according to claim 1 wherein the updating step comprises the step of<br>
updating the relational database with the objects to be updated in the relational<br>
database, in an arbitrary order.<br>
3.	A method according to any preceding Claim wherein the step of ordering the<br>
objects to be deleted from the relational database comprises the steps of:<br>
identifying associations among the objects to be deleted;<br>
-	determining if a current object to be deleted has delete precedence over an associated object to be deleted;<br>
-	ordering the current object to be deleted ahead of the associated object to<br>
be deleted if the current object to be deleted has delete precedence over<br>
the associated object to be deleted;<br>
-	ordering the current object to be deleted behind the associated object to be<br>
deleted if the current object to be deleted does not have delete precedence<br>
over the associated object to be deleted; and<br>
-	repeatedly performing the steps of determining, ordering ahead and<br>
ordering behind, for remaining objects associated with the current object<br>
to be deleted.<br><br>
4.	A method according to any preceding claim further comprising the step of<br>
recursively performing the steps of determining, ordering ahead and ordering<br>
behind, for the associated objects of each associated object that is associated with<br>
the current object to be deleted that is ordered ahead of the associated object to be<br>
deleted.<br>
5.	A method according to claim 3 wherein the step of identifying associations among<br>
the objects to be deleted comprises the steps of:<br>
identifying current and associated objects for the objects to be deleted; identifying foreign keys and primary keys in the objects to be deleted; and identifying constraints in the relational database between pairs of the identified foreign keys and primary keys; and<br>
wherein the step of determining if a current object to be deleted has delete precedence over its associated objects to be deleted comprises the steps of: determining if a foreign key of the current object to be deleted refers to a primary key of the associated object to be deleted;<br>
determining that the current object to be deleted has delete precedence over an associated object to be deleted if there is a constraint identified between the foreign key of the current object to be deleted and the primary key of the associated object to be deleted; and<br>
-	determining that the current object to be deleted does not have delete<br>
precedence over an associated object to be deleted if no constraints are<br>
identified between the foreign key of the current object to be deleted and<br>
the primary key of the associated object to be deleted.<br>
6.	A method according to any preceding Claim wherein the step of ordering the<br>
objects to be inserted to the relational database comprises the steps of:<br>
-	identifying associations among the objects to be inserted;<br>
determining if a current object to be inserted has insert precedence over<br>
associated objects to be inserted;<br>
-	ordering the current object to be inserted ahead of an associated object to<br>
be inserted if the current object to be inserted has: precedence over the<br>
associated object to be inserted;<br>
-	ordering the current object to be inserted behind an associated objects to<br>
be inserted if the current object to be inserted does not have insert<br>
precedence over an associated objects to be inserted; and<br>
-	repeatedly performing the steps of determining, ordering ahead and<br>
ordering behind, for remaining objects associated with the current object<br>
to be inserted.<br>
7.	A method according to Claim 6 further comprising the step of recursively<br>
performing the steps of determining, ordering ahead and ordering behind, for the<br>
associated objects of each associated object that is associated with the current<br>
object to be inserted that is ordered ahead of the associated object to be inserted.<br>
8.	A method according to claim 6 wherein the step of identifying associations among<br>
the objects to be inserted comprises the steps of:<br>
identifying current and associated objects for the objects to be inserted; identifying foreign keys and primary keys in the objects to be inserted; and identifying constraints in the relational database between pairs of the identified foreign keys and primary keys; and<br>
-	wherein the step of determining if a current object to be inserted has insert<br>
precedence over its associated objects to be inserted comprises the steps<br>
of:<br>
-	determining if a foreign key of the associated object to be inserted refers<br>
to a primary key of the current object to be inserted;<br>
-	determining that the current object to be inserted has insert precedence<br>
over an associated object to be inserted if there is a constraint identified<br>
between the foreign key of the current object to be inserted and the<br>
primary key of the associated object to be inserted; and<br>
determining that the current object to be inserted does not have insert precedence over an associated object to be inserted if no constraints are identified between the primary key of the current object to be inserted and the foreign key of the associated object to be inserted.<br>
9. A method of ordering objects to be inserted into or deleted from a relational database upon completion of a transaction by an object-oriented transaction system, the method comprising the steps of:<br>
-	identifying associations among the objects to be inserted or deleted;<br>
-	determining if a current object to be inserted or deleted has insert or delete<br>
precedence over an associated object to be inserted or deleted;<br>
ordering the current object to be inserted or deleted ahead of the associated<br>
object to be inserted or deleted if the current object to be inserted or<br>
deleted has insert or delete precedence over the associated object to be<br>
inserted or deleted;<br>
ordering the current object to be inserted or deleted behind the associated<br>
object to be inserted or deleted if the current object to be inserted or<br>
deleted does not have insert or delete precedence over the associated<br>
object to be inserted or deleted; and<br>
repeatedly performing the steps of determining, ordering ahead and<br>
ordering behind, for remaining objects associated with the current object<br>
to be inserted or deleted.<br>
10.      A data processing system comprising: a relational database;<br>
-	an object-oriented transaction system;<br>
means for clustering the objects in the completed transaction into groups of objects to be inserted into the relational database, objects to be deleted from the relational database and objects to be updated in the relational database;<br>
-	means for ordering the objects to be inserted into the relational database<br>
according to an insert precedence of the objects into the relational<br>
database to thereby define an insert order;<br>
-	means for ordering the objects to be deleted from the relational database<br>
according to a delete precedence of the objects from the relational<br>
database to thereby define a delete order;<br>
means for inserting into the relational database, the objects to be inserted into the relational database, in the insert order;<br>
means for updating the relational database with the objects to be updated in the relational database in response to the means for inserting; and means for deleting from the relational database, the objects to be deleted from the relational database, in the delete order, in response to the means for updating.<br>
11.	A system according to claim 10 wherein the updating means comprises means for<br>
updating the relational database with the objects to be updated in the relational<br>
database, in an arbitrary order.<br>
12.	A system according to Claim 10 wherein the means for ordering the objects to be<br>
deleted from the relational database comprises:<br>
means for identifying associations among the objects to be deleted; means  for determining  if a current  object to be deleted has  delete precedence over an associated object to be deleted;<br>
- means for ordering the current object to be deleted ahead of an associated object to be deleted if the current object to be deleted has delete precedence over the associated object to be deleted; and means for ordering the current object to be deleted behind an associated object to be deleted if the current object to be deleted does not have delete precedence over the associated object to be deleted.<br>
13.      A system according to claim 12 wherein the means for identifying associations among the objects to be deleted comprises:<br>
means for identifying current and associated objects for the objects to be deleted;<br>
means for identifying foreign keys and primary keys in the objects to be deleted; and means for identifying constraints in the relational database between pairs of the identified foreign keys and primary keys; and wherein the means for determining if a current object to be deleted has delete precedence over an associated object deleted comprises:<br>
means for determining if a foreign key of the current object to be deleted refers to a primary key of the associated object to be deleted; means for determining that the current object to be deleted has delete precedence over the associated object to be deleted if there is a constraint identified between the foreign key of the current object to be deleted and the primary key of the associated object to be deleted; and<br>
means for determining that the current object to be deleted does not have<br>
delete precedence over the associated object to be deleted if no constraints are identified between the foreign key of the current object to be deleted and the primary key of the associated object to be deleted.<br>
14.      A system according to claim 10 wherein the means for ordering the objects to be inserted from the relational database comprises:<br>
means for identifying associations among the objects to be inserted;<br>
-	means for determining if a current object to be inserted has insert<br>
precedence over an associated object to be inserted;<br>
-	means for ordering the current object to be inserted ahead of an associated<br>
object to be inserted if the current object to be inserted has insert<br>
precedence over the associated object to be inserted; and<br>
-	means for ordering the current object to be inserted behind an associated objects to be inserted if the current object to be inserted does not have<br>
insert precedence over the associated object to be inserted.<br>
15.      A system according to claim 14 wherein the means for identifying associations among the objects to be inserted comprises:<br>
-	means for identifying current and associated objects for the objects to be<br>
inserted;<br>
means for identifying foreign keys and primary keys in the objects to be inserted; and<br>
-	means for identifying constraints in the relational database between pairs<br>
of the identified foreign keys and primary keys; and<br>
-	wherein the means for determining if a current object to be inserted has<br>
insert precedence over an associated object to be inserted comprises:<br>
means for determining if a foreign key of the associated object to be<br>
inserted refers to a primary key of the current object to be inserted;<br>
means for determining that the current object to be inserted has insert<br>
precedence over an associated objects to be inserted if there is a constraint<br>
identified between the foreign key of the current object to be inserted and<br>
the   primary   key   of   the   associated   object   to   be   inserted;   and<br>
means for determining that the current object to be inserted does not have<br>
insert precedence over an associated objects to be inserted if no constraints<br>
are identified between the primary key of the current object to be inserted<br>
and the foreign key of the associated object to be inserted.<br>
16.       A data processing system comprising:<br>
-	a relational database;<br>
-	an object-oriented transaction system;<br>
means for identifying associations among the objects to be inserted or deleted;<br>
-	means for determining if a current object to be inserted or deleted has<br>
insert or delete precedence over an associated object to be inserted or<br>
deleted;<br>
-	means for ordering the current object to be inserted or deleted ahead of an<br>
associated object to be inserted or deleted if the current object to be<br>
inserted or deleted has insert or delete precedence over the associated<br>
object to be inserted or deleted ; and<br>
means for ordering the current object to be inserted or deleted behind the associated object to be inserted or deleted if the current object to be inserted or deleted does not have insert or delete precedence over the associated object to be inserted or deleted.<br>
17. A computer program product for ordering database operations that are performed on a relational database upon completion of a transaction by an object-oriented transaction system, the computer program product comprising a computer-readable storage medium having computer-readable program code means embodied in the medium, for implementing the method of any claims 1-9.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">1436-del-1999-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1hc3NpZ25tZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">1436-del-1999-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">1436-del-1999-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1jb3JyZXNwb25kZW5jZS1vdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">1436-del-1999-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1jb3JyZXNwb25kZW5jZS1wby5wZGY=" target="_blank" style="word-wrap:break-word;">1436-del-1999-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">1436-del-1999-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">1436-del-1999-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1mb3JtLTEucGRm" target="_blank" style="word-wrap:break-word;">1436-del-1999-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1mb3JtLTE5LnBkZg==" target="_blank" style="word-wrap:break-word;">1436-del-1999-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1mb3JtLTIucGRm" target="_blank" style="word-wrap:break-word;">1436-del-1999-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1mb3JtLTMucGRm" target="_blank" style="word-wrap:break-word;">1436-del-1999-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1mb3JtLTUucGRm" target="_blank" style="word-wrap:break-word;">1436-del-1999-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1ncGEucGRm" target="_blank" style="word-wrap:break-word;">1436-del-1999-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1wZXRpdGlvbi0xMzcucGRm" target="_blank" style="word-wrap:break-word;">1436-del-1999-petition-137.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzNi1kZWwtMTk5OS1wZXRpdGlvbi0xMzgucGRm" target="_blank" style="word-wrap:break-word;">1436-del-1999-petition-138.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="216734-a-process-for-the-isomerization-of-a-non-equilibrium-feed-mixture-of-xylenes-and-ethylbenzene.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="216736-a-process-for-preparing-a-novel-polycrystalline-ceramic-phosphor-composition-useful-as-a-light-emittting-material.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>216735</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1436/DEL/1999</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>31-Mar-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>19-Mar-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>02-Nov-1999</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTERNATIONAL BUSINESS MACHINES CORPORATION,</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>ARMONK, NEW YORK 10504, U.S.A.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>SALO TIMO JUHANI</td>
											<td>108 CONNELLY SPRINGS PLACE, APEX, NC 27502, U.S.A.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>WILLIAMS KEVIN JOE</td>
											<td>1302 ESPLANADE AVENUE, #320N, REDONDO BEACH, CA 90277, USA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 17/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/224,427</td>
									<td>1998-12-31</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/216735-a-data-processing-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:58:35 GMT -->
</html>
