<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/213590-a-method-and-system-for-restoring-a-memory-device-channel by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 06:05:17 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 213590:A METHOD AND SYSTEM FOR RESTORING A MEMORY DEVICE CHANNEL</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD AND SYSTEM FOR RESTORING A MEMORY DEVICE CHANNEL</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method comprising: storing a plurality of memory initialization values from a plurality of storage locations in a memory controller into a memory which maintains values during a power down state, the plurality of memory initialization values being necessary to access a system memory; entering the power down state; restoring the plurality of memory initialization values to the plurality of storage locations in the memory controller when the power down state is exited; executing a routine to derive one or more additional memory initialization values in response to exiting the power down state.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT 1970<br>
[39 OF 1970]<br>
COMPLETE SPECIFICATION<br>
[See Section 10]<br>
"A METHOD AND SYSTEM FOR RESTORING A MEMORY DEVICE CHANNEL"<br>
The following specification particularly describes the nature of the invention and the manner in which it is to be performed :-<br><br>
The present invention relates to a method and system for restorin a memory device channel.<br>
1.	Field of the Invention<br>
The present disclosure pertains to the field of data processing systems. More particularly, the present disclosure pertains to initializing or configuring memory devices in a memory channel and restoring memory devices when exiting a low power state.<br>
2.	Description of Related Art<br>
Placing a computer system into a low power state is a well known technique for saving power. For example, the Advanced Configuration and Power Management Interface (ACPI) specification suggests the use of several low power states and defines the interfaces between the operating system software and system hardware.<br>
A suspend-to-RAM (STR) state is a common state used in power management applications. Typically, when this low power state is entered, processing activity ceases, and certain values are stored in memory, preserving them for when processing resumes at a later point in time. For example, the ACPI S3 sleeping state is a state where all system context is lost except system memory. Processor and memory controller context (i,e., register and internal memory values) are lost in this state. Additionally, other power management techniques may include similar states in which the register and/or memory values in a chipset or memory controller are lost.<br>
Losing memory controller values may be particularly problematic in a system that requires memory configuration registers to be initialized in order to communicate properly with the memory. Until such values are restored, the main memory can not be accessed.   Moreover, the main<br><br>
memory cannot be used to store the configuration values or to store a program for restoring such values.<br>
To restore values to such memory configuration registers, one approach would be to execute the entire memory initialization sequence to re-establish the lost initialization values. This approach, however, may be disadvantageous for two reasons. First, the initialization sequence may be lengthy, thereby causing a significant latency to occur when the system tries to wake up from a STR state. Secondly, the initialization sequence may perform some operations that jeopardize the contents of the memory. If memory were indeed lost by re-initializing the system, such an approach would not be practical for some implementations. For example, if exiting the ACPI S3 state corrupted memory, the implementation would not be compliant with the ACPI specification.<br>
One bus that requires a significant amount of initialization prior to proper operation is a Rambus™ Direct Rambus Dynamic Random Access Memory channel (a Direct RDRAM™ channel). This bus is described in detail in documentation available from Rambus Corporation of Mountain View, California. Numerous memory controller values may be lost when a memory controller for a bus architecture like the Direct Rambus™ channel architecture is placed in a low power state, and the prior art may not provide an adequate mechanism to recover these values.<br>
SUMMARY<br>
A method and apparatus for restoring a memory device channel when exiting a low power state is disclosed. One method involves storing a set of memory initialization values from storage locations in a memory controller into a memory that maintains values during a power down state. The values may be necessary to access a system memory. When the power down state is exited, the values are restored to the storage locations in the memory controller.<br><br>
BRIEF DESCRIPTION OF THE FIGURES<br>
The present invention is illustrated by way of example and not limitation in the figures of the accompanying drawings.<br>
Figure 1 illustrates one embodiment of a system using configuration registers in a memory controller to designate initialization operations for memory initialization.<br>
Figure 2 illustrates a flow diagram of programming and executing initialization operations of one embodiment of the system of Figure 1.<br>
Figure 3 illustrates one embodiment of a memory control hub that performs memory initialization according to values loaded into control and data registers.<br>
Figure 4 illustrates a flow diagram for a memory device core initialization operation.<br>
Figure 5 illustrates one embodiment of a system implementing an initialization flow shown in Figures 6-9.<br>
Figure 6 illustrates a flow diagram of one embodiment of an overall initialization sequence for the memory subsystem of the system shown in Figure 5.<br>
Figure 7 illustrates one embodiment of a serial device identification process.<br>
Figures 8A-8C illustrate one embodiment of a group device identification process.<br>
Figure 9 illustrates one embodiment of a memory device core initialization process.<br>
Figure 10 illustrates one embodiment of the process of returning from a suspend-to-RAM power management state.<br><br><br>
DETAILED DESCRIPTION<br>
The following description provides a method and apparatus for restoring a memory device channel when exiting a low power state. In the following description, numerous specific details such as register names, memory types, bus protocols, specific types of components, and logic partitioning and integration choices are set forth in order to provide a more thorough understanding of the present invention. It will be appreciated, however, by one skilled in the art that the invention may be practiced without such specific details. In other instances, control structures and gate level circuits have not been shown in detail in order not to obscure the invention. Those of ordinary skill in the art, with the included descriptions, will be able to implement the necessary logic circuits without undue experimentation.<br>
Using the presently disclosed techniques, efficient and flexible memory initialization may be performed. Control and data registers may be programmed, thereby causing a memory control hub (MCH) to perform initialization operations (lOPs) according the values loaded in the registers. Since the registers may be programmed by software such as a basic input/output system (BIOS), the initialization may be altered with relative ease.<br>
Figure 1 illustrates one embodiment of a system utilizing registers to perform memory initialization. The system includes a processor 195 and a memory subsystem 104 that are coupled to a memory control hub (MCH) 100. Also coupled to the MCH 100 is a secondary bus 180 having coupled thereto an input device 190 and a non-volatile memory 185 containing BIOS routines. In some embodiments, either or both of the non-volatile memory 185 and the input device 190 may be coupled to the MCH 100 by a second control hub (not shown).<br><br><br>
In the illustrated embodiment, the memory subsystem 104 includes three memory modules 160, 170, and 175 coupled to the MCH 100 via a serial bus 142 and a memory bus 132 (also referred to as a channel). Each memory module may contain a set of individual memory devices. For example, the memory module 160 includes at least memory devices 160, 161, and 168. In one embodiment, the memory devices 160,161, and 168 are Rambus DRAMs (RDRAMs), the memory modules are Rambus In-line Memory Modules (RIMMs), and the channel operates according to protocols defined for RIMMs and RDRAMs.<br>
The MCH 100 includes a control register 112 and a data register 114 which may be used for initialization purposes. An initialization control circuit 120 executes initialization operands (lOPs) which are programmed into the control register 112. The control register 112 typically includes other fields to specify information about initialization operations, and some of the operations "Specified by the lOPs involve data exchange with devices in the memory subsystem (e.g., writing and reading of memory device control registers or otherwise generating control signals).<br>
A serial interface circuit 140 generates serial command and data sequences on the serial bus 142. Some of the commands executed by the initialization control circuit 120 send commands and/or data to the memory subsystem via the serial bus 142. In one embodiment, the serial interface circuit implements a serial presence detect (SPD) protocol for communication with the memory subsystem 104. The SPD protocol utilizes a SPD clock (SCK) pin, a command (CMD) pin, and bi-directional serial I/O pins (SIOO and SI01) for reading from and writing to memory subsystem control registers.<br>
Control registers, including device registers for identification numbers, may be read and written via the SPD interface.  Additionally, a<br><br>
non-volatile memory for each module may be read via the SPD interface to determine information such as timing information, device organization, and device technology about each particular memory module. More details of the SPD protocol are discussed in the "Serial Presence Detect Application Brief as well as the Direct Rambus™ RIMM™ Module and the 64/72 Mbit Direct RDRAM™ data sheets available from Rambus.<br>
A memory interface circuit 130 translates memory data to and from data packets which are exchanged with the memory subsystem. In one embodiment, the memory interface circuit is a Rambus ASIC Cell (RAC) functioning substantially as described in the "Direct RAC Data Sheet" available from Rambus Corporation of Mountain View, California. Briefly, the RAC converts the Rambus Signal Level (RSL) signals on the channel (bus 132) to signals which can be processed by other portions of the MCH 100. Similarly, the RAC converts the memory controller signals to RSL signal which can be processed by memory devices on the Rambus channel.<br>
A sequence of initialization events for the system of Figure 1 is illustrated in Figure 2. As the system is reset or turned on, the BIOS typically performs various initialization operations. In block 200, the BIOS reaches the memory configuration portion. Depending on the type of memory and the intended mode of usage, initialization operations will be selected (block 205) by the BIOS in a particular sequence. More details of one embodiment of an initialization sequence for a system utilizing RDRAMs are discussed with respect to Figures 5-9.<br>
As indicated in block 210, data (if any) for the particular initialization operation is stored in the data register 114, and the initialization operand itself with other control information is stored in the control register 112. In some embodiments, the BIOS may perform this function by writing to peripheral    component    interconnect     (PCI)    configuration     registers.<br><br>
Alternatively, other registers may be used, or general purpose memory locations either within or without the MCH may be the control register. In fact, the control register may be any storage location accessible to the MCH prior to memory initialization that is capable of storing sufficient bits for lOPs and any other needed control information.<br>
The initialization operation may commence automatically when the proper initialization operation and/or control information are programmed into the control register 112. For example, the execution of the initialization operation indicated in block 215 may be accomplished by setting an initiate initialization operation (HO) bit, which may be a field of the control register 112, when the initialization operand is loaded into the control register 112.<br>
Completion of the initialization operation may be signaled in any manner sufficient to alert or inform the BIOS that the initialization operation is complete. For example, the MCH may automatically clear the HO bit when the initialization operation completes. If the BIOS polls the IIO bit, it may determine when the initialization operation completes as indicated in block 220. If the initialization operation has not completed, the BIOS may continue polling the IIO bit. If the initialization operation has completed, the BIOS may select the next initialization operation in the initialization sequence in block 205.<br>
The input device 190 may either accept program instructions from a computer storage device 192 (e.g., an optical or magnetic disk or other storage device) or from a network or communications interface 194. BIOS code (i.e., computer instructions) causing the system to implement the disclosed techniques may be programmed into the non-volatile memory 185 in several ways. The BIOS may be programmed when the system is manufactured or may be later delivered via a computer readable medium through the input device 190.<br><br><br>
In cases where the BIOS is later delivered, the instructions may be ^ * delivered via a computer readable medium. With an appropriate interface device 190, either an electronic signal or a tangible carrier is a computer readable medium. For example, the computer storage device 192 is a computer readable medium in one embodiment. A carrier wave 196 carrying the computer instruction is a computer readable medium in another embodiment. The carrier wave 196 may be modulated or otherwise manipulated to contain instructions that can be decoded by the input device 190 using known or otherwise available communication techniques. In either case, the computer instructions may be delivered via a computer readable medium.<br>
Figure 3 illustrates additional details of a memory controller hub (MCH) 300. Details of specific register names, locations, sizes, field definitions, and initialization operations are given for one embodiment below. Other embodiments will be apparent to those of skill in the art. Several of the operations below invoke specific commands defined by Rambus in the 64/72-Mbit Data Sheet and the Direct RAC data sheet. These defined operations are operations that the Rambus RAC itself sends to RDRAMs when appropriate control signals are sent to the RAC. As detailed below, this embodiment of the MCH 300 invokes known RAC commands by previously unavailable hardware and in new methods or sequences.<br>
In this exemplary embodiment, the MCH 300 includes a device register data (DRD) register 314. The DRD register 314 is at address offset 90-91h in PCI configuration space, the default value is OOOOh (16 bits), and the register is a read/write register. The fields of the DRD register are shown in Table 1.<br><br>
Table 1: An Embodiment of the DRD Register<br><br><br><br>
Description<br>
Register Data (RD): Bits 15:0 contain the 16 bit data to be written to a RDRAM register or the data read from a RDRAM register as a result of IOP execution. Data will be valid when the IIO bit of RICM register transitions from 1 to 0<br><br>
The MCH 300 also includes a RDRAM Initialization Control Management (RICM) Register 312. The RICM Register is at address offset 94-96h in PCI configuration space, the default value is OOOOOOh (24 bits), and the register is a read/write register. The fields of the RICM register for this embodiment are set forth in Table 2.<br>
TABLE 2: AN EMBODIMENT OF THE RICM REGISTER<br><br><br>
Bit<br>
18  	Description	<br><br>
	Initialization	Opcode (IOP): This field specifies the initialization operation to<br>
3:0	be done on a	RDRAM device or the MCH RAC.<br>
	Bits[18,3:0]	Operation Specified<br>
	0 0 0 0 0	RDRAM Register Read<br>
	0 0 0 0 1	RDRAM Register Write<br>
	0 0 0 1 0	RDRAM Set Reset<br>
	0 0 0 1 1	RDRAM Clear Reset<br>
	0 0 1 0 0	RDRAM Set Fast Clock Mode<br>
	0 0 1 0 1	Reserved<br>
	0 0 1 1 0	RDRAM Temperature Calibrate Enable and then Temperature Calibrate<br>
	0 0 1 1 1	to  0 1 1 1 1     Reserved<br>
	1 0 0 0 0	RDRAM Core Initialization (RCl)<br>
	1 0 0 0 1	RDRAM SIO Reset<br>
	1 0 0 1 0	RDRAM Powerdown Exit<br>
	1 0 0 1 1	RDRAM Powerdown Entry<br>
	1 0 1 0 0	RDRAM "Current Car and 'Current Cal + Sample"<br>
	1 0 1 0 1	Manual Current Calibration of MCH RAC<br>
	1 0 1 1 0 register	Load MCH RAC control register with data from DRD<br>
	1 0 1 1 1	Initialize MCH RAC<br>
	1 1 0 0 0	RDRAM Nap Entry<br>
	1 1 0 0 1	RDRAM Nap Exit<br>
	1 1 0 1 0	RDRAM Refresh<br>
	1 1 0 1 1	RDRAM Precharge<br>
	All other combinations are reserved.<br>
	More details on the operations specified by IOP field is shown in Table 3<br>
	below.	<br>
Also illustrated in Figure 3 is an initialization control circuit 320 which includes an RDRAM IOP execution circuit 325. Details of the various lOPs executed by the control circuit 320 are illustrated in Table 3. In Table 3, the broadcast address (BA) field (bit 19) and the SDA field (bits 8:4) are listed either as one of the following:<br>
NE:      This field has no effect on the initialization operation<br>
0:	This field is to be set to 0 for this initialization operation.<br>
1:	This field is to be set to 1 for this initialization operation.<br>
x:	This field should be programmed as appropriate for the particular<br>
initialization operation.<br>
Table 3: IOP Operation Details<br><br>
Bits [18,3:0]	Operation Name	BA	SDA	Details<br>
0 0 0 0 0	RDRAM Register Read	0	X	This lOP performs the serial read of the RDRAM register specified by SDA and DRA fields. The data read will be available in DRD register when the HO bit is cleared to 0.<br>
0    0    0     0     1	RDRAM Register Write	X	X	This lOP performs the serial write of the RDRAM register specified by SDA and DRA fields. The write data is provided in the DRD register.  A write operation to all RDRAM devices on the channel can be performed by setting the BA field to 1.<br>
0   0    0     10	RDRAM Set Reset	X	X	This lOP performs the serial setting of a reset bit in an RDRAM device specified by the SDA field.<br>
The setting of the reset bit begins a period for the RDRAM device to reset and prepare to respond to all other defined operations. The Set Reset lOP also puts the RDRAM in active mode.<br>
0   0    0     11	RDRAM Clear Reset	X	X	This lOP performs the serial clearing of the reset bit in an RDRAM device specified by SDA field. The Clear Reset operation puts the device into Powerdown state. A minimum of 4 SCK cycles must pass after the SIO Request Packet before the RDRAM device is allowed to exit this Powerdown state. The Clear Reset operation may not be issued before greater than 16 SCK cycles have occurred after the Set<br><br>
Bits {18,3:0]	Operation Name	BA	SDA	Details<br>
				Reset operation.<br>
0 0 1 0 0	RDRAM Set Fast Clock Mode	X	X	The Set Fast Clock Mode operation prepares the RDRAM device to transmit and receive data on RSL signals using RDRAM clock (RCLK).<br>
0 0 1 1 0	RDRAM Temperature Calibrate Enable and then Temperature Calibrate	1	X	Upon receiving this lOP, the MCH issues a Temperature Calibrate Enable" SIO request packet followed immediately by a Temperature Calibrate" SIO Request packet to all RDRAMs.<br>
1 0 0 0 0	RDRAM Core Initialization<br>
(see Figure 4)	NE	NE	Upon receiving this lOP command the MCH does the following:<br>
1.	Broadcast<br>
Powerdown Exit.<br>
2.	Initialize all RDRAM<br>
cores of all RDRAM devices on the channel.<br>
3.	Broadcast Temp<br>
Cal Enable and Temp Cal.<br>
4.	Broadcast NAP<br>
entry (if bit 6 (PBS) of DRAMC register is 1).<br>
5.	If IC bit (bit 20) of<br>
RICM register is set to 1 along with this command, then the MCH enables RDRAM Refresh, RDRAM Current Cal, RDRAM Temp Cal, and RDRAM DLL Refresh logic after this command completes.<br>
1 0 0 0 1	RDRAM SIO Reset	NE	NE	This lOP sends an SIO pin initialization sequence to all RDRAMs. When this<br><br>
Bits [18,3:0]	Operation Name	BA	SDA	Details<br>
				operation occurs the<br>
SIO0	pin on the RDRAM<br>
is configured as input and<br>
SIO1	pin is configured as<br>
output. Additionally, the<br>
SIO repeater bit is set to<br>
1.<br>
1 0  0 1 0	RDRAM Powerdown Exit	X	X	Upon receiving this IOP, the MCH initiates a Powerdown exit sequence for the RDRAM device specified by SDA and BA fields. The SDA field should contain the device ID, not the serial device ID.<br>
10    0     11	RDRAM Powerdown Entry	X	X	Upon receiving this IOP, the MCH sends a Powerdown Entry PCP packet to the RDRAM device specified by SDA and BA fields. The SDA field should contain the device ID, not the serial device ID.<br>
1 0 1 0  0	RDRAM "Current Cal" and "Current Cal + Sample"	X	X	Upon receiving this IOP, the MCH sends three Current Calibrate SCP packets followed by one Current Calibrate and Sample SCP packet to the RDRAM device specified by SDA field.<br>
1 0 1 0 1	Manual Current Calibration of MCH RAC	NE	NE	Upon receiving this IOP, the MCH initiates a manual Current calibration operation of MCH RAC.<br>
1 0 1 1 0	Load MCH RAC control register with data from DRD register	NE	NE	Upon receiving this IOP, the MCH loads the MCH RAC control register with the data from the DRD register.<br>
1 0 1 1 1	Initialize MCH RAC	NE	NE	Upon receiving this IOP, the MCH initializes the MCH RAC. The MCH RAC initialization includes Power Up sequence,<br><br>
Bits [18,3:0]	Operation Name	BA	SDA	Details<br>
				Current Calibration and Temperature Calibration of the MCH RAC. After executing this command, the MCH enables the periodic Current and Temperature Calibration of the MCH RAC even if the IC bit is not set to 1.<br>
1 1 0 0 0	RDRAM Nap Entry	X	X	Upon receiving this lOP, the MCH sends a Nap Entry PCP packet to the RDRAM device specified by SDA and BA fields. The SDA field should contain the device ID, not the serial device ID.<br>
1 1 0 0 1	RDRAM Nap Exit	X	X	Upon receiving this lOP, the MCH initiates a Nap exit sequence for the RDRAM device specified by SDA and BA fields. The SDA field should contain the device ID, not the serial device ID.<br>
1 1 0 1 0	RDRAM Refresh	1	X	Upon receiving this lOP, the MCH sends a Refresh PCP packet to the specified bank of all RDRAM devices. The bank address is specified by SDA field.<br>
1 1 0 1 1	RDRAM Precharge	1	X	Upon receiving this lOP, the MCH sends a Precharge PCP packet to the specified bank of all RDRAM devices. The bank address is specified by SDA field.<br><br>
Details of operations conducted by one embodiment of the initialization control circuit 320 in response to receiving the RDRAM Core Initialization IOP (10000b) are shown in Figure 4. In block 400, a broadcast powerdown exit command is issued on the bus. Next, as per block 405, the sequence indicated by blocks 410 to 470 is repeated sixteen times for bank addresses zero to thirty-one. These numbers may be appropriate for a memory subsystem having one hundred and twenty-eight current calibration levels and up to thirty-two banks. In other embodiments, a different number of repetitions may be used if, for example, a larger or smaller number of current calibration levels are available. Similarly, differing numbers of banks may be available in different systems.<br>
In block 410, no operation is performed to ensure that the powerdown exit is complete and that the refresh operation (REFA command) is properly performed in block 415. In block 420, another no operation command is executed, followed by two more refresh operations (REFA) in blocks 425 and 430. Three more no operation commands are executed in block 435, allowing sufficient time to pass before a refresh precharge (REFP) command occurs. After another no operation command in block 445, another refresh precharge (REFP) command is executed in block 450.<br>
A calibrate (CAL) command is next executed in block 455. This command calibrates (drives) lα current for the presently indicated device. As indicated in blocks 460 and 465, this operation may be repeated twice. Then, as indicated in block 470, a sample (SAMR) command is executed. The sample command updates the lα current for the presently indicated device. Until all sixteen repetitions for the thirty-two two banks are performed, this process is repeated.<br>
INITIALIZATION SEQUENCE<br><br><br>
With the above initialization operations, registers, and related hardware, a system may be initialized. For example, the system shown in Figure 5, which implements a Rambus Direct RDRAM channel, may be initialized. In this system, a memory controller 500 (also referred to as a memory control hub or MCH) uses serial interface signals SCK, CMD and SIO to read and write to memory device configuration registers and perform other initialization operations on the channel. The memory controller also initiates specific ROW/COLUMN packets on the channel.<br>
The memory controller includes a Rambus ASIC Cell (RAC) 530, a control circuit 520, a SPD interface circuit 540, and a variety of registers. The registers include a initialization registers 515, which are used to initialize the system memory, and powerdown restoration registers 510. The powerdown restoration registers contain timing and other information \ crucial to operating the memory channel. In other words, the powerdown \ restoration registers are simply registers that need to be restored after powering down the memory controller 500 in order to resume accesses to the memory channel. The registers may be PCI configuration registers.<br>
\ The memory channel includes RIMM modules 560, 565, and 570 that are connected to the MCH 500 by a control and data bus 532 and a serial bus 542. The control and data bus 532 may be terminated by a resistive termination 533, and a Direct Rambus Clock Generator (DRCG) 580 may be provided at the far end of the channel from the MCH 500 to provide clock signals over signal lines 582.<br>
Additionally, the system includes an Input/Output control hub (ICH) 505 which couples the MCH to a secondary bus 506. The ICH has general purpose outputs (GPOs) which are used to control various system functions such as setting the frequency of the DRCG 580. A non¬volatile  memory 585  containing the  BIOS  may  be  coupled to the<br><br><br>
secondary bus 506, as well as a battery backed-up random access memory 590. The battery backed-up memory 590 may store powerdown restoration configuration values 592 for the MCH powerdown registers 510 so the MCH can resume accessing the RDRAM channel without performing the full initialization sequence detailed below.<br>
Briefly, the initialization process may be summarized as follows. After power up reset, the configuration information from Serial Presence Detection (SPD) data on the RIMMs in a channel is read. For example, a storage device, SPD memory 572, stores configuration information for the RDRAMs 573, 574, 576, and 577 on the RIMM 570. The memory controller configuration registers are programmed with the appropriate values from the SPD information, and then the RDRAM device IDs are programmed such that each RDRAM device can be uniquely identified and accessed by the memory controller. Once a device has been initialized, it can be used.<br>
Each RDRAM device has two identification numbers that are used to uniquely select a device on the channel, the Serial Device ID, and the Group Device ID. These two IDs are used for distinct operations on the RDRAM channel. The serial device ID is used to select devices when the memory controller is sending initialization operations on the SCK, SIO, and CMD signals of the RDRAM channel. The group device ID is used by the memory controller to select a device when sending ROW packets and COLUMN packets on RQ[7:0] signals of the RDRAM channel. Both the serial device ID and the group device ID are programmed after reset and before devices may be individually addressed by initialization operations (lOPs) and ROW/COLUMN packets, respectively.<br>
Looking at the initialization process of the Rambus channel in more detail, a particular sequence may be followed to achieve correct<br><br><br>
operation of the RDRAM devices on the channel. Figure 6 illustrates a flow diagram for proper channel initialization in one embodiment, and Table 4 enumerates some of the variables used in this initialization flow.<br>
Table 4: Variables Used in Initialization<br><br>
Name	Width (bits)	Description<br>
RIMMMax	2	Maximum number of RIMMs present. 0    No RIMMs present 1-3 1-3 RIMM(s) present<br>
RIMMCount	2	Counter used during initialization to select a RIMM.<br>
RIMMDeviceCount	5	Number of RDRAM devices in a particular RIMM.<br>
MemberMax	5	Maximum number of devices present on a channel<br>
0-31     1 -32 RDRAM devices present on the channel<br>
MemberCount	5	Counter used during group device ID enumeration to indicate # of devices that have been assigned group IDs.<br>
SeriallDCount	5	Serial Device ID index used to select devices on a channel.<br>
0-31     Maps to serial device ID 0-31<br>
GroupDevicelDCount	5	Group Device ID index used during group device ID enumeration to assign a Group Device ID to the next RDRAM device.<br>
0-31     Maps to group device ID 0-31<br>
RIMMDeviceConfigNo	8	Byte indicating RDRAM technology definition. Bit definition matches GAR register.<br>
DRAMConfigIndex	3	Index into table of DRAM technologies supported by MCH. Used during group device ID enumeration assign group IDs to RDRAMs in a technology descending order.<br>
MchTrdly	3	Temporary storage of maximum Mch Trdly during channel levelization procedure. Bit definition matches the MCH's tRDLY field in<br><br>
		the MCH RDT register.<br>
DeviceTestAddress	32	32-bit CPU address used to test a RDRAM device during channel levelization.<br>
Templndex	8	Temporary index used during algorithm.<br>
In block 602, system reset occurs. The MCH resets all its state machines and prepares for initialization. In block 604, memory module configuration of the system is verified. The BIOS reads SPD data to determine the memory configuration. If only RIMMs are present, the RDRAM initialization sequence may proceed with block 608. If mixed memory modules are present, an error is posted to the user and the system is halted as indicated in 606.<br>
The clock generator is started in block 608. This operation may be accomplished by software querying the SPD data of every RIMM module present on the motherboard and determining a channel frequency at which all RIMMs may operate. The DRCG 580 may be set to the proper frequency by a general purpose output (i.e., GPOx as shown in Figure 5) from the ICH 505. in one embodiment, the BIOS waits at least 8ms between this step and the MCH RAC initialization.<br>
As indicated in block 610, the MCH RAC is next initialized. The channel clock from the DRCG should be stable prior to MCH RAC initialization. The MCH RAC initialization is accomplished by executing the MCH RAC initialization IOP. The RAC initialization IOP performs basic initialization to prepare the internal RAC of the memory controller for normal operation.<br>
In one embodiment, the BIOS provides a time out of 5ms for the (fO bit to clear after the MCH RAC initialization IOP. If the HO bit is not cleared by the MCH after 5ms, the BIOS should report the error, and the channel is unusable.   An additional 5ms delay may be added after the<br><br>
MCH clears the IIO bit due to completion of the MCH RAC initialization IOP. This allows sufficient time for the MCH clocks to stabilize and lock. Also in some embodiments, a bus in the RAC may need to be cleared before other operations commence. This may be accomplished by executing the MCH RAC Control Register Load IOP (DRD = 00000h). It may also be possible to perform the RAC initialization at a later point in the initialization sequence in some embodiments.<br>
As indicated in block 612, a number of MCH configuration registers may next be initialized. In one embodiment, the paging policy register RMC idle timer (PGPOL RIT) field (MCH 052h [2:0]) is set to 001b to ensure no pages are closed during channel levelization (discussed below). The PGPOL RIT field sets the number of host bus clocks that the memory controller will remain in the idle state before all open pages are closed, and a value of zero indicates that there will be an infinite latency before the memory controller starts closing pages.<br>
Additionally, in some embodiments, operating pools may be used to group RDRAMs based on defined RDRAM states. In order to reduce operating power, the RDRAM devices may be grouped into two operating pools called "Pool A" and "Pool B." In one embodiment, up to eight devices may be in Pool A at a time. In this embodiment, up to four out of eight in Pool A may be in Active Read/Write or Active states at a time, and the devices in Pool A are in either Active Read/Write, Active, or Standby states.<br>
The maximum number of devices in Pool A is programmable and is specified by a PAC field of the RDRAM power management register (RPMR) register (MCH 053h). All devices that are not in Pool A are members of Pool B. All devices in Pool B are either in the Standby or Nap state. The state of the devices in Pool B is specified by a PBS field of a DRAM control (DRAMC) register (MCH 051 h).  In one embodiment,<br><br><br>
the RPMR register is set to OOh, selecting a pool A of 1 device only, and Pool B operation is set for standby operation (MCH 051h [6] = 0).<br>
Next, as indicated in block 614, additional channel initialization may be performed. This may include performing an SIO (serial interface) reset using the SIO reset IOP, and allowing sufficient delay for completion of the SIO reset sequence. Additionally, other registers which may need to be initialized for proper operation may be set at this point. For example, in some embodiments, a Test77 register may need to be written to with a zero value after the SIO reset as specified on page 37 of the Direct RDRAM -64/72 Mbit Data Sheet (execute a Broadcast SIO Register Write IOP: TEST77, DRA = 4Dh, DRD = OOOOh).<br>
SERIAL DEVICE ID ASSIGNMENT<br>
As indicated in block 620, serial device identification values (IDs) may be assigned next. In general, the software uniquely identifies each device on the channel to allow initialization operations to be targeted at individual devices. The serial device ID for each RDRAM is stored in the RDRAM INIT register (index 21h) in bits 4-0. After SIO reset, the default value of the serial device ID is 1Fh in all RDRAMs on the channel. Also, after reset, the Serial Repeater (SRP bit (RDRAM 021h [7]) is set to 1, enabling each RDRAM to propagate SIO data received on SIO0 to the RDRAM's SI01 pin, passing the SIO packet to the next RDRAM device. Since all devices have the same serial device ID after reset, an individual device may not be accessed prior to assigning unique serial IDs.<br>
Further details of the serial device enumeration performed by one embodiment are shown in Figure 7. In block 700, the variable SeriallDCount is initialized to zero. Next, as indicated in block 710, the SIO repeaters of all devices on the channel are disabled (Broadcast SIO Register Write IOP, INIT, DRA = 21h, DRD = 001 Fh).   This operation<br><br>
causes all serial device IDs to be set to 01fh. The SIO repeater bit is set to zero, so only the first device on the SIO channel can be accessed.<br>
Starting with block 710, the process loops through all devices on the channel and assigns a unique ID to each. The serial ID of the current device is set to SeriallDCount and the SIO repeater bit is enabled (SIO Register Write IOP: INIT, SDCA = 1Fh, DRA = 21h, DRD = 0080h + SeriallDCount). Next, whether the device is actually present and functioning in the system is tested as indicated in block 715. The RDRAM INIT register is read to determine if the same value which was just written is properly read back out (SIO Register Read IOP. INIT, SDCA = SeriallDCount, DRA = 21h).<br>
If the data matches (as tested in block 720), seriallDcount is incremented (block 725), and the SeriallDCount is checked to see whether a maximum number of devices (e.g., thirty-two) have been given IDs (block 730). If the SeriallDCount still indicates a valid serial ID, the next device is identified in block 705.<br>
If the SeriallDCount exceeds the maximum permissible value, or if the data did not match in block 720, then the last device has been given an ID, and a variable tracking the total number of devices may be set to the SeriallDCount as indicated in block 735. Finally, to disable any additional devices beyond the last permitted device, the SIO repeater of the RDRAM with the highest serial ID is disabled. Accordingly, any additional devices (i.e., improperly functioning devices or devices beyond the maximum, e.g., thirty-two) do not receive commands and therefore should not respond. As an additional check, the SPD information on the RIMMs may be examined to determine if the final device count is correct.<br>
GROUP DEVICE ID ASSIGNMENT<br><br>
Returning to Figure 6, after the unique serial IDs have been assigned and the S10 output of the last device disabled, group IDs are assigned based on memory device size as indicated in block 630. In one embodiment, the MCH supports up to thirty-two RDRAM devices and eight groups. Each group has up to four devices and has a group boundary access register (GBA) to define the group ID and the upper and lower addresses for each group. Thus, each GBA register may be programmed with a group ID and a nine bit upper address limit value. Unpopulated groups may have a value equal to the previous group and a group size of zero.<br>
Additionally, the flowchart in Figures 8A - 8C illustrates one embodiment of the process of enumerating group device IDs indicated in block 630. As indicated in block 800 in Figure 8A, a number of variables are initialized. Variables SeriallDCount, GroupDevicelDCount, RIMMCount, RIMMDeviceCount, and RIMMDeviceConfigNo are initialized to zero. A DRAMConfiglndex variable is initialized to a value indicating the largest core technology supported by the MCH.<br>
As indicated in block 805, data is read from the SPD memory of a module (module number RIMMCount) identifying the core technology of that module. This information may include the number of rows per device, the number of columns per device, the number of banks per device, and whether the banks are dependent or independent. Next, as indicated in block 810, the RIMMDeviceConfigNo is set by translating the core technology value read from the SPD into a value in a Group Architecture (GAR) register equivalent value.<br>
Next, as indicated in block 815, the RIMMDeviceCount variable is set to the number of devices indicated by the SPD memory for that RIMM. Thereafter, the device IDs may be assigned and associated register values set as indicated in block 820.    Further details of the<br><br><br>
process indicated in block 820 for one embodiment are shown in Figure 8B.<br>
In general, the enumeration process adds the number of RDRAM devices on a RIMM to the first Serial ID and then counts down until the RIMM is finished. Therefore, as indicated in block 822, whether RIMMDeviceConfigNo equals the DRAMConfiglndex is tested to determine whether group device IDs have been assigned for all devices in a particular core technology. If they are unequal, all devices have group IDs, and SeriallDCount is set to SeriallDCount plus RIMMDeviceCount (as indicated in block 830) and the process returns to Figure 8A as indicated in block 832. Additionally, if RIMMDeviceCount is zero (as tested in block 824) or MemberCount is zero (as tested in block 826), there are no more devices to give group IDs and the process returns to Fig. 8A as indicated in block 832.<br>
If RIMMDeviceCount and MemberCount are not zero, a GroupDevicelDCount is assigned to be the group device ID of the RDRAM with the serial ID equal to the present value of SeriallDCount as indicated in block 828. Next, the current group boundary address register (GBA) is updated to reflect the addition of the new device to this group as indicated in block 830. This may be accomplished by adding a value indicative of the device size to the previous value stored in that GBA register.<br>
Next, the GroupDevicelDCount is compared to four (the maximum number of devices per group) in block 832. If the group is full, the MCH Group Architecture Register (GAR) for that group is updated as indicated in block 834. The GAR is updated to properly indicate the group configuration (i.e., the number of banks and the DRAM technology (size)). In block 836, SerialDevicelDCount is incremented, MemberCount is     decremented,      GroupDevicelDCount      is      incremented,      and<br><br><br>
RIMMDeviceCount is decremented.   The process then returns to block 824.<br>
Returning to Figure 8A, if either RIMMDeviceCount or MemberCount is zero, RIMMCount is incremented as indicated in block 850. If RIMMCount is less than a maximum RIMMCount, as tested in block 855, then the process returns to block 805. If the RIMMCount has reached the last RIMM, the process continues in Figure 8C as indicated by block 860.<br>
Turning to Figure 8C, if MemberCount is zero (as tested in block 865), the device ID enumeration process ends. If, however, MemberCount is not zero, the next MCH group is selected to start enumerating the devices in the next DRAM technology as indicated in block 870. GroupDevicelDCount may be updated by adding three and performing a logical AND operation of the resulting value and OFFFCh.<br>
If GroupDevicelDCount is a maximum number devices allowed in the channel (e.g., thirty-two as tested in block 872), then the group ID enumeration process ends. If, however, fewer devices have been given group ID numbers, the DRAMConfiglndex is set to the next smallest core technology supported by the MCH as indicated in block 874. If the DRAMConfiglndex indicates that there are no smaller core technologies supported (e.g., DRAMConfiglndex is zero as tested in block 876), then the ID enumeration process ends. If there are more core technologies, seriallDCount and RIMMCount are reset to zero, as indicated in block 878, and the process returns to block 805 in Figure 8A.<br>
The psuedo-code below indicates operations that may be used to perform thejroup ID enumeration indicated by block 630 of Figure 6 in one embodiment.<br>
630.   Enumerate MCH device groups.<br><br><br>
630.1. Loop through RIMM SPD memory and group the devices on the RIMMs. The largest technology devices must be grouped in the lowest groups, with the technology size decreasing as the group #s increase.<br>
630.1.1.	Set MemberCount = MemberMax<br>
630.1.2.	Set SeriallDCount = 0. This is the Serial Device ID counter<br>
630.1.3.	Set GroupDevicelDCount = 0. This is the Group Device ID counter<br>
630.1.4.	Set RIMMCount = 0. This is the RIMM counter<br>
630.1.5.	Set RIMMDeviceCount = 0. This is the counter for the # of devices on a RIMM.<br>
630.1.6.	DRAMConfiglndex = Largest technology supported by MCH<br>
630.1.7.	Compute RIMM #RIMMCount's core technology 630.1.7.1 .RIMMDeviceConfigNo = core technology<br>
read from RIMMs SPD.<br>
630.1.8.	RIMMDeviceCount = # of RDRAM devices in RIMM #RIMMCount, read from the RIMM's SPD EEPROM.<br>
630.1.9.	Assign group device IDs and program MCH GAR and GBA registers for RIMM.<br>
630.1.630.1. If RIMMDeviceConfigNo !=<br>
DRAMConfiglndex, break to 630.1.10<br>
630.1.9.2.lf RIMMDeviceCount = 0, break to 630.1.10<br>
630.1.9.3.If MemberCount = 0, break to 630.1.10<br><br>
630.1.9.4.SIO Register Write lOP. DEVID, SDCA = SeriallDCount, DRA = 40h, DRD = GroupDevicelDCount.<br>
630.1.9.5.Program MCH GBA[GroupDevicelDCount SHR 2] = MCH GBA[GroupDevicelDCount SHR 2 -1] + RIMM #RIMMCount device size.<br>
630.1.9.6.lf GroupDevjcelDCount AND 011b = 0 630.1.9.6.1.  Program MCH<br>
GAR[GroupDevicelDCount SHR 2] = RIMMDeviceConfigNo<br>
630.1.9.7. Increment GroupDevicelDCount<br>
630.1.9.8.Increment SeriallDCount<br>
630.1.9.9.Decrement MemberCount<br>
630.1.9.10.	Decrement RIMMDeviceCount<br>
630.1.9.11.	Go to step 630.1.9.2<br><br>
630.1.10.	Increment RIMMCount<br>
630.1.11.	If RIMMCount 
630.1.12.	If MemberCount = 0 then break to step 10<br>
630.1.13.	Select next group for next RDRAM technology. 630.1.13.1.   GroupDevicelDCount =<br>
(GroupDevicelDCount + 011b) AND 011b<br>
630.1.14.	If GroupDevicelDCount = 32 then break to step 10<br>
630.1.15.	DRAMConfiglndex = next smallest DRAM technology<br>
630.1.16.	If DRAMConfiglndex = 0, then break to step 10<br>
630.1.17.	SeriallDCount = 0<br>
630.1.18.	RIMMCount = 0<br><br>
630.1.19. Go to step 630.1.7. This will begin searching the RIMMs for the next smallest RDRAM technology.<br>
Returning to Figure 6, after the group IDs have been assigned, the individual RDRAM devices may be brought out of powerdown mode and put into fast clock mode for normal operation as indicated in step 640. The individual RDRAM timing registers in the MCH and RDRAMs may be programmed. The REFB and REFR RDRAM control registers may also be initialized (Broadcast SIO Register Write IOP. REFB, DRA = 41h, DRD = OOOOh; Broadcast SIO Register Write IOP. REFR, DRA = 42h, DRD = OOOOh).<br>
The RDRAM devices may be reset by executing a Broadcast Set Reset IOP, and in some embodiments this may be done twice with delays after each reset. The RDRAMs are brought out of powerdown by executing a broadcast RDRAM power down exit IOP, and the fast clock mode is entered by executing a broadcast RDRAM Set Fast Clock Mode Initialization IOP.<br>
Thereafter, the RDRAM cores may be initialized as indicated in block 642. Further details of one embodiment of the RDRAM core initialization are shown in Figure 9. As indicated in block 900, the RDRAM devices are prepared for current calibration by writing an intermediate value to the appropriate RDRAM registers (Broadcast SIO Register Write IOP. CCA, DRA = 43h, DRD = 0040h; Broadcast SIO Register Write IOP. CCB, DRA - 44h, DRD = 0040h). Forty hexadecimal may be an appropriate intermediate value in an embodiment that has one hundred and twenty-seven possible current calibration levels. Starting at this intermediate value limits the total number of calibration cycles needed since the calibration value could only be off by approximately half than the full range of calibration values.<br><br><br>
Next, precharge operations are performed on each bank of each RDRAM device. To perform the precharge operations, the MCH counts up through the banks by two, first precharging odd banks, and then even ones. A bank index is set to zero in block 905. A broadcast precharge IOP is then executed as indicated in block 910. The bank index value is incremented by two as indicated in block 915, and the broadcast precharge is repeated for even banks until the bank index is found to be equal to a maximum number of banks (e.g., thirty two) in block 920.<br>
Once the maximum number of banks is reached, the bank index is set to one, and all odd banks are precharged. Once the bank index exceeds the maximum number of banks, the RDRAM Core Initialization IOP is executed six times as indicated in block 940.<br>
CHANNEL LEVELIZATION<br>
Returning to Figure 6, after the initialization of the RDRAM cores in block 642, the channel may be levelized as indicated in block 644. This process involves equalizing the sum of the RDRAM read response time and a propagation delay from the RDRAM to the MCH for all RDRAMs. In other words, once the channel Is levelized, all RDRAMs will provide data at the memory controller in the same number of bus cycles.<br>
The following psuedo-code indicates a sequence of steps that may be performed in one embodiment to implement the levelization process indicated in block 644.<br>
644.   Levelize the Rambus channel<br>
644.1. Phase 1: Determine MCH tRDLY field value.<br>
644.1.1.	SeriallDCount = MemberMax<br>
644.1.2.	MchTrdly = 0<br>
644.1.3.	Program MCH RDT:TRDLY field = MchTrdly<br><br>
644.1.4.	Compute the 32 bit address to test the RDRAM<br>
device for levelization.<br>
644.1.4.1.SIO Register Read IOP. DEVID, SDCA =<br>
SerialIDCount, DRA = 40th 644.1.4.2.The DRD (MCH 090h [15:0]) now contains<br>
the RDRAM's Device ID 644.1.4.3.DeviceTest Address = MCH GBA[(DRD<br>
SHR 2)-1] SHL 23 + ((DRD AND 011b) *<br>
device size in bytes (from GARfDRD SHR 2])<br>
644.1.5.	Do QWORD write operation to address DeviceTestAddress with TestPattem.<br>
644.1.6.	Do QWORD read operation to address DeviceTestAddress<br>
644.1.7.	If data read != TestPattem<br>
644.1.7.1.Increment MCH RDT:TRDLY field. 644.1.7.2.lf MCH RDT:TRDLY field 
644.1.8.	Else (if data read = TestPattem)<br>
644.1.8.1. MchTrdly = data read from MCH<br>
RDT:TRDLY field 644.1.8.2.if MchTrdly = 4 then break to step 644.2<br>
644.1.9.	Decrement SeriallDCount<br>
644.1.10.	If SeriallDCount &gt;= 0 then go to step 644.1.3<br>
644.2. Phase 2: Determine the RDRAM's levelization timing values<br>
644.2.1,   SeriallDCount = MemberMax 644.2.2.  Compute the 32 bit address to test the RDRAM<br>
device for levelization.<br>
644.2.2.1.SIO Register Read IOP. DEVID, SDCA = SeriallDCount, DRA = 40h<br><br>
644.2.2.2.The DRD (MCH 090h [15:0]) now contains the RDRAM's Device ID<br>
644.2.2.3.DeviceTestAddress = MCH GBA[(DRD SHR 2) -1] SHL 23 + ((DRD AND 011b) * device size in bytes (from GAR[DRD SHR 2])<br>
644.2.3.	Do QWORD write operation to address DeviceTestAddress with TestPattern.<br>
644.2.4.	Do QWORD read operation to address DeviceTestAddress<br>
644.2.5.	If, data read = TestPattern then break to step 644.2.8<br>
644.2.6.	If TCDLY field of RDRAMs 
644.2.6.1. Increment the RDRAMs TCDLY registers (TDAC &amp; TRDLY) according to the TCDLY support table.<br>
644.2.6.2.Break to step 644.2.3<br>
644.2.7.	Mark the RDRAM device to be disabled.<br>
644.2.8.	Decrement SeriallDCount<br>
644.2.9.	If SeriallDCount &gt;= 0 then go to step 644.2.2<br>
After levelization completes, one embodiment stores a number of powerdown recovery memory initialization values in the battery backed-up memory 590 as indicated in block 646. Notably, this operation may be performed at any other stage after the appropriate values have been determined by the initialization routine. The values are saved to preserve the initialization information determined by the initialization process to this point.<br><br>
When a low power state (e.g., suspend-to-RAM) is entered by the system, power to the MCH may be removed. Thus, if the initialization information is not preserved, the entire initialization process may have to be repeated. Storing key initialization information to a non-volatile memory may advantageously speed wake-up from such a low power state. The difficulty of storing such information is increased by the fact that the memory subsystem will not be functional until these values are restored.<br>
Any non-volatile memory which can be written to may be used to store the appropriate initialization information; however, a battery backed-up memory is present in many computer systems and therefore may be a convenient choice. In one embodiment, the registers below are stored in the memory 590.<br>
•	MCH Group Architecture (GAR) registers (040-047h): These registers indicate device configuration for each group such as the number of banks and the DRAM technology (size).<br>
•	MCH RDRAM Timing Register RDT (050h): This register defines the timing parameters for all devices in the channel.<br>
•	MCH DRAM Control (DRAMC) register (051 h): This register includes the Pool B Operation Select (PBS) bit, a memory transfer hub presence bit (MTHP), which specifies an operational mode of the MCH, and an Aperture Access Global Enable bit which prevents access to an aperture from any port before the aperture range and translation table are established.<br>
•	MCH Page Policy (PGPOL) Register (052h): This register specifies paging policy attributes include a DRAM Refresh Rate (DRR) and a RMC Idle Timer (RIT). The DRR field adjusts the DRAM refresh rate and the RIT field determines the number of host bus clock cycles that<br><br>
the memory controller will remain in the idle state before all the open pages are closed.<br>
•	MCH RPMR (053h): This register includes a Device Napdown Timer<br>
(DNT) field, an Active Devices in Pool A (ADPA) field, a Device Napdown<br>
Enable (DNE) field, and a Pool A Capacity (PAC) field. The DNT field<br>
specifies the number of host clocks the memory controller is idle before<br>
the least recently used device in Pool A is pushed out to Pool B. The<br>
ADPA field defines the maximum number of RDRAM devices in Pool A<br>
that can be in Active Read/Write or Active state at a time. The devices in<br>
Pool A that are not in Active ReaoVWrite or Active state are in standby<br>
state. The DNE bit (when set to 1) enables the channel inactivity counter<br>
to count continuous inactivity time. When the counter value exceeds the<br>
threshold specified by DNT, the least recently used device from Pool A is<br>
pushed to Pool B. The PAC field defines the maximum number of<br>
RDRAM devices that can reside in Pool A at a time. Devices that are not<br>
part of Pool A belong to Pool B.<br>
•	MCH Group Boundary Access (GBA) registers (060-6Fh): The GBA registers contain a group ID and a value indicating the upper address limit for the group.<br>
•	MCH Configuration Registers MCHCFG (OBE-BFh): These registers contain the Rambus Frequency &amp; DRAM Data Integrity Mode fields.<br>
Also, at this point powerdown configuration options may be programmed. In one embodiment, the self refresh and low power self refresh options are set (for each SeriallDCount: SIO Register Write IOP. INIT, SDCA = SeriallDCount, DRA = 21 h, DRD = 400h (LSR, if SPD supports) + 200h (PSR) + 80h (SRP)).<br>
Normal operation may start, as indicated in block 650, after a few more registers are programmed for normal operation. The page policy register is set to operate normally (PGPOL RIT field (MCH 052h [2:0]) to<br><br><br>
001b) since the page closing timer was effectively disabled for levelizing, and the power management features are enabled at this point via the RPMR register (MCH 053h). If the Pool B Select bit (MCH 051 h [6]) is configured for NAP operation, a broadcast NAP entry IOP may be executed to put all devices to the NAP state. In the same I/O instruction that sets the IIO bit, set the IC bit in RICM also to one so that normal operations of the MCH may commence.<br>
RESTORING THE CHANNEL WHEN EXITING A LOW POWER STATE<br>
After normal operation continues for some time, the system may enter a low power state due to system inactivity or for another reason, as indicated in block 1000 of Figure 10. One state which the system may enter is a suspend-to-RAM (STR) state in which the MCH loses values stored in its registers. After entering the STR state, an event which causes the system to exit STR may be sensed as indicated in block 1010. Accordingly, the BIOS powers up the MCH and other system components. The configuration registers of the MCH may be automatically reset to a default value in this process.<br>
Accordingly, to again access memory devices on the memory channel, at least some of the_ configuration register values are needed. The BIOS may cause the ICH 505 to access the battery backed-up memory 590 and restore the registers listed below (saved in block 646 of Figure 6).<br>
•	MCH GAR registers (040-047h)<br>
•	MCH RDT(050h)<br>
•	MCH DRAMC(051h)<br><br>
•	MCH PGPOL (052h)<br>
•	MCH RPMR (053h)<br>
•	MCH GBA registers (060-6Fh)<br>
•	MCH Configuration Registers MCHCFG (OBE-BFh)<br>
After restoring values to these registers, the MCH can once again access items stored in memory when the STR state was entered, including such items as the processor context if saved. The memory devices perform self-refresh in the STR state so other data is not lost.<br>
Next, the clock generator is started as indicated in block 1040. The proper Rambus channel frequency is read from the MCH MCHCFG register (MCH OBEh [11], which was restored in block 1030). After the clock is allowed to stabilize, the MCH RAC is initialized as indicated in block 1050. This may be accomplished" by executing the MCH RAC Initialization IOP. Additionally, the DRD register may be loaded with OOOOh and the MCH RAC control register load IOP executed to initialize a bus in the RAC (as discussed with respect to block 610).<br>
Next, current calibration is performed as indicated in block 1060. This may be performed as discussed with respect to block 642 and Figure 9. In the final iteration indicated by block 940, however, the IC bit in the RICM register may be set, allowing normal operations to immediately commence once the current calibration has completed. Thus, the resume from STR sequence may be substantially faster than the entire initialization sequence required when the system is first powered up since channel levelization, SPD querying, ID assignment, and a number of other initialization operations may be avoided.<br>
In conclusion, a method and apparatus for restoring a memory device channel when exiting a low power state is disclosed.    While<br><br><br>
certain exemplary embodiments have been described and shown in the accompanying drawings, it is to be understood that such embodiments are merely illustrative of and not restrictive on the broad invention, and that this invention not be limited to the specific constructions and arrangements shown and described, since various other modifications may occur to those ordinarily skilled in the art upon studying this disclosure.<br><br>
WE CLAIM:<br>
1.	A method comprising:<br>
storing a plurality of memory initialization values from a plurality of storage locations in a memory controller into a memory which maintains values during a power down state, the plurality of memory initialization values being necessary to access a system memory;<br>
entering the power down state;<br>
restoring the plurality of memory initialization values to the plurality of storage locations in the memory controller when the power down state is exited;<br>
executing a routine to derive one or more additional memory initialization values in response to exiting the power down state.<br>
2.	The method as claimed in claim 1 wherein entering the power down state comprises entering a suspend to random access memory state.<br>
3.	The method as claimed in claim 1 wherein storing the plurality of initialization values comprises storing the plurality of initialization values in a battery backed memory.<br>
4.	The method as claimed in claim 1 wherein storing the plurality of initialization values<br>
comprises:<br>
storing at least one architecture register value in the memory which maintains values during the power down state, the at least one architecture value indicating a memory organization for at least one memory device.<br><br>
5.	The method as claimed in claim 4 wherein storing at least one<br>
architecture register value comprises:<br>
storing a plurality of RDRAM group architecture register values.<br>
6.	The method as claimed in claim 1 wherein storing the plurality of<br>
initialization values comprises:<br>
storing a timing register value in the memory which maintains values during the power down state, the timing register value indicating timing values for a plurality of memory devices coupled to the memory controller.<br>
7.	The method as claimed in claim 1 wherein storing the plurality of<br>
initialization values comprises:<br>
storing a memory device control register value in the memory which maintains values during the power down state, the memory device control register value having a pool operation selection field, a memory transfer hub presence field, and an aperture access enable field.<br>
8.	The method as claimed in claim 1, wherein storing the plurality of<br>
initialization values<br>
comprises:<br>
storing a page policy value in the memory which maintains values during the power down state.<br>
9.	The method as claimed in claim 1 wherein storing the plurality of<br>
initialization values comprises:<br><br>
storing a power management register value in the memory which maintains values during the power down state.<br>
10.	The method as claimed in claim 1 wherein storing the plurality of<br>
initialization values comprises:<br>
storing at least one group boundary access value in the memory which maintains values during the power down state.<br>
11.	The method as claimed in claim 1 wherein storing the plurality of<br>
initialization values comprises:<br>
storing a frequency value in the memory which maintains values during the power down state.<br>
12.	The method as claimed in claim 1 wherein storing the plurality of<br>
initialization values comprises:<br>
storing a data integrity mode valuetin the memory which maintains values during the power down state.<br>
13.	The method as claimed in claim   1  wherein entering the power<br>
down state comprises:<br>
powering off the memory controller<br>
14.	The method as claimed in claim 13 further comprising:<br>
sensing a suspend terminating event; and<br>
powering up the memory controller.<br><br>
15.	The method as claimed in claim 1 comprising performing core initialization operations for a plurality of memory devices.<br>
16.	The method as claimed in claim 1 comprising:<br>
returning to normal operation by executing a plurality of initialization operations when a plurality of initialization operands are loaded into a memory controller control register.<br>
17.	The method as claimed in claim 16 wherein returning to normal<br>
operation comprises:<br>
starting a clock generator;<br>
executing a memory interface initialization operation; and<br>
performing core initialization for a plurality of memory devices.<br>
18.	The method of claim 1 wherein executing comprises:<br>
performing a current calibration sequence.<br>
19.	The method as claimed in claim 18 wherein performing a current calibration sequence comprises performing said current calibration sequence from a median calibration value.<br>
20.	The method as claimed in claim 18 wherein performing the current calibration comprises:<br>
executing a core initialization operation six times.<br><br>
21.	The method as claimed in claim 20 comprising: setting an initialization complete bit; and resuming normal memory access operations.<br>
22.	A system comprising: a processor;<br>
a memory controller coupled to the processor, the memory controller having a control register;<br>
a memory bus having a plurality of memory devices coupled thereto, the memory bus being coupled to the memory controller;<br>
a memory which maintains values during a power down state;<br>
an additional memory device coupled to the memory controller, the additional memory device being accessible to the memory controller prior to initializing the plurality of memory devices, the additional memory device containing a plurality of instructions which, if executed by the system, cause the system to perform operation comprising:<br>
storing a plurality of memory initialization values from a plurality of storage locations in the memory controller into the memory which maintains value during a power down state, the plurality of memory initialization values being necessary to access the plurality of memory devices on the memory bus;<br>
entering the power down state; end<br><br>
restoring the plurality of initialization values the plurality of storage locations in the memory controller when the power down state is exited; and<br>
executing a routine to derive one or more additional memory initialization values in response to exiting the power down state.<br>
23.	The system as claimed in claim 22 wherein the memory controller has a control circuit coupled to perform a plurality of initialization operations when a plurality of initialization operands are loaded into the control register during the process of returning to normal operation.<br>
24.	An article comprising a machine readable medium having stored thereon a plurality of instructions which, if executed by the machine, cause the machine to perform operations comprising:<br>
storing a plurality of memory initialization values from a plurality of storage locations in a memory controller into a memory which maintains values during a power down state, the memory initialization values being necessary to access a system memory;<br>
entering the power down state;<br>
restoring the plurality of initialization values the plurality of storage locations in the memory controller when the power down state is exited; and<br>
executing a routine to derive one or more additional memory initialization values in response to exiting the power down state.<br>
25.	The article as claimed in claim 24 wherein the machine readable<br>
medium is a storage device.<br><br>
26.     The article as claimed in claim 24 wherein the machine readable medium is a carrier wave.<br>
27.     A system comprising:<br>
a system main memory; main memory control logic;<br>
logic to store a plurality of memory initialization values from a plurality of storage locations in said main memory control logic into a memory which maintains values during a power down state, the plurality of memory initialization values being necessary to access a system memory;<br>
logic to restore said plurality of memory initialization values to the plurality of storage locations in the main memory control logic when the power down state is exited;<br>
logic to derive one or more additional memory initialization values in response to exiting the power down state.<br>
28.	The system as claimed in claim 27 wherein said logic to derive one or more additional memory initialization values comprises logic to perform a current calibration operation.<br>
29.	The system as claimed in claim 28 comprising logic to perform core initialization operations for a plurality of memory devices.<br>
30.	The system as claimed in claim 22 wherein executing comprises:<br>
performing a current calibration sequence.<br><br>
31.	The   system   as   claimed   in   claim   30   wherein   said   operations<br>
comprise:<br>
starting a clock generator;<br>
executing a memory interface initialization operation; and<br>
performing core initialization for a plurality of memory devices.<br>
32.	The article as claimed in claim 24 wherein executing comprises:<br>
performing a current calibration sequence.<br>
33.	The   article   as   claimed   in   claim   24   wherein   said   operations<br>
comprise:<br>
starting a clock generator;<br>
executing a memory interface initialization operation; and<br>
performing core initialization for a plurality of memory devices.<br>
Dated .	this     18th   day    of       May,   2001.<br>
[RITUSHKA NEGI]<br>
  OF REMFRY &amp; SAGAR<br>
   ATTORNEY FOR THE APPLICANTS<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWNhbmNlbGxlZCBwYWdlcygwNC0wNS0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-cancelled pages(04-05-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWNsYWltcyhncmFudGVkKS0oMDQtMDUtMjAwNSkuZG9j" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-claims(granted)-(04-05-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWNsYWltcyhncmFudGVkKS0oMDQtMDUtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-claims(granted)-(04-05-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWNvcnJlc3BvbmRlbmNlKDAxLTA4LTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-correspondence(01-08-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWNvcnJlc3BvbmRlbmNlKGlwbyktKDExLTA1LTIwMDQpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-correspondence(ipo)-(11-05-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWRyYXdpbmcoMDQtMDUtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-drawing(04-05-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWZvcm0gMSgxOC0wNS0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-form 1(18-05-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWZvcm0gMTMoMDctMDgtMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-form 13(07-08-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWZvcm0gMTkoMjYtMDMtMjAwNCkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-form 19(26-03-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWZvcm0gMWEoMDQtMDUtMjAwMSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-form 1a(04-05-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWZvcm0gMWEoMDctMDgtMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-form 1a(07-08-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWZvcm0gMihncmFudGVkKS0oMDQtMDUtMjAwNSkuZG9j" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-form 2(granted)-(04-05-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWZvcm0gMihncmFudGVkKS0oMDQtMDUtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-form 2(granted)-(04-05-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWZvcm0gMygwNC0wNS0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-form 3(04-05-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWZvcm0gMygxOC0wNS0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-form 3(18-05-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWZvcm0gNSgxOC0wNS0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-form 5(18-05-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWZvcm0tcGN0LWlwZWEtNDA5KDExLTA1LTIwMDQpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-form-pct-ipea-409(11-05-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLWZvcm0tcGN0LWlzYS0yMTAoMTEtMDUtMjAwNCkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-form-pct-isa-210(11-05-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLW90aGVyIGRvY3VtZW50cygxNy0wNC0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-other documents(17-04-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLXBldGl0aW9uIHVuZGVyIHJ1bGUgMTM3KDA0LTA1LTIwMDEpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-petition under rule 137(04-05-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLXBldGl0aW9uIHVuZGVyIHJ1bGUgMTM4KDA0LTA1LTIwMDEpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-petition under rule 138(04-05-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLXBvd2VyIG9mIGF1dGhvcml0eSgwNC0wNS0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-power of authority(04-05-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA1NzAtbXVtLXBvd2VyIG9mIGF1dGhvcml0eSgyNC0wNS0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00570-mum-power of authority(24-05-2001).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="213589-device-for-connecting-a-multilayered-web-by-ultrasound.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="213592-a-process-for-the-preparation-of-a-crystalline-polymorphic-form-of-a-hemisulphate-salt-compound.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>213590</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2001/00570/MUM</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>12/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>21-Mar-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>09-Jan-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>18-May-2001</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTEL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2200 MISSION COLLEGE BOULEVARD, SANTA CLARA, CALIFORNIA 95052, UNITED STATES OF AMERICA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>WILLIAM STEVENS</td>
											<td>111 ECONOME COURT, FOLSOM, CALIFORNIA 95360 USA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>PUTHIYA NIZAR</td>
											<td>1762 DARWIN WAY, EI DORADO HILLS, CALIFORNIA 95762, USA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 1/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US99/24755</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>1999-10-22</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09 / 186,049</td>
									<td>1998-11-03</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/213590-a-method-and-system-for-restoring-a-memory-device-channel by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 06:05:18 GMT -->
</html>
