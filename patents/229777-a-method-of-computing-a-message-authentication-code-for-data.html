<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/229777-a-method-of-computing-a-message-authentication-code-for-data by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:29:40 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 229777:A METHOD OF COMPUTING A MESSAGE AUTHENTICATION CODE FOR DATA</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD OF COMPUTING A MESSAGE AUTHENTICATION CODE FOR DATA</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>No. 3353/CHENP/2005 ABSTRACT &quot;A METHOD OF COMPUTING A MESSAGE AUTHENTICATION CODE FOR DATA&quot; The present invention relates to a method, system and computer program product for computing a message authentication code for data in storage of a computing environment. An instruction specifies a unit of storage for which an authentication code is to be computed. An computing operation computes an authentication code for the unit of storage. Figure 12.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
This invention relates to computer system architecture and particularly to new instructions which augment the IBM z/Architecture and can be emulated by other architectures.<br>
Before our invention IBM has created through the work of many highly talented engineers beginning with machines known as the IBM System 360 in the 1960s to the present, a special architecture which, because of its essential nature to a computing system, became known as "the mainframe" whose principles of operation state the architecture of the machine by describing the instructions which may be executed upon the "mainframe" implementation of the instructions which had been invented by IBM inventors and adopted, because of their significant contribution to improving the state of the computing machine represented by "the mainframe", as significant contributions by inclusion in IBM's Principles of Operation as  stated over the years. The First Edition of the z/Architecture Principles of Operation  which was published December, 2000 has become the standard published reference as SA22-7832-00.<br>
We determined that further new instructions would assist the art and could be included in a z/Architecture machine and also emulated by others in simpler machines, as described herein.<br>
The present invention provides a method as claimed in claim 1.<br>
The features of the preferred embodiments of the invention will be apparent to one skilled in the art from the following detailed description taken in conjunction with the accompanying drawings in which:<br>
Fig. 1 is an illustration of the Compute Message Authentication Code (KMAC) instruction in the RRE instruction format;<br>
Fig. 2 is a table showing the function codes for the KMAC instruction of Fig. 1;<br>
Fig. 3 is an illustration of the general register assignment for the KMAC instruction of Fig. 1;<br>
Fig. 4 illustrates the symbol used for Fit-Wise Exclusive Or;<br>
Fig. 5 illustrates symbol for DEA Encryption and Decryption;<br><br>
Fig. 6 illustrates the format for the parameter block for KMAC-Query;<br>
Fig. 7 illustrates the format for the parameter block for KMAC-DEA;<br>
Fig. 8 illustrates the operation of KMAC-DEA;<br>
Fig. 9 illustrates the format for the parameter block for KMAC-TDEA-128;<br>
Fig. 10 illustrates the operation of KMAC-TDEA-128;<br>
Fig. 11 illustrates the format for the parameter block for KMAC-TDEA-192;<br>
Fig. 12 illustrates the operation of KMAC-TDEA-192;<br>
Fig. 13 is a table showing the priority of execution for KMAC;<br>
Fig. 14 illustrates our cryptographic coprocessor; and<br>
Fig. 15 shows the generalized preferred embodiment of a computer memory storage containing instructions in accordance with the preferred embodiment and data, as well as the mechanism for fetching, decoding and executing these instructions, either on a computer system employing these architected instructions or as used in emulation of our architected instructions.<br>
The COMPUTE MESSAGE AUTHENTICATION CODE (KMAC) instruction will be discussed first, and then a preferred computer system, and, in the alternative, a computer system for emulating a computer system havafrng a different architecture for executing the instruction.<br>
COMPUTE MESSAGE AUTHENTICATION CODE (KMAC)<br><br>
Fig. 1 is an illustration of the Compute Message Authentication Code (KMAC) instruction in the RRE instruction format.<br>
A function specified by the function code in general register 0 is performed. Bits 16-23 of the instruction and the Rl field are ignored.<br>
Bit positions 57-63 of general register 0 contain the function code. Fig. 2 shows the assigned function codes. All other function codes are unassigned. Bit 56 of general register 0 must be zero; otherwise, a specification exception is recognized. All other bits of general register 0 are ignored.<br>
General register 1 contains the logical address of the leftmost byte of the parameter block in storage. In the 24-bit addressing mode, the contents of bit positions 40-63 of general register 1 constitute the address, and the contents of bit positions 0-39 are ignored. In the 31-bit addressing mode, the contents of bit positions 33-63 of general register 1 constitute the address, and the contents of bit positions 0-32 are ignored.<br>
In the 64-bit addressing mode, the contents of bit positions 0-63 of general register 1 constitute the address.<br>
The function codes for COMPUTE MESSAGE AUTHENTICATION CODE are shown in Fig. 2.<br>
All other function codes are unassigned. The query function provides the means of indicating the availability of the other functions. The contents of general registers R2 and R2 + 1 are ignored.<br>
For all other functions, the second operand is processed as specified by the function code using an initial chaining value in the parameter block and the result replaces the chaining value. The operation also uses a cryptographic key in the parameter block. The operation proceeds until the end of the second-operand location is reached or a CPU-determined number of bytes have been processed, whichever occurs first. The result is indicated in the condition code.<br>
The R2 field designates an even-odd pair of general registers and must designate an even numbered register; otherwise, a specification exception is recognized.<br><br>
The location of the leftmost byte of the second operand is specified by the contents of the R2 general register. The number of bytes in the second-operand location is specified in general register R2 + 1.<br>
As part of the operation, the address in general register R2 is incremented by the number of bytes processed from the second operand, and the length in general register R2 + 1 is decremented by the same number. The formation and updating of the address and length is dependent on the addressing mode.<br>
In the 24-bit addressing mode, the contents of bit positions 40-63 of general register R2 constitute the address of second operand, and are ignored; bits 40-63 of the updated address replace the corresponding bits in general register R_, carries out of bit position 40 of the updated address are ignored and, the contents of bit positions 32-39 of general register R_ are set to zeros. In the 31-bit addressing mode, the contents of bit positions 33-63 of general register R_ constitute the address of second operand, and the contents of bit positions 0-32 are ignored; bits 33-63 of the updated address replace the corresponding bits in general register R_, carries out of bit position 33 of the updated address are ignored, and the content of bit position 32 of general register R_ is set to zero. In the 64-bit addressing mode, the contents of bit positions 0-63 of general register R_ constitute the address of second operand; bits 0-63 of the updated address replace the contents of general register R_ and carries out of bit position 0 are ignored.<br>
In both the 24-bit and the 31-bit addressing modes, the contents of bit positions 32-63 of general register R2 + 1 form a 32-bit unsigned binary integer which specifies the number of bytes in the second operand; and the updated value replaces the contents of bit positions 32-63 of general register R2 + 1. In the 64-bit addressing mode, the contents of bit positions 0-63 of general register R2 + 1 form a 64-bit unsigned binary integer which specifies the number of bytes in the second operand; and the updated value replaces the contents of general register R2 + 1.<br>
In the 24-bit or 31-bit addressing mode, the contents of bit positions 0-31 of general registers R2 and R2 + 1, always remain unchanged.<br>
Fig. 3 shows the contents of the general registers just described.<br>
In the access-register mode, access registers 1 and R2 specify the address spaces containing the parameter block and second operand, respectively.<br><br>
The result is obtained as if processing starts at the left end of the second operand and proceeds to the right, block by block. The operation is ended when all source bytes in the second operand have been processed (called normal completion), or when a CPU-determined number of blocks that is less than the length of the second operand have been processed (called partial completion). The CPU-determined number of blocks depends on the model, and may be a different number each time the instruction is executed. The CPU-determined number of blocks is usually nonzero. In certain unusual situations, this number may be zero, and condition code 3 may be set with no progress. However, the CPU protects against endless reoccurrence of this no-progress case.<br>
When the chaining-value field overlaps any portion of the second operand, the result in the chaining value field is unpredictable.<br>
Normal completion occurs when the number of bytes in the second operand as specified in general register R + 1 have been processed.<br>
When the operation ends due to normal completion, condition code 0 is set and the resulting value in R2 + 1 is zero. When the operation ends due to partial completion, condition code 3 is set and the resulting value in R2 + 1 is nonzero.<br>
When the second-operand length is initially zero, the second operand and the parameter block are not accessed, general registers R2 and R2 + 1 are not changed, and condition code 0 is set.<br>
As observed by other CPUs and channel programs, references to the parameter block and storage operands may be multiple-access references, accesses to these storage locations are not necessarily block-concurrent, and the sequence of these accesses or references is undefined.<br>
Access exceptions may be reported for a larger portion of the second operand than is processed in a single execution of the instruction; however, access exceptions are not recognized for locations beyond the length of the second operand nor for locations more than 4K bytes beyond the current location being processed.<br>
Symbols Used in Function Descriptions<br>
The symbols of Figs. 4 and 5 are used in the subsequent description of the COMPUTE MESSAGE AUTHENTICATION CODE functions. For data-encryption-algorithm (DEA) functions, the DEA-key-parity bit in each<br><br>
byte of the DEA key is ignored, and the operation proceeds normally, regardless of the DEA-key parity of the key.<br>
Further description of the data-encryption algorithm may be found in Data Encryption Algorithm,   ANSI-X3.92.1981, American National Standard for Information Systems.<br>
KMAOQuery (Function Code 0)<br>
The locations of the operands and addresses used by the instruction are as shown m Fig. 3. The parameter block used for the KMAC-Query function has the format shown in Fig. 6.<br>
A 128-bit status word is stored in the parameter block. Bits 0-127 of this field correspond to function codes 0-127, respectively, of the KMAC instruction. When a bit is one, the corresponding function is installed; otherwise, the function is not installed.<br>
Condition code 0 is set when execution of the KMAC-Query function completes; condition code 3 is not applicable to this function.<br>
KMAC-DEA (Function Code 1)<br>
The locations of the operands and addresses used by the instruction are as<br>
shown in Fig. 3.<br>
The parameter block used for the KMAC-DEA function has the format shown in Fig. 7.<br>
The message authentication code for the 8-byte message blocks (Ml, M2, ..., Mn) in operand 2 is computed using the DEA algorithm with the 64-bit cryptographic key and the 64-bit chaining value in the parameter block.<br><br>
The message authentication code, also called the output chaining value (OCV), is stored in the chaining-value field of the parameter block. The KMAC-DEA operation is shown in Fig. 8.<br>
KMAC-TDEA-128 (Function Code 2)<br>
The locations of the operands and addresses used by the instruction are as<br>
shown in Fig. 3.<br>
The parameter block used for the KMAC-TDEA-12 8 function has the format shown in Fig. 9.<br>
The message authentication code for the 8-byte message blocks (Ml, M2, ..., Mh) in operand 2 is computed using the TDEA algorithm with the two 64-bit cryptographic keys and the 64-bit chaining value in the parameter block.<br>
The message authentication code, also called the output chaining value (OCV), is stored in the chaining-value field of the parameter block. The KMAC-TDEA-128 operation is shown in Fig. 10.<br>
KMAC-TDEA-192 (Function Code 3)<br>
The locations of the operands and addresses used by the instruction are as<br>
shown in Fig. 3.<br>
The parameter block used for the KMAC-TDEA-192 function has the format shown in Fig. 11.<br>
The message authentication code for the 8-byte message blocks (Ml, M2, ..., Mn) in operand 2 is computed using the TDEA algorithm with the three 64-bit cryptographic keys and the 64-bit chaining value in the parameter block.<br><br>
The message authentication code, also called the output chaining value (OCV), is stored in the chaining-value field of the parameter block. The KMAC-TDEA-192 operation is shown in Fig. 12.<br>
Special Conditions for KMAC<br>
A specification exception is recognized and no other action is taken if<br>
any of the following occurs:<br>
1.	Bit 56 of general register 0 is not zero.<br>
2.	Bits 57-63 of general register 0 specify an unassigned or uninstalled function code.<br>
3.	The R_ field designates an odd-numbered register or general register 0.<br>
4.	The second-operand length is not a multiple of the data block size of the designated function (see Figure 7-54 on page 7-92 to determine the data block size for COMPUTE MESSAGE AUTHENTICATION CODE functions).<br>
Resulting- Condition Code:<br>
0	Normal completion<br>
1	--<br>
2	--<br>
3	Partial completion<br>
Program Exceptions:<br>
•	Access (fetch, operand 2, cryptographic key; fetch and store, chaining value)<br>
•	Operation (if the message-security assist is not installed)<br>
•	Specification<br>
Programming Notes:<br>
1.	Bit 56 of general register 0 is reserved for future extension and should be set to zero.<br>
2.	When condition code 3 is set, the second operand address and length in general registers R2 and R2 + 1, respectively, and the chaining-value in the parameter block are usually updated such that the program can simply branch back to the instruction to continue the operation. For unusual situations, the CPU protects against endless reoccurrence for the no-progress case. Thus, the program can safely branch back to the instruction whenever condition code 3 is set with no exposure to an endless loop.<br><br>
3 . If the length of the second operand is nonzero initially and condition code 0 is set, the registers are updated in the same manner as for condition code 3; the chaining value in this case is such that additional operands can be processed as if they were part of the same chain.<br>
4. Before processing the first part of a message, the program must set the initial values for the chaining-value field. To comply with ANSI X9.9 or X9.19, the initial chaining value shall be set to all binary zeros.<br>
CRYPTO COPROCESSOR:<br>
The preferred embodiment provides a crypto coprocessor which can be used with the instructions described herein and to execute cipher messages and assist in a variety of chaining message tasks which can be employed for chained and cryptographic use with the appropriate instructions.<br>
Fig. 14 illustrates our cryptographic coprocessor which is directly attached to a data path common to all internal execution units on the general purpose microprocessor, which has multiple execution pipelines. The microprocessor internal bus (1) is common to all other execution units is attached to the cryptographic control unit (2), and the control unit watches the bus for processor instructions that it should execute.<br>
The cryptographic control unit provides a cryptographic coprocessor directly attached to a data path common to all internal execution units of the central processing unit on a general purpose microprocessor providing the available hardware (E0...En), or from a combination thereof in the preferred embodiment having multiple execution pipelines) for the central processing unit.  When a cryptographic instruction is encountered in the command register (3), the control unit (2) invokes the appropriate algorithm from the available hardware. Operand data is delivered over the same internal microprocessor bus via an input FIFO register (4).  When an operation is completed the a flag is set in a status register (6) and the results are available to be read out from the output FIFO register (5).<br>
The illustrated preferred embodiment of our invention is designed to be extensible to include as many hardware engines as required by a particular implementation depending on the performance goals of the system.  The data paths to the input and output registers (7) are common among all engines.<br><br>
The preferred embodiment of the invention cryptographic functions are implemented in execution unit hardware on the CPU and this implementation enables a lower latency for calling and executing encryption operations and increases the efficiency.<br>
This decreased latency greatly enhances the capability of general purpose processors in systems that frequently do many encryption operations, particularly when only small amounts of data are involved. This allows an implementation that can significantly accelerate the processes involved in doing secure online transactions.  The most common methods of securing online transactions involve a set of three algorithms.  The first algorithm is only used one time in a session, and may be implemented in hardware or software, while the other operations are invoked with every transaction of the session, and the cost in latency of calling external hardware as well as the cost in time to execute the algorithm in software are both eliminated with this invention.<br>
In Fig. 15 we have shown conceptually how to implement what we have in a preferred embodiment implemented in a mainframe computer having the microprocessor described above which can effectively be used, as we have experimentally proven within IBM, in a commercial implementation of the long displacement facility computer architected instruction format the instructions are used by programmers, usually today l'C" programmers. These instruction formats stored in the storage medium may be executed natively in a Z/Architecture IBM Server, or alternatively in machines executing other architectures. They can be emulated in the existing and in future IBM mainframe servers and on other machines of IBM (e.g. pSeries Servers and xSeries Servers). They can be executed in machines running Linux on a wide variety of machines using hardware manufactured by IBM, Intel, AMD, Sun Microsystems and others. Besides execution on that hardware under a Z/Architecture, Linux can be used as well as machines which use emulation by Hercules, UMX, FXI or Platform Solutions, where generally execution is in an emulation mode. In emulation mode the specific instruction being emulated is decoded, and a subroutine built to implement the individual instruction, as in a "C" subroutine or driver, or some other method of providing a driver for the specific hardware as is within the skill of those in the art after understanding the description of the preferred embodiment. Various software and hardware emulation patents including, but not limited to US 5551013, US6009261, US5574873, US6308255, US6463582, and US5790825 illustrate the variety of known ways to achieve emulation of an instruction format architected for a different machine for a target<br><br>
machine available to those skilled in the art, as well as those commercial software techniques used by those referenced above.<br>
In the preferred embodiment the existing pre-long displacement instruction formats for a non superscalar instruction form the operand storage address by the summing of the base register and 12 bit unsigned displacement or the base register, the index register, and the 12 bit unsigned displacement and the new long displacement instruction formats form the operand storage address by the summing of the base register and the 20 bit signed displacement or the base register, the index register, and the 20 bit signed displacement.<br>
As illustrated by Fig. 15, these instructions are executed in hardware by a processor or by emulation of said instruction set by software executing on a computer having a different native instruction set.<br>
In Fig. 15, #501 shows a computer memory storage containing instructions and data. The long displacement instructions described in this invention would initially stored in this computer.  #502 shows a mechanism for fetching instructions from a computer memory and may also contain local buffering of these instructions it has fetched.  Then the raw instructions are transferred to an instruction decoder, #503, where it determines what type of instruction has been fetched.  #504, shows a mechanism for executing instructions.  This may include loading data into a register from memory, #501, storing data back to memory from a register, or performing some type of arithmetic or logical operation.  This exact type of operation to be performed has been previously determined by the instruction decoder.  The long displacement instructions described in this invention would be executed here.  If the long displacement instructions are being executed natively on a computer system, then this diagram is complete as described above.  However, if an instruction set architecture, containing long displacement instructions, is being emulated on another computer, the above process would be implemented in software on a host computer, #505.  In this case, the above stated mechanisms would typically be implemented as one or more software subroutines within the emulator software. In both cases an instruction is fetched, decoded and executed.<br>
More particularly, these architected instructions can be used with a computer architecture with existing instruction formats with a 12 bit unsigned displacement used to form the operand storage address and also one having additional instruction formats that provide a additional displacement bits, preferably 20 bits, which comprise an extended signed<br><br>
displacement used to form the operand storage address. These computer architected instructions comprise computer software, stored in a computer storage medium, for producing the code running of the processor utilizing the computer software, and comprising the instruction code for use by a compiler or emulator/interpreter which is stored in a computer storage medium 501, and wherein the first part of the instruction code comprises an operation code which specified the operation to be performed and a second part which designates the operands for that participate.  The long displacement instructions permit additional addresses to be directly addressed with the use of the long displacement facility instruction.<br>
As illustrated by Fig. 15, these instructions are executed in hardware by a processor or by emulation of said instruction set by software executing on a computer having a different native instruction set.<br>
In accordance with the computer architecture of the preferred embodiment the displacement field is defined as being in two parts, the least significant part being 12 bits called the DL, DLl for operand 1 or DL2 for operand 2, and the most significant part being 8 bits called the DH, DH1 for operand 1 or DH2 for operand 2.<br>
Furthermore, the preferred computer architecture has an instruction format such that the opcode is in bit positions 0 through 7 and 40 through 47, a target register called Rl in bit positions 8 through 11, an index register called X2 in bit positions 12 through 15, a base register called B2 in bit positions 16 through 19, a displacement composed of two parts with the first part called DL2 in bit positions 20 through 31 and the second part called DH2 in bit positions 32 through 39.<br>
This computer architecture has an instruction format such that the opcode is in bit positions 0 through 7 and 40 through 47, a target register called Rl in bit positions 8 through 11, an source register called R3 in bit positions 12 through 15, a base register called B2 in bit positions 16 through 19, a displacement composed of two parts with the first part called DL2 in bit positions 20 through 31 and the second part called DH2 in bit positions 32 through 39.<br>
Furthermore, our computer architecture instructions having a long displacement facility has an instruction format such that the opcode is in bit positions 0 through 7 and 40 through 47, a target register called Rl in bit positions 8 through 11, a mask value called M3 in bit positions 12 through 15, a base register called B2 in bit positions 16 through 19, a<br><br>
displacement composed of two parts with the first part called DL2 in bit positions 20 through 31 and the second part called DH2 in bit positions 32 through 3 9.<br>
As illustrated, our preferred computer architecture with its long displacement facility has an instruction format such that the opcode is in bit posicions 0 through 7 and 40 through 47, an immediate value called 12 in bit positions 8 through 15, a base register called B2 in bit positions 16 through 19, a displacement composed of two parts with the first part called DL1 in bit positions 20 through 31 and the second part called DH1 in bit positions 32 through 39.<br>
Our long displacement facility computer architecture operates effectively when using new instructions which are created that only use the instruction format with the new 20 bit unsigned displacement.<br>
A specific embodiment of our computer architecture utilizes existing instructions which have the instruction formats that only have the 12 bit unsigned displacement and are now defined to be in the new instruction formats to have either the existing 12 bit unsigned displacement value when the high order 8 bits of the displacement, field DH, are all zero, or a 20 bit signed value when the high order 8 bits of the displacement, field DH, is non-zero.<br>
An apparatus for computing a message authentication code for data in<br>
storage of a computing environment, the apparatus comprising:	'<br>
means for specifying, via an instruction, a unit of storage for      _ &gt; which an authentication code is to be computed; and<br>
means for computing an authentication code for the unit of storage.     . , , <.></.><br>
WE CLAIM:<br>
1.	A method of computing a message authentication code for data in storage of a<br>
computing environment, said method comprising:<br>
specifying, via a microprocessor instruction, a unit of data for which an authentication code is to be computed; and<br>
computing, via the instruction, an authentication code for the unit of data;<br>
wherein the instruction is associated with a field which identifies a function code value, and a processor executing the instruction recognizes which encryption technique is to be used to compute the authentication code based on the function code value; characterized in that<br>
one additional function code value corresponds to a query operation which causes a status word to be stored in a parameter block, the status word having a plurality of bits, wherein when a bit of the status word has a first binary value then that bit corresponds to a function code value corresponding to an installed function and when a bit of the status word has a second binary value then that bit corresponds to a function code value corresponding to an uninstalled function.<br>
2.	The method as claimed in claim 1 wherein the computed authentication code is stored in a first operand.<br>
3.	The method as claimed in claim 1 wherein the encryption techniques which correspond to the function code values include a DEA 64-bit key cryptographic operation, a Triple DEA two 64-bit key cryptographic operation and a Triple DEA three 64-bit key cryptographic operation.<br>
4.	The method as claimed in claim 1 wherein the computing of the authentication code comprises providing a cryptographic key associated with the unit of data.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1DSEVOUC0yMDA1ICBDTEFJTVMucGRm" target="_blank" style="word-wrap:break-word;">3353-CHENP-2005  CLAIMS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGFic3RyYWN0IGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 abstract duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGFzc2lnbm1lbnQucGRm" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGNsYWltcyBkdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 claims duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGNvcnJlc3BvbmRlbmNlIG90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 correspondence others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGNvcnJlc3BvbmRlbmNlIHBvLnBkZg==" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 correspondence po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGRlc2NyaXB0aW9uIChjb21wbGV0ZSkgZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 description (complete) duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGRyYXdpbmdzIGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 drawings duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGZvcm0tMjYucGRm" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IGZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IHBjdCBzZWFyY2ggcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 pct search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IHBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 pct.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzM1My1jaGVucC0yMDA1IHBldGl0aW9uLnBkZg==" target="_blank" style="word-wrap:break-word;">3353-chenp-2005 petition.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="229776-a-device-and-a-method-for-recording-information-on-a-storage-medium.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="229778-rig-baking.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>229777</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>3353/CHENP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>27-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>20-Feb-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>12-Dec-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTERNATIONAL BUSINESS MACHINES CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>Armonk, New York 10504,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>LUNDVALL, Shawn</td>
											<td>10 Wantaugh Avenue, Poughkeepsie, NY 12603,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>SMITH, Ronald</td>
											<td>131 Cider Mill Loop, Wappingers Falls, NY 12590,</td>
										</tr>
										<tr>
											<td>3</td>
											<td>YEH, Phil, Chi-Chung</td>
											<td>88 Round Hill Road, Poughkeepsie, NY 12603,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 9/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/GB04/01925</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-04-30</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/435,910</td>
									<td>2003-05-12</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/229777-a-method-of-computing-a-message-authentication-code-for-data by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:29:41 GMT -->
</html>
