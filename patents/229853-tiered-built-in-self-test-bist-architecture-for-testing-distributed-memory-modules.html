<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/229853-tiered-built-in-self-test-bist-architecture-for-testing-distributed-memory-modules by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:34:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 229853:TIERED BUILT-IN SELF-TEST (BIST) ARCHITECTURE FOR TESTING DISTRIBUTED MEMORY MODULES</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">TIERED BUILT-IN SELF-TEST (BIST) ARCHITECTURE FOR TESTING DISTRIBUTED MEMORY MODULES</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A distributed, hierarchical built-in self-test (BIST) architecture for testing the operation of one or more memory modules is described. As described, the architecture includes three tiers of abstraction: a centralized BIST controller, a set of sequencers, and a set of memory interfaces coupled to memory modules. The BIST controller stores a set of commands that generically define an algorithm for testing the memory modules without regard to the physical characteristics or timing requirements of the memory modules. The sequencers receive the commands and generate sequences of memory operations in accordance with the timing requirements of the various memory modules. The memory interfaces apply the memory operations to the memory module in accordance with physical characteristics of the memory module, e.g., by translating address and data signals based on the row-column arrangement of the memory modules to achieve bit patterns described by the commands.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
TIERED BUILT-IN SELF-TEST (BIST) ARCHITECTURE FOR TESTING<br>
DISTRIBUTED MEMORY MODULES<br>
[0001] This application claims the benefit of U.S. Provisional Application Serial No. 60/456,452, entitled "An Apparatus and Method for a Memory Built-in Self-Test Engine/' filed March 20,2003.<br>
TECHNICAL FIELD<br>
[0002] The disclosure relates to electronic devices and, in particular, built-in self-test architectures for use in electronic devices.<br>
BACKGROUND<br>
[0003] Built-in self-test (BIST) units are now commonly incorporated into memory chips and other integrated circuits to test their functionality and reliability For example, a BIST unit incorporated into a particular memory module operates by writing and reading various data patterns to and from the associated memory module to detect any possible memory faults. By comparing the data written and the data subsequently returned from the memory module, the BIST unit is able to determine whether any memory cell of the memory module is faulty.<br>
[0004] The integrated BIST unit typically generates a variety of predetermined test patterns and asserts or deasserts an output signal based on the results of the memory test. A variety of algorithms may be used for detecting memory faults. For example, test patterns of all zeros, all ones, or a "checkerboard" pattern having alternating zeros and ones may be written throughout the memory cells. Moreover, the data may be written to the cells in any order, such as consecutively in an increasing or decreasing addressing scheme.<br>
[0005] Thus, BIST units are commonly included in many types of integrated circuits that use or otherwise incorporate memory modules and operate according to some predetermined algorithm to verify the functionality of the internal chip circuitry. However, electronic devices typically comprise more than the internal circuitry of a single chip. Normally they are constructed from many integrated circuit chips and many supporting components mounted on a circuit board.<br><br>
[0006] As the complexity of a typical computing device increases, the number of memory chips and other integrated circuits increases. For example, conventional computing devices typically include a plurality of the memory modules, which are often of different types. The memory modules within a single computing device may include various combinations of random access memory (RAM), read-only memory (ROM), Flash memory, dynamic random access memory (DRAM), and the like. These various types of memory modules often require different testing procedures, and have different bit densities, access speeds, addressing requirements, access protocols, and other particularities. As a result, a typical computing device may have a respective BIST unit for each memory module, and each BIST unit may be particularized to test the associated memory module.<br>
SUMMARY<br>
[0007] In general, the disclosure is directed to a distributed, hierarchical built-in self-test (BIST) architecture for testing the operation of one or more memory modules. As described, the architecture includes three tiers of abstraction: a centralized BIST controller, a set of sequencers, and a set of memory interfaces coupled to memory modules.<br>
[0008] The BIST controller provides centralized, high-level control over the testing of the memory modules. The BIST controller communicates centrally stored and maintained test algorithms to the sequencers for application to the memory modules. The BIST controller communicates the algorithms as a set of generalized commands that conform to a command protocol described herein. Moreover, the command protocol allows algorithms to be generically defined without regard to any timing requirements, physical organization or particular interface characteristics of the memory modules. As a result, a variety of test algorithms may easily be defined and centrally-maintained for distribution throughout an electronic device as needed. Consequently, common test patterns need not be redundantly stored within memory modules. [0009] The sequencers provide a second level of abstraction. The sequencers are distributed within device blocks that include one or more memory modules. In this manner, each sequencer is associated with one or more memory modules. The sequencers receive the high-level commands from BIST controller. In response to the commands, the sequencers issue a sequence of one or more memory operations to their<br><br>
respective memory interfaces to carry out the commands. For example, a sequencer may issue commands to sequentially access a range of addresses in response to a single command from the BIST controller. The sequencers report the results of the tests to the BIST controller.<br>
[0010] The sequencers control the application of the operations in accordance with the timing characteristics of their respective memory modules. For example, each of the sequencers controls the application speed of the sequence of operations in accordance with the access speed of the respective memory module. A single sequencer may control the application of the test algorithms to a plurality of memory modules that operate on a common clock domain. Consequently, logic for controlling application timing and sequencing of the test pattern domain is incorporated within the sequencers, and need not distributed within the individual memory modules or maintained by the BIST controller.<br>
[0011] The third tier, the memory interfaces, handles specific interface requirements for each of the memory modules. Each of the memory interfaces may be designed in accordance with the particular signal interface requirements and physical characteristics of the respective one of memory modules. Each memory interface receives memory operations from a controlling sequencer, and translates the memory operations, including associated address and data signals, as needed based on the physical characteristics of the respective memory module. For example, a memory interface may translate addresses supplied by the controlling sequencer based on the rows and columns of the memory module to fill a memory in a row-wise or column-wise fashion. As another example, the memory interface may translate the data to create specific bit patterns, such as a checkerboard pattern or as "striped" rows or columns in which adjacent rows or columns have opposing patterns.<br>
[0012] In one embodiment, a system comprises a built-in self-test (BIST) controller, a sequencer, and a memory interface coupled to a memory module. The BIST controller stores a set of commands defining an algorithm for testing the memory module. The sequencer receives the commands and issues one or more memory operations in accordance with the commands. The memory interface applies the memory operations to the memory module in accordance with physical characteristics of the memory module.<br><br>
[0013] In another embodiment, a system comprises a plurality of memory modules, a. built-in self-test (BIST) controller, and a plurality of sequencers. The BIST controller stores an algorithm for testing the memory modules. The plurality of sequencers are respectively coupled to different subsets of the memory modules, wherein each subset of the memory module is selected to include the memory modules having common clock domains. Each sequencer controls the application of the test algorithm to the respective subset of memory modules in accordance with the common clock domain of that subset of memory modules.<br>
[0014] In another embodiment, a device comprises a first-level built-in, self-test (BIST) means for issuing commands that define a BIST algorithm for a plurality of distributed memory modules having different timing requirements and physical characteristics, and a second-level BIST means for processing the commands to generate sequences of memory operations in accordance with the timing requirements of the memory modules. The device further comprises a third-level BIST means for generating translated address and data signals from the memory operations based on the physical characteristics of the memory modules to apply the BIST algorithm to the distributed memory modules. [001S] In another embodiment, a method comprises issuing commands from a centralized BIST controller to a sequencer, wherein the commands define a memory test algorithm to be applied to a set of distributed memory modules without regard to physical characteristics or timing requirements of the memory modules, and processing the commands with the sequencer to generate one or more sequences of memory operations in accordance with the timing requirements of the memory modules. The method further comprises applying the memory operations to the distributed memory modules to test the memory modules.<br>
[0016] The techniques described herein may achieve one or more advantages. For example, the techniques may allow a variety of test algorithms to easily be defined and maintained centrally in the form of generalized commands. The generalized commands can be distributed to sequencers located throughout an electronic device for interpretation and application to memory modules. As a result, common test algorithms need not be redundantly stored within the memory modules.<br>
[0017] In addition, the techniques may provide for the simultaneous application of algorithms to different memory modules, which may reduce overall test time and more thoroughly test for inter-memory effects. Moreover, the distributed, hierarchical nature<br><br>
of the architecture may allow the techniques to be readily applied to existing chip<br>
designs.<br>
[0018] The details of one or more embodiments are set forth in the accompanying<br>
drawings and the description below.   Other features, objects, and advantages will be<br>
apparent from the description and drawings, and from the claims.<br>
BRIEF DESCRIPTION OF DRAWINGS<br>
[0019] FIG. 1 is a block diagram illustrating an example electronic device having a<br>
distributed, hierarchical built-in self-test (BIST) architecture.<br>
[0020] FIG 2 is a block diagram illustrating an example embodiment of a BIST<br>
controller.<br>
[0021] FIG 3 is a timing diagram that further illustrates communication between the<br>
BIST controller and a set of sequencers for a single command of a generic BIST<br>
algorithm.<br>
[0022] FIG. 4 is a block diagram illustrating an example embodiment of a device block.<br>
[0023] FIG 5 is a block diagram illustrating an example embodiment of a sequencer.<br>
[0024] FIG. 6 is a block diagram illustrating an example embodiment of a memory<br>
interface.<br>
[0025] FIG 7 is a block diagram that illustrates an example embodiment of a data<br>
generation unit.<br>
[0026] FIG 8 is a block diagram illustrating an example data structure of a command<br>
issued by the BIST controller.<br>
[0027] FIGS. 9A-9E illustrate exemplary data structures in accordance with the<br>
command protocol described herein.<br>
[0028] FIG 10 is a flowchart illustrating example operation of the distributed, three-tier<br>
self-test architecture.<br>
DETAILED DESCRIPTION<br>
[0029] FIG. 1 is a block diagram illustrating an example electronic device 2 having a distributed, hierarchical built-in self-test (BIST) architecture. In particular, electronic device 2 includes a built-in self-test (BIST) controller 4 that provides centralized, high-level control over testing of device blocks 6A through 6N (collectively "device blocks<br><br>
6"). Each of device blocks 6 includes a sequencer 8, and a set of one or more memory interfaces 10 and one or more respective memory modules 12.<br>
[0030] lii general, BIST controller 4 provides and communicates test algorithms to sequencers 8 for application to device blocks 6. BIST controller 4 communicates each of the algorithms to sequencers 8 as a set of commands that conform to a generic and flexible command protocol. Each command specifies an operational code and a set of parameters that define one or more memory operations without regard to the physical characteristics or timing requirements of memory modules 12.   In this manner the command protocol allows a variety of test algorithms to easily be defined and distributed throughout electronic device 2.  Consequently, BIST controller 4 provides centralized control over the maintenance and distribution of the algorithms. As a result, common test algorithms need not be redundantly stored within device blocks 6. [0031] Sequencers 8 interpret and execute the test algorithms provided by BIST controller 4.    In particular, sequencers 8 receive high-level commands from BIST controller 4 that define a complete BIST algorithm. A single command, for example, may define a particular bit pattern to be written over a range of one or more addresses. In response to the commands, each of sequencers 8 issues one or more sequences of memory operations to their respective memory interfaces 10 to perform the commands. Moreover, sequencers 8 control the application of the operations in accordance with the timing characteristics of their respective memory modules 12.   For example, each of sequencers 8 controls the application speed of the sequence of operations in accordance with the access speed of the respective memory module 12. A single sequencer 8, e.g., sequencer 8A, may control the application of the test algorithms to one or more memory modules, e.g., memory modules 12A, that operate on a common clock domain. Memory modules 12 may be grouped and assigned to respective sequencers 8 based on any of a variety of criteria, such as clock domains for each of the memory modules and any pre-existing hierarchy or grouping of the memory modules. Consequently, logic for controlling application timing and sequencing of the test pattern for memory modules 12 operating on a common clock domain may be incorporated within a common sequencer 8, and need not distributed within the individual memory modules. [0032] Memory interfaces 10 handle specific interface requirements for each of memory modules 12. For example, each of memory interfaces 10 may be designed in accordance with the particular signal interface requirements and physical characteristics<br><br>
of the respective one of memory modules 12. As a result, each of memory interfaces 10 may be viewed as providing an interface "wrapper" around the particular interface signals, e.g., address, data, and control signals, for each respective memory module 12. In this manner, the BIST architecture of electronic device 2 comprises a three-tier, distributed arrangement including BIST controller 4, sequencers 8, and memory interfaces 10.<br>
[0033] Memory modules 12 may be any type of memory, such as random access memory (RAM), read-only memory (ROM), Flash memory, dynamic random access memory (DRAM), SDRAM, RDRAM, DDR-RAM, combinations thereof, and the like, and the techniques described herein are not limited in this regard. Moreover, electronic device 2 may be any device that incorporates memory modules, such as an embedded computing system, a computer, server, personal digital assistant (PDA), mobile computing device, mobile communication device, digital recording device, network appliance, mobile positioning device, and the like.<br>
[0034] FIG. 2 is a block diagram illustrating an example embodiment of BIST controller 4. In this illustrated embodiment, BIST controller 4 includes an algorithm memory 20 that stores a set of N test algorithms. As described below, each algorithm is defined in accordance with a set of binary commands. In one embodiment, for example, a complete algorithm may be specified by a set of 32-bit commands, where the commands define all necessary parameters for performing one or more sequences of memory operations over address ranges of device blocks 6 (FIG. 1) to test the functionality of memory modules 12.<br>
[0035] User interface 22 invokes algorithm controller 26 in response to external input, such as a control signal from an external testing apparatus. Alternatively, algorithm controller may be automatically invoked upon power-up of electronic device 2. Once invoked, algorithm controller 26 provides an algorithm select signal (ALGJ3ELECT) to multiplexer 24 to select one of the algorithms stored within algorithm memory 20. Once selected, a stream of binary commands that comprises the selected algorithm is applied to device blocks 6 as command data (CMD^DATA).<br>
[0036] Algorithm controller 26 controls the delivery of the algorithms to device blocks 6 based on acknowledge signals (SEQ_ACK) received from each sequencer 8 of the device blocks. In particular, algorithm controller 26 sequentially delivers each command of the selected algorithm to sequencers 8, and proceeds from one command to<br><br>
the next upon receiving an acknowledge signal from each of sequencers 8. In this manner, algorithm controller 26 ensures that each sequencer 8 has completed application of a current command to memory modules 12 via memory interfaces 10 before proceeding to the next command. Algorithm controller 26 may be programmatically or statically configured to establish the number of device blocks 6 and, in particular, sequencers 8 that are present within electronic device 2. In addition, algorithm controller 26 may be programmatically configured to apply a given algorithm to one, all, or any combination of memory modules 12 using any combination of device blocks 6.<br>
[0037] In addition to the algorithms stored in algorithm memory 20, user interface 22 may programmably receive algorithms via external input. User interface 22 delivers the received algorithms to multiplexer 24 in a form similar to that of the stored algorithms, i.e., a sequence of binary commands in which each command defines a test within the overall algorithm. In this manner, BIST controller 4 provides a centralized, first tier of the three-tier, distributed self-test architecture.<br>
[0038] FIG. 3 is a timing diagram that further illustrates communication between BIST controller 4 and sequencers 8 for a single command of a generic BIST algorithm. As illustrated, at a time Tl, BIST controller 4 asserts the command request (CMDJREQ) interconnects, and communicates a current command of the algorithm on the CMDJDATA interconnects.<br>
[0039] Upon receiving and applying the command, sequencers 8 assert a corresponding SEQ_ACK signal. For example, in the illustrated example, each of sequencers 8 assert respective signals SEQ_ACK[1], SEQ_ACK[2], SEQ_ACK[N] and SEQ_ACK[0] at times T2, T3, T4 and T5, respectively. In response, BIST controller 4 de-asserts the command request (CMDJREQ) signal at a time T6, causing sequencers 8 to de-assert their respective SEQ_ACK signal. BIST controller 4 asserts SEQSJOONE signal when all SEQ_ACK signals have been de-asserted, allowing BIST controller 4 to initiate another command at a time T7.<br>
[0040] FIG. 4 is a block diagram illustrating an example embodiment of a device block, e.g., device block 6A, in more detail. As illustrated, device block 6A includes sequencer 8A, a set of memory interfaces 10A-10C (collectively "memory interfaces 10"), and a set of memory modules 12A-12C (collectively "memory modules 12"). As illustrated in FIG. 4, each of memory interfaces 10 corresponds to a respective memory module 12.<br><br>
Sequencer 8A may be programmatically and/or statically configured to establish the number of memory interfaces 10 to be controlled, as well as the characteristics, e.g., maximum address, for the largest of memory modules 12.<br>
[0041] FIG 5 is a block diagram illustrating an example embodiment of a sequencer, e.g., sequencer 8A, in more detail. Sequencer 8A receives high-level commands from BIST controller 4 that collectively define a BIST algorithm. As illustrated in detail below, BIST controller 4 issues the commands in a generic, flexible format, and a single command may define a particular bit pattern to be written over a range of one or more addresses,<br>
[0042] In general, sequencer 8A receives the generic BIST commands, and controls the application of each command as a sequence of one or more memory operations applied to a set of respective memory modules. In the illustrated embodiment, sequencer 8A includes a command parser (CMD PARSER) 30 that receives command data (CMDJDATA) from BIST controller 4. Command parser 30 processes the received command to identify the specified operation, e.g., by identifying an operational code (op-code) specified by the command.<br>
[0043] Based on the specified operation, command parser 30 may extract one or more parameters from the command, and select a corresponding one of command controllers (CMD CONTROLLER) 34A-34N. In other words, each one of command controllers 34 corresponds to a different command that may be specified by CMDJDATA. Command parser 30 invokes the selected command controller 34, and passes the parameters extracted from the received command. Although illustrated separately, command controllers 34 may be combined and/or integrated into a single functional block having logic to perform each of the supported commands. [0044] In response to each command, the invoked one of command controllers 34 issues a sequence of one or more operations to each memory interface 10. In particular, the invoked one of command controllers 34 sequentially drives the appropriate command control signals (CMD__CTRL_SIGNALS) to carry out each operation of the sequence. The command control signals may include signals to provide a memory address and data to the receiving memory interfaces 10 and to direct the receiving memory interfaces to invert bits, perform read or write operations, invert rows, and the like, as further described below.<br><br>
[0045] Moreover, command controller 34 controls the application of the operations in accordance with the timing characteristics of their respective memory modules 12. Consequently, logic for controlling application timing and sequencing of the operations for memory modules 12 operating on a common clock domain may be incorporated within a common sequencer 8, and need not distributed within the individual memory modules.<br>
[0046] Sequencer 8A receives data from the tested memory modules 12, e.g., via signals MEM[0]_DOUT throughout MEM[N]_DOUT, and selectively communicates the data back to BIST controller 4 or an external device via multiplexer 37 and data selection signal 39. In this manner, sequencers 8 allow for the analysis of the data to identify any failures.<br>
[0047] Thus, sequencers 8 allow BIST controller 4 to centrally manage the storage and issuance of algorithms using generic and flexible command format. Sequencers 8 receive the generic BIST commands in accordance with the command protocol, and control the application of the commands by generating and issuing sequences of one or more memory operations for application to a set of respective memory modules 12, thereby providing a second tier of the distributed, hierarchical self-test architecture. [0048] FIG 6 is a block diagram illustrating an example embodiment of a memory interface 41 that provides the final layer of abstraction of the distributed BIST architecture by handling specific interface requirements for a respective memory module 12.<br>
[0049] In the illustrated embodiment, memory interface 41 includes a layer of multiplexers 45,46 that isolates the memory module 12 from normal functionality when electronic device 2 is operating in BIST mode. In particular, under normal operating conditions, BIST enable (BIST_EN) is de-asserted, causing multiplexers 45,46 to select the address / control signals (ADDR/CTRL) and data signals (DATA), e.g., as provided by a programmable processor. When electronic device 2 is operating in BIST mode, however, the BIST enable signal causes multiplexers 45,46 to select the BIST address / control signals (BIST_ADDR/CTRL) and the test data provided by a respective higher-level sequencer. In this manner, the sequencer controls multiplexers 45, 46 of memory interface 41 to selectively isolate the respective memory module, thereby allowing BIST algorithms to be applied to that memory module.<br><br>
[0050] Memory interface 41 further includes a data generation unit 44 that receives BISTJDATA signals and default data (DEFAULT_DIN) as provided by the sequencer 8, and generates transformed BIST data signals 49 (BIST_DATA_T) based on control signals (BIST_DATA_GEN„CTRL) provided by the sequencer and the specific physical characteristics of the corresponding memory module 12. More specifically, as described in further detail below, data generation unit 44 generates the exact data (RAMJDIN) applied to the memory inputs during each operation of the algorithm. Data generation unit 44 generates the transformed BIST data based on the physical configuration, e.g., physical row and column configuration, of the respective memory module 12, as well as the bit pattern specified by sequencer 8A, e.g., checkerboard, inverted, and the like.<br>
[0051] For example, sequencer 8 may request a checkerboard bit pattern that requires columns of data within the memory module to alternate between ones and zeros. Different memory modules 12, however, may be arranged with different row and column configurations. As a result, the memory cell for a given address may be located in a different row and column for memory modules 12 having different row-column configurations. For example, a 256 bit memory module 12 may be organized as 128 rows and 2 columns, 32 rows by 8 columns, 16 rows by 16 columns, and the like. As a result, writing a particular pattern throughout this matrix, such as a checkerboard pattern, requires knowledge of the specific row-column configuration of the memory module. Data generation unit 44 processes the data provided by the sequencer 8, and transforms that data, e.g., inverts the data, as needed to ensure the desired bit pattern is correctly written, as described in further detail below.<br>
[0052] Similarly, address generation unit 42 generates the address applied to the memory module 12 based on the addressing requirements specified by sequencer 8A and the physical configuration of the rows and columns of the memory module. For example, in some BIST tests, sequencer 8A directs memory interface 41 to write BIST data in a row (or column) first fashion, i.e., requiring each row (or column) to be completely written before proceeding to the next row (or column). As these requirements are specific to the row and column configuration, address generation unit 42 transforms the address provided by sequencer 8A to an appropriate to traverse an entire row (or column) before proceeding.<br><br>
[0053] As a result, the sequencer is able to issue operations by sequentially traversing an address space defined by the respective command, limited by the maximum-sized memory module associated with that sequencer. Each memory interface, e.g., memory interface 41, transforms the received address as needed to apply the operation to an appropriate memory cell. For example, for a column first BIST algorithm, the sequencer 8 issues the operations to the addresses in sequence, while address generation unit 42 computationally transforms the received address to access memory cells that fall within along the columns of. the memory module 12. In this example, address generation unit 42 transforms the addresses to access the memory module \2 in a column-wise fashion from a lowest-significant column to a highest-significant column based on whether the sequencer 8 is incrementing or decrementing through the address space.<br>
[0054] Comparator 48 that determines whether the data (RAMJDOUT) read from the memory module 12 equals the data last written to that address of the memory module as expected. When the comparison fails, i.e., when the data read from the memory module 12 does not equal the previously written data, comparator 48 asserts the BIST_FAIL signal to indicate that a memory error has been detected.<br>
[0055] In this manner, memory interface 41 processes the sequential memory operations issued by the higher-level sequencer, and transforms the data and addresses provided by the sequencer as needed based on the particular physical characteristics of the memory module, thereby providing a third tier of the distributed, hierarchical self-test architecture. As a result, the sequencer is able to issue operations for complex BIST algorithms without requiring detailed knowledge regarding the physical characteristics and capacities of each memory module 12.<br>
[0056] FIG 7 is a block diagram that illustrates an example embodiment of data generation unit 44 (FIG 6). In the illustrated embodiment, data generation unit 44 receives a BISTJDATA signal, a default data signal (DEFAULT_DIN) provided by the sequencer 8. In addition, data generation unit 44 receives a number of control signals in the form of BISTJNVERTJBITS, BISTJNVERTJROWS, LSBJtOW_ADDR, and BIST_WRTTE. Based on the received data and these control signals, data generation unit 44 generates transformed BIST data signals 49 (BISTJDATAJT) based on control signals (BISTJDATAJJENJ^TRL) provided by the sequencer 8 and the specific physical characteristics of the corresponding memory module 12.<br><br>
[0057] In particular, the sequencer 8 asserts and deasserts the invert bits signal (BISTJNVERTJBITS), the invert rows signal (BISTJNVERTJROWS), and the invert columns signal (not shown) to specify data patterns, such as solid, checkerboard, horizontal and vertical striped data patterns. If neither the invert bits nor the invert rows signals are asserted, then the BIST_DATA signal passes through XOR gates 52, 54 without modification. As a result, data generation unit 44 generates the transformed data signal 49 (BISTJDATAJT) to fill the memory module 12 with the data dictated from the sequencer 8 without modification.<br>
[0058] If the BISTJNVERTJIOW signal is set then data generation unit 44 inverts the values every time a row is crossed, as indicated by the least significant row address bit (LSBJR.OW_ADDR). As a result, AND gate 50 causes XOR gate 52 to invert the values dictated by the sequencer, and thereby invert values written to neighboring rows. Similar functionality may be provided to invert values as columns are crossed. When the BISTJDWERT_BITS signal is asserted, data generation unit 44 automatically inverts the values dictated by the sequencer. This may be useful in inverting values between corresponding cells of the different matrices.<br>
[0059] The DEFAULT_ DIN field establishes a default data value applied to the memory modules during read operations for memory modules 12. Multiplexer 56 selects between the DEFAULT JOIN data and the data generated by XOR gate 54 based on whether a write or a read operation is being performed, as indicated by the BIST_WRITE signal.<br>
[0060] FIG 8 is a block diagram illustrating an example data structure of a command issued by BIST controller 4. In the illustrated embodiment, command 60 includes a sequencer identifier (ID) 62, and a payload 64. Sequencer ID 62 identifies a sequencer, e.g., sequencer 8A, to which command 60 is being issued, as described in further detail below.<br>
[0061] BIST controller 4 broadcast commands to all sequencers 8, or may issue a command in unicast fashion to a particular one of the sequencers. In particular, BIST controller 4 sets sequencer ID 62 to a unique identifier for one of sequencers 8 to send a unicast command to that sequencer. For a broadcast command, BIST controller 4 sets sequencer ID 62 to a broadcast identifier, such as 0x0.<br>
[0062] Payload 64 of command 60 carries binary data that defines the command itself. In particular, payload 64 includes an operational code (OP CODE) 66 and a set of<br><br>
parameters 68. In general, OP CODE 66 specifies a particular function to be performed by the receiving sequencers 8. The following table enumerates an exemplary set of operational codes:<br><br>
[0063] In one embodiment, OP CODE 66 and parameters 68 comprise three bits and twenty-nine bits, respectively, to form a 32-bit command. The format and meaning of parameters 68 is dependent upon the type of command, as specified by OP CODE 66. [0064] FIG. 9A illustrates an example data structure of parameters 68 for the RESET command. As illustrated, the only relevant bit of parameters 68 is bit 28, which can be asserted or de-asserted to selectively enable and disable BIST mode. When asserted, the receiving sequencers 8 enter a mode for applying test algorithms to test the respective device blocks 6. When de-asserted, the receiving sequencers reset and terminate the current algorithm.<br>
[0065] FIG 9B illustrates an example data structure of parameters 68 for the EXECUTE command. As illustrated, for the EXECUTE command, parameters 68 directs the receiving sequencers 8 to apply a sequence of memory operations over a range of addresses in accordance with the particular timing characteristics of their respective memory modules 12.<br><br>
[0066] Once received, by default, sequencers 8 repetitively execute the specified memory operation over the address range of the largest memory module 12 within the respective device block 6. However, if SINGLE ROW (SR) bit is enabled, sequencers 8 execute the defined sequence of memory operations for all columns of the memory module 12 that has the largest column-bit option while maintaining the row address constant.<br>
[0067] When applying the sequence of memory operations, sequencers 8 either increment or decrement through the address range supported by the largest of the memory modules 12 within their respective device blocks 6 based on the state of the ADD INC/DEC bit of parameters 68. If ADD INC/DEC is asserted, for example, sequencers 8 apply the defined memory operations to each address starting from zero and proceeding to the maximum addresses. If ADD INC/DEC is deasserted, however, sequencers 8 apply the defined memory operations to each address starting from the maximum address and decrementing to zero. The DEF DIN field establishes a default data value applied to the memory modules 12 during read operations for the memory modules.<br>
[0068] The rippling row (RR) field directs sequencer 8 to apply the defined memory operations in a column-wise fashion, i.e., by applying the operations to an entire column before proceeding to the next column. In other words, each of sequencers 8 hold the column address constant while applying the memory operations and "rippling" the row address.<br>
[0069] The invert bits (IB) field, invert rows (IR), and invert columns (IC) fields can be used to specify data patterns for testing memory modules 12, such as solid, checkerboard, horizontal and vertical stripes data patterns. More specifically, if BIST controller 4 does not set either of the IR and IC fields, then the receiving sequencers 8 direct the memory interfaces 10 to fill memory modules 12 with the values dictated from the sequencer. If the IR field is set, then the values dictated by the sequencers 8 will have inverted values written to neighboring rows. Similarly, if the IC field is set, then the values dictated by the sequencers 8 will have inverted values written to neighboring columns. As a result, if both the IR field and the IC field are set, values are inverted between each column and between each row to create a checkerboard pattern within the memory modules. Finally, as described above, a given memory module 12 may be configured as more than one matrix. If the invert bits (IB) field is set, then the<br><br>
memory interfaces 10 automatically invert the values dictated by sequencer 8 between corresponding cells of the different matrices.<br>
[0070] Operations fields (OP1 - OP8) can be used to define a set of operations to be applied to each memory address. For example, each operation field, such as OP1, may comprise two bits. The first bit may be asserted or deasserted to indicate whether the operation is a read or a write. The second bit may be set based on the data to be written, i.e., a zero or a one. The number of operations (NUM OPS) field instructs sequencers 8 as to how many operations have been defined for application to each memory address. In this manner, a single command may be used to generically define a step within an overall BIST algorithm, and each step may define one or more operations to be applied to each address of the memory modules 12 with device blocks 6 of the receiving sequencers 8.<br>
[0071] FIG 9C illustrates an example data structure of parameters 68 for the TEST MEM command. For this command, parameters 68 include an FA/ BIST bit to interpret the TEST MEM command as a failure analysis command and as a BIST command. When set to failure analysis command, the value specified by the MEM ID field is used by the receiving sequencers 8 to select the data output of a specific one of memory modules 12 for failure analysis. When set to a BIST command, the value specified by the MEM ID field is used by the receiving sequencers 8 to select the data output of a specific one of memory interface 10 for participation within a particular test. In this manner, the algorithm can be selectively applied to individual memory modules 12 within a device block 6. The MEM BUS SLICE field is used to indicate which portion of the multiplexed data bus from the memory modules 12 is used for the failure analysis.<br>
[0072] FIG 9D is an example data structure of parameters 68 for the SET ADDRESS command. For this command, parameters 68 includes and address field (ADDRESS) that sets a specific memory address for application of a BIST step. This may be useful in conjunction with the SINGLE WORD ACCESS command. Parameters 68 also include a limit (LIMIT) field for specifying a maximum address limit for the test algorithm. In one embodiment, the LIMIT field comprises a 2-bit data field for setting the limit to: (1) the maximum address of the largest of the memory modules 12 of the device block 6, (2) the maximum address divided by two, (3) the maximum address divided by four, and (4) the maximum address divided by eight.<br><br>
[0073] FIG 9E is an example data structure of parameters 68 for the SINGLE WORD ACCESS command. For this command, parameters 68 includes an enable address change (ENADC) bit that controls whether the receiving sequencers 8 should change their respective current BIST addresses after applying the step. If enabled, the address increment / decrement (ADD INC/DEC) bit controls whether the current BIST address should be incremented or decremented. The invert bits (IB) field, invert row (ER), and invert column (IC) fields can be used to specify data patterns for testing memory modules 12, such as solid, checkerboard, horizontal and vertical stripes data patterns, as described above in reference to the EXECUTE command. The data field (DATA) is used to supply a default value for input data for read operations of the tested memory modules 12.<br>
[0074] Table 2 illustrates an example checkerboard BIST algorithm stored and issued by BIST controller 4 in accordance with the described command protocol. As illustrated, a relatively complex checkerboard memory test algorithm can be described<br><br>
[0075] Table 3 illustrates an example "Blanket March" BIST algorithm stored and issued by BIST controller 4 in accordance with the described command protocol. As illustrated, this memory test algorithm can be described in as few as six commands using the command protocol. Each of the commands directs the receiving sequencers 8 to issues sequences of memory operations that traverse the entire memory space in a defined direction. Moreover, several of the commands direct the sequencers to apply multiple memory operations to each address within the available memory space. In this manner, complex BIST algorithms can be easily distributed throughout and applied by the constituent components of the hierarchical self-test architecture.<br><br><br>
[0076] FIG. 10 is a flowchart illustrating example operation of the electronic device 2<br>
and, in particular, the distributed, three-tier self-test architecture of BIST controller 4,<br>
sequencers 8, and memory interfaces 10.<br>
[0077] Initially, BIST controller 4 selects one of the algorithms stored within an internal<br>
algorithm memory, e.g., algorithm memory 20 (70).   Upon selecting the algorithm,<br>
BIST controller 4 issues the first command defined by the algorithm to one or more of<br>
sequencers 8 (72).<br>
[0078] Each receiving sequencer 8 parses the command to identify the defined op-code<br>
and corresponding parameters (78).   For memory access commands, each receiving<br>
sequencer 8 initializes a starting address defined by the command (80). Next, sequencer<br>
8 issues a memory operation, i.e., generates the appropriate address, data and control<br>
signals (82).<br>
[0079] In turn, each receiving memory interface 10 translates the data and address<br>
signals based on the physical characteristics of each respective memory module 12 (92,<br><br>
94), and applies the translated signals to the memory modules (96). In addition, for read memory accesses (97), memory interfaces 10 automatically compares the data read from the respective memory modules 12 with the expected data (98). Based on the comparison, memory interfaces 10 update respective BIST failure signals to report the status of the tested memory module 12 (100).<br>
[0080] Once the memory operation has been issued by the memory interfaces 10, sequencers 8 determine if additional operations are to be applied to the current memory address within the sequence (84). If so, sequencers 8 issue the commands to memory interfaces 10 in similar fashion (82). If additional operations are not required, sequencers 8 update the address (86) and determine whether the entire address range defined by the command has been sequenced or whether additional addresses remain (88). When the entire address range has been sequenced and the memory operations have been applied to the addresses within the range, sequencers 8 issue acknowledge signals to BIST controller 4 (90).<br>
[0081] Upon receiving acknowledgements from each of sequencers 8 targeted with the command (74), BIST controller 4 determines whether the last command for the selected algorithm has been issued. If not, BIST controller 4 repeats the process and issues the additional commands (72). Once all of the commands have been issued and applied by sequencers 8 and memory interfaces 10 (76), BIST controller 4 terminates the current BIST test.<br>
[0082] Various embodiments have been described. These and other embodiments are within the scope of the following claims.<br><br><br><br><br><br>
TIERED BUILT-IN SELF-TEST (BIST) ARCHITECTURE FOR TESTING<br>
DISTRIBUTED MEMORY MODULES<br>
[0001] This application claims the benefit of U.S. Provisional Application Serial No. 60/456,452, entitled "An Apparatus and Method for a Memory Built-in Self-Test Engine/' filed March 20,2003.<br>
TECHNICAL FIELD<br>
[0002] The disclosure relates to electronic devices and, in particular, built-in self-test architectures for use in electronic devices.<br>
BACKGROUND<br>
[0003] Built-in self-test (BIST) units are now commonly incorporated into memory chips and other integrated circuits to test their functionality and reliability For example, a BIST unit incorporated into a particular memory module operates by writing and reading various data patterns to and from the associated memory module to detect any possible memory faults. By comparing the data written and the data subsequently returned from the memory module, the BIST unit is able to determine whether any memory cell of the memory module is faulty.<br>
[0004] The integrated BIST unit typically generates a variety of predetermined test patterns and asserts or deasserts an output signal based on the results of the memory test. A variety of algorithms may be used for detecting memory faults. For example, test patterns of all zeros, all ones, or a "checkerboard" pattern having alternating zeros and ones may be written throughout the memory cells. Moreover, the data may be written to the cells in any order, such as consecutively in an increasing or decreasing addressing scheme.<br>
[0005] Thus, BIST units are commonly included in many types of integrated circuits that use or otherwise incorporate memory modules and operate according to some predetermined algorithm to verify the functionality of the internal chip circuitry. However, electronic devices typically comprise more than the internal circuitry of a single chip. Normally they are constructed from many integrated circuit chips and many supporting components mounted on a circuit board.<br><br>
[0006] As the complexity of a typical computing device increases, the number of memory chips and other integrated circuits increases. For example, conventional computing devices typically include a plurality of the memory modules, which are often of different types. The memory modules within a single computing device may include various combinations of random access memory (RAM), read-only memory (ROM), Flash memory, dynamic random access memory (DRAM), and the like. These various types of memory modules often require different testing procedures, and have different bit densities, access speeds, addressing requirements, access protocols, and other particularities. As a result, a typical computing device may have a respective BIST unit for each memory module, and each BIST unit may be particularized to test the associated memory module.<br>
SUMMARY<br>
[0007] In general, the disclosure is directed to a distributed, hierarchical built-in self-test (BIST) architecture for testing the operation of one or more memory modules. As described, the architecture includes three tiers of abstraction: a centralized BIST controller, a set of sequencers, and a set of memory interfaces coupled to memory modules.<br>
[0008] The BIST controller provides centralized, high-level control over the testing of the memory modules. The BIST controller communicates centrally stored and maintained test algorithms to the sequencers for application to the memory modules. The BIST controller communicates the algorithms as a set of generalized commands that conform to a command protocol described herein. Moreover, the command protocol allows algorithms to be generically defined without regard to any timing requirements, physical organization or particular interface characteristics of the memory modules. As a result, a variety of test algorithms may easily be defined and centrally-maintained for distribution throughout an electronic device as needed. Consequently, common test patterns need not be redundantly stored within memory modules. [0009] The sequencers provide a second level of abstraction. The sequencers are distributed within device blocks that include one or more memory modules. In this manner, each sequencer is associated with one or more memory modules. The sequencers receive the high-level commands from BIST controller. In response to the commands, the sequencers issue a sequence of one or more memory operations to their<br><br>
respective memory interfaces to carry out the commands. For example, a sequencer may issue commands to sequentially access a range of addresses in response to a single command from the BIST controller. The sequencers report the results of the tests to the BIST controller.<br>
[0010] The sequencers control the application of the operations in accordance with the timing characteristics of their respective memory modules. For example, each of the sequencers controls the application speed of the sequence of operations in accordance with the access speed of the respective memory module. A single sequencer may control the application of the test algorithms to a plurality of memory modules that operate on a common clock domain. Consequently, logic for controlling application timing and sequencing of the test pattern domain is incorporated within the sequencers, and need not distributed within the individual memory modules or maintained by the BIST controller.<br>
[0011] The third tier, the memory interfaces, handles specific interface requirements for each of the memory modules. Each of the memory interfaces may be designed in accordance with the particular signal interface requirements and physical characteristics of the respective one of memory modules. Each memory interface receives memory operations from a controlling sequencer, and translates the memory operations, including associated address and data signals, as needed based on the physical characteristics of the respective memory module. For example, a memory interface may translate addresses supplied by the controlling sequencer based on the rows and columns of the memory module to fill a memory in a row-wise or column-wise fashion. As another example, the memory interface may translate the data to create specific bit patterns, such as a checkerboard pattern or as "striped" rows or columns in which adjacent rows or columns have opposing patterns.<br>
[0012] In one embodiment, a system comprises a built-in self-test (BIST) controller, a sequencer, and a memory interface coupled to a memory module. The BIST controller stores a set of commands defining an algorithm for testing the memory module. The sequencer receives the commands and issues one or more memory operations in accordance with the commands. The memory interface applies the memory operations to the memory module in accordance with physical characteristics of the memory module.<br><br>
[0013] In another embodiment, a system comprises a plurality of memory modules, a. built-in self-test (BIST) controller, and a plurality of sequencers. The BIST controller stores an algorithm for testing the memory modules. The plurality of sequencers are respectively coupled to different subsets of the memory modules, wherein each subset of the memory module is selected to include the memory modules having common clock domains. Each sequencer controls the application of the test algorithm to the respective subset of memory modules in accordance with the common clock domain of that subset of memory modules.<br>
[0014] In another embodiment, a device comprises a first-level built-in, self-test (BIST) means for issuing commands that define a BIST algorithm for a plurality of distributed memory modules having different timing requirements and physical characteristics, and a second-level BIST means for processing the commands to generate sequences of memory operations in accordance with the timing requirements of the memory modules. The device further comprises a third-level BIST means for generating translated address and data signals from the memory operations based on the physical characteristics of the memory modules to apply the BIST algorithm to the distributed memory modules. [001S] In another embodiment, a method comprises issuing commands from a centralized BIST controller to a sequencer, wherein the commands define a memory test algorithm to be applied to a set of distributed memory modules without regard to physical characteristics or timing requirements of the memory modules, and processing the commands with the sequencer to generate one or more sequences of memory operations in accordance with the timing requirements of the memory modules. The method further comprises applying the memory operations to the distributed memory modules to test the memory modules.<br>
[0016] The techniques described herein may achieve one or more advantages. For example, the techniques may allow a variety of test algorithms to easily be defined and maintained centrally in the form of generalized commands. The generalized commands can be distributed to sequencers located throughout an electronic device for interpretation and application to memory modules. As a result, common test algorithms need not be redundantly stored within the memory modules.<br>
[0017] In addition, the techniques may provide for the simultaneous application of algorithms to different memory modules, which may reduce overall test time and more thoroughly test for inter-memory effects. Moreover, the distributed, hierarchical nature<br><br>
of the architecture may allow the techniques to be readily applied to existing chip<br>
designs.<br>
[0018] The details of one or more embodiments are set forth in the accompanying<br>
drawings and the description below.   Other features, objects, and advantages will be<br>
apparent from the description and drawings, and from the claims.<br>
BRIEF DESCRIPTION OF DRAWINGS<br>
[0019] FIG. 1 is a block diagram illustrating an example electronic device having a<br>
distributed, hierarchical built-in self-test (BIST) architecture.<br>
[0020] FIG 2 is a block diagram illustrating an example embodiment of a BIST<br>
controller.<br>
[0021] FIG 3 is a timing diagram that further illustrates communication between the<br>
BIST controller and a set of sequencers for a single command of a generic BIST<br>
algorithm.<br>
[0022] FIG. 4 is a block diagram illustrating an example embodiment of a device block.<br>
[0023] FIG 5 is a block diagram illustrating an example embodiment of a sequencer.<br>
[0024] FIG. 6 is a block diagram illustrating an example embodiment of a memory<br>
interface.<br>
[0025] FIG 7 is a block diagram that illustrates an example embodiment of a data<br>
generation unit.<br>
[0026] FIG 8 is a block diagram illustrating an example data structure of a command<br>
issued by the BIST controller.<br>
[0027] FIGS. 9A-9E illustrate exemplary data structures in accordance with the<br>
command protocol described herein.<br>
[0028] FIG 10 is a flowchart illustrating example operation of the distributed, three-tier<br>
self-test architecture.<br>
DETAILED DESCRIPTION<br>
[0029] FIG. 1 is a block diagram illustrating an example electronic device 2 having a distributed, hierarchical built-in self-test (BIST) architecture. In particular, electronic device 2 includes a built-in self-test (BIST) controller 4 that provides centralized, high-level control over testing of device blocks 6A through 6N (collectively "device blocks<br><br>
6"). Each of device blocks 6 includes a sequencer 8, and a set of one or more memory interfaces 10 and one or more respective memory modules 12.<br>
[0030] lii general, BIST controller 4 provides and communicates test algorithms to sequencers 8 for application to device blocks 6. BIST controller 4 communicates each of the algorithms to sequencers 8 as a set of commands that conform to a generic and flexible command protocol. Each command specifies an operational code and a set of parameters that define one or more memory operations without regard to the physical characteristics or timing requirements of memory modules 12.   In this manner the command protocol allows a variety of test algorithms to easily be defined and distributed throughout electronic device 2.  Consequently, BIST controller 4 provides centralized control over the maintenance and distribution of the algorithms. As a result, common test algorithms need not be redundantly stored within device blocks 6. [0031] Sequencers 8 interpret and execute the test algorithms provided by BIST controller 4.    In particular, sequencers 8 receive high-level commands from BIST controller 4 that define a complete BIST algorithm. A single command, for example, may define a particular bit pattern to be written over a range of one or more addresses. In response to the commands, each of sequencers 8 issues one or more sequences of memory operations to their respective memory interfaces 10 to perform the commands. Moreover, sequencers 8 control the application of the operations in accordance with the timing characteristics of their respective memory modules 12.   For example, each of sequencers 8 controls the application speed of the sequence of operations in accordance with the access speed of the respective memory module 12. A single sequencer 8, e.g., sequencer 8A, may control the application of the test algorithms to one or more memory modules, e.g., memory modules 12A, that operate on a common clock domain. Memory modules 12 may be grouped and assigned to respective sequencers 8 based on any of a variety of criteria, such as clock domains for each of the memory modules and any pre-existing hierarchy or grouping of the memory modules. Consequently, logic for controlling application timing and sequencing of the test pattern for memory modules 12 operating on a common clock domain may be incorporated within a common sequencer 8, and need not distributed within the individual memory modules. [0032] Memory interfaces 10 handle specific interface requirements for each of memory modules 12. For example, each of memory interfaces 10 may be designed in accordance with the particular signal interface requirements and physical characteristics<br><br>
of the respective one of memory modules 12. As a result, each of memory interfaces 10 may be viewed as providing an interface "wrapper" around the particular interface signals, e.g., address, data, and control signals, for each respective memory module 12. In this manner, the BIST architecture of electronic device 2 comprises a three-tier, distributed arrangement including BIST controller 4, sequencers 8, and memory interfaces 10.<br>
[0033] Memory modules 12 may be any type of memory, such as random access memory (RAM), read-only memory (ROM), Flash memory, dynamic random access memory (DRAM), SDRAM, RDRAM, DDR-RAM, combinations thereof, and the like, and the techniques described herein are not limited in this regard. Moreover, electronic device 2 may be any device that incorporates memory modules, such as an embedded computing system, a computer, server, personal digital assistant (PDA), mobile computing device, mobile communication device, digital recording device, network appliance, mobile positioning device, and the like.<br>
[0034] FIG. 2 is a block diagram illustrating an example embodiment of BIST controller 4. In this illustrated embodiment, BIST controller 4 includes an algorithm memory 20 that stores a set of N test algorithms. As described below, each algorithm is defined in accordance with a set of binary commands. In one embodiment, for example, a complete algorithm may be specified by a set of 32-bit commands, where the commands define all necessary parameters for performing one or more sequences of memory operations over address ranges of device blocks 6 (FIG. 1) to test the functionality of memory modules 12.<br>
[0035] User interface 22 invokes algorithm controller 26 in response to external input, such as a control signal from an external testing apparatus. Alternatively, algorithm controller may be automatically invoked upon power-up of electronic device 2. Once invoked, algorithm controller 26 provides an algorithm select signal (ALGJ3ELECT) to multiplexer 24 to select one of the algorithms stored within algorithm memory 20. Once selected, a stream of binary commands that comprises the selected algorithm is applied to device blocks 6 as command data (CMD^DATA).<br>
[0036] Algorithm controller 26 controls the delivery of the algorithms to device blocks 6 based on acknowledge signals (SEQ_ACK) received from each sequencer 8 of the device blocks. In particular, algorithm controller 26 sequentially delivers each command of the selected algorithm to sequencers 8, and proceeds from one command to<br><br>
the next upon receiving an acknowledge signal from each of sequencers 8. In this manner, algorithm controller 26 ensures that each sequencer 8 has completed application of a current command to memory modules 12 via memory interfaces 10 before proceeding to the next command. Algorithm controller 26 may be programmatically or statically configured to establish the number of device blocks 6 and, in particular, sequencers 8 that are present within electronic device 2. In addition, algorithm controller 26 may be programmatically configured to apply a given algorithm to one, all, or any combination of memory modules 12 using any combination of device blocks 6.<br>
[0037] In addition to the algorithms stored in algorithm memory 20, user interface 22 may programmably receive algorithms via external input. User interface 22 delivers the received algorithms to multiplexer 24 in a form similar to that of the stored algorithms, i.e., a sequence of binary commands in which each command defines a test within the overall algorithm. In this manner, BIST controller 4 provides a centralized, first tier of the three-tier, distributed self-test architecture.<br>
[0038] FIG. 3 is a timing diagram that further illustrates communication between BIST controller 4 and sequencers 8 for a single command of a generic BIST algorithm. As illustrated, at a time Tl, BIST controller 4 asserts the command request (CMDJREQ) interconnects, and communicates a current command of the algorithm on the CMDJDATA interconnects.<br>
[0039] Upon receiving and applying the command, sequencers 8 assert a corresponding SEQ_ACK signal. For example, in the illustrated example, each of sequencers 8 assert respective signals SEQ_ACK[1], SEQ_ACK[2], SEQ_ACK[N] and SEQ_ACK[0] at times T2, T3, T4 and T5, respectively. In response, BIST controller 4 de-asserts the command request (CMDJREQ) signal at a time T6, causing sequencers 8 to de-assert their respective SEQ_ACK signal. BIST controller 4 asserts SEQSJOONE signal when all SEQ_ACK signals have been de-asserted, allowing BIST controller 4 to initiate another command at a time T7.<br>
[0040] FIG. 4 is a block diagram illustrating an example embodiment of a device block, e.g., device block 6A, in more detail. As illustrated, device block 6A includes sequencer 8A, a set of memory interfaces 10A-10C (collectively "memory interfaces 10"), and a set of memory modules 12A-12C (collectively "memory modules 12"). As illustrated in FIG. 4, each of memory interfaces 10 corresponds to a respective memory module 12.<br><br>
Sequencer 8A may be programmatically and/or statically configured to establish the number of memory interfaces 10 to be controlled, as well as the characteristics, e.g., maximum address, for the largest of memory modules 12.<br>
[0041] FIG 5 is a block diagram illustrating an example embodiment of a sequencer, e.g., sequencer 8A, in more detail. Sequencer 8A receives high-level commands from BIST controller 4 that collectively define a BIST algorithm. As illustrated in detail below, BIST controller 4 issues the commands in a generic, flexible format, and a single command may define a particular bit pattern to be written over a range of one or more addresses,<br>
[0042] In general, sequencer 8A receives the generic BIST commands, and controls the application of each command as a sequence of one or more memory operations applied to a set of respective memory modules. In the illustrated embodiment, sequencer 8A includes a command parser (CMD PARSER) 30 that receives command data (CMDJDATA) from BIST controller 4. Command parser 30 processes the received command to identify the specified operation, e.g., by identifying an operational code (op-code) specified by the command.<br>
[0043] Based on the specified operation, command parser 30 may extract one or more parameters from the command, and select a corresponding one of command controllers (CMD CONTROLLER) 34A-34N. In other words, each one of command controllers 34 corresponds to a different command that may be specified by CMDJDATA. Command parser 30 invokes the selected command controller 34, and passes the parameters extracted from the received command. Although illustrated separately, command controllers 34 may be combined and/or integrated into a single functional block having logic to perform each of the supported commands. [0044] In response to each command, the invoked one of command controllers 34 issues a sequence of one or more operations to each memory interface 10. In particular, the invoked one of command controllers 34 sequentially drives the appropriate command control signals (CMD__CTRL_SIGNALS) to carry out each operation of the sequence. The command control signals may include signals to provide a memory address and data to the receiving memory interfaces 10 and to direct the receiving memory interfaces to invert bits, perform read or write operations, invert rows, and the like, as further described below.<br><br>
[0045] Moreover, command controller 34 controls the application of the operations in accordance with the timing characteristics of their respective memory modules 12. Consequently, logic for controlling application timing and sequencing of the operations for memory modules 12 operating on a common clock domain may be incorporated within a common sequencer 8, and need not distributed within the individual memory modules.<br>
[0046] Sequencer 8A receives data from the tested memory modules 12, e.g., via signals MEM[0]_DOUT throughout MEM[N]_DOUT, and selectively communicates the data back to BIST controller 4 or an external device via multiplexer 37 and data selection signal 39. In this manner, sequencers 8 allow for the analysis of the data to identify any failures.<br>
[0047] Thus, sequencers 8 allow BIST controller 4 to centrally manage the storage and issuance of algorithms using generic and flexible command format. Sequencers 8 receive the generic BIST commands in accordance with the command protocol, and control the application of the commands by generating and issuing sequences of one or more memory operations for application to a set of respective memory modules 12, thereby providing a second tier of the distributed, hierarchical self-test architecture. [0048] FIG 6 is a block diagram illustrating an example embodiment of a memory interface 41 that provides the final layer of abstraction of the distributed BIST architecture by handling specific interface requirements for a respective memory module 12.<br>
[0049] In the illustrated embodiment, memory interface 41 includes a layer of multiplexers 45,46 that isolates the memory module 12 from normal functionality when electronic device 2 is operating in BIST mode. In particular, under normal operating conditions, BIST enable (BIST_EN) is de-asserted, causing multiplexers 45,46 to select the address / control signals (ADDR/CTRL) and data signals (DATA), e.g., as provided by a programmable processor. When electronic device 2 is operating in BIST mode, however, the BIST enable signal causes multiplexers 45,46 to select the BIST address / control signals (BIST_ADDR/CTRL) and the test data provided by a respective higher-level sequencer. In this manner, the sequencer controls multiplexers 45, 46 of memory interface 41 to selectively isolate the respective memory module, thereby allowing BIST algorithms to be applied to that memory module.<br><br>
[0050] Memory interface 41 further includes a data generation unit 44 that receives BISTJDATA signals and default data (DEFAULT_DIN) as provided by the sequencer 8, and generates transformed BIST data signals 49 (BIST_DATA_T) based on control signals (BIST_DATA_GEN„CTRL) provided by the sequencer and the specific physical characteristics of the corresponding memory module 12. More specifically, as described in further detail below, data generation unit 44 generates the exact data (RAMJDIN) applied to the memory inputs during each operation of the algorithm. Data generation unit 44 generates the transformed BIST data based on the physical configuration, e.g., physical row and column configuration, of the respective memory module 12, as well as the bit pattern specified by sequencer 8A, e.g., checkerboard, inverted, and the like.<br>
[0051] For example, sequencer 8 may request a checkerboard bit pattern that requires columns of data within the memory module to alternate between ones and zeros. Different memory modules 12, however, may be arranged with different row and column configurations. As a result, the memory cell for a given address may be located in a different row and column for memory modules 12 having different row-column configurations. For example, a 256 bit memory module 12 may be organized as 128 rows and 2 columns, 32 rows by 8 columns, 16 rows by 16 columns, and the like. As a result, writing a particular pattern throughout this matrix, such as a checkerboard pattern, requires knowledge of the specific row-column configuration of the memory module. Data generation unit 44 processes the data provided by the sequencer 8, and transforms that data, e.g., inverts the data, as needed to ensure the desired bit pattern is correctly written, as described in further detail below.<br>
[0052] Similarly, address generation unit 42 generates the address applied to the memory module 12 based on the addressing requirements specified by sequencer 8A and the physical configuration of the rows and columns of the memory module. For example, in some BIST tests, sequencer 8A directs memory interface 41 to write BIST data in a row (or column) first fashion, i.e., requiring each row (or column) to be completely written before proceeding to the next row (or column). As these requirements are specific to the row and column configuration, address generation unit 42 transforms the address provided by sequencer 8A to an appropriate to traverse an entire row (or column) before proceeding.<br><br>
[0053] As a result, the sequencer is able to issue operations by sequentially traversing an address space defined by the respective command, limited by the maximum-sized memory module associated with that sequencer. Each memory interface, e.g., memory interface 41, transforms the received address as needed to apply the operation to an appropriate memory cell. For example, for a column first BIST algorithm, the sequencer 8 issues the operations to the addresses in sequence, while address generation unit 42 computationally transforms the received address to access memory cells that fall within along the columns of. the memory module 12. In this example, address generation unit 42 transforms the addresses to access the memory module \2 in a column-wise fashion from a lowest-significant column to a highest-significant column based on whether the sequencer 8 is incrementing or decrementing through the address space.<br>
[0054] Comparator 48 that determines whether the data (RAMJDOUT) read from the memory module 12 equals the data last written to that address of the memory module as expected. When the comparison fails, i.e., when the data read from the memory module 12 does not equal the previously written data, comparator 48 asserts the BIST_FAIL signal to indicate that a memory error has been detected.<br>
[0055] In this manner, memory interface 41 processes the sequential memory operations issued by the higher-level sequencer, and transforms the data and addresses provided by the sequencer as needed based on the particular physical characteristics of the memory module, thereby providing a third tier of the distributed, hierarchical self-test architecture. As a result, the sequencer is able to issue operations for complex BIST algorithms without requiring detailed knowledge regarding the physical characteristics and capacities of each memory module 12.<br>
[0056] FIG 7 is a block diagram that illustrates an example embodiment of data generation unit 44 (FIG 6). In the illustrated embodiment, data generation unit 44 receives a BISTJDATA signal, a default data signal (DEFAULT_DIN) provided by the sequencer 8. In addition, data generation unit 44 receives a number of control signals in the form of BISTJNVERTJBITS, BISTJNVERTJROWS, LSBJtOW_ADDR, and BIST_WRTTE. Based on the received data and these control signals, data generation unit 44 generates transformed BIST data signals 49 (BISTJDATAJT) based on control signals (BISTJDATAJJENJ^TRL) provided by the sequencer 8 and the specific physical characteristics of the corresponding memory module 12.<br><br>
[0057] In particular, the sequencer 8 asserts and deasserts the invert bits signal (BISTJNVERTJBITS), the invert rows signal (BISTJNVERTJROWS), and the invert columns signal (not shown) to specify data patterns, such as solid, checkerboard, horizontal and vertical striped data patterns. If neither the invert bits nor the invert rows signals are asserted, then the BIST_DATA signal passes through XOR gates 52, 54 without modification. As a result, data generation unit 44 generates the transformed data signal 49 (BISTJDATAJT) to fill the memory module 12 with the data dictated from the sequencer 8 without modification.<br>
[0058] If the BISTJNVERTJIOW signal is set then data generation unit 44 inverts the values every time a row is crossed, as indicated by the least significant row address bit (LSBJR.OW_ADDR). As a result, AND gate 50 causes XOR gate 52 to invert the values dictated by the sequencer, and thereby invert values written to neighboring rows. Similar functionality may be provided to invert values as columns are crossed. When the BISTJDWERT_BITS signal is asserted, data generation unit 44 automatically inverts the values dictated by the sequencer. This may be useful in inverting values between corresponding cells of the different matrices.<br>
[0059] The DEFAULT_ DIN field establishes a default data value applied to the memory modules during read operations for memory modules 12. Multiplexer 56 selects between the DEFAULT JOIN data and the data generated by XOR gate 54 based on whether a write or a read operation is being performed, as indicated by the BIST_WRITE signal.<br>
[0060] FIG 8 is a block diagram illustrating an example data structure of a command issued by BIST controller 4. In the illustrated embodiment, command 60 includes a sequencer identifier (ID) 62, and a payload 64. Sequencer ID 62 identifies a sequencer, e.g., sequencer 8A, to which command 60 is being issued, as described in further detail below.<br>
[0061] BIST controller 4 broadcast commands to all sequencers 8, or may issue a command in unicast fashion to a particular one of the sequencers. In particular, BIST controller 4 sets sequencer ID 62 to a unique identifier for one of sequencers 8 to send a unicast command to that sequencer. For a broadcast command, BIST controller 4 sets sequencer ID 62 to a broadcast identifier, such as 0x0.<br>
[0062] Payload 64 of command 60 carries binary data that defines the command itself. In particular, payload 64 includes an operational code (OP CODE) 66 and a set of<br><br>
parameters 68. In general, OP CODE 66 specifies a particular function to be performed by the receiving sequencers 8. The following table enumerates an exemplary set of operational codes:<br><br>
[0063] In one embodiment, OP CODE 66 and parameters 68 comprise three bits and twenty-nine bits, respectively, to form a 32-bit command. The format and meaning of parameters 68 is dependent upon the type of command, as specified by OP CODE 66. [0064] FIG. 9A illustrates an example data structure of parameters 68 for the RESET command. As illustrated, the only relevant bit of parameters 68 is bit 28, which can be asserted or de-asserted to selectively enable and disable BIST mode. When asserted, the receiving sequencers 8 enter a mode for applying test algorithms to test the respective device blocks 6. When de-asserted, the receiving sequencers reset and terminate the current algorithm.<br>
[0065] FIG 9B illustrates an example data structure of parameters 68 for the EXECUTE command. As illustrated, for the EXECUTE command, parameters 68 directs the receiving sequencers 8 to apply a sequence of memory operations over a range of addresses in accordance with the particular timing characteristics of their respective memory modules 12.<br><br>
[0066] Once received, by default, sequencers 8 repetitively execute the specified memory operation over the address range of the largest memory module 12 within the respective device block 6. However, if SINGLE ROW (SR) bit is enabled, sequencers 8 execute the defined sequence of memory operations for all columns of the memory module 12 that has the largest column-bit option while maintaining the row address constant.<br>
[0067] When applying the sequence of memory operations, sequencers 8 either increment or decrement through the address range supported by the largest of the memory modules 12 within their respective device blocks 6 based on the state of the ADD INC/DEC bit of parameters 68. If ADD INC/DEC is asserted, for example, sequencers 8 apply the defined memory operations to each address starting from zero and proceeding to the maximum addresses. If ADD INC/DEC is deasserted, however, sequencers 8 apply the defined memory operations to each address starting from the maximum address and decrementing to zero. The DEF DIN field establishes a default data value applied to the memory modules 12 during read operations for the memory modules.<br>
[0068] The rippling row (RR) field directs sequencer 8 to apply the defined memory operations in a column-wise fashion, i.e., by applying the operations to an entire column before proceeding to the next column. In other words, each of sequencers 8 hold the column address constant while applying the memory operations and "rippling" the row address.<br>
[0069] The invert bits (IB) field, invert rows (IR), and invert columns (IC) fields can be used to specify data patterns for testing memory modules 12, such as solid, checkerboard, horizontal and vertical stripes data patterns. More specifically, if BIST controller 4 does not set either of the IR and IC fields, then the receiving sequencers 8 direct the memory interfaces 10 to fill memory modules 12 with the values dictated from the sequencer. If the IR field is set, then the values dictated by the sequencers 8 will have inverted values written to neighboring rows. Similarly, if the IC field is set, then the values dictated by the sequencers 8 will have inverted values written to neighboring columns. As a result, if both the IR field and the IC field are set, values are inverted between each column and between each row to create a checkerboard pattern within the memory modules. Finally, as described above, a given memory module 12 may be configured as more than one matrix. If the invert bits (IB) field is set, then the<br><br>
memory interfaces 10 automatically invert the values dictated by sequencer 8 between corresponding cells of the different matrices.<br>
[0070] Operations fields (OP1 - OP8) can be used to define a set of operations to be applied to each memory address. For example, each operation field, such as OP1, may comprise two bits. The first bit may be asserted or deasserted to indicate whether the operation is a read or a write. The second bit may be set based on the data to be written, i.e., a zero or a one. The number of operations (NUM OPS) field instructs sequencers 8 as to how many operations have been defined for application to each memory address. In this manner, a single command may be used to generically define a step within an overall BIST algorithm, and each step may define one or more operations to be applied to each address of the memory modules 12 with device blocks 6 of the receiving sequencers 8.<br>
[0071] FIG 9C illustrates an example data structure of parameters 68 for the TEST MEM command. For this command, parameters 68 include an FA/ BIST bit to interpret the TEST MEM command as a failure analysis command and as a BIST command. When set to failure analysis command, the value specified by the MEM ID field is used by the receiving sequencers 8 to select the data output of a specific one of memory modules 12 for failure analysis. When set to a BIST command, the value specified by the MEM ID field is used by the receiving sequencers 8 to select the data output of a specific one of memory interface 10 for participation within a particular test. In this manner, the algorithm can be selectively applied to individual memory modules 12 within a device block 6. The MEM BUS SLICE field is used to indicate which portion of the multiplexed data bus from the memory modules 12 is used for the failure analysis.<br>
[0072] FIG 9D is an example data structure of parameters 68 for the SET ADDRESS command. For this command, parameters 68 includes and address field (ADDRESS) that sets a specific memory address for application of a BIST step. This may be useful in conjunction with the SINGLE WORD ACCESS command. Parameters 68 also include a limit (LIMIT) field for specifying a maximum address limit for the test algorithm. In one embodiment, the LIMIT field comprises a 2-bit data field for setting the limit to: (1) the maximum address of the largest of the memory modules 12 of the device block 6, (2) the maximum address divided by two, (3) the maximum address divided by four, and (4) the maximum address divided by eight.<br><br>
[0073] FIG 9E is an example data structure of parameters 68 for the SINGLE WORD ACCESS command. For this command, parameters 68 includes an enable address change (ENADC) bit that controls whether the receiving sequencers 8 should change their respective current BIST addresses after applying the step. If enabled, the address increment / decrement (ADD INC/DEC) bit controls whether the current BIST address should be incremented or decremented. The invert bits (IB) field, invert row (ER), and invert column (IC) fields can be used to specify data patterns for testing memory modules 12, such as solid, checkerboard, horizontal and vertical stripes data patterns, as described above in reference to the EXECUTE command. The data field (DATA) is used to supply a default value for input data for read operations of the tested memory modules 12.<br>
[0074] Table 2 illustrates an example checkerboard BIST algorithm stored and issued by BIST controller 4 in accordance with the described command protocol. As illustrated, a relatively complex checkerboard memory test algorithm can be described<br><br>
[0075] Table 3 illustrates an example "Blanket March" BIST algorithm stored and issued by BIST controller 4 in accordance with the described command protocol. As illustrated, this memory test algorithm can be described in as few as six commands using the command protocol. Each of the commands directs the receiving sequencers 8 to issues sequences of memory operations that traverse the entire memory space in a defined direction. Moreover, several of the commands direct the sequencers to apply multiple memory operations to each address within the available memory space. In this manner, complex BIST algorithms can be easily distributed throughout and applied by the constituent components of the hierarchical self-test architecture.<br><br><br>
[0076] FIG. 10 is a flowchart illustrating example operation of the electronic device 2<br>
and, in particular, the distributed, three-tier self-test architecture of BIST controller 4,<br>
sequencers 8, and memory interfaces 10.<br>
[0077] Initially, BIST controller 4 selects one of the algorithms stored within an internal<br>
algorithm memory, e.g., algorithm memory 20 (70).   Upon selecting the algorithm,<br>
BIST controller 4 issues the first command defined by the algorithm to one or more of<br>
sequencers 8 (72).<br>
[0078] Each receiving sequencer 8 parses the command to identify the defined op-code<br>
and corresponding parameters (78).   For memory access commands, each receiving<br>
sequencer 8 initializes a starting address defined by the command (80). Next, sequencer<br>
8 issues a memory operation, i.e., generates the appropriate address, data and control<br>
signals (82).<br>
[0079] In turn, each receiving memory interface 10 translates the data and address<br>
signals based on the physical characteristics of each respective memory module 12 (92,<br><br>
94), and applies the translated signals to the memory modules (96). In addition, for read memory accesses (97), memory interfaces 10 automatically compares the data read from the respective memory modules 12 with the expected data (98). Based on the comparison, memory interfaces 10 update respective BIST failure signals to report the status of the tested memory module 12 (100).<br>
[0080] Once the memory operation has been issued by the memory interfaces 10, sequencers 8 determine if additional operations are to be applied to the current memory address within the sequence (84). If so, sequencers 8 issue the commands to memory interfaces 10 in similar fashion (82). If additional operations are not required, sequencers 8 update the address (86) and determine whether the entire address range defined by the command has been sequenced or whether additional addresses remain (88). When the entire address range has been sequenced and the memory operations have been applied to the addresses within the range, sequencers 8 issue acknowledge signals to BIST controller 4 (90).<br>
[0081] Upon receiving acknowledgements from each of sequencers 8 targeted with the command (74), BIST controller 4 determines whether the last command for the selected algorithm has been issued. If not, BIST controller 4 repeats the process and issues the additional commands (72). Once all of the commands have been issued and applied by sequencers 8 and memory interfaces 10 (76), BIST controller 4 terminates the current BIST test.<br>
[0082] Various embodiments have been described. These and other embodiments are within the scope of the following claims.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1IGFic3RyYWN0LWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">2331-chenp-2005 abstract-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1IGNsYWltcy1kdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">2331-chenp-2005 claims-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1IGRlc2NyaXB0aW9uIChjb21wbGV0ZSktZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">2331-chenp-2005 description (complete)-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1IGRyYXdpbmdzLWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">2331-chenp-2005 drawings-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">2331-chenp-2005-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1LWFzc2lnbmVtZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">2331-chenp-2005-assignement.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">2331-chenp-2005-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">2331-chenp-2005-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1LWNvcnJlc3BvbmRuZWNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">2331-chenp-2005-correspondnece-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1LWRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">2331-chenp-2005-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">2331-chenp-2005-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">2331-chenp-2005-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">2331-chenp-2005-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">2331-chenp-2005-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1LWZvcm0xOC5wZGY=" target="_blank" style="word-wrap:break-word;">2331-chenp-2005-form18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjMzMS1jaGVucC0yMDA1LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">2331-chenp-2005-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="229852-polyester-polycondensation-with-lithium-titanyl-oxalate-catalyst.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="229854-magnesium-dichloride-alcohol-adducts-and-catalyst-components-obtained-therefrom.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>229853</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2331/CHENP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>27-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>20-Feb-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>20-Sep-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 MOREHOUSE DRIVE, SAN DIEGO, CALIFORNIA 92121,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>HANSQUINE, DAVID, W</td>
											<td>12885 SUNDANCE AVENUE, SAN DIEGO, CALIFORNIA 92129,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>AVERBUJ, ROBERTO, FABIAN</td>
											<td>4110 VIA CANDIDIZ, #103, SAN DIEGO, CALIFORNIA 92130,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G11C 29/04</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US04/08663</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-03-19</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/630,516</td>
									<td>2003-07-29</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/456,452</td>
									<td>2003-03-20</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/229853-tiered-built-in-self-test-bist-architecture-for-testing-distributed-memory-modules by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:34:38 GMT -->
</html>
