<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/269120-remote-control-framework by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:16:46 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 269120:REMOTE CONTROL FRAMEWORK</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">REMOTE CONTROL FRAMEWORK</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A remote control framework enables a plurality of target devices to be controlled by a plurality of remote control devices irrespective of bearer types. In a preferred embodiment any target device may also act as a control device and any control device may also act as a target device. The framework also enables any application running on any target device to be controlled by any controller device.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>Remote Control Framework<br>
The present invention relates to a method for enabling the remote control of devices.<br>
For the avoidance of doubt, in the following description of the present invention the term device is used to refer to an entity that is capable of being remotely controlled by any type of external device over any type of wired or wireless connection.<br>
The first demonstration of wireless remote control was by Nikola Tesia, who exhibited a radio controlled boat on a specially built pond at an electrical exhibition in Madison Square Gardens in 1898. US Patent 613,809 was issued on this invention.<br>
Despite this venerable pedigree, the commercial exploitation of remote control technology for domestic electrical and electronic appliances did not occur in earnest for about another 50 years, when it was eventually pioneered by Zenith in connection with televisions. Their first television remote control, the lazy Bones', appeared in 1950, and this was connected to the television by means of a long wire. Whilst wired remote controls for televisions were not a long-lived technology (principally because users kept tripping over the cord), they have always continued to be manufactured for many other types of electronic appliances, from traditional wired remotes such as those for slide projectors and dictaphones, to more modern appliances such as digital camcorders: the Sony RMVD1 is a recent example of this latter art.<br>
It is wireless remote controls that now comprise the majority of such devices. In 1955, Zenith's 'Flashmatic' was the first wireless television remote control to appear; it operated by means of visible light signals made to photoelectric cells on the television. The following year, Robert Adler’s 'Space Commander’ became Zenith's first truly practical wireless remote control; it was a mechanically operated ultrasonic device. Ultrasonics remained the basis of remote control technology until the development of infrared transmission devices in the 1980s. Infrared remains the technology of choice<br><br>
for remote control devices today, though RF (Radio Frequency) is commonly used in cases where the line-of-sight communication required by infrared is impractical.<br>
Although wireless remotes are still the more common variety, it is noticeable that wired remotes are making something of a comeback, especially on appliances for which wires are needed in any case; the clearest example of this is appliances with audio functionality. This includes mobile phones, which can be controlled via buttons in a module inserted into the audio lead on hands-free headsets, and in a rather more sophisticated form on top-end digital music players (ail the market leaders such as the Apple iPod™, the Creative Zen™, and the River™ have optional or integral wired remote controls).<br>
In summary, the remote control of modern electrical and electronic appliances is today extremely widespread in any situation where close physical proximity between the person seeking to operate the appliance and the appliance itself is either<br>
•	impossible; as in the case of model vehicles such as aeroplanes or ships<br>
•	awkward; as in the case of appliances such as air conditioners that are usually mounted in a high position on a wall or a ceiling<br>
•	inconvenient, because it requires a physical alteration or effort which is deemed inappropriate for the circumstances of use; as in the case of modern audiovisual and audio appliances such as televisions, DVDs and music players.<br>
Until recentiy, the technology for remote control of appliances was limited in a number of related ways:<br>
•	Remote control devices were manufactured and sold with the<br>
appliances which they were intended to control, and closely coupled to<br>
them; proprietary signals and protocols were used for communications.<br>
This is true even of infrared devices. Although there is a standard for<br>
infrared communication developed by the Infra-red Data Association<br><br>
(IrDA, see http://www.irela.org/), it is not utilised by remote controls. "There are in fact "many different coding systems in use, and generally different manufacturers use different codes and different data rates for transmission," (from http://www.epanorama.net/linlcs/lrremote.html).<br>
It should be noted in this context that the existence of programmable remote ccxitrols, which can be used with appliances from many different manufacturers, is not evidence that they all conform to a common standard. Such programmable devices are able to emulate the operating modes, transmission protocols, data rates and control codes of each of the various manufacturers rather than being able to run in a single mode that functions in all situations.<br>
•	The remote controls appliances were supplied with were all dedicated and non-expandabie devices; they had a fixed set of capabilities and were not able to perform any functions except those embedded at manufacture time.<br>
•	Similarly, all appliances that were to be controlled remotely had to be specifically designed for this; their capabilities were fixed and they were not able to perform any functions except those embedded at appliance manufacture.<br>
However, electronic appliances are increasingly becoming multifunctional and programmable; the trend is for them to be built around the same type of central processing units and memory that are employed in general-purpose computers. There is substantial evidence that where this is the case, it is increasingly possible to circumvent the limitations described above.<br>
In the domain of remote control technology, appliances that are built around the same processor and memory components that are used in programmable computers are generally now able to utilise standardised communication technologies. Among these standards are:<br>
• Bluetooth (see the Bluetooth Special Interest Group web site at http://www.bluetooth.com/). This is a low-power short-range wireless networking protocol which is implemented in various profiles designed<br><br>
to be used in specific situations. One of the most common uses of Bluetooth is in wireless headsets for mobile telephones, utilising either the handsfree or headset profiles, either of which enable the headset to remotely control the mobile phone.<br>
♦	Firewire/IEEE 1394 (see the 1394 Trade Association web site at<br>
http;//www. 1394ta.org/ or the The Institute of Electrical and Electronic<br>
Engineers High Performance Serial Bus Bridges Working Group<br>
P1394.1 at http://grouper.ieee.Org/groups/1394/1/index.html). This is a<br>
fast serial protocol running over a wire, which is increasingly being<br>
used for remote control of multimedia appliances; the standard includes<br>
a Digital Remote Control Command Set.<br>
•	ANSi/CEA-2027; this is a relatively new standard, being finished as<br>
recently as July 2004, and comes from the Consumer Electronics<br>
Association (CEA). It defines an interface that can be used for control<br>
of audio/video equipment interconnected via a home network using IP<br>
(Internet Protocols).<br>
Although there is an increasing use of standards such as these, it is notable that many companies do not utilise them as much as they ought. For example, despite the fact that Apple invented Firewire, they do not use the technology in their own remote controls; people have had to go to some lengths to reverse engineer the proprietary protocols used in the iPod remote control, some of which are described at http://www.maushammer.com/ systems/ipod-remote/ipod-remote.html).<br>
As well as the above standards-based technologies, it has also become apparent that where appliances incorporate a programmable digital computer, linking two together enables one to control the other, provided that both are running compatible software. A larger static appliance (such as a personal computer) can therefore be controlled by a smaller mobile appliance (such as a cellular phone), giving in many cases a superset of the functionality of conventional remote controls. Many examples of this technology exist which enable mobile telephones to be used to control media players and other applications  on   personal  computers  via  Bluetooth,   such   as  Bemused<br><br>
(http://www.compsoc.man.ac.uk/'-'ashley/bemused/) and Bluetooth Remote Control (http:/Awww.labtech.epltech.net/remotecontrol/), which both control Windows PCs. Sailing Clicker enables a mobile telephone to control an Apple Macintosh (http://homepage.mac.com/jonassalling/Shareware/Clicker/) while implementations for Linux also exist (such as http://www.iptel-now.de/HOWTO/BT_REMOTE/bt„remote.html).<br>
The prior art as described above shows a gradual progression from dedicated, inflexible and proprietary remote control solutions to versatile, flexible and standard-based ones.<br>
However, all the standards-based solutions described above are limited by the fact that they are specific to bearer technologies, and very often also specific to transport protocols used with that bearer. Those that are skilled in this art will be aware that many possible bearers for remote control signalling exist, including but not limited to:<br>
•	Bluetooth (using any one of a number of possible profiles);<br>
•	Wireless Ethernet (802.11), using any IP based signalling method;<br>
•	Infrared (both proprietary and IrDA);<br>
•	Proprietary RF solution;<br>
•	IEEE 1394 (Firewire) utilising either the IEEE 1394 command set or ANSI/CEA-2027;<br>
•	USB (Universal Serial Bus) including USB-OTG (On-The-Go);<br>
•	Other wired solutions, Including RS-232 serial protocols.<br>
An appliance that is designed to work with a remote control using any one of these bearers is not currently able to work with any of the other types of bearer, irrespective of whether or not the remote control uses standard protocols. An MPS or other music player designed to be used with its bespoke wired remote control cannot be made to work with a generic Firewire, USB, Bluetooth or Infrared remote control device even though it may have such an industry standard interface available.<br>
Even with remote control devices making use of the same bearer, appliances may fail to work where an incompatible protocol is implemented. For example,<br><br>
it is well known that the Bluetooth headset and handsfree profile are sufficiently different that a Bluetooth enabled mobile phone that only supports the headset profile will not work with a Bluetooth peripheral that only supports the handsfree profile; this type of incompatibility has caused distress to numerous consumers, as there is no easy way of fixing it.<br>
Therefore, it is an object of the present invention to provide a remote control interface which at least alleviates the above mentioned problems caused by the close coupling between remote control solutions and specific bearer technologies through the provision of a generic remote control interface that can be used by application software running on an appliance to receive commands to and from any type of remote control device, irrespective of the protocol or bearer that it might be used to transport those commands.<br>
The same generic software interface can also be used by a remote control device to send commands to an appliance, once again irrespective of any protocol or bearer.<br>
Furthermore, any appliance incorporating a programmable computing device which implements this generic software interface can not only use It to receive commands from a remote control device, but can also use it {in conjunction with a suitable application) to act itself as a remote control device.<br>
According to a first aspect of the present invention there is provided a method of enabling one or more target devices to be remotely controlled by one or more controller devices through the use of commands sent over at least one of a plurality of bearers including but not limited to:<br>
•	Fixed wires, including USB and simple serial.<br>
•	Infrared<br>
•	Ultrasound<br>
•	RF, including but not limited to Bluetooth and 802.11 Wireless Networking<br>
through the provision of a generic remote control interface enabling the said one or more target devices to receive commands from any arbitrary controller device over any arbitrary bearer.<br><br>
According to a second aspect of the present invention there is provided a computing device arranged to operate in accordance with the method of the first aspect.<br>
According to a third aspect of the present invention there is provided an operating system for causing a computing device to operate in accordance with the method of the first aspect.<br>
An embodiment of the present invention will now be described, by way of further example only, with reference to thq accompanying drawings in which:-<br>
Figure 1 shows a remote control architecture in accordance with the present invention;<br>
Figure 2 shows an architectural overview of a remote control architecture in accordance with the present invention; and<br>
Figure 3 shows a practical embodiment of a remote control architecture in accordance with the present invention.<br>
In the following description the generic interface of the present invention is referred to as a Remote Control Frameworl<. it can be used by any applications or software running on the appliance however remote control framework intemally uses bearer plug-in modules to send receive external commands. a defined as replaceable item of executable code that provides specific services loosely coupled application service load invoke at njn-time.></.>
Each unique bearer requires its own plug-in. Each bearer plug-in externally implements the same generic application programming interface {API) but is intemally customised to make use of the specific features and requirements of the relevant bearer technology to send and receive commands to and from the remote control device.<br><br>
Example bearer plug-ins are a Wired Headset, an Infrared remote control, and the Bluetooth audio video remote control profile (AVRCP),<br>
Figure 1 shows one preferred implementation of this architecture diagrammatically, for an apparatus that is capable of acting both as a remote controller and as a controlled appliance. Implementations of this invention may also encompass alternative devices which encapsulate multiple controller and controlling functions, all of which can be performed concurrently in a discrete reliable and safe manner; multimedia and home security are amongst the technical areas where the complexity of control is such as to warrant devices of this type. However, it should be noted that while this preferred implementation can both control appliances and itself be remotely controlled, this invention can also be implemented in versions which lack either one of these capabilities and are suitable either for dedicated remote controllers, or alternatively for dedicated appliances that require controlling.<br>
The arrows in Figure 1 show the flow of commands and of control for a typical architecture in accordance with the present invention.<br>
Figure 1 shows audio application 2 and video application 4 running on an apparatus 6 which is being used as a controlled appliance. These applications receive commands from a remote control server 8 which offers a consistent Target Client API 10 for passing such commands to all applications, irrespective of the remote controller they originate from or the type of bearer used to transport them.<br>
Figure 1 also shows a remote controller application 12, which can also run on the apparatus when used as a remote controller. This uses its own Controller Client API 14 to send commands via the remote control server 8; once again, this API is consistent for any destination appliance and type of bearer.<br>
The remote control server 8 has plug-ins 14, 16, 18 for AVRCP, a wired remote and Infrared available, with extensions possible, one of which Is shown as box 20 in figure 1. In this embodiment, the remote control server indudes a target selector 22. The target selector performs three roles:<br><br>
1)	for incoming commands, it determines which target applications should receive the command.<br>
2)	for outgoing commands, it determines the default bearer and appliance to be controlled if the remote control application failed to specify these. Those skilled in the art will be aware that there are many mechanisms (e.g. some type of Control Panel) which can be used by the user or the appliance to determine the default bearer.<br>
3)	for outgoing commands which are sent by a remote control application which specifies the appliance to be controlled, it acts as a gatekeeper; it permits or denies the communication at a level above the bearer.<br>
The dotted line 24 in figure 1 signifies the boundary of the apparatus which is implementing this invention. When the apparatus is being used as a controlled appliance, commands are received or 'come in' over this boundary. When the apparatus is being used as a remote control, commands are passed or ‘go out over this boundary. The nature of the bearer for these commands is encapsulated within the remote control server 8.<br>
It should be noted that the further devices 26 shown at the bottom of figure 1 may themselves be running the remote control framework, but they need not be; the modules that plug-in to the server can be designed to implement any protocol over any type of bearer.<br>
Adding support for extra remote controls for a controlled appliance is simply a matter of adding additional plug-in modules to the Remote Control Framework on that appliance. So, a USB remote control only requires a USB plug-In (not shown) to be made available to the remote control sen/er; for example in lieu of the extension box 20 in figure 1. This may be provided as an Installable software module on an open operating system; alternatively, it could be provided as a hardware upgrade, by means such as an over-the-air or service centre upgrade, or a user-insertable module such as an EPROM which would be recognised by the operating system.<br><br>
Adding the capability to control additional appliances by a remote control is similarly managed by adding plug-in modules to that appliance's own remote control framework.<br>
The example of the present invention which will now be described is an implementation of the invention on a cellular telephone running Symbian OS, the advanced operating system for mobile phones produced by Symbian Ltd; it therefore uses terms and idioms which will be familiar to those skilled in the art of building devices with this operating system, as described in various textbooks on Symbian OS (such as Symbian OS Explained by J. Stichbury, Wiley 2004, ISBN 0470021306), and in the various development kits published by Symbian Ltd (such as those found at http;//www.symbian.com/developer/ techlib /sdl.html). Those skilled in the art will of course appreciate that the sample implementation described here can also be adapted to run on many different operating systems and many different devices.<br>
This example Remote Control System (RemCon) shows how the invention can be used to control a phone, and in particular a music application such as an MPS player running on the phone, from a Bluetooth stereo audio headset. The application being controlled is referred to as a target. For instance, in this example the user may interact with a headset to perform functions such as play, pause, and 'next track’: in essence the headset is used for remote control of the phone.<br>
More generally, the phone may be controlled by another device over any suitable bearer or protocol. Therefore, in order to demonstrate the extensibility of the invention, another initial implementation described is that of a relatively basic plug-In which works over a serial transport using an arbitrary naive protocol.<br>
The remote control system of the present invention also allows the use of the device as a remote control for other devices.  The application on the device<br><br>
for this functionality is referred to as a controller. For example, the device might be used for the remote control of a television.<br>
The system is extensible in terms of the transports and protocols (collectively known as bearers) which may be used to transmit and receive remote control messages. Although in this description, headsets are generally envisaged as Bluetooth headsets, it is clearly possible to support other types of headsets, such as wired ones.<br>
Independently of bearer extensibility, the system is also extensible in terms of the messages which may be sent and received. Compliance with a new bearer protocol may also involve, therefore, supporting new messages.<br>
The system also allows multiple client applications to use It simultaneously. Not just one controller and one target, but multiple targets at the same time as multiple controllers.<br>
Controller clients send commands and receive responses. Target clients receive commands and send responses. The controller API allows, therefore, connectionless operation (where commands are routed by the system as decided by the device manufacturers) and connection-oriented operation (where the client specifies the bearer and any relevant addressing information for the remote party). Clients can monitor the states of the various connections extant at any point in time. The system is therefore bearer agnostic.<br>
Figure 2 shows an architectural overview of the system.<br>
Some of the components in the architecture shown in figure 2 implement standard protocols, which are well known to those skilled in the art. These include:<br>
•	AVCTP (Audio Video Control Transmission Protocol)<br>
•	AS/DTP (Audio-Video Distribution Transport Protocol)<br>
•	AVRCP (Audio Video Remote Control Profile)<br><br>
•	L2CAP (Logical Link Controller and Adaptation Protocol)<br>
•	RTF (Real Time Protocol)<br>
•	SBC (Sub Band Codec)<br>
Other components of the architecture shown in figure 2 are specific to this implementation.<br>
•	Media Player app uses a MultiMedia Framework (MMF) to send audio over AVDTP to the Bluetooth headset. The MMF is represented by the MMF Client API and the MMF Controller Plug-in. The Media Player app is also a RemCon target, and receives remote control commands (like next track, pause, etc) from the headset, via AVRCP.<br>
•	Remote Controller app Is a RemCon controller and sends remote control commands to remote devices via AVRCP.<br>
•	DevSound is also envisaged as a RemCon controller; this is how it sets the remote volume directly via the Audio Policy Server (i.e. the media volume is treated as a system property, not handled on a per-media-player-app basis),<br>
•	The RemCon Target API and RemCon Controller API include the command extensibility mentioned above.<br>
•	The RemCon sen/er Includes the bearer extensibility framework and the message routing policy also mentioned above.<br>
An overview of the principal components of the design will now be provided.<br>
RemCon<br>
There will be at most a single instance of the RemCon server running on the device. It is a transient server; that is to say, it will not always be in use and, in order to save resources, it shuts down when there are no clients.<br>
Bearers<br>
Bearers are implemented as plug-ins to RemCon and all instantiate a standard interface.<br><br>
This particular implementation of the remote control system is associated with implementations of the AVRCP and AVCTP extensions to the Bluetooth system. Hence:<br>
•	AVRCP is delivered as a bearer plug-in to RemCon<br>
•	AVCTP is delivered as part of the Bluetooth protocol module.<br>
It is also be associated with a reference serial bearer as described above.<br>
The server is designed<br>
a)	to work with these components and<br>
b)	as far as possible, to work with any other conceivable bearer, i.e. to remain bearer-agnostic.<br>
While there are two possible types of bearer, connection-oriented and connectionless, this implementation requires that connectionless bearers emulate connection-oriented behaviour. The bearer API is therefore connection-oriented, as is the AVRCP bearer plug-in.<br>
Instantiation of a connection-oriented bearer causes it to start listening for incoming connections. Such bearers accept incoming connections and notify the RemCon server.<br>
It should be noted that the RemCon server is also able to command a bearer in order to attempt connection to a specific remote device.<br>
Controllers<br>
Controller entities send messages to remote targets, and field any replies given.<br>
When a controller In connectionless mode sends a command, the actual bearers to be used (and specific connections within those bearers) are specified by a plug-in. normally specific to a device and provided by its manufacturers, known here as the Target Selector Plug-in (TSP); this is discussed in more detail below, in connection with targets. When a controller in connection-oriented mode sends a command, the connection used is that<br><br>
already opened by the controller. The TSP is not bypassed; however; it is able to control whether that controller may send that command to the specified remote at that time.<br>
Bearers are used to transmit commands and receive responses. The server maintains knowledge of commands sent by each controller. Responses coming in over a connection are directed by the server to that controller client which has recently sent the appropriate initiating command over that connection.<br>
The controller API also contains a NotifyConnectionsChange API, which delivers Information on all the connections over all bearers in the system.<br>
Targets<br>
As with controller clients, there may be more than one target client operating at once. Target operation is more problematic than controller operation because bearer protocols do not necessarily encapsulate which target an incoming command is intended for. Which target needs to field a particular incoming command changes not only at run-time, but in ways in which the target (client) may have no control, or even knowledge. By way of illustration, if the user is listening to music using an MPS player application, and a call comes in, which is picked up by the user, the target application (for volume control changes initiated by the headset) changes from the MPS player application to the phone application. If the device user interface (Ul) maintains a distinction between'Multimedia volume' and 'Call volume', then each of these applications needs to listen for volume control changes in order to update their own on-screen display.<br>
In effect, the system is trying to model what the user thinks is being remotely controlled at any one time. With current practices, this is generally quite straightfonward; a user uses a TV remote control to control a TV. and a video remote control to control a video recorder. This makes the mapping between the physical controller and the target explicit.<br><br>
However, with multiple target applications running on a phone being controlled by a single remote controller(headset), this mapping is more obscure. The following factors are amongst those which may be used to establish the mapping:<br>
(a)	application order in the Read Only Memory (ROM) of the device<br>
(b)	whether or not the application is in the foreground<br>
(c)	recent history of user operations<br>
(d)	relative deemed importance of applications (e.g. for a phone application, when a call is active is probably the most important)<br>
(e)	if the MPS player knows that a loud section of music has recently started, then a volume down command Is more likely to have been commanded for the MPS player than for any other application<br>
(f)	if the MPS player remembers and knows that the user generally performs'next track' soon after the beginning of a particular track in a playlist, the user probably means to skip the next track this time also<br>
(g)	if a user Is listening to music streamed off the web from a service which provides a 'user rating' for tracks, and the user selects 'next track' on a track that other users think is not good, the user maybe thinks so too.<br>
The above possibilities, which are merely exemplary, make it clear that it is impossible for a generic operating system to offer a definitive answer to the mapping problem. The manufacturer of the device, who determines the user interface, is therefore often better placed to decide mappings.<br>
Hence, a mechanism is provided, called the Target Selector Plug-in (TSP) which can be used by device manufacturers to implement a set of rules which make best sense according to their user interface system. Thus, the TSP is provided with a list of the current client target process IDs and is expected to indicate back to RemCon (by process ID) a list of target clients to receive the nnessage.<br>
Due to the fact that targets cannot be expected to know which bearer will deliver commands to them, whenever a target client connects to the remote control system, all available bearers must be loaded and start listening for<br><br>
incoming connections. Note that the target client Is agnostic towards bearers, but it is not completely unaware of their existence. The NotifyConnectionsChange API previously mentioned is also available to targets.<br>
The Target Selector Plug-^in (TSP)<br>
The TSP is responsible for deciding three things:<br>
1.	for each Incoming command, which target(s) to deliver the command to;<br>
2.	for a controller in connectionless mode, which remote target(s) to deliver outgoing commands to (i.e. which bearer/bearer remote address to deliver commands to); and<br>
3.	for a controller in connection-oriented mode, whether to permit or refuse the controller's request to send a specific command to a specific remote.<br>
A single reference implementation of the TSP interface is provided by RemCon. For targeting purposes, this interface is provided with an array of potential recipients. In this way, it is able to indicate an array of intended recipients, and the message will be delivered to each.<br>
As described earlier, the TSP is provided for the device manufacturer to implement according to their own particular Interface policy.<br>
in a working device, a single TSP is provided at read only memory (ROM) build time. There is logically only one such plug-in in the system as there is logically only one correct way to answer the question on a device with just one Ul. The commands are actually delivered by RemCon; the TSP is merely queried by RemCon so it knows where to deliver the messages.<br>
Target clients are identified for these purposes by process ID and secure ID. RemCon polices the establishment of target clients such that only one is allowed per client process. For each command, the TSP is given a list of the<br><br>
IDs of the currently open target clients so it knows which targets are available. The TSP IS also at liberty to trigger the opening of further target client applications, and add their IDs to the array.<br>
Remote targets are identified by a combination of the bearer's Unique Identifier (UID) and a bearer-specific connection information package. Bearer-specific connection packges types should already have been made public to third parties so that connection-oriented controllers are able to function correctly.<br>
The TSP API functions via a request-callback mechanism, for maximum flexibility in its implementation. The callback may be synchronous or asynchronous. The TSP is designed to be capable of understanding any command passed to it by RemCon for addressing, sufficient to fulfil its purpose of addressing the command. This includes not only Core API commands but also extension commands. If the TSP 'errors' a command then that command will not be delivered.<br>
Target listening mechanism<br>
Tliere is only one TSP instance in the system. Therefore incoming events from many bearers are queued in RemCon before being sent across an asynchronous API to the TSP. For targets, once a command has been 'addressed' it Is given to those selected target clients, assuming they each have an outstanding receive request.<br>
When the receive request of the target concerned is completed, that target processes the given data and (usually) reposts the request. If the TSP indicates that target X should receive a command when that target has no 'Receive request' outstanding at that point in time, then that command is queued until target X posts a Receive request. Incoming responses are also queued in this way.<br><br>
Extension APIs<br>
The framework supports extensions to the core API, for instance to support APIs specific to the various device manufacturers. A controller client does not necessarily know, when sending a command, which bearer it will be sent over. Therefore, the packaging of the command into the bearer-specific format is cam'ed out 'server-side'.<br>
An extension API consists of:<br>
(a) a client-side DLL (dynamic link library) which provides unique identifiers<br>
for the 'new' messages and APIs for sending and receiving those<br>
messages, and (b)a  'converter'  plug-in to each existing bearer plug-in. The server<br>
administers these plugins, and fields requests from the bearers to<br>
convert messages to and from the bearer-specific format.<br>
If a converter plug-in to convert between a particular bearer format and a particular extension API is not found, then that bearer is not able to process messages from that API and they are dropped.<br>
Converters<br>
A converter is a plug-in, responsible for converting between:<br>
(a)	the message format of one client-side API (whether it is the Core API, or an extension), and<br>
(b)	the message format of one bearer.<br>
Consequently there are in principle N converters in the system, where N is the product of the number of bearers and the number of APIs. In practice N may be less that this, because<br>
a)	an extension API may choose to not support a number of bearers, and<br>
b)	a bearer protocol may be incapable of supporting extensions.<br><br>
In the description which folkws, specific Converters will be named according to the folkwing convention: Converter (A, B) is a converter which converts between API A message formats and bearer B message formats, For instance, the RemCon work will provide converter (Core, serial) and Converter (SxtApil, Serial), and the AVRCP will provide Converter{Core,   Avrcp) and Converter(ExtApil,   Avrcp).<br>
A practical embodiment of the invention is illustrated in Figure 3, where the folkwing executables are shown:<br>
(a)	RemCon Server,<br>
(b)	three Dynamic Link Libraries (DLLs) in the client side API<br>
o   RemCom Core API<br>
o   RemCon Intermediate client side (the framework for extensions)<br>
o   RemCon Client inner client side<br>
(c)	an extension API (ExtaApil) supplying Song Title and Absolute Volume APIs<br>
(d)	TargetSelectorPlug-in, the base DLL for the TSP<br>
(e)	Reference TSP<br>
(f)	BearerPlug-in,  the  base  DLL for  bearer  plug-ins.  the  reference SerialBearer, and the AVRCP Bearer<br>
(g)	ConverterPlug-in, the base DLL for converter plug-ins<br>
o	Converter(Core, Serial)<br>
o	Converter(ExtApi1, Serial)<br>
o	Converter(Core, AVRCP)<br>
o	Converter(ExtApi1, AVRCP)<br>
Class definitions for these components may typically be as folkws:<br>
RemCon<br>
class CRemConServer: public CPolicyServer, public MRemConTargetSeiectorPluginObserver<br>
CRemConServer is the concrete server type for the RemCon server.<br>
The server owns and controls the command queues. It is the heart of<br>
RemCon, dealing with all message routing.<br><br>
class CRemConSession : public CSession2<br>
CRennConSesskn is the concrete server-side session type.<br>
One Instance wilt be created per client-side RRemCon handle attached.<br>
The session fields all IPC calls fronn the client side.<br>
It has a member holding the client's process ID. This is used by the session to make sure that at most only one fully instantiated instance of a target session is created per client process.<br>
Objects of this type field client requests, holding RMessage2 members for each such asynchronous API for later completion.<br>
class CBearerManager: public CBase, public MRemConBearerObserver<br>
CBearerManager is a singleton, owned by the CRemConServer.<br>
It kads, on instantiation, all the bearer plug-ins. It is the interface to the<br>
bearers.<br>
Bearer<br>
The design of the bearer API, and the design of the reference serial bearer, is<br>
described here. Note that each bearer is required to support each and every message in every possible API. It is permissible to do this by returning KErrNotSupported when an attempt to send a message is made, but simply ignoring or dropping a message Is not alkwed. In practice, the UID identifying the API is used by bearers to fonward the message to the correct converter. If there is no converter for that API. then KErrNotSupported is the correct response. If the converter is found but does not (for whatever bearer-specific reason) support the particular message, then KErrNotSupported is given back as a response.<br>
Bearer API<br>
General<br>
Bearers will be plug-ins. A bearer uses converter plug-ins (each bearer has, in principle, one for each extension API plus one for the Core API) to convert each message between the bearer protocol-specific message format and the<br><br>
client-friendly bearer-agnostic message format. If a converter plug-in is not supplied for a particular bearer/API pair, then that bearer will not be able to send or receive messages beknging to that API.<br>
RemCon alkws bearers to support multiple simultaneous connections.<br>
Bearers are instantiated on server startup. The Instantiation of a bearer causes it to listen for incoming connections. An incoming connection is accepted automatically by the bearer, subject to its own policy. This may include either protocol-specific or other security policies; while it is clearly desirable to ensure that RemCom is secured, this invention does not specify or depend on any particular security model.<br>
RemCon is then notified of the existence of a new connection and relevant (remote address, etc) parameters. Bearers are alkwed to support multiplexing, or multiple 'remote control channels'. RemCon is informed by the bearer of the states of any bearer connections.<br>
The bearer API is able to support multiple commands and responses being sent simultaneously. If the bearer is able to support queuing, then RemCon will be able to post many simultaneously-outstanding Send commands on that bearer, on one or more connections. If the bearer does not support queuing, then it must return an en-or to RemCon, which will complete the client's original request accordingly.<br>
Possibilities for the timing of the completion of a send request include:<br>
(a)	once the bearer has tried to send the request over the transport,<br>
(b)	when the bearer has assumed responsibility for the message, i.e. when the bearer has either sent the request or queued the request for sending, and<br>
(c)	when a response arrives.<br>
For a connectionless controller, once a command has been addressed by a TSP, the resulting addressed message(s) are sent over the relevant bearer<br><br>
connections. If any fails, the particular commanded operation is aborted and the controller client Is notified of that error.<br>
RemCon provides no API for querying available bearer plug-ins; this can be achieved using normal operating system (OS) facilities as necessary, because the nature of all plug-ins and the interfaces with which they can be used are public information.<br>
A connection-oriented bearer supporting only one connection at once will start listening when it is created. When it is connected (either by accepting a connection or when driven by a connection-oriented controller) it notifies RemCon of the state of the connection. If the connection is terminated for any reason, the bearer notifies RemCon.<br>
A connection-oriented bearer supporting multiple connections (e.g. AVRCP) will start listening when it is created. If a connection is established using the listener, it will continue to listen for (further) incoming connections. RemCon is kept up-to-date regarding the states of connections.<br>
Connectionless bearers must emulate the connection-oriented behaviour of the bearer API. The serial bearer supports connectionless behaviour and it is able to indicate to RemCon that it is'connected' when the COM port is opened successfully. If there is a problem opening the port, then it will retry to connect after a pause.<br>
Relevant APIs<br>
(Note that lines beginning with '@ 'document API parameters or return conditions.)<br>
class CRemConBearerPiug-in : public CBase<br>
virtual void ConnectRequest(const TRemConAddressA aAddr) = 0;<br>
Called by RemCon to get the bearer to connect to another party, param aAddr Remote address information.<br>
virtual void DisconnectRequest(const TRemConAddressA aAddr) = 0;<br>
Called by RemCon to get the bearer to disconnect from another party.<br><br>
param aAddr Remote address information. Sending messages<br>
virtual Tint Senckommand(TUid aInterfaceUid.<br>
TUint aOperationId,<br>
TUInt aTransactionId,<br>
RBuf8&amp; aDafa,<br>
const TRemConAddress&amp; aAddr) = 0; virtual Tint SendResponse(TUId aInterfaceUid,<br>
TUint aOperationidj<br>
TUint aTransactionId,<br>
RBuf8&amp; aData,<br>
const TRemConAddress&amp; aAddr) - 0; Called by RemCon to send messages on a connection. The bearer must indicate the completion of the request (i.e. that it has sent the message or queued it for sending) synchronously by return. @param aInterfaceUid The UID of the client API interface. @param aOperationId The operation ID within the API. @param aTransactionId The identifier of the transaction this command or response bekngs to.<br>
@param aData API-specific message data; If the bearer returns KEn^None, it is considered by RemCon to have taken ownership of this. @param aAddr Remote address information, ©return Error.<br>
Note that after accepting a SendCommand request, the bearer is required to generate at least one response (whether genuinely from the remote party or not).<br>
Receiving messages<br>
virtual Tint GetResponse(TUid&amp; aInterfaceUid, TUInt&amp; aTransactionId, TUint&amp; aOperationId, RBuf8&amp; aCommandData, TRemConAddress&amp; aAddr) = 0;<br><br>
virtual Tint GetCommand(TUid&amp; aInterfaceUid,<br>
TUint&amp; aTransactionId,<br>
TUintSc aOperathnld,<br>
RBuf8&amp; aCommandData,<br>
tRemConAddress&amp; aAddr) = 0; Called by RemCon to pick up a message previously notified to it, by the bearer, using NewCommand or Nev^Response. @param alnterfaceUid The UID of the client API interface. @param aOperationId The operation ID within the API. @param aTransactionld The transaction ID of the command or response. @param aData API-specific message data. Ownership is returned by the bearer. @param aAddr Remote address information.<br>
virtual void CiientStatus(TBool aControllerPresent, TBool aTargetPresent) = 0;<br>
This is called by RemCon to indicate whether there are any controller clients present (aControllerPresent) and whether there are any target clients present (aTargetPresent). It is called both:<br>
(a)	when the number of controller clients changes from 0 to 1 or from 1 to<br>
0, and<br>
(b)	when the number of target clients changes from 0 to 1 or from 1 to 0.<br>
aControllerPresent will be a tme value if any controllers are present, and<br>
EFalse othenvise. Implementers are reminded not to compare to ETrue.<br>
This API is provided to facilitate the creation and destruction of Service Discovery Protocol (SDP) records by the AVRCP bearer. Failure is not interesting to RemCon, hence the void return type.<br>
virtual TSecurifyPolicy SecurityPolky() « 0;<br>
@return The capabilities required to  use (connect,  send,   receive) the<br>
transport.<br>
RemCon has adequate capabilities to use any conceivable transport, but it is<br>
required to check whether controller clients have capabilities.   This API is<br><br>
called so that RemCon can police controller client requests. For connection-oriented controllers, the check is perfomfied when the client tries to associate itself with the bearer. For connectionless controllers, the check is performed after the TSP has chosen a particular bearer for the client's transmission.<br>
class MRemConBearerObserver<br>
CRemConBearerPlug-in has a reference to an object of this type, which it uses to signal completion of requests to RemCon.<br>
virtual Tint MrcboConnectlndkate(const TRemConAddross&amp; aAddr) = 0;<br>
Called by a bearer when an incoming connection has been established, param aAddr Remote address information, return Error.<br>
virtual void MrcboDisconn0Ctlndicate(const TRemConAddres$&amp; aAddr)^0;<br>
Called by a bearer when a connection has been disconnected from the<br>
remote end.<br>
@param aAddr Remote address information.<br>
virtual Tint MrcboConnectConfirm(const TRemConAddress&amp; aAddr, Tint aError) - 0;<br>
Called by a bearer to indicate completion of an outgoing connection request<br>
(CRemConBearerPlug-in::Connect).<br>
@param aAddr Remote address information.<br>
param aError En-or.<br>
return Error. If this is not KErrNone, the bearer drops the connection.<br>
virtual void MrcboDisconnBctConfirm(const TRemConAddressA aAddr, Tint aError) = 0;<br>
Called  by a  bearer to indicate completion of a disconnection  request (CRemConBearerPlug-'in::Di8connect). @param aAddr Remote address information. @param aError Error,<br>
Incoming messages<br><br>
virtual Tint MrcboNewResponse(const TRemConAddress&amp; aAddr) - 0;<br>
virtual Tlr)t MrcboNewCommar)d(con$t TRemConAddrBss&amp; aAddr) - 0; Called by the bearer when a new message is available in its queues to be picked up by RemCon. RemCon vwil call Get Response or GetCommand. @param aAddr Remote address information.<br>
virtual CRemConConverter&amp; MrcboConverter(TUid aInterfaceUid, TUid aBearerUid) , 0;<br>
Accessor for a converter. The two UlDs given can be used to uniquely identify a converter. Converters are managed by RemCon and merely accessed by bearers via this interface. @param aBearerUid The UID of the bearer implementation.<br>
@param alnterfaceliid The UID of the interface.<br>
Serial bearer<br>
The serial bearer is a concrete Implementation of the bearer interface. CRemConSerialBearer derives from CRemConBearerPlug-in.  It owns Active Objects which use RComm:;Read and RComm::Write to receive and send data on a serial line- these notify completion through the observer interfaces.<br>
CRemConSerialBearer opens the comm port on instantiation and immediately indicates 'connect complete' to RemCon. When it receives, from RemCon, a request to Send a command, it packages the API UID and operation UID into a fixed-width buffer (using the appropriate converter) and sends it over the serial line without retry. When the RComm::Write completes, the CRemConSerialBearer is notified, and it calls SendComplete on the observer. When it receives, from RemCon. a request to Receive a command, it queues a RComm::Read for the fixed buffer size. When this is completed, the string is decomposed using the appropriate Converter into an API UID and operation ID, which are notified to the observer via ReceiveComplete.<br><br>
TSP<br>
General<br>
The TSP is a plug-in.<br>
class CRemConTargetSel0ctorPlug'in: public CBase<br>
virtual void AddressOutgoingCommand(TUid aInterfaceUid, TUint aOperationId, const TCiientlnfo&amp; aSender, TSgiQue<tremconaddress>&amp; aConnections, TSglQue<tbearersecurlty>&amp; aBearerSecurity)« 0;<br>
This is calied by RemCon to address the given outgoing {i.e. from a connectionless controller) command (alnterfaceUid / aOperationld). aConnections is empty when passed In. The TSP appends zero or more TRemoteAddresses and calls OutgoingCommandAddressed on RemCon. The TSP may do this asynchronously. RemCon directs the command to the given bearers with the associated connection infomnation.<br>
virtual void PermitOutgo!ngCommand(TUid alnterfaceUid, TUint aOperationld, const TCIientlnfo&amp; aSender, const TRemConAddress&amp; aConnection) = 0;<br>
This is called by RemCon when a connection-oriented controller tries to send a command. The TSP calls OutgoingCommandPermitted with either ETrue (the send is permitted) or EFalse (the send is not permitted).<br>
virtual void AddresslncomingCommand(TUid alnterfaceUid, TUint aOperationld, TSglQue<tciientlnfo>&amp; aClients) = 0;<br>
This is called by RemCon to address the given incoming command. aClients, when passed in, contains the current set of target clients. The TSP adds or removes zero or more items from this collection and calls IncomingCommandAddressed on RemCon. The TSP may do this asynchronously. The TSP is at liberty to start client applications and add a suitable TCIientlnfo (populated w\\h at least their process ID) to the collection. RemCon directs the command to the given clients, without assuming that any of them are still extant.<br><br>
class MRemConTargetSelectorPluginObserver<br>
Implemented by RemCon.<br>
virtual void MrctspoOutgoingCommandAddressed(Tlnt aError), 0;<br>
Called by the TSP to indicate that the previous AddressOutgoingCommand request has been answered, (the array passed by reference is correctly populated), NB Only one AddressOutgoingCommand may be outstanding at any time, but more than one of AddressOutgoingCommand and Addr^sslncomingCommand may be outstanding at once.<br>
virtual void l\/lrctspoOutgoingCommandPermitted(TBool alsPermitted) == 0;<br>
Called by the TSP to indicate that it has decided whether the controller send represented by the most recent call to PermitOutgoingCommand is permitted or not.<br>
virtual void MrctspolncomingCommandAddrdssed(Tint aError) = 0;<br>
Called by the TSP to indicate that the previous AddresslncomingCommand request has been answered (the array passed by reference is correctly populated). It should be noted that only one AddresslncomingCommand may be outstanding at any time, but more than one of AddressOutgoingCommand and AddresslncomingCommand may be outstanding simultaneously,<br>
TCIientlnfo<br>
This Is a simple type wrapping up the client session's process ID and current send message, which may be used for security purposes&gt;<br>
Client side<br>
Overview<br>
The RemCon client side supports sending and receiving commands and responses, it is also extensible. It has three layers, as shown in figure 3: 1, an 'inner' client side, which is nearest to the server, consisting of a single DLL containing RRemCon,<br><br>
2.	an 'intemnediate' layer, consisting of a single DLL, which (a) hands off messages coming from the inner client side to the appropriate 'outer' DLL, (b) provides an abstract interface on which to base API interfaces, and (c) provides the central session creation and control point for the ultimate client, and<br>
3.	an 'outer' layer, consisting of the actual API DLLs. The Core API DLL and the 'extension API 1' DLL (supporting song title and absolute volume messages) are provided in this layer. Third parties may add further APIs in this layer. Each DLL in this layer is uniquely identified by its'APIUID'.<br>
The inner client side sends and receives generic data. The data consists of an interface UID (associated with a specific outer layer DLL), an ID of an operation within that interface, and any associated data. The interface U!D and the operation ID together constitute a unique message identifier.<br>
Clients link statically to the outer layer DLL(s) they want to use and to the intermediate layer On initialisation, the client calls a method on the intermediate layer DLL to register an object from the outer layer DLL (by its interface UID) with the intermediate layer. The intermediate layer presents methods for opening RemCon sessions.<br>
When a message is sent by a client, the outer layer DLL adds Its interface UID, and the intemnediate layer simply fonwards this data as a whole to RemCon. When a command is received the TSP decides which target(s) it is to be delivered to. When a response is received RemCon hands it to the controller client that sent the original request The RemCon server simply delivers the message to the indicated target RRemCon session(s) in the Inner' client side, which delivers it to the intermediate layer. The intermediate layer analyses the interface UID of the message, and, if it has a registered outer layer object with that UID, it hands the message to that outer layer object. The outer layer DLL analyses the operation ID, optionally decomposes the associated (descriptor) data, and hands the message to the ultimate client via its own API.<br><br>
Inner client side (RRemCon)<br>
The 'immediate' client side is that nearest to the server. It consists of a single R-class, RRemCon, and some auxiliary types.<br>
It is preferable to implement some type of security policing on RemCon accesses at this point to avoid control being given to any entity that may abuse or misuse it. This invention is agnostic with respect to any particular security model.<br>
This, the inner layer of the RemCon API, is not accessible to clients. class RR0mCon: public RSessionBase<br>
RRemCon is an abstract base class for session types for the client side of the RemCon server. It is used to provide server heap failure debugging APIs in debug builds of the system only. These are not detailed here. The folkwing APIs are available from instances of derived concrete classes.<br>
IMPORT^C TVersion Verskn() const;<br>
Returns the version of the RemCon server. This API is tiie only one (apart from Ckse) that can be called before Connect.<br>
IMPORT.C Tint Connect();<br>
This is the standard session handle connection method. If handle creation is successful, a further IPC call is made to the RemCon server to set the 'type' of the client as either target or controller.<br>
IMPORT^C.void Send(TRequestStatus&amp; aStatus, TUid alnterfaceliid, TUint aOperationid, TUint&amp; aNumRemotes, const TDesC8&amp; aData , KNullDesCSO);<br>
Send is used by 'targets' to send responses to commands, and'controllers' to send commands.<br>
When a target client sends a response it is sent on the bearer which transported the original command. This addressing is carried out by RemCon itself.  aInteri'aceUid contains the UID of the interi'ace (core, or extension) to<br><br>
which the message bekngs. aOperatknId is the ID of the operation within that interface. aData is any associated data, if the client is a target (i.e. sending a response), and RemCon server does not remember having delivered a corresponding command to this client, the client will be panicked.<br>
On completion, aNumRemotes contains the number of remotes the message was sent to. If the message is a response, or from a connection-oriented contnaller, this will be 1 on success and 0 on failure. If the client is a connectionless controller then aNumRemotes indicates, of the remotes the TSP requested the command be sent to, how many succeeded (at the bearer level). Note that the TSP may say to send the command to 0 remotes. This is not considered as an error but as a success case.<br>
IMPORT_.C Tint SendCancol();<br>
Cancels the client's interest in the completion of an asynchronous Send request.<br>
IMPORT.C void Receive(TRequestStatus&amp; aStatus, TUid&amp; aInterfaceUld, TUInt&amp; aOperationld, TDes8&amp; aData);<br>
Receive is used by targets to receive commands, and controllers to receive responses to commands.<br>
Targets effectively receive commands from all bearers, subject to the TSP mechanism. Controller clients have responses delivered to them by virtue of RemCon remembering the controller which originated each command and the connection(s) over which a command went out.<br>
IMPORT^C Tint RecelveCancel();<br>
Cancels the client's interest in the completion of an asynchronous Receive request.<br>
IMPORTED Tint GetConnections(TSglQue<tremconaddress>&amp; aConnections);<br>
Synchronous getter for the currently extant connections on all bearers.<br><br>
TRemConAddress indicates the bearer (by its implementation DID) and bearer-specific connection information. If a connection is in the array, then it exists as a bearer-level connection in RemCon. If it does not exist in the array, then it does not exist as a bearer-level connection in the system. No other state is relevant. On success, the client is responsible for destroying the ' items in the queue.<br>
IMPORT_C void NotifyConnectionsChange(TRequestStatus&amp; aStatus);<br>
Notification for changes to the state of the bearer connections. On completion, the client preferably uses GetConnectkns to examine the actual connections.<br>
IMPORT^C Tint NotifyConnectionsChangeCancel();<br>
Cancels the client's interest in the completion of a bearer connection state change notification,<br>
class RRemConController: public RRemCon<br>
This is the concrete controller session type.<br>
IMPORT_C Tint GoConnectionOr!ented(const TRemConAddress&amp; aConnection);<br>
Makes the controller connection-oriented, using the given address. This address is used to send all commands from this session, and all responses will come from this remote (or be generated by the corresponding bearer). Pn^vided that there are ho security-related problems with the client, RemCon completes GoConnectionOriented accordingly. This is the only security check that RemCon itself does, and it is all that stands between a connection-oriented client and a bearer. Each command is also 'permitted' by the TSP at send time.<br>
IMPORT_C Tint GoConnect!onless();<br>
Makes the controller connectionless, using the given remote. The TSP will be used to address each command sent.<br>
IMPORT.C void ConnectBearer(TRequestStatus&amp; aStatus);<br>
A controller client may call this API to attempt to create a bearer-level connection    using   the   TRemConAddress    previously   registered   witH<br><br>
GoConnectionOriented. This API can only be used by connection-oriented controllers.<br>
IMPORT^C Tint ConnectBearerCancel();<br>
Cancels the client's interest in the completion of a 'connect bearer' request.<br>
IMPORT.C void DisconnectBearer(TReque$tStatus&amp; aStatus);<br>
A controller client may call this API to attempt to destroy a bearer-level connection using the TRemConAddress previously registered with GoConnectionOriented. This API can only be used by connection-oriented controllers.<br>
IMPORT_C Tint DisconnectBearerCancel();<br>
Cancels the client's interest in the completion of a 'disconnect bearer' request.<br>
class RRemConTarget: public RRemCon<br>
This is the concrete target session type.<br>
TRemConAddress<br>
This is a simple type wrapping a UID (the bearer's implementation UID) and a narrow buffer to hold the bearer-specific connection information.<br>
Intermediate layer<br>
class CRemConlnterfaceSelector: public CBase<br>
This is a concrete class. It owns an RRemConController and an RRemConTarget session, and, for each, an Active Object maintaining a Receive request on the session. It is the heart of the client's interaction with RemCon. Clients instantiate a CRemConlnterfaceSdector. Instances of the desired API interfaces are created, owned by the CRemConlnterfaceSelector. They then open a controller and/or a target session (through the selector's API), and then either (a) send commands and wait for responses using the interface(s), or (b) wait for commands and send responses, also using the interface(s).<br>
IMPORT_.C void OpenControllerL()<br>
Used by clients to open a controller session. It defaults to connectionless.<br><br>
IMPORT_C void OpenTargetLQ;<br>
Used by clients to open a target session.<br>
Other APIs are provided to wrap RRemCon' APIs.<br>
class CRemConlnterfaceBase; public CBase<br>
This is the base class for API interfaces, including the Core API.<br>
Receiving messages<br>
virtual void MrcibNewResponseCTUInt aOperaiionId, const TDesC8&amp; aData) = 0;<br>
virtual void MrclbNewCommand(TUint aOperatiorxld, const TDesC8&amp; aData) = 0;<br>
These are called by the intermediate layer when a message of the appropriate type comes in with the interface UID beknging to this instantiation of CRemConlnterfaceBase.<br>
Outer layer<br>
The provided component includes a 'core' API outer layer DLL. It provides implementations of CRemConlnterfaceBase, one for a controller client and one for a target client. It also provides a test 'extension' outer layer DLL to present Song Title and Absolute Volume APIs.<br>
Converter<br>
Converters are plug-ins, implementing the interface, and are stateless.<br>
The API essentially consists of two functions<br>
•	a first functton to convert from the bearer-specific to the interface-specific form<br>
•	a second function to convert in the opposite direction.<br>
It should be noted that a bearer Is not obliged to use converters. It can hard-code all its conversion code. However this assumes that the bearer will know how to convert any future API extension. This is perfectly acceptable if the<br><br>
bearer is only going to support an already-existing set of messages, but for extensibility converters sliould preferably be used.<br>
class CRemConConverterPlugin : public CBase<br>
virtual Tint lntorfaceToBearer(TUid aInterfaceUid, TUInt aOperatknId, const TDe$C8&amp; aDafa, TRemConMessageType aMsgType, TDes8&amp; aBearerData) const = 0;<br>
Called by the bearer to convert interface-specific data (interface DID, operation ID, message type and data) to the bearer-specific (packaged) form.<br>
virtual Tint BearerTolnterface(const TDesC8&amp; aBearerData, TUid&amp; aInterfaceUid, TUint&amp; aOperationId, TRemConMessageType&amp; aMsgType, TDes8&amp; aData) const - 0;<br>
Called by the bearer to convert bearer-specific data (packaged) to interface-specific data (interfaceUID, operation ID, message type and data).<br>
virtual TBool SupportedUids(const TUid&amp; aIntertaceUid, const TUid&amp; aBearerUid) const ~ 0;<br>
Called by RemCon to find out if this converter converts between this Interface and this bearer.<br>
virtual TBool Supportedlnterface(const TDesC8&amp; aInterfaceData, const TUid&amp; aBearerUid) const &amp; 0;<br>
Called by RemCon to find out if this converter converts between this interface and this bearer. aInterfaceData is tiie interface identifier in a bearer-specific format.<br>
Typical operational scenarios for the server system may be as folkws: Startup<br>
Example client startup code<br>
The client is obliged to do the folkwing;<br>
CRemConlnterfaceSelector'	ilnterfaceSelector<br>
CRemConlnterfaceSelector::NewL();<br><br>
Then the client must create an instance of the interface which they want to use. For example, for an application wishing to act as a target, and using the<br>
Core API;<br>
CRemConCoreApiTarget' iCorelf =<br>
CRemConCoreApiTarget::NewL('ilnterfaceSelecton 'tNs); where 1his' implements MRemConCoreAplTargetObserver. iCorelf is now owned by the interface selector, which is owned by the client.<br>
MRemConCk)reApiTargetObserver has pure virtuals to inform the implementer when various incoming Core API commands are delivered. CRemConCoreApiTarget also has methods to alkw the app to send responses to these commands.<br>
The client then needs to create a controller or target session. Only one of each may be created per instance of CRemConlnterfaceSelecton Only one target may be connected per client process.<br>
Creating a controller session;<br>
ilnterfaceSelector'&gt;Oper)ControllerL(); The controller session is opened in connectionless mode (any commands sent will be routed by the TSP). To make the controller connection-oriented, the folkwing may be folkwed;<br>
TRemConAddress addr;<br>
addrSearerUidO = TUid::Uld(0x1020453C);<br>
//No bearer-specific cor)r)ectior) data.<br>
ilnterfaceSelector-&gt;GoConnectionOrientedL(dddr); The client may wish to bring up a bearer-level connection at this time, to make the sending of the first command quicker:<br>
TRequestStatus stat;<br>
ilr}terfaceSelector-&gt;Conr)ectBearer(stat);<br>
User::WaitForRequest(stat);<br><br>
In the above example, the bearer with implementation UID 0x1020453C is used. This is the test serial bearer. Any commands sent by a connection-oriented controller are directed to the specific connection given in this call. To open a target session, the folkwing is called: ilnterfaceSelector-&gt;OpenTargetL0;<br>
Server-side<br>
The RemCon sen/er is started in its own process by the connection of the first session (controller or target). If the server is already running, the session will simply be connected.<br>
First, the singleton instance of CRemConServer is created. The first thing this server does after C++ construction is to register itself with the kernel via StartL, using its unique server name. If there is already an instance of the server mnning (due to a race condition triggered by more than one client side attempting to (X)nnect) StartL will leave and the nascent server will be destroyed cleanly. This ensures that there is only ever (at most) a single fully instantiated RemCon server in the system.<br>
After StartL, the server sets about creating the folkwing objects, with the associated actions:<br>
(a)	Any operating system objects that may be needed, such as any required system kgging objects or framework objects for plug-ins (such as Symbian's common object module).<br>
(b)	A shutdown timer. This is used to terminate the server when there are no connected sessions. It is only initiated when the last session ckses.<br>
(c)	The singleton connection history object, to support GetConnections and NotifyConnectionsChange APIs.<br>
(d)The singleton instance of CBearerManager. Creatbn of the bearer manager should cause (in its ConstructL) all bearer plug-ins to be enumerated and instantiated. This causes connection-oriented bearers to start listening for incoming connections. The test serial (connectionless) bearer opens its COM port and immediately calls back with ConnectComplete, as if it had been asked to make an outgoing<br><br>
connection. If there are no bearer Implementations in the system, RemCon will panic. This is because if this is a valid device configuration, then RemCon should also not have been implemented,<br>
(e)	Five instances of CMessageQueue, used to kg messages. There is one each for outgoing commands pending addressing or permission-granting by the TSP; outgoing commands whicli have been sent (pending responses from remotes); incoming commands pending addressing by the TSP; incoming messages which are pending a client Receive request being posted; and incoming commands which have been delivered to controller sessions (awaiting responses from controllers).<br>
(f)	The singleton Instance of the converter manager. This makes one Instance of each converter.<br>
(g)The singleton instance of the TSP. If there is not precisely one implementation of the TSP interface in the system, RemCon will panic. The TSP may perform any instantiation it wishes, but it Is not expected by RemCon to do anything at all other than successfully return an object which can be used to address commands.<br>
All of the above actions happen synchronously. From this point on, the<br>
system     is    successfully    instantiated.	Immediately    after    this,<br>
CActiveScheduler::Start is called in the server startup code, and any further actions occur asynchronously. These actions include:<br>
(a)	A change to a connection over a bearer from the remote end. If an incoming connection arises, RemCon is told by the bearer, if a connection is dropped remotely, RemCon is also told. RemCon uses this information to complete client notifications.<br>
(b)	Completion of a RemCon-initiated connect or disconnect request on a bearer for a specific connection. RemCon handles tliese in the same way as remotely-triggered connection changes. Connect and disconnect requests are initiated by the client. When RemCon wants to send a message over a particular connection, it does not check that it exists first (as kng as tlie bearer exists)-Remcon just gives the message to the bearer and leaves the bearer to deal with the message.<br><br>
(c)	An incoming message from a bearer.<br>
(d)	An incoming client request. If the client ckses its session, then, if it is the last session, the server will begin to shut down, A typical 'Shutdown' scenario is described bekw. If the client tries to send a message, then the message will be addressed by the TSP or explicitly by the client (if it is connection-oriented).<br>
Shutdown<br>
To disconnect from RemCon. the client must delete any interface objects and then the interface selector. Cksure of the last open session triggers the shutdown of the server.<br>
Whenever a session ckses, its destructor is called. This unconditionally informs the server of the event, which removes any commands beknging to that session from the queues and keeps track of the number of open sessions. If the number of open sessions falls to zero, then the shutdown timer is started. When the shutdown timer fires, the server terminates itself by calling CActiveScheduler::Stop. If any new sessions arrive (at any time) the shutdown timer is cancelled, making sure that the server is not terminated when a session is requested.<br>
When CActiveSchedu!er::Stop is called, execution returns to the server startup code after the call to CActiveScheduleriStart, The server object Is destroyed immediately. The folkwing events also occur in the folkwing order:<br>
(a)	The bearer manager is destroyed. This cancels all outstanding requests on the bearers and destroys them synchronously. Destruction of a bearer is arranged to operate cleanly, cksing connections and cancelling self-requests on their service providers appropriately.<br>
(b)	The shutdown timer can be safely destroyed at this time,<br>
(c)	The arrays of messages are destroyed,<br>
(d)	The TSP is destroyed. However, there may be a request outstanding on It, for instance if there Is an incoming command which is currently being addressed by the TSP. Hence, the TSP is arranged to cancel any outstanding requests and self cleanse at this time,<br>
(e)The converter manager is destroyed. It destroys all the converter instances.<br><br>
(T)  I ne connection nisxory oojeci is aesxroyea.<br>
(g)Any operating system objects that were created are also now destroyed. Destruction of the server, once it has started, is irrevocable, if a client tries to connect while server shutdown is occurring the kernel will complete the client's attempt to connect with an error. In this circumstance, the client side will then restart the server and again try to connect.<br>
Outgoing command and incoming response<br>
An outgoing command scenario may start with a controller client sending a command, using an API provided by an instantiated interface, for example:<br>
TRequestStatus stat;<br>
iCorelf-&gt;Play(stat);<br>
User::WaitForRequest(stat); The Core API translates the Play (for example) request into a generic 'operation ID' and associated data (e.g. play speed). It passes this data to the intermediate layer with its interface DID. The intermediate layer uses its controller session to send the message to the server.<br>
The server examines the controller session. A CRemConMessage is constructed containing the connection address (if the controller is connection-oriented), interface UID, operation ID, associated data, message type (command or response), and the ID of the originating session.<br>
If the session is a connection-oriented controller, then this message is placed on the 'outgoing pending access to the TSP' queue and given to the TSP for permission-granting. If permission Is given, the message is placed on the 'outgoing sent' queue and delivered to the con-ect bearer with the given connection address. The bearer indicates synchronously its acceptance of this request-if it errors then the message is removed from the 'outgoing sent' queue. The dienf s send request Is completed immediately. If permission is denied by the TSP then the client's request is completed with KErrPermissionDenied.<br><br><br><br>
If the TSP directs a Play command to multiple remotes, and they each generate a response, PlayResponse will end up being called on the client multiple times.<br>
Incoming command and outgoing response<br>
This scenario starts with a bearer delivering an Incoming command to RemCon. RemCon creates a CRemConMessage containing the remote address, interface UID. operation ID, associated data, and message type (command or response). This message is placed in the 'incoming pending address' queue and sent to the TSP for addressing.<br>
The purpose of the TSP in this scenario Is essentially to populate the session ID field of the address. Once this is done, the message is removed from the 'incoming pending address' queue and N copies added to the 'incoming delivered' queue, and each is delivered to the relevant target client: the 'incoming pending Receive' queue may be used If the client does not have a Receive request outstanding when the command arrives at the session. The intermediate layer checks the interface UID, fonwarding the message to the correct interface object. The interface decomposes the message and calls, for instance, Play on the client, indicating that a Play command has been received.<br>
The client may choose to send a response. It calls PlayResponse, which sends a message to RemCon via the intermediate layer's target session. The server checks the 'incoming delivered' queue for commands matching the session ID, interface UID and operation ID, and uses the remote address of the found command to address the response to the correct bearer. The found command is removed from the queue and destroyed.<br>
A remote control client application may be implemented as folkws. This scenario involves implementing a client of the remote control system, using the existing remote control APIs.<br><br>
Firstly, it is decided whether the application is for a controller or a target. If it is required to remote control other devices, a controller appiication is required. If it is required to be remote controlled, a target application is required. It is permitted to be both a controller and a target at any one time.<br>
If a controller is required, is it necessary to know which remote to communicate with, and over which bearer. If this information is known,'then the application may operate in connection-oriented mode, where the remote control system is explicitly told the bearer and the remote's address. If this information is not known, then it is required to operate in connectionless mode (the default). In this case, commands are routed by the system (specifically, by the Target Selector Plug-in as provided by the device manufacturer.<br>
It is then necessary to decide which APIs are required to be used. The Core API is provided, which covers many basic operations including Play, Stop, etc. (Tracklnfo and Absolute Volume APIs are also provided, but without the kwer-level implementations required to be able to send and receive such messages over Bluetooth.)<br>
The controller set up will now be described.<br>
The first step is to create an instance of CRemConinterfaceSelector. This is the heart of the client side, owning sessions on the server and interface objects, and routing messages between them.<br>
CRemConlnterfaceSelector' sei = CRemConlnterfaceSelector::NewL();<br>
Next an instance of the controller interface of the desired API is created (in this example the Core API).<br>
CRemConCoreApiController' cont =<br>
CRemConCoreApiController:NewL('this, 'sel);<br>
This code assumes that this is an object of a type which implements MRemConCoreApiControllerObserver. This mixin determines how incoming responses (to your commands) are delivered. Ownership of cent now resides with sel.<br><br>
It is now necessary to teli the interface selector to connect a controller session with the server.<br>
sel-&gt;OpenControllerL();<br>
At this point, the controller session is connectionless. Any commands sent will be addressed by the TSP. If the bearer and remote which are to be controlled are known, then the folkwing code may be used:<br>
TRemConAddress addr;<br>
addr.BearerUidO   =    xxx;   //  xxx=:=the bearer's UID<br>
addr.Addr 0   =    yyy;   //  the yyy=reinote's  address   in bearer-specific form<br>
sel-&gt;GoConnectionOrlentedL (addr) ; Once GoConnectionOrientedL succeeds, the application is connection-oriented, and the controller session is dedicated to communicating with the single remote specified. The TSP does not address specific commands, but still permits or denies each command sent. Note that no bearer-level connection with the remote is established by this operation.<br>
It is possible to become connectionless again using<br>
sel-&gt;GoConnectionlessL();<br>
Once connection-oriented, to reduce the latency of the first command sent, it is possible to explicitly set up a bearer-level connection with the remote as folkws:<br>
TRequestStatus stat; sel-&gt;ConnectBearer(stat); User::WaitForRequest(stat);<br>
If this is not done, the server will attempt to bring up a connection as required, when the first (and any subsequent) command is sent. ConnectBearer is provided as a facility to reduce latency.<br>
The bearer-level connection can be pulled down as folkws:<br>
TRequestStatiis stat;<br>
sel-&gt;DisconnectBearer(stat);<br><br>
User: :WaitForRequest (stat) ;<br>
It Is worth noting that bearer-level connections should not be controlled arbitrarily. It is only possible to control the bearer-level connection on which the application is currently 'connection-orlented'. This is the reason for the lack of a TRemConAddress parameter in ConnectBearer and DisconnectBearer.<br>
It should also be noted that the remote may bring up or down the application connection at its own behest. If a remote pulls down the connection, then the next command sent will cause the server to try to pull it back up again. This may entail an unexpected delay. If the re-connection fails, the send will be failed. Despite all this, the application will remain connection-oriented: orientation of connection is independent of any actual bearer-level connection.<br>
If the state of connection, at the bearer level, is considered of interest, the<br>
folkwing APIs on CRemConlnterf aceSelector may be used:<br>
IMPORT_C  Tint GetConnections (TSglQue<tremcorladdress>&amp; aConnections) ;<br>
IMPORT_C void NotifyConnectionsChange (TRequestStatusSc aStatus) ;<br>
IMPORT_C Tint NotifyConnectionsChangeCancel () ; GetConnections supplies all the currently extant connections in the system. NotifyConnectionsChange just indicates When that set has changed.<br>
Sending commands and receiving responses<br>
cent can now be used to send commands as folkws.<br>
TRequestStatus stat;<br>
cont-&gt;Play(stat);<br>
User; ;WaitForRequest (stat) ;<br>
Responses are delivered via the MRemConCoreApiControllerObserver interface.<br><br>
Only one command send can be outstanding at any time. If a connectionless controller is being implemented, the TSP may have addressed the command to multiple remotes. In this case, a single command send may result in multiple responses, and these are filtered or used as considered appropriate.<br>
If the TSP has sent the command to multiple remotes, and one or more of those sends fails, an enror value will be provided from one of the failed sends. The number of remotes to which the command was successfully sent is also provided. Bearers are obliged to give back a response to each command they send. Depending on the bearer, this response may or may not have actually come from the remote, A send either succeeds or fails at the bearer level-either the bearer takes responsibility for sending or it does not. Hence even a 'successful' send may not actually result in a transmission to the required remote.<br>
Note that each command sent to a remote involves memory being alkcated in the server's heap, which is only released on client cksure or when a response is received. If there is good reason to believe that any remote for which communication is not required is no knger present then it is preferably arranged to stop sending commands to that remote in order to reduce the kad on the memory in the server.<br>
Tear-down<br>
To clean up the involvement in the remote control system, all outstanding asynchronous requests should be cancelled and the interface selector should be deleted.<br>
Target Setup<br>
This is very similar to the controller setup, except that there is no concept of<br>
connection-orientation. Targets implement a mixin through which the interface<br>
selector delivers incoming commands, and instantiates an object to send<br>
responses. All incoming commands are addressed by the TSP. Outgoing<br><br>
responses are addressed implicitly to the remote from which the originating command came.<br>
CRemConlnterfaceSelector' sel = CRemConlnterfaceSelector: :NewL{) ;<br>
CRemConCoreApiTarget' targ = CRemConCoreApiTarget: :NewL('this, 'sel) ;<br>
Ownership of targ now resides in sel.<br>
The client now opens a target session on the server.<br>
sel-&gt;OpenTargetL();<br>
Receiving commands and sending responses<br>
Incoming    commands    are    given    via    (in    the    above    case)    the<br>
MRemConCoreApiTargetObserver mixln.<br>
Having received a command, it is required to send a response.<br>
TRequestStatus  stat;<br>
cont-&gt;PlayReBponse(stat,   response); User::WaitForReguest (stat) ;<br>
Only one response can be outstanding at any time. If commands come in quickly, it is necessary to queue responses to them. However, it should be remembered that each command delivered to a target involves memory alkcated in the sen/er's heap, which is only released on client cksure or when a response is sent.<br>
Tear-down<br>
To clean up involvement in the remote control system, all outstanding asynchronous requests should be cancelled and the interface selector should be deleted.<br>
A new remote control API may be implemented as folkws.<br>
To implement a new API, two pieces of work need to be undertaken: the creation of an outer-layer DLL, and the creation of a family of converters.<br>
Outer-layer DLL<br>
The jobs of an outer-layer DLL are:<br><br>
(a)	to present to the client a friendly API,<br>
(b)	to convert between fields/terms in the client API and the DLL's internal data format (this will include both operation IDs and the layouts of fields of operation-specific data), and<br>
(c)	to publish as much of the above as is needed to (i) empower clients to use the API, and (ii) empower implementers of converters.<br>
Folkwing the pattern established in the Core API, the folkwing steps may be folkwed:<br>
o   create a static DLL linking against<br>
remconinterf acebase ' lib.<br>
o   alkcate a new UID for the API.<br>
o   define a class for each of the controller and target types in the<br>
new API. each deriving from CRemConlnterf aceBase, o   Provide NewL and destructor methods, and public exported<br>
methods - for the controller, to send commands, and, for the<br>
target, to send responses. o   Define observer mixins for each of the controller and target, for<br>
the client to be informed of incoming responses and commands<br>
respectively. o   In each of the interfaces,<br>
CRemConlnterfaceBase: :MrGibNewMessage can be<br>
implemented to decode an incoming message and call the correct mixin method. o   Specify operation identifiers, and the format of each message in the API. These&gt;A^II be used to create converters.<br>
Converters<br>
When a client sends a message using an outer-layer DLL. a bearer receives<br>
the folkwing information: the UID of the API the message came from, the operation ID of the message, and a descriptor containing any operation-specific data. It is the job of the converter to convert between the data format in the operation-specific data and the format required by the bearer.<br><br>
The Converter API is in remotecontrol\converterplug-in\public (but actually<br>
#include from  epoc32\include\remcon).  The  Core^Serial  converter  is  in<br>
remotecontrol\test\converters\Core„Serial.<br>
Folkwing the  pattern established  in the  Core_Serial  converter,  a  new<br>
implementation UID should be alkcated for the converter, implementing the<br>
Converter API as an ECOM plug-in.<br>
CReimConConverterPlug-in: :SupportedUids	(const	TUid&amp;<br>
ainterfaceUid, const TUid&amp; aBearerUid) should be implemented in order to determine whether or not conversion of message formats between the given API and the given bearer are supported.<br>
CRemConConverterPlug-in: iSupportedlnterf ace (const    TDesC8&amp; ainterfaceData,   const   TUid&amp;  aBearerUid) is then implemented to answer the same support question, except posed in a slightly different way. In this case, the API is identified by a package in the format of the given bearer. The remaining converter implementation is relatively straightfonAfard.<br>
Converters are stateless synchronous data-processing machines. To do the conversion, the converter has to know the operation IDs of the API, and the API's UID.<br>
However, a bearer must explicitly request the help of a converter to 'understand' a message. If the bearer does not, then no converter will be invoked- the bearer is essentially cksed to APIs beyond those it already knows how to do the conversion for. This may be perfectly valid, depending on the bearer.<br>
If however a new API is being implemented, a converter must be provided for each existing bearer. If this information is not provided, then the framework is effectively failing to infonn a bearer of how to convert messages between its format and the format of the new API: in essence, this is tantamount to saying that the new API cannot be used over that particular bearer. This too may be fine, depending on the particular framework requirements.<br><br>
A converter needs not only fomiatting Information published by the API, but also formatting information from the bearer. In the nature of things, however, bearer formats are more likely to exist as published specifications (e.g. AVRCP) than are proprietary remote control APIs.<br>
A TSP may be implemented s folkws.<br>
Firstly, a plug-in implementing the TSP API is implemented, with a new implementation UID.<br>
The TSP should be prepared so that it can answer the folkwing questions:<br>
(a)	to which currently-connected (i.e. connected to the server) target clients should the server deliver the folkwing incoming command (with an interface UID and operation ID, and a collection of information about the target clients, including their secure IDs)<br>
(b)	to which remote(s) should the server deliver the folkwing outgoing command (with an Interface UID and operation ID, information about the controller client trying to send the command, including its secure ID and its RMessage2, and a collection of TSecurityPolicys for the bearers).<br>
It should be remembered that if the TSP gives a command to client X then it is effectively empowering client X to send precisely one response over the bearer which delivered the originating command.<br>
There must be only one such DLL In ROM.<br>
A new remote control bearer can be implemented as follows.<br>
A plug-in implementing the bearer API is created, with a new implementation UID.<br>
The bearer API is connection-oriented. All messages sent and delivered are associated either with a specific recipient address or a specific sender<br><br>
address. The server is responsible for bringing up a bearer-level connection to a particular remote before issuing a bearer-level send to that remote.<br>
Real bearers may not in fact be connection-oriented. For example, the test serial bearer simply works over a serial cable. Therefore, (a) it has no bearer-specific remote address format (so 'remote addresses' simply consist of the serial bearer's UID), and (b) it has to emulate connection-oriented be haviour by 'indicating' an incoming connection essentially on start-up, when it first opens the serial port. This 'connection' never goes down. Bearers are instantiated at server start-up time, and should immediately start listening for incoming connections. Each connection is indicated up to the server.<br>
It can be seen from the above description that the present invention provides a generic remote control framework which provides significant advantages over current non generic frameworks, including;-<br>
•	facilitating the creation of applications that can be remotely controlled. Because existing remote control solutions are invariably tied to one bearer technokgy, it has not hitherto been possible to provide an application for generic remote control, unless the application was devekped to utilise specific bearer technokgies involved.<br>
•	The ability for device manufacturers to release after-market accessories using new technokgies were not catered for at device manufacture time. Without this invention, any such accessories would need to ship with a new version of any controllable applications.<br>
•	The ability to have multiple controllable applications running concurrently on the device: in cases where more than one application exists it provides a mechanism for selecting one of a number of possible target applications.<br><br>
Although the present invention has been described with reference to particular embodiments, "rt will be appreciated that modifications may be effected whilst remaining within the scope of the present invention as defined by the appended claims.<br>
One possible example of such a modification of this invention is applicable to a computing device with multiple audio applications, ail of which have registered to receive remote control commands. Such a device with multiple audio applications may comprise a mobile telephone with many multimedia applications capable of playing audio data, such as an IV1P3 player, a radio, a browser plug-in which can play streamed audio from the internet, a voice memo or dictation application, and a kcal voicemail store.<br>
Where all of these applications have registered to receive remote control commands, this embodiment would enable correct delivery of such commands in the case where one application was already playing audio by enabling the remote control manager to deliver remote control commands on such a device to the application which is already playing audio.<br><br><br><br><br><br><br><br><br><br><br><br><br>
Claims:<br>
1.	A method of enabling one or more target devices to be remotely<br>
controlled by one or more controller devices through the use of<br>
commands sent over at least one of a plurality of bearers including but<br>
not limited to:<br>
•	Fixed wires, including USB and simple serial.<br>
•	Infrared<br>
•	Ultrasound<br>
•	RF, including but not limited to Bluetooth and 802.11 Wireless Networking<br>
through the provision of a generic remote control interface enabling the said one or more target devices to receive commands from any arbitrary controller device over any arbitrary bearer,<br>
2.	A method according to claim 1 wherein at least one controller device is arranged to cause the generic interface to transmit commands to any arbitrary target device over any arbitrary bearer.<br>
3.	A method according to claim 1 or claim 2 wherein commands are independent of any type of bearer.<br>
4.	A method according to any one of claims 1 to 3 wherein at least one target device is enabled to act as a controller device for transmitting commands to a target device in addition to acting as a target device for receiving commands from a controller device.<br>
5.	A method as claimed in any one of claims 1 to 4 wherein at least one controller device is enabled to act as a target device for receiving commands from a controller device in addition to acting as a controller device for transmitting commands to a target device.<br><br>
A method according to any one of the preceding claims wherein the generic remote control interface is provided with the capability to utilitise plug-in modules specific to a particular type of bearer.<br>
A method according to claim 7 wherein target and/or controlier devices are arranged to enable additional plug-in modules for additional bearers to be added after manufacture.<br>
A method according to any one of the preceding claims wherein a target device is running multiple applications and in which one or more of the said applications can receive commands from a different controller device.<br>
A method according to of the preceding claims wherein a target device is njnning multiple applications and in which the determination of which of the said multiple applications a command is intended for is made by a target selector.<br>
.A method according to claim 8 or 9 wherein the multiple applications comprise audio applications and commands are routed by the remote control interface to the application that is currently playing audio.<br>
A method according to claim 9 wherein the target selector is a plug-in.<br>
A method according to any one of the preceding claims wherein the remote control interface is configured as a server.<br>
A method according to claim 12 wherein the sen/er is configured as a transient server.<br>
 A method according to claim 12, when appendant to claim 9, wherein the target selector is arranged within the server.<br><br>
15.A method according to any one of the preceding claims wherein commands between a controller device and a target device are created in dependence upon any one or more of the following factors:<br>
a.	application order in Read Only Memory (ROM) of the device<br>
b.	whether or not the application is in the foreground<br>
c.	recent history of user operations<br>
d.	relative deemed importance of applications.<br>
16.	A method according to any one of the preceding claims wherein the<br>
remote control interface is arranged for connectionless operation<br>
(where commands are routed by the system as decided by the device<br>
manufacturers) and connection-oriented operation (where the target<br>
specifies the bearer and any relevant addressing information for the<br>
controller).<br>
17.	A method according to any one of the preceding claims wherein at<br>
least one target device and/or at least one controller device is selected<br>
to comprise a mobile telephone.<br>
18.	A computing device arranged to operate in accordance with a method<br>
as claimed in any of claims 1 to 17.<br>
19.	An operating system for causing a computing device to operate in<br>
accordance with a method as claimed in any one of claims 1 to 17.<br><br></tremcorladdress></tremconaddress></tciientlnfo></tbearersecurlty></tremconaddress></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=FQrWUdt8u8uz54qhgXdbug==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=FQrWUdt8u8uz54qhgXdbug==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==</a></p>
		<br>
		<div class="pull-left">
			<a href="269119-ultrasonic-medical-instrument-and-medical-instrument-connection-assembly.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="269121-audio-coding.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>269120</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>6039/CHENP/2007</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>41/2015</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>09-Oct-2015</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>30-Sep-2015</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>31-Dec-2007</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SYMBIAN SOFTWARE LIMITED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2-6 BOUNDARY ROW LONDON SE1 8HP</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>JAMES, SIAN</td>
											<td>37 CAMBRIDGE ROAD MILTON, CAMBRIDGE CB24 6AW</td>
										</tr>
										<tr>
											<td>2</td>
											<td>HARRIS, NEAL</td>
											<td>6 IMPINGTON LANE IMPINGTON, CAMBRIDGE CB24 9LT</td>
										</tr>
										<tr>
											<td>3</td>
											<td>HOWES, TIM</td>
											<td>57 ROSEMARY ROAD WATERBEACH CAMBRIDGE CB25 9NB</td>
										</tr>
										<tr>
											<td>4</td>
											<td>TURNER, JOHN</td>
											<td>76 GATEWAY GARDENS ELY CB6 3DE</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G08C 17/02</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/GB06/02395</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2006-06-29</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>0513312.9</td>
									<td>2005-06-29</td>
								    <td>U.K.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/269120-remote-control-framework by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:16:47 GMT -->
</html>
