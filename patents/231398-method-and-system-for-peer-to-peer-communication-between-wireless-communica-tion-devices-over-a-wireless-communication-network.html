<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/231398-method-and-system-for-peer-to-peer-communication-between-wireless-communica-tion-devices-over-a-wireless-communication-network by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:16:28 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 231398:METHOD AND SYSTEM FOR PEER-TO-PEER COMMUNICATION BETWEEN WIRELESS COMMUNICA TION DEVICES OVER A WIRELESS COMMUNICATION NETWORK</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD AND SYSTEM FOR PEER-TO-PEER COMMUNICATION BETWEEN WIRELESS COMMUNICA TION DEVICES OVER A WIRELESS COMMUNICATION NETWORK</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The present invention discloses a method and a system for peer-to-peer communication between a first handset and a second handset, the first handset and second handset communicatively coupled with a communication server over a wireless communication network. The method includes receiving, at the communication server, a server opcode set from the first handset (540), the server opcode set compiled on the first handset (540) and comprising at least one server opcode and a first data payload ; wherein said method further includes : processing the server opcode set and compiling at least a portion of the first data payload into a remote opcode set comprising at least one remote opcode and a second data payload; and sending the remote opcode set to the second handset for processing thereon.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>METHOD AND SYSTEM FOR PEER - TO - PEER COMMUNICATION<br>
BETWEEN WIRELESS COMMUNICATION DEVICES OVER A<br>
WIRELESS COMMUNICATION NETWORK<br>
Background<br>
1.   Field of the Invention<br>
[01] The present invention generally relates to the field of wireless communications<br>
and more particularly relates to peer-to-peer communication between wireless<br>
communication devices over a wireless communication network.<br>
2.   Related Art<br>
[02]  Conventional wireless communication devices (also described herein as "wireless<br>
devices" "handsets" and "mobile devices") that are deployed in the market typically<br>
connect with other wireless communication devices by way of a conventional voice<br>
connection over a wireless communication network. This conventional voice connection<br>
allows for real time audio data to be conveyed between the two or more geographically<br>
disperse wireless communication devices participating in the voice connection.<br>
[03]  Another useful aspect of conventional wireless communication devices is their<br>
ability to establish a data connection with the wireless communication network.   Such a<br>
conventional data connection allows the mobile device to communicate with the network,<br>
for example to request and receive software updates.<br>
[04]  What is lacking, however, is the ability for conventional mobile devices to initiate<br>
and participate in data communications between mobile devices, carried out over a<br>
wireless communication network. Therefore, what is needed is a system and method that<br>
overcomes these significant problems found in the conventional systems as described<br>
above.<br><br>
Summary<br>
[05]  Handsets that  are deployed  in the field have  limited  data communication<br>
capabilities. In particular, handsets completely lack the ability for peer-to-peer data<br>
communication  between  handsets.   This   inability   limits   the   utility  of wireless<br>
communication devices, and therefore also limits air time usage.<br>
[06] A peer-to-peer data communication system and method is presented that allows<br>
handsets to engage in data communications over a wireless communication network.<br>
Initially, an originating handset creates a server operation code ("opcode") set and<br>
couples the server opcode set with a corresponding data payload. The server opcode set<br>
and corresponding data payload is then sent to a network based server where the data is<br>
extracted and the executable instructions corresponding to the opcodes are carried out.<br>
The executable instructions cause the network based server to compile a remote opcode<br>
set and a corresponding data payload. This remote opcode set and data payload are sent<br>
to a recipient handset identified by the originating handset in the data payload. When the<br>
recipient handset receives the remote opcode set and data payload, the recipient handset<br>
extracts the data payload and executes the instruction corresponding to the opcodes in the<br>
remote opcode set. Execution of the instructions causes an action to be performed on the<br>
recipient handset that effectuates data communication between the originating handset<br>
and the recipient handset.<br>
[07] A variety of applications may be implemented using this system and method for<br>
peer-to-peer data communications between wireless communication devices. For<br>
example, phone book entries on mobile devices can be added or updated, data files such<br>
as pictures or emails or other documents can be delivered, customer ringers can be<br>
delivered and assigned to the originating handset, GPS and position location can be<br>
requested and provided, and even a fantasy sports team draft can be conducted.<br>
Brief Description of thaDrawings<br>
[08]  The details of the present invention, both as to its structure and operation, may be<br>
gleaned in part by study of the accompanying drawings, in which like reference numerals<br>
refer to like parts, and in which:<br><br><br>
[09]  Figure 1 is a schematic block diagram of the overall wireless device software<br>
maintenance system;<br>
[10]  Figure 2 is a schematic block diagram of the software maintenance system,<br>
highlighting the installation of instruction sets via the airlink interface;<br>
[11]  Figure 3 is a schematic block diagram illustrating the present invention system<br>
for executing dynamic instruction sets in a wireless communications device;<br>
[12]  Figure 4 is a schematic block diagram of the wireless device memory;<br>
[13]  Figure 5 is a table representing the code section address table of Fig. 3;<br>
[14]  Figure 6 is a detailed depiction of symbol library one of Fig. 3, with symbols;<br>
[15]  Figure 7 is a table representing the symbol offset address table of Fig. 3;<br>
[16]  Figure 8 is a depiction of the operation code ("opcode") being accessed by the<br>
run-time engine;<br>
[17]  Figure 9 is a more detailed depiction of the first operation code of Fig. 8;<br>
[18]  Figures 10 is a are flowchart illustrating the present invention method for<br>
executing dynamic instruction sets in a wireless communications device;<br>
[19]  Figure 11  is a flowchart illustrating an exemplary dynamic instruction set<br>
operation;<br>
[20]  Figure 12 is a flowchart illustrating another exemplary dynamic instruction set<br>
operation;<br>
[21]  Figure 13 is a flowchart illustrating a third exemplary dynamic instruction set<br>
operation;<br>
[22]  Figure 14 is a flowchart illustrating a fourth exemplary dynamic instruction set<br>
operation;<br>
[23]  Figure 15 is a flowchart illustrating a fifth exemplary dynamic instruction set<br>
operation;<br>
[24]  Figure 16 is a high level network diagram illustrating an example wireless<br>
communication network;<br>
[25]  Figure 17A is block diagram illustrating an example wireless communication<br>
device;<br><br>
[26]  Figure 17B is block diagram illustrating an example remote runtime instructions<br>
code section;<br>
[27]  Figure 18A is a block diagram illustrating an example PMRTI server;<br>
[28]  Figure 18B is a block diagram illustrating an example server runtime instructions<br>
code section;<br>
[29]  Figure 19 is a flow diagram illustrating an example peer-to-peer communication<br>
between handsets;<br>
[30]  Figure 20 is a flow diagram illustrating an example process for executing<br>
dynamic instruction sets on a wireless communication device;<br>
[31]  Figure 21  is a flow diagram illustrating an example process for compiling<br>
dynamic instruction sets on a wireless communication device;<br>
[32]  Figure 22 is a flow diagram illustrating an example process for executing<br>
dynamic instruction sets on a PMRTI server;<br>
[33]  Figure 23 is a flow diagram illustrating an example process for sending a data<br>
communication to a peer handset; and<br>
[34]  Figure 24 is a block diagram illustrating an exemplary computer system that may<br>
be used in connection with various embodiments described herein.<br>
Detailed Description<br>
[35] Certain embodiments as disclosed herein provide for systems and methods for bi-<br>
directional communication of dynamic instruction sets between a wireless<br>
communication device and a wireless communication network. For example, one method<br>
as disclosed herein allows for a wireless communication device to dynamically construct<br>
an instruction set and send that instruction set to the network for execution and<br>
processing.<br>
[36] After reading this description it will become apparent to one skilled in the art how<br>
to implement the invention in various alternative embodiments' and alternative<br>
applications. However, although various embodiments of the present invention will be<br>
described herein, it is understood that these embodiments are presented by way of<br>
example only, and not limitation. As such, this detailed description of various alternative<br><br>
embodiments should not be construed to limit the scope or breadth of the present<br>
invention as set forth in the appended claims.<br>
[37]  Some portions of the detailed descriptions that follow are presented in terms of<br>
procedures, steps, logic blocks, codes, processing, and other symbolic representations of<br>
operations on data bits within a wireless device microprocessor or memory.   These<br>
descriptions  and representations are the means used by those  skilled  in the data<br>
processing arts to most effectively convey the substance of their work to others skilled in<br>
the art.   A procedure, microprocessor executed step, application, logic block, process,<br>
etc., is here, and generally, conceived to be a self-consistent sequence of steps or<br>
instructions  leading  to  a desired  result.  The  steps  are those  requiring physical<br>
manipulations of physical quantities.   Usually, though not necessarily, these quantities<br>
take the form of electrical or magnetic signals capable of being stored, transferred,<br>
combined, compared, and otherwise manipulated in a microprocessor based wireless<br>
device.  It has proven convenient at times, principally for reasons of common usage, to<br>
refer to these signals as bits, values., elements, symbols, characters, terms, numbers, or the<br>
like.   Where physical devices, such as a memory are mentioned, they are connected to<br>
other physical devices through a bus or other electrical connection.   These physical<br>
devices can be considered to interact with logical processes or applications and, therefore,<br>
are "connected" to logical operations.  For example, a memory can store or access code<br>
to further a logical operation, or an application can call a code section from memory for<br>
execution.<br>
[38] It should be borne in mind, however, that all of these and similar terms are to be<br>
associated with the appropriate physical quantities and are merely convenient labels<br>
applied to these quantities. Unless specifically stated otherwise as apparent from the<br>
following discussions, it is appreciated that throughout the present invention, discussions<br>
utilizing terms such as "processing" or "connecting" or "translating" or "displaying" or<br>
"prompting" or "determining" or "displaying" or "recognizing" or the like, refer to the<br>
action and processes of in a wireless device microprocessor system that manipulates and<br>
transforms data represented as physical (electronic) quantities within the computer<br><br>
system's registers and memories into other data similarly represented as physical<br>
quantities within the wireless device memories or registers or other such information<br>
storage, transmission or display devices.<br>
[39]  Fig.  1 is a schematic block diagram of the overall wireless device software<br>
maintenance system  100.  The present  invention  system software organization  is<br>
presented in detail below, following a general overview of the software maintenance<br>
system 100.  The general system 100 describes a process of delivering system software<br>
updates and instruction sets (programs), and installing the delivered software in a<br>
wireless device. System software updates and patch manager run time instructions<br>
(PMRTI), that are more generally known as instruction sets or dynamic instruction sets,<br>
are created by the manufacturer of the handsets.   The system software is organized into<br>
symbol libraries.   The symbol libraries are arranged into code sections.   When symbol<br>
libraries are to be updated, the software update 102 is transported as one or more code<br>
sections.   The software update is broadcast to wireless devices in the field, of which<br>
wireless  communications device   104  is  representative,  or transmitted in  separate<br>
communications from a base station 106 using well known, conventional air, data or<br>
message transport protocols.. The invention is not limited to any particular transportation<br>
format, as the wireless communications device can be easily modified to process any<br>
available over-the-air transport protocol for the purpose of receiving system software and<br>
PMRTI updates.<br>
[40] The system software can be viewed as a collection of different subsystems. Code<br>
objects can be tightly coupled into one of these abstract subsystems and the resulting<br>
collection can be labeled as a symbol library. This provides a logical breakdown of the<br>
code base and software patches and fixes can be associated with one of these symbol<br>
libraries. In most cases, a single update is associated with one, or at most two, symbol<br>
libraries. The rest of the code base, the other symbol libraries, remains unchanged.<br>
[41] The notion of symbol libraries provides a mechanism to deal with code and<br>
constants. The read-write (RW) data, on the other hand, fits into a unique individual RW<br>
library that contains RAM based data for all libraries.<br><br>
[42]  Once received by the wireless device 104, the transported code section must be<br>
processed. This wireless device over-writes a specific code section of nonvolatile<br>
memory 108. The nonvolatile memory 108 includes a file system section (FSS) 110 and<br>
a code storage section 112.  The code section is typically compressed before transport in<br>
order to minimize occupancy in the FSS 110.   Often the updated code section will be<br>
accompanied by its RW data, which is another kind of symbol library that contains all the<br>
RW data for each symbol library. Although loaded in random access volatile read-write<br>
memory 114 when the system software is executing, the RW data always needs to be<br>
stored in the nonvolatile memory 108, so it can be loaded into random access volatile<br>
read-write memory 114 each time the wireless device is reset. This includes the first time<br>
RW data is loaded into random access volatile read-write memory. As explained in more<br>
detail below, the RW data is typically arranged with a patch manager code section.<br>
[43]  The system 100 includes the concept of virtual tables. Using such tables, symbol<br>
libraries in one code section can be patched (replaced), without breaking (replacing) other<br>
parts of the system software (other code sections).  Virtual tables execute from random<br>
access volatile read-write memory 114 for efficiency purposes.  A code section address<br>
table and symbol offset address table are virtual tables.<br>
[44] The updated code sections are received by the wireless device 104 and stored in<br>
the FSS 110. A wireless device user interface (UI) will typically notify the user that new<br>
software is available. In response to UI prompts the user acknowledges the notification<br>
and signals the patching or updating operation. Alternately, the updating operation is<br>
performed automatically. The wireless device may be unable to perform standard<br>
communication tasks as the updating process is performed. The patch manager code<br>
section includes a non-volatile read-write driver symbol library that is also loaded into<br>
random access volatile read-write memory 114, The non-volatile read-write driver<br>
symbol library causes code sections to be overwritten with updated code sections. The<br>
patch manager code section includes the read-write data, code section address table, and<br>
symbol offset address table, as well a symbol accessor code and the symbol accessor<br>
code address (discussed below).   Portions of this data are invalid when updated code<br><br>
sections are introduced, and an updated patch manager code sections includes read-write<br>
data, a code section address table, and a symbol offset address table valid for the updated<br>
code sections. Once the updated code sections are loaded into the code storage section<br>
112, the wireless device is reset. Following the reset operation, the wireless device can<br>
execute the updated system software. It should also be understood that the patch<br>
manager code section may include other symbol libraries that have not been discussed<br>
above. These other symbol libraries need not be loaded into read-write volatile memory<br>
114.<br>
[45] Fig. 2 is a schematic block diagram of the software maintenance system 100,<br>
highlighting the installation of instruction sets via the airlink interface. In addition to<br>
updating system software code sections, the maintenance system 100 can download and<br>
install dynamic instructions sets, programs, or patch manager instruction sets (PMIS),<br>
referred to herein as patch manager run time instructions (PMRTI). The PMRTI code<br>
section 200 is transported to the wireless device 104 in the same manner as the above-<br>
described system software code sections. PMRTI code sections are initially stored in the<br>
FSS 110. A PMRTI code section is typically a binary file that may be visualized as<br>
compiled instructions to the handset. A PMRTI code section is comprehensive enough to<br>
provide for the performance of basic mathematical operations and the performance of<br>
conditionally executed operations. For example, an RF calibration PMRTI could perform<br>
the following operations:<br>
IF RF CAL ITEM IS LESS THAN X<br>
EXECUTE INSTRUCTION<br>
ELSE<br>
EXECUTE INSTRUCTION<br>
[46] A PMRTI can support basic mathematical operations, such as: addition,<br>
subtraction, multiplication, and division. As with the system software code sections, the<br>
PMRTI code section may be loaded in response to UI prompts, and the wireless device<br>
must be reset after the PMRTI is loaded into code storage section 112. Then the PMRTI<br><br>
section can be executed. If the PMRTI code section is associated with any virtual tables<br>
or read-write data, an updated patch manager code section will be transported with the<br>
PMRTI for installation in the code storage section 112. Alternately, the PMRTI can be<br>
kept and processed from the FSS 110. After the handset 104 has executed all the<br>
instructions in the PMRTI section, the PMRTI section can be deleted from the FSS 110.<br>
Alternately, the PMRTI is maintained for future operations. For example, the PMRTI<br>
may be executed every time the wireless device is energized.<br>
[47] PMRTI is a very powerful runtime instruction engine. The handset can execute<br>
any instruction delivered to it through the PMRTI environment. This mechanism may be<br>
used to support RF calibrations. More generally, PMRTI can be used to remote debug<br>
wireless device software when software problems are recognized by the manufacturer or<br>
service provider, typically as the result of user complaints. PMRTI can also record data<br>
needed to diagnose software problems. PMRTI can launch newly downloaded system<br>
applications for data analysis, debugging, and fixes. PMRTI can provide RW data based<br>
updates for analysis and possible short term fix to a problem in lieu of an updated system<br>
software code section. PMRTI can provide memory compaction algorithms for use by<br>
the wireless device.<br>
[48] In some aspects of the invention, the organization of the system software into<br>
symbol libraries may impact the size of the volatile memory 114 and nonvolatile memory<br>
108 required for execution. This is due to the fact that the code sections are typically<br>
larger than the symbol libraries arranged in the code sections. These larger code sections<br>
exist to accommodate updated code sections. Organizing the system software as a<br>
collection of libraries impacts the nonvolatile memory size requirement. For the same<br>
code size, the amount of nonvolatile memory used will be higher due to the fact that code<br>
sections can be sized to be larger than the symbol libraries arranged within.<br>
[49] Once software updates have been delivered to the wireless device, the software<br>
maintenance system 100 supports memory compaction. Memory compaction is similar<br>
to disk de-fragmentation applications in desktop computers. The compaction mechanism<br>
ensures that memory is optimally used and is well balanced for future code section<br><br>
updates, where the size of the updated code sections are unpredictable. The system 100<br>
analyzes the code storage section as it is being patched (updated). The system 100<br>
attempts to fit updated code sections into the memory space occupied by the code section<br>
being replaced. If the updated code section is larger than the code section being replaced,<br>
the system 100 compacts the code sections in memory 112. Alternately, the compaction<br>
can be calculated by the manufacturer or service provider, and compaction instructions<br>
can be transported to the wireless device 104.<br>
[50] Compaction can be a time consuming process owing to the complexity of the<br>
algorithm and also the vast volume of data movement. The compaction algorithm<br>
predicts feasibility before it begins any processing. UI prompts can be used to apply for<br>
permission from the user before the compaction is attempted.<br>
[51] In some aspects of the invention, all the system software code sections can be<br>
updated simultaneously. A complete system software upgrade, however, would require a<br>
larger FSS 110.<br>
[52]  Fig. 3 is a schematic block diagram illustrating the present invention dynamic<br>
instruction set execution in a wireless communications device.  The system 300<br>
comprises a code storage section 112 in memory 108 including executable wireless<br>
device system software differentiated into a plurality of current code sections.   Code<br>
section one (302), code section two (304), code section n (306), and a patch manager<br>
code section 30S are shown.   However, the invention is not limited to any particular<br>
number of code sections.  Further, the system 300 further comprises a first plurality of<br>
symbol libraries arranged into the second plurality of code sections. Shown are symbol<br>
library one (310) arranged in code section one (302), symbol libraries two (312) and three<br>
(314) arranged in code section two (304), and symbol library m (316) arranged in code<br>
section n (306). Each library comprises symbols having related functionality. For<br>
example, symbol library one (310) may be involved in the operation of the wireless<br>
device liquid crystal display (LCD). Then, the symbols would be associated with display<br>
functions.  As explained in detail below, additional symbol libraries are arranged in the<br>
patch manger code section 308.<br><br>
[53] Fig. 4 is a schematic block diagram of the wireless device memory. As shown,<br>
the memory is the code storage section 112 of Fig. 1. The memory is a writeable,<br>
nonvolatile memory, such as Flash memory. It should be understood that the code<br>
sections need not necessarily be stored in the same memory as the FSS 110. It should<br>
also be understood that the present invention system software structure could be enabled<br>
with code sections stored in a plurality of cooperating memories. The code storage<br>
section 112 includes a second plurality of contiguously addressed memory blocks, where<br>
each memory block stores a corresponding code section from the second plurality of code<br>
sections. Thus, code section one (302) is stored in a first memory block 400, code<br>
section two (304) in the second memory block 402, code section n (306) in the nth.<br>
memory block 404, and the patch manager code section (308) in the^th memory block<br>
406.<br>
[54]  Contrasting Figs. 3 and 4, the start of each code section is stored at corresponding<br>
start addresses in memory, and symbol libraries are arranged to start at the start of code<br>
sections.  That is, each symbol library begins at a first address and runs through a range<br>
of addresses in sequence from the first address.   For example, code section one (302)<br>
starts at the first start address 408 (marked with "S") in code storage section memory 112.<br>
In Fig. 3, symbol library one (310) starts at the start 318 of the first code section.<br>
Likewise code section two (304) starts at a second start address 410 (Fig. 4), and symbol<br>
library two starts at the start 320 of code section two (Fig. 3).   Code section n (306) starts<br>
at a third start address 412 in code storage section memory 112 (Fig. 4), and symbol<br>
library m (316) starts at the start of code section n 322 (Fig. 3). The patch manager code<br>
section starts at /?th start address 414 in code storage section memory 112, and the first<br>
symbol library in the patch manager code section 308 starts at the start 324 of the patch<br>
manager code section.   Thus, symbol library one (310) is ultimately stored in the first<br>
memory block 400.   If a code section includes a plurality of symbol libraries, such as<br>
code section two (304), the plurality of symbol libraries are stored in the corresponding<br>
memory block, in this case the second memory block 402.<br><br>
[55] In Fig. 3, the system 300 further comprises a code section address table 326 as a<br>
type of symbol included in a symbol library arranged in the patch manager code section<br>
308. The code section address table cross-references code section identifiers with<br>
corresponding code section start addresses in memory.<br>
[56] Fig. 5 is a table representing the code section address table 326 of Fig. 3. The<br>
code section address table 326 is consulted to find the code section start address for a<br>
symbol library. For example, the system 300 seeks code section one when a symbol in<br>
symbol library one is required for execution. To find the start address of code section<br>
one, and therefore locate the symbol in symbol library one, the code section address table<br>
326 is consulted. The arrangement of symbol libraries in code sections, and the tracking<br>
of code sections with a table permits the code sections to be moved or expanded. The<br>
expansion or movement operations may be needed to install upgraded code sections (with<br>
upgraded symbol libraries).<br>
[57] Returning to Fig. 3, it should be noted that not every symbol library necessarily<br>
starts at the start of a code section. As shown, symbol library three. (314) is arranged in<br>
code section two (304), but does not start of the code section start address 320. Thus, if a<br>
symbol in symbol library three (314) is required for execution, the system 300 consults<br>
the code section address table 326 for the start address of code section two (304). As<br>
explained below, a symbol offset address table permits the symbols in symbol library<br>
three (314) to be located. It does not matter that the symbols are spread across multiple<br>
libraries, as long as they are retained with the same code section.<br>
[58] As noted above, each symbol library includes functionally related symbols. A<br>
symbol is a programmer-defined name for locating and using a routine body, variable, or<br>
data structure. Thus, a symbol can be an address or a value. Symbols can be internal or<br>
external. Internal symbols are not visible beyond the scope of the current code section.<br>
More specifically, they are not sought by other symbol libraries, in other code sections.<br>
External symbols are used and invoked across code sections and are sought by libraries in<br>
different code sections. The symbol offset address table typically includes a list of all<br>
external symbols.<br><br>
[59] For example, symbol library one (310) may generate characters on a wireless<br>
device display. Symbols in this library would, in turn, generate telephone numbers,<br>
names, the time, or other display features. Each feature is generated with routines,<br>
referred to herein as a symbol. For example, one symbol in symbol library one (310)<br>
generates telephone numbers on the display. This symbol is represented by an "X", and<br>
is external. When the wireless device receives a phone call and the caller ID service is<br>
activated, the system must execute the "X" symbol to generate the number on the display.<br>
Therefore, the system must locate the "X" symbol.<br>
[60] Fig. 6 is a detailed depiction of symbol library one (310) of Fig. 3, with symbols.<br>
Symbols are arranged to be offset from respective code section start addresses. In many<br>
circumstances, the start of the symbol library is the start of a code section, but this is not<br>
true if a code section includes more than one symbol library. Symbol library one (310)<br>
starts at the start of code section one (see Fig. 3). As shown in Fig. 6, the "X" symbol is<br>
located at an offset of (03) from the start of the symbol library and the "Y" symbol is<br>
located at an offset of (15). The symbol offset addresses are stored in a symbol offset<br>
address table 328 in the patch manager code section (see Fig. 3).<br>
[61] Fig. 7 is a table representing the symbol offset address table 328 of Fig. 3. The<br>
symbol offset address table 328 cross-references symbol identifiers with corresponding<br>
offset addresses, and with corresponding code section identifiers in memory. Thus, when<br>
the system seeks to execute the "X" symbol in symbol library one, the symbol offset<br>
address table 328 is consulted to locate the exact address of the symbol, with respect to<br>
the code section in which it is arranged.<br>
[62] Returning to Fig. 3, the first plurality of symbol libraries typically all include<br>
read-write data that must be consulted or set in the execution of these symbol libraries.<br>
For example, a symbol library may include an operation dependent upon a conditional<br>
statement. The read-write data section is consulted to determine the status required to<br>
complete the conditional statement. The present invention groups the read-write data<br>
from all the symbol libraries into a shared read-write section. In some aspects of the<br>
invention, the read-write data 330 is arranged in the patch manager code section 308.<br><br>
Alternately (not shown), the read-write data can be arranged in a different code section,<br>
code section n (306), for example.<br>
[63] The first plurality of symbol libraries also includes symbol accessor code<br>
arranged in a code section to calculate the address of a sought symbol. The symbol<br>
accessor code can be arranged and stored at an address in a separate code section, code<br>
section two (304), for example. However, as shown, the symbol accessor code 332 is<br>
arranged and stored at an address in the patch manager code section 3OS. The system 300<br>
further comprises a first location for storage of the symbol accessor code address. The<br>
first location can be a code section in the code storage section 112, or in a separate<br>
memory section of the wireless device (not shown). The first location can also be<br>
arranged in the same code section as the read-write data. As shown, the first location 334<br>
is stored in the patch manager code section 308 with the read-write data 330, the symbol<br>
offset address table 328, the code section address table 326, and the symbol accessor code<br>
332, and the patch library (patch symbol library) 336.<br>
[64]  The symbol accessor code accesses the code section address table and symbol<br>
offset address tables to calculate, or find the address of a sought symbol in memory. That<br>
is, the symbol accessor code calculates the address of the sought symbol using a<br>
corresponding symbol identifier and a corresponding code section identifier.  For<br>
example, if the "X" symbol in symbol library one is sought, the symbol accessor is<br>
invoked to seek the symbol identifier (symbol ED) "X_l", corresponding to the "X"<br>
symbol (see Fig. 7). The symbol accessor code consults the symbol offset address table<br>
to determine that the "X_l" symbol identifier has an offset of (03) from the start of code<br>
section one (see Fig. 6).  The symbol accessor code is invoked to seek the code section<br>
identifier "CS_1", corresponding to code section one. The symbol accessor code consults<br>
the code section address table to determine the start address associated with code section<br>
identifier (code  section ED)  "CS_1".  In  this manner, the symbol accessor code<br>
determines that the symbol identifier "X_l" is offset (03) from the address of (00100), or<br>
is located at address (00103).<br><br>
[65] The symbol "X" is a reserved name since it is a part of the actual code. In other<br>
words, it has an absolute data associated with it. The data may be an address or a value.<br>
The symbol identifier is an alias created to track the symbol. The symbol offset address<br>
table and the code section address table both work with identifiers to avoid confusion<br>
with reserved symbol and code section names. It is also possible that the same symbol<br>
name is used across many symbol libraries. The use of identifiers prevents confusion<br>
between these symbols.<br>
[66]  Returning to Fig.  1, the system 300 further comprises a read-write volatile<br>
memory 114, typically random access memory (RAM).   The read-write data 330, code<br>
section address table 326, the symbol offset address table 328, the symbol accessor code<br>
332, and the symbol accessor code address 334 are loaded into the read-write volatile<br>
memory 114 from the patch manager code section for access during execution of the<br>
system software. As is well known, the access times for code stored in RAM is<br>
significantly less than the access to a nonvolatile memory such as Flash.<br>
[67]  Returning to Fig. 3, it can be noted that the symbol libraries need not necessarily<br>
fill the code sections into which they are arranged, although the memory blocks are sized<br>
to exactly accommodate the corresponding code sections stored within. Alternately<br>
stated, each of the second plurality of code sections has a size in bytes that accommodates<br>
the arranged symbol libraries, and each of the contiguously addressed memory blocks<br>
have a size in bytes that accommodates corresponding code sections. For example, code<br>
section one (302) may be a 100 byte section to accommodate a symbol library having a<br>
length of 100 bytes.  The first memory block would be 100 bytes to match the byte size<br>
of code section one.   However, the symbol library loaded into code section 1 may be<br>
smaller than 100 bytes. As shown in Fig. 3, code section one (302) has an unused section<br>
340, as symbol library one (310) is less than 100 bytes.   Thus, each of the second<br>
plurality of code sections may have a size larger than the size needed to accommodate the<br>
arranged symbol libraries.   By "oversizing" the code sections, larger updated symbol<br>
libraries can be accommodated.<br><br>
[68] Contiguously addressed memory blocks refers to partitioning the physical<br>
memory space into logical blocks of variable size. Code sections and memory blocks are<br>
terms that are essentially interchangeable when the code section is stored in memory.<br>
The concept of a code section is used to identify a section of code that is perhaps larger<br>
than the symbol library, or the collection of symbol libraries in the code section as it is<br>
moved and manipulated.<br>
[69]  As seen in Fig. 3, the system 300 includes a patch symbol library, which will be<br>
referred to herein as patch library 336, to arrange new code sections in the code storage<br>
section with the current code sections.   The arrangement of new code sections with<br>
current code sections in the code storage section forms updated executable system<br>
software. The patch manager 336 not only arranges new code sections in with the current<br>
code sections, it also replaces code sections with updated code sections.<br>
[70]  Returning to Fig. 4, the file system section 110 of memory 108 receives new code<br>
sections, such as new code section 450 and updated patch manager code section 452.<br>
The file system section also receives a first patch manager run time instruction (PMRTI)<br>
454 including instructions for arranging the new code sections with the current code<br>
sections.   As seen in Fig. 1, an airlink interface 150 receives new, or updated code<br>
sections, as well as the first PMRTI. Although the airlink interface 150 is being<br>
represented by an antenna, it should be understood that the airlink interface would also<br>
include an RF transceiver, baseband circuitry, and demodulation circuitry (not shown).<br>
The file system section 110 stores the new code sections received via the airlink interface<br>
150.   The patch library 336, executing from read-write volatile memory 114, replaces a<br>
first code section in the code storage section, code section n (306) for example, with the<br>
new, or updated code section 450, in response to the first PMRTI 454.   Typically, the<br>
patch manager code section 308 is replaced with the updated patch manager code section<br>
452.   When code sections are being replaced, the patch library 336 over-writes the first<br>
code section, code section n (306) for example, in the code storage section 112 with the<br>
updated code sections, code section 450 for example, in the file system section 110.  In<br>
the extreme case, all the code sections in code storage section 112 are replaced with<br><br>
updated code sections.   That is, the FSS 110 receives a second plurality of updated code<br>
sections (not shown), and the patch library 336 replaces the second plurality of code<br>
sections in the code storage section 112 with the second plurality of updated code<br>
sections. Of course, the FSS 110 must be large enough to accommodate the second<br>
plurality of updated code sections received via the airlink interface.<br>
[71]  As noted above, the updated code sections being received may include read-write<br>
data code sections, code section address table code sections, symbol libraries., symbol<br>
offset address table code sections, symbol accessor code sections, or a code section with a<br>
new patch library.   All these code sections, with their associated symbol libraries and<br>
symbols, may be stored as distinct and independent code sections.  Then each of these<br>
code sections would be replaced with a unique updated code section. That is, an updated<br>
read-write code section would be received and would replace the read-write code section<br>
in the code storage section. An updated code section address table code section would be<br>
received and would replace the code section address table code section in the code<br>
storage section. An updated symbol offset address table code section would be received<br>
and would replace the symbol offset address table code section in the code storage<br>
section. An updated symbol accessor code section would be received and would replace<br>
the symbol accessor code section in the code storage section. Likewise, an updated patch<br>
manager code section (with a patch library) would be received and would replace the<br>
patch manager code section in the code storage section.<br>
[72] However, the above-mentioned code sections are typically bundled together in the<br>
patch manager code section. Thus, the read-write code section in the code storage section<br>
is replaced with the updated read-write code section from the file system section 110<br>
when the patch manager code section 308 is replaced with the updated patch manger code<br>
section 450. Likewise, the code section address table, the symbol offset address table, the<br>
symbol accessor code sections, as well as.the patch library are replaced when the updated<br>
patch manager code section 450 is installed. The arrangement of the new read-write data,<br>
the new code section address table, the new symbol offset address table, the new symbol<br>
accessor code, and the new patch library as the updated patch manager code section 450,<br><br>
together with the current code sections in the code storage section, forms updated<br>
executable system software.<br>
[73]  When the file system section 110 receives an updated symbol accessor code<br>
address, the patch manager replaces the symbol accessor code address in the first location<br>
in memory with updated symbol accessor code address. As noted above, the first<br>
location in memory 334 is typically in the patch manager code section (see Fig. 3).<br>
[74]  As seen in Fig. 3, the patch library 30S is also includes a compactor, or a<br>
compactor symbol library 342.  The compactor 342 can also be enabled as a distinct and<br>
independent code section, however as noted above, it is useful and efficient to bundle the<br>
functions associated with system software upgrades into a single patch manager code<br>
section.   Generally, the compactor 342 can be said to resize code sections, so that new<br>
sections can be arranged with current code sections in the code storage section 112.<br>
[75]  With the organization, downloading, and compaction aspects of the invention now<br>
established, the following discussion will center on the wireless communications device<br>
dynamic instruction set execution system 300.   The system 300 comprises executable<br>
system software and system data differentiated into code sections, as discussed in great<br>
detail, above.' Further, the system 300 comprises dynamic instruction sets for operating<br>
on the system data and the system software, and controlling the execution of the system<br>
software.   As seen in Fig. 4, a dynamic instruction set 470 is organized into the first<br>
PMRTI 454. As seen in Fig. 3, the system also comprises a run-time engine for<br>
processing the dynamic instruction sets, enabled as run-time library 370.   As with the<br>
compactor library 342 and patch library 336 mentioned above, the run-time library 370 is<br>
typically located in the patch manager code section 308.  However, the run-time library<br>
370 could alternately be located in another code section, for example the first code<br>
section 304.<br>
[76] The dynamic instruction sets are a single, or multiple sets of instructions that<br>
include conditional operation code, and generally include data items. The run-time<br>
engine reads the operation code and determines what operations need to be performed.<br>
Operation code can be conditional, mathematical, procedural, or logical.   The run-time<br><br>
engine, or run-time library 370 processes the dynamic instruction sets to perform<br>
operations such as mathematical or logical operations. That is, the run-time engine reads<br>
the dynamic instruction set 470 and performs a sequence of operations in response to the<br>
operation code. Although the dynamic instruction sets are not limited to any particular<br>
language, the operation code is typically a form of machine code, as the wireless device<br>
memory is limited and execution speed is important. The operation code is considered<br>
conditional in that it analyzes a data item and makes a decision as a result of the analysis.<br>
The run-time engine may also determine that an operation be performed on data before it<br>
is analyzed.<br>
[77]  For example, the operation code may specify that a data item from a wireless<br>
device memory be compared to a predetermined value.  If the data item is less than the<br>
predetermined value, the data item is left alone, and if the data item is greater than the<br>
predetermined value, it is replaced with the predetermined value. Alternately, the<br>
operation code may add a second predetermined value to a data item from the wireless<br>
device memory, before the above-mentioned comparison operation is performed.<br>
[78]  As mentioned above, the file system section nonvolatile memory 110 receives the<br>
dynamic instruction sets.through an interface such as the airlink 150. As shown in Fig. 1,<br>
the interface can also be radio frequency (RF) hardline 160.   Then, the PMRTI can be<br>
received by the FSS 110 without the system software being operational, such as in a<br>
factory calibration environment. The PMRTI can also be received via a logic port<br>
interface 162 or an installable memory module 164.   The memory module 164 can be<br>
installed in the wireless device 104 at initial calibration, installed in the field, or installed<br>
during factory recalibration.  Although not specially shown, the PMRTI can be received<br>
via an infrared or Bluetooth interfaces.<br>
[79] Fig. 8 is a depiction of instructions being accessed by the run-time engine 370.<br>
Shown is a first instruction 800, a second instruction 802, and ayth instruction 804,<br>
however, the dynamic instruction set is not limited to any particular number of<br>
instructions. The length of the operation code in each instruction is fixed. The run-time<br>
engine 370 captures the length of the instruction, as a measure of bytes or bits, determine<br><br>
if the instruction includes data items. The remaining length of the instruction, after the<br>
operation code is subtracted, includes the data items. The run-time engine extracts the<br>
data items from the instruction. As shown, the length 806 of the first instruction 800 is<br>
measured and data items 808 are extracted. Note that not all instructions necessary<br>
include data items to be extracted. The run-time engine 370 uses the extracted data 808<br>
in performing the sequence of operations responsive to the operation code 810 in<br>
instruction 800.<br>
[80] Fig. 9 is a more detailed depiction of the first instruction 800 of Fig. 8. Using the<br>
first instruction 800 as an example, the instruction includes operation code 810 and data<br>
808. The instruction, and more specifically, the data item section 808 includes symbol<br>
identifiers, which act as a link to symbols in the wireless device code sections. As<br>
explained in detail above, the symbol identifiers are used with the code section address<br>
table 326 (see Fig. 5) and the symbol offset address table 32S (see Fig. 7) to locate the<br>
symbol corresponding to the symbol identifier. As shown, a symbol identifier "X_l" is<br>
shown in the first instruction 800. The symbol offset address table 328 locates the<br>
corresponding symbol in a code section with the "CS_1" identifier and an offset of "3".<br>
The code section address table 326 gives the start address of code section one (302). In<br>
this manner, the symbol "X" is found (see Fig. 6).<br>
[81] After the run-time engine locates symbols corresponding to the received symbol<br>
identifiers using the code section address table and symbol offset address table, it extracts<br>
data when the located symbols are data items. For example, if the symbol "X" is a data<br>
item in symbol library one (310), the run-time engine extracts it. Alternately, the "X"<br>
symbol can be operation code, and the run-time engine executes the symbol "X" when it<br>
is located.<br>
[82] PMRTI can be used to update system data, or system data items. In some aspects<br>
of the invention system data is stored in a code section in the file system section 110,<br>
code section 472 for example, see Fig. 4. The run-time engine accesses system data from<br>
code section 472 and analyzes the system data. The run-time engine processes the<br>
operation code of the dynamic instruction sets to perform mathematical or logical<br><br>
operation on data items, as described above.   After the operation, the run-time engine<br>
processes the instructions to create updated system data.   Note that the updated system<br>
data may include unchanged data items in some circumstances.   The system data in the<br>
second code section 472 is replaced with the updated system data in response to the<br>
operation code. Thus, by the processing of instruction by the run-time engine, the system<br>
software is controlled to execute using the updated system data in code section 472.  In<br>
this manner, specifically targeted symbols in the system software can be updated, without<br>
replacing entire code sections. By the same process, the system data can be replaced in a<br>
code section in the code storage section 112. For example, the system data can be stored<br>
in the third code section 344, and the run-time engine can replace the system data in the<br>
third code section with updated system data in response to the operation code.<br>
[83]  PMRTI can also be used to update data items in volatile memory 114.   As an<br>
example, the volatile memory 114 accept read-write data 330, see Fig. 1. The read-write<br>
data can be from one, or from a plurality of code sections in the code storage section 112<br>
and/or the FSS 110. The run-time engine accesses the read-write data, analyzes the read-<br>
write data 330, creates updated read-write data, and replaces the read-write data 330 in<br>
the volatile memory 114 with the updated read-write data in response to the operation<br>
code.   Then, the system software is controlled to execute using the updated read-write<br>
data in volatile memory 114.<br>
[84] hi some aspects of the invention, the run-time engine monitors the execution of<br>
the system software. Performance monitoring is broadly defined to include a great<br>
number of wireless device activities. For example, data such as channel parameters,<br>
channel characteristics, system stack, error conditions, or a record of data items in RAM<br>
through a sequence of operations leading to a specific failure condition or reduced<br>
performance condition can be collected. It is also possible to use dynamic instructions<br>
sets to analyze collected performance data, provide updated data variants, and recapture<br>
data to study possible solutions to the problem. Temporary fixes can also be provisioned<br>
using PMRTI processes.<br><br>
[85] More specifically, the run-time engine collects performance data, and stores the<br>
performance data in the file system section in response to the operation code. Then, the<br>
system software is controlled to execute by collecting the performance data for evaluation<br>
of the system software. Evaluation can occur as a form of analysis performed by<br>
dynamic instruction set operation code, or it can be performed outside the wireless<br>
device, In some aspects of the invention, the run-time engine accesses the performance<br>
data that has been collected from the file system section and transmits the performance<br>
data via an airlink interface in response to the operation code. Collecting performance<br>
data from wireless devices in the field permits a manufacturer to thoroughly analyze<br>
problems, either locally or globally, without recalling the devices.<br>
[86]  In some aspects of the invention, file system section 110 receives a patch manager<br>
run time instruction including a new code section. For example, a new code section 474<br>
is shown in Fig. 4. Alternately, the new code section can be independent of the PMRTI,<br>
such as new code section n (450). For example, the new code section n (450) may have<br>
been received in earlier airlink communications, or have been installed during factory<br>
calibration. The run-time engine adds the new code section 474 (450) to the code storage<br>
section in response to the operation code. In some aspects of the invention, the new code<br>
section is added to an unused block in the code storage section 112.   Alternately, a<br>
compaction operation is required.   Then, the system software is controlled to execute<br>
using the new code section 474 (450). In other aspects of the invention, the PMRTI 454<br>
includes an updated code section 474.   Alternately, the new code section 450 is an<br>
updated code section independent of the PMRTI.   The run-time engine replaces a code<br>
section in the code storage section, code section two (304) for an example, with the<br>
updated code section 474 (450) in response to the operation code. The system software is<br>
controlled to execute using the updated code section 474 (450).   In some aspects of the<br>
invention a compaction operation is required to accommodate the updated code section.<br>
Alternately, the updated code section is added to an unused or vacant section of the code<br>
storage section.<br><br>
[87] As explained above, the addition of a new code section or the updating of a code<br>
section typically requires the generation of a new code section address table, as these<br>
operation involve either new and/or changed code section start addresses. Further, a<br>
compaction operation also requires a new code section address table. The compaction<br>
operations may be a result of the operation of the compactor 342, explained above, or the<br>
result of PMRTI instructions that supply details as to how the compaction is to occur.<br>
When the PMRTI includes downloading and compaction instructions, the PMRTI<br>
typically also includes a new code section address table that becomes valid after the<br>
downloading and compaction operations have been completed.<br>
[88]  Figs. 10a and 10b are flowcharts illustrating the present invention method for<br>
executing dynamic instruction sets in a wireless communications device. Although<br>
depicted as a sequence of numbered steps for clarity, no order should be inferred from the<br>
numbering (and the numbering in the methods presented below) unless explicitly stated.<br>
The method starts at Step 1000.   Step 1001a forms the system software into symbol<br>
libraries, each symbol library comprising symbols having related, functionality.   Step<br>
1001b arranges the symbol libraries into code sections. Step 1002 executes system<br>
software. Step 1003 receives the dynamic instruction sets. Receiving the dynamic<br>
instruction sets in Step 1003 includes receiving the dynamic instruction sets through an<br>
interface selected from the group including airlink, radio frequency (RF) hardline,<br>
installable memory module, infrared, and logic port interfaces.   In some aspects of the<br>
invention, receiving the dynamic instruction set in Step 1003 includes receiving a patch<br>
manager run time instruction (PMRTI) in a file system section nonvolatile memory.<br>
[89]  Step 1004 launches a run-time engine.   Typically, launching a run-time engine<br>
includes invoking a run-time library from a first code section.  The run-time engine can<br>
be launched from either volatile or nonvolatile memory.   Step 1006 processes dynamic<br>
instruction sets.  Processing dynamic instruction sets includes processing instructions in<br>
response to mathematical and logical operations.  In some aspects of the invention, Step<br>
1007 (not shown), following the processing of the dynamic instruction sets, deletes<br>
dynamic instruction sets.  Step 1008 operates on system data and system software. Step<br><br>
1010, in response to operating on the system data and system software, controls the<br>
execution of the system software.<br>
[90] Typically, receiving the patch manager run time instructions in Step 1003<br>
includes receiving conditional operation code and data items. Then, processing dynamic<br>
instruction sets in Step 1006 includes substeps. Step 1006al uses the run-time engine to<br>
read the patch manager run time instruction operation code. Step 1006b performs a<br>
sequence of operations in response to the operation code.<br>
[91]  In some aspects, arranging the symbol libraries into code sections in Step 1001b<br>
includes starting symbol libraries at the start of code sections and arranging symbols to be<br>
offset from their respective code section start addresses.   Then the method comprises<br>
further steps. Step  1001c  stores the start of code sections at corresponding start<br>
addresses.  Step 1001d maintains a code section address table (CSAT) cross-referencing<br>
code section identifiers with corresponding start addresses. Step lOOle maintains a<br>
symbol   offset   address   table   (SOAT)   cross-referencing   symbol   identifiers   with<br>
corresponding offset addresses, and corresponding code section identifiers.<br>
[92]  In some aspects of the invention, receiving the patch manager run time instruction<br>
in Step 1003 includes receiving symbol identifiers. Then, the method comprises a further<br>
step.   Step 1006a2 locates symbols corresponding to the received symbol identifiers by<br>
using the code section address table and symbol offset address table.   Performing a<br>
sequence of operations in response to the operation code in Step 1006b includes substeps.<br>
Step 1006bl extracts the data when the located symbols are data items.   Step 1006b2<br>
executes the symbols when the located symbols are instructions.<br>
[93] In some aspects of the invention, processing dynamic instruction sets in Step<br>
1006bl includes additional substeps. Step 1006bla uses the run-time engine to capture<br>
the length of the patch manager run time instruction. Step 1006blb extracts the data<br>
items from the patch manager run time instruction, in response to the operation code.<br>
Step 1006blc uses the extracted data in performing the sequence of operations responsive<br>
to the operation code.<br><br>
[94] Fig. 11 is a flowchart illustrating an exemplary dynamic instruction set operation.<br>
Several of the Steps in Fig. 11 are the same as in Fig. 10, and are not repeated here in the<br>
interest of brevity. Processing dynamic instruction sets in Step 1106 includes substeps.<br>
Step 1106a accesses system data stored in a second code section in the file system<br>
section. Step 1106b analyzes the system data. Step 1106c creates updated system data.<br>
Then, operating on system data and system software in Step 1108 includes replacing the<br>
system data in the second section with the updated system data, and controlling the<br>
execution of the system software in Step 1010 includes using the updated system data in<br>
the execution of the system software.<br>
[95] Fig. 12 is a flowchart illustrating another exemplary dynamic instruction set<br>
operation. Several of the Steps in Fig. 12 are the same as in Fig. 10, and are not repeated<br>
here in the interest of brevity. Step 1201c stores a plurality of code sections in a code<br>
storage section nonvolatile memory. Processing dynamic instruction sets in Step 1206<br>
includes substeps. Step 1206a accesses system data stored in a third code section in the<br>
code storage section (CSS). Step 1206b analyzes the system data.. Step 1206c creates<br>
updated system data. Operating on the system data and system software in Step 1208<br>
includes replacing the system data in the third code section with the updated system data.<br>
Controlling the execution of the system software in Step 1210 includes using the updated<br>
system data in the execution of the system software.<br>
[96] Fig. 13 is a flowchart illustrating a third exemplary dynamic instruction set<br>
operation. Several of the Steps in Fig. 13 are the same as in Fig. 10, and are not repeated<br>
here in the interest of brevity. Step 1301c stores a plurality of code sections in a code<br>
storage section nonvolatile memory. Step 1301d loads read-write data into volatile<br>
memory. Processing dynamic instruction sets in Step 1306 includes substeps. Step<br>
1306a accesses the read-write data in volatile memory. Step 1306b analyzes the read-<br>
write data. Step 1306c creates updated read-write data. Operating on the system data<br>
and system software in Step 1308 includes replacing the read-write' data in volatile<br>
memory with the updated read-write data.   Controlling the execution of the system<br><br>
software includes using the updated read-write data in the execution of the system<br>
software.<br>
[97] Fig. 14 is a flowchart illustrating a fourth exemplary dynamic instruction set<br>
operation. Several of the Steps in Fig. 14 are the same as in Fig. 10, and are not repeated<br>
here in the interest of brevity. Processing dynamic instruction sets includes substeps.<br>
Step 1406a, in response to the operation code, monitors the execution of the system<br>
software. Step 1406b collects performance data. Step 1406c stores the performance data.<br>
Step 1406d transmits the stored data via an airlink interface. Operating on the system<br>
data and system software in Step 1408 includes using the performance data in the<br>
evaluation of system software.<br>
[98] Fig. 15 is a flowchart illustrating a fifth exemplary dynamic instruction set<br>
operation. Several of the Steps in Fig. 15 are the same as in Fig. 10, and are not repeated<br>
here in the interest of brevity. Step 1501c stores a plurality of code sections in a code<br>
storage section nonvolatile memory. Receiving patch manager run time instructions in<br>
Step 1503 includes receiving a new code section. Operating on the system data and<br>
system software in Step 1508 includes adding the new code section to the code storage<br>
section, and controlling the execution of the system software in Step 1510 includes using<br>
the new code section in the execution of the system software.<br>
[99] Alternately, receiving a new code section in Step 1503 includes receiving an<br>
updated code section. Then, operating on the system data and system software in Step<br>
1508 includes replacing a fourth code section in the code storage section with the updated<br>
code section.<br>
[100] A system and method have been provided for executing dynamic instruction sets<br>
in a wireless communications device, so as to aid in the process of updating the software<br>
and monitoring the performance of the software. The system is easily updateable because<br>
of the arrangement of symbol libraries in code sections, with tables to access the start<br>
addresses of the code sections in memory and the offset addresses of symbols in the<br>
symbol libraries. The use on dynamic instruction sets permits custom modifications to be<br>
performed to each wireless device, based upon specific characteristics of that device. A<br><br>
few general examples have been given illustrating possible uses for the dynamic<br>
instructions sets. However, the present invention is not limited to just these examples.<br>
Other variations and embodiments of the invention will occur to those skilled in the art.<br>
[101] Fig. 16 is a high level network diagram illustrating an example wireless<br>
communication network. The illustrated wireless communication network comprises a<br>
plurality of wireless communication devices 10, 12, and 14 that are communicatively<br>
coupled with PMRTI server 30 via network 40.<br>
[102] Wireless communication devices 10, 12, and 14 can be any sort of electronic<br>
device with the ability to communicate within a wireless communication network. For<br>
example, wireless communication device 10 may be a cell phone, a personal digital<br>
assistant ("PDA"), a laptop computer, wristwatch, or any other device configured for<br>
wireless communication. Wireless communication devices may also be referred to herein<br>
as "handsets" or "mobile phones" or "mobile devices" or "wireless devices".<br>
[103] Network 40 is preferably a private network operated by the wireless carrier.<br>
Network 40 advantageously provides the infrastructure for wireless communications<br>
between handsets, including base stations (not pictured) and base station controllers (also<br>
not pictured).1 Network 40 is configured to manage wireless communications including<br>
the negotiation of handoffs between base stations for a handset travelling between cells of<br>
the wireless network. Additionally, network 40 preferably provides the communication<br>
link between various application servers and other computer based servers such as<br>
PMRTI server 30.<br>
[104] Network 40 may also server as the conduit for connections to other networks (not<br>
pictured) such as an Integrated Services Digital Network ("ISDN"), Public Switched<br>
Telephone Network ("PSTN"), Public Land Mobile Network ("PLMN"), Packet<br>
Switched Public Data Network ("PSPDN"), and the Internet, just to name a few.<br>
[105] PMRTI server 30 can be implemented as a single computer or as a plurality of<br>
servers logically arranged to provide dynamic instruction sets to mobile devices and to<br>
execute dynamic instruction sets received from mobile devices. PMRTI server 30 may<br>
have a single processor or a plurality of processors. A description of a general purpose<br><br>
computer than can be implemented as PMRTI server 30 is presented later with respect to<br>
Fig. 9. The PMRTI server 30 may also be referred to as a communication server.<br>
[106] Fig. 17A is block diagram illustrating an example wireless communication device<br>
10. The general features of wireless communication device 10 that allow it to function as<br>
such are well known in the art and are therefore not illustrated or described herein.<br>
[107] Wireless communication device 10 includes runtime engine 50, remote operation<br>
code ("opcode") library 60, server opcode library 70, and remote runtime instructions<br>
code section SO. Runtime engine 50 is preferably configured to process dynamic<br>
instructions sets. One example of a dynamic instruction set is a PMRTI instruction set.<br>
Another example of a dynamic instruction set is an RPMRTI instruction set. The<br>
difference between these two instruction sets is that the PMRTI set includes those<br>
functions that can be executed by the wireless device while the RPMRTI instruction set<br>
includes those functions that can be executed by the PMRTI server 30 that resides on the<br>
network 40.<br>
[108] The processing of dynamic instruction sets includes execution of PMRTI sets that<br>
are received from the PMRTI server 30 and the compilation of RPMRTI sets and<br>
corresponding data for deliver}' to the PMRTI server 30. Preferably, runtime engine 50<br>
can be launched by wireless communication device 10 when needed so that it runs only<br>
when necessary and consumes a minimal amount of system resources (e.g. memory, CPU<br>
cycles, etc.) on the device 10.<br>
[109] Remote opcode library 60 preferably includes the universe of operation codes that<br>
represent each PMRTI function or executable code segment. Advantageously, remote<br>
opcode library 60 includes the operation codes that serve as place holders for the actual<br>
executable machine code functions or code segments. As such, the remote opcode library<br>
60 contains a list of all available operation codes that correspond to each and every<br>
PMRTI function that can be executed by the wireless communications device 10.<br>
 [110] Similarly, the server opcode library 70 preferably includes 'the universe of<br>
operation codes that represent each RPMRTI function or executable code segment.<br>
Advantageously, server opcode library 70 only includes the operation codes for the actual<br><br>
executable machine code functions or code segments, which do not reside on the wireless<br>
communication device 10. As such, the server opcode library 70 contains a list of all the<br>
operation codes for each available RPMRTI function that can be executed by the PMRTI<br>
server 30 on behalf of the wireless communication device 10.<br>
[Ill] In the preferred embodiment, the number of available RPMRTI functions can well<br>
exceed the number of available PMRTI functions because the PMRTI server 30 does not<br>
suffer from the minimal resources typically found on mobile devices such as cell phones<br>
and PDAs.<br>
[112] Additionally, wireless communication device 10 includes remote runtime<br>
instructions code section SO. The code section 80 is where the actual machine code or<br>
executable instructions reside in persistent memory on the device 10. These executable<br>
instructions or code segments preferably correspond in a one-to-one relationship with the<br>
opcodes contained in the remote opcode library 60. Fig. 17B is block diagram illustrating<br>
an example code section SO. As shown, any number of PMRTI functions can be included<br>
in code section 80, from instruction 01 through instruction n. Optimally, a large number<br>
of functions are available in code section 80 and yet consume very little resources (e.g.<br>
persistent memory) of the device 10.<br>
[113] Advantageously, the server opcode library 70, the remote opcode library 60, and<br>
the corresponding code section 80 can be installed in persistent memory on the wireless<br>
communication device 10 during manufacture of the device 10 and prior to its<br>
deployment in the field (i.e., prior to being sold to the consumer). Future updates to the<br>
set of opcodes contained in either library or to the set of executable instructions in the<br>
code section 80 can be provided by the PMRTI server 30 implementing the process later<br>
described with respect to Fig. 22.<br>
[114] Finally, in the illustrated embodiment, wireless communication device includes an<br>
over-the-air communication link 90. Implementation of the communication link 90 is<br>
well known in the art and provides the wireless communication device 10 with the ability<br>
to communicate within the wireless communication network via a radio or other over-the-<br>
air connection.   Advantageously, over-the-air communication link 90 can provide the<br><br>
means for PMRTI server 30 to update remote opcode library 60, server opcode library 70,<br>
and remote runtime instructions codes section SO.<br>
[115] Fig. ISA is a block diagram illustrating an example PMRTI server 30. The<br>
features of a general purpose computer that may implement the PMRTI server are later<br>
described with respect to Fig. 24.<br>
[116] In the illustrated embodiment, PMRTI server 30 includes control module 95,<br>
remote opcode library 60, server opcode library 70, and server runtime instructions code<br>
section 82. The remote opcode library 60 and server opcode library 70 preferably contain<br>
the same list of opcodes as the libraries that are present on the wireless communication<br>
device 10. The control module 95 is preferably configured to process dynamic<br>
instructions sets and manage a network of PMRTI communications between the PMRTI<br>
server 30 and a plurality of wireless communication devices available via the wireless<br>
communication network.<br>
[117] For example, the control module 95 may compile various dynamic PMRTI sets<br>
and send those instruction sets to a variety of discrete wireless communication devices.<br>
Similarly, the control module 95 may also receive a plurality of dynamic RPMRTI sets<br>
and execute those instruction sets on behalf of the sending wireless communication<br>
device.<br>
[118]   Remote opcode library 60 preferably includes the universe of operation codes<br>
corresponding  to   each   available   PMRTI   function   or  executable   code   segment.<br>
Advantageously, remote opcode library 60 comprises a list of the operation codes that<br>
serve as place holders for the actual executable machine code functions or code segments<br>
in the remote runtime instructions code section 80 (on the wireless communication<br>
device). As such, the remote opcode library 60 contains a list of all available opcodes for<br>
all available PMRTI functions that can be executed by a wireless communications device.<br>
[119]   Similarly, the server opcode library 70 preferably includes the universe of<br>
operation codes corresponding to each RPMRTI function or executable code segment.<br>
Advantageously, server opcode library 70 only includes the operation codes for the actual<br>
executable machine code functions or code segments that can be carried out the PMRTI<br><br>
server 30. In the preferred embodiment, the number of available RPMRTI functions can<br>
well exceed the number of available PMRTI functions because the PMRTI server 30 does<br>
not suffer from the minimal resources typically found on mobile devices such as cell<br>
phones and PDAs.<br>
[120] Additionally. PMRTI server 30 includes the server runtime instructions code<br>
section 82. The code section 82 is where the actual machine code or executable<br>
instructions reside in persistent memory on the server 30. These executable instructions<br>
or code segments preferably correspond in a one-to-one relationship with the operation<br>
codes contained in the server opcode library 70, which resides both on the server 30 and<br>
the wireless communication device 10. Fig. 18B is a block diagram illustrating an<br>
example server runtime instructions code section.<br>
[121] Fig. 19 is a flow diagram illustrating an example peer-to-peer communication<br>
between handsets. In the illustrated embodiment, peer-to-peer communications are<br>
carried out between handset 10 and handset 12. Alternatively, however, peer-to-peer<br>
communications may be carried out between a single handset and. many handsets in a<br>
one-to-many relationship or a many-to-on relationship. In all cases, PMRTI server 30<br>
performs an intermediary function in the communication process, handling and<br>
processing opcodes and datapayloads on behalf of the handsets.<br>
[122] An example communication between handset 10 and handset 12 can be a<br>
communication from handset 10 to add a new phonebook entry in the phonebook on<br>
handset 12. Such an example communication can begin with handset 10 compiling a<br>
server opcode set and a corresponding data payload. In this example, the server opcode<br>
set includes an opcode for sending data to handset 12. The corresponding data payload<br>
includes a unique identifier (e.g. phone number) for handset 12 and the phonebook entry<br>
data to be sent to handset 12. In other examples, the data being sent may be a data file<br>
such as a picture, an email, a text document, a GPS or other type of location, or any other<br>
desirable data.<br>
[123]   Once the PMRTI server 30 receives the server opcode set and corresponding data<br>
payload, it extracts the data payload and preferably saves it in temporary memory. Next<br><br>
the opcodes are translated into executable instructions and the instructions are carried out.<br>
In this case the opcodes correspond to an instruction to send data to handset 12, the data<br>
being housed in the data payload and comprising the new phonebook entry. PMRTI<br>
server 30 then compiles a remote opcode set and corresponding data payload to be sent to<br>
handset 12.<br>
[124] In this example, the remote opcode set includes an opcode for adding a new<br>
phonebook entry and the data payload includes the phonebook entry to be added. When<br>
handset 12 receives the remote opcode set and data payload, it extracts the data payload<br>
and preferably saves it in temporary memory. Next handset 12 translates the opcodes<br>
into executable instructions and the instructions are carried out. In this example, the<br>
opcodes correspond to an instruction to add a new entry to the phonebook, the new entry<br>
being housed in the data payload stored in temporary memory. Handset 12 then adds the<br>
new entry to the phonebook by executing the instruction, thus completing the peer-to-<br>
peer data communication between handset 10 and handset 12.<br>
[125] Fig. 20 is a flow diagram illustrating an example process for executing dynamic<br>
instruction sets on a wireless communication device. Initially, in step 500, the wireless<br>
device receives a set of remote opcodes. The set of remote opcodes can be received via<br>
an over-the-air communication link, for example a link with a wireless communication<br>
network. Preferably, the opcodes are optimized to minimize the amount of data sent<br>
over-the-air. Additionally, a data payload may be included with the set of opcodes<br>
received by the wireless device.<br>
[126] In step 5-2, the wireless device launches its runtime engine to process the remote<br>
opcode set. As illustrated in step 504, the runtime engine parses the remote opcode set<br>
and then extracts the data payload in step 506. If no data payload exists, then this step<br>
can be skipped. If a data payload does exist, then the resulting data can be stored in an<br>
available portion of volatile memory for later use. Next, the runtime engine obtains the<br>
executable instructions that correspond to the opcodes in the remote opcode set as shown<br>
in step 508. These instructions can be obtained from the remote runtime instructions<br>
code section of the wireless device.<br><br>
[127] Once the executable instructions corresponding to the opcodes in the remote<br>
opcode set have been obtained, the runtime engine executes the instructions, as illustrated<br>
in step 510. When the instructions are being executed, any necessary data to be operated<br>
on can be obtained from volatile memory where the data payload is stored. Alternatively,<br>
or additionally, any necessary data to be operated on may be obtained as the result of an<br>
executed instruction.<br>
[128] For example, the data payload may include a favorite software game module for<br>
the wireless device. Additionally, one of the opcodes in the remote opcode set may<br>
correspond to an executable instruction for installing a new software game module on the<br>
wireless device. Thus, the remote opcode set and data payload operate on the wireless<br>
device to install a new software game module that was sent by a peer wireless device.<br>
[129] Other examples of data communications between handsets may include updating<br>
or adding a new phonebook entry, sending a data file (e.g. a photo, an email, a document,<br>
etc.), installing a customer ringer, providing or requesting GPS or location information,<br>
and even a fantasy sports league draft.<br>
[130] Once the instruction set has been executed in its entirety by the runtime engine,<br>
the runtime engine can be terminated, as shown in step 512. Advantageously, the<br>
runtime engine may be launched and terminated so that it only runs when necessary.<br>
This saves system resources on the wireless device, for example it may save volatile<br>
memory space and CPU cycles.<br>
[131] Fig. 21 is a flow diagram illustrating an example process for compiling dynamic<br>
instruction sets on a wireless communication device. Initially, the runtime engine is<br>
launched, as illustrated in step 520. Once the runtime engine is running, the engine can<br>
compile a set of server opcodes, as shown in step 522. The set of server opcodes may be<br>
obtained from a background process running on the wireless device. Alternatively, the<br>
server opcode set may be obtained from a process running on the wireless device under<br>
the direction of a user.<br>
[132] For example, the wireless device may include a set of routines that are<br>
periodically and automatically run by the operating system in order to perform system<br><br>
maintenance or other desirable functions. These procedures may, as a result of their<br>
execution, cause a server opcode set to be generated by the runtime engine.<br>
Alternatively, a user may initiate a particular set of routines that are only executed when<br>
requested by a user. This set of routines may also cause a server opcode set to be<br>
generated by the runtime engine. In both cases, the result is a server opcode set generated<br>
by the runtime engine, as shown in step 522.<br>
[133] Once the server opcode set has been generated, the runtime engine determines in<br>
step 524 if a data payload should accompany the server opcode set. If there is data that<br>
needs to go along with the server opcode set, in step 526 the runtime engine fetches the<br>
data from persistent or volatile memory, or executes an instruction that returns the data<br>
needed. Once the data has been obtained, the run time engine next inserts the data into<br>
the server opcode set, as illustrated in step 528. One simple way to achieve this is to<br>
append the data payload to the server opcode set in a single data packet.<br>
[134] Once the data payload has been combined with the server opcode set, or if no data<br>
payload is required, then the runtime engine sends the server opcode set (with or without<br>
a data payload) to the server, as shown in step 530. After the server opcode set has been<br>
sent, the runtime engine may be terminated to free up resources on the wireless device, as<br>
illustrated in step 532.<br>
[135] Fig. 22 is a flow diagram illustrating an example process for executing dynamic<br>
instruction sets on a PMRTI server. Initially, in step 540 the server receives the server<br>
opcode set. The opcode set is preferably a list of monikers that represent a series of<br>
executable instructions, with each opcode representing a discrete executable instruction<br>
or a discrete set of executable instructions. Once the set of server opcodes has been<br>
received, the server then parses the server opcode set in step 542 and extracts any data<br>
payload included with the server opcode set, as illustrated in step 544. When the data<br>
payload is extracted, it may be temporarily stored in volatile memory on the server for<br>
later use.<br>
[136]   Next, the server obtains the corresponding instruction set, as shown in step 546.<br>
Preferably, the corresponding instruction set is stored in a server runtime instructions<br><br>
code section that resides in persistent memory on the PMRTI server machine. Once the<br>
instruction set has been obtained, the server then executes the instruction set, as seen in<br>
step 548. When the instruction set is being executed, the executing routines may use the<br>
data payload that came with the server opcode set. Preferably, the data payload is stored<br>
in memory on the server for this purpose. Alternatively, the executing routines may<br>
include instructions that generate the data necessary for the instruction set to carry out its<br>
function.<br>
[137]   Fig. 23 is a flow diagram illustrating an example process for sending a phonebook<br>
entry (i.e., a data communication ) to a peer handset.   Initially, in step 580 the handset<br>
obtains the phonebook entry from memory in the handset.  Advantageously, the<br>
phonebook entry may be compressed by the handset to reduce the size of the data<br>
payload. Next, in step 582 the handset obtains a unique identifier for the peer handset. In<br>
most cases, the handset's telephone number can be used as the unique identifier.   This<br>
information can be obtained from the phonebook or as input from the user.<br>
[138]   Once the data payload comprising the phonebook entry and.the unique identifier<br>
have been obtained, the handset compiles the server opcode set and the corresponding<br>
data payload, as illustrated in step 584.  Preferably, a server opcode exists that instructs<br>
the server to send the data communication to the peer handset. In this example, the data<br>
communication  being   the   phonebook   entry.   Once   the  server   opcode   set   and<br>
corresponding data payload are combined, the handset sends them to the PMRTI server<br>
in step 586 for processing and ultimately for dissemination to the peer handset.<br>
[139]   Turning back to Fig. 22, when the PMRTI server receives the server opcode set<br>
and corresponding data payload in step 540, it parses the server opcode set in step 542<br>
and extracts the data payload in step 544. The data payload can advantageously be stored<br>
in a temporary local memory on the PMRTI server. The server next translates the<br>
opcodes into the corresponding set of executable instructions in step 546 and carries out<br>
those instructions, ash shown in step 548.  In this example, the set of instructions causes<br>
the server to compile a remote opcode set and combine it with the corresponding data<br><br>
payload, which in this case is the phonebook entry. The server then sends the remote<br>
opcode set and data payload to the peer handset identified by the unique identifier.<br>
[140] Turning back to Fig. 20 when the peer handset receives the remote opcode set and<br>
corresponding data payload in step 500, it launches the runtime engine in step 502. The<br>
runtime engine then parses the remote opcode set in step 504 and extracts the data<br>
payload in step 506, which includes the phonebook entry. Preferably, the data payload<br>
can be stored in a temporary memory location. The runtime engine then translates the<br>
remote opcode set into the corresponding executable instruction set in step 508 and then<br>
executes the set of instructions, as illustrated instep 510. In this example, the set of<br>
instructions causes the handset to add the phonebook entry contained in the data payload<br>
to the handset's own phonebook. Once the instruction set has been executed, the handset<br>
can then terminate the runtime engine, as shown in step 512.<br>
[141] Additional applications of the ability of a handset to construct a server opcode set<br>
and corresponding data payload and send them to the PMRTI server 30 for processing<br>
and delivery to a peer handset include providing location updates to. a peer handset (e.g.,<br>
GPS information), sending a voice memo to a peer handset, sending files to other people,<br>
including moving pictures, images, text, and audio. In the general sense, sending files to<br>
peer handsets encompasses an extremely broad range of desirable applications such as<br>
sending custom rings to a friend or family member, sending photos or digital images<br>
captured by the wireless device, sending emails, documents, software applications, or any<br>
other data to be shared with other people or peer handsets.<br>
[142] Fig. 24 is a block diagram illustrating an exemplary computer system 550 that<br>
may be used in connection with the various examples described herein. For example, the<br>
computer system 550 may be employed as the PMRTI server that resides within the<br>
wireless communication network. Computer system 550 may also be employed as any of<br>
the various other general or specific purpose computer systems that comprise the wireless<br>
communication network and its constituent components. However,' other computer<br>
systems and computer architectures may be used, as will be clear to those skilled in the<br>
art.<br><br>
[143] The computer system 550 preferably includes one or more processors, such as<br>
processor 552. Additional processors may be provided, such as an auxiliary processor to<br>
manage input and output, an auxiliary processor to perform floating point mathematical<br>
operations, a special-purpose microprocessor having an architecture suitable for fast<br>
execution of signal processing algorithms (e.g., digital signal processor), a slave<br>
processor subordinate to the main processing system (e.g., back-end processor), an<br>
additional microprocessor or controller for dual or multiple processor systems, or a<br>
coprocessor. Such auxiliary processors may be discrete processors or may be integrated<br>
with the processor 552.<br>
[144]   The processor 552 is preferably connected to a communication bus 554.   The<br>
communication bus 554 may include a data channel for facilitating information transfer<br>
between storage and other peripheral components of the computer system 550.   The<br>
communication bus 554 further may provide a set of signals used for communication<br>
with the processor 552, including a data bus, address bus, and control bus (not shown).<br>
The communication bus 554 may comprise any standard or non-standard bus architecture<br>
such as, for example, bus architectures compliant with industry standard architecture<br>
("ISA"), extended industry standard architecture ("EISA"), Micro Channel Architecture<br>
("MCA"),   peripheral   component   interconnect   ("PCI")   local   bus,   or   standards<br>
promulgated by the Institute of Electrical and Electronics Engineers ("IEEE") including<br>
IEEE 488 general-purpose interface bus ("GPIB"), IEEE 696/S-100, and the like.<br>
[145]   Computer system 550 preferably includes a main memory 556 and may also<br>
include a secondary memory 558. The main memory 556 provides storage of instructions<br>
and data for programs executing on the processor 552. The main memory 556 is<br>
typically  semiconductor-based  memory  such   as  dynamic  random   access  memory<br>
("DRAM") and/or static random access memory ("SRAM"). Other semiconductor-based<br>
memory types include, for example, synchronous dynamic random access memory<br>
("SDRAM"), Rambus  dynamic random access memory ("RDRAM"),  ferroelectric<br>
random access memory ("FRAM"), and the like, including read only memory ("ROM").<br><br>
[146] The secondary memory 55S may optionally include a hard disk drive 560 and/or a<br>
removable storage drive 562, for example a floppy disk drive, a magnetic tape drive, a<br>
compact disc ("CD") drive, a digital versatile disc ("DVD") drive, etc. The removable<br>
storage drive 562 reads from and/or writes to a removable storage medium 564 in a well-<br>
known manner. Removable storage medium 564 may be, for example, a floppy disk,<br>
magnetic tape, CD, DVD, etc.<br>
[147] The removable storage medium 564 is preferably a computer readable medium<br>
having stored thereon computer executable code (i.e., software) and/or data. The<br>
computer software or data stored on the removable storage medium 564 is read into the<br>
computer system 550 as electrical communication signals 578.<br>
[148] In alternative embodiments, secondary memory 558 may include other similar<br>
means for allowing computer programs or other data or instructions to be loaded into the<br>
computer system 550. Such means may include, for example, an external storage<br>
medium 572 and an interface 570. Examples of external storage medium 572 may<br>
include an external hard disk drive or an external optical drive, or and external magneto-<br>
optical drive.<br>
[149]   Other examples of secondary memory 558 may include semiconductor-based<br>
memory such as programmable read-only memory ("PROM"), erasable programmable<br>
read-only memory ("EPROM"), electrically erasable read-only memory ("EEPROM"), or<br>
flash memory (block oriented memory similar to EEPROM). Also included are any other<br>
removable storage units 572 and interfaces 570, which allow software and data to be<br>
transferred from the removable storage unit 572 to the computer system 550.<br>
[150]   Computer system 550 may also include a communication interface 574.   The<br>
communication interface 574  allows software  and data to be transferred between<br>
computer system 550 and external devices (e.g. printers), networks, or information<br>
sources.   For example, computer software or executable code may be transferred to<br>
computer system 550 from a network server via communication interface 574. Examples<br>
of communication interface 574 include a modem, a network interface card ("NIC"), a<br><br>
communications port, a PCMCIA slot and card, an infrared interface, and an DEEE 1394<br>
fire-wire, just to name a few.<br>
[151] Communication interface 574 preferably implements industry promulgated<br>
protocol standards, such as Ethernet IEEE 802 standards, Fiber Channel, digital<br>
subscriber line ("DSL"), asynchronous digital subscriber line ("ADSL"), frame relay,<br>
asynchronous transfer mode ("ATM"), integrated digital services network ("ISDN"),<br>
personal communications services ("PCS"), transmission control protocol/Internet<br>
protocol ("TCP/IP"), serial line Internet protocol/point to point protocol ("SLDP/PPP"),<br>
and so on, but may also implement customized or non-standard interface protocols as<br>
well.<br>
[152] Software and data transferred via communication interface 574 are generally in<br>
the form of electrical communication signals 578. These signals 578 are preferably<br>
provided to communication interface 574 via a communication channel 576.<br>
Communication channel 576 carries signals 578 and can be implemented using a variety<br>
of communication means including wire or cable, fiber optics, conventional phone line,<br>
cellular phone link, radio frequency (RF) link, or infrared link, just to name a few.<br>
[153] Computer executable code (i.e., computer programs or software) is stored in the<br>
main memory 556 and/or the secondary memory 558. Computer programs can also be<br>
received via communication interface 574 and stored in the main memory 556 and/or the<br>
secondary memory 558. Such computer programs, when executed, enable the computer<br>
system 550 to perform the various functions of the present invention as previously<br>
described.<br>
[154] In this description, the term "computer readable medium" is used to refer to any<br>
media used to provide computer executable code (e.g., software and computer programs)<br>
to the computer system 550. Examples of these media include main memory 556,<br>
secondary memory 558 (including hard disk drive 560, removable storage medium 564,<br>
and external storage medium 572), and any peripheral device communicatively coupled<br>
with communication interface 574 (including a network information server or other<br><br>
network device). These computer readable mediums are means for providing executable<br>
code, programming instructions, and software to the computer system 550.<br>
[155] In an embodiment that is implemented using software, the software may be stored<br>
on a computer readable medium and loaded into computer system 550 by way of<br>
removable storage drive 562, interface 570, or communication interface 574. In such an<br>
embodiment, the software is loaded into the computer system 550 in the form of<br>
electrical communication signals 578. The software, v/hen executed by the processor<br>
552, preferably causes the processor 552 to perform the inventive features and functions<br>
previously described herein.<br>
[156] Various embodiments may also be implemented primarily in hardware using, for<br>
example, components such as application specific integrated circuits ("ASICs"), or field<br>
programmable gate arrays ("FPGAs"). Implementation of a hardware state machine<br>
capable of performing the functions described herein will also be apparent to those<br>
skilled in the relevant art. Various embodiments may also be implemented using a<br>
combination of both hardware and software.<br>
[157] While the particular systems and methods herein shown and described in detail<br>
are fully capable of attaining the above described objects of this invention, it is to be<br>
understood that the description and drawings presented herein represent a presently<br>
preferred embodiment of the invention and are therefore representative of the subject<br>
matter which is broadly contemplated by the present invention. It is further understood<br>
that the scope of the present invention fully encompasses other embodiments that may<br>
become obvious to those skilled in the art and that the scope of the present invention is<br>
accordingly limited by nothing other than the appended claims.<br><br>
WE CLAIM :<br>
1.	A method for peer-to-peer communication between a first handset (10) and a second<br>
handset (12), the first handset (10) and second handset (12) communicatively coupled with a<br>
communication server (30) over a wireless communication network, said method comprising :<br>
receiving, at the communication server, a server opcode set from the first handset (540),<br>
the server opcode set compiled on the first handset (540) and comprising at least one server<br>
opcode and a first data payload ;<br>
characterized in that said method comprises :<br>
processing the server opcode set and compiling at least a portion of the first data payload<br>
into a remote opcode set comprising at least one remote opcode and a second data payload; and<br>
sending the remote opcode set to the second handset for processing thereon.<br>
2.	The method as claimed in claim 1, wherein the first data payload comprises a unique<br>
identifier for the second handset (12).<br>
3.	The method as claimed in claim 1, wherein the first data payload comprises a data<br>
communication for the second handset (12).<br>
4.	The method as claimed in claim 1, wherein the processing step comprises :<br>
parsing the server opcode set to obtain the at least one server opcode and the first data<br>
payload (542);<br>
translating the at least one server opcode into one or more executable instructions (546);<br>
and<br>
executing the one or more executable instructions to create the remote opcode set (548).<br>
5.	The method as claimed in claim 4, wherein the executing step comprises :<br>
obtaining a unique identifier from the first data payload ;<br>
obtaining one or more remote opcodes from a remote opcode library (60) ;<br><br>
obtaining a second data payload, at least a portion of the second data payload derived<br>
from the first data payload ; and<br>
combining the one or more remote opcodes with the second data payload to generate the<br>
remote opcode set.<br>
6.	The method as claimed in claim 1, comprising :<br>
compiling a server opcode set at the first handset, the server opcode set comprising the at<br>
least one server opcode and the first data payload ; and<br>
processing the remote opcode set to receive a data communication at the second handset.<br>
7.	The method as claimed in claim 6, wherein the compiling step comprises :<br>
obtaining one or more server opcodes from a server opcode library;<br>
obtaining a first data payload, the first data payload comprising a data communication<br>
and a unique identifier for the second handset (582); and<br>
combining the one or more server opcodes with the first data payload to create a server<br>
opcode set.<br>
8.	The method as claimed in claim 4, wherein the executing step comprises :<br>
obtaining a unique identifier from the first data payload ;<br>
obtaining one or more remote opcodes from a remote opcode library ;<br>
obtaining a second data payload, at least a portion of the second data payload derived<br>
from the first data payload ; and<br>
combining the one or more remote opcodes with the second data payload to create a<br>
remote opcode set.<br>
9.	The method as claimed in claim 6, wherein the step of processing the remote opcode set<br>
comprises :<br><br>
parsing the remote opcode set to obtain at least one remote opcode and a second data<br>
payload (504);<br>
translating the at least one remote opcode into one or more executable instructions (508);<br>
and<br>
executing the one or more executable instructions to obtain a data communication from<br>
the second data payload (510).<br>
10.	A system for peer-to-peer communication between wireless communication devices, said<br>
system comprising :<br>
a first handset (10) having a server opcode library (70) containing a plurality of server<br>
opcodes and a data storage area ;<br>
a second handset (12) having a remote opcode library (60) containing a plurality of<br>
remote opcodes ; and<br>
a communication server (30) having a server opcode library (70) containing a plurality<br>
of server opcodes and a remote opcode library (60) containing a plurality of remote opcodes,<br>
the communication server (30) communicatively coupled with the first handset (10) and the<br>
second handset (12) over a wireless communication network (40) ;<br>
wherein the first handset (10) compiles a server opcode set comprising at least one<br>
server opcode and a first data payload and sends the server opcode set to the communication<br>
server (30) where the server opcode set is processed and at least a portion of the data payload is<br>
compiled into a remote opcode set comprising at least one remote opcode and a second data<br>
payload and sent to the second handset (12) where the remote opcode set is processed to receive<br>
the second data payload.<br>
11.	The system as claimed in claim   10, wherein the first data payload comprises a unique<br>
identifier for the second handset (12).<br><br>
12.	The system as claimed in claim 10, wherein the first data payload comprises a data<br>
communication for the second handset (12).<br>
13.	The system as claimed in claim 12, wherein the second data payload comprises the data<br>
communication for the second handset (12).<br><br>
The present invention discloses a method and a system for peer-to-peer<br>
communication between a first handset and a second handset, the first handset and<br>
second handset communicatively coupled with a communication server over a wireless<br>
communication network. The method includes receiving, at the communication server, a<br>
server opcode set from the first handset (540), the server opcode set compiled on the<br>
first handset (540) and comprising at least one server opcode and a first data payload ;<br>
wherein said method further includes : processing the server opcode set and compiling<br>
at least a portion of the first data payload into a remote opcode set comprising at least<br>
one remote opcode and a second data payload; and sending the remote opcode set to the<br>
second handset for processing thereon.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLUtPTE5QLTIwMDQtQ09SUkVTUE9OREVOQ0UucGRm" target="_blank" style="word-wrap:break-word;">143-KOLNP-2004-CORRESPONDENCE.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLUtPTE5QLTIwMDQtRk9STSAyNy5wZGY=" target="_blank" style="word-wrap:break-word;">143-KOLNP-2004-FORM 27.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLUtPTE5QLTIwMDQtRk9STS0yNy5wZGY=" target="_blank" style="word-wrap:break-word;">143-KOLNP-2004-FORM-27.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1hc3NpZ25tZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1jb3JyZXNwb25kZW5jZS5wZGY=" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1leGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1mb3JtIDEucGRm" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1mb3JtIDE4LnBkZg==" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1mb3JtIDMucGRm" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1mb3JtIDUucGRm" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1wYS5wZGY=" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-pa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1yZXBseSB0byBleGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLWtvbG5wLTIwMDQtZ3JhbnRlZC1zcGVjaWZpY2F0aW9uLnBkZg==" target="_blank" style="word-wrap:break-word;">143-kolnp-2004-granted-specification.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQzLUtPTE5QLTIwMDQtT1RIRVIgRE9DVU1FTlQucGRm" target="_blank" style="word-wrap:break-word;">143-KOLNP-2004-OTHER DOCUMENT.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="231397-an-electroconductive-ink-and-a-method-for-making-the-same.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="231399-a-composition-of-non-ergot-d2-d3-receptor-agonists-to-treat-fibromyalgia.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>231398</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>143/KOLNP/2004</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>10/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>06-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>04-Mar-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>04-Feb-2004</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>KYOCERA WIRELESS CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>10300 CAMPUS POINT DRIVE, SAN DIEGO, CA 92121</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>RAJARAM GOWRI</td>
											<td>3520 LEBON DRIVE APT. 5330, SAN DIEGO CA 92122</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04L 12/56</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/IB02/02905</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-07-25</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td></td>
									<td></td>
								    <td>NA</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/231398-method-and-system-for-peer-to-peer-communication-between-wireless-communica-tion-devices-over-a-wireless-communication-network by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:16:29 GMT -->
</html>
