<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/279422-system-and-method-for-video-encoding-and-decoding by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:03:43 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 279422:SYSTEM AND METHOD FOR VIDEO ENCODING AND DECODING</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">SYSTEM AND METHOD FOR VIDEO ENCODING AND DECODING</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A video coding method comprises dividing a coefficient vector into two or more sub-vectors, each sub-vector having a length less than or equal to a length of the coefficient vector, indicating a size of each sub-vector and a position of each sub-vector   within the coefficient vector, and forming a block corresponding to each sub-vector</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>THE PATENTS ACT, 1970<br>
COMPLETE SPECIFICATION<br>
Section 10<br>
"SYSTEM AND METHOD FOR VIDEO ENCODING AND DECODING"<br>
Nokia Corporation, a corporation organized and existing under the laws of Finland, of Keilaiahdentie 4, FIN-02150 Espoo Finland.<br>
The following specification particularly describes the nature of this invention and the manner in which it is to be performed:<br>
 <br>
SYSTEM AND METHOD FOR VIDEO ENCODING AND<br>
DECODING<br>
FIELD OF THE INVENTION<br>
[0001]    The present invention relates generally to the field of video coding and decoding. More particularly, the present invention relates to increasing the efficiency of video coding and decoding.<br>
BACKGROUND OF THE INVENTION<br>
[0002]    This section is intended to provide a background or context to the invention that is recited in the claims. The description herein may include concepts that could be pursued, but are not necessarily ones that have been previously conceived or pursued. Therefore, unless otherwise indicated herein, what is described in this section is not prior art to the description and claims in this application and is not admitted to be prior art by inclusion in this section.<br>
[0003]    Video coding standards include ITU-T H.261, ISO/IEC MPEG-1 Visual, ITU-T H.262 or ISO/IEC MPEG-2 Visual, ITU-T H.263, ISO/IEC MPEG-4 Visual and ITU-T H.264 (also know as ISO/IEC MPEG-4 AVC). In addition, there are currently efforts underway with regards to the development of new video coding standards. One such standard under development is the scalable video coding (SVC) standard, which will become the scalable extension to H.264/AVC. Another standard under development is the multivideo coding standard (MVC), which is also an extension of H.264/AVC. Yet another such effort involves the development of Chinese video coding standards. [0004]    The latest draft of the SVC is described in JVT-T201, "Joint Draft 7 of SVC Amendment," 20th JVT Meeting, Klagenfurt, Austria, July 2006, available from http://ftp3.itu.ch/av-arch/jvt-site/2006_07_Klagenfurt/JVT-T201 .zip. The latest draft of MVC is in described in JVT-T208, "Joint Multiview Video Model (JMVM) 1.0", 20th JVT meeting, Klagenfurt, Austria, July 2006, available from http://ftp3.itu.ch/av-arch/jvt-<br>
 <br>
site/2006_07_Klagenfurt/JVT-T208.zip. Both of these documents are incorporated herein by reference in their entireties.<br>
[0005]    In scalable video coding (SVC), a video signal can be encoded into a base layer and one or more enhancement layers constructed in a layered fashion. An enhancement layer enhances the temporal resolution (i.e., the frame rate), the spatial resolution, or the quality of the video content represented by another layer or a portion of another layer. Each layer, together with its dependent layers, is one representation of the video signal at a certain spatial resolution, temporal resolution and quality level. A scalable layer together with its dependent layers are referred to as a "scalable layer representation." The portion of a scalable bitstream corresponding to a scalable layer representation can be extracted and decoded to produce a representation of the original signal at certain fidelity.<br>
[0006]    In some cases, data in an enhancement layer can be truncated after a certain location, or at arbitrary positions, where each truncation position may include additional data representing increasingly enhanced visual quality. Such scalability is referred to as fine-grained (granularity) scalability (FGS). In contrast to FGS, the scalability provided by those enhancement layers that cannot be truncated is referred to as coarse-grained (granularity) scalability (CGS). CGS collectively includes traditional quality (SNR) scalability and spatial scalability.<br>
[0007]    The Joint Video Team (JVT) has been in the process of developing a SVC standard as an extension to the H.264/Advanced Video Coding (AVC) standard. SVC uses the same mechanism as H.264/AVC to provide temporal scalability. In AVC, the signaling of temporal scalability information is realized by using sub-sequence-related supplemental enhancement information (SEI) messages.<br>
[0008]    SVC uses an inter-layer prediction mechanism, wherein certain information can be predicted from layers other than the currently reconstructed layer or the next lower layer. Information that can be inter-layer predicted include intra texture, motion and residual data. Inter-layer motion prediction includes the prediction of block coding mode, header information, etc., wherein motion information from the lower layer may be<br>
 <br>
used for prediction of the higher layer. In the case of intra coding, a prediction from surrounding macroblocks or from co-located macroblocks of lower layers is possible. These prediction techniques do not employ motion information and hence, are referred to as intra prediction techniques. Furthermore, residual data from lower layers can also be employed for prediction of the current layer.<br>
[0009]    The elementary unit for the output of an SVC encoder and the input of a SVC decoder is a Network Abstraction Layer (NAL) unit. A series of NAL units generated by an encoder is referred to as a NAL unit stream. For transport over packet-oriented networks or storage into structured files, NAL units are typically encapsulated into packets or similar structures. In the transmission or storage environments that do not provide framing structures, a bytestream format, which is similar to a start code-based bitstream structure, has been specified in Annex B of the H.264/AVC standard. The bytestream format separates NAL units from each other by attaching a start code in front of each NAL unit.<br>
[0010]    A problem associated with this layered coding approach is that creation of small discrete layers (in terms of bit rate) leads to very poor coding efficiency, because information present in the base layer tends to be partially duplicated in the enhancement layer and is thus coded twice. On the other hand, since the size of discrete layers controls how accurately a desired bit rate or quality may be achieved, if large enhancement layers are used, the bit rate or quality cannot be controlled with much granularity. This "coarse¬grained scalability" (CGS) may provide an insufficient; degree of control for some applications.<br>
[0011]    To balance these two problems, the concept of medium-grained scalability (MGS) has been proposed. MGS involves the same encoder and decoder structure as CGS, but in an intermediate stage, a "quality level" is assigned to each CGS enhancement layer slice according to a rate-distortion measure. When truncating the bit stream to a desired bit rate, CGS slices from the highest quality level are discarded first, and so on until the target bit rate is achieved.<br>
 <br>
[0012]    It is important to note that the number of CGS layers assigned to a given quality level may not be constant throughout the sequence but may vary from one frame to another. For example, {1 A, IB, 1C}, {2A, 2B, 2C}, {3A, 3B, 3C} may represent nine slices. The number indicates the frame number, and the letter indicates the CGS layer. The base quality of the first frame is {1A}, an intermediate quality of the first frame is formed from {IA, IB}, and the maximum quality of the first frame is formed from {1A, IB, 1C}. The base-layer representation of the entire three-frame sequence would consist of {IA, 2A, 3A}. Conventionally, the first CGS layer would consist of {IB, 2B, 3B}. With MGS, the first quality layer might contain {IB, 1C, 3B}, representing two CGS enhancements from the first frame, none from the second, and one from the third. [0013]    The result is that the average number of CGS layers in a sequence is not restricted to integer values, but may vary depending upon the construction of the "quality layer", and since the CGS coding structure is used, the coding efficiency penalty is relatively minor.<br>
SUMMARY OF THE INVENTION<br>
[0014]    One aspect of the invention relates to a method for encoding an image comprising dividing a coefficient vector into a plurality of sub-vectors, indicating position of a sub-vector of the plurality of sub-vectors within the coefficient vector, and encoding the coefficient values of the sub-vector using a variable-length coder. [0015]    In one embodiment, the position of the sub-vector is indicated by a start and end position within the coefficient vector. In another embodiment, the position of the sub-vector is indicated by a start position within the coefficient vector and a length of the sub-vector.<br>
[0016]    In one embodiment, the method further comprises selecting a variable length coder for the sub-vector based on the length of the sub-vector from a group of variable length coders. The selecting a coder may include determining whether the length of the sub-vector is greater than or less than a predetermined threshold. In one embodiment, the<br>
 <br>
method further includes assigning a variable-length codeword to represent a coefficient of the sub-vector based on the length of the sub-vector.<br>
[0017] In one embodiment, the method further comprises selecting a variable length coder for the sub-vector based on the position of the sub-vector within the coefficient vector from a group of variable length coders.<br>
[0018]    In one embodiment, the method further includes encoding a "trailing ones" syntax element for the block corresponding to a sub-vector.<br>
[0019]    In one embodiment, the method further includes encoding a coded block pattern for a macroblock, the coded block pattern representative of whether a plurality of sub-vectors of coefficient vectors corresponding to a plurality of blocks of the macroblock have any non-zero coefficient values.<br>
[0020]    In one embodiment, the method further includes encoding an indication representative of whether a coded block pattern for a macroblock is derived from a coded block pattern for a previously coded macroblock or not, the coded block pattern representative of whether a plurality of sub-vectors of coefficient vectors corresponding to a plurality of blocks of the macroblock have any non-zero coefficient values. [0021]    In one embodiment, the VLC codeword matrix designed for one vector length is truncated for use with a smaller sub-vector. The shortest N codewords that would be discarded through truncation are "inserted" into the VLC codeword matrix so that the VLC codewords retained for use with the sub-vector are no longer than the VLC codewords discarded. Equivalently, this may be achieved using a "mapping matrix". [0022]    In one embodiment, a "continuation indicator" is coded into the bit stream, indicating whether the CBP from a previous macroblock should be used as the CBP for the present macroblock. When so indicated, decoding the CBP for the present macroblock may be omitted. Alternatively, the "continuation indicator" may be assigned one value from the possible set of CBP values and coded using a variable-length code. [0023]    In one embodiment, the VLC table used to code a "total run" in a block is adjusted based on the sub-vector length and/or position. For example, the VLC table<br>
 <br>
index may be incremented by a value proportional to the difference between the sub-vector length and the next highest vector length.<br>
[0024]    In one embodiment, each macroblock includes a trailing ones indicator having a value corresponding to a number of trailing ones in the sub-vector. Alternately, each macroblock includes a trailing ones indicator having a value corresponding to a number of non-zero coefficients in the sub-vector.<br>
[0025]    In another aspect of the invention, an apparatus comprises a receiver for receiving a source video signal and an encoder configured to process the video signal, the encoder being configured to divide a coefficient vector into a plurality of sub-vectors. The encoder is further configured to indicate position of a sub-vector of the plurality of sub-vectors within the coefficient vector and to encode the coefficient values of the sub-vector using a variable-length coder.<br>
[0026]    In another aspect of the invention, an apparatus comprises a processor and a memory unit communicatively connected to the processor. The memory unit includes computer code for dividing a coefficient vector into a plurality of sub-vectors, computer code for indicating position of a sub-vector of the plurality of sub-vectors within the coefficient vector, and computer code for encoding the coefficient values of the sub-vector using a variable-length coder.<br>
[0027]    In another aspect, the invention includes a computer program embodied on a computer-readable medium. The computer program is configured to provide a method comprising dividing a coefficient vector into a plurality of sub-vectors, indicating position of a sub-vector of the plurality of sub-vectors within the coefficient vector, and encoding the coefficient values of the sub-vector using a variable-length coder. [0028]    In another aspect of the invention, a method for decoding an encoded image includes receiving position of a sub-vector within a coefficient vector representative of a block of an image, receiving a set of coefficients for the sub-vector, forming the coefficient vector based on the received set of coefficients and the position of the sub-vector, and decoding the block.<br>
 <br>
[0029]    In another aspect of the invention, an apparatus comprising a receiver for receiving a source video signal and a decoder configured to process the video signal. The decoder is configured to receive position of a sub-vector within a coefficient vector representative of a block of an image, receive a set of coefficients for the sub-vector, form the coefficient vector based on the received set of coefficients and the position of the sub-vector, and decode the block.<br>
[0030]    In another aspect of the invention, an apparatus includes a processor; and a memory unit communicatively connected to the processor. The memory unit includes computer code for receiving position of a sub-vector within a coefficient vector representative of a block of an image, computer code for receiving a set of coefficients for the sub-vector, computer code for forming the coefficient vector based on the received set of coefficients and the position of the sub-vector, and computer code for decoding the block.<br>
[0031]    In another aspect, the invention includes a computer program embodied on a computer-readable medium. The computer program is configured to provide a method comprising receiving position of a sub-vector within a coefficient vector representative of a block of an image, receiving a set of coefficients for the sub-vector, forming the coefficient vector based on the received set of coefficients and the position of the sub-vector, and decoding the block.<br>
[0032]    These and other advantages and features of various embodiments of the present invention, together with the organization and manner of operation thereof, will become apparent from the following detailed description when taken in conjunction with the accompanying drawings, wherein like elements have like numerals throughout the several drawings described below.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0033]    Figure 1 is an overview diagram of a system within which the present invention may be implemented;<br>
 <br>
[0034]    Figure 2 is a perspective view of a mobile device that can be used in the<br>
implementation of the present invention;<br>
[0035]    Figure 3 is a schematic representation of the circuitry of the mobile device of<br>
Figure 2;<br>
[0036]    Figure 4 is an exemplary illustration of a Network Abstraction Layer (NAL) unit<br>
stream according to an embodiment of the present invention;<br>
[0037]    Figure 5 is an exemplary illustration of an NAL unit according to an<br>
embodiment of the present invention; and<br>
[0038]    Figure 6 is an exemplary illustration of amacroblock in the NAL unit of Figure<br>
5 according to an embodiment of the present invention.<br>
DETAILED DESCRIPTION OF VARIOUS EMBODIMENTS<br>
[0039]    Embodiments of the present invention pertain to the entropy coding of coefficients when they are partitioned in a MGS or CGS framework. The coding efficiency in such framework may be improved by partitioning coefficients into separate quality layers. A 4x4 block may written in vector form, for example [12 0 4-200101 0 0 0 0 0 0 0]. It is possible to separate the block into two vectors consisting of the first four and last twelve coefficients (a "4-12 split"), written as a sum of two vectors: [12 0 4 -2 00000000000 0]+ [0 00000101000000 0]. Thus the existing MGS technique can not only select which CGS slices will provide the best rate-distortion increase, but also which coefficients within the slice.<br>
[0040]    However, when a block of coefficients is split into two or more vectors, each of the split blocks is padded with zeros. If the block is split into two vectors, this results in twice the number of coefficients as the original vector. If the block is split in three, the number of coefficients triples, and so on. For example, [1204-2 001 01 000000 0] may be split into two, [12 04-2 00000000000 0]+ [0 00000101000000 0]. Call these two vectors VI and V2, and the n'th coefficient in the vector Vl,n. If the same split is used for each block in a frame, then the probability that a coefficient is zero for n&gt;=4 is 1 in VI, mathematically p(Vl,n = 0) = 1 forn&gt;=4, and similarly p(V2,n = 0) = 1<br>
 <br>
for n
[0041]    Figure 1 shows a generic multimedia communications system for use with embodiments of the present invention. As shown in Figure 1, a data source 100 provides a source signal in an analog, uncompressed digital, or compressed digital format, or any combination of these formats. An encoder 110 encodes the source signal into a coded media bitstream. The encoder 110 may be capable of encoding more than one media type, such as audio and video, or more than one encoder 110 may be required to code different media types of the source signal. The encoder 110 may also get synthetically produced input, such as graphics and text, or it may be capable of producing coded bitstreams of synthetic media. In the following, only processing of one coded media bitstream of one media type is considered to simplify the description. It should be noted, however, that typically real-time broadcast services comprise several streams (typically at least one audio, video and text sub-titling stream). It should also be noted that the system may include many encoders, but in the following only one encoder 110 is considered to simplify the description without a lack of generality.<br>
[0042]    The coded media bitstream is transferred to a storage 120. The storage 120 may comprise any type of mass memory to store the coded media bitstream. The format of the coded media bitstream in the storage 120 may be an elementary self-contained bitstream format, or one or more coded media bitstreams may be encapsulated into a container file. Some systems operate "live", i.e. omit storage and transfer coded media bitstream from the encoder 110 directly to the sender 130. The coded media bitstream is then transferred to the sender 130, also referred to as the server, on a need basis. The format used in the transmission may be an elementary self-contained bitstream format, a packet stream format, or one or more coded media bitstreams may be encapsulated into a container file. The encoder 110, the storage 120, and the sender 130 may reside in the same physical device or they may be included in separate devices. The encoder 110 and<br>
 <br>
sender 130 may operate with live real-time content, in which case the coded media bitstream is typically not stored permanently, but rather buffered for small periods of time in the content encoder 110 and/or in the sender 130 to smooth out variations in processing delay, transfer delay, and coded media bitrate. [0043]    The sender 130 sends the coded media bitstream using a communication protocol stack. The stack may include but is not limited to Real-Time Transport Protocol (RTP), User Datagram Protocol (UDP), and Internet Protocol (IP). When the communication protocol stack is packet-oriented, the sender 130 encapsulates the coded media bitstream into packets. For example, when RTP is used, the sender 130 encapsulates the coded media bitstream into RTP packets according to an RTP payload format. Typically, each media type has a dedicated RTP payload format. It should be again noted that a system may contain more than one sender 130, but for the sake of simplicity, the following description only considers one sender 130. [0044]    The sender 130 may or may not be connected to a gateway 140 through a communication network. The gateway 140 may perform different types of functions, such as translation of a packet stream according to one communication protocol stack to another communication protocol stack, merging and forking of data streams, and manipulation of data stream according to the downlink and/or receiver capabilities, such as controlling the bit rate of the forwarded stream according to prevailing downlink network conditions. Examples of gateways 140 include multipoint conference control units (MCUs), gateways between circuit-switched and packet-switched video telephony, Push-to-talk over Cellular (PoC) servers, IP encapsulators in digital video broadcasting-handheld (DVB-H) systems, or set-top boxes that forward broadcast transmissions locally to home wireless networks. When RTP is used, the gateway 140 is called an RTP mixer and acts as an endpoint of an RTP connection.<br>
[0045]    The system includes one or more receivers 150, typically capable of receiving, de-modulating, and de-capsulating the transmitted signal into a coded media bitstream. The coded media bitstream is typically processed further by a decoder 160, whose output is one or more uncompressed media streams. It should be noted that the bitstream to be<br>
 <br>
decoded can be received from a remote device located within virtually any type of network. Additionally, the bitstream can be received from local hardware or software. Finally, a renderer 170 may reproduce the uncompressed media streams with a loudspeaker or a display, for example. The receiver 150, decoder 160, and renderer 170 may reside in the same physical device or they may be included in separate devices. [0046]    Scalability in terms of bitrate, decoding complexity, and picture size is a desirable property for heterogeneous and error prone environments. This property is desirable in order to counter limitations such as constraints on bit rate, display resolution, network throughput, and computational power in a receiving device. [0047]    It should be understood that, although text and examples contained herein may specifically describe an encoding process, one skilled in the art would readily understand that the same concepts and principles also apply to the corresponding decoding process and vice versa. It should be noted that the bitstream to be decoded can be received from a remote device located within virtually any type of network. Additionally, the bitstream can be received from local hardware or software.<br>
[0048]    Communication devices of the present invention may communicate using various transmission technologies including, but not limited to, Code Division Multiple Access (CDMA), Global System for Mobile Communications (GSM), Universal Mobile Telecommunications System (UMTS), Time Division Multiple Access (TDMA), Frequency Division Multiple Access (FDMA), Transmission Control Protocol/Internet Protocol (TCP/IP), Short Messaging Service (SMS), Multimedia Messaging Service (MMS), e-mail, Instant Messaging Service (IMS), Bluetooth, IEEE 802.11, etc. A communication device may communicate using various media including, but not limited to, radio, infrared, laser, cable connection, and the like.<br>
[0049]    Figures 2 and 3 show one representative mobile device 12 within which the present invention may be implemented. It should be understood, however, that the present invention is not intended to be limited to one particular type of mobile device 12 or other electronic device.<br>
 <br>
[0050]    The mobile device 12 of Figures 2 and 3 includes a housing 30, a display 32 in the form of a liquid crystal display, a keypad 34, a microphone 36, an ear-piece 38, a battery 40, an infrared port 42, an antenna 44, a smart card 46 in the form of a UICC according to one embodiment of the invention, a card reader 48, radio interface circuitry 52, codec circuitry 54, a controller 56 and a memory 58. Individual circuits and elements are all of a type well known in the art, for example in the Nokia range of mobile devices. [0051]    Referring now to Figure 4, an exemplary NAL unit stream 400 is illustrated. As noted above, the NAL unit stream 400 includes a series of NAL units 410 generated by an encoder. Each NAL unit 410 in the stream is separated by a start code (or prefix) in front of each NAL unit.<br>
[0052]    Figure 5 illustrates an exemplary NAL unit 410 in greater detail with various components of the NAL unit 410. The NAL unit 410 includes an NAL prefix 412 and an NAL header 414, followed by one or more macro blocks 420. Each macroblock 420 includes data corresponding to a frame, a portion of a frame, an enhancement layer or a portion of an enhancement layer.<br>
[0053]    Figure 6 illustrates a macroblock 420 according to an embodiment of the present invention. The macroblock 420 illustrated in Figure 6 is shown with certain components. It will be understood by those skilled in the art that the macroblock 420 may include additional components as necessary or as desired. The components of the macroblock 420 include a coded block pattern section 422, a trailing ones indicator 424 and a coefficients block 426, each of which individually is well understood by those skilled in the art. The trailing ones indicator 424 generally has a value corresponding to the number of trailing ones in the coefficient vector or the sub-vector. [0054]    In accordance with embodiments of the present invention, it is desirable to split a vector of coefficients into a sum of several different vectors, and code each individually in a macroblock using a CAVLC-like entropy coder. In one embodiment, the coefficient vector is divided into two or more sub-vectors. The sub-vectors correspond to the two coefficient vectors described above with the padded zeros removed. Thus, in one example, in the above example with the original coefficient vector being [12 0 4-200 1<br>
 <br>
0 1 0 0 0 0 0 0 0], the coefficient vector can be divided into two sub-vectors: [1204-2] and [0 0 1 0 1 0 0 0 0 0 0 0]. To facilitate decoding, the header of the slice may be provided with indicators reflecting the size and position of each sub-vector within the coefficient vector. In one embodiment, the size and position of each sub-vector may be indicated by the start and end positions of the sub-vector. For example, indicating the start and end positions (0,3) and (4,15) would result in the vector [1204-2 0010100 0 0 0 0 0] being divided into the sub-vectors [12 0 4 -2] and [0 0 1 0 1 0 0 0 0 0 0 0], respectively. When the start of one sub-vector always immediately follows the end of the previous sub-vector, coding of either the start or end position may be omitted. In another embodiment, the size and position of the sub-vector may be represented by the start position and length of the sub-vector. Thus, coding the start position and length (0,4) would indicate the sub-vector [12 0 4-2] and the start position and length (4,12) would indicate the sub-vector [001010000000]. When the start of one sub-vector always immediately follows the end of the previous sub-vector, the start position may be omitted, so that the sub-vector lengths would be coded as {4, 12}. The regular CAVLC coder may be used for each of these cases.<br>
[0055]    In another embodiment of this invention, the CAVLC coder used to code each sub-vector may be selected independently. For example, a particular CAVLC coder may be more efficient for a sub-vector of one size versus another. Thus, the selection of the CAVLC coder may be based on the length of the sub-vector from a group of CAVLC coders.<br>
[0056]    For example, H.264/AVC has two CAVLC scenarios, one for 16-value vectors and another for 4-value vectors. A threshold may be set such that any vectors at or below a particular length are coded using the 4-value CAVLC coder, and any above the threshold are coded using the 16-value CAVLC coder.<br>
[00S7]    The mapping between the CAVLC coder and sub-vector length may be achieved, for example, via a lookup table or a mathematical function, such as a threshold operation. The mapping may be hard-coded such that it is easily determinable and identical for a particular sub-vector in both encoder and decoder. Alternatively, the<br>
 <br>
mapping or selection of the coder may be dictated into the bit stream and, thereby, relayed to the decoder,<br>
[0058]    In another embodiment of this invention, the trailing ones indicator 424 may be modified based on the length of the sub-vector. In one embodiment, the trailing ones indicator 424 is dynamically modified so that it only specifies the non-zero count, depending upon the length of the vector to be coded. When this modification is in effect, the number of trailing ones is assumed to be zero, and a different VLC codeword table may be used.<br>
[0059]    For example, if the vector length is either less than 5 or greater than 10, the trailing ones indicator 424 may specify both the number of trailing ones and the number of non-zero coefficients, and regular H.264/AVC CAVLC decoding may be used. On the other hand, if the vector length is in the range 5 to 10, the trailing ones indicator 424 may be modified according to a codeword table such as the following:<br>
<br>
VLC codeword	Num. non-zero values	Trailing ones<br>
0	0	0<br>
10	1	0<br>
110	2	0<br>
11100	3	0<br>
11130	4	0<br>
111010	5	0<br>
111011	6	0<br>
111130	7	0<br>
1111130	8	0<br>
11313310	9	0<br>
13111311	10	0<br>
[0060]    In one embodiment, the value of the trailing ones indicator 424 may be capped. For example, the maximum value of the trailing ones indicator 424 may vary between zero and three depending upon the length of the sub-vector and/or the number of non¬zero coefficients. For example, for a sub-vector having a length of 6, the value of the trailing ones indicator 424 may be capped at 1 and, therefore, may have a value of either Oor 1.<br>
 <br>
[0061]    In another embodiment of the present invention, a "mapping function" is used to re-map H.264/AVC CAVLC codewords for the trailing ones indicator 424 based on the sub-vector length. According to H.264/AVC CAVLC, the VLC codeword length for the trailing ones indicator 424 is based on both the number of trailing ones and the total number of non-zero values in the block. For example, for vectors of size 16 and context zero, the VLC codeword lengths are given by the matrix:<br>
1	6	8	9	10	11	33	13	13	14	14	15	15	16	16	16	16<br>
0	2	6	8	9	10	11	13	13	14	14	15	15	15	16	16	16<br>
0	0	3	7	8	9	10	11	13	13	14	14	15	15	16	16	16<br>
0	0	0	5	6	7	8	9	10	11	13	14	14	15	15	16	16<br>
where the vertical index is the number of trailing ones and the horizontal index is the total number of non-zero values. If a sub-vector has length 2, the dimensions are constrained since the sub-vector can have only 0, 1, or 2 trailing ones and only 0, 1, or 2 non-zero values:<br>
<br>
"1    6	8~<br>
0   2	6<br>
0   0	3<br>
[0062]    However, simply truncating the VLC matrix effectively prohibits some shorter-length codewords while using longer-length codewords. For example, the above matrix retains VLC lengths 6 and 8 while eliminating length 5. This results in a loss of coding efficiency. It is preferable to "insert" the shorter eliminated VLC lengths into the matrix, so that if N shorter codewords are inserted, the N longest codewords are removed. For example, after inserting value 5, the above matrix becomes:<br>
 <br>
1 5 6 0 2 6 0   0   3<br>
[0063]    A characteristic of this operation is that no VLC codeword in the truncated matrix is longer than any VLC codeword removed through truncation. Another characteristic is that the relative length of VLC codewords within the truncated matrix is preserved, so that one VLC codeword that was no longer than a second VLC codeword in the original matrix will still be no longer than the second VLC codeword in the truncated matrix.<br>
[0064]    This "insertion" of lower-length codewords can be equivalently written as a mapping function. First, the codewords are written as an ordered vector. Continuing the example of H.264/AVC CAVLC for vector size 16 and context 0, the lengths would be [1 2356667788889999...]. A "mapping matrix" then indicates which codeword index should be used at each position in the VLC length matrix:<br>
"0	4	9	13<br>
-	1	5	10	14<br>
-	-	2	7	11    15<br>
-	-	-	3	6     8    12   16<br>
[0065]    Thus for the top-left element in the matrix, the VLC codeword with index 0<br>
should be used, i.e. length 1. For the top, second-from left element in the matrix, the<br>
VLC codeword with index 4 should be used, i.e. length 6. Thus it is possible to<br>
reconstruct the original VLC length matrix from the VLC vector and the "mapping<br>
matrix",<br>
[0066]    If the sub-vector is now restricted to length 3, for example, the mapping matrix<br>
is simply truncated and packed to remove discontinuities:<br>
 <br>
0    4    7    9<br>
-	1    5    8<br>
-	-   2   6<br>
[0067]    Finally, replacing the values in the "mapping matrix" with the corresponding VLC codeword lengths gives:<br>
"16    7    8"<br>
-	2    6    7<br>
_   _   3    6<br>
-	-    -    5<br>
[0068]    As noted, this "mapping function" is an equivalent way of performing the "insertion" operation to ensure that low-length VLC codewords are not wasted when using sub-vectors. This approach avoids the need to store many different VLC tables corresponding to each sub-vector length, and thus may provide a complexity benefit even though the tables are not necessarily optimal for each case. The thresholding feature mentioned earlier may be used in conjunction with this embodiment. For example, one "mapping matrix" corresponding to vector length 4 may be used for sub-vectors up to and including length 4, and a second "mapping matrix" corresponding to vector length 16 may be used for sub-vectors longer than length 4.<br>
(0069]    In a further embodiment, the VLC codewords may be "terminated". For example, if there is one VLC codeword of length 7 and another VLC codeword of length 8, but none with length 9 or greater, then the VLC codeword of length 8 may be shortened to length 7, since the prefix bits are no longer required. [0070]    In another embodiment of the present invention, the VLC used for coded block pattern section 422 varies according to the length of the sub-vector and/or the starting position of the vector. In this regard, one VLC may be used for vectors starting at<br>
 <br>
position zero, and a different VLC used for other vectors. For example, in the case of the above-described sub-vectors [12 0 4 -2] and [0 0 1 0 1 0 0 0 0 0 0 0], the start position of the first sub-vector is zero and the start position of the second sub-vector is 4. The regular H.264/AVC CBP VLC may be used for the first vector, and a different VLC used for the second vector. Or, for example, in the case of the above-described sub-vectors [12 0 4 -2] and [0 0 1 0 1 0 0 0 0 0 0 0], the length of the first sub-vector is 4 and the length of the second sub-vector is 12. The regular H.264/AVC CBP VLC may be used for the second vector based on its length, and a different VLC used for the first vector. [0071]    In another embodiment, an indicator, such as a prefix flag in the coded block pattern section 422, is provided for sub-vectors starting at positions other than zero. The H.264/AVC CBP VLC (optionally shifted) is used with the prefix flag, which indicates whether any of the blocks contain non-zero values. For example, if the flag is set to one, the CBP may be decremented and coded into the bit stream using the regular H.264/AVC CBP procedure.<br>
[0072]    In another embodiment, since the regular H.264/AVC CBP VLC is context-based, where the context is determined by the presence of non-zero values in neighboring blocks the contexts may be modified so that the non-zero determination is based not only on coefficients in the same vector of neighboring blocks, but also on earlier vectors. This feature may be enabled or disabled based the length of the sub-vector and/or the sub-vector start position. For example, considering the vector [0 0101000000 0] which covers coefficient positions 4 to 35 and using regular H.264/AVC CBP coding, the presence of non-zero values in coefficients 0 to 3 of neighboring blocks would be ignored (those coefficients are coded in a different slice, and are padded with zeros in the current slice). A coding efficiency gain may be realized by taking into consideration not only the presence of non-zero values in coefficients 4 to 15, but also coefficients 0 to 3 of the slice that contains vector [12 0 4 -2]. By way of illustration, if there are a very high number of non-zero values in the neighboring vector of the same block, the CBP should be biased towards a non-zero value.<br>
 <br>
[0073]    In a further embodiment, the CBP value may be prefixed by a continuity flag that indicates whether the CBP is the same as that for the previously coded macroblock. Thus, if the continuity flag is set to zero, the CBP is coded as usual. If the continuity flag is set to one, the CBP from the previous macroblock is used. This continuity flag may be included or omitted from the bit stream based upon criteria such as the start position of the sub-vector and/or the length of the sub-vector, the slice type, the layer or quality ID, the base layer ID, and context information from neighboring macroblocks. The continuity flag may also be combined with the CBP itself, rather than coded as a separate flag, so that one particular value in the set of possible CBP values indicates that the CBP from the previous macroblock should be re-used.<br>
[0074]    This may also be applicable to context-based binary arithmetic coding (CABAC), wherein the CBP value of the previous macroblock is used, at least in part, when determining the context for coding of the current macroblock CBP. [0075]    In another embodiment, the VLC table used when coding the "total run" in H.264/AVC CAVLC is adjusted based upon the length of the sub-vector. Conventionally, the VLC codeword used when coding the "total run" is a two dimensional array based on the scan position within the block and on the total run in the block. According to this embodiment, a third dimension reflecting the length of the sub-vector is added to the array.<br>
[0076]    In a further embodiment, the VLC codeword tables of H.264/AVC CAVLC are used when coding the "total run" for a sub-vector, but the VLC table index is adjusted based on the length of the sub-vector. For example, if a sub-vector has length 3, then the H.264/AVC VLC codeword tables corresponding to vector length 4 may be used, with the VLC table index incremented by one. For example, if a sub-vector has length 2, then the H.264/AVC VLC codeword tables corresponding to vector length 4 may be used, with the VLC table index incremented by two. Thus the increment is based on a mathematical expression involving the next-highest H.264/AVC vector length (either 4 or 36) and the sub-vector size. For example, the mathematical expression min(VLCTable+4-SubbandSize,2) may be used when the sub-vector length<br>
 <br>
(SubbandSize) is less than or equal to 4. The VLC table index would be capped so that it does not exceed the maximum permissible value in H.264/AVC.<br>
[0077]    This aspect of the invention may be used in a similar manner in CABAC coding. For example, when forming a CABAC context for the coding of a significance indicator or a level indicator, the ordinary CABAC context may be shifted by an amount based on (4-SubbandSize) for sub-vectors of length iess than or equal to 4. As with the CAVLC case, the context shift would be capped so as to be within the minimum and maximum limits imposed by H.264/AVC.<br>
[0078]    In another embodiment, various modes associated with macroblocks corresponding to a common coefficient vector may be aligned. Thus, all sub-vector macroblocks for a given coefficient vector have the same mode. In the above example with the coefficient vector [12 0 4 -2 0 0 1 0 1 0 0 0 0 0 0 0], the macroblock for the sub-vector [12 0 4-2] and the macroblock for the sub-vector [0 0101000000 0] have aligned modes. This alignment may be stipulated in the coder design or, alternatively, may be indicated in the bit stream.<br>
[0079]    In such embodiments, the coding of syntax elements such as the transform size flag, BL skip flag, etc., may be skipped depending upon the alignment condition, for all macroblocks except those corresponding to the first sub-vector (vectors starting at coefficient position 0).<br>
[0080]    While particular embodiments of the present invention have been disclosed, it is to be understood that various different modifications and combinations are possible and are contemplated within the true spirit and scope of the appended claims. There is no intention, therefore, of limitations to the exact abstract and disclosure herein presented, [0081]    Various embodiments of present invention described herein are described in the general context of method steps, which may be implemented in one embodiment by a program product including computer-executable instructions, such as program code, executed by computers in networked environments. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Computer-executable instructions, associated<br>
 <br>
data structures, and program modules represent examples of program code for executing steps of the methods disclosed herein. The particular sequence of such executable instructions or associated data structures represents examples of corresponding acts for implementing the functions described in such steps. Various embodiments of the present invention can be implemented directly in software using any common programming language, e.g. C/C++ or assembly language.<br>
[0082]    Software and web implementations of the present invention could be accomplished with standard programming techniques with rule based logic and other logic to accomplish the various database searching steps, correlation steps, comparison steps and decision steps. It should also be noted that the words "component" and "module," as used herein and in the claims, is intended to encompass implementations using one or more lines of software code, and/or hardware implementations, and/or equipment for receiving manual inputs.<br>
[0083]    Individual and specific structures described in the foregoing examples should be understood as constituting representative structure of means for performing specific functions described in the following the claims, although limitations in the claims should not be interpreted as constituting "means plus function" limitations in the event that the term "means" is not used therein. Additionally, the use of the term "step" in the foregoing description should not be used to construe any specific limitation in the claims as constituting a "step plus function" limitation. To the extent that individual references, including issued patents, patent applications, and non-patent publications, are described or otherwise mentioned herein, such references are not intended and should not be interpreted as limiting the scope of the following claims.<br>
[0084]    The foregoing description of embodiments of the present invention have been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the present invention to the precise form disclosed, and modifications and variations are possible in light of the above teachings or may be acquired from practice of the present invention. The embodiments were chosen and described in order to explain the principles of the present invention and its practical application to enable one skilled in<br>
 <br>
the art to utilize the present invention in various embodiments and with various modifications as are suited to the particular use contemplated.<br>
 <br>
We claim:<br>
1.	A method for encoding an image, comprising:<br>
dividing a coefficient vector into a plurality of sub-vectors;<br>
indicating position of a sub-vector of the plurality of sub-vectors within the coefficient vector; and<br>
encoding the coefficient values of the sub-vector using a variable-length coder.<br>
2.	The method as claimed in claim 1, wherein the position of the sub-vector is indicated by a start and end position within the coefficient vector.<br>
3.	The method as claimed in claim 1, wherein the position of the sub-vector is indicated by a start position within the coefficient vector and a length of the sub-vector.<br>
4.	The method as claimed in claim 1, comprising:<br>
selecting a variable length coder for the sub-vector based on the length of the sub-vector from a group of variable length coders.<br>
5.	The method as claimed in claim 4, wherein the selecting a coder includes determining whether the length of the sub-vector is greater than or less than a predetermined threshold.<br>
6.	The method as claimed in claim 4, comprising:<br>
assigning a variable-length codeword to represent a coefficient of the sub-vector based on the sub-vector length.<br>
7.	The method as claimed in claim 1, comprising:<br>
selecting a variable length coder for the sub-vector based on the position of the sub-vector within the coefficient vector from a group of variable length coders.<br>
8.	The method as claimed in claim 1, comprising:<br>
encoding a "trailing ones" syntax element for the block corresponding to a sub-vector.<br>
9.	The method as claimed in claim 1, comprising:<br>
 <br>
encoding a coded block pattern for a macroblock, the coded block pattern representative of whether a plurality of sub-vectors of coefficient vectors corresponding to a plurality of blocks of the macroblock have any non-zero coefficient values.<br>
10.	The method as claimed in claim 1, comprising:<br>
encoding an indication representative of whether a coded block pattern for a macroblock is derived from a coded block pattern for a previously coded macroblock or not, the coded block pattern representative of whether a plurality of sub-vectors of coefficient vectors corresponding to a plurality of blocks of the macroblock have any non-zero coefficient values.<br>
11.	An apparatus, comprising:<br>
a receiver for receiving a source video signal; and<br>
an encoder operatively coupled to the receiver wherein the encoder is configured to: -<br>
process the video signal,<br>
divide a coefficient vector into a plurality of sub-vectors;<br>
indicate position of a sub-vector of the plurality of sub-vectors within the coefficient vector; and<br>
encode the coefficient values of the sub-vector using a variabie-iength coder.<br>
12.	The apparatus as claimed in claim 11, wherein the position of the sub-vector is indicated by a start and end position within the coefficient vector.<br>
13.	The apparatus as claimed in claim 11 , wherein the position of the sub-vector is indicated by a start position within the coefficient vector and a length of the sub-vector.<br>
14.	The apparatus as claimed in claim 11, wherein the encoder is configured to select a variable length coder for the sub-vector based on the length of the sub-vector from a group of variable length coders.<br>
15.	The apparatus as claimed in claim 14, wherein the encoder is configured to determine whether the length of the sub-vector is greater than or less than a predetermined threshold.<br>
 <br>
16.	The apparatus as claimed in claim 14, wherein the encoder is configured to assign a variable-length codeword to represent a coefficient of the sub-vector based on the sub-vector length.<br>
17.	The apparatus as claimed in claim 11, wherein the encoder is configured to select a variable length coder for the sub-vector based on the position of the sub-vector within the coefficient vector from a group of variable length coders.<br>
18.	The apparatus as claimed in claim 11, wherein the encoder is configured to encode a "trailing ones" syntax element for the block corresponding to a sub-vector.<br>
19.	The apparatus as claimed in claim 11, wherein the encoder is configured to encode a coded block pattern for a macroblock, the coded block pattern representative of whether a plurality of sub-vectors of coefficient vectors corresponding to a plurality of blocks of the macroblock have any non-zero coefficient values.<br>
20.	An apparatus, comprising:<br>
a processor; and<br>
a memory unit communicatively coupled to the processor wherein the processor is configured to:<br>
divide a coefficient vector into a plurality of sub-vectors;<br>
indicate position of a sub-vector of the plurality of sub-vectors within the coefficient vector; and<br>
encode the coefficient values of the sub- vector using a variable-length coder.<br>
21.	A computer-readable storage medium having a program recorded thereon<br>
where the program makes the computer execute:<br>
dividing a coefficient vector into a plurality of sub-vectors;<br>
indicating position of a sub-vector of the plurality of sub-vectors within the coefficient vector; and<br>
encoding the coefficient values of the sub- vector using a variable-length coder.<br>
 <br>
22.	The computer-readable storage medium as claimed in claim 21 , wherein the position of the sub-vector is indicated by a start and end position within the coefficient vector.<br>
23.	The computer-readable storage medium as claimed in claim 21 , comprising:<br>
selecting a variable length coder for the sub- vector based on the length of the sub-vector from a group of variable length coders.<br>
24.	The computer-readable storage medium as claimed in claim 21, comprising:<br>
assigning a variable-length codeword to represent a coefficient of the sub-vector based on the sub-vector length.<br>
25.	The computer-readable storage medium as claimed in claim 21, comprising:<br>
encoding a coded block pattern for a macroblock, the coded block pattern representative of whether a plurality of sub-vectors of coefficient vectors corresponding to a plurality of blocks of the macroblock have any non-zero coefficient values.<br>
26.	A method for decoding an encoded image, comprising:<br>
receiving position of a sub-vector within a coefficient vector representative of a biock of an image;<br>
receiving a set of coefficients for the sub-vector;<br>
forming the coefficient vector based on the received set of coefficients and the position of the sub-vector; and<br>
decoding the block.<br>
27.	The method as claimed in claim 26, wherein the position of the sub-vector is indicated by a start and end position within the coefficient vector.<br>
28.	The method as claimed in claim 26, wherein the position of the sub-vector is indicated by a start position within the coefficient vector and a length of the sub-vector.<br>
29.	The method as claimed in claim 26, comprising:<br>
selecting a variable length coder for the sub-vector based on the length of the sub-vector from a group of variable length coders.<br>
 <br>
30.	The method as claimed in claim 29, wherein the selecting a coder includes determining whether the length of the sub-vector is greater than or less than a predetermined threshold.<br>
31.	The method as claimed in claim 29, comprising:<br>
decoding a variable- length codeword to represent a coefficient of the sub-vector based on the sub-vector length.<br>
32.	The method as claimed in claim 26, comprising:<br>
selecting a variable length coder for the sub-vector based on the position of the sub-vector within the coefficient vector from a group of variable length coders.<br>
33.	The method as claimed in claim 26, comprising:<br>
decoding a "trailing ones" syntax element for the block corresponding to a sub-vector.<br>
34.	The method as claimed in claim 26, comprising:<br>
decoding a coded block pattern for a macroblock, the coded block pattern representative of whether a plurality of sub-vectors of coefficient vectors corresponding to a plurality of blocks of the macroblock have any non-zero coefficient values.<br>
35.	The method as claimed in claim 26, comprising:<br>
receiving an indication representative of whether a coded block pattern for a macroblock is derived from a coded block pattern for a previously coded macroblock or not, the coded block pattern representative of whether a plurality of sub-vectors of coefficient vectors corresponding to a plurality of blocks of the macroblock have any non-zero coefficient values.<br>
36.	An apparatus, comprising:<br>
a receiver for receiving a source video signal; and<br>
a decoder operatively coupled to the receiver wherein the decoder is configured to: -<br>
process the video signal,<br>
receive position of a sub-vector within a coefficient vector representative of a block of an image;<br>
 <br>
receive a set of coefficients for the sub-vector;<br>
form the coefficient vector based on the received set of coefficients and the position of the sub-vector; and<br>
decode the block.<br>
37.	The apparatus as claimed in claim 36, wherein the position of the sub-vector is indicated by a start and end position within the coefficient vector.<br>
38.	The apparatus as claimed in claim 36, wherein the position of the sub-vector is indicated by a start position within the coefficient vector and a length of the sub-vector.<br>
39.	The apparatus as claimed in claim 36, wherein the decoder is configured to select a variable length coder for the sub-vector based on the length of the sub-vector from a group of variable length coders.<br>
40.	The apparatus as claimed in claim 39, wherein the decoder is configured to determine whether the length of the sub-vector is greater than or less than a predetermined threshold.<br>
41.	The apparatus as claimed in claim 39, wherein the decoder is configured to decode a variable-length codeword to represent a coefficient of the sub-vector based on the sub-vector length.<br>
42.	The apparatus as claimed in claim 36, wherein the decoder is configured to select a variable length coder for the sub-vector based on the position of the sub-vector within the coefficient vector from a group of variable length coders.<br>
43.	The apparatus as claimed in claim 36, wherein the decoder is configured to decode a "trailing ones" syntax element for the block corresponding to a sub-vector.<br>
44.	The apparatus as claimed in claim 36, wherein the decoder is configured to decode a coded block pattern for a macroblock, the coded block pattern representative of whether a plurality of sub-vectors of coefficient vectors corresponding to a plurality of blocks of the macroblock have any non-zero coefficient values.<br>
45.	The apparatus as claimed in claim 36, wherein the decoder is configured to receive an indication representative of whether a coded block pattern for a macroblock is derived from a coded block pattern for a previously coded macroblock or not, the coded block pattern representative of whether a plurality of sub-vectors of coefficient vectors corresponding to a plurality of blocks of the macroblock have any non-zero coefficient values.<br>
 <br>
46.	An apparatus, comprising:<br>
a processor; and<br>
a memory unit communicatively coupled to the processor wherein the processor is configured to:<br>
receive   position   of   a   sub-vector   within   a   coefficient   vector representative of a block of an image;<br>
receive a set of coefficients for the sub-vector;<br>
form the coefficient vector based on the received set of coefficients and the position of the sub- vector; and<br>
decode the block.<br>
47.	A computer-readable storage medium having a program recorded thereon<br>
where the program makes the computer execute:<br>
receiving position of a sub-vector within a coefficient vector representative of a block of an image;<br>
receiving a set of coefficients for the sub- vector;<br>
forming the coefficient vector based on the received set of coefficients and the position of the sub-vector; and<br>
decoding the block.<br>
48.	The computer-readable storage medium as claimed in claim 47, wherein the position of the sub-vector is indicated by a start and end position within the coefficient vector.<br>
49.	The computer-readable storage medium as claimed in claim 47, where the program makes the computer execute::<br>
selecting a variable length coder for the sub- vector based on the length of the sub-vector from a group of variable length coders.<br>
50.	The computer-readable storage medium as claimed in claim 47, where the<br>
program makes the computer execute::<br>
decoding a variable-length codeword to represent a coefficient of the sub-vector based on the sub-vector length.<br>
 <br>
51. The computer-readable storage medium as claimed in claim 47, where the program makes the computer execute::<br>
decoding a coded block pattern for a macroblock, the coded block pattern representative of whether a plurality of sub-vectors of coefficient vectors corresponding to a plurality of blocks of the macroblock have any non-zero coefficient values.<br>
<br>
Dated this 08th day of October 2009<br>
<br>
Of Anand and Anand, Advocates Agents for the Applicants</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=IxxxwU0RoYQM1jP559BvWw==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=IxxxwU0RoYQM1jP559BvWw==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==</a></p>
		<br>
		<div class="pull-left">
			<a href="279421-method-and-apparatus-for-pitch-search.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="279423-a-system-for-synchronizing-clocks-across-a-network.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>279422</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>5954/CHENP/2009</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>04/2017</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>27-Jan-2017</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>20-Jan-2017</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>08-Oct-2009</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>NOKIA TECHNOLOGIES OY</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>Karaportti 3, FI-02610 Espoo,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>RIDGE Justin</td>
											<td>5604 Summit Knoll Trail  Sachse,  TX 75048 USA.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>WANG Xianglin</td>
											<td>431 EL Camino Real  Apt, 3210  Santa Clara  CA 95050 USA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04N 7/26</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/IB2008/050905</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2008-03-12</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/894,667</td>
									<td>2007-03-13</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/279422-system-and-method-for-video-encoding-and-decoding by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:03:44 GMT -->
</html>
