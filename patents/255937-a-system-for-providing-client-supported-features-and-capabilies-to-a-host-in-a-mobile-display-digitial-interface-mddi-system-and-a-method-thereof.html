<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/255937-a-system-for-providing-client-supported-features-and-capabilies-to-a-host-in-a-mobile-display-digitial-interface-mddi-system-and-a-method-thereof by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:06:12 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 255937:&quot;A SYSTEM FOR PROVIDING CLIENT SUPPORTED FEATURES AND CAPABILIES TO A HOST IN A MOBILE DISPLAY DIGITIAL INTERFACE (MDDI) SYSTEM AND A METHOD THEREOF&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;A SYSTEM FOR PROVIDING CLIENT SUPPORTED FEATURES AND CAPABILIES TO A HOST IN A MOBILE DISPLAY DIGITIAL INTERFACE (MDDI) SYSTEM AND A METHOD THEREOF&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A system for providing management of data in a MDDI system is provided. A method and system is provided such that client supported features and capabilities to a host in a mobile display digital interface (MDDI) system is provided wherein at least one field is added to a client capability packet for the client supported features and capabilities followed by providing values to each field of the at least one field unique to at least one client in the client capability packet and such that the client capability packet is transmitted from the at least one client to the host after acquisition of forward link synchronization. The transmission of the client capability packet is required when requested by the host using a reverse link flag in a reverse link encapsulation packet. Also a method and system for reverse data sampling in a mobile display digital interface (MDDI) is provided.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>CROSS-REFERENCE TO RELATED APPLICATIONS<br>
[0001] The present Application for Patent claims priority to Provisional Application No. 60/511,742 entitled "Switchable Threshold Differential Interface" filed October 15, 2003, and assigned to the assignee hereof and hereby expressly incorporated by reference herein.<br>
BACKGROUND<br>
I.	Field<br>
[0002] Embodiments of the invention in this disclosure relate to a system for providing client supported features and capabilities to a host in a mobile display digital interface (MDDI) system and a method thereof. More specifically, the disclosure relates to a technique for transferring multimedia and other types of digital signals from a host or controller device to a client device for presentation or display to an end user using a low power high data rate transfer mechanism having internal and external device applications.<br>
II.	Background<br>
[0003] Computers, electronic game related products, and various video technologies (for example DVD's and High Definition VCRs) have advanced significantly over the last few years to provide for presentation of increasingly higher resolution still, video, video-on-demand, and graphics images, even when including some types of text, to end users of such equipment. These advances in turn mandated the use of higher resolution electronic viewing devices such as high definition video monitors, HDTV monitors, or specialized image projection elements. Combining such visual images with high-definition or -quality audio data, such as when using CD type sound reproduction, DVDs, surround-sound, and other devices also having associated audio signal outputs, is used to create a more realistic, content rich, or true multimedia experience for an end user. In addition, highly mobile, high quality sound systems and music transport mechanisms, such as MP3 players, have been developed for audio only presentations to end users. This has resulted in increased expectations for typical users of commercial electronics devices, from computers to televisions and even telephones, now being accustomed to and expecting high or premium quality output.<br>
[0004] In a typical video presentation scenario, involving an electronics product, video<br>
data is typically transferred using current techniques at a rate that could be best termed<br>
as slow or medium, being on the order of one to tens of kilobits per second. This data is<br>
then either buffered or stored in transient or longer-term memory devices, for delayed<br>
(later) play out on a desired viewing device. For example, images may be transferred<br>
"across" or using the Internet using a program resident on a computer having a modem<br>
or other type of Internet connection device, to receive or transmit data useful in digitally<br>
representing an image. A similar transfer can take place using wireless devices such as<br>
portable computers equipped with wireless modems, or wireless Personal Data<br>
Assistants (PDAs), or wireless telephones.<br>
[0005] Once received, the data is stored locally in memory elements, circuits, or<br>
devices, such as RAM or flash memory, including internal or external storage devices<br>
such as small size hard drives, for playback. Depending on the amount of data and the<br>
image resolution, the playback might begin relatively quickly, or be presented with<br>
longer-term delay. That is, in some instances, image presentation allows for a certain<br>
degree of real time playback for very small or low resolution images not requiring much<br>
data, or using some type of buffering, so that after a small delay, some material is<br>
presented while more material is being transferred. Provided there are no interruptions<br>
in the transfer link, or interference from other systems or users relative to the transfer<br>
channel being used, once the presentation begins the transfer is reasonably transparent<br>
to the end user of the viewing device. Naturally, where multiple users share a single<br>
communication path, such as a wired Internet connection, transfers can be interrupted or<br>
slower than desired.<br>
[0006] The data used to create either still images or motion video are often<br>
compressed using one of several well known techniques such as those specified by the<br>
Joint Photographic Experts Group (JPEG), the Motion Picture Experts Group (MPEG),<br>
and other well known standards organizations or companies in the media, computer, and<br>
communications industries to speed the transfer of data over a communication link.<br>
This allows transferring images or data faster by using a smaller number of bits to<br>
transfer a given amount of information.<br>
[0007] Once the data is transferred to a "local" device such as a computer having a<br>
storage mechanism such as memory, or magnetic or optical storage elements, or to other<br>
recipient devices, the resulting information is un-compressed (or played using special<br>
decoding players), and decoded if needed, and prepared for appropriate presentation<br>
based on the corresponding available presentation resolution and control elements. For<br>
example, a typical computer video resolution in terms of a screen resolution of X by Y<br>
pixels typically ranges from as low as 480x640 pixels, through 600x800 to 1024x1024,<br>
although a variety of other resolutions are generally possible, either as desired or<br>
needed.<br>
[0008] Image presentation is also affected by the image content and the ability of<br>
given video controllers to manipulate the image in terms of certain predefined color<br>
levels or color depth (bits per pixel used to generate colors) and intensities, and any<br>
additional overhead bits being employed. For example, a typical computer presentation<br>
would anticipate anywhere from around 8 to 32, or more, bits per pixel to represent<br>
various colors (shades and hues), although other values are encountered.<br>
[0009] From the above values, one can see that a given screen image is going to<br>
require the transfer of anywhere from 2.45 Megabits (Mb) to around 33.55 Mb of data<br>
over the range from the lowest to highest typical resolutions and depth, respectively.<br>
When viewing video or motion type images at a rate of 30 frames per second, the<br>
amount of data required is around 73.7 to 1,006 Megabits of data per second (Mbps), or<br>
around 9.21 to 125.75 Megabytes per second (MBps). In addition, one may desire to<br>
present audio data in conjunction with images, such as for a multimedia presentation, or<br>
as a separate high resolution audio presentation, such as CD quality music. Additional<br>
signals dealing with interactive commands, controls, or signals may also be employed.<br>
Each of these options adding even more data to be transferred. Furthermore, newer<br>
transmission techniques involving High Definition (HD) television and movie<br>
recordings may add even more data and control information. In any case, when one<br>
desires to transfer high quality or high resolution image data and high quality audio<br>
information or data signals to an end user to create a content rich experience, a high data<br>
transfer rate link is required between presentation elements and the source or host<br>
device that is configured to provide such types of data.<br>
[0010] Data rates of around 115 Kilobytes (KBps) or 920 Kilobits per second (Kbps)<br>
can be routinely handled by some modern serial interfaces. Other interfaces such as<br>
USB serial interfaces, can accommodate data transfers at rates as high as 12 MBps, and<br>
specialized high speed transfers such as those configured using the Institute of Electrical<br>
and Electronics Engineers (IEEE) 1394 standard, can occur at rates on the order of 100<br>
to 400 MBps. Unfortunately, these rates fall short of the desired high data rates<br>
discussed above which are contemplated for use with future wireless data devices and<br>
other services for providing high resolution, content rich, output signals for driving<br>
portable video displays or audio devices. This includes computers for business and<br>
other presentations, gaming devices, and so forth. In addition, these interfaces require<br>
the use of a significant amount of host or system and client software to operate. Their<br>
software protocol stacks also create an undesirably large amount of overhead, especially<br>
where mobile wireless devices or telephone applications are contemplated. Such<br>
devices have severe memory and power consumption limitations, as well as already<br>
taxed computational capacity. Furthermore, some of these interfaces utilize bulky<br>
cables which are too heavy and unsatisfactory for highly aesthetic oriented mobile<br>
applications, complex connectors which add cost, or simply consume too much power.<br>
[0011] There are other known interfaces such as the Analog Video Graphics Adapter<br>
(VGA), Digital Video Interactive (DVI) or Gigabit Video Interface (GVIF) interfaces.<br>
The first two of these are parallel type interfaces which process data at higher transfer<br>
rates, but also employ heavy cables and consume large amounts of power, on the order<br>
of several watts. Neither of these characteristics are amenable to use with portable<br>
consumer electronic devices. Even the third interface consumes too much power and<br>
uses expensive or bulky connectors.<br>
[0012] For some of the above interfaces, and other very high rate data<br>
systems/protocols or transfer mechanisms associated with data transfers for fixed<br>
installation computer equipment, there is another major drawback. To accommodate the<br>
desired data transfer rates also requires substantial amounts of power and/or operation at<br>
high current levels. This greatly reduces the usefulness of such techniques for highly<br>
mobile consumer oriented products.<br>
[0013] Generally, to accommodate such data transfer rates using alternatives such as<br>
say optical fiber type connections and transfer elements, also requires a number of<br>
additional converters and elements that introduce much more complexity and cost, than<br>
desired for a truly commercial consumer oriented product. Aside from the generally<br>
expensive nature of optical systems as yet, their power requirements and complexity<br>
prevents general use for lightweight, low power, portable applications.<br>
[0014] What has been lacking in the industry for portable, wireless, or mobile<br>
applications, is a technique to provide a high quality presentation experience, whether it<br>
be audio, video, or multimedia based, for highly mobile end users. That is, when using<br>
portable computers, wireless phones, PDAs, or other highly mobile communication<br>
devices or equipment, the current video and audio presentation systems or devices being<br>
used simply cannot deliver output at the desired high quality level. Often, the perceived<br>
quality that is lacking is the result of unobtainable high data rates needed to transfer the<br>
high quality presentation data. This can include both transfer to more efficient,<br>
advanced or feature laden external devices for presentation to an end user, or transfer<br>
between hosts and clients internal to portable devices such as computers, gaming<br>
machines, and wireless devices such as mobile telephones.<br>
[0015] In this latter case, there have been great strides made in adding higher and<br>
higher resolution internal video screens, and other specialty input and/or output devices<br>
and connections to wireless devices like so called third generation telephones, and to so<br>
called laptop computers. However, internal data busses and connections which may<br>
include bridging across rotating or sliding hinge or hinge-like structures which mount or<br>
connect video screens or other elements to the main housing where the host and/or<br>
various other control elements and output components reside. It is very difficult to<br>
construct high throughput data transfers interfaces using prior techniques which can<br>
require up to 90 conductors, or more, to achieve the desired throughput, on say a<br>
wireless telephone, as one example. This presents many manufacturing, cost<br>
prohibitive, and reliability challenging issues to overcome.<br>
[0016] Such issues and requirements are also being seen on fixed location installations<br>
where communication or computing type devices, as one example, are added to<br>
appliances and other consumer devices to provide advanced data capabilities, Internet<br>
and data transfer connections, or built in entertainment. Another example would be<br>
airplanes and busses where individual video and audio presentation screen are mounted<br>
in seat-backs. However, in these situations it is often more convenient, efficient, and<br>
easily serviceable to have the main storage, processing, or communication control<br>
elements located a distance from visible screens or audio outputs with an<br>
interconnecting link or channel for the presentation of information. This link will need<br>
to handle a significant amount of data to achieve the desired throughput, as discussed<br>
above.<br>
[0017] Therefore, a new transfer mechanism is needed to increase data throughput<br>
between host devices providing the data and client display devices or elements<br>
presenting an output to end users.<br>
[0018] Applicants have proposed such new transfer mechanisms in US Patent<br>
Application Serial Nos. 10/020,520 and 10/236,657, both entitled "Generating And<br>
Implementing A Communication Protocol And Interface For High Data Rate Signal<br>
Transfer", now allowed, which are assigned to the assignee of the present invention and<br>
incorporated herein by reference. Also, Application Serial No. 10/860,116 entitled<br>
"Generating and Implementing a Signal Protocol and Interface for Higher Data Rates."<br>
The techniques discussed in those applications can greatly improve the transfer rate for<br>
large quantities of data in high speed data signals. However, the demands for ever<br>
increasing data rates, especially as related to video presentations, continue to grow.<br>
Even with other ongoing developments in data signal technology, there is still a need to<br>
strive for even faster transfer rates, improved communication link efficiencies, and more<br>
powerful communication links. Therefore, there is a continuing need to develop a new<br>
or improved transfer mechanism which is needed to increase data throughput between<br>
host and client devices.<br>
SUMMARY<br>
[0019] The above drawback, and others, existent in the art are addressed by<br>
embodiments of the invention in which a new protocol and data transfer means, method<br>
and mechanism have been developed for transferring data between a host device and a<br>
recipient client device at high data rates.<br>
[0020] Embodiments for the invention are directed to a Mobile Data Digital Interface<br>
(MDDI) for transferring digital data at a high rate between a host device and a client<br>
device over a communication path which employs a plurality or series of packet<br>
structures to form a communication protocol for communicating a pre-selected set of<br>
digital control and presentation data between the host and client devices. The signal<br>
communications protocol or link layer is used by a physical layer of host or client link<br>
controllers. At least one link controller residing in the host device is coupled to the<br>
client device through the communications path or link, and is configured to generate,<br>
transmit, and receive packets forming the communications protocol, and to form digital<br>
presentation data into one or more types of data packets. The interface provides for bidirectional<br>
transfer of information between the host and client, which can reside within<br>
a common overall housing or support structure.<br>
[0021] The implementation is generally all digital in nature with the exception of<br>
differential drivers and receivers which can be easily implemented on a digital CMOS<br>
chip, requires a few as 6 signals, and operates at almost any data rate that is convenient<br>
for the system designer. The simple physical and link layer protocol makes it easy to<br>
integrate, and this simplicity plus a hibernation state enables the portable system to have<br>
very low system power consumption.<br>
[0022] To aid in use and acceptance, the interface will add very little to the cost of a<br>
device, will allow for consumption of very little power while able to power displays<br>
through the interface using standard battery voltages, and can accommodate devices<br>
having a pocket-able form-factor. The interface is scalable to support resolutions<br>
beyond HDTV, supports simultaneous stereo video and 7.1 audio to a display device,<br>
performs conditional updates to any screen region, and supports multiple data types in<br>
both directions.<br>
[0023] In further aspects of embodiments of the invention, at least one client link<br>
controller, or client receiver, is disposed in the client device and is coupled to the host<br>
device through the communications path or link. The client link controller is also<br>
configured to generate, transmit, and receive packets forming the communications<br>
protocol, and to form digital presentation data into one or more types of data packets.<br>
Generally, the host or link controller employs a state machine for processing data<br>
packets used in commands or certain types of signal preparation and inquiry processing,<br>
but can use a slower general purpose processor to manipulate data and some of the less<br>
complex packets used in the communication protocol. The host controller comprises<br>
one or more differential line drivers; while the client receiver comprises one or more<br>
differential line receivers coupled to the communication path.<br>
[0024] The packets are grouped together within media frames that are communicated<br>
between the host and client devices having a pre-defined fixed length with a predetermined<br>
number of packets having different variable lengths. The packets each<br>
comprise a packet length field, one or more packet data fields, and a cyclic redundancy<br>
check field. A Sub-frame Header Packet is transferred or positioned at the beginning of<br>
transfers of other packets from the host link controller. One or more Video Stream type<br>
packets and Audio Stream type packets are used by the communications protocol to<br>
transfer video type data and audio type data, respectively, from the host to the client<br>
over a forward link for presentation to a client device user. One or more Reverse Link<br>
Encapsulation type packets are used by the communications protocol to transfer data<br>
from the client device to the host link controller. These transfer in some embodiments<br>
include the transfer of data from internal controllers having at leas one MDDI device to<br>
internal video screens. Other embodiments include transfer to internal sound systems,<br>
and transfers from various input devices including joysticks and complex keyboards to<br>
internal host devices,<br>
[0025] Filler type packets are generated by the host link controller to occupy periods<br>
of forward link transmission that do not have data. A plurality of other packets are used<br>
by the communications protocol to transfer video information. Such packets include<br>
Color Map, Bit Block Transfer, Bitmap Area Fill, Bitmap Pattern Fill, and Transparent<br>
Color Enable type packets. User-Defined Stream type packets are used by the<br>
communications protocol to transfer interface-user defined data. Keyboard Data and<br>
Pointing Device Data type packets are used by the communications protocol to transfer<br>
data to or from user input devices associated with said client device. A Link Shutdown<br>
type packet is used by the communications protocol to terminate the transfer of data in<br>
either direction over said communication path,<br>
[0026] The communication path generally comprises or employs a cable having a<br>
series of four or more conductors and a shield. In addition, printed wires or conductors<br>
can be used, as desired, with some residing on flexible substrates.<br>
[0027] The host link controller requests display capabilities information from the<br>
client device in order to determine what type of data and data rates said client is capable<br>
of accommodating through said interface. The client link controller communicates<br>
display or presentation capabilities to the host link controller using at least one Client<br>
Capability type packet. Multiple transfer modes are used by the communications<br>
protocol with each allowing the transfer of different maximum numbers of bits of data<br>
in parallel over a given time period, with each mode selectable by negotiation between<br>
the host and client link controllers. These transfer modes are dynamically adjustable<br>
during transfer of data, and the same mode need not be used on the reverse link as is<br>
used on the forward link.<br>
[0028] In other aspects of some embodiments of the invention, the host device<br>
comprises a wireless communications device, such as a wireless telephone, a wireless<br>
PDA, or a portable computer having a wireless modem disposed therein. A typical<br>
client device comprises a portable video display such as a micro-display device, and/or<br>
a portable audio presentation system. Furthermore, the host may use storage means or<br>
elements to store presentation or multimedia data to be,transferred to be presented to a<br>
client device user.<br>
[0029] In still other aspects of some embodiments, the host device comprises a<br>
controller or communication link control device with drivers as described below<br>
residing within a portable electronic device such as a wireless communications device,<br>
such as a wireless telephone, a wireless PDA, or a portable computer. A typical client<br>
device in this configuration comprises a client circuit or integrated circuit or module<br>
coupled to the host and residing within the same device, and to an internal video display<br>
such as a high resolution screen for a mobile phone, and/or a portable audio presentation<br>
system, or in the alternative some type of input system or device.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0030] Further features and advantages of the invention, as well as the structure and<br>
operation of various embodiments of the invention, are described in detail below with<br>
reference to the accompanying drawings. In the drawings, like reference numbers<br>
generally indicate identical, functionally similar, and/or structurally similar elements or<br>
processing steps, and the drawing in which an element first appears is indicated by the<br>
leftmost digit(s) in the reference number.<br>
[0031] FIG. 1A illustrates a basic environment in which embodiments of the invention<br>
might operate including the use of a micro-display device, or a projector, in conjunction<br>
with a portable computer or other data processing device.<br>
[0032] FIG. IB illustrates a basic environment in which embodiments of the invention<br>
might operate including the use of a micro-display device or a projector, and audio<br>
presentation elements used in conjunction with a wireless transceiver.<br>
[0033] FIG. 1C illustrates a basic environment in which embodiments of the invention<br>
might operate including the use of internal display or audio presentation devices used in<br>
a portable computer.<br>
[0034] FIG. ID illustrates a basic environment in which embodiments of the invention<br>
might operate including the use of internal display or audio presentation elements used<br>
in a wireless transceiver.<br>
[0035] FIG. 2 illustrates the overall concept of a Mobile Digital Data Interface with a<br>
host and client interconnection.<br>
[0036] FIG. 3 illustrates the structure of a packet useful for realizing data transfers<br>
from a client device to a host device.<br>
[0037] FIG. 4 illustrates the use of an MDDI link controller and the types of signals<br>
passed between a host and a client over the physical data link conductors for a Type 1<br>
interface.<br>
 [0038] FIG. 5 illustrates the use of an MDDI link controller and the types of signals<br>
passed between a host and a client over the physical data link conductors for Types 2, 3,<br>
and 4 interfaces.<br>
[0039] FIG. 6 illustrates the structure of frames and sub-frames used to implement the<br>
interface protocol.<br>
[0040] FIG. 7 illustrates the general structure of packets used to implement the<br>
interface protocol.<br>
[0041] FIG. 8 illustrates the format of a Sub-frame Header Packet.<br>
[0042] FIG. 9 illustrates the format and contents of a Filler Packet.<br>
[0043] FIG. 10 illustrates the format of a Video Stream Packet.<br>
[0044] FIGS. 11A-11E illustrate the format and contents for the Video Data Format<br>
Descriptor used in FIG. 10.<br>
[0045] FIG. 12 illustrates the use of packed and unpacked formats for data.<br>
[0046] FIG. 13 illustrates the format of an Audio Stream Packet.<br>
[0047] FIG. 14 illustrates the use of byte-aligned and packed PCM formats for data<br>
[0048] FIG. 15 illustrates the format of a User-Defined Stream Packet.<br>
[0049] FIG. 16 illustrates the format of a Color Map Packet.<br>
[0050] FIG. 17 illustrates the format of a Reverse Link Encapsulation Packet.<br>
[0051] FIG. 18 illustrates the format of a Client Capability Packet.<br>
[0052] FIG. 19 illustrates the format of a Keyboard Data Packet.<br>
[0053] FIG. 20 illustrates the format of a Pointing Device Data Packet.<br>
[0054] FIG. 21 illustrates the format of a Link Shutdown Packet.<br>
[0055] FIG. 22 illustrates the format of a Client Request and Status Packet.<br>
[0056] FIG. 23 illustrates the format of a Bit Block Transfer Packet.<br>
[0057] FIG. 24 illustrates the format of a Bitmap Area Fill Packet.<br>
[0058] FIG. 25 illustrates the format of a Bitmap Pattern Fill Packet.<br>
[0059] FIG. 26 illustrates the format of a Communication Link Data Channel Packet.<br>
[0060] FIG. 27 illustrates the format of a Interface Type Handoff Request Packet.<br>
[0061] FIG. 28 illustrates the format of an Interface Type Acknowledge Packet.<br>
[0062] FIG. 29 illustrates the format of a Perform Type Handoff Packet.<br>
[0063] FIG. 30 illustrates the format of a Forward Audio Channel Enable Packet.<br>
[0064] FIG. 31 illustrates the format of a Reverse Audio Sample Rate Packet.<br>
[0065] FIG. 32 illustrates the format of a Digital Content Protection Overhead Packet.<br>
[0066] FIG. 33 illustrates the format of a Transparent Color Enable Packet.<br>
 [0067] FIG. 34 illustrates the format of a Round Trip Delay Measurement Packet.<br>
[0068] FIG. 35 illustrates the timing of events during the Round Trip Delay<br>
Measurement Packet.<br>
[0069] FIG. 36 illustrates a sample implementation of a CRC generator and checker<br>
useful for implementing the invention.<br>
[0070] FIG. 37 A illustrates the timing of CRC signals for the apparatus of FIG. 36<br>
when sending data packets.<br>
[0071] FIG. 37B illustrates the timing of CRC signals for the apparatus of FIG. 36<br>
when receiving data packets.<br>
[0072] FIG. 38 illustrates processing steps for a typical service request with no<br>
contention.<br>
[0073] FIG. 39 illustrates processing steps for a typical service request asserted after<br>
the link restart sequence has begun, contending with link start.<br>
[0074] FIG. 40 illustrates how a data sequence can be transmitted using DATA-STB<br>
encoding.<br>
[0075] FIG. 41 illustrates circuitry useful for generating the DATA and STB signals<br>
from input data at the host, and then recovering the data at the client.<br>
[0076] FIG. 42 illustrates drivers and terminating resistors useful for implementing<br>
one embodiment.<br>
[0077] FIG. 43 illustrates steps and signal levels employed by a client to secure<br>
service from the host and by the host to provide such service.<br>
[0078] FIG. 44 illustrates relative spacing between transitions on the DataO, other data<br>
lines (DataX), and the strobe lines (Stb).<br>
[0079] FIG. 45 illustrates the presence of a delay in response that can occur when a<br>
host disables the host driver after transferring a packet.<br>
[0080] FIG. 46 illustrates the presence of a delay in response that can occur when a<br>
host enables the host driver to transfer a packet.<br>
[0081] FIG. 47 illustrates the relationship at the host receiver input between the timing<br>
of the data being transferred and the leading and trailing edges of the strobe pulses.<br>
[0082] FIG. 48 illustrates switching characteristics and corresponding client output<br>
delay developed by the reverse data timing.<br>
[0083] FIG. 49 illustrates a high level diagram of signal processing steps and<br>
conditions by which synchronization can be implemented using a state machine.<br>
 [0084] FIG. 50 illustrates typical amounts of delay encountered for signal processing<br>
on the forward and reverse paths in a system employing the MDDI.<br>
[0085J FIG. 51 illustrates marginal round trip delay measurement.<br>
[0086] FIG. 52 illustrates Reverse Link data rate changes.<br>
[0087] FIG. 53 illustrates a graphical representation of values of the Reverse Rate<br>
Divisor versus forward link data rate.<br>
[0088] FIGS. 54A and 54B illustrate steps undertaken in the operation of an interface.<br>
[0089] FIG. 55 illustrates an overview of the interface apparatus processing packets.<br>
[0090] FIG. 56 illustrates the format of a Forward Link Packet<br>
[0091] FIG. 57 illustrates typical values for propagation delay and skew in an Type 1<br>
Link interface.<br>
[0092] FIG. 58 illustrates Data, Stb, and Clock Recovery Timing on a Type 1 Link for<br>
exemplary signal processing through the interface.<br>
[0093] FIG. 59 illustrates typical values for propagation delay and skew in Type 2,<br>
Type 3 or Type 4 Link interfaces.<br>
[0094] FIGS. 60A, 60B, and 60C illustrate different possibilities for the timing of two<br>
data signals and MDDI_Stb with respect to each other, being ideal, early, and late,<br>
respectively.<br>
[0095] FIG. 61 illustrates interface pin assignments exemplary connectors used with a<br>
Type-I/Type 2 interfaces.<br>
[0096] FIGS. 62A and 62B illustrate possible MDDI_Data and MDDIJStb waveforms<br>
for both Type 1 and Type 2 Interfaces, respectively.<br>
[0097] FIG. 63 illustrates a high level diagram of alternative signal processing steps<br>
and conditions by which synchronization can be implemented using a state machine.<br>
[0098] FIG. 64 illustrates exemplary relative timing between a series of clock cycles<br>
and the timing of a various reverse link packets bits and divisor values.<br>
[0099] FIG. 65 illustrates exemplary error code transfer processing.<br>
[00100] FIG. 66 illustrates apparatus useful for error code transfer processing.<br>
[00101] FIG. 67A illustrates error code transfer processing for code overloading.<br>
[00102] FIG. 67B illustrates error code transfer processing for code reception.<br>
[00103] FIG. 68A illustrates processing steps for a host initiated wake-up.<br>
[00104] FIG. 68B illustrates processing steps for a client initiated wake-up.<br>
[00105] FIG. 68C illustrates processing steps for host and client initiated wake-up with<br>
contention.<br>
 [00106] FIG. 69 illustrates the format of a Request VCP Feature Packet.<br>
[00107] FIG. 70 illustrates the format of a VCP Feature Reply Packet.<br>
[00108] FIG. 71 illustrates the format of a VCP Feature Reply List.<br>
[00109] FIG. 72 illustrates the format of a Set VCP Feature Packet.<br>
[00110] FIG. 73 illustrates the format of a Request Valid Parameter Packet.<br>
[00111] FIG. 74 illustrates the format of a Valid Parameter Reply Packet.<br>
[00112] FIG. 75 illustrates the format of a Alpha-Cursor Image Capability Packet.<br>
[00113] FIG. 76 illustrates the format of a Alpha-Cursor Transparency Map Packet.<br>
[00114] FIG. 77 illustrates the format of a Alpha-Cursor Image Offset Packet.<br>
[00115] FIG. 78 illustrates the format of a Alpha-Cursor Video Stream Packet.<br>
[00116] FIG. 79 illustrates the format of a Scaled Video Stream Capability Packet.<br>
[00117] FIG. 80 illustrates the format of a Scaled Video Stream Setup Packet.<br>
[00118] FIG. 81 illustrates the format of a Scaled Video Stream Acknowledgement<br>
Packet.<br>
[00119] FIG. 82 illustrates the format of a Scaled Video Stream Packet.<br>
[00120] FIG. 83 illustrates the format of a Request Specific Status Packet.<br>
[00121] FIG. 84 illustrates the format of a Valid Status Reply List Packet.<br>
[00122] FIG. 85A illustrates the format of a Packet Processing Delay Parameters<br>
Packet.<br>
[00123] FIG. 85B illustrates the format of a Delay Parameters List item<br>
[00124] FIG. 86 illustrates the format of a Personal Display Capability Packet.<br>
[00125] FIG. 87A illustrates the format of a Client Error Report Packet.<br>
[00126] FIG. 87B illustrates the format of an Error Report List item<br>
[00127] FIG. 88 illustrates the format of a Client Identification Packet.<br>
[00128] FIG. 89 illustrates the format of a Alternate Display Capability Packet.<br>
[00129] FIG. 90 illustrates the format of a Register Access Packet<br>
[00130] FIG. 91A-91C illustrate use of two display buffers to reduce visible artifacts.<br>
[00131] FIG. 92 illustrates two buffers with display refresh faster than image transfer.<br>
[00132] FIG. 93 illustrates two buffers with display refresh slower than image transfer.<br>
[00133] FIG. 94 illustrates two buffers with display refresh much faster than image<br>
transfer.<br>
[00134] FIG. 95 illustrates three buffers with display refresh faster than image transfer.<br>
[00135] FIG. 96 illustrates three buffers with display refresh slower than image<br>
transfer.<br>
 [00136] FIG. 97 illustrates one buffer with display refresh faster than image transfer.<br>
[00137] FIG. 98 illustrates host-client connection via daisy -chain and hub.<br>
[00138] FIG. 99 illustrates client devices connected via a combination of hubs and<br>
daisy chains.<br>
[00139] FIG. 100 illustrates a color map.<br>
[00140] FIG. 101 illustrates leakage current analysis.<br>
DETAILED DESCRIPTION OF THE EMBODIMENTS<br>
I. Overview<br>
[00141] A general intent of the invention is to provide a Mobile Display Digital<br>
Interface (MDD1), as discussed below, which results in or provides a cost-effective, low<br>
power consumption, transfer mechanism that enables high- or very-high- speed data<br>
transfer over a short-range communication link between a host device and a client<br>
device, such as a display element, using a "serial" type of data link or channel. This<br>
mechanism lends itself to implementation with miniature connectors and thin flexible<br>
cables which are especially useful in connecting internal (to a housing or support frame)<br>
display elements or input devices to a central controller, or external display elements or<br>
devices such as wearable micro-displays (goggles or projectors) to portable computers,<br>
wireless communication devices, or entertainment devices.<br>
[00142] Although the terms Mobile and Display are associated with the naming of the<br>
protocol, it is to be understood that this is for convenience only in terms of having a<br>
standard name easily understood by those skilled in the art working with the interface<br>
and protocol. However, it will be readily understood after a review of the embodiments<br>
presented below that many non-mobile and non-display related applications will benefit<br>
from application of this protocol and resulting interface structure, and the MDDI label is<br>
not intended to imply any limitations to the nature or usefulness of the invention or its<br>
various embodiments.<br>
[00143] An advantage of embodiments of the invention is that a technique is provided<br>
for data transfer that is low in complexity, low cost, has high reliability, fits well within<br>
the environment of use, and is very robust, while remaining very flexible.<br>
[00144] Embodiments of the invention can be used in a variety of situations to<br>
communicate or transfer large quantities of data, generally for audio, video, or<br>
multimedia applications from a host or source device where such data is generated or<br>
stored, to a client display or presentation device at a high rate. A typical application,<br>
which is discussed below, is the transfer of data from either a portable computer or a<br>
wireless telephone or modem to a visual display device such as a small video screen or a<br>
wearable micro-display appliance, such as in the form of goggles or helmets containing<br>
small projection lenses and screens, or from a host to client device within such<br>
components. That is, from a processor to an internal screen or other presentation<br>
element, as well as from various internal, or external input devices employing a client to<br>
an internally located (collocated within same device housing or support structure) host.<br>
[00145] The characteristics or attributes of the MDDI are such that they are<br>
independent of specific display or presentation technology. This is a highly flexible<br>
mechanism for transferring data at a high rate without regards to the internal structure of<br>
that data, nor the functional aspects of the data or commands it implements. This allows<br>
the timing of data packets being transferred to be adjusted to adapt to the idiosyncrasies<br>
of particular client devices, such as for unique display desires for certain devices, or to<br>
meet the requirements of combined audio and video for some A-V systems, or for<br>
certain input devices such as joysticks, touch pads, and so forth. The interface is very<br>
display element or client device agnostic, as long as the selected protocol is followed.<br>
In addition, the aggregate serial link data, or data rate, can vary over several orders of<br>
magnitude which allows a communication system or host device designer to optimize<br>
the cost, power requirements, client device complexity, and client device update rates.<br>
[00146] The data interface is presented primarily for use in transferring large amounts<br>
of high rate data over a "wired" signal link or small cable. However, some applications<br>
may take advantage of a wireless link as well, including optical based links, provided it<br>
is configured to use the same packet and data structures developed for the interface<br>
protocol, and can sustain the desired level of transfer at low enough power consumption<br>
or complexity to remain practical.<br>
II. Environment<br>
[00147] A typical application can be seen in FIGS. 1A and IB where a portable or<br>
laptop computer 100 and wireless telephone or PDA device 102 are shown<br>
communicating data with display devices 104 and 106, respectively, along with audio<br>
reproduction systems 108 and 112. In addition, FIG 1A shows potential connections to<br>
a larger display or screen 114 or an image projector 116, which are only shown in one<br>
figure for clarity, but are connectable to wireless device 102 as well. The wireless<br>
device can be currently receiving data or have previously stored a certain amount of<br>
multimedia type data in a memory element or device for later presentation for viewing<br>
and/or hearing by an end user of the wireless device. Since a typical wireless device is<br>
used for voice and simple text communications most of the time, it has a rather small<br>
display screen and simple audio system (speakers) for communicating information to<br>
the device 102 user.<br>
[00148] Computer 100 has a much larger screen, but still inadequate external sound<br>
system, and still falls short of other multimedia presentation devices such as a high<br>
definition television, or movie screens. Computer 100 is used for purposes of<br>
illustration and other types of processors, interactive video games, or consumer<br>
electronics devices can also be used with the invention. Computer 100 can employ, but<br>
is not limited to or by, a wireless modem or other built in device for wireless<br>
communications, or be connected to such devices using a cable or wireless link, as<br>
desired.<br>
[00149] This makes presentation of more complex or "rich" data a less than a useful or<br>
enjoyable experience. Therefore, the industry is developing other mechanisms and<br>
devices to present the information to end users and provide a minimum level of desired<br>
enjoyment or positive experience.<br>
[00150] As previously discussed above, several types of display devices have or are<br>
currently being developed for presenting information to end users of device 100. For<br>
example, one or more companies have developed sets of wearable goggles that project<br>
an image in front of the eyes of a device user to present a visual display. When<br>
correctly positioned such devices effectively "project" a virtual image, as perceived by a<br>
users eyes, that is much larger than the element providing the visual output. That is, a<br>
very small projection element allows the eye(s) of the user to "see" images on a much<br>
larger scale than possible with typical LCD screens and the like. The use of larger<br>
virtual screen images also allows the use of much higher resolution images than<br>
possible with more limited LCD screen displays. Other display devices could include,<br>
but are not limited to, small LCD screens or various flat panel display elements,<br>
projection lenses and display drivers for projecting images on a surface, and so forth.<br>
[00151] There may also be additional elements connected to or associated with the use<br>
of wireless device 102 or computer 100 for presenting an output to another user, or to<br>
another device which in turn transfers the signals elsewhere or stores them. For<br>
example, data may be stored in flash memory, in optical form, for example using a<br>
writeable CD media or on magnetic media such as in a magnetic tape recorder and<br>
similar devices, for later use.<br>
[00152] In addition, many wireless devices and computers now have built-in MP3<br>
music decoding capabilities, as well as other advanced sound decoders and systems.<br>
Portable computers utilize CD and DVD playback capabilities as a general rule, and<br>
some have small dedicated flash memory readers for receiving pre-recorded audio files.<br>
The issue with having such capabilities is that digital music files promise a highly<br>
increased feature rich experience, but only if the decoding and playback process can<br>
keep pace. The same holds true for the digital video files.<br>
[00153] To assist with sound reproduction, external speakers 114 are shown in FIG.<br>
1A, which could also be accompanied by addition elements such as sub-woofers, or<br>
"surround-sound" speakers for front and rear sound projection. At the same time,<br>
speakers or earphones 108 are indicated as built-in to the support frame or mechanism<br>
of micro-display device 106 of FIG. IB. As would be known, other audio or sound<br>
reproduction elements can be used including power amplification or sound shaping<br>
devices.<br>
[00154] In any case, as discussed above, when one desires to transfer high quality or<br>
high resolution image data and high quality audio information or data signals from a<br>
data source to an end user over one or more communication links 110, a high data rate is<br>
required. That is, transfer link 110 is clearly a potential bottleneck in the<br>
communication of data as discussed earlier, and is limiting system performance, since<br>
current transfer mechanisms do not achieve the high data rates typically desired. As<br>
discussed above for example, for higher image resolutions such as 1024 by 1024 pixels,<br>
with color depths of 24-32 bits per pixel and at data rates of 30 fps, the data rates can<br>
approach rates in excess of 755 Mbps or more. In addition, such images may be<br>
presented as part of a multimedia presentation which includes audio data and potentially<br>
additional signals dealing with interactive gaming or communications, or various<br>
commands, controls, or signals, further increasing the quantity or data and the data rate.<br>
[00155] It is also clear that fewer cables or interconnections required for establishing a<br>
data link, means that mobile devices associated with a display are easier to use, and<br>
more likely to be adopted by a larger user base. This is especially true where multiple<br>
devices are commonly used to establish a full audio-visual experience, and more<br>
especially as the quality level of the displays and audio output devices increases.<br>
 [00156] Another typical application related to many of the above and other<br>
improvements in video screens and other output or input devices can be seen in FIGS.<br>
1C and ID where a portable or laptop computer 130 and wireless telephone or PDA<br>
device 140 are shown communicating data with "internal" display devices 134 and 144,<br>
respectively, along with audio reproduction systems 136 and 146.<br>
[00157] In FIGS, 1C and ID, small cut-away sections of the overall electronic devices<br>
or products are used to show the location of one or more internal hosts and controllers in<br>
one portion of the device with a generalized communication link, here 138 and 148,<br>
respectively, connecting them to the video display elements or screens having the<br>
corresponding clients, across a rotating joint of some known type used throughout the<br>
electronics industry today. One can see that the amount of data involved in these<br>
transfers requires a large number of conductors to comprise links 138 and 148. It is<br>
estimated that such communication links are approaching 90 or more conductors in<br>
order to satisfy today's growing needs for utilizing advanced color and graphical<br>
interfaces, display elements, on such devices because of the types of parallel or other<br>
known interface techniques available for transferring such data.<br>
[00158] Unfortunately, the higher data rates exceed current technology available for<br>
transferring data. Both in terms of the raw amount of data needing to be transferred per<br>
unit time, and in terms of manufacturing reliable cost effective physical transfer<br>
mechanisms.<br>
[00159] What is needed is a technique, a structure, means or method, for transferring<br>
data at higher rates for the data transfer link or communication path between<br>
presentation elements and the data source, which allows for consistently low(er) power,<br>
light weight, and as simple and economical a cabling structure as possible. Applicants<br>
have developed a new technique, or method and apparatus, to achieve these and other<br>
goals to allow an array of mobile, portable, or even fixed location devices to transfer<br>
data to desired displays, micro-displays, or audio transfer elements, at very high data<br>
rates, while maintaining a desired low power consumption, and complexity.<br>
III. High Rate Digital Data Interface System Architecture<br>
[00160] In order to create and efficiently utilize a new device interface, a signal<br>
protocol and system architecture has been formulated that provides a very high data<br>
transfer rate using low power signals. The protocol is based on a packet and common<br>
frame structure, or structures linked together to form a protocol for communicating a<br>
pre-selected set of data or data types along with a command or operational structure<br>
imposed on the interface.<br>
A. Overview<br>
[00161] The devices connected by or communicating over the MDDI link are called the<br>
host and client, with the client typically being a display device of some type, although<br>
other output and input devices are contemplated. Data from the host to the display<br>
travels in the forward direction (referred to as forward traffic or link), and data from the<br>
client to the host travels in the reverse direction (reverse traffic or link), as enabled by<br>
the host. This is illustrated in the basic configuration shown in FIG. 2. In FIG. 2, a host<br>
202 is connected to a client 204 using a bi-directional communication channel 206<br>
which is illustrated as comprising a forward link 208 and a reverse link 210. However,<br>
these channels are formed by a common set of conductors whose data transfer is<br>
effectively switched between the forward or reverse link operations. This allows for<br>
greatly reduced numbers of conductors, immediately addressing one of the many<br>
problems faced with current approaches to high speed data transfer in low power<br>
environments such as for mobile electronic devices.<br>
[00162] As discussed elsewhere, the host comprises one of several types of devices that<br>
can benefit from using the present invention. For example, host 202 could be a portable<br>
computer in the form of a handheld, laptop, or similar mobile computing device. It<br>
could also be a Personal Data Assistant (PDA), a paging device, or one of many<br>
wireless telephones or modems. Alternatively, host 202 could be a portable<br>
entertainment or presentation device such as a portable DVD or CD player, or a game<br>
playing device.<br>
[00163] Furthermore, the host can reside as a host device or control element in a variety<br>
of other widely used or planned commercial products for which a high speed<br>
communication link is desired with a client. For example, a host could be used to<br>
transfer data at high rates from a video recording device to a storage based client for<br>
improved response, or to a high resolution larger screen for presentations. An appliance<br>
such as a refrigerator that incorporates an onboard inventory or computing system<br>
and/or Bluetooth connections to other household devices, can have improved display<br>
capabilities when operating in an internet or Bluetooth connected mode, or have reduced<br>
wiring needs for in-the-door displays (a client) and keypads or scanners (client) while<br>
the electronic computer or control systems (host) reside elsewhere in the cabinet. In<br>
general, those skilled in the ait will appreciate the wide variety of modern electronic<br>
devices and appliances that may benefit from the use of this interface, as well as the<br>
ability to retrofit older devices with higher data rate transport of information utilizing<br>
limited numbers of conductors available in either newly added or existing connectors or<br>
cables.<br>
[00164] At the same time, client 204 could comprise a variety of devices useful for<br>
presenting information to an end user, or presenting information from a user to the host.<br>
For example, a micro-display incorporated in goggles or glasses, a projection device<br>
built into a hat or helmet, a small screen or even holographic element built into a<br>
vehicle, such as in a window or windshield, or various speaker, headphone, or sound<br>
systems for presenting high quality sound or music. Other presentation devices include<br>
projectors or projection devices used to present information for meetings, or for movies<br>
and television images. Another example would be the use of touch pads or sensitive<br>
devices, voice recognition input devices, security scanners, and so forth that may be<br>
called upon to transfer a significant amount of information from a device or system user<br>
with little actual "input" other than touch or sound from the user. In addition docking<br>
stations for computers and car kits or desk-top kits and holders for wireless telephones<br>
may act as interface devices to end users or to other devices and equipment, and employ<br>
either clients (output or input devices such as mice) or hosts to assist in the transfer of<br>
data, especially where high speed networks are involved.<br>
[00165] However, those skilled in the art will readily recognize that the present<br>
invention is not limited to these devices, there being many other devices on the market,<br>
and proposed for use, that are intended to provide end users with high quality images<br>
and sound, either in terms of storage and transport or in terms of presentation at<br>
playback. The present invention is useful in increasing the data throughput between<br>
various elements or devices to accommodate the high data rates needed for realizing the<br>
desired user experience.<br>
[00166] The inventive MDD Interface and communication signal protocol may be used<br>
to simplify the interconnect between a host processor, controller, or circuit component<br>
(for example), and a display within a device or device housing or structure (referred to<br>
as an internal mode) in order to reduce the cost or complexity and associated power and<br>
control requirements or constraints of these connections, and to improve reliability, not<br>
just for connection to or for external elements, devices, or equipment (referred to as an<br>
external mode).<br>
2!<br>
[00167] The aggregate serial link data rate on each signal pair used by this interface<br>
structure can vary over many orders of magnitude, which allows a system or device<br>
designer to easily optimize cost, power, implementation complexity, and the display<br>
update rate for a given application or purpose. The attributes of MDDI are independent<br>
of display or other presentation device (target client) technology. The timing of data<br>
packets transferred through the interface can be easily adjusted to adapt to<br>
idiosyncrasies of particular clients such as display devices, sound systems, memory and<br>
control elements, or combined timing requirements of audio-video systems. While this<br>
makes it possible to have a system with a very small power consumption, it is not a<br>
requirement of the various clients to have frame buffers in order to make use of the<br>
MDDI protocol at least at some level.<br>
B. Interface Types<br>
[00168] The MDD Interface is contemplated as addressing at least fours, and<br>
potentially more, somewhat distinct physical types of interfaces found in the<br>
communications and computer industries. These are labeled simply as Type 1, Type 2,<br>
Type 3, and Type 4, although other labels or designations may be applied by those<br>
skilled in the art depending upon the specific applications they are used for or industry<br>
they are associated with. For example, simple audio systems use fewer connections<br>
than more complex multimedia systems, and may reference features such as "channels"<br>
differently, and so forth.<br>
[00169] The Type 1 interface is configured as a 6-wire, or other type of conductor or<br>
conductive element, interface which makes it suitable for mobile or wireless telephones,<br>
PDAs, electronic games, and portable media players, such as CD players, or MP3<br>
players, and similar devices or devices used on similar types of electronic consumer<br>
technology. In one embodiment, a an interface can be configured as an 8-wire<br>
(conductor) interface which is more suitable for laptop, notebook, or desktop personal<br>
computers and similar devices or applications, not requiring rapid data updates and<br>
which do not have a built-in MDDI link controller. This interface type is also<br>
distinguishable by the use of an additional two-wire Universal Serial Bus (USB)<br>
interface, which is extremely useful in accommodating existing operating systems or<br>
software support found on most personal computers.<br>
 [00170] Type 2, Type 3, and Type 4 interfaces are suitable for high performance clients<br>
or devices and use larger more complex cabling with additional twisted-pair type<br>
conductors to provide the appropriate shielding and low loss transfers for data signals.<br>
[00171] The Type 1 interface passes signals which can comprise display, audio,<br>
control, and limited signaling information, and is typically used for mobile clients or<br>
client devices that do not require high-resolution full-rate video data. A Type 1<br>
interface can easily support SVGA resolution at 30 fps plus 5.1 channel audio, and in a<br>
minimum configuration might use only three wire pairs total, two pairs for data<br>
transmission and one pair for power transfer. This type of interface is primarily<br>
intended for devices, such as mobile wireless devices, where a USB host is typically not<br>
available within the such device for connection and transfer of signals. In this<br>
configuration, the mobile wireless device is a MDDI host device, and acts as the<br>
"master" that controls the communication link from the host, which generally sends data<br>
to the client (forward traffic or link) for presentation, display or playback.<br>
[00172] In this interface, a host enables receipt of communication data at the host from<br>
the client (reverse traffic or link) by sending a special command or packet type to the<br>
client that allows it to take over the bus (link) for a specified duration and send data to<br>
the host as reverse packets. This is illustrated in FIG. 3, where a type of packet referred<br>
to as an encapsulation packet (discussed below) is used to accommodate the transfer of<br>
reverse packets over the transfer link, creating the reverse link. The time interval<br>
allocated for the host to poll the client for data is pre-determined by the host, and is<br>
based on the requirements of each specified application. This type of half-duplex bidirectional<br>
data transfer is especially advantageous where a USB port is not available<br>
for transfer of information or data from the client.<br>
[00173] High-performance displays capable of HDTV type or similar high resolutions<br>
require around 1.5 Gbps rate data streams in order to support full-motion video. The<br>
Type 2 interface supports high data rates by transmitting 2 bits in parallel, the Type 3 by<br>
transmitting 4 bits in parallel, and the Type 4 interface transfers 8 bits in parallel. Type<br>
2 and Type 3 interfaces use the same cable and connector as Type 1 but can operate at<br>
twice and four times the data rate to support higher-performance video applications on<br>
portable devices. A Type 4 interface is suited for very high performance clients or<br>
displays and requires a slightly larger cable that contains additional twisted-pair data<br>
signals.<br>
 [00174] The protocol used by the MDDI allows each Type 1, 2, 3, or 4 host to<br>
generally communicate with any Type 1, 2, 3, or 4 client by negotiating what is the<br>
highest data rate possible that can be used. The capabilities or available features of<br>
what can be referred to as the least capable device is used to set the performance of the<br>
link. As a rule, even for systems where the host and client are both capable using Type<br>
2, Type 3, or Type 4 interfaces, both begin operation as a Type 1 interface. The host<br>
then determines the capability of the target client, and negotiates a hand-off or<br>
reconfiguration operation to either Type 2, Type 3, or Type 4 mode, as appropriate for<br>
the particular application.<br>
[00175] It is generally possible for the host to use the proper link-layer protocol<br>
(discussed further below) and step down or again reconfigure operation at generally any<br>
time to a slower mode to save power or to step up to a faster mode to support higher<br>
speed transfers, such as for higher resolution display content. For example, a host may<br>
change interface types when the system switches from a power source such as a battery<br>
to AC power, or when the source of the display media switches to a lower or higher<br>
resolution format, or a combination of these or other conditions or events may be<br>
considered as a basis for changing an interface type, or transfer mode.<br>
[00176] It is also possible for a system to communicate data using one mode in one<br>
direction and another mode in another direction. For example, a Type 4 interface mode<br>
could be used to transfer data to a display at a high rate, while a Type 1 mode is used<br>
when transferring data to a host device from peripheral devices such as a keyboard or a<br>
pointing device. It will be appreciated by one skilled in the art that hosts and clients<br>
may communicate outgoing data at different rates.<br>
[00177] Often, users of the MDDI protocol may distinguish between an "external"<br>
mode and an "internal" mode. An external mode describes the use of the protocol and<br>
interface to connect a host in one device to a client outside of that device that is up to<br>
about 2 meters or so from the host. In this situation, the host may also send power to<br>
the external client so that both devices can easily operate in a mobile environment. An<br>
internal mode describes when the host is connected to a client contained inside the same<br>
device, such as within a common housing or support frame or structure of some kind.<br>
An example would be applications within a wireless phone or other wireless device, or a<br>
portable computer or gaming device where the client is a display or display driver, or an<br>
input device such as a keypad or touch-pad, or a sound system, and the host is a central<br>
controller, graphics engine, or CPU element. Since a client is located much closer to the<br>
host in internal mode applications as opposed to external mode applications, there are<br>
generally no requirements discussed for the power connection to the client in such<br>
configurations.<br>
C. Physical Interface Structure<br>
[00178] The general disposition of a device or link controller for establishing<br>
communications between host and client devices is shown in FIGS. 4 and 5. In FIGS. 4<br>
and 5, a MDDI link controller 402 and 502 is shown installed in a host device 202 and a<br>
MDDI link controller 404 and 504 is shown installed in a client device 204. As before,<br>
host 202 is connected to a client 204 using a bi-directional communication channel 406<br>
comprising a series of conductors. As discussed below, both the host and client link<br>
controllers can be manufactured as an integrated circuit using a single circuit design that<br>
can be set, adjusted, or programmed to respond as either a host controller (driver) or a<br>
client controller (receiver). This provides for lower costs due to larger scale<br>
manufacturing of a single circuit device.<br>
[00179] In FIG. 5, a MDDI link controller 502 is shown installed in a host device 202'<br>
and a MDDI link controller 504 is shown installed in a client device 204'. As before,<br>
host 202' is connected to a client 204' using a bi-directional communication channel 506<br>
comprising a series of conductors. As discussed before, both the host and client link<br>
controllers can be manufactured using a single circuit design.<br>
[00180] Signals passed between a host and a client, such as a display device, over the<br>
MDDI link, or the physical conductors used, are also illustrated in FIGS. 4 and 5. As<br>
seen in FIGS. 4 and 5, the primary path or mechanism for transferring data through the<br>
MDDI uses data signals labeled as MDDI_DataO+/- and MDDI_Stb+/-. Each of these<br>
are low voltage data signals that are transferred over a differential pair of wires in a<br>
cable. There is only one transition on either the MDDI_DataO pair or the MDDI_Stb<br>
pair for each bit sent over the interface. This is a voltage based transfer mechanism not<br>
current based, so static current consumption is nearly zero. The host drives the<br>
MDDIjStb signals to the client display.<br>
[00181] While data can flow in both the forward and reverse directions over the<br>
MDDI__Data pairs, that is, it is a bi-directional transfer path, the host is the master or<br>
controller of the data link. The MDDI_DataO and MDDI-Stb signal paths are operated<br>
in a differential mode to maximize noise immunity. The data rate for signals on these<br>
lines is determined by the rate of the clock sent by the host, and is variable over a range<br>
of about 1 kbps up to 400 Mbps or more.<br>
[00182] The Type 2 interface contains one additional data pair or conductors or paths<br>
beyond that of the Type 1, referred to as MDDI_Datall+/-. The Type 3 interface<br>
contains two additional data pairs or signal paths beyond that of the Type 2 interface<br>
referred to as MDDI_Data2W-, and MDDIJData3+/-. The Type 4 interface contains<br>
four more data pairs or signal paths beyond that of the Type 3 interface referred to as:<br>
MDDI_data4W-, MDDI_Data5+/-, MDDL.Data6+/-, and MDDI_Data7+/-,<br>
respectively. In each of the above interface configurations, a host can send power to the<br>
client or display using the wire-pair or signals designated as HOST_Pwr and<br>
HOST_Gnd. As discussed further below, power transfer can also be accommodated, if<br>
desired, in some configurations on the MDDI_data4+/-, MDDI_Data5+/-,<br>
MDDI_Data6+/-, or MDDI_Data7+/- conductors when an interface "Type" is being<br>
used that employs fewer conductors than are available or present for the other modes.<br>
This Power transfer is generally employed for external modes, there generally being no<br>
need for internal modes, although some applications may differ.<br>
[00183] A summary of the signals passed between the host and client (display) over the<br>
MDDI link for various modes are illustrated in Table I, below, in accordance with the<br>
interface type.<br>
(Table Removed)    [00184] Also note that the HOST_Pwr/Gnd connections for transfer from the host are<br>
provided generally for external modes. Internal applications or modes of operation<br>
generally have clients that draw power directly from other internal resources, and do not<br>
use MDDI to control power distribution, as would be apparent to one skilled in the art,<br>
so such distribution is not discussed in further detail here. However, it is certainly<br>
possible to allow power to be distributed through the MDDI interface to allow for<br>
certain kinds of power control, synchronization, or interconnection convenience, for<br>
example, as would be understood by one skilled in the art.<br>
[00185] Cabling generally used to implement the above structure and operation is<br>
nominally on the order of 1.5 meters in length, generally 2 meters or less, and contains<br>
three twisted pairs of conductors, each in turn being multi-strand 30 AWG wire. A foil<br>
shield covering is wrapped or otherwise formed above the three twisted pairs, as an<br>
additional drain wire. The twisted pairs and shield drain conductor terminate in the<br>
client connector with the shield connected to the shield for the client, and there is an<br>
insulating layer, covering the entire cable, as would be well known in the art. The wires<br>
are paired as: HOST_Gnd with HOST_Pwr; MDDI_Stb+ with MDDI_Stb-;<br>
MDDI_DataO+ with MDDI_DataO-; MDDI_Datal+ with MDDI_Datal~; and so forth.<br>
However, a variety of conductors and cabling can be used, as would be understood in<br>
the ait, to implement the embodiments of the invention, depending upon specific<br>
applications. For example, heavier outside coatings or even metallic layers may be used<br>
to protect the cable in some applications, while thinner, flatter conductive ribbon type<br>
structures may be well suited to other applications.<br>
D. Data Types and Rates<br>
[00186] To achieve a useful interface for a full range of user experiences and<br>
applications, the Mobile Digital Data Interface (MDDI) provides support for a variety of<br>
clients and display information, audio transducers, keyboards, pointing devices, and<br>
many other input or output devices that might be integrated into or working in concert<br>
with a mobile display device, along with control information, and combinations thereof.<br>
The MDD interface is designed to be able to accommodate a variety of potential types<br>
of streams of data traversing between the host and client in either the forward or reverse<br>
link directions using a minimum number of cables or conductors. Both isochronous<br>
streams and asynchronous stream (updates) are supported. Many combinations of data<br>
types are possible as long as the aggregate data rate is less than or equal to the<br>
maximum desired MDDI link rate, which is limited by the maximum serial rate and<br>
number of data airs employed. These could include, but are not limited to, those items<br>
(Table Removed)    listed in Tables II and HI below.<br>
((Table Removed)    <br>
[00187] The interface is not fixed but extensible so that it can support the transfer of a<br>
variety of information "types" which includes user-defined data, for future system<br>
flexibility. Specific examples of data to be accommodated are: full-motion video,<br>
either in the form of full or partial screen bitmap fields or compressed video; static<br>
bitmaps at low rates to conserve power and reduce implementation costs; PCM or<br>
compressed audio data at a variety of resolutions or rates; pointing device position and<br>
selection, and user-definable data for capabilities yet to be defined. Such data may also<br>
be transferred along with control or status information to detect device capability or set<br>
operating parameters.<br>
[00188] Embodiments of the invention advance the art for use in data transfers that<br>
include, but are not limited to: watching a movie (video display and audio); using a<br>
personal computer with limited personal viewing (graphics display, sometimes<br>
combined with video and audio); playing a video game on a PC, console, or personal<br>
device (motion graphics display, or synthetic video and audio); "surfing" the Internet,<br>
using devices in the form of a video phone (bi-directional low-rate video and audio), a<br>
camera for still digital pictures, or a camcorder for capturing digital video images; using<br>
a phone, computer, or PDA docked with a projector to give a presentation or docked<br>
with a desktop docking station connected to a video monitor, keyboard, and mouse; and<br>
for productivity enhancement or entertainment use with cell phones, smart phones, or<br>
PDAs, including wireless pointing devices and keyboard data.<br>
[00189] The high speed data interface as discussed below is presented in terms of<br>
providing large amounts of A-V type data over a communication or transfer link which<br>
is generally configured as a wire-line or cable type link. However, it will be readily<br>
apparent that the signal structure, protocols, timing, or transfer mechanism could be<br>
adjusted to provide a link in the form of an optical or wireless media, if it can sustain<br>
the desired level of data transfer.<br>
[00190] The MDD interface signals use a concept known as the Common Frame Rate<br>
(CFR) for the basic signal protocol or structure. The idea behind using of a Common<br>
Frame Rate is to provide a synchronization pulse for simultaneous isochronous data<br>
streams. A client device can use this common frame rate as a time reference. A low CF<br>
rate increases channel efficiency by decreasing overhead to transmit the sub-frame<br>
header. On the other hand, a high CF rate decreases the latency, and allows a smaller<br>
elastic data buffer for audio samples. The CF rate of the present inventive interface is<br>
dynamically programmable and may be set at one of many values that are appropriate<br>
for the isochronous streams used in a particular application. That is, the CF value is<br>
selected to best suit the given client and host configuration, as desired.<br>
[00191] The number of bytes generally required per sub-frame, which is adjustable or<br>
programmable, for isochronous data steams that are most likely to be used with an<br>
application, such as for a video or micro-display are shown in Table IV.<br>
(Table Removed)    [00192] Fractional counts of bytes per sub-frame are easily obtained using a simple<br>
programmable M/N counter structure. For example, a count of 26-2/3 bytes per CF is<br>
implemented by transferring 2 frames of 27 bytes each followed by one sub-frame of 26<br>
bytes. A smaller CF rate may be selected to produce an integer number of bytes per<br>
sub-frame. However, generally speaking, to implement a simple M/N counter in<br>
hardware should require less area within an integrated circuit chip or electronic module<br>
used to implement part or all of embodiments of the invention than the area needed for a<br>
larger audio sample FIFO buffer.<br>
[00193] An exemplary application that illustrates the impact of different data transfer<br>
rates and data types is a Karaoke system. For Karaoke, a system where an end user, or<br>
users, sings along with a music video program. Lyrics of the song are displayed<br>
somewhere on, typically at the bottom of, a screen so the user knows the words to be<br>
sung, and roughly the timing of the song. This application requires a video display with<br>
infrequent graphics updates, and mixing of the user's voice, or voices, with a stereo<br>
audio stream.<br>
[00194] If one assumes a common frame rate of 300 Hz, then each sub-frame will<br>
consist of: 92,160 bytes of video content and 588 bytes of audio content (based on 147<br>
16-bit samples, in stereo) over the forward link to the client display device, and an<br>
average of 26.67 (26-2/3) bytes of voice are sent back from a microphone to the mobile<br>
Karaoke machine. Asynchronous packets are sent between the host and the display,<br>
possibly head mounted. This includes at most 768 bytes of graphics data (quarterscreen<br>
height), and less than about 200 bytes (several) bytes for miscellaneous control<br>
and status commands.<br>
[00195] Table V, shows how data is allocated within a sub-frame for the Karaoke<br>
example. The total rate being used is selected to be about 279 Mbps. A slightly higher<br>
rate of 280 Mbps allows about another 400 bytes of data per sub-frame to be transferred<br>
which allows the use of occasional control and status messages.<br>
(Table Removed)    III.(Continued) High Rate Digital Data Interface System Architecture<br>
E. Link Layer<br>
[00196] Data transferred using the MOD interface high-speed serial data signals<br>
consists of a stream of time-multiplexed packets that are linked one after the other.<br>
Even when a transmitting device has no data to send, a MDDI link controller generally<br>
automatically sends filler packets, thus, maintaining a stream of packets. The use of a<br>
simple packet structure ensures reliable isochronous timing for video and audio signals<br>
or data streams.<br>
[00197] Groups of packets are contained within signal elements or structures referred to<br>
as sub-frames, and groups of sub-frames are contained within signal elements or<br>
structures referred to as a media-frame. A sub-frame contains one or more packets,<br>
depending on their respective size and data transfer uses, and a media-frame contains<br>
one more sub-frames. The largest sub-frame provided by the protocol employed by the<br>
embodiments presented here is on the order of 232-l or 4,294,967,295 bytes, and the<br>
largest media-frame size then becomes on the order of 216-1 or 65,535 sub-frames.<br>
[00198] A special sub-frame header packet contains a unique identifier that appears at<br>
the beginning of each sub-frame, as is discussed below. That identifier is also used for<br>
acquiring the frame timing at the client device when communication between the host<br>
and client is initiated. Link timing acquisition is discussed in more detail below.<br>
[00199] Typically, a display screen is updated once per media-frame when full-motion<br>
video is being displayed. The display frame rate is the same as the media-frame rate.<br>
The link protocol supports full-motion video over an entire display, or just a small<br>
region of full-motion video content surrounded by a static image, depending on the<br>
desired application. In some low-power mobile applications, such as viewing web<br>
pages or email, the display screen may only need to be updated occasionally. In those<br>
situations, it is advantageous to transmit a single sub-frame and then shut down or<br>
inactivate the link to minimize power consumption. The interface also supports effects<br>
such as stereo vision, and handles graphics primitives.<br>
[00200] Sub-frames allow a system to enable the transmission of high-priority packets<br>
on a periodic basis. This allows simultaneous isochronous streams to co-exist with a<br>
minimal amount of data buffering. This is one advantage embodiments provide to the<br>
display process, allowing multiple data streams (high speed communication of video,<br>
voice, control, status, pointing device data, etc.) to essentially share a common channel.<br>
It transfers information using relatively few signals. It also enables display-technologyspecific<br>
actions to exist, such as horizontal sync pulses and blanking intervals for a CRT<br>
monitor, or for other client-technology-specific actions.<br>
F. Link Controller<br>
[00201] The MDDI link controller shown in FIGS. 4 and 5 is manufactured or<br>
assembled to be a completely digital implementation with the exception of the<br>
differential line receivers which are used to receive MDDI data and strobe signals.<br>
However, even the differential line drivers and receivers can be implemented in the<br>
same digital integrated circuits with the link controller, such as when making a CMOS<br>
type 1C. No analog functions or phase lock loops (PLLs) are required for bit recovery<br>
or to implement the hardware for the link controller. The host and client link controllers<br>
contain very similar functions, with the exception of the client interface which contains<br>
a state machine for link synchronization. Therefore, the embodiments of the invention<br>
allow the practical advantage of being able to create a single controller design or circuit<br>
that can be configured as either a host or client, which can reduce manufacturing costs<br>
for the link controllers, as a whole.<br>
IV. Interface Link Protocol<br>
A. Frame structure<br>
[00202] The signal protocol or frame structure used to implement the forward link<br>
communication for packet transfer is illustrated in FIG. 6. As shown in FIG. 6,<br>
information or digital data is grouped into elements known as packets. Multiple packets<br>
are in turn grouped together to form what are referred to as a "sub-frame," and multiple<br>
sub-frames are in turn grouped together to form a "media" frame. To control the<br>
formation of frames and transfer of sub-frames, each sub-frame begins with a specially<br>
predefined packet referred to as a Sub-frame Header Packet (SHP).<br>
[00203] The host device selects the data rate to be used for a given transfer. This rate<br>
can be changed dynamically by the host device based on both the maximum transfer<br>
capability of the host, or the data being retrieved from a source by the host, and the<br>
maximum capability of the client, or other device the data is being transferred to.<br>
[00204] A recipient client device designed for, or capable of, working with the MDDI<br>
or inventive signal protocol is able to be queried by the host to determine the maximum,<br>
or current maximum, data transfer rate it can use, or a default slower minimum rate may<br>
be used, as well as useable data types and features supported. This information could be<br>
transferred using a Client Capability Packet (DCP), as discussed further below. The<br>
client display device is capable of transferring data or communicating with other<br>
devices using the interface at a pre-selected minimum data rate or within a minimum<br>
data rate range, and the host will perform a query using a data rate within this range to<br>
determine the full capabilities of the client devices.<br>
[00205] Other status information defining the nature of the bitmap and video frame-rate<br>
capabilities of the client can be transferred in a status packet to the host so that the host<br>
can configure the interface to be as efficient or optimal as practical, or desired within<br>
any system constraints.<br>
[00206] The host sends filler packets when there are no (more) data packets to be<br>
transferred in the present sub-frame, or when the host cannot transfer at a rate sufficient<br>
to keep pace with the data transmission rate chosen for the forward link. Since each<br>
sub-frame begins with a sub-frame header packet, the end of the previous sub-frame<br>
contains a packet (most likely a filler packet) the exactly fills the previous sub-frame.<br>
In the case of a lack of room for data bearing packets per se, a filler packet will most<br>
likely be the last packet in a sub-frame, or at the end of a next previous sub-frame and<br>
before a sub-frame header packet. It is the task of the control operations in a host<br>
device to ensure that there is sufficient space remaining in a sub-frame for each packet<br>
to be transmitted within that sub-frame. At the same time, once a host device initiates<br>
the sending of a data packet, the host must be able to successfully complete a packet of<br>
that size within a frame without incurring a data under-run condition.<br>
 [00207] In one aspect of embodiments, sub-frame transmission has two modes. One<br>
mode is a periodic sub-frame mode, or periodic timing epochs, used to transmit live<br>
video and audio streams. In this mode, the Sub-frame length is defined as being nonzero.<br>
The second mode is an asynchronous or non-periodic mode in which frames are<br>
used to provide bitmap data to a client when new information is available. This mode is<br>
defined by setting the sub-frame length to zero in the Sub-frame Header Packet. When<br>
using the periodic mode, sub-frame packet reception may commence when the client<br>
has synchronized to the forward link frame structure. This corresponds to the "in sync"<br>
states defined according to the state diagram discussed below with respect to FIG. 49 or<br>
FIG. 63. In the asynchronous non-periodic sub-frame mode, reception commences after<br>
the first Sub-frame Header packet is received.<br>
B. Overall Packet Structure<br>
[00208] The format or structure of packets used to formulate the communication or<br>
signal protocol, or method or means for transferring data, implemented by the<br>
embodiments are presented below, keeping in mind that the interface is extensible and<br>
additional packet structures can be added as desired. The packets are labeled as, or<br>
divided into, different "packet types" in terms of their function in the interface, that is,<br>
commands, information, value, or data they transfer or are associated with. Therefore,<br>
each packet type denotes a pre-defined packet structure for a given packet which is used<br>
in manipulating the packets and data being transferred. As will be readily apparent, the<br>
packets may have pre-selected lengths or have variable or dynamically changeable<br>
lengths depending on their respective functions. The packets could also bear differing<br>
names, although the same function is still realized, as can occur when protocols are<br>
changed during acceptance into a standard. The bytes or byte values used in the various<br>
packets are configured as multi-bit (8- or 16-bit) unsigned integers. A summary of the<br>
packets being employed along with their "type" designations, listed in type order, is<br>
shown in Tables VI-1 through VI-4.<br>
[00209] Each table represents a general "type" of packet within the overall packet<br>
structure for ease in illustration and understanding. There is no limitation or other<br>
impact implied or being expressed for the invention by these groupings, and the packets<br>
can be organized in many other fashions as desired. The direction in which transfer of a<br>
packet is considered valid is also noted.<br>
(Table Removed)    [00210] Something that is clear from other discussions within this text is that while the<br>
Reverse Encapsulation Packet, Client Capability Packet, and Client Request and Status<br>
Packet are each considered very important to, or even required in many embodiments of<br>
communication interfaces, for External Mode operation, while they can be or are more<br>
likely to be considered optional for Internal Mode operation. This creates yet another<br>
type of MDD Interface protocol which allows communication of data at very high<br>
speeds with a reduced set of communications packets, and corresponding simplification<br>
of control and timing.<br>
[00211] Packets have a common basic structure or overall set of minimum fields<br>
comprising a Packet Length field, a Packet Type field, Data Bytes field(s), and a CRC<br>
field, which is illustrated in FIG. 7. As shown in FIG. 7, the Packet Length field<br>
contains information, in the form of a multi-bit or -byte value, that specifies the total<br>
number of bits in the packet, or its length between the packet length field and the CRC<br>
field. In one embodiment, the packet length field contains a 16-bit or 2-byte wide,<br>
unsigned integer, that specifies the packet length. The Packet Type field is another<br>
multi-bit field which designates the type of information that is contained within the<br>
packet. In an exemplary embodiment, this is an 16-bit or 2-byte wide value, in the form<br>
of an 16-bit unsigned integer, and specifies such data types as display capabilities,<br>
handoff, video or audio streams, status, and so forth.<br>
[00212] A third field is the Data Bytes field, which contains the bits or data being<br>
transferred or sent between the host and client devices as part of that packet. The format<br>
of the data is defined specifically for each packet type according to the specific type of<br>
data being transferred, and may be separated into a series of additional fields, each with<br>
its own format requirements. That is, each packet type will have a defined format for<br>
this portion or field. The last field is the CRC field which contains the results of a 16-<br>
bit cyclic redundancy check calculated over the Data Bytes, Packet Type, and Packet<br>
Length fields, which is used to confirm the integrity of the information in the packet. In<br>
other words, calculated over the entire packet except for the CRC field itself. The client<br>
generally keeps a total count of the CRC errors detected, and reports this count back to<br>
the host in the Client Request and Status Packet (see further below).<br>
[00213] Generally, these field widths and organization are designed to keep 2-byte<br>
fields aligned on an even byte boundary, and 4-byte fields aligned on 4-byte boundaries.<br>
This allows packet structures to be easily built in a main memory space of, or associated<br>
with, a host and a client without violating the data-type alignment rules encountered for<br>
most or typically used processors or control circuits.<br>
[00214] During transfer of the packets, fields are transmitted starting with the Least<br>
Significant Bit (LSB) first and ending with the Most Significant Bit (MSB) transmitted<br>
last. Parameters that are more than one byte in length are transmitted using the least<br>
significant byte first, which results in the same bit transmission pattern being used for a<br>
parameter greater than 8 bits in length, as is used for a shorter parameter where the LSB<br>
is transmitted first. The data fields of each packet are generally transmitted in the order<br>
that they are defined in the subsequent sections below, with the first field listed being<br>
transmitted first, and the last field described being transmitted last. The data on the<br>
MDDLDataO signal path is aligned with bit '0' of bytes transmitted on the interface in<br>
any of the modes, Type 1, Type 2, Type 3, or Type~4.<br>
[00215] When manipulating data for displays, the data for arrays of pixels are<br>
transmitted by rows first, then columns, as is traditionally done in the electronics arts.<br>
In other words, all pixels that appear in the same row in a bit map are transmitted in<br>
order with the left-most pixel transmitted first and the right-most pixel transmitted last.<br>
After the right-most pixel of a row is transmitted then the next pixel in the sequence is<br>
the left-most pixel of the following row. Rows of pixels are generally transmitted in<br>
order from top to bottom for most displays, although other configurations can be<br>
accommodated as needed. Furthermore, in handling bitmaps, the conventional<br>
approach, which is followed here, is to define a reference point by labeling the upperleft<br>
corner of a bitmap as location or offset "0,0." The X and Y coordinates used to<br>
define or determine a position in the bitmap increase in value as one approaches the<br>
right and bottom of the bitmap, respectively. The first row and first column (upper left<br>
comer of an image) start with an index value of zero. The magnitude of the X<br>
coordinate increases toward the right side of the image, and the magnitude of the Y<br>
coordinate increases toward the bottom of the image as viewed by the user of the<br>
display.<br>
[00216] A display window is the visible portion of a bitmap, the portion of the pixels in<br>
the bitmap that can be seen by the user on the physical display medium. It is often the<br>
case that the display window and the bitmap are the same size. The upper-left corner of<br>
a display window always displays bitmap pixel location '0,0'. The width of the display<br>
window corresponds to the X axis of the bitmap, and the display window width for this<br>
embodiment is less than or equal to the width of the corresponding bitmap. The height<br>
of the window corresponds to the Y axis of the bitmap, and the display window height<br>
for this embodiment is less than or equal to the height of the corresponding bitmap. The<br>
display window itself is not addressable in the protocol because it is only defined as the<br>
visible portion of a bitmap.<br>
[00217] The relationship between a bitmaps and display windows is well known in the<br>
computer, electronic art, Internet communication, and other electronics related arts.<br>
Therefore, no further discussion or illustration of these principles is provided here.<br>
C. Packet Definitions<br>
1. Sub-Frame Header Packet<br>
[00218] The Sub-Frame Header packet is the first packet of every sub-frame, and has a<br>
basic structure as illustrated in FIG. 8. The Sub-Frame Header Packet is used for hostclient<br>
synchronization, every host should be able to generate this packet, while every<br>
client should be able to receive and interpret this packet. As can be seen in one<br>
embodiment in FIG. 8, this type of packet is structured to have Packet Length, Packet<br>
Type, Unique Word, Reserved 1, Sub-Frame Length, Protocol Version, Sub-Frame<br>
Count, and Media-frame Count fields, generally in that order. In one embodiment, this<br>
type of packet is generally identified as a Type 15359 (Ox3bff hexadecimal) packet and<br>
uses a pre-selected fixed length of 20 bytes, not including the packet length field.<br>
[00219] The Packet Type field and the Unique Word field each use a 2 byte value (16-<br>
bit unsigned integer). The 4-byte combination of these two fields together forms a 32-<br>
bit unique word with good autocorrelation. In one embodiment, the actual unique word<br>
is Ox005a3bff, where the lower 16 bits are transmitted first as the Packet Type, and the<br>
most significant 16 bits are transmitted afterward.<br>
[00220] The Reserved 1 field contains 2 bytes that are reserved space for future use,<br>
and is generally configured at this point with all bits set to zero. One purpose of this<br>
field is to cause subsequent 2-byte fields to align to a 16-bit word address and cause 4-<br>
byte fields to align to a 32-bit word address. The least significant byte is reserved to<br>
indicate whether or not a host is capable of addressing multiple client devices. A value<br>
of zero for this byte is reserved to indicate that the host is capable of operating only<br>
with a single client device.<br>
[00221] The Sub-frame Length field contains 4 bytes of information, or values, that<br>
specifies the number of bytes per sub-frame. In one embodiment, the length of this field<br>
may be set equal to zero to indicate that only one sub-frame will be transmitted by the<br>
host before the link is shut down into an idle state. The value in this field can be<br>
dynamically changed "on-the-fly" when transitioning from one sub-frame to the next.<br>
This capability is useful in order to make minor timing adjustments in the sync pulses<br>
for accommodating isochronous data streams. If the CRC of the Sub-frame Header<br>
packet is not valid then the link controller should use the Sub-frame Length of the<br>
previous known-good Sub-frame Header packet to estimate the length of the current<br>
sub-frame,<br>
[00222] The Protocol Version field contains 2 bytes that specify the protocol version<br>
used by the host. The Protocol Version field may be set to '0' to specify the first or<br>
current version of the protocol as being used. This value will change over time as new<br>
versions are created, and is already being upgraded to a value of T for some version<br>
fields. Version values will probably or generally follow a current version number for an<br>
approved standards document which covers interfaces such as MDDI, as would be<br>
known.<br>
[00223] The Sub-frame Count field contains 2 bytes that specify a sequence number<br>
that indicates the number of sub-frames that have been transmitted since the beginning<br>
of the media-frame. The first sub-frame of the media-frame has a Sub-frame Count of<br>
zero. The last sub-frame of the media-frame has a value of n-1, where n is the number<br>
of sub-frames per media-frame. The value of the Sub-frame Count field is equal to the<br>
Sub-frame Count sent in the previous Sub-Frame packet plus 1, except for a first subframe<br>
of a media-frame which will have a count of zero. Note that if the Sub-frame<br>
Length is set equal to zero (indicating a non-periodic sub-frame) then the Sub-frame<br>
count is also set equal to zero.<br>
[00224] The Media-frame Count field contains 4 bytes (32-bit unsigned integer) that<br>
specify a sequence number that indicates the number of media-frames that have been<br>
transmitted since the beginning of the present media item or data being transferred. The<br>
first media-frame of a media item has a Media-frame Count of zero. The Media-frame<br>
Count increments just prior to the first sub-frame of each media-frame and wraps back<br>
to zero after the maximum Media-frame Count (for example, media-frame number<br>
23"1 = 4,294,967,295) is used. The Media-frame Count value may be reset generally at<br>
any time by the Host to suit the needs of an end application.<br>
2. Filler Packet<br>
[00225] A filler packet is a packet that is transferred to, or from, a client device when<br>
no other information is available to be sent on either the forward or reverse link. It is<br>
recommended that filler packets have a minimum length in order to allow maximum<br>
flexibility in sending other packets when required. At the very end of a sub-frame or a<br>
reverse link encapsulation packet (see below), a link controller sets the size of the filler<br>
packet to fill the remaining space to maintain packet integrity. The Filler Packet is<br>
useful to maintain timing on the link when the host or client have no information to send<br>
or exchange. Every host and client needs to be able to send and receive this packet to<br>
make effective use of the interface.<br>
[00226] An exemplary embodiment of the format and contents of a Filler Packet are<br>
shown in FIG. 9. As shown in FIG. 9, this type of packet is structured to have Packet<br>
Length, Packet Type, Filler Bytes, and CRC fields. In one embodiment, this type of<br>
packet is generally identified as a Type 0, which is indicated in the 2-byte Type field.<br>
The bits or bytes in the Filler Bytes field comprise a variable number of all zero bit<br>
values to allow the filler packet to be the desired length. The smallest filler packet<br>
contains no bytes in this field. That is, the packet consists of only the packet length,<br>
packet type, and CRC, and in one embodiment uses a pre-selected fixed length of 6<br>
bytes or a Packer Length value of 4. The CRC value is determined for all bytes in the<br>
packet including the Packet Length, which may be excluded in some other packet types.<br>
3. Video Stream Packet<br>
[00227] Video Stream Packets carry video data to update typically rectangular regions<br>
of a display device. The size of this region may be as small as a single pixel or as large<br>
as the entire display. There may be an almost unlimited number of streams displayed<br>
simultaneously, limited by system resources, because all context required to display a<br>
stream is contained within the Video Stream Packet. The format of one embodiment of<br>
a Video Stream Packet (Video Data Format Descriptor) is shown in FIG. 10. As seen in'<br>
FIG. 10, in one embodiment, this type of packet is structured to have Packet Length (2<br>
bytes), Packet Type, bClient ED, Video Data Descriptor, Pixel Display Attributes, X<br>
Left Edge, Y Top Edge, X Right Edge, Y Bottom Edge, X and Y Start, Pixel Count,<br>
Parameter CRC, Pixel Data, and Pixel Data CRC fields. This type of packet is generally<br>
identified as a Type 16, which is indicated in the 2-byte Type field. In one embodiment,<br>
a client indicates an ability to receive a Video Stream Packet using RGB, Monochrome,<br>
and Y Cr Cb Capability fields of the Client Capability Packet.<br>
[00228] In one embodiment, the bClient ID field contains 2 bytes of information that<br>
are reserved for a Client ID, Since this is a newly developed communications protocol<br>
actual client IDs are not yet known or sufficiently communicable. Therefore, the bits in<br>
this field are generally set equal to zero until such ID values are known, at which time<br>
the ID values can be inserted or used, as would be apparent to those skilled in the art.<br>
The same process will generally be true for the client ID fields discussed below.<br>
[00229] The common frame concept discussed above is an effective way to minimize<br>
the audio buffer size and decrease latency. However, for video data it may be necessary<br>
to spread the pixels of one video frame across multiple Video Stream Packets within a<br>
media-frame. It is also very likely that the pixels in a single Video Stream Packet will<br>
not exactly correspond to a perfect rectangular window on the display. For the<br>
exemplary video frame rate of 30 frames per second, there are 300 sub-frames per<br>
second, which results in 10 sub-frames per media-frame. If there are 480 rows of pixels<br>
in each frame, each Video Stream Packet in each sub-frame will contain 48 rows of<br>
pixels. In other situations, the Video Stream Packet might not contain an integer<br>
number of rows of pixels. This is true for other video frame sizes where the number of<br>
sub-frames per media-frame does not divide evenly into the number of rows (also<br>
known as video lines) per video frame. For efficient operation, each Video Stream<br>
Packet generally must contain an integer number of pixels, even though it might not<br>
contain an integer number of rows of pixels. This is important if pixels are more than<br>
one byte each, or if they are in a packed format as shown in FIG. 12.<br>
[00230] The format and contents employed for realizing the operation of an exemplary<br>
Video Data Descriptor field, as mentioned above, are shown in FIGS. 11A-11E. In<br>
FIGS. 11 A-HE, the Video Data Format Descriptor field contains 2 bytes in the form of<br>
a 16-bit unsigned integer that specifies the format of each pixel in the Pixel Data in the<br>
present stream in the present packet. It is possible that different Video Stream packets<br>
may use different pixel data formats, that is, use a different value in the Video Data<br>
Format Descriptor, and similarly, a stream (region of the display) may change its data<br>
format on-the-fly. The pixel data format should comply with at least one of the valid<br>
formats for the client as defined in the Client Capability Packet. The Video Data<br>
Format Descriptor defines the pixel format for the present packet only which does not<br>
imply that a constant format will continue to be used for the lifetime of a particular<br>
video stream.<br>
[00231] FIGS. 11A through 11D illustrate how the Video Data Format Descriptor is<br>
coded. As used in these figures, and in this embodiment, when bits [15:13] are equal to<br>
'000', as shown in FIG. 11 A, then the video data consists of an array of monochrome<br>
pixels where the number of bits per pixel is defined by bits 3 through 0 of the Video<br>
Data Format Descriptor word. Bits 11 through 4 are generally reserved for future use or<br>
applications and are set to zero in this situation. When bits [15:13] are instead equal to<br>
the values '001', as shown in FIG. 11B, then the video data consists of an array of color<br>
pixels that each specify a color through a color map (palette). In this situation, bits 5<br>
through 0 of the Video Data Format Descriptor word define the number of bits per<br>
pixel, and bits 11 through 6 are generally reserved for future use or applications and set<br>
equal to zero. When bits [15:13] are instead equal to the values '010', as shown in<br>
FIG. 11C, then the video data consists of an array of color pixels where the number of<br>
bits per pixel of red is defined by bits 11 through 8, the number of bits per pixel of green<br>
is defined by bits 7 through 4, and the number of bits per pixel of blue is defined by bits<br>
3 through 0. In this situation, the total number of bits in each pixel is the sum of the<br>
number of bits used for red, green, and blue.<br>
[00232] However, when bits [15:13] are instead equal to the values or string 'Oil', as<br>
shown in FIG. 1 ID, then the video data consists of an array of video data in 4:2:2<br>
YCbCr format with luminance and chrominance information, where the number of bits<br>
per pixel of luminance (Y) is defined by bits 11 through 8, the number of bits of the Cb<br>
component is defined by bits 7 through 4, and the number of bits of the Cr component is<br>
defined by bits 3 through 0. The total number of bits in each pixel is the sum of the<br>
number of bits used for red, green, and blue. The Cb and Cr components are sent at half<br>
the rate as Y. In addition, the video samples in the Pixel Data portion of this packet are<br>
organized as follows: Cbn, Yn, Crn, Yn+1, Cbn+2, Yn+2, Crn+2, Yn+3, ... where Cbn<br>
and Cm are associated with Yn and Yn+1, and Cbn+2 and Crn+2 are associated with<br>
Yn+2 and Yn+3, and so on.<br>
[00233] Yn, Yn+1, Yn+2 and Yn+3 are luminance values of four consecutive pixels in<br>
a single row from left to right. If there are an odd number of pixels in a row (X Right<br>
Edge - X Left Edge + 1) in the window referenced by the Video Stream Packet then the<br>
Y value corresponding to the last pixel in each row will be followed by the Cb value of<br>
the first pixel of the next row, and a Cr value is not sent for the last pixel in the row. It<br>
is recommended that windows using Y Cb Cr format have a width that is an even<br>
number of pixels. The Pixel Data in a packet should contain an even number of pixels.<br>
It may contain an odd or even number of pixels in the case where the last pixel of the<br>
Pixel Data corresponds to the last pixel of a row in the window specified in the Video<br>
Stream Packet header, i.e. when the X location of the last pixel in the Pixel Data is equal<br>
to X Right Edge.<br>
[00234] When bits [15:13] are instead equal to the values '100' then the video data<br>
consists of an array of Bayer pixels where the number of bits per pixel is defined by bits<br>
3 through 0 of the Video Data Format Descriptor word. The Pixel Group Pattern is<br>
defined by bits 5 and 4 as shown in FIG. HE. The order of pixel data may be<br>
horizontal or vertical, and the pixels in rows or columns may be sent in forward or<br>
backward order and is defined by bits 8 through 6. Bits 11 through 9 should be set to<br>
zero. The group of four pixels in the pixel group in the Bayer format resembles what is<br>
often referred to as a single pixel in some display technologies. However, one pixel in<br>
the Bayer format is only one of the four colored pixels of the pixel group mosaic pattern<br>
[00235] For all five formats shown in the figures, Bit 12, which is designated as "P",<br>
specifies whether or not the Pixel Data samples are packed, or byte-aligned pixel data.<br>
A value of '0' in this field indicates that each pixel in the Pixel Data field is byte-aligned<br>
with an MDD interface byte boundary. A value of 1' indicates that each pixel and each<br>
color within each pixel in the Pixel Data is packed up against the previous pixel or color<br>
within a pixel leaving no unused bits. The difference between Byte-Aligned and<br>
Packed Pixel data format is shown in more detail in FIG. 12, where one can clearly see<br>
that byte-aligned data may leave unused portions of the data sub-frame, as opposed to<br>
packed pixel format which does not.<br>
[00236] The first pixel in the first video stream packet of a media frame for a particular<br>
display window will go into the upper left corner of the stream window defined by an X<br>
Left Edge and a Y Top Edge, and the next pixel received is placed in the next pixel<br>
location in the same row, and so on. In this first packet of a media frame, the X start<br>
value will usually be equal to X Left Edge, and Y start value will usually be equal to Y<br>
Top Edge. In subsequent packets corresponding to the same screen window, the X and<br>
Y start values will usually be set to the pixel location in the screen window that would<br>
normally follow after the last pixel sent in the Video Stream Packet that was transmitted<br>
in the previous sub-frame.<br>
4. Audio Stream Packet<br>
[00237] The audio stream packets carry audio data to be played through the audio<br>
system of the client, or for a stand alone audio presentation device. Different audio data<br>
streams may be allocated for separate audio channels in a sound system, for example:<br>
left-front, right-front, center, left-rear, and right-rear, depending on the type of audio<br>
system being used. A full complement of audio channels is provided for headsets that<br>
contain enhanced spatial-acoustic signal processing. A client indicates an ability to<br>
receive an Audio Stream Packet using the Audio Channel Capability and Audio Sample<br>
Rate fields of the Client Capability Packet. The format of Audio Stream Packets is<br>
illustrated in FIG. 13.<br>
[00238] As shown in FIG. 13, this type of packet is structured in one embodiment to<br>
have Packet Length, Packet Type, bClient ID, Audio Channel ID, Reserved 1, Audio<br>
Sample Count, Bits Per Sample and Packing, Audio Sample Rate, Parameter CRC,<br>
Digital Audio Data, and Audio Data CRC fields. In one embodiment, this type of<br>
packet is generally identified as a Type 32 packet.<br>
[00239] The bClient ED field contains 2 bytes of information that are reserved for a<br>
Client ID, as used previously. The Reserved 1 field contains 2 bytes that is reserved for<br>
future use, and is generally configured at this point with all bits set to zero.<br>
[00240] The Bits Per Sample and Packing field contains 1 byte in the form of an 8-bit<br>
unsigned integer that specifies the packing format of audio data. The format generally<br>
employed is for Bits 4 through 0 to define the number of bits per PCM audio sample.<br>
Bit 5 then specifies whether or not the Digital Audio Data samples are packed. The<br>
difference between packed and byte-aligned audio samples, here using 10-bit samples,<br>
is illustrated in FIG. 14. A value of '0' indicates that each PCM audio sample in the<br>
Digital Audio Data field is byte-aligned with an MDDI interface byte boundary, and a<br>
value of T indicates that each successive PCM audio sample is packed up against the<br>
previous audio sample. This bit is generally effective only when the value defined in<br>
bits 4 through 0 (the number of bits per PCM audio sample) is not a multiple of eight.<br>
Bits 7 through 6 are reserved for future use and are generally set at a value of zero.<br>
5. Reserved Stream Packets<br>
[00241] In one embodiment, packet types 1 to 15, 18 to 31, and 33 through 55 are<br>
reserved for stream packets to be defined for use in future versions or variations of the<br>
packet protocols, as desired for various applications encountered. Again, this is part of<br>
making the MDD interface more flexible and useful in the face of ever changing<br>
technology and system designs as compared to other techniques.<br>
6. User-Defined Stream Packets<br>
[00242] Eight data stream types, known as Types 56 through 63, are reserved for use in<br>
proprietary applications that may be defined by equipment manufacturers for use with a<br>
MDDI link. These are known as User-defined Stream Packets. Such packets may be<br>
used for any purpose, but the host and client should only employ such packets in<br>
situations where the result of such use is very well understood or known. The specific<br>
definition of the stream parameters and data for these packet types is left to the specific<br>
equipment manufacturers or interface designers implementing such packet types or<br>
seeking their use. Some exemplary uses of the User-defined Stream Packets are to<br>
convey test parameters and test results, factory calibration data, and proprietary special<br>
use data. The format of the user-defined stream packets as used in one embodiment is<br>
illustrated in FIG. 15. As shown in FIG. 15, this type of packet is structured to have<br>
Packet Length (2 bytes), Packet Type, bClient ID number, Stream Parameters,<br>
Parameter CRC, Stream Data, and Stream Data CRC fields.<br>
7. Color Map Packets<br>
[00243] The color map packets specify the contents of a color map look-up table used<br>
to present colors for a client. Some applications may require a color map that is larger<br>
than the amount of data that can be transmitted in a single packet. In these cases,<br>
multiple Color Map packets may be transferred, each with a different subset of the color<br>
map by using the offset and length fields described below. The format of the Color<br>
Map Packet in one embodiment is illustrated in FIG. 16. As shown in FIG. 16, this type<br>
of packet is structured to have Packet Length, Packet Type, hClient ID, Color Map Item<br>
Count, Color Map Offset, Parameter CRC, Color Map Data, and Data CRC fields. In<br>
one embodiment, this type of packet is generally identified as a Type 64 packet (Video<br>
Data Format and Color Map Packet) as specified in the Packet Type Field (2 bytes). A<br>
client indicates an ability to receive Color Map Packets using the Color Map Size and<br>
Color Map Width fields of the Client Capability Packet.<br>
8. Reverse Link Encapsulation Packets<br>
[00244] In an exemplary embodiment, data is transferred in the reverse direction using<br>
a Reverse Link Encapsulation Packet. A forward link packet is sent and the MDDI link<br>
operation (transfer direction) is changed or turned around in the middle of this packet so<br>
that packets can be sent in the reverse direction. The format of the Reverse Link<br>
Encapsulation packet in one embodiment is illustrated in FIG. 17. As shown in FIG. 17,<br>
this type of packet is structured to have Packet Length, Packet Type, hCLient ID,<br>
Reverse Link Flags, Reverse Rate Divisor, Turn-Around 1 Length, Turn-Around 2<br>
Length, Parameter CRC, All Zero 1, Turn-Around 1, Reverse Data Packets, Turn-<br>
Around 2, and All Zero 2 fields. In one embodiment, this type of packet is generally<br>
identified as a Type 65 packet. For External Mode every host must be able to generate<br>
this packet and receive data, and every client must be able to receive and send data to<br>
the host. Implementation of this packet is optional for Internal Mode, but the Reverse<br>
Link Encapsulation Packet is used for the host to receive data from the client.<br>
[00245] The MDDI link controller behaves in a special manner while sending a<br>
Reverse Link Encapsulation Packet. The MDD interface has a strobe signal that is<br>
generally always driven by the host as controller of the link. The host behaves as if it<br>
were transmitting a zero for each bit of the Turn-Around and Reverse Data Packets<br>
portions of the Reverse Link Encapsulation packet. The host toggles a MDDI_Strobe<br>
signal at each bit boundary during the two turn-around times and during the time<br>
allocated for reverse data packets. (This is the same behavior as if it were transmitting<br>
all-zero data.)<br>
[00246] The host disables its MDDI data signal line drivers during the time period<br>
specified by Turn-Around 1, and the client re-enables its line drivers during the Driver<br>
Re-enable field following the time period specified by Turn-Around 2 field. The client<br>
reads the Turn-Around Length parameter and drives the data signals toward the host<br>
immediately after the last bit in the Turn-Around 1 field. That is, the client clocks new<br>
data into the link on certain rising edges of the MDDI strobe as specified in the packet<br>
contents description below, and elsewhere. The client uses the Packet Length and Turn-<br>
Around Length parameters to know the length of time it has available to send packets to<br>
the host. The client may send filler packets or drive the data lines to a zero state when it<br>
has no data to send to the host. If the data lines are driven to zero, the host interprets<br>
this as a packet with a zero length (not a valid length) and the host does not accept any<br>
more packets from the client for the duration of the current Reverse Link Encapsulation<br>
Packet.<br>
[00247] The Host drives the MDDI_Data signals to the logic-zero level during the All<br>
Zero 1 field, and a client drives the MDDI data lines to a logic-zero level for at least one<br>
reverse link clock period before the start of the Turn Around 2 field, that is during the<br>
All Zero 2 field period. This keeps the data lines in a deterministic state during the Turn<br>
Around 1 and Turn Around 2 fields time period. If the client has no more packets to<br>
send, it may even disable the data lines after driving them to a logic-zero level because<br>
the hibernation bias resistors (discussed elsewhere) keep the data lines at a logic-zero<br>
level for the remainder of the Reverse Data Packets field, or a duration of about 16<br>
forward link bytes or more.<br>
[00248] In one embodiment, the Reverse Link Request field of the Client Request and<br>
Status Packet may be used to inform the host of the number of bytes the client needs in<br>
the Reverse Link Encapsulation Packet to send data back to the host. The host attempts<br>
to grant the request by allocating at least that number of bytes in the Reverse Link<br>
Encapsulation Packet. The host may send more than one Reverse Link Encapsulation<br>
Packet in a sub-frame. The client may send a Client Request and Status Packet at<br>
almost any time, and the host will interpret the Reverse Link Request parameter as the<br>
total number of bytes requested in one sub-frame.<br>
9. Client Capability Packets<br>
[00249] A host needs to know the capability of the client (display) it is communicating<br>
with in order to configure the host-to-client link in an generally optimum or desired<br>
manner. It is recommended that a display send a Client Capability Packet to the host<br>
after forward link synchronization is acquired. The transmission of such a packet is<br>
considered required when requested by the host using the Reverse Link Flags in the<br>
Reverse Link Encapsulation Packet. The Client Capability Packet is used to inform the<br>
host of the capabilities of a client. For External Mode every host should be able to<br>
receive this packet, and every client should be able to send this packet to fully utilize<br>
this interface and protocol. Implementation of this packet is optional for Internal Mode,<br>
since the capabilities of the client, such as a display, keyboard or other input/output<br>
device, in this situation should already be well defined and known to the host at the time<br>
of manufacture or assembly into a single component or unit of some type.<br>
 [00250] The format of the Client Capability packet in one embodiment is illustrated in<br>
FIG. 18. As shown in FIG. 18, for this embodiment, this type of packet is structured to<br>
have Packet Length, Packet Type, reserved cClientID, Protocol Version, Min Protocol<br>
Version, Data Rate Capability, Interface Type Capability, Number of Alt Displays,<br>
Reserved 1, Bitmap Width, Bitmap Height, Display Window Width, Display Window<br>
Height. Color Map Size, Color Map RGB Width, RGB Capability, Monochrome<br>
Capability, Reserved 2, Y Cr Cb Capability, Bayer Capability, Alpha-Cursor Image<br>
Planes, Client Feature Capability, Max Video Frame Rate, Min Video Frame Rate, Min<br>
Sub-frame rate, Audio Buffer Depth, Audio Channel Capability, Audio Sample Rate<br>
Capability, Audio Sample Resolution, Mic Audio Sample Resolution, Mic Sample Rate<br>
Capability, Keyboard Data Format, Pointing Device Data Format, Content Protection<br>
Type, Mfr. Name, Product Code, Reserved 3, Serial Number, Week of Mfr., Year of<br>
Mfr., and CRC fields. In an exemplary embodiment, this type of packet is generally<br>
identified as a Type 66 packet.<br>
10. Keyboard Data Packets<br>
[00251] A keyboard data packet is used to send keyboard data from the client device to<br>
the host. A wireless (or wired) keyboard may be used in conjunction with various<br>
displays or audio devices, including, but not limited to, a head mounted video<br>
display/audio presentation device. The Keyboard Data Packet relays keyboard data<br>
received from one of several known keyboard-like devices to the host. This packet can<br>
also be used on the forward link to send data to the keyboard. A client indicates an<br>
ability to send and receive Keyboard Data Packets using the Keyboard Data Field in the<br>
Client Capability Packet.<br>
[00252] The format of a Keyboard Data Packet is shown in FIG. 19, and contains a<br>
variable number of bytes of information from or for a keyboard. As shown in FIG. 19,<br>
this type of packet is structured to have Packet Length, Packet Type, bClient ID,<br>
Keyboard Data Format, Keyboard Data, and CRC fields. Here, this type of packet is<br>
generally identified as a Type 67 packet.<br>
[00253] The bClient ID is a reserved field, as before, and the CRC is performed over all<br>
bytes of the packet. The Keyboard Data Format field contains a 2 bytes value that<br>
describes the keyboard data format. Bits 6 through 0 should be identical to the<br>
Keyboard Data Format field in the Client Capability Packet. This value is not to equal<br>
127. Bits 15 through 7 are reserved for future use and are, therefore, currently set to<br>
zero.<br>
11, Pointing Device Data Packets<br>
[00254] A pointing device data packet is used as a method, structure, or means to send<br>
position information from a wireless mouse or other pointing device from the client to<br>
the host. Data can also be sent to the pointing device on the forward link using this<br>
packet. An exemplary format of a Pointing Device Data Packet is shown in FIG. 20,<br>
and contains a variable number of bytes of information from or for a pointing device.<br>
As shown in FIG. 20, this type of packet is structured to have Packet Length, Packet<br>
Type, bClient ID, Pointing Device Format, Pointing Device Data, and CRC fields. In<br>
an exemplary embodiment, this type of packet is generally identified as a Type 68<br>
packet in the 1-byte type field.<br>
12. Link Shutdown Packets<br>
[00255] A Link Shutdown Packet is sent from the host to the client as a method or<br>
means to indicate that the MDDI data and strobe will be shut down and go into a lowpower<br>
consumption "hibernation" state. This packet is useful to shut down the link and<br>
conserve power after static bitmaps are sent from a mobile communication device to the<br>
display, or when there is no further information to transfer from a host to a client for the<br>
time being. Normal operation is resumed when the host sends packets again. The first<br>
packet sent after hibernation is a sub-frame header packet. The format of a Client Status<br>
Packet for one embodiment is shown in FIG. 21. As shown in FIG. 21, this type of<br>
packet is structured to have Packet Length, Packet Type, CRC and All Zeros fields. In<br>
one embodiment, this type of packet is generally identified as a Type 69 packet in the 1-<br>
byte type field, and uses a pre-selected fixed length of 3 bytes.<br>
[00256] In the low-power hibernation state, the MDDI_Data driver is disabled into a<br>
high-impedance state, and the MDDI_Data signals are pulled to a logic zero state using<br>
a high-impedance bias network that can be overdriven by the client. The strobe signal<br>
used by the interface is set to a logic-zero level in the hibernation state to minimize<br>
power consumption. Either the host or client may cause the MDDI link to "wake up"<br>
from the hibernation state as described elsewhere, which is a key advance for and<br>
advantage of the present invention.<br>
13. Client Request and Status Packets<br>
[00257] The host needs a small amount of information from the client so it can<br>
configure the host-to-client link in a generally optimum manner. It is recommended that<br>
the client send one Client Request and Status Packet to the host each sub-frame. The<br>
client should send this packet as the first packet in the Reverse Link Encapsulation<br>
Packet to ensure that it is delivered reliably to the host. The forwarding of this packet is<br>
also accomplished when requested by a host using the Reverse Link Flags in the<br>
Reverse Link Encapsulation Packet. The Client Request and Status Packet is used to<br>
report errors and status to the host. Every host should be able to receive this packet, and<br>
every client should be able to send this packet in order to properly or optimally employ<br>
the MDD Interface protocol.<br>
[00258] The format of a Client Request and Status Packet is shown in FIG. 22. As<br>
shown in FIG. 22, this type of packet is structured to have Packet Length, Packet Type,<br>
cClient ID, Reverse Link Request, Capability Change, Graphics Bugs, CRC Error<br>
Count, and CRC fields. This type of packet is generally identified as a Type 70 packet<br>
in the 1-byte type field, and typically uses a pre-selected fixed length of 12 bytes.<br>
[00259] The Reverse Link Request field may be used to inform the host of the number<br>
of bytes the client needs in the Reverse Link Encapsulation Packet to send data back to<br>
the host. The host should attempt to grant the request by allocating at least that number<br>
of bytes in the Reverse Link Encapsulation Packet. The host may send more than one<br>
Reverse Link Encapsulation Packet in a sub-frame in order to accommodate data. The<br>
client may send a Client Request and Status Packet at any time and the host will<br>
interpret the Reverse Link Request parameter as the total number of bytes requested in<br>
one sub-frame. Additional details and specific examples of how reverse link data is sent<br>
back to the host are shown below.<br>
14. Bit Block Transfer Packets<br>
[00260] The Bit Block Transfer Packet provides a means, structure, or method to scroll<br>
regions of the display in any direction. Displays that have this capability will report the<br>
capability in bit 0 of the Display Feature Capability Indicators field of the Client<br>
Capability Packet. The format for one embodiment of a Bit Block Transfer Packet is<br>
shown in FIG. 23. As shown in FIG. 23, this type of packet is structured to have Packet<br>
Length, Packet Type, hClient ID, Upper Left X Value, Upper Left Y Value, Window<br>
Width, Window Height, Window X Movement, Window Y Movement, and CRC fields.<br>
This type of packet is generally identified as a Type 71 packet, and in one embodiment<br>
uses a pre-selected fixed length of 15 bytes.<br>
[00261] The fields are used to specify the X and Y values of the coordinate of the upper<br>
left comer of the window to be moved, the width and height of the window to be<br>
moved, and the number of pixels that the window is to be moved horizontally, and<br>
vertically, respectively. Positive values for the latter two fields cause the window to be<br>
moved to the right, and down, and negative values cause movement to the left and up,<br>
respectively.<br>
15. Bitmap Area Fill Packets<br>
[00262] The Bitmap Area Fill Packet provides a means, structure, or method to easily<br>
initialize a region of the display to a single color. Displays that have this capability will<br>
report the capability in bit 1 of the Client Feature Capability Indicators field of the<br>
Client Capability Packet. One embodiment for the format of a Bitmap Area Fill Packet<br>
is shown in FIG. 24. As shown in FIG. 24, in this case this type of packet is structured<br>
to have Packet Length, Packet Type, h Client ID, Upper Left X Value, Upper Left Y<br>
Value, Window Width, Window Height, Data Format Descriptor, Pixel Area Fill Value,<br>
and CRC fields. This type of packet is generally identified as a Type 72 packet in the 1-<br>
byte type field, and uses a pre-selected fixed length of 17 bytes.<br>
16. Bitmap Pattern Fill Packets<br>
[00263] The Bitmap Pattern Fill Packet provides a means or structure to easily initialize<br>
a region of the display to a pre-selected pattern. Displays that have this capability will<br>
report the capability in bit 2 of the Client Feature Capability field of the Client<br>
Capability Packet. The upper left corner of the fill pattern is aligned with the upper left<br>
corner of the window to be filled, unless the horizontal or vertical pattern offset is nonzero.<br>
If the window to be filled is wider or taller than the fill pattern, then the pattern<br>
may repeated horizontally or vertically a number of times to fill the window. The right<br>
or bottom of the last repeated pattern is truncated as necessary. If the window is smaller<br>
than the fill pattern, then the right side or bottom of the fill pattern may be truncated to<br>
fit the window.<br>
[00264] If a horizontal pattern offset is non-zero, then the pixels between the left side of<br>
the window and the left side plus the horizontal pattern offset are filled with the rightmost<br>
pixels of the pattern. The horizontal pattern offset is to be less than the pattern<br>
width. Similarly, if a vertical pattern offset is non-zero, then the pixels between the top<br>
side of the window and the top of the side plus vertical pattern offset are filled with the<br>
lower-most pixels of the pattern. The vertical pattern offset is to be less than the pattern<br>
height.<br>
[00265] One embodiment for the format of a Bitmap Pattern Fill Packet is shown in<br>
FIG. 25. As shown in FIG. 25, this type of packet is structured to have Packet Length,<br>
Packet Type, h Client ED, Upper Left X Value, Upper Left Y Value, Window Width,<br>
Window Height, Pattern Width, Pattern Height, Horizontal Pattern Offset, Vertical<br>
Pattern Offset, Data Format Descriptor, Parameter CRC, Pattern Pixel Data, and Pixel<br>
Data CRC fields. In some embodiments, this type of packet is generally identified as a<br>
Type 73 packet in the 1-byte type field.<br>
17. Communication Link Data Channel Packets<br>
[00266] The Communication Link Data Channel Packet provides a structure, means, or<br>
method for a client with high-level computing capability, such as a PDA, to<br>
communicate with a wireless transceiver such as a cell phone or wireless data port<br>
device. In this situation, the MDDI link is acting as a convenient high-speed interface<br>
between the communication device and the computing device with the mobile display,<br>
where this packet transports data at a Data Link Layer of an operating system for the<br>
device. For example, this packet could be used if a web browser, email client, or an<br>
entire PDA were built into a mobile display. Displays that have this capability will<br>
report the capability in bit 3 of the Client Feature Capability field of the Client<br>
Capability Packet.<br>
[00267] The format of an embodiment for a Communication Link Data Channel Packet<br>
is shown in FIG. 26. As shown in FIG. 26, this type of packet is structured to have<br>
Packet Length, Packet Type, h Client ID, Parameter CRC, Communication Link Data,<br>
and Communication Data CRC fields. In one embodiment, this type of packet is<br>
generally identified as a Type 74 packet in the type field.<br>
18. Interface Type Handoff Request Packets<br>
[00268] The Interface Type Handoff Request Packet provides a means, method or<br>
structure that enables the host to request that the client or display shift from an existing<br>
or current mode to the Type 1 (serial), Type 2 (2-bit parallel), Type 3 (4-bit parallel), or<br>
Type 4 (8-bit parallel) modes. Before the host requests a particular mode it should<br>
confirm that the client is capable of operating in the desired mode by examining bits 6<br>
and 7 of the Display Feature Capability Indicators field of the Client Capability Packet.<br>
One embodiment for the format of a Interface Type Handoff Request Packet is shown in<br>
FIG. 27. As shown in FIG. 27, this type of packet is structured to have Packet Length,<br>
Packet Type, Interface Type, Reserved 1, and CRC fields. This type of packet is<br>
generally identified as a Type 75 packet, and uses a pre-selected fixed length of 4 bytes.<br>
19. Interface Type Acknowledge Packets<br>
[00269] The Interface Type Acknowledge Packet is sent by a client and provides a<br>
means, method or structure that enables a client to confirm receipt of the Interface Type<br>
Handoff Packet. The requested mode, Type 1 (serial), Type 2 (2-bit parallel), Type 3<br>
(4-bit parallel), or Type 4 (8-bit parallel) mode, is echoed back to the host as a<br>
parameter in this packet. The format of one embodiment for a Interface Type<br>
Acknowledge Packet is shown in FIG. 28. As shown in FIG. 28, this type of packet is<br>
structured to have Packet Length, Packet Type, cClient ID, Interface Type, Reseerved 1,<br>
and CRC fields. This type of packet is generally identified as a Type 76 packet, and<br>
uses a pre-selected fixed length of 4 bytes.<br>
20. Perform Type Handoff Packets<br>
[00270] The Perform Type Handoff Packet is a means, structure, or method for the host<br>
to command the client to handoff to the mode specified in this packet. This is to be the<br>
same mode that was previously requested and acknowledged by the Interface Type<br>
Handoff Request Packet and Interface Type Acknowledge Packet. The host and client<br>
should switch to the agreed upon mode after this packet is sent. The client may lose and<br>
re-gain link synchronization during the mode change. The format of one embodiment<br>
for a Perform Type Handoff Packet is shown in FIG. 29. As shown in FIG. 29, this type<br>
of packet is structured to have Packet Length, Packet Type, Packet Type, Reserve 1, and<br>
CRC fields. This type of packet is generally identified as a Type 77 packet in the 1-byte<br>
type field, and uses a pre-selected fixed length of 4 bytes.<br>
21. Forward Audio Channel Enable Packets<br>
[00271] This packet provides a structure, method, or means that allows a host to enable<br>
or disable audio channels in a client. This capability is useful so that a client (a display<br>
for example) can power off audio amplifiers or similar circuit elements to save power<br>
when there is no audio to be output by the host. This is significantly more difficult to<br>
implement implicitly simply using the presence or absence of audio streams as an<br>
indicator. The default state when the client system is powered-up is that all audio<br>
channels are enabled. The format of one embodiment of a Forward Audio Channel<br>
Enable Packet is shown in FIG. 30. As shown in FIG 30, this type of packet is<br>
structured to have Packet Length, Packet Type, h Client ID, Audio Channel Enable<br>
Mask, and CRC fields. This type of packet is generally identified as a Type 78 packet<br>
in the 1-byte type field, and uses a pre-selected fixed length of 4 bytes.<br>
22. Reverse Audio Sample Rate Packets<br>
[00272] This packet allows the host to enable or disable the reverse-link audio channel,<br>
and to set the audio data sample rate of this stream. The host selects a sample rate that<br>
is defined to be valid in the Client Capability Packet. If the host selects an invalid<br>
sample rate then the client will not send an audio stream to the host, and an appropriate<br>
error, error value, or error signal, may be sent to the host in the Client Error Report<br>
Packet. The host may disable the reverse-link audio stream by setting the sample rate to<br>
a value of 255. The default state assumed when the client system is initially poweredup<br>
or connected is with the reverse-link audio stream disabled. The format of one<br>
embodiment for a Reverse Audio Sample Rate Packet is shown in FIG. 31. As shown<br>
in FIG. 31, this type of packet is structured to have Packet Length, Packet Type, hClient<br>
ID, Audio Sample Rate, Reserved 1, and CRC fields. This type of packet is generally<br>
identified as a Type 79 packet, and uses a pre-selected fixed length of 4 bytes.<br>
2.1 Digital Content Protection Overhead Packets<br>
[00273] This packet provides a structure, method, or means that allows a host and a<br>
client to exchange messages related to the digital content protection method being used.<br>
Presently two types of content protection are contemplated, Digital Transmission<br>
Content Protection (DTCP), or High-bandwidth Digital Content Protection System<br>
(HDCP), with room reserved for future alternative protection scheme designations. The<br>
method being used is specified by a Content Protection Type parameter in this packet.<br>
The format of an embodiment of a Digital Content Protection Overhead Packet is shown<br>
in FIG. 32. As shown in FIG. 32, this type of packet is structured to have Packet<br>
Length, Packet Type, bClient ID, Content Protection Type, Content Protection<br>
Overhead Messages, and CRC fields. This type of packet is generally identified as a<br>
Type 80 packet.<br>
24. Transparent Color Enable Packets<br>
[00274] The Transparent Color Enable Packet is a structure, method, or means that<br>
used to specify which color is transparent in a display and to enable or disable the use of<br>
a transparent color for displaying images. Displays that have this capability will report<br>
that capability in bit 4 of the Client Feature Capability field of the Client Capability<br>
Packet. When a pixel with the value for transparent color is written to the bitmap, the<br>
color does not change from the previous value. The format of a Transparent Color<br>
Enable Packet is shown in FIG. 33. As shown in FIG. 33, in one embodiment this type<br>
of packet is structured to have Packet Length, Packet Type, hClient ID, Transparent<br>
Color Enable, Reserved 1, Alpha-Cursor Identifier, Data Format Descriptor,<br>
Transparent Pixel Value, and CRC fields. This type of packet is generally identified as<br>
a Type 81 packet in the 1-byte type field, and uses a pre-selected fixed length of 10<br>
bytes.<br>
25. Round Trip Delay Measurement Packets<br>
[00275] The Round Trip Delay Measurement Packet provides a structure, method, or<br>
means that is used to measure the propagation delay from the host to a client (display)<br>
plus the delay from the client (display) back to the host. This measurement inherently<br>
includes the delays that exist in the line drivers and receivers, and an interconnect subsystem.<br>
This measurement is used to set the turn around delay and reverse link rate<br>
divisor parameters in the Reverse Link Encapsulation Packet, described generally<br>
above. This packet is most useful when the MDDI link is running at the maximum<br>
speed intended for a particular application. The MDDI_Stb signal behaves as though all<br>
zero data is being sent during the following fields: both Guard Times, All Zero, and the<br>
Measurement Period. This causes MDDIJStb to toggle at half the data rate so it can be<br>
used as periodic clock in the client during the Measurement Period<br>
In one embodiment, a client generally indicates an ability to support the Round<br>
Trip Delay Measurement Packet through use of bit 18 of the Client Feature Capability<br>
Indicators field of the Client Capability Packet. It is recommended that all clients<br>
support round trip delay measurement, but it is possible for the host to know the worstcase<br>
round trip delay based on a maximum cable delay, and on maximum driver and<br>
receiver delays. The host may also know the round-trip delay in advance for an MDDI<br>
link used in internal mode, since this is an aspect of known design elements (conductor<br>
lengths, circuitry type, and features, and so forth) of the device in which the interface is<br>
being used.<br>
[00276] The format of a Round Trip Delay Measurement Packet is shown in FIG. 34.<br>
As shown in FIG. 34, in one embodiment this type of packet is structured to have Packet<br>
Length, Packet Type, hClient ID, Parameter CRC, Guard Time 1, Measurement Period,<br>
All Zero, and Guard Time 2 fields. This type of packet is generally identified as a Type<br>
82 packet, and uses a pre-selected fixed length of 159 bits.<br>
[00277] The timing of events that take place during the Round Trip Delay<br>
Measurement Packet are illustrated in FIG, 35. In FIG. 35, the host transmits the Round<br>
Trip Delay Measurement Packet, shown by the presence of the Parameter CRC and<br>
Strobe Alignment fields followed by the All Zero and Guard Time 1 fields. A delay<br>
3502 occurs before the packet reaches the client display device or processing circuitry.<br>
As the client receives the packet, it transmits the Oxff, Oxff, and 30 bytes of 0x0 pattern<br>
as precisely as practical at the beginning of the Measurement Period as determined by<br>
the client. The actual time the client begins to transmit this sequence is delayed from<br>
the beginning of the Measurement Period from the point of view of the host. The<br>
amount of this delay is substantially the time it takes for the packet to propagate through<br>
the line drivers and receivers and the interconnect subsystem (cables, conductors). A<br>
similar amount of delay 3504 is incurred for the pattern to propagate from the client<br>
back to the host.<br>
[00278] In order to accurately determine the round trip delay time for signals traversing<br>
to and from the client, the host counts the number of forward link bit time periods<br>
occurring after the start of the Measurement Period until the beginning of the Oxff, Oxff,<br>
and 30 bytes of 0x0 sequence is detected upon arrival. This information is used to<br>
determine the amount of time for a round trip signal to pass from the host to the client<br>
and back again. Then, about one half of this amount is attributed to a delay created for<br>
the one way passage of a signal to the client.<br>
[00279] The host and client both drive the line to a logic-zero level during both guard<br>
times to keep the MDDI_DATA lines in a defined state. The enable and disable times<br>
of the host and client during both guard times are such that the MDDI_Data signals are<br>
at a valid low level for any valid round-trip delay time.<br>
26. Forward Link Skew Calibration Packet<br>
[00280] The Forward Link Skew Calibration Packet allows a client or display to<br>
calibrate itself for differences in the propagation delay of the MDDI_Data signals with<br>
respect to the MDDI_Stb signal. Without delay skew compensation, the maximum data<br>
rate is generally limited to account for potential worst-case variation in these delays.<br>
Generally, this packet is only sent when the forward link data rate is configured to a rate<br>
of around 50 Mbps or lower. After sending this packet to calibrate the display, the data<br>
rate may be stepped up above 50 Mbps. If the data rate is set too high during the skew<br>
calibration process, the display might synchronize to an alias of the bit period which<br>
could cause the delay skew compensation setting to be off by more than one bit time,<br>
resulting in erroneous data clocking. The highest data rate type of interface or greatest<br>
possible Interface Type is selected prior to sending the Forward Link Skew Calibration<br>
Packet so that all existing data bits are calibrated.<br>
[00281] One embodiment of the format of a Forward Link Skew Calibration Packet is<br>
shown in FIG. 56. As shown in FIG. 56, this type of packet is structured to have Packet<br>
Length (2 bytes), Packet Type, hClient ID, Parameter CRC, All Zero, Calibration Data<br>
Sequence, and CRC fields. This type of packet is generally identified as a Type 83<br>
packet in the type field, and in one embodiment has a pre-selected length of 515.<br>
Virtual Control Panel<br>
[00282] The use of a Virtual Control Panel (VCP) allows a host to set certain user<br>
controls in a client. By allowing these parameters to be adjusted by the host, the user<br>
interface in the client can be simplified because screens that allow a user to adjust<br>
parameters such as audio volume or display brightness can be generated by host<br>
software rather than by one or more microprocessors in the client. The host has the<br>
ability to read the parameter settings in the client and to determine the range of valid<br>
values for each control. The client generally has the capability to report back to the host<br>
which control parameters can be adjusted.<br>
[00283] The control codes (VCP Codes) and associated data values generally specified,<br>
are utilized to specify controls and settings in the client. The VCP Codes in the MDDI<br>
specification are expanded to 16 bits to preserve proper data field alignment in the<br>
packet definitions, and in the future to support supplementary values that are unique to<br>
this interface or future enhancements.<br>
27. Request VCP Feature Packet<br>
[00284] The Request VCP Feature Packet provides a means, mechanism, or method for<br>
the host to request the current setting of a specific control parameter or all valid control<br>
parameters. Generally, a client responds to a VCP Packet with the appropriate<br>
information in a VCP Feature Reply Packet. In one embodiment, the client indicates an<br>
ability to support the Request VCP Feature Packet using bit 20 of the Client Feature<br>
Capability Indicators field of the Client Capability Packet.<br>
[00285] The format of the Request VCP Feature Packet in one embodiment is shown in<br>
FIG. 69. As seen in FIG. 69, this type of packet is structured to have Packet Length,<br>
Packet Type, hClient ID, MCCS VCP code, and CRC fields. This type of packet is<br>
generally identified in one embodiment as a Type 128, which is indicated in the 2 byte<br>
type field. The packet length, which specifies the total number of bytes in the packet<br>
not including the packet length field, is typically fixed for this type of packet at a length<br>
of 8 bytes.<br>
[00286] The hClient ID field is reserved for use as a Client ID in future<br>
implementations and is typically set to zero. The MCCS VCP Code field comprises 2<br>
bytes of information that specifies the MCCS VCP Control Code Parameter. A value in<br>
the range of 0 to 255 causes a VCP Feature Reply Packet to be returned with a single<br>
item in the VCP Feature Reply List corresponding to the specified MCCS code. An<br>
MCCS VCP Code of 65535 (Oxffff) requests a VCP Feature Reply Packet with a VCP<br>
Feature Reply List containing a Feature Reply List Item for each control supported by<br>
the client. The values of 256 through 65534, for this field are reserved for future use<br>
and presently not. in use.<br>
28. VCP Feature Reply Packet<br>
[00287] The VCP Feature Reply Packet provides a means, mechanism, or method for a<br>
client to respond to a host request with the current setting of a specific control parameter<br>
or all valid control parameters. Generally, a client sends the VCP Feature Reply Packet<br>
in response to a Request VCP Feature Packet. This packet is useful to determine the<br>
current setting of a specific parameter, to determine the valid range for a specific<br>
control, to determine if a specific control is supported by the client, or to determine the<br>
set of controls that are supported by the client. If a Request VCP Feature is sent that<br>
references a specific control that is not implemented in the client then a VCP Feature<br>
the unimplemented control that contains the appropriate error code. In one<br>
embodiment, the client indicates an ability to support the VCP Feature Reply Packet<br>
using bit 20 of the Client Feature Capability field of the Client Capability Packet.<br>
[00288] The format of the VCP Feature Reply Packet in one embodiment is shown in<br>
FIG. 70. As seen in FIG. 70, this type of packet is structured to have Packet Length,<br>
Packet Type, cClient ID, MCCS Version, Reply Sequence Number, VCP Feature Reply<br>
List, and CRC fields. This type of packet is generally identified in one embodiment as a<br>
Type 129, as indicated in the 2 byte type field.<br>
[00289] The cClient ID field contains information reserved for a Client ID. This field<br>
is reserved for future use and is generally set to zero. MCCS Version field contains 2<br>
bytes of information that specifies the Version of the VESA MCCS Specification<br>
implemented by the client.<br>
[00290] The 2 byte Reply Sequence Number field contains information or data that<br>
specifies the sequence number of the VCP Feature Reply Packets returned by the client.<br>
The client returns one or more VCP Feature Reply Packets in response to a Request<br>
VCP Feature Packet with an MCCS Control Code value of 65535. The client may<br>
spread the feature reply list over multiple VCP Feature Reply Packets. In this case, the<br>
client assigns a sequence number to each successive packet, and the sequence numbers<br>
of the VCP Feature Reply Packets sent in response to a single Request VCP Feature<br>
Packet starts at zero and increments by one. The last VCP Feature List Item in the last<br>
VCP Feature Reply Packet should contain an MCCS VCP Control Code value equal to<br>
Oxffff to identify that the packet is the last one and contains the highest sequence<br>
number of the group of packets returned. If only one VCP Feature Reply Packet is sent<br>
in response to a Request VCP Feature Packet then the Reply Sequence Number in that<br>
single packet is zero and the VCP Feature Reply List contains a record having an<br>
MCCS VCP Control Code equal to Oxffff.<br>
[00291] The Number of Features in List field contains 2 bytes that specify the number<br>
of VCP Feature List Items that are in the VCP Feature Reply List in this packet, while<br>
the VCP Feature Reply List field is a group of bytes that contain one or more VCP<br>
Feature Reply List Items. The format of a single VCP Feature Reply List Item in one<br>
embodiment is shown in FIG. 71.<br>
[00292] As shown in FIG. 71, each VCP Feature Reply List Item is 12 bytes in length,<br>
and comprises the MCCS VCP Code, Result Code, Maximum Value, and Present Value<br>
fields. The 2-byte MCCS VCP Code field contains data or information that specifies<br>
the MCCS VCP Control Code Parameter associated with this list item. Only the<br>
Control Code values defined in the VESA MCCS Specification version 2 and later are<br>
considered as valid for this embodiment. The 2-byte Result Code field contains<br>
information that specifies an error code related to the request for information regarding<br>
the specified MCCS VCP Control. A value of '0' in this field means there is no error,<br>
while a value of T means the specified control is not implemented in the client.<br>
Further values for this field of 2 through 65535 are currently reserved for future use and<br>
implementation of other application contemplated by the art, but are not to be used for<br>
now.<br>
[00293] The 4-byte Maximum Value field contains a 32-bit unsigned integer that<br>
specifies the largest possible value to which the specified MCCS Control can be set. If<br>
the requested control is not implemented in the client this value is set to zero. If the<br>
value returned is less than 32 bits (4 bytes) in length, then the value is cast into a 32-bit<br>
integer leaving the most significant (unused) bytes set to zero. The 4-byte Present<br>
Value field contains information that specifies the present value of the specified MCCS<br>
VCP Continuous (C) or non-continuous (NC) control. If the requested control is not<br>
implemented in the client or if the control is implemented but is a table (T) data type,<br>
then this value is set to zero. If the value returned is less than 32 bits (4 bytes) in length<br>
per the VKS A MCCS specification then the value is cast into a 32-bit integer leaving the<br>
most significant (unused) bytes set to zero.<br>
29. Set VCP Feature Packet<br>
[00294] The Set VCP Feature Packet provides a means, mechanism, or method for a<br>
host to set VCP control values for both continuous and non-continuous controls in a<br>
client. In one embodiment, the client indicates the ability to support the Set VCP<br>
Feature Packet using bit 20 of the Client Feature Capability field of the Client<br>
Capability Packet.<br>
[00295] The format of the Set VCP Feature Packet in one embodiment is shown in<br>
FIG. 72. As seen in FIG. 72, this type of packet is structured to have Packet Length,<br>
Packet Type, hClient ID, MCCS VCP Code, Number of Values in List, Control Value<br>
List, and CRC fields. This type of packet is generally identified as a Type 130, as<br>
indicated in the 2 byte type field, is 20 bytes long exclusive of the Packet Length field.<br>
[00296] The hCiient ID field again uses a 2-byte value to specify or act as a Client ID.<br>
field uses 2 bytes of information or values to specify the MCCS VCP Control Code<br>
Parameter to be adjusted. The 2-byte Number of Values in List Field contains<br>
information or values that specifies the number of 16-bit values that exist in the Control<br>
Value List. The Control Value List will usually contain one item unless the MCCS<br>
Control Code relates to a table in the client. In the case of non-table-related controls,<br>
The Control Value List will contain a value that specifies the new value to be written to<br>
the control parameter specified by the MCCS VCP Code field. For table-related<br>
controls the format of the data in the Control Value List is specified by the parameter<br>
description of the specified MCCS VCP Code. If the list contains values that are larger<br>
than one byte, then the least-significant byte is transmitted first, consistent with the<br>
method defined elsewhere. Finally, the 2-byte CRC field contains a 16-bit CRC of all<br>
bytes in the packet including the Packet Length.<br>
30. Request Valid Parameter Packet<br>
[00297] The Request Valid Parameter Packet is used as a means or structure useful to<br>
request that a client return a Valid Parameter Reply Packet containing a list of<br>
parameters supported by the specified non-continuous (NC) or table (T) control. This<br>
packet should only specify non-continuous controls or controls that relate to a table in<br>
the client, and not specify a MCCS VCP Code value of 65535 (Oxffff) to specify all<br>
controls. If a non-supported or invalid MCCS VCP Code is specified then an<br>
appropriate error value is returned in the Valid Parameter Reply Packet. In one<br>
embodiment, the client indicates an ability to support the Request Valid Parameter<br>
Packet using bit 20 of the Client Feature Capability field of the Display Capability<br>
Packet.<br>
[00298] The format of the Request Valid Parameter Packet in one embodiment is<br>
shown in FIG. 73. As seen in FIG. 73, this type of packet is structured to have Packet<br>
Length, Packet Type, hClient ID, MCCS VCP Code, and CRC fields. This type of<br>
packet is generally identified in one embodiment as a Type 131, as indicated in the 2<br>
byte type field.<br>
[00299] The packet length, as indicated in the 2-bytes Packet Length Field is generally<br>
set to have a total number of bytes in the packet, not including the packet length field of<br>
8. The hClient ID again specifies the Client ID, but is currently reserved for future use,<br>
as would be apparent to one skilled in the art, and is set to zero. The 2-byte MCCS<br>
VCP Code Filed contains a value that specifies the non-continuous MCCS VCP Control<br>
Code Parameter to be queried. The value in this field should correspond to a noncontinuous<br>
control that is implemented in the client. The values 256 through 65535<br>
(Oxffff) are typically reserved or considered as invalid, and are considered as an<br>
unimplemented control in the error response.<br>
31. Valid Parameter Reply Packet<br>
[00300] A Valid Parameter Reply Packet is sent in response to a Request Valid<br>
Parameter Packet. It is used as a means, method, or structure to identify the valid<br>
settings for a non-continuous MCCS VCP control or a control that returns the contents<br>
of a table. If the control relates to a table in the client, then the VCP Parameter Reply<br>
List simply contains the specific list of sequential table values that were requested. If<br>
the contents of the table cannot fit into a single Valid Parameter Reply Packet then<br>
multiple packets with sequential Reply Sequence Numbers can be sent by the client. In<br>
one embodiment, a client indicates an ability to support a Valid Parameter Reply Packet<br>
using bit 20 of the Client Feature Capability field of the Client Capability Packet.<br>
[00301] A host may request the contents of a table in the following manner: the host<br>
sends a Set VCP Feature Packet containing the necessary or desired parameters such as<br>
read/write parameter, LUT offset, and RGB selection; then a Request Valid Parameter<br>
Packet that specifies the desired control is sent by the host; then the client returns one or<br>
more Valid Parameter Reply Packets containing the table data. This sequence of<br>
operations performs a similar function as the table reading functions described in the<br>
MCCS operation model.<br>
[00302] If a specific client parameter is not supported by the client then in one<br>
embodiment the corresponding field of this packet will contain a value of 255. For<br>
parameters that are used in the client, the corresponding field should contain a value of<br>
the parameter in the client.<br>
[00303] The format of the Valid Parameter Reply Packet for one embodiment is shown<br>
in FIG. 74. As seen in FIG. 74, this type of packet is structured to have Packet Length,<br>
Packet Type, cClient ID, MCCS VCP Code, Response Code, Reply Sequence Number,<br>
Number Values in List, VCP Parameter Reply List, and CRC fields. This type of packet<br>
is generally identified for one embodiment as a Type 132, as indicated in the 2 byte type<br>
field.<br>
[00304] The cClient ID field is reserved for the future Client ID, as is known from the<br>
above discussions, while the 3-byte MCCS VCP Code Packet contains a value that<br>
specifies a non-continuous MCCS VCP Control Code Parameter that is described by<br>
this packet. If an invalid MCCS VCP Control Code is specified by a Request Valid<br>
Parameter Packet, then the same invalid parameter value will be specified in this field<br>
with the appropriate value in the Response Code field. If the MCCS Control Code is<br>
invalid then the VCP Parameter Reply List will have zero length,<br>
[00305] The Response Code field contains 2 bytes of information or values that specify<br>
the nature of the response related to the request for information regarding the specified<br>
MCCS VCP Control. If the value in this field is equal to 0, then no error is considered<br>
as being present for this data type, and the last Valid Parameter Reply Packet in the<br>
sequence is sent, it having the highest Reply Sequence Number. If the value in this field<br>
is equal to 1, then no error is considered as being present, but other Valid Parameter<br>
Reply Packets will be sent that have higher sequence numbers. If the value in this field<br>
is equal to 2, then the specified control is not considered as being implemented in the<br>
client. If the value in this field id equal to 3, then the specified control is not a noncontinuous<br>
control (it is a continuous control that always has a valid set of all values<br>
from zero to its maximum value). Values for this field equal to 4 through 65535 are<br>
reserved for future use and generally not to be used.<br>
[00306] The 2-byte Reply Sequence Number field specifies the sequence number of the<br>
Valid Parameter Reply Packets returned by the client. The client returns one or more<br>
Valid Parameter Reply Packets in response to a Request Valid Parameter Packet. The<br>
client may spread the VCP Parameter Reply List over multiple Valid Parameter Reply<br>
Packets. In this latter case, the client will assign a sequence number to each successive<br>
packet, and set the Response Code to 1 in all but the last packet in the sequence. The<br>
last Valid Parameter Reply Packet in the sequence will have the highest Reply Sequence<br>
Number and the Response Code contains a value of 0.<br>
[00307] The 2-byte Number of Values in List field specifies the number of 16-bit<br>
values that exist in the VCP Parameter Reply List. If the Response Code is not equal to<br>
zero then the Number of Values in List parameter is zero. The VCP Parameter Reply<br>
List field contains a list of 0 to 32760 2-byte values that indicate the set of valid values<br>
for the non-continuous control specified by the MCCS Control Code field. The<br>
definitions of the non-continuous control codes are specified in the VESA MCCS<br>
Specification. Finally, in this embodiment, the CRC field contains a 16-bit CRC of all<br>
bytes in the packet including the Packet Length.<br>
Alpha-Cursor Images<br>
[00308] The MDD interface and associated inventive protocol and mechanisms for<br>
communicating data over a communications link provides support for multiple image<br>
planes that overlap each other and can have varying degrees of transparency. A<br>
hardware cursor can be implemented using an overlapping image that has a variable XY<br>
offset. An overview of the Alpha-Cursor functionality and associated protocol<br>
support is provided below. The ability to support Alpha-Cursor image packets is<br>
defined in the Alpha-Cursor Image Capability Packet, which is sent in response to a<br>
Request Specific Status Packet.<br>
32. Alpha-Cursor Image Capability Packet<br>
[00309] The Alpha-Cursor Image Capability Packet is used to define the characteristics<br>
of the alpha-cursor image and associated transparency maps in a client. In one<br>
embodiment, a client indicates an ability to support an Alpha-Cursor Image Capability<br>
Packet using a parameter value of 133 in the Valid Parameter Reply List of the Valid<br>
Status Reply List Packet. The packet length specified in the packet length field is set to<br>
a fixed value of 20 for one embodiment, not including the packet length field.<br>
[00310] The format of the Alpha-Cursor Image Capability Packet for one embodiment<br>
is shown in FIG. 75. As seen in FIG. 75, this type of packet is structured to have Packet<br>
Length, Packet Type, cClient ED, Alpha-Cursor Identifier, Alpha-Cursor Bitmap Width,<br>
Alpha-Cursor Bitmap Height, RGB Capability, Monochrome Capability, Reserved 1, Y<br>
Cr Cb Capability, Transparency Map Res., Capability Bits, and CRC fields. The<br>
cClient ID field is typically reserved for future Client ID use and currently set to zero.<br>
[00311] The Alpha Cursor Identifier field (2 bytes) contains a value that identifies a<br>
specific alpha-cursor plane. If the client supports n alpha-cursor image planes then the<br>
Alpha-Cursor Identifier has a valid range of 0 to n - 1. In one embodiment, the value n<br>
is specified by the Alpha-Cursor Image Planes field of the Client Capability Packet.<br>
The client returns a unique Alpha-Cursor Image Capability Packet for each alpha-cursor<br>
image plane.<br>
[00312] The 2-byte Alpha-Cursor Bitmap Width field value specifies the width of the<br>
alpha-cursor bitmap image expressed as a number of pixels, while the 2-byte Alpha-<br>
Cursor Bitmap Height field value specifies the height of the alpha-cursor bitmap image<br>
expressed as a number of pixels.<br>
 [00313] The RGB Capability field uses 2 bytes to specify the number of bits of<br>
resolution that can be displayed in RGB format. If the client cannot use the RGB<br>
format then this value is zero. The RGB Capability word is composed of three separate<br>
values, which in one embodiment are implemented such that: Bits 3 through 0 define<br>
the maximum number of bits of blue (the blue intensity) in each pixel; Bits 7 through 4<br>
define the maximum number of bits of green (the green intensity) in each pixel; Bits 11<br>
through 8 define the maximum number of bits of red (the red intensity) in each pixel;<br>
and Bits 15 through 12 are reserved for future use in presenting RGB capability<br>
information so they are generally set to zero for now.<br>
[00314] The 1-byte Monochrome Capability field is used to specify the number of bits<br>
of resolution that can be displayed in monochrome format. If a client cannot use the<br>
monochrome format then this value is set at zero. Bits 7 through 4 are reserved for<br>
future use and are, therefore, generally set to zero. Bits 3 through 0 define the<br>
maximum number of bits of grayscale that can exist in each pixel. These four bits make<br>
it possible to specify that each pixel consists of 1 to 15 bits. If the value is zero then the<br>
monochrome format is not supported by the client.<br>
[00315] The 1-byte Reserved 1 field contains a value generally reserved for future use,<br>
and as such all bits in this field are set to zero. This will cause subsequent 2-byte fields<br>
to align to a 16-bit word address and cause 4-byte fields to align to a 32-bit word<br>
address,<br>
[00316] The 2-byte Y Cb Cr Capability field contains values or information that<br>
specifies the number of bits of resolution that can be displayed in Y Cb Cr format. If<br>
the client cannot: use the Y Cr Cb format then this value is zero. Generally, in one<br>
embodiment, the Y Cb Cr Capability word is composed of three separate values with:<br>
Bits 3 through 0 defining a maximum number of bits that specify the Cr sample; Bits 7<br>
through 4 defining the maximum number of bits that specify the Cb sample; Bits 11<br>
through 8 defining the maximum number of bits that specify the Y sample; and with<br>
Bits 15 through 12 being reserved for future use in presenting Y Cb Cr Capability<br>
information or values, but currently being set to zero.<br>
[00317] The 1-byte Transparency Map Resolution field contains values or information<br>
that specifies the number of bits (depth) in each pixel location of the alpha-cursor image<br>
transparency map. This value may range from 1 to 8, If the value is zero then the<br>
transparency map is not supported for this alpha-cursor image buffer (the buffer<br>
specified by the Alpha-Cursor Identifier Field).<br>
 [00318] The 1-byte Capability Bits field provides values or information that contains a<br>
set of flags that specify capabilities associated with the alpha-cursor image buffer. In<br>
one embodiment, the flags are defined such that: Bit 0 acts to select Pixel data in the<br>
alpha-Cursor Video Stream Packet to be in a packed format. Bit 1 acts to show that<br>
transparency map data in the Alpha-Cursor Transparency Packet is in a packet format.<br>
An example of byte-aligned and packed transparency map data is shown in FIG. 76. Bit<br>
2 acts to show that the alpha-cursor image plane supports image offset capability using<br>
the Alpha-Cursor Image Offset Packet. Bit 3 acts to show that the alpha-cursor image<br>
plane can support a color map data format. The same color map table is used for the<br>
alpha-cursor image planes as is used for the main image buffer and scaled video<br>
streams. The color map is configured using the Color Map Packet described elsewhere.<br>
[00319] Bits 7 through 4 are reserved for future use and are generally, therefore, set to a<br>
zero value or logic level.<br>
33. Alpha-Cursor Transparency Map Packet<br>
[00320] The Alpha-Cursor Transparency Map Packet defines the contents of the image<br>
transparency map for the specified alpha-cursor image plane. Some applications may<br>
require a transparency map that is larger than the amount of data that can be transmitted<br>
in a single packet. In these cases, multiple Alpha-Cursor Transparency Map Packets<br>
may be sent, each with a different subset of the transparency map by using the<br>
Transparency Map X and Y Start fields described below. These fields operate in a<br>
similar manner as the X Start and Y Start fields of the Video Stream Packet. A client<br>
indicates an ability to support the Alpha-Cursor Transparency Map Packet in one<br>
embodiment using the Transparency Map Resolution field of the Alpha-Cursor Image<br>
Capability Packet for each specific Alpha-Cursor Plane specified by the Alpha-Cursor<br>
Identifier field of the Alpha-Cursor Image Capability Packet. The packet length and<br>
Client ID fields operate as before for other packets discussed above. In one<br>
embodiment, a value of 134 in the Packet Type field is used to identify a packet as a<br>
Alpha-Cursor Transparency Map Packet.<br>
[00321] The format of the Alpha-Cursor Transparency Map Packet for one embodiment<br>
is shown in FIG. 76. As seen in FIG. 76, this type of packet is structured to have Packet<br>
Length, Packet Type, hClient ID, Alpha-Cursor Identifier, Transparency Map X Start,<br>
Transparency Map Y Start, Transparency Map Resolution, Reserved 1, Parameter CRC,<br>
Transparency Map Media, and Transparency Map Data CRC fields.<br>
 [00322] The 2-byte Alpha Cursor Identifier field has a value that identifies a specific<br>
alpha-cursor plane. If the client supports n alpha-cursor image planes then the Alpha-<br>
Cursor Identifier has a valid range of 0 to n -1.<br>
[00323] The 2-byte Transparency Map X and Y Start fields each specify the absolute X<br>
and Y coordinates, where the point (Transparency Map X Start, Transparency Map Y<br>
Start) is the first pixel in the Transparency Map Data field below.<br>
[00324] The transparency Map Resolution field (1 byte) contains a value that specifies<br>
the resolution of the transparency map and whether or not the data is packed. In one<br>
embodiment of this field, Bits 3 through 0 define the number of bits of resolution that<br>
exist in all transparency map table items. Valid values specify the width to be from 1 to<br>
8 bits. Values 0 and 9 through 15 are considered invalid. This value should match the<br>
value returned by a client in the Transparency Map Resolution field in the Alpha-Cursor<br>
Image Capability Packet. Bits 6 through 4 are reserved for future use and are, therefore,<br>
is generally set to logic-zero at this time. Bit 7 of this byte specifies whether or not the<br>
Transparency Map Data is in packed or byte-aligned form. If bit 7 is equal to T then<br>
the Transparency Map Data is in packed form, and if '0' the data is byte-aligned. An<br>
example of packed and byte-aligned Transparency Map data is shown elsewhere. The<br>
value of this bit must match the value of bit 1 of the Capability Bits field of the Alpha-<br>
Cursor Image Capability Packet.<br>
[00325] The 1 byte Reserved 1 field is reserved for future use, therefore, all bits in this<br>
field are generally set equal to a logic-zero level. One purpose of this field is to cause<br>
all subsequent 2 byte fields to align to a 16-bit word address and cause 4-byte fields to<br>
align to a 32-bit word address. The Parameter CRC field contains a 16-bit CRC of all<br>
bytes from the Packet Length to the Reserved 1 field. If this CRC fails to check then<br>
the entire packet is to be discarded.<br>
[00326] For the Transparency Map Data field, each transparency map location is 1 to 8<br>
bits in width. If a single transparency map cannot fit into one Alpha and Cursor<br>
Transparency Map Packet, then the entire transparency map may be specified by<br>
sending multiple packets with different Transparency Map Data and Transparency Map<br>
X and Y Start values in each packet.<br>
[00327] The 2-byte Transparency Map Data CRC field contains a 16-bit CRC of only<br>
the Transparency Map Data. If this CRC fails to check then the Transparency Map Data<br>
can still be used but the CRC error count is incremented.<br>
34. Alpha-Cursor Image Offset Packet<br>
[00328] The Alpha-Cursor Image Offset Packet specifies the X and Y offset of the<br>
cursor from the upper left comer of the main display image. The format of the Alpha-<br>
Cursor Image Offset Packet is illustrated in FIG. 77. As shown in FIG. 77, in one<br>
embodiment, the Alpha-Cursor Image Offset Packet is structured with Packet Length,<br>
Packet Type, hClient ID, Alpha-Cursor X Offset, Alpha-Cursor Y Offset, and CRC<br>
fields. In one embodiment, a client indicates the ability to support the Alpha-Cursor<br>
Image Offset Packet using bit 2 of the Capability Bits field of the Alpha-Cursor Image<br>
Capability Packet for each specific Alpha-Cursor Plane specified by the Alpha-Cursor<br>
Identifier field of" the Alpha-Cursor Image Capability Packet. In one embodiment, the<br>
packet length is fixed at 10, as shown in the 2-byte Packet Length field. In one<br>
embodiment, a Packet Type of 135 identifies the packet as an Alpha-Cursor Image<br>
Offset Packet.<br>
[00329] The 2-byte Alpha-Cursor X and Y Offset fields contain values that specify the<br>
horizontal and vertical, respectively, offset of the left-most column and top row,<br>
respectively of pixels of the cursor image from the left side and top of the main image.<br>
The hClient ID - 2 bytes that contain a 16-bit unsigned integer reserved for the Client<br>
ID. This field is reserved for future use and is generally set to logic-zero levels or<br>
values for the bits.<br>
35. Alpha-Cursor Video Stream Packet<br>
[00330] The Alpha-Cursor Video Stream Packet carries video data to update a<br>
rectangular region of an alpha-cursor image plane. The size of this region may be as<br>
small as a single pixel or as large as the entire display. The format of the Alpha-Cursor<br>
Video Stream Packet is illustrated in FIG. 78, As shown in FIG 78, in one embodiment<br>
the Alpha-Cursor Video Stream Packet is structured with Packet Length, Packet Type,<br>
bClient ID, Video Data Format Attributes, X Left Edge, Y Top Edge, X Rigth Edge, Y<br>
Bottom Edge, X Start, Y Start, Pixel Count, Parameter Crc Pixel Data, and Pixel Data<br>
CRC fields. In one embodiment, a client indicates an ability to support the Alpha-<br>
Cursor Video Stream Packet and its associated parameters by using the Alpha-Cursor<br>
Image Capability Packet for each specific Alpha-Cursor Plane specified by the Alpha-<br>
Cursor Identifier field of the Alpha-Cursor Image Capability Packet, and a value of 17<br>
in the packet type field indicates or identifies a packet as being an Alpha-Cursor Video<br>
Stream Packet. The hClient ID field (2 bytes) is reserved for future use as a Client ED,<br>
and is generally set to zero in the meantime, as would be well understood in the art.<br>
[00331] The 2-byte Video Data Format Descriptor field contains information or a value<br>
that specifies the format of each pixel in the Pixel Data in the present stream in the<br>
present packet. The pixel data format must comply with at least one of the valid formats<br>
for the alpha-cursor image plane as defined in the Alpha-Cursor Image Capability<br>
Packet. The Video Data Format Descriptor field contains a value that defines the pixel<br>
format for the current packet only and does not imply that a constant format will<br>
continue to be used for the lifetime of a particular video stream. FIG. 11, above<br>
illustrates how the Video Data Format Descriptor is coded. The format is as follows:<br>
[00332] In one embodiment, when bits [15:13] are '000' then the video data consists of<br>
an array of monochrome pixels where the number of bits per pixel is defined by bits 3<br>
through 0 of the Video Data Format Descriptor word. Bits 11 through 4 are then set to<br>
zero. When bits [15:13] are '001' then the video data consists of an array of color<br>
pixels that each specify a color through a color map (palette). Bits 5 through 0 of the<br>
Video Data Format Descriptor word define the number of bits per pixel, and Bits 11<br>
through 6 are set to zero. When bits [15:13] are '010' then the video data consists of an<br>
array of color pixels in raw RGB format where the number of bits per pixel of red is<br>
defined by bits 11 through 8, the number of bits per pixel of green is defined by bits 7<br>
through 4, and the number of bits per pixel of blue is defined by bits 3 through 0. The<br>
total number of bits in each pixel is the sum of the number of bits used for red, green,<br>
and blue.<br>
[00333] When bits [15:13] are 'Oil' then the video data consists of an array of video<br>
data in 4:2:2 Y Cb Cr format with luminance and chrominance information. The<br>
number of bits per pixel of luminance (Y) is defined by bits 11 through 8, the number of<br>
bits of the Cb component is defined by bits 7 through 4, and the number of bits of the Cr<br>
component is defined by bits 3 through 0. The Cb and Cr components are sent at half<br>
the rate as Y. The video samples in the Pixel Data portion of this packet will be<br>
organized as follows: Cbn, Yn, Crn, Yn+1, Cbn+2, Yn+2, Crn+2, Yn+3, ... where Cbn<br>
and Crn are associated with Yn and Yn+1, and Cbn+2 and Crn+2 are associated with<br>
Yn+2 and Yn+3, and so on. Yn, Yn+1, Yn+2 and Yn+3 are luminance values of four<br>
consecutive pixels in a single row from left to right. The ordering of the color<br>
components is the same as the Microsoft UYVY FOURCC format. If there are an odd<br>
number of pixels in a row (X Right Edge - X Left Edge + 1) in the window referenced<br>
by the Video Stream Packet then the Cb value corresponding to the last pixel in each<br>
row will be followed by the Y value of the first pixel of the next row.<br>
[00334] It is recommended that windows using Y Cb Cr format have a width that is an<br>
even number of pixels. The Pixel Data in a packet contains an even number of pixels.<br>
It may contain an odd or even number of pixels in the case where the last pixel of the<br>
Pixel Data corresponds to the last pixel of a row in the window specified in the Video<br>
Stream Packet header, i.e. when the X location of the last pixel in the Pixel Data is equal<br>
to X Right Edge.<br>
[00335] For all five formats, bit 12 (designated as "P" in the figures) specifies whether<br>
or not the Pixel Data samples are packed. When the value of bit 12 is '0' then each<br>
pixel and each color within each pixel in the Pixel Data field is byte-aligned with an<br>
MDDI interface byte boundary. When the value of bit 12 is T then each pixel and<br>
each color within each pixel in the Pixel Data is packed up against the previous pixel or<br>
color within a pixel leaving no unused bits.<br>
[00336] In one embodiment, the Pixel Data Attributes field (2 byte) has a series of bit<br>
values that are interpreted as follows. Bits 1 and 0 select how the display pixel data is<br>
routed. For bit values of '11' data is displayed to or for both eyes, for bit values '10',<br>
data is routed only to the left eye, and for bit values '01', data is routed only to the right<br>
eye.<br>
[00337] Bit 2 of the Pixel Data Attributes field indicates whether or not the Pixel Data<br>
is presented in an interlace format, with a value of '0' meaning the pixel data is in the<br>
standard progressive format, and that the row number (pixel Y coordinate) is<br>
incremented by J when advancing from one row to the next. When this bit has a value<br>
of T, the pixel data is in interlace format, and the row number is incremented by 2<br>
when advancing from one row to the next. Bit 3 indicates that the Pixel Data is in<br>
alternate pixel format. This is similar to the standard interlace mode enabled by bit 2,<br>
but the interlacing is vertical instead of horizontal. When Bit 3 is '0' the Pixel Data is<br>
in the standard progressive format, and the column number (pixel X coordinate) is<br>
incremented by 1 as each successive pixel is received. When Bit 3 is T the Pixel Data<br>
is in alternate pixel format, and the column number is incremented by 2 as each pixel is<br>
received.<br>
[00338] Bit 4 of the Pixel Data Attributes field indicates whether or not the Pixel data is<br>
related to a display or a camera, as where data is being transferred to or from an internal<br>
display for a wireless phone or similar device or even a portable computer, or such other<br>
devices as discussed above, or the data is being transferred to or from a camera built<br>
into or directly coupled to the device. When Bit 4 is '0' the Pixel data is being<br>
transferred to or from a display frame buffer. When Bit 4 is T Pixel data is being<br>
transferred to or from a camera or video device of some type, such devices being well<br>
known in the art.<br>
[00339] Bit 5 of the Pixel Data Attributes field is reserved for future use or applications<br>
of the MDD interface and is, therefore, generally set as zero value or '0'.<br>
[00340] Bits 7 and 6 of the Pixel Data Attributes field are Display Update Bits that<br>
specify a frame buffer where the pixel data is to be written. The more specific effects<br>
are discussed elsewhere. For bit values of '01' Pixel data is written to the offline image<br>
buffer. For bit values of '00' Pixel data is written to the image buffer used to refresh the<br>
display. For bit values of '11' Pixel data is written to all image buffers. The bit values<br>
or combination of '10' is treated as an invalid value or designation and Pixel data is<br>
ignored and not written to any of the image buffers. This value may have use for future<br>
applications of the interface. Bits 8 through 15 of the Pixel Data Attributes field are<br>
reserved for future use and are, therefore, generally set as zero.<br>
[00341] In one embodiment, the 2-byte X Start and Y Start fields specify the absolute X<br>
and Y coordinates of the point (X Start, Y Start) for the first pixel in the Pixel Data<br>
field. The 2-byte X Left Edge and Y Top Edge fields specify the X coordinate of the<br>
left edge and Y coordinate of the top edge of the alpha-cursor image window filled by<br>
the Pixel Data field, while the X Right Edge and Y Bottom Edge fields specify the X<br>
coordinate of the right edge, and the Y coordinate of the bottom edge of the alphacursor<br>
image window being updated.<br>
[00342] The Pixel Count field (2 bytes) specifies the number of pixels in the Pixel Data<br>
field below. The 2-byte Parameter CRC field contains a CRC of all bytes from the<br>
Packet Length to the Pixel Count. If this CRC fails to check then the entire packet is<br>
discarded.<br>
[00343] The Pixel Data field contains the raw video information that is to be displayed,<br>
and which is formatted in the manner described by the Video Data Format Descriptor<br>
field. The data is transmitted one "row" at a time as discussed elsewhere. The Pixel<br>
Data CRC field (2 bytes) contains a 16-bit CRC of only the Pixel Data. If a CRC<br>
verification of this value fails then the Pixel Data can still be used, but the CRC error<br>
count is incremented.<br>
Scaled Video Stream Images<br>
[00344] The MDD Interface or protocol mechanism, structure, means, or method<br>
provides support for scaled video stream images that allow the host to send an image to<br>
the client that is scaled larger or smaller than the original image, and the scaled image is<br>
copied to a main image buffer. An overview of the Scaled Video Stream functionality<br>
and associated protocol support is provided elsewhere. An ability to support scaled<br>
video streams is defined by or within the Scaled Video Stream Capability Packet, which<br>
is sent in response to a Request Specific Status Packet.<br>
36. Scaled Video Stream Capability Packet<br>
[00345] The Scaled Video Stream Capability Packet defines the characteristics of the<br>
scaled video stream source image in or used by a client. The format of the Scaled Video<br>
Stream Capability Packet is shown generally in FIG. 79. As seen in FIG. 79, in one<br>
embodiment, a Scaled Video Stream Capability Packet is structured to have Packet<br>
Length, Packet Type, cClient ID, Max Number of Streams, Source Max X Size, Source<br>
Max Y size, RGB Capability, Monochrome Capability, Reserved 1, Y Cr Cb Capability,<br>
Reserved 2, and CRC fields. The packet length, in one embodiment, is selected to be a<br>
fixed 20 bytes, as shown in the length field, including the 2-byte cClient ID field, which<br>
is reserved for use for a Client ID, otherwise set to zero, and the CRC field. In one<br>
embodiment, the client indicates an ability to support the Scaled Video Stream<br>
Capability Packet using a parameter value of 143 in the Valid Parameter Reply List of<br>
the Valid Status Reply List Packet.<br>
[00346] The 2-byte Maximum Number of Streams field contains a value to identify the<br>
maximum number of simultaneous scaled video streams that may be allocated at one<br>
time. In one embodiment, a client should deny a request to allocate a scaled video<br>
stream if the maximum number of scaled video streams are already allocated. If less<br>
than the maximum number of scaled video streams are allocated the client may also<br>
deny an allocation request based on other resource limitations in the client.<br>
[00347] The Source Maximum X Size and Y size fields (2 bytes) specify values for the<br>
maximum width and height, respectively, of the scaled video stream source image<br>
expressed as a number of pixels.<br>
[00348] The RGB Capability field uses values to specify the number of bits of<br>
resolution that can be displayed in RGB format. If the scaled video stream cannot use<br>
the RGB format then this value is set equal to zero. The RGB Capability word is<br>
composed of three separate unsigned values with: Bits 3 through 0 defining a maximum<br>
number of bits of blue (the blue intensity) in each pixel, Bits 7 through 4 defining the<br>
maximum number of bits of green (the green intensity) in each pixel, and Bits 11<br>
through 8 defining the maximum number of bits of red (the red intensity) in each pixel,<br>
while Bits 15 through 12 are reserved for future use in future capability definitions, and<br>
are generally set to zero.<br>
[00349] The 1-byte Monochrome Capability field contains a value that specifies the<br>
number of bits of resolution that can be displayed in monochrome format. If the scaled<br>
video stream cannot use the monochrome format then this value is set to zero. Bits 7<br>
through 4 are reserved for future use and should, therefore, be set to zero ('0') for<br>
current applications, although this may change over time, as will be .appreciated by<br>
those skilled in the art. Bits 3 through 0 define the maximum number of bits of<br>
grayscale that can exist in each pixel. These four bits make it possible to specify that<br>
each pixel consists of 1 to 15 bits. If the value is zero, then the monochrome format is<br>
not supported by the scaled video stream.<br>
[00350] The Reserved 1 field (here 1 byte) is reserved for future use in providing<br>
values related to the Scaled Video Stream Packet information or data. Therefore,<br>
currently, all bits in this field are set to a logic '0'. One purpose of this field is to cause<br>
all subsequent 2-byte fields to align to a 16-bit word address and cause 4-byte fields to<br>
align to a 32-bit word address.<br>
[00351] The 2-byte Y Cb Cr Capability field contain values that specify the number of<br>
bits of resolution that can be displayed in Y Cb Cr format. If the scaled video stream<br>
cannot use the Y Cb Cr format then this value is zero. The Y Cb Cr Capability word is<br>
composed of three separate unsigned values with: Bits 3 through 0 defining the<br>
maximum number of bits that specify the Cr sample; Bits 7 through 4 defining the<br>
maximum number of bits that specify the Cb sample; Bits 11 through 8 defining the<br>
maximum number of bits specify the Y sample; and with Bits 15 through 12 being<br>
reserved for future use and is generally set to zero.<br>
[00352] The 1-byte Capability Bits field contains a set of flags that specify capabilities<br>
associated with the scaled video stream. The flags are defined as follows: Bit 0 covers<br>
Pixel data in the Scaled Video Stream Packet can be in a packed format. An example of<br>
packed and byte-aligned pixel data is shown earlier in FIG. 12. Bit 1 is reserved for<br>
future .use and is generally set to zero; Bit 2 is also reserved for future use and is set to<br>
zero; Bit 3 covers scaled video streams that can be specified in the color map data<br>
format. The same color map table is used for the scaled video streams as is used for the<br>
main image buffer and the alpha-cursor image planes. The color map is configured<br>
using the Color Map Packet described elsewhere; and Bits 7 through 4 are reserved for<br>
future use and are generally set to be zero.<br>
[00353] The Reserved 2 field (here 1 byte) is reserved for future use in providing<br>
values related to the Scaled Video Stream Packet information or data. Therefore,<br>
currently, all bits in this field are set to a logic '0'. One purpose of this field is to cause<br>
all subsequent 2-byte fields to align to a 16-bit word address and cause 4-byte fields to<br>
align to a 32-bit word address.<br>
37. Scaled Video Stream Setup Packet<br>
[00354] The Scaled Video Stream Setup Packet is used to define the parameters of the<br>
scaled video stream and the client uses the information to allocate internal storage for<br>
buffering and scaling of the image. A stream may be de-allocated by sending this packet<br>
with the X Image Size and Y Image Size fields equal to zero. Scaled video streams that<br>
have been de-allocated may be reallocated later with the same or different stream<br>
parameters. In one embodiment a client indicates an ability to support the Scaled Video<br>
Stream Setup Packet using a parameter value of 143 in the Valid Parameter Reply List<br>
of the Valid Status Reply List Packet, and by using a non-zero value in the Maximum<br>
Number of Streams field of the Scaled Video Stream Capability Packet.<br>
[00355] The format of the Scaled Video Stream Setup Packet is shown generally in<br>
FIG. 80. As seen in FIG. 80, in one embodiment, a Scaled Video Stream Setup Packet<br>
is structured to have Packet Length Packet Type, hClient, Stream ID, Visual Data<br>
Format Descriptor, Pixel Data Attributes, X Left Edge, Y Top Edge, X Right Edge, Y<br>
Bottom Edge, X Image Size, Y Image Size, and CRC fields.<br>
[00356] The 2-byte Packet Length field specifies the total number of bytes in the<br>
packet not including the packet length field. In one embodiment, this packet length is<br>
fixed at 24. The 2-byte Packet Type field employs a value of 136 to identify the packet<br>
as a Scaled Video Stream Setup Packet. The 2-byte hClient ID field is reserved for<br>
future use as a Client ID, and is generally set to an all bits at logic-zero value for the<br>
moment, or until a protocol user determines what ID values are to be used, as would be<br>
known.<br>
[00357] The Stream ID field uses 2 bytes to specify a unique identifier for the Stream<br>
ID. This value is assigned by the host and ranges in value from zero to the maximum<br>
Stream ID value specified in the Client Capability Packet. The host must manage the<br>
use of Stream ID values carefully to ensure that each active stream is assigned a unique<br>
value, and that streams that are no longer active are de-allocated or reassigned.<br>
[00358] In one embodiment, the Video Data Format Descriptor field uses 2 bytes to<br>
specify the format of each pixel in the Pixel Data in the present stream in the present<br>
packet. The pixel data format should comply with at least one of the valid formats for<br>
the alpha-cursor image plane as defined in the Alpha-Cursor Image Capability Packet.<br>
The Video Data Format Descriptor defines the pixel format for the current packet only<br>
and does not imply that a constant format will continue to be used for the lifetime of a<br>
particular video stream. Fig. 11 illustrates an embodiment of how the Video Data<br>
Format Descriptor is coded, and as discussed above for other packets.<br>
[00359] The 2-byte Pixel Data Attributes filed has values that are interpreted as<br>
follows:<br>
[00360] Bits 1 and 0 select the display where the pixel data is to be routed.<br>
[00361] Bits [1:0] = 11 or 00 - data is displayed to both eyes<br>
[00362] Bits [1:0] = 10 - data is routed to the left eye only.<br>
[00363] Bits [1:0] = 01 - data is routed to the right eye only.<br>
[00364] Bit 2 indicates whether or not the Pixel Data is in interlace format. When Bit 2<br>
is 0, then the Pixel Data is in the standard progressive format. The row number (pixel Y<br>
coordinate) is incremented by 1 when advancing from one row to the next. When Bit 2<br>
is 1, then the Pixel Data is in interlace format. The row number (pixel Y coordinate) is<br>
incremented by 2 when advancing from one row to the next.<br>
[00365] Bit 3 indicates whether or not the Pixel Data is in alternate pixel format. This<br>
is similar to the standard interlace mode enabled by bit 2, but the interlacing is vertical<br>
instead of horizontal. When Bit 3 is 0, the Pixel Data is in the standard progressive<br>
format. The column number (pixel X coordinate) is incremented by 1 as each<br>
successive pixel is received. When Bit 3 is 1, then the Pixel Data is in alternate pixel<br>
format. The column number (pixel X coordinate) is incremented by 2 as each pixel is<br>
received.<br>
[00366] Bit 4 indicates whether the Pixel data is related to the display or the camera.<br>
When Bit 4 is 0, the Pixel Data is to or from the display frame buffer. When Bit 4 is 1,<br>
the Pixel Data is to or from the camera. Bit 5 is reserved for future use and is, therefore,<br>
generally set to be zero.<br>
 [00367] Bits 7 and 6 are the Display Update Bits that specify the frame buffer where<br>
the pixel data is to be written. The effects of the Frame Update Bits are described in<br>
more detail elsewhere. When Bits [7:6] are '01', the Pixel data is written to the offline<br>
image buffer. When Bits [7:6] are '00', the Pixel data is written to the image buffer<br>
used to refresh the display. When Bits [7:6] are '11', the Pixel data is written to all<br>
image buffers. If Bits [7:6] are '10', this is treated as an invalid value. These bits are<br>
currently reserved for future use. In this situation, Pixel data would be ignored and not<br>
written to any of the image buffers.<br>
[00368] Bits 8 through 15 are reserved for future use and are generally be set to logiczero<br>
level or values.<br>
[00369] The 2-byte X Left Edge, Y Top Edge, X Right Edge, Y Bottom Edge fields<br>
specify the X coordinate of the left edge, the Y coordinate of the top edge, the X<br>
coordinate of the right edge, and the bottom edge of the destination image, respectively.<br>
The 2-byte X Image Size and Y Image Size fields specify the width and the height,<br>
respectively, of the source image. The CRC field, again, contain a CRC of all bytes in<br>
the packet including the Packet Length.<br>
38. Scaled Video Stream Acknowledgement Packet<br>
[00370] The Scaled Video Stream Acknowledgement Packet allows a client to<br>
acknowledge the receipt of a Scaled Video Stream Setup Packet. The client can indicate<br>
an ability to support the Scaled Video Stream Acknowledgement Packet via a parameter<br>
value of 143 in the Valid Parameter Reply List of the Valid Status Reply List Packet<br>
and via a non-zero value in the Maximum Number of Streams field of the Scaled Video<br>
Stream Capability Packet.<br>
[00371] The format of the Scaled Video Stream Acknowledgement Packet is shown<br>
generally in FIG. 81. As seen in FIG. 81, in one embodiment, a Scaled Video Stream<br>
Acknowledgement Packet is structured to have Packet Length, Packet Type, cClient,<br>
Stream ID, ACK Code, and CRC fields. The 2-byte Packet Length field is used to<br>
specify the total number of bytes, excluding the packet length field, with a value of 10<br>
for this packet type, while a Packet Type of 137 identifies a packet as a Scaled Video<br>
Stream Acknowledgement Packet.<br>
[00372] The 2-byte cClient ID field is reserved for future use for the Client ID, and is<br>
generally set to zero. The 2-byte Stream ID field specifies a unique identifier for the<br>
77<br>
Stream ID. This is the same value assigned by the host in the Scaled Video Stream<br>
Setup Packet.<br>
[00373] The 2-byte Ack Code field provides values containing a code that describes the<br>
outcome of an attempt to update the specified scaled video stream. In one embodiment,<br>
the codes are defined as follows:<br>
[00374] 0 - The sfream allocation attempt was successful.<br>
1 - the stream de-allocation attempt was successful.<br>
2 - invalid attempt to allocate a stream ID that has already been allocated.<br>
3 - invalid attempt to de-allocate a stream ID that is already de-allocated.<br>
4 - the client does not support scaled video streams<br>
5 - the stream parameters are inconsistent with the capability of the client.<br>
6 - stream ID value larger than the maximum value allowed by the client.<br>
7 - insufficient resources available in the client to allocate the specified stream.<br>
[00375] The 2-byte CRC field contains the CRC of all bytes in the packet including the<br>
Packet Length.<br>
39. Scaled Video Stream Packet<br>
[00376] The Scaled Video Stream Packet is used to transmit the pixel data associated<br>
with a specific scaled video stream. The size of the region reference by this packet is<br>
defined by the Scaled Video Stream Setup Packet. The client can indicate an ability to<br>
support the Scaled Video Stream Packet via a parameter value of 143 in the Valid<br>
Parameter Reply List of the Valid Status Reply List Packet and using a successful<br>
scaled video stream allocation response in the Ack Code field of the Scaled Video<br>
Stream Acknowledgement Packet.<br>
[00377] The format of one embodiment of the Scaled Video Stream Packet is shown<br>
generally in FIG. 82. As seen in FIG. 82, a Scaled Video Stream Packet is structured to<br>
have Packet Length, Packet Type, hClient ID, Stream ED, Parameter CRC, Pixel Count,<br>
Pixel Data, and Pixel Data CRC fields. The 2-byte Packet Type field uses a value of 18<br>
to identify a packet as a Scaled Video Stream Packet. The hClient ID field is reserved<br>
for the Client ID, and generally set to zero. As before, the 2-byte Stream ID field<br>
specifies a unique identifier for the Stream ID. This value is specified by the host in the<br>
Scaled Video Stream Setup Packet and confirmed in the Scaled Video Stream<br>
Acknowledgement Packet.<br>
 [00378] The 2-byte Pixel Count field specifies the number of pixels in the Pixel Data<br>
field below. The 2-byte Parameter CRC field has the CRC of all bytes from the Packet<br>
Length to the Pixel Count. If this CRC fails to check then the entire packet is discarded.<br>
The 2-byte Pixel Data field contains the raw video information that is to be scaled and<br>
then displayed. Data is formatted in the manner described by the Video Data Format<br>
Descriptor field. The data is transmitted a row at a time as defined previously.<br>
[00379] The 2-byte Pixel Data CRC field contains a CRC of only the Pixel Data. If this<br>
CRC fails to check then the Pixel Data can still be used but the CRC error count is<br>
incremented.<br>
40. Request Specific Status Packet<br>
[00380] The Request Specific Status Packet provides a means, mechanism, or method<br>
for a host to request that the client send a capability or status packet back to the host as<br>
specified in this packet. The client returns the packet of the specified type in the next<br>
Reverse Link Encapsulation Packet. The client will set bit 17 in the Client Feature<br>
Capability field of the Client Capability Packet if the client has the capability to respond<br>
to the Request Specific Status Packet. The client can indicate an ability to support the<br>
Request Specific Status Packet using bit 21 of Client Feature Capability field of the<br>
Client Capability Packet.<br>
[00381] The format of one embodiment of a Request Specific Status Packet is shown<br>
generally in FIG. 83. As seen in FIG. 83, a Request Specific Status Packet is structured<br>
to have Packet Length, Packet Type, hClient ID, Status Packet ID, and CRC fields.<br>
Packet Length field specifies the total number of bytes in the packet not including the<br>
packet length field, and is generally fixed at a value of 10 for this packet type. A Packet<br>
Type of 138 identifies the packet as a Request Specific Status Packet. The hClient ID<br>
field (2 bytes) is reserved for future use for a Client ID, and is set to zero for now, while<br>
a 2-byte Status Packet ID field specifies the type of capability or status packet that the<br>
client is going to send to the host. Typical packets types are:<br>
[00382] 66 - Client Capability Packet is sent by the client.<br>
133 - Alpha-Cursor Image Capability Packet is sent by the client.<br>
139 - Valid Status Reply List Packet is sent that identifies the exact types of<br>
capability and status packets that the client can send.<br>
140 - Packet Processing Delay Parameters Packet is sent by the client.<br>
141 - Personal Client Capability Packet is sent by the client.<br>
142 - Client Error Report Packet is sent by the client.<br>
143 - Scaled Video Stream Capability Packet is sent by the client.<br>
144 - Client Identification Packet is sent by the client.<br>
[00383] Packet Types 56 through 63 can be used for manufacturer-specific capability<br>
and status identifiers.<br>
[00384] The CRC field again contains a CRC of all bytes in the packet including the<br>
Packet Length.<br>
41. Valid Status Reply List Packet<br>
[00385] The Valid Status Reply List Packet provides the host with a structure, means,<br>
or method to have a list of status and capability packets to which the client has the<br>
capability to respond. A client can indicate an ability to support the Valid Status Reply<br>
List Packet using bit 21 of Client Feature Capability field of the Client Capability<br>
Packet.<br>
[00386] The format of one embodiment of a Valid Status Reply List Packet is shown<br>
generally in FIG 84. As &gt;seen in FIG. 84, a Valid Status Reply List Packet is structured<br>
to have Packet Length, Packet Type, cClient ID, Number of Values in List, Valid<br>
Parameter Reply List, and CRC fields. The packet length for this type of packet is<br>
generally fixed at a value of 10, and a type value of 139 identifies the packet as a Valid<br>
Status Reply Packet. The cClient ID field is reserved for future use as the Client ID,<br>
and is generally be set to zero. The 2- byte Number of Values in List field specifies the<br>
number of items in the following Valid Parameter Reply List.<br>
[00387] The Valid Parameter Reply List field contains a list of 2-byte parameters that<br>
specify the types of capability or status packets that the client can send to the host. If<br>
the client has indicated that it can respond to the Request Specific Status Packet (using<br>
bit 21 of the Client Feature Capability field the in the Client Capability Packet) then it is<br>
capable of sending at least the Client Capability Packet (Packet Type = 66) and the<br>
Valid Status Reply List Packet (Packet Type = 139). The Packet Types that can be sent<br>
by the client and may be included in this list, along with their respective assignments for<br>
purposes of the one embodiment, are:<br>
[00388] 66 - Client Capability Packet.<br>
133 - Alpha-Cursor Image Capability Packet.<br>
139 - Valid Status Reply List Packet, that identifies the exact types of capability<br>
and status packets that the client can send.<br>
140 - Packet Processing Delay Parameters Packet.<br>
141 - Personal Display Capability Packet.<br>
142 - Client Error Report Packet.<br>
143 - Scaled Video Stream Capability Packet.<br>
the packet. The 1 -byte Horizontal Pixel Delay field contains a value that is an index to<br>
a delay value table (same table as DPVL). The value read from the table is multiplied<br>
by the width (in pixels) of the destination field of the packet. The 1-byte Vertical Pixel<br>
Delay field contains a value that is an index to a delay value table (generally uses the<br>
same table as DPVL). The value read from the table is multiplied by the height (in<br>
pixels) of the destination field of the packet.<br>
[ 00394] The Fixed Delay field uses 1 byte as an index to a delay value table (same table<br>
as DPVL). The value read from the table is a fixed delay parameter that represents a<br>
time required to process the packet that is unrelated to any parameter values specified in<br>
the packet. The total delay, or packet processing completion time delay, is determined<br>
according to the relationship:<br>
[00395] Delay = (PacketProcessingDelay(PixelDelay)-TotalPixels) +<br>
(PacketProcessingDelay(HorizontalPixelDelay)-Width) +<br>
(PacketProcessingDelay(VerticalPixelDelay) -Height) +<br>
PacketProcessingDelay(FixedDelay)<br>
[00396] For some packets, the Total Pixels, Width, or Height do not apply because<br>
those parameters are not referenced in the corresponding packet. In those cases, the<br>
corresponding Pixel Delay parameter is generally set to be zero.<br>
43. Personal Display Capability Packet<br>
[00397] The Personal Display Capability Packet provides a set of parameters that<br>
describe the capabilities of a personal display device, such as a head-mounted display or<br>
display glasses. This enables the host to customize the display information according to<br>
the specific capabilities of a client. A client, on the other hand, indicates an ability to<br>
send the Personal Display Capability Packet by using a corresponding parameter in the<br>
Valid Parameter Reply List of the Valid Status Reply List Packet.<br>
The format of one embodiment of a Personal Display Capability Packet is shown<br>
generally in FIG. 86. As seen in FIG. 86, a Personal Display Capability Packet is<br>
structured to have Packet Length, Packet Type, cClient ID, Sub-Pixel Layout, Pixel<br>
Shape, Horizontal Field of View, Vertical Field of View, Visual Axis Crossig, Lft./Rt.<br>
Image, See Through, Maximum Brightness, Optical Cpability, Minimum IPD,<br>
Maximum IPD, Points of IFeld of Curvature List and CRC fields. In one embodiment,<br>
the Packet Length field value is fixed at 68. A Packet Type value of 141 identifies a<br>
packet as a Personal Display Capability Packet. The cClient ED field is reserved for<br>
future use and is generally set to zero for now.<br>
[00398] The Sub-Pixel Layout field specifies the physical layout of a sub-pixel from<br>
top to bottom and left to right, using values of: 0 to indicate that a sub-pixel layout is<br>
not defined; 1 to indicate red, green, blue stripe; 2 to indicate blue, green, red stripe; 3 to<br>
indicate a quad-pixel, having a 2-by-2 sub-pixel arrangement of red at the top left, blue<br>
at the bottom right, and two green sub-pixels, one at the bottom left and the other at the<br>
top right; 4 to indicate a quad-pixel, with a 2-by-2 sub-pixel arrangement of red at the<br>
bottom left, blue at the top right, and two green sub-pixels, one at the top left and the<br>
other at the bottom right; 5 to indicate a Delta (Triad); 6 to indicate a mosaic with red,<br>
green, and blue overlayed (e.g. LCOS display with field-sequential color); and with<br>
values 7 through 255 being generally reserved for future use.<br>
[00399] The Pixel Shape field specifies the shape of each pixel that is composed of a<br>
specific configuration sub-pixels, using a value of: 0 to indicate that a sub-pixel shape<br>
is not defined; 1 to indicate round; 2 to indicate square; 3 to indicate rectangular; 4 to<br>
indicate oval; 5 to indicate elliptical; and with the values 6 through 255 being reserved<br>
for future use in indicating desired chapes, as can be appreciated by one skilled in the<br>
art.<br>
[00400] A1-byte Horizontal Field of View (HFOV) field specifies the horizontal field<br>
of view in 0.5 degree increments (e.g. if the HFOV is 30 degrees, this value is 60). If<br>
this value is zero then the HFOV is not specified.<br>
[00401] A1-byte Vertical Field of View (VFOV) field specifies the vertical field of<br>
view in 0.5 degree increments (e.g. if the VFOV is 30 degrees, this value is 60). If this<br>
value is zero then the VFOV is not specified.<br>
[00402] Al-byte Visual Axis Crossing field specifies the visual axis crossing in 0.01<br>
diopter (1/m) increments (e.g. if the visual axis crossing is 2.22 meters, this value is 45).<br>
If this value is zero then the Visual Axis Crossing is not specified. {Note: is the<br>
specification of this parameter appropriate for the desired range in most applications?}<br>
[00403] Al-byte Left/Right Image Overlap field specifies the percentage of overlap of<br>
the left and right image. The allowable range of the image overlap in percent is 1 to<br>
100. Values of 101 to 255 are invalid and are generally not to be used. If this value is<br>
zero then the image overlap is not specified.<br>
[00404] A 1-byt.e See Through field specifies the see-through percentage of image. The<br>
allowable range of see-through in percent is 0 to 100. Values of 101 to 254 are invalid<br>
and are not to be used. If this value is 255 then the see-through percentage is not<br>
specified. A1-byte Maximum Brightness field specifies the maximum brightness in<br>
increments of 20 nits (e.g. if the maximum brightness is 100 nits, this value is 5). If this<br>
value is zero then the maximum brightness is not specified.<br>
[00405] A 2-byte Optical Capability Flags field contains various fields that specify<br>
optical capabilities of the display. These bit values are generally assigned according to:<br>
[00406] Bits 15 through 5 are reserved for future use, is generally set to zero.<br>
[00407] Bit 4 selects Eye Glass Focus Adjustment, with a value of '0' meaning the<br>
display has no eye glass focus adjustment, and a value of 1' meaning the display has an<br>
eye glass focus adjustment.<br>
[00408] Bits 3 through 2 select a Binocular Function according to: a value of 0 means<br>
the display is binocular and can display 2-dimensional (2D) images only; 1 means the<br>
display is binocular and can display 3-dimensional (3D) images; 2 means the display is<br>
monocular, and 3 is reserved for future use.<br>
[00409] Bits 1 through 0 select Left-Right Field Curvature Symmetry, with a value of 0<br>
meaning Field curvature not defined. If this field is zero then all field curvature values<br>
from Al through E5 are set to zero except for point C3, which specifies a focal distance<br>
of the display or be set to zero to indicate the focal distance is not specified. A value of<br>
1 means Left and Right displays have the same symmetry; 2 means Left and right<br>
displays are mirrored on the vertical axis (column C); and 3 is reserved for future use.<br>
[00410] The 1-byte Inter-Pupillary Distance (IPD) Minimum field specifies the<br>
minimum inter-pupillary distance in millimeters (mm). If this value is zero then the<br>
minimum inter-pupillary distance is not specified. The 1-byte Inter-Pupillary Distance<br>
(IPD) Maximum field specifies the maximum inter-pupillary distance in millimeters<br>
(mm). If this value is zero then the maximum inter-pupillary distance is not specified.<br>
[00411] The Points of Field Curvature List field contains a list of 25 2-byte parameters<br>
that specify the focal distance in thousandths of a diopter (1/m) with a range of 1 to<br>
65535 (e.g. 1 is 0.001 diopters and 65535 is 65.535 diopters). The 25 elements in the<br>
Points of Field Curvature List are labeled Al through E5 as shown below. The points<br>
are to be evenly distributed over the active area of the display. Column C corresponds<br>
to the vertical axis of the display and row 3 corresponds to the horizontal axis of the<br>
display. Columns A and E correspond to the left and right edges of the display,<br>
respectively. And rows 1 and 5 correspond to the top and bottom edges of the display,<br>
respectively. The order ot the /:&gt; points in me list is: AI, m, ui, ui, m, AZ,<br>
D2, E2, A3, B3, C3, D3, E3, A4, B4, C4, D4, E4, A5, B5, C5, D5, E5.<br>
The CRC field contains a CRC of all bytes in the packet including the Packet Length.<br>
44. Client Error Report Packet<br>
[00412] The Client Error Report Packet acts as a mechanism or means for allowing a<br>
client to provide a list of operating errors to the host. The client may detect a wide<br>
range of errors in the course of its normal operation as a result of receiving certain<br>
commands from the host. Examples of these errors include: the client may have been<br>
commanded to operate in a mode that it does not support, the client may have received a<br>
packet containing certain parameters that are out of range or are beyond the capability<br>
of the client, the client may have been commanded to enter a mode in an improper<br>
sequence. The Client Error Report Packet may be used to detect errors during normal<br>
operation, but is most useful to the system designer and integrator to diagnose problems<br>
in development and integration of host and client systems. A client indicate its ability to<br>
send a Client Error Report Packet using a parameter value of 142 in the Valid Parameter<br>
Reply List of the Valid Status Reply List Packet.<br>
The format of one embodiment of a Client Error Report Packet is shown<br>
generally in FIG. 87A. As seen in FIG. 87 A, a Client Error Report Packet is structured<br>
to have Packet Length, Packet Type, cClient ID, Number of List Items, Error Code List,<br>
and CRC fields, A Packet Type value of 142 identifies a packet as a Client Error<br>
Report Packet. The cClient ID field is reserved for future use and is generally set to<br>
zero for now. The Number of List Items field (2 bytes) specifies the number of items in<br>
the following Error Code List. The Error Code List field (here 8 bytes) is a list<br>
containing one or more Error Report List items. The format of a single Error Report<br>
List item is shown in FIG. 87B.<br>
[00413] In one embodiment, as shown in FIG. 87B, each Error Report List Item is<br>
exactly 4 bytes in length, and has a structure in one embodiment comprising: a 2-byte<br>
Display Error Code field that specifies the type of error being reported, a 2-byte Error<br>
Sub-code field specifies a greater level of detail regarding the error defined by the<br>
Client Error Code packet. The specific definition of each Client Error Code is defined<br>
by the manufacturer of the client. An Error Sub-code does not have to be defined for<br>
every Display Error Code, and in those cases where the Error Sub-code is not defined<br>
the value is set to zero. The specific definition of each Error Sub-code is defined by the<br>
manufacturer of the client.<br>
45. Client Identification Packet<br>
[00414] The Client Identification Packet allows a client to return identifying data in<br>
response to a Request Specific Status Packet. In one embodiment, a client indicates an<br>
ability to send the Client Identification Packet using a parameter value of 144 in the<br>
Valid Parameter Reply List of the Valid Status Reply List Packet. It is useful for the<br>
host to be able to determine the client device manufacturer name and model number by<br>
reading this data from the client. The information may be used to determine if the client<br>
has special capabilities that cannot described in the Client Capability Packet. There are<br>
potentially two methods, means, or mechanisms for reading identification information<br>
from the client. One is through use of the Client Capability Packet, which contains<br>
fields similar to those in the base EDU) structure. The other method is through use of<br>
the Client Identification Packet that contains a richer set of information compared to the<br>
similar fields in the Client Capability Packet. This allows a host to identify<br>
manufacturers that have not been assigned a 3-character EISA code, and allows serial<br>
numbers to contain alphanumeric characters.<br>
The format of one embodiment of a Client Identification Packet is shown<br>
generally in FIG. 88. As seen in FIG. 88, a Client Identification Packet is structured to<br>
have Packet Length, Packet Type, cClient ID, Week of Mfr, Year of Mfr., Length of<br>
Mfr Name, Length of Product Name, Length of Serial Number, Manufacturer Name<br>
String, Product Name Suing, Serial Number String, and CRC fields.<br>
 [00415] The 2 byte Packet Type field contains a value that identifies the packet as a<br>
Client Identification Packet. This value is selected to be 144 in one embodiment. The<br>
cClient ID field (2 bytes) again is reserved for future use for the Client ED, and is<br>
generally set to zero. The CRC field (2 bytes) contains a 16-bit CRC of all bytes in the<br>
packet including the Packet Length.<br>
[00416] A 1 -byte Week of Manufacture field contains a value that defines the week of<br>
manufacture of the display. In at least one embodiment, this value is in the range of 1 to<br>
53 if it is supported by the client. If this field is not supported by the client, then it is<br>
generally set to zero. A 1-byte Year of Manufacture field contains a value that defines<br>
the year of manufacture of the client (display). This value is an offset from the year<br>
1990 as a starting point, although other base years could be used. Years in the range of<br>
1991 to 2245 can be expressed by this field. Example: the year 2003 corresponds to a<br>
Year of Manufacture value of 13. If this field is not supported by the client it shold be<br>
set to a value of zero.<br>
[00417] The Length of Mfr Name, Length of Product Name, and Length of Serial<br>
Number fields each contain 2-byte values that specify the length of the Manufacturer<br>
Name String field including any null termination or null pad characters, the length of the<br>
Product Name String field including any null termination or null pad characters, and the<br>
length of the Serial Number String field including any null termination or null pad<br>
characters, respectively.<br>
[00418] The Manufacturer Name String, Product Name String, and Serial Number<br>
String fields each contain a variable number of bytes specified by the Length Mfr Name,<br>
Product Name, and Serial Number fields, respectively, that contain an ASCII string that<br>
specifies the manufacturer, product name, and alphanumeric serial number of the<br>
display, respectively. Each of these strings are terminated by at least one null character.<br>
46. Alternate Display Capability Packet<br>
[00419] The Alternate Display Capability Packet indicates the capability of the<br>
alternate displays attached to the MDDI client controller. It is sent in response to a<br>
Request Specific Status Packet. When prompted a client device sends an Alternate<br>
Display Capability Packet for each alternate display that is supported. The client can<br>
indicate an ability to send the Alternate Display Capability Packet via a parameter value<br>
of 145 in the Valid Parameter Reply List of the Valid Status Reply List Packet.<br>
 [00420] For MDDI systems operated in internal mode it may be common to have more<br>
than one display connected to an MDDI client controller. An example application is a<br>
mobile phone with a large display on the inside of the flip and a smaller display on the<br>
outside. The Number of Alt Displays field of the Client Capability Packet is used to<br>
report that more than one display is attached and the Alternate Display Capability<br>
Packet reports the capability of each alternate display. The video stream packet<br>
contains 4 bits in the Pixel Data Attributes field to address each alternate display in the<br>
client device.<br>
The format of one embodiment of a Alternate Display Capability Packet is<br>
shown generally in FIG. 89. As seen in FIG. 89, an Alternate Display Capability Packet<br>
is structured to have Packet Length, Packet Type, cClient ID, Alt Display Number,<br>
Reserved 1, Bitmap Width, Bitmap Height, Display Window Width, Display Window<br>
Height, Color Map RGB Width, RGB Capability, Monochrome Cpability, Reserved 2,<br>
Y Cb Cr Capability, Display Feature Capability, Reserved 3, and CRC fields. A Packet<br>
Type value of 145 identifies a packet as a Alternate Display Capability Packet. The<br>
cClient ID field is reserved for a Client ID for future use and generally set to zero.<br>
[00421] The Alt Display Number field uses 1 byte to indicate the identity of the<br>
alternate display with an integer in the range of 0 to 15. The first alternate display is<br>
typically designated as number 0 and the other alternate displays are identified with<br>
unique Alt Display Number values with the largest value used being the total number of<br>
alternate displays minus 1. Values larger than the total number of alternate displays<br>
minus 1 are not used. Example: a mobile phone having a primary display and a caller-<br>
ID display connected to an MDDI client has one alternate display, so the Alt Display<br>
Number of the caller-ID display is zero and the Number of Alt Displays field of the<br>
Client Capability Packet has a value of 1.<br>
[00422] The Reserved 1 field (1 byte) is reserved for future use. All bits in this field<br>
are set to zero. One purpose of this field is to cause all subsequent 2 byte fields to align<br>
to a 16-bit word address and cause 4-byte fields to align to a 32-bit word address.<br>
[00423] The Bitmap Width field uses 2 bytes that specify the width of the bitmap<br>
expressed as a number of pixels. The Bitmap Height field uses 2 bytes that specify the<br>
height of the bitmap expressed as a number of pixels. The Display Window Width field<br>
uses 2 bytes that specify the width of the display window expressed as a number of<br>
pixels. The Display Window Height field uses 2 bytes that specify the height of the<br>
display window expressed as a number of pixels.<br>
 [00424] The Color Map RGB Width field uses 2 bytes that specify the number of bits<br>
of the red, green, and blue color components that can be displayed in the color map<br>
(palette) display mode. A maximum of 8 bits for each color component (red, green, and<br>
blue) can be used. Even though 8 bits of each color component are sent in the Color<br>
Map Packet, only the number of least significant bits of each color component defined<br>
in this field are used. If the display client cannot use the color map (palette) format then<br>
this value is zero. The color map RGB Width word is composed of three separate<br>
unsigned values:<br>
[00425] Bits 3 through 0 define the maximum number of bits of blue in each pixel with<br>
values of 0 to 8 being considered valid. Bits 7 through 4 define the maximum number<br>
of bits of green in each pixel with values of 0 to 8 being considered valid. Bits 11<br>
through 8 define the maximum number of bits of red in each pixel with values of 0 to 8<br>
being considered valid. Bits 14 through 12 are reserved for future use and are generally<br>
set to zero. Bit 15 is used to indicate the ability of a client to accept Color Map pixel<br>
data in packed or unpacked format. When Bit 15 is set to a logic-one level, this<br>
indicates that the client can accept Color Map pixel data in either packed or unpacked<br>
format. If bit 15 is set to a logic-zero, this indicates that the client can accept Color Map<br>
pixel data only in unpacked format.<br>
[00426] RGB Capability field uses 2 bytes to specify the number of bits of resolution<br>
that can be displayed in RGB format. In one embodiment, if the client cannot use the<br>
RGB format then this value is set equal to zero. The RGB Capability word is composed<br>
of three separate unsigned values: Bits 3 through 0 define the maximum number of bits<br>
of blue (the blue intensity) in each pixel, Bits 7 through 4 define the maximum number<br>
of bits of green (the green intensity) in each pixel, and Bits 11 through 8 define the<br>
maximum number of bits of red (the red intensity) in each pixel. Bits 14 through 12 are<br>
reserved for future use and are set to zero. Bit 15 is used to indicate the ability of a<br>
client to accept RGB pixel data in packed or unpacked format. When Bit 15 is set to a<br>
logic-one level, this indicates that the client can accept RGB pixel data in either packed<br>
or unpacked format. If bit 15 is set to a logic-zero, this indicates that the client can<br>
accept RGB pixel data only in unpacked format.<br>
[00427] The 1 byte Monochrome Capability field contains a value or information to<br>
specify the number of bits of resolution that can be displayed in monochrome format. If<br>
the client cannot use the monochrome format then this value is set equal to zero. Bits 6<br>
through 4 are reserved for future use and are generally set to zero. Bits 3 through 0<br>
define the maximum number of bits of grayscale that can exist in each pixel. These four<br>
bits make it possible to specify that each pixel consists of 1 to 15 bits. If the value is<br>
zero then the monochrome format is not supported by the client. Bit 7 when set to one<br>
indicates that the client can accept monochrome pixel data in either packed or unpacked<br>
format. If bit 7 is set to zero this indicates that the client can accept monochrome pixel<br>
data only in unpacked format.<br>
[00428] The Reserved 2 field is a 1 byte wide field reserved for future use and<br>
generally has all bits in this field set to logic-zero level. In one embodiment, one<br>
purpose of this field is to cause all subsequent 2 byte fields to align to a 16-bit word<br>
address and cause 4-byte fields to align to a 32-bit word address.<br>
[00429] A 2-byte Y Cb Cr Capability field specifies the number of bits of resolution<br>
that can be displayed in Y Cb Cr format. If the client cannot use the Y Cb Cr format<br>
then this value is zero. The Y Cb Cr Capability word is composed of three separate<br>
unsigned values: Bits 3 through 0 define the maximum number of bits that specify the<br>
Cb sample, Bits 7 through 4 define the maximum number of bits that specify the Cr<br>
sample, Bits 11 through 8 define the maximum number of bits that specify the Y<br>
sample, and Bits 14 through 12 are reserved for future use and are set to zero. Bit 15<br>
when set to one indicates that the client can accept Y Cb Cr pixel data in either packed<br>
or unpacked format. If bit 15 is set to zero this indicates that the client can accept Y Cb<br>
Cr pixel data only in unpacked format.<br>
[00430] A 1 byte Bayer Capability field specifies the number of bits of resolution, pixel<br>
group, and pixel order that can be transferred in Bayer format. If the client cannot use<br>
the Bayer format then this value is set at zero. The Bayer Capability field is composed<br>
of the following values: Bits 3 through 0 define the maximum number of bits of<br>
intensity that exist in each pixel, Bits 5 through 4 define the pixel group pattern that<br>
may be required, Bits 8 through 6 define a pixel order that is required, and Bits 14<br>
through 9 are reserved for future use and are set to zero. Bit 15 when set to one<br>
indicates that the client can accept Bayer pixel data in either packed or unpacked format.<br>
If bit 15 is set to zero this indicates that the client can accept Bayer pixel data only in<br>
unpacked format<br>
[00431] The 2-byte CRC field contains a 16-bit CRC of all bytes in the packet<br>
including the Packet Length.<br>
47. Register Access Packet<br>
[00432] The Register Access Packet provides either a host or a client with a means,<br>
mechanism, or method to access configuration and status registers in the opposite end of<br>
the MDDI link. These registers are likely to be unique for each display or device<br>
controller. These registers already exist in many displays that require setting<br>
configurations, modes of operation, and have other useful and necessary settings. The<br>
Register Access Packet allows the MDDI host or client to both write to a register and<br>
request to read a register using the MDDI link. When the host or client requests to read<br>
a register the opposite end should respond by sending the register data in the same<br>
packet type, but also by indicating that this is the data read from a particular register<br>
with the use of the Read/Write Info field. The Register Access Packet may be used to<br>
read or write multiple registers by specifying a register count greater than 1. A client<br>
indicates an ability to support the Register Access Packet using bit 22 of Client Feature<br>
Capability field of the Client Capability Packet.<br>
The format of one embodiment of a Register Access Packet is shown generally<br>
in FIG. 90. As seen in FIG. 90, a Register Access Packet is structured to have Packet<br>
Length, Packet Type, bClient ID, Read/Write Flags, Register Address, Parameter CRC,<br>
Register Data List and Register Data CRC fields. A Packet Type value of 146<br>
identifies a packet as Register Access Packet. The bClient ID field is reserved for future<br>
use and is generally set to zero for now.<br>
[00433] The 2-byte Read/Write Flags field specifies the specific packet as either a<br>
write, or a read, or a response to a read, and provides a count of the data values.<br>
[00434] Bits 15 through 14 act as Read/Write Flags. If Bits[15:14] are '00' then this<br>
packet contains data to be written to a register addressed by the Register Address field.<br>
The data to be written to the specified registers is contained in the Register Data List<br>
field. If Bits[15:14] are '10' then this is a request for data from one or more registers<br>
addressed by the Register Address field. If Bits[15:14] are '11' then that packet<br>
contains data that was requested in response to a Register Access Packet having bits<br>
15:14 of the Read/Write Flags set to '10'. The Register Address field contains the<br>
address of the register corresponding to the first Register Data List item, and the<br>
Register Data List field contains data that was read from the address or addresses. If<br>
Bits[15:14] are '01' this is treated as an invalid value, this value is reserved for future<br>
use and is not used.<br>
 [00435] Bits 13:0 use a 14-bit unsigned integer to specify the number of 32-bit Register<br>
Data items to be transferred in the Register Data List field. If bits 15:14 equal '00' then<br>
bits 13:0 specify the number of 32-bit register data items that are contained in the<br>
Register Data List field to be written to registers starting at the register specified by the<br>
Register Address field. If bits 15:14 equal '10' then bits 13:0 specify the number of 32-<br>
bit register data items that the receiving device sends to a device requesting that the<br>
registers be read. The Register Data List field in this packet contain no items and is of<br>
zero length. If bits 15:14 equal '11' then bits 13:0 specify the number of 32-bit register<br>
data items that have been read from registers that are contained in the Register Data List<br>
field. Bits 15:14 are not currently set equal to '01', which is considered an invalid<br>
value, and otherwise reserved for future designations or use.<br>
[00436] The Register Address field uses 4 bytes to indicate the register address that is<br>
to be written to or read from. For addressing registers whose addressing is less than 32<br>
bits, the upper bits are set to zero.<br>
[00437] The 2-byte Parameter CRC field contains a CRC of all bytes form the Packet<br>
Length to the Register Address. If this CRC fails to check then the entire packet is<br>
discarded.<br>
[00438] The Register Data List field contains a list of 4-byte register data values to be<br>
written to client registers or values that were read from client device registers.<br>
[00439] The 2-byte Register Data CRC field contains a CRC of only the Register Data<br>
List. If this CRC fails to check then the Register Data may still be used, but the CRC<br>
error count is incremented.<br>
D. Packet CRC<br>
[00440] The CRC fields appear at the end of the packets and sometimes after certain<br>
more critical parameters in packets that may have a significantly large data field, and<br>
thus, an increased likelihood of errors during transfer. In packets that have two CRC<br>
fields, the CRC generator, when only one is used, is re-initialized after the first CRC so<br>
that the CRC computations following a long data field are not affected by the<br>
parameters at the beginning of the packet.<br>
[00441] In an exemplary embodiment, the polynomial used for the CRC calculation is<br>
known as the CRC-16, or X16 + X15 + X2 + XO. A sample implementation of a CRC<br>
generator and checker 3600 useful for implementing the invention is shown in FIG. 36.<br>
In FIG. 36, a CRC register 3602 is initialized to a value of 0x0001 just prior to transfer<br>
of the first bit of a packet which is input on the Tx_MDDI_Data_Before_CRC line, then<br>
the bytes of the packet are shifted into the register starting with the LSB first. Note that<br>
the register bit numbers in this figure correspond to the order of the polynomial being<br>
used, and not the bit positions used by the MDDI. It is more efficient to shift the CRC<br>
register in a single direction, and this results in having CRC bit 15 appear in bit position<br>
0 of the MDDI CRC field, and CRC register bit 14 in MDDI CRC field bit position 1,<br>
and so forth until MDDI bit position 14 is reached.<br>
[00442] As an example, if the packet contents for the Client Request and Status Packets<br>
are: OxOOOc, 0x0046, 0x000, 0x0400, 0x00, 0x00, 0x0000 (or represented as a sequence<br>
of bytes as: OxOc, 0x00, 0x46, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00),<br>
and are submitted using the inputs of the multiplexors 3604 and 3606, and NAND gate<br>
3608, the resulting CRC output on the Tx_MDDI_Data_With_CRC line is Oxd9aa (or<br>
represented as a sequence as Oxaa, Oxd9).<br>
[00443] When CRC generator and checker 3600 is configured as a CRC checker, the<br>
CRC that is received on the Rx_MDDI__Data line is input to multiplexor 3604 and<br>
NAND gate 3608, and is compared bit by bit with the value found in the CRC register<br>
using NOR gate 3610, exclusive-OR (XOR) gate 3612, and AND gate 3614. If there<br>
are any errors, as output by AND gate 3614, the CRC is incremented once for every<br>
packet that contains a CRC error by connecting the output of gate 3614 to the input of<br>
register 3602. Note that the example circuit shown in the diagram of FIG. 36 can output<br>
more than one CRC error signal within a given CHECK_CRC_NOW window (see FIG.<br>
37B). Therefore, the CRC error counter generally only counts the first CRC error<br>
instance within each interval where CHECK_CRC_NOW is active. If configured as a<br>
CRC generator the CRC is clocked out of the CRC register at the time coinciding with<br>
the end of the packet.<br>
[00444] The timing for the input and output signals, and the enabling signals, is<br>
illustrated graphically in FIGS. 37A and 37B. The generation of a CRC and<br>
transmission of a packet of data are shown in FIG. 37A with the state (0 or 1) of the<br>
Gen_Reset, Check_CRC_Now, Generate_CRC_Now, and Sending_MDDI_Data<br>
signals, along with the Tx_MDDIJData_Before_CRC and Tx_MDDI_Data_With_CRC<br>
signals. The reception of a packet of data and checking of the CRC value are shown in<br>
FIG. 37B, with the state of the Gen_Reset, Check_CRC_Now, Generate_CRC_Now,<br>
and SendingJVIDDLData signals, along with the RxJVEDDIJData and CRC error<br>
signals.<br>
E. Error Code Overload for Packet CRC<br>
[00445] Whenever only data packets and CRC are being transferred between the host<br>
and client, there are no error codes being accommodated. The only error is a loss of<br>
synchronization. Otherwise, one has to wait for the link to timeout from a lack of a<br>
good data transfer path or pipeline and then reset the link and proceed. Unfortunately,<br>
this is time consuming and somewhat inefficient.<br>
[00446J For use in one embodiment, a new technique has been developed in which the<br>
CRC portion of packets is used to transfer error code information. This is generally<br>
shown in FIG. 65. That is, one or more error codes are generated by the processors or<br>
devices handling the data transfer which indicate specific predefined errors or flaws that<br>
might occur within the communication processing or link. When an error is<br>
encountered, that the appropriate error code is generated and transferred using the bits<br>
for the CRC of a packet. That is, the CRC value is overloaded, or overwritten, with the<br>
desired error code, which can be. detected on the receiving end by an error monitor or<br>
checker that monitors the values of the CRC field. For those cases in which the error<br>
code matches the CRC value for some reason, the compliment of the error is transferred<br>
to prevent confusion.<br>
[00447] In one embodiment, to provide a robust error warning and detection system,<br>
the error code may be transferred several times, using a series of packets, generally all,<br>
that are transferred or sent after the error has been detected. This occurs until the point<br>
at which the condition creating the error is cleared from the system, at which point the<br>
regular CRC bits are transferred without overloading by another value.<br>
[00448] This technique of overloading the CRC value provides a much quicker<br>
response to system errors while using a minimal amount of extra bits or fields.<br>
[00449] As shown in FIG. 66, a CRC overwriting mechanism or apparatus 6600 is<br>
shown using an error detector or detections means 6602, which can form part of other<br>
circuitry previously described or known, detects the presence or existence of errors<br>
within the communication link or process. An error code generator or means 6604,<br>
which can be formed as part of other circuitry or use techniques such as look up tables<br>
to store pre-selected error messages, generates one or more error codes to indicate<br>
specific predefined errors or flaws that have been detected as occurring. It is readily<br>
understood that devices 6602 and 6604 can be formed as a single circuit or device as<br>
desired, or as part of a programmed sequence of steps for other known processors and<br>
elements.<br>
[00450] A CRC value comparator or comparison means 6606 is shown for checking to<br>
see if the selected error code or codes are the same as the CRC value being transferred.<br>
If that is the case then a code compliment generator or generation means or device is<br>
used to provide the compliment of the error codes as to not be mistaken as the original<br>
CRC pattern or value and confuse or complicate the detection scheme. An error code<br>
selector or selection means element or device 6610 then selects the error code or value it<br>
is desired to insert or overwrite, or their respective compliments as appropriate. An<br>
error code CRC over-writer or over writing mechanism or means 6612 is a device that<br>
receives the data stream, packets, and the desired codes to be inserted and overwrites the<br>
corresponding or appropriate CRC values, in order to transfer the desired error codes to<br>
a receiving device.<br>
[00451] As mentioned, the error code may be transferred several times, using a series of<br>
packets, so the over-writer 6612 may utilize memory storage elements in order to<br>
maintain copies of the codes during processing or recall these codes from previous<br>
elements or other known storage locations which can be used to store or hold their<br>
values as needed, or as desired.<br>
[00452] The general processing the overwriting mechanism of FIG. 66 is implementing<br>
is shown in additional detail in FIGS. 67A and 67B. In 67A an error, one or more, is<br>
detected in step 6702 in the communication data or process and an error code is selected<br>
in step 6704 to indicate this condition. At the same time, or at an appropriate point, the<br>
CRC value to be replaced is checked in a step 6706, and compared to the desired error<br>
code in step 6708. The result of this comparison, as discussed earlier, is a determination<br>
as to whether or not the desired code, or other representative values, will be the same as<br>
the CRC value present. If this is the case, then processing proceeds to a step 6712<br>
where the compliment, or in some cases another representative value, as desired, is<br>
selected as the code to insert. One it has been determined what error codes or values<br>
are to be inserted in steps 6710 and 6714, that appropriate code is selected for insertion.<br>
These steps are illustrated as separate for purposes of clarity but generally represent a<br>
single choice based on the output of the step 6708 decision. Finally, in step 6716 the<br>
appropriate values are overwritten in the CRC location for transfer with the packets<br>
being targeted by the process.<br>
 [00453] On the packet reception side, as shown in FIG. 67B, the packet CRC values are<br>
being monitored in a step 6722. Generally, the CRC values are being monitored by one<br>
or more processes within the system to determine if an error in data transfer has<br>
occurred and whether or not to request a retransmission of the packet or packets, or to<br>
inhibit further operations and so forth, some of which is discussed above. As part of<br>
such monitoring the information can also be used to compare values to known or<br>
preselected error codes, or representative values and detect the presence of errors.<br>
Alternatively, a separate error detection process and monitor can be implemented. If a<br>
code appeal's to be present it is extracted or otherwise noted in step 6724 for further<br>
processing. A determination can be made in step 6726 as to whether or not this is the<br>
actual code or a compliment, in which case an additional step 6728 is used to translate<br>
the value to the desired code value. In either case the resulting extracted code,<br>
compliment, or other recovered values are then used to detect what error has occurred<br>
form the transmitted code in step 6730.<br>
V. Link Hibernation<br>
[00454] The MDDI link can enter the hibernation state quickly and wake up from<br>
hibernation quickly. This responsiveness allows a communicating system or device to<br>
force the MDDI link into hibernation frequently to reduce power consumption, since it<br>
can wake up again for use very quickly. In onfe embodiment, as an external mode client<br>
wakes up from hibernation for the first time it does so at a data rate and with strobe<br>
pulse timing that is consistent with a 1 Mbps rate, that is, the MDDI_Stb pair should<br>
toggle at a 500 kHz rate. Once characteristics of the client have been discovered by or<br>
communicated to the host, then the host may wake up the link at generally any rate from<br>
1 Mbps to the maximum rate at which the client can operate. Internal mode clients may<br>
wake up at any rate at which both the host and client can operate. This is also generally<br>
applicable to the first time an internal mode client wakes up.<br>
[00455] In one embodiment, when the link wakes up from hibernation the host and<br>
client exchange a sequence of pulses. These pulses can be detected using low-speed<br>
line receivers that consume only a fraction of the' current as the differential receivers<br>
required to receive the signals at the maximum link operating speed. Either the host or<br>
client can wake up the link, so the wake-up protocol is designed to handle possible<br>
contention that can occur if both host and client attempt to wake up simultaneously.<br>
 [00456] During the hibernation state the MDDI_Data and MDDI_Stb differential<br>
drivers are disabled and the differential voltage across all differential pairs is zero volts.<br>
The differential line receivers used to detect the sequence of pulses during the wake-up<br>
from hibernation have an intentional voltage offset. In one embodiment, the threshold<br>
between a logic-one and logic-zero level in these receivers is approximately 125 mV.<br>
This causes an un-driven differential pair to be seen as a logic-zero level during the link<br>
wake-up sequence.<br>
[00457] In order to enter a Hibernation State, the host sends 64 MDDI_Stb cycles after<br>
the CRC of the Link Shutdown Packet. The host disables the MDDI_DataO output of<br>
the host in the range of 16 to 56 MDDI_Stb cycles (including output disable<br>
propagation delays) after the CRC. The host finishes sending the 64 MDDIJStb cycles<br>
after the CRC of the Link Shutdown packet before it initiates the wake-up sequence. In<br>
one embodiment, the host-initiated wake-up is defined as the host having to wait at least<br>
100 nsec after MDDI_DataO reaches a valid logic-one level before driving pulses on<br>
MDDLStb. In one embodiment, the client waits at least 60 MDDI_Stb cycles after the<br>
CRC of the Link Shutdown Packet before it drives MDDI_DataO to a logic-one level to<br>
attempt to wake-up the host.<br>
[00458] In order to "wake-up" from a Hibernation State, several actions or processes<br>
are undertaken. When the client, here a display, needs data or communication, service,<br>
from the host it drives the MDDIJDataO line to a logic-one state for around 70 to 1000<br>
(j,sec, while MDDI_Stb is inactive and keeps MDDIJDataO driven to a logic-one level<br>
for about 70 MDDI_Stb cycles (over a range of 60 to 80) after MDDI_Stb becomes<br>
active, although other periods can be used as desired. The client then disables the<br>
MDDI_DataO driver by placing it into a high-impedance state.<br>
[00459] If MDDI_Stb is active during hibernation, although unlikely, then the client<br>
might only drive MDDIJDataO to a logic-one state for about 70 MDDI_Stb cycles (over<br>
a range of 60 to 80). This action causes the host to start or restart data traffic on the<br>
forward link (208) and to poll the client for its status.<br>
[00460] The host must detect the presence of the request pulse and begins the startup<br>
sequence of driving MDDIJDataO to a logic-one level for about 150 MDDI_Stb cycles<br>
(a range of 140 to 160) and to logic-zero for about 50 MDDI_Stb cycles (a range of 40<br>
to 60. The display should not send a service request pulse if it detects MDDIJDataO in<br>
the logic-one state for more than 70 MDDI_Stb cycles. After the host drives<br>
MDDIJDataO to a logic-zero level for a duration of 50 MDDI_Stb cycles then the host<br>
starts sending packets on the link. The first packet sent is a Sub-frame Header Packet.<br>
The nature of selection of the times and tolerances of time intervals related to the<br>
hibernation processing and start up sequence are discussed further below. (See FIGS.<br>
68A-C below)<br>
[00461] The host may initiate the wake-up by first enabling MDDI_Stb and<br>
simultaneously drive it to a logic-zero level. MDDI_Stb should not be driven to a logicone<br>
level until pulses are output as described below. After MDDI_Stb raches a vlai<br>
logic-zero level the host enables MDDI_DataO and simultaneously drives it to a logicone<br>
level. MDDI_DataO should not be driven to a logic-zero level until the interval<br>
where it is driven to a logic-zero level for an interval of 50 MDDI_Stb pulses as<br>
described below. The host should wait at least 100 nsec after MDDI_DataO reaches a<br>
valid logic-one level before driving pulses on MDDLStb. This timing relationship<br>
occurs while considering the worst-case output enable delays. This substantially<br>
guarantees that a client has sufficient time to fully enable its MDDI_Stb receiver after<br>
being awakened by a logic-one level on MDDI_DataO that was driven by the host.<br>
[00462] An example of the processing steps for a typical client service request event<br>
3800 with no contention is illustrated in FIG. 38, where the events are labeled for<br>
convenience in illustration using the letters A, B, C, D, E, F, and G. The process<br>
commences at point A when the host sends a Link Shutdown Packet to the client device<br>
to inform it that the link will transition to a low-power hibernation state. In a next step,<br>
the host enters the low-power hibernation state by disabling the MDDI_DataO driver<br>
and setting the MDDI_Stb driver to a logic zero, as shown at point B. MDDI_DataO is<br>
driven to a logic-zero level by a high-impedance bias network. After some period of<br>
time, the client sends a service request pulse to the host by driving MDDI_DataO to a<br>
logic one level as seen at point C. The host still asserts the logic-zero level using the<br>
high-impedance bias network, but the driver in the client forces the line to a logic one<br>
level. Within 50 usec, the host recognizes the service request pulse, and asserts a logic<br>
one level on MDDI_DataO by enabling its driver, as seen at point D. The client then<br>
ceases from attempting to assert the service request pulse, and the client places its driver<br>
into a high-impedance state, as seen at point E. The host drives MDDI_DataO to a<br>
logic-zero level for 50 u,sec, as shown at point F, and also begins to generate MDDI_Stb<br>
in a manner consistent with the logic-zero level on MDDI_DataO. After asserting<br>
MDDI_DataO to a logic-zero level and driving MDDI_Stb for 50 psec, the host begins<br>
to transmit data on the forward link by sending a Sub-frame Header Packet, as shown at<br>
point G.<br>
[00463] A similar example is illustrated in FIG. 39 where a service request is asserted<br>
after the link restart sequence has begun, and the events are again labeled using the<br>
letters A, B, C, D, E, F, and G. This represents a worst case scenario where a request<br>
pulse or signal from the client comes closest to corrupting the Sub-frame Header Packet.<br>
The process commences at point A when the host again sends a Link Shutdown Packet<br>
to the client device to inform it that the link will transition to a low-power hibernation<br>
state. In a next step, the host enters the low-power hibernation state by disabling the<br>
MDDI_DataO driver and setting the MDDI_Stb driver to a logic-zero level, as shown at<br>
point B. As before, MDDI_DataO is driven to a logic-zero level by a high-impedance<br>
bias network. After a period of time, the host begins the link restart sequence by driving<br>
MDDI_DataO to a logic-one level for 150 usec as seen at point C. Prior to 50 u,sec<br>
passing after the link restart sequence begins the display also asserts MDDI_DataO for a<br>
duration of 70 fisec, as seen at point D. This happens because the display has a need to<br>
request service from the host and does not recognize that the host has already begun the<br>
link restart sequence. The client then ceases attempting to assert the service request<br>
pulse, and the client places its driver into a high-impedance state, as seen at point E.<br>
The host continues to drive MDDI_DataO to a logic-one level. The host drives<br>
MDDIJDataO to a logic-zero level for 50 |j,sec, as shown at point F, and also begins to<br>
generate MDDI_Stb in a manner consistent with the logic zero level on MDDI_DataO.<br>
After asserting MDDI_DataO to a logic-zero level, and driving MDDI_Stb for 50 (J,sec,<br>
the host begins to transmit data on the forward link by sending a Sub-frame Header<br>
Packet, as shown at point G.<br>
[00464] From the above discussion, one sees that the prior solution involved having the<br>
host go through two states as part of a wakeup sequence. For the first state, the host<br>
drives the MDDI_DataO signal high for 150 us, and then drives the MDDI_DataO signal<br>
low for 50us while activating the MDDI_Stb line, and then begins to transmit MDDI<br>
packets. This process works well to advance the state of the art in terms of data rates<br>
achievable using the MDDI apparatus and methods. However, as stated earlier, more<br>
speed in terms of reduced response time to conditions or being able to more quickly<br>
select the next step or process, are the ability to simplify processing or elements, are<br>
always in demand.<br>
 [00465] Applicants have discovered a new inventive approach to wake-up processing<br>
and timing in which the host uses a clock cycle based timing for the signal toggling. In<br>
this configuration, the host starts toggling MDDI_Stb from 0 to 10 u,sec after the host<br>
drives the MDDIJDataO signal high at the beginning of the wake-up sequence, and does<br>
not wait until the signal is driven low. During a wake-up sequence, the host toggles<br>
MDDI_Stb as though the MDDI_DataO signal were always at a logic-zero level. This<br>
effectively removes the concept of time from the client side, and the host changes from<br>
the prior 150 us and 50 u.s periods for the first two states, to 150 clock cycles and 50<br>
clock cycles, for these periods.<br>
[00466] The host now becomes responsible for driving that data line high, and within<br>
10 clock cycles starting to transmit a strobe signal as if the data line was zero. After the<br>
host has driven the data line high for 150 clock cycles, the host drives the data line low<br>
for 50 clock cycles while continuing to transmit the strobe signal. After it has<br>
completed both of these processes, the host can begin to transmit the first sub-frame<br>
header packet.<br>
[00467] On the client side, the client implementation can now use the generated clock<br>
to calculate the number of clock cycles that the data line is first high, and then low. The<br>
number of clock cycles that need to occur in both the data line driven high state is 150<br>
and data line driven low state is 50. This means that for a proper wakeup sequence, the<br>
client should be able to count at least 150 continuous clock cycles of the data line being<br>
high, followed by at least 50 continuous clock cycles of the data line being low. Once<br>
these two conditions are met, the client can begin to search for the unique word of the<br>
first sub-frame. A break in this pattern is used as a basis to return the counters to an<br>
initial state in which the client again looks for the first 150 continuous clock cycles of<br>
the data line being high.<br>
[00468] A client implementation of the invention for host based wakeup from<br>
hibernation is very similar to the initial start-up case except that the clock rate is not<br>
forced to start at IMbps., as discussed earlier. Instead the clock rate can be set to<br>
resume at whatever previous rate was active when the communication link went into<br>
hibernation. If the host begins transmission of a strobe signal as described above, the<br>
client should be able to again count at least 150 continuous clock cycles of the data line<br>
being high, followed by at least 50 continuous clock cycles of the data line being low.<br>
Once these two conditions have been met, the client can begin the search for the unique<br>
word.<br>
100<br>
[00469] A client implementation of the invention for client based wakeup from<br>
hibernation is similar to the host based wakeup except that it starts by having the client<br>
driving the data line. The client can asynchronously drive the data line without a clock<br>
to wake up the host device. Once the host recognizes that the data line is being driven<br>
high by the client, it can begin its wakeup sequence. The client can count the number of<br>
clock cycles generated by the host starting or during its wakeup process. Once the<br>
client counts 70 continuous clock cycles of the data being high, it can stop driving the<br>
data line high. At this point, the host should already be driving the data line high as<br>
well. The client can then count another 80 continuous clock cycles of the data line<br>
being high to reach the 150 clock cycles of the data line being high, and can then look<br>
for 50 clock cycles of the data line being low. Once these three conditions have been<br>
met the client can begin to look for the unique word.<br>
[00470] An advantage of this new implementation of wake-up processing is that it<br>
removes the need for a time measuring device. Whether this is an oscillator, or<br>
capacitor discharge circuit, or other such known devices, the client no longer needs such<br>
external devices to determine the start up conditions. This saves money and circuit area<br>
when implementing controllers, counters, and so forth on a client device board. While<br>
this may not be as advantageous to the client, for the host, this technique should also<br>
potentially simplify the host in terms of very high density logic (VHDL) being used for<br>
core circuitry. The power consumption of using the data and strobe lines as the wakeup<br>
notification and measurement source will also be lower since no external circuitry will<br>
need to be running for the core elements to be waiting for a host based wakeup. The<br>
..number of cycles or clock periods used are exemplary and other periods can be used as<br>
will be apparent to one skilled in the ait.<br>
[00471] An advantage of this new implementation of wake-up processing is that it<br>
removes the need for a time measuring device. Whether this is an oscillator, or<br>
capacitor discharge circuit, or other such known devices, the client no longer needs such<br>
external devices to determine the start up conditions. This saves money and circuit area<br>
when implementing controllers, counters, and so forth on a client device board. While<br>
this may not be as advantageous to the client, for the host, this technique should also<br>
potentially simplify the host in terms of very high density logic (VHDL) being used for<br>
core circuitry. The power consumption of using the data and strobe lines as the wakeup<br>
notification and measurement source will also be lower since no external circuitry will<br>
need to be running for the core elements to be waiting for a host based wakeup.<br>
[00472] To clarify and illustrate the operation of this new technique, the timing of<br>
MDDI_DataO, MDDI_Stb, and various operations relative to the clock cycles are shown<br>
in FIGS. 68A, 68B, and 68C.<br>
[00473] An example of the processing steps for a typical Host-initiated Wake-up with<br>
no contention is illustrated in FIG. 68A, where the events are again labeled for<br>
convenience in illustration using the letters A, B, C, D, E, F, and G. The process<br>
commences at point A when the host sends a Link Shutdown Packet to the client device<br>
to inform it that the link will transition to a low-power hibernation state. In a next step,<br>
point B, the host toggles MDDI_Stb for about 64 cycles (or as desired for system<br>
design) to allow processing by the client to be completed prior to stopping MDDI_Stb<br>
from toggling, which stops the recovered clock in the client device. The host also<br>
initially sets MDDI_DataO to logic-zero level and then disables the MDDI_DataO output<br>
in the range of 16 to 48 cycles (generally including output disable propagation delays)<br>
after the CRC. It may be desirable to place high-speed receivers for MDDI_DataO and<br>
MDDI_Stb in the client in a low power state some time after the 48 cycles after the<br>
CRC and prior to the next stage (C). The client places its high-speed receivers for<br>
MDDIJDataO and MDDI_Stb into hibernation any time after the rising edge of the 48th<br>
MDDI_Stb cycle after the CRC of the Link Shutdown Packet. It is recommended that<br>
the client place its high-speed receivers for MDDIJDataO and MDDI_Stb into<br>
hibernation before the rising edge of the 64th MDDI_Stb cycle after the CRC of the Link<br>
Shutdown Packet.<br>
[00474] The host enters the low-power hibernation state at point or step C, by disabling<br>
the MDDIJDataO and MDDI_Stb drivers and placing a host controller in a low power<br>
hibernation state. One can also set the MDDI_Stb driver to a logic-zero level (using a<br>
high-impedance bias network) or to continue toggling during hibernation, as desired.<br>
The client is also in a low power level hibernation state.<br>
[00475] After some period of time, the host commences the link restart sequence at<br>
point D, by enabling the MDDI_DataO and MDDI_Stb driver output. The host drives<br>
MDDIJDataO to a logic-one level and MDDI_Stb to a logic-zero level for as long as it<br>
should take for the drivers to fully enable their respective outputs. The host typically<br>
waits around 200 nanoseconds after these outputs reach desired logic levels before<br>
driving pulses on MMDI_Stb. This allows the client time to prepare to receive.<br>
[00476] With the host drivers enabled and MDDI_DataO being driven to a logic-one<br>
level, the host begins to toggle MDDI_Stb for a duration of 150 MDDI_Stb cycles, as<br>
seen at point E. The host drives MDDI_DataO to a logic zero level for 50 cycles, as<br>
shown at point F, and the client begins to look for the Sub-frame Header Packet after<br>
MDDIJDataO is at a logic-zero level for 40 MDDI_Stb cycles. The host begins to<br>
transmit data on the forward link by sending a Sub-frame Header Packet, as shown at<br>
point G.<br>
[00477] An example of the processing steps for a typical Client-initiated Wake-up with<br>
no contention is illustrated in FIG. 68B, where the events are again labeled for<br>
convenience in illustration using the letters A, B, C, D, E, F, G, H, and I. As before, the<br>
process commences at point A when the host sends a Link Shutdown Packet to inform<br>
the client that the link will transition to the low power state.<br>
[00478] At point B, the host toggles MDDI_Stb for about 64 cycles (or as desired for<br>
system design) to allow processing by the client to be completed prior to stopping<br>
MDDI_Stb from toggling, which stops the recovered clock in the client device. The<br>
host also initially sets MDDI_DataO to a logic-zero level and then disables the<br>
MDDIJDataO output in the range of 16 to 48 cycles (generally including output disable<br>
propagation delays) after the CRC. It may be desirable to place high-speed receivers for<br>
MDDI_DataO and MDDI_Stb in the client in a low power state some time after the 48<br>
cycles after the CRC and prior to the next stage (C).<br>
[00479] The host enters the low-power hibernation state at point or step C, by disabling<br>
the MDDI_DataO and MDDI_Stb drivers and placing a host controller in a low power<br>
hibernation state. One can also set the MDDIJStb driver to a logic-zero level (using a<br>
high-impedance bias network) or to continue toggling during hibernation, as desired.<br>
The client is also in a low power level hibernation state.<br>
[00480] After some period of time, the client commences the link restart sequence at<br>
point D, by enabling the MDDIJStb receiver, and also enabling an offset in the<br>
MDDI_Stb receiver to guarantee the state of the received version of MDDI_Stb is a<br>
logic-zero level in the client before the host enables its MDDI_Stb driver. It may be<br>
desirable for the client to enable the offset slightly ahead of enabling the receiver to<br>
ensure the reception of a valid differential signal and inhibit erroneous signals, as<br>
desired. The Client enables the MDDI_DataO driver while driving the MDDI_DataO<br>
line to a logic one level<br>
[00481] Within about 1 msec., point E, the host recognizes the service request pulse<br>
from the client, and the host begins the link restart sequence by enabling the<br>
MDDI_DataO and MDDI_Stb driver outputs. The host drives MDDIJDataO to a logic104<br>
MDDI_DataO, and places its driver into a high impedance state by disabling its output.<br>
The host continues to drive MDDI_DataO to a logic-one level for 80 additional cycles.<br>
[00486] The host drives MDDI_DataO to a logic zero level for 50 cycles, as shown at<br>
point H, and the client begins to look for the Sub-frame Header Packet after<br>
MDDIJDataO is at a logic-zero level for 40 MDDI_Stb cycles. The host begins to<br>
transmit data on the forward link by sending a Sub-frame Header Packet, as shown at<br>
point I.<br>
VI. Interface Electrical Specifications<br>
[00487] In the example embodiments, Data in a Non-Return-to-Zero (NRZ) format is<br>
encoded using a data-strobe signal or DATA-STB format, which allows clock<br>
infonnation to be embedded in the data and strobe signals. The clock can be recovered<br>
without complex phase lock loop circuitry. Data is carried over a bi-directional<br>
differential link, generally implemented using a wire-line cable, although other<br>
conductors, printed wires, or transfer elements can be used, as stated earlier. The strobe<br>
signal (STB) is carried over a uni-directional link which is driven only by the host. The<br>
strobe signal toggles value (0 or 1) whenever there is a back-to-back state, 0 or 1, that<br>
remains the same on the Data line or signal.<br>
[00488] An example of how a data sequence such as bits "1110001011" can be<br>
transmitted using DATA-STB encoding is shown in graphical form in FIG. 40. In<br>
FIG. 40, a DATA signal 4002 is shown on the top line of a signal timing chart and a<br>
STB signal 4004 is shown on a second line, each time aligned as appropriate (common<br>
starting point). As time passes, when there is a change of state occurring on the DATA<br>
line 4002 (signal), then the STB line 4004 (signal) maintains a previous state, thus, the<br>
first T state of the DATA signal correlates with the first '0' state for the STB signal, its<br>
starting value. However, if or when the state, level, of the DATA signal does not<br>
change then the STB signal toggles to the opposite state or T in the present example, as<br>
is the case in FIG. 40 where the DATA is providing another T value. That is, there is<br>
one and only one transition per bit cycle between DATA and STB. Therefore, the STB<br>
signal transitions again, this time to '0' as the DATA signal stays at T and holds this<br>
level or value as the DATA signal changes level to '0'. When the DATA signal stays at<br>
T, the STB signal toggles to the opposite state or T in the present example, and so<br>
forth, as the DATA signal changes or holds levels or values.<br>
 [00489] Upon receiving these signals, an exclusive-OR (XOR) operation is performed<br>
on the DATA and STB signals to produce a clock signal 4006, which is shown on the<br>
bottom of the timing chart for relative comparison with the desired data and strobe<br>
signals. An example of circuitry useful for generating the DATA and STB outputs or<br>
signals from input data at the host, and then recovering or recapturing the data from the<br>
DATA and STB signals at the client, is shown in FIG. 41.<br>
[00490] In FIG. 41, a transmission portion 4100 is used to generate and transmit the<br>
original DATA and STB signals over an intermediary signal path 4102, while a<br>
reception portion 4120 is used to receive the signals and recover the data. As shown in<br>
FIG 41, in order to transfer data from a host to a client, the DATA signal is input to two<br>
D-type flip-flop circuit elements 4104 and 4106 along with a clock signal for triggering<br>
the circuits. The two flip-flop circuit outputs (Q) are then split into a differential pair of<br>
signals MDDIJDataO+, MDDI_DataO- and MDDI_Stb+, MDDI_Stb-, respectively,<br>
using two differential line drivers 4108 and 4110 (voltage mode). A three-input<br>
exclusive-NOR (XNOR) gate, circuit, or logic element 4112 is connected to receive the<br>
DATA and outputs of both flip-flops, and generates an output that provides the data<br>
input for the second flip-flop, which in turn generates the MDDI_Stb+, MDDI_Stbsignals.<br>
For convenience, the XNOR gate has the inversion bubble placed to indicate<br>
that it is effectively inverting the Q output of the flip-flop that generates the Strobe.<br>
[00491] In reception portion 4120 of FIG 41, the MDDIJDataO+, MDDI_DataO- and<br>
MDDI_Stb+, MDDI_Stb- signals are received by each of two differential line receivers<br>
4122 and 4124, which generate single outputs from the differential signals. The outputs<br>
of the amplifiers are then input to each of the inputs of a two-input exclusive-OR (XOR)<br>
gate, circuit, or logic element 4126 which produces the clock signal. The clock signal is<br>
used to trigger each of two D-type flip-flop circuits 4128 and 4130 which receive a<br>
delayed version of the DATA signal, through delay element 4132, one of which (4128)<br>
generates data '0' values and the other (4130) data T values. The clock has an<br>
independent output from the XOR logic as well. Since the clock information is<br>
distributed between the DATA and STB lines, neither signal transitions between states<br>
faster than half of the clock rate. Since the clock is reproduced using the exclusive-OR<br>
processing of the DATA and STB signals, the system effectively tolerates twice the<br>
amount of skew between the input data and clock compared to the situation when a<br>
clock signal is sent directly over a single dedicated data line.<br>
 [00492] The MDDI Data pairs, MDDI_Stb+, and MDDI_Stb- signals are operated in a<br>
differential mode to maximize immunity from the negative affects of noise. Each<br>
differential pair is parallel-terminated with the characteristic impedance of the cable or<br>
conductor being used to transfer signals. Generally, all parallel-terminations reside in<br>
the client device. This is near the differential receiver for forward traffic (data sent from<br>
the host to the client), but it is at the driving end of the cable or other conductors or<br>
transfer elements for reverse traffic (data sent from the client to the host). For reverse<br>
traffic the signal is driven by the client, reflected by the high impedance receiver at the<br>
host, and is terminated at the client. This avoids the need for a double termination that<br>
would increase current consumption. It also functions at data rates greater than the<br>
reciprocal of the round-trip delay in the cable. The MDDI_Stb+ and MDDI_Stbconductors<br>
or signals are only driven by the host.<br>
[00493] An exemplary configuration of elements useful for achieving the drivers,<br>
receivers, and terminations for transferring signals as part of the inventive MDD<br>
interface are shown in FIG. 42. This exemplary interface uses low voltage sensing, here<br>
200 mV, with less than 1 volt power swings and low power drain. The driver of each<br>
signal pair has a differential current output. While receiving MDDI packets the<br>
MDDIJData and MDDI_Stb pairs use a conventional differential receiver with a voltage<br>
threshold of zero volts. In the hibernation state the driver outputs are disabled and the<br>
parallel-termination resistors pull the voltage on each signal pair to zero volts. During<br>
hibernation a special receiver on the MDDI_DataO pair has an offset input threshold of<br>
positive 125 mV, which causes the hibernation line receiver to interpret the un-driven<br>
signal pair as a logic-zero level.<br>
[00494] Sometimes the host or client simultaneously drive the differentia] pair to a<br>
logic-one level or a logic-zero level to guarantee a valid logic-level on the pair when the<br>
direction of data flow changes (from host-to-client or client-to-host). The output<br>
voltage range and output specifications shall still be met with simultaneously driven<br>
outputs driven to the same logic level. In some systems it may be necessary to drive a<br>
small current into the terminated differential pair to create a small offset voltage at<br>
certain times during hibernation and when the link is waking up from the hibernation<br>
state. In those situations the enabled offset-current bias circuits must drive the<br>
following leakages:<br>
x ~ internal BSD diode and differential receiver input.<br>
O lESD-and-Rx ^ 1 ^A.<br>
-HS-Z- differential driver output in the high-impedance state.<br>
o ITX-HI-Z  1 MA.<br>
SD - the leakage through the external BSD protection diodes.<br>
O lexteinal-ESD S 3 UA<br>
[00495] Each of these leakage currents is illustrated in FIG. 101. The pull-up and pulldown<br>
circuits must achieve the minimum differential voltage under the worst-case<br>
leakage conditions described above when all occur simultaneously. The total leakage is<br>
external mode with external BSD protection<br>
[00496] The electrical parameters and characteristics of the differential line drivers and<br>
line receivers are described in Table VUL Functionally, the driver transfers the logic<br>
level on the input directly to a positive output, and the inverse of the input to a negative<br>
output. The delay from input to outputs is well-matched to the differential line which is<br>
driven differentially. In most implementations, the voltage swing on the outputs is less<br>
than the swing on the input to minimize power consumption and electromagnetic<br>
emissions. Table VIII presents a minimum voltage swing to be around 0.5V. However,<br>
other values can be used, as would be known by those skilled in the art, and the<br>
inventors contemplate a smaller value in some embodiments, depending on design<br>
constraints.<br>
[00497] The differential line receivers have the same characteristic as a high-speed<br>
voltage comparator. In FIG. 41, the input without the bubble is the positive input and<br>
the input with the bubble is the negative input. The output is a logic one if: (Vinput+) -<br>
(Vinput-) is greater than zero. Another way to describe this is a differential amplifier<br>
with very large (virtually infinite) gain with the output clipped at logic 0 and 1 voltage<br>
levels.<br>
[00498] The delay skew between different pairs should be minimized to operate the<br>
differential transmission system at the highest potential speed.<br>
[00499] In FIG. 42, a host controller 4202 and a client or display controller 4204 are<br>
shown transferring packets over the communication link 4206. The host controller<br>
employs a series of three drivers 4210, 4212, and 4214 to receive the host DATA and<br>
STB signals to be transferred, as well as to receive the client Data signals to be<br>
transferred, while the client employs the three drivers 4230, 4232, and 4234. The driver<br>
responsible for passage of the host DATA (4212) employs an enable signal input to<br>
allow activation of the communication link generally only when transfer from the host<br>
to the client is desired. Since the STB signal is formed as part of the transfer of data, no<br>
additional enable signal is employed for that driver (4212). The inputs of each of the<br>
client DATA and STB receivers (4132, 4230) have termination impedances or resistors<br>
4218 and 4220, respectively paced across them. Driver 4234 in the client controller is<br>
used to prepare the data signals being transferred from the client to the host, where<br>
driver 4214 on the input side, processes the data.<br>
[00500] The special receivers (drivers) 4216 and 4236 are coupled or connected to the<br>
DATA lines, and generate or use the 125 mV voltage offset previously discussed, as<br>
part of the hibernation control discussed elsewhere. The offsets cause the hibernation<br>
line receivers to interpret un-driven signal pairs as a logic-zero level.<br>
[00501] The above drivers and impedances can be formed as discrete components or as<br>
part of a circuit jnodule, or an application specific integrated circuit (ASIC) which acts<br>
as a more cost effective encoder or decoder solution.<br>
[00502] It can be easily seen that power is transferred to the client device, or display,<br>
from the host device using the signals labeled HOST_Pwr and HOST_Gnd over a pair<br>
of conductors. The HOST_Gnd portion of the signal acts as the reference ground and<br>
the power supply return path or signal for the client device. The HOSTJPwr signal acts<br>
as the client device power supply which is driven by the host device In an exemplary<br>
configuration, for low power applications, the client device is allowed to draw up to 500<br>
mA. The HOST_Pwr signal can be provided from portable power sources, such as but<br>
not limited to, a lithium-ion type battery or battery pack residing at the host device, and<br>
may range from 3.2 to 4.3 volts with respect to HOST_Gnd.<br>
VII. Timing Characteristics<br>
A. Overview<br>
[00503] The steps and signal levels employed by a client to secure service from the host<br>
and by the host to provide such service, are illustrated in FIG. 43. In FIG. 43, the first<br>
part of signals being illustrated shows a Link Shutdown Packet being transferred from<br>
the host and the data line is then driven to a logic zero state using the high-impedance<br>
bias circuit. No data is being transmitted by the client display, or host, which has its<br>
driver disabled. A series of strobe pulses for the MDDIJStb signal line can be seen at<br>
the bottom, since MDDI_Stb is active during the Link Shutdown Packet. Once this<br>
packet ends and the logic level changes to zero as the host drives the bias circuit and<br>
logic to zero, the MDDI_Stb signal line changes to a logic-zero level as well. This<br>
represents the termination of the last signal transfer or service from the host, and could<br>
have occurred at any time in the past, and is included to show the prior cessation of<br>
service, and the state of the signals prior to service commencement. If desired, such as<br>
signal can be sent just to reset the communication link to the proper state without a<br>
'known' prior communication having been undertaken by this host device.<br>
[00504] As shown in FIG. 43, the signal output from the client is initially set at a logic<br>
level of zero. In other words, the client output is at a high impedance, and the driver is<br>
disabled. When service is being requested, the client enables its driver and sends a<br>
service request to the host, which is a period of time, designated tservice during which the<br>
line is driven to a logic one level. A certain amount of time then passes or may be<br>
needed before the host detects the request, termed thost-aetect, after which the host<br>
responds with a link startup sequence by driving the signal to a logic one level. At this<br>
point, the client de-asserts the request, and disables the service request driver so that the<br>
output line from the client goes to a zero logic level again. During this time, the<br>
MDDI_Stb signal is at a logic zero level.<br>
[00505] The host drives the host data output at the T level for a period termed trestarthigh,<br>
after which the host drives the logic level to zero and activates MDDI_Stb for a<br>
period termed Wait-low, after which the first forward traffic begins with a Sub-Frame<br>
Header Packet, and the forward traffic packets are then transferred. The MDDI_Stb<br>
signal is active during the treS(art-iow period and the subsequent Sub-Frame Header Packet.<br>
[00506] Tables VII and VIII show representative times or processing periods for the<br>
length of the various periods discussed above, and the relationship to exemplary<br>
minimum and maximum data rates, where:<br>
thit = , where Link Data Rate is the bit rate of a single data<br>
" Link_Data_Rate - - B<br>
pair.<br>
(Table Removed)   [00507] Those skilled in the art will readily understand that the functions of the<br>
individual elements illustrated in FIGS. 41 and 42, are well known, and the function of<br>
the elements in FIG. 42 is confirmed by the timing diagram in FIG. 43. Details about<br>
the series terminations and hibernation resistors that are shown in FIG. 42 were omitted<br>
from FIG. 41 because that information is unnecessary for a description of how to<br>
perform the Data-Strobe encoding and recover the clock from it.<br>
B. Data-Strobe Timing Forward Link<br>
[00508] The switching characteristics for the transfer of data on the forward link from<br>
the host driver output is shown in Table IX. Table IX presents a tabular form of the<br>
minimum and maximum desired, versus typical times for certain signal transitions to<br>
occur. For example, the typical length of time for a transition to occur from the start to<br>
the end of a data value (output of a '0' or T), a DataO to DataO transition, termed ttdd-<br>
(host-output), is ttbit while the minimum time is about ttbit-0.5 nsec., and the maximum<br>
is about tu,it+0.5 nsec. The relative spacing between transitions on the DataO, other data<br>
lines (DataX), and the strobe lines (Stb), is illustrated in FIG. 44 where the DataO to<br>
Strobe, Strobe to Strobe, Strobe to DataO, DataO to non-DataO, non-DataO to non-DataO,<br>
non-DataO to Strobe, and Strobe to non-DataO transitions are shown, which are referred<br>
tO as ttds-(host-output). ttss-(host-output&gt; ttsd-(host-output)&gt; ttddx-(host-output) ttdxdx-(host-output)&gt; t(dxs-(host-output)&gt;<br>
and ^(host-output), respectively.<br>
(Table Removed) [00509] The typical MDDI timing requirements for the client receiver input for the<br>
same signals transferring data on the forward link is shown in Table X. Since the same<br>
signals are being discussed but time delayed, no new figure is needed to illustrate the<br>
signal characteristics or meaning of the respective labels, as would be understood by<br>
those skilled in the art.<br>
(Table Removed) [00510] FIGS. 45 and 46 illustrate the presence of a delay in response that can occur<br>
when the host disables or enables the host driver, respectively. In the case of a host<br>
forwarding certain packets, such as the Reverse Link Encapsulation Packet or the Round<br>
Trip Delay Measurement Packet, the host, disables the line driver after the desired<br>
packets are forwarded, such as the Parameter CRC, Strobe Alignment, and All Zero<br>
packets illustrated in FIG. 45 as having been transferred. However, as shown in<br>
FIG. 45, the state of the line does not necessarily switch from '0' to a desired higher<br>
value instantaneously, although this is potentially achievable with certain control or<br>
circuit elements present, but takes a period of time termed the host Driver Disable Delay<br>
period to respond. While it could occur virtually instantly such that this time period is 0<br>
nanoseconds (nsec.) in length, it could more readily extend over some longer period<br>
with 10 nsec. being a desired maximum period length, which occurs during the Guard<br>
Time 1 or Turn Around 1 packet periods.<br>
[00511] Looking in FIG. 46, one sees the signal level change undergone when the host<br>
Driver is enabled for transferring a packet such as the Reverse Link Encapsulation<br>
Packet or the Round Trip Delay Measurement Packet. Here, after the Guard Time 2 or<br>
Turn Around 2 packet periods, the host driver is enabled and begins to drive a level,<br>
here '0', which value is approached or reached over a period of time termed the Host<br>
Driver Enable Delay period, which occurs during the Driver Re-enable period, prior to<br>
the first packet being sent.<br>
[00512] A similar process occurs for the drivers and signal transfers for the client<br>
device, here a display. The general guidelines for the length of these periods, and their<br>
respective relationships are shown in Table XI, below.<br>
(Table Removed) C. Data-Strobe Timing Reverse Link<br>
[00513] The switching characteristics and timing relationships for the data and strobe<br>
signals used to transfer data on the reverse link from the client driver output are shown<br>
in FIGS. 47, and 48. The typical times for certain signal transitions are discussed<br>
below. FIG. 47 illustrates the relationship at the host receiver input between the timing<br>
of the data being transferred and the leading and trailing edges of the strobe pulses.<br>
That is, what is referred to as the set-up time for the rising or leading edge of the strobe<br>
signals, tsu.sl and the set-up time for the trailing or falling edge of the strobe signals, tsu.Sf.<br>
A typical length of time for these set-up periods is on the order of a minimum of 8<br>
nanoseconds.<br>
[00514] FIG, 48 illustrates the switching characteristics and corresponding client output<br>
delay developed by the reverse data timing. In FIG. 48, one can see the relationship<br>
between the timing of the data being transferred and the leading and trailing edges of the<br>
strobe pulses accounting for induced delay. That is, what is referred to as the<br>
propagation delay between the rising or leading edge of the strobe signals and the data<br>
(valid), tpd-sr, and the propagation delay between the data and the trailing or falling edge<br>
of the strobe signals, tpd.Sf. A typical maximum length of time for these propagation<br>
delay periods is on the order of 8 nanoseconds.<br>
VIII. Implementation of Link Control (Link Controller Operation)<br>
A. State Machine Packet Processor<br>
[00515] Packets being transferred over a MDDI link are dispatched very rapidly,<br>
typically at a rate on the order of 300 Mbps or more, such as 400 Mbps, although lower<br>
rates are certainly accommodated, as desired. This type of bus or transfer link speed is<br>
too great for currently commercially available (economical) general-purpose<br>
microprocessors or the like to control. Therefore, a practical implementation to<br>
115<br>
accomplish this type of signal transfer is to utilize a programmable state machine to<br>
parse the input packet stream to produce packets that are transferred or redirected to the<br>
appropriate audio-visual subsystem for which they are intended. Such devices are well<br>
known and use circuits generally dedicated to a limited number of operations, functions,<br>
or states to achieve a desired high speed or very high speed operation.<br>
[00516] General purpose controllers, processors, or processing elements, can be used to<br>
more appropriately act upon or manipulate some information such as control or status<br>
packets, which have lower speed demands. When those packets (control, status, or<br>
other pre-defined packets) are received, the state machine should pass them through a<br>
data buffer or similar processing element to the general-purpose processor so the<br>
packets can be acted upon to provide a desired result (effect) while the audio and visual<br>
packets are transferred to their appropriate destination for action. If future,<br>
microprocessors or other general purpose controllers, processors, or processing elements<br>
are manufactured to achieve higher data rate processing capabilities, then the states or<br>
state machine discussed below might also be implemented using software control of<br>
such devices, typically as programs stored on a storage element or media.<br>
[00517] The general purpose processor function can be realized in some embodiments<br>
by taking advantage of the processing power, or excess cycles available for,<br>
microprocessors (CPUs) in computer applications, or controllers, processors, digital<br>
signal processors (DSPs), specialized circuits, or ASICs found in wireless devices, in<br>
much the same manner as some modems or graphics processors utilize the processing<br>
power of CPUs found in computers to perform some functions and reduce hardware<br>
complexity and costs. However, this cycle sharing or usage can negatively impact the<br>
processing speed, timing, or overall operation of such elements, so in many<br>
applications, dedicated circuits or elements are preferred for this general processing.<br>
[00518] In order for image data to be viewed on a display (micro-display), or to reliably<br>
receive all packets sent by the host device, the client signal processing is synchronized<br>
with the forward link channel timing. That is, signals arriving at the client and the client<br>
circuits need to be substantially time synchronized for proper signal processing to occur.<br>
A high level diagram of states achieved by signal for one embodiment is presented in<br>
the illustration of FIG. 49. In FIG. 49, the possible forward link synchronization<br>
"states" for a state machine 4900 are shown being categorized as one ASYNC FRAMES<br>
STATE 4904, two ACQUIRING SYNC STATES 4902 and 4906, and three IN-SYNC<br>
STATES 4908,4910, and 4912.<br>
 [00519] As shown by starting step or state 4902, the display or client, such as a<br>
presentation device, starts in a pre-selected "no sync" state, and searches for a unique<br>
word in the first sub-frame header packet that is detected. It is to be noted that this no<br>
sync state represents the minimum communication setting or "fall-back" setting in<br>
which a Type 1 interface is selected. When the unique word is found during the search,<br>
the client saves the sub-frame length field. There is no checking of the CRC bits for<br>
processing on this first frame, or until synchronization is obtained. If this sub-frame<br>
length is zero, then sync state processing proceeds accordingly to a state 4904 labeled<br>
here as the "async frames" state, which indicates that synchronization has not yet been<br>
achieved. This step in the processing is labeled as having encountered cond 3, or<br>
condition 3, in FIG. 49. Otherwise, if the frame length is greater than zero, then the<br>
sync state processing proceeds to a state 4906 where the interface state is set as "found<br>
one sync frame." This step in the processing is labeled as encountering cond 5, or<br>
condition 5, in FIG. 49. In addition, if the state machine sees a frame header packet and<br>
good CRC determination for a frame length greater than zero, processing proceeds to<br>
the "found one sync frame" state. This is labeled as meeting cond 6, or condition 6, in<br>
FIG. 49.<br>
[00520] In each situation in which the system is in a state other than "no sync", if a<br>
packet with a good CRC result is detected, then the interface state is changed to the "insync"<br>
state 4908. This step in the processing is labeled as having encountered cond 1,<br>
or condition 1, in FIG. 49. On the other hand, if the CRC in any packet is not correct,<br>
then the sync state processing proceeds or returns to the interface state 4902 of "NO<br>
SYNC FRAME" state. This portion of the processing is labeled as encountering cond 2,<br>
or condition 2, in the state diagram of FIG. 49.<br>
B. Acquisition Time for Sync<br>
[00521] The interface can be configured to accommodate a certain number of "sync<br>
errors" prior to deciding that synchronization is lost and returning to the "NO SYNC<br>
FRAME" state. In FIG. 49, once the state machine has reached the "IN-SYNC STATE"<br>
and no errors are found, it is continuously encountering a cond 1 result, and remains in<br>
the "IN-SYNC" state. However once one cond 2 result is detected, processing changes<br>
the state to a "one-sync-error" state 4910. At this point, if processing results in<br>
detecting another cond 1 result, then the state machine returns to the "in-sync" state,<br>
otherwise it encounters another cond 2 result, and moves to a "TWO-SYNC-ERRORS"<br>
state 4912. Again, if a cond 1 occurs, processing returns the state machine to the "INSYNC"<br>
state. Otherwise, another cond 2 is encountered and the state machine returns to<br>
the "no-sync" state. It is also understandable that should the interface encounter a "link<br>
shutdown packet", then this will cause the link to terminate data transfers and return to<br>
the "no-sync frame" state as there is nothing to synchronize with, which is referred to as<br>
meeting cond 4, or condition 4, in the state diagram of FIG. 49.<br>
[00522] It is understood that it is possible for there to be a repeating "false copy" of the<br>
unique word which may appear at some fixed location within the sub-frame. In that<br>
situation, it is highly unlikely that the state machine will synchronize to the sub-frame<br>
because the CRC on the sub-frame Header Packet must also be valid when processed in<br>
order for the MDD interface processing to proceed to the "IN SYNC" state.<br>
[00523] The sub-frame length in the sub-frame Header Packet may be set to zero to<br>
indicate that the host will transmit only one sub-frame before the link is shut down, and<br>
the MDD interface is placed in or configured into an idle hibernation state. In this case,<br>
the client must immediately receive packets over the forward link after detecting the<br>
sub-frame Header Packet because only a single sub-frame is sent before the link<br>
transitions to the idle state. In normal or typical operations, the sub-frame length is nonzero<br>
and the client only processes forward link packets while the interface is in those<br>
states collectively shown as "IN-SYNC" states in FIG. 49.<br>
[00524] An external mode client device may be attached to the host while the host is<br>
already transmitting a forward link data sequence. In this situation, the client must<br>
synchronize to the host. The time required for a client to synchronize to the forward<br>
link signal is variable depending on the sub-frame size and the forward link data rate.<br>
The likelihood of detecting a "false copy" of the unique word as part of the random, or<br>
more random, data in the forward link is greater when the sub-frame size is larger. At<br>
the same time, the ability to recover from a false detection is lower, and the time taken<br>
to do so is longer, when a forward link data rate is slower.<br>
C. Initialization<br>
[00525] As stated earlier, at the time of "start-up", the host configures the forward link<br>
to operate at or below a minimum required, or desired, data rate of 1 Mbps, and<br>
configures the sub-frame length and media-frame rate appropriately for a given<br>
application. That is, both the forward and reverse links begin operation using the Type<br>
1 interface. These parameters are generally only going to be used temporarily while the<br>
host determines the capability or desired configuration for the client display (or other<br>
type of client device). The host sends or transfers a sub-frame Header Packet over the<br>
forward link followed by a Reverse Link Encapsulation Packet which has bit '0' of the<br>
Request Flags set to a value of one (1), in order to request that the display or client<br>
responds with a Client Capability Packet. Once the display acquires synchronization on<br>
(or with) the forward link, it sends a Client Capability Packet and a Client Request and<br>
Status Packet over the reverse link or channel.<br>
[00526] The host examines the contents of the Client Capability Packet in order to<br>
determine how to reconfigure the link for optimal or a desired level of performance.<br>
The host examines the Protocol Version and Minimum Protocol Version fields to<br>
confirm1 that the host and client use versions of the protocol that are compatible with<br>
each other. The protocol versions generally remain as the first two parameters of the<br>
client capability Packet so that compatibility can be determined even when other<br>
elements of the protocol might not be compatible or completely understood as being<br>
compatible.<br>
D. CRC Processing<br>
[00527] For all packet types, the packet processor state machine ensures that the CRC<br>
checker is controlled appropriately or properly. It also increments a CRC error counter<br>
when a CRC comparison results in one or more errors being detected, and it resets the<br>
CRC counter at the beginning of each sub-frame being processed.<br>
E. Alternative Loss Of Synchronization Check<br>
[00528] While the above series of steps or states work to produce higher data rates or<br>
throughput speed, Applicants have discovered that an alternative arrangement or change<br>
in the conditions the client uses to declare that there is a loss of synchronization with the<br>
host, can be used effectively to achieve even higher data rates or throughput. The new<br>
inventive embodiment has the same basic structure, but with the conditions for changing<br>
states changed. Additionally a new counter is implemented to aid in making checks for<br>
sub-frame synchronization. These steps and conditions are presented relative to FIG.<br>
63, which illustrates a series of states and conditions useful in establishing the<br>
operations of the method or state machine. Only the "ACQU1RING-SYNC STATES"<br>
and "IN-SYNC STATES" portions are shown for clarity. In addition, since the resulting<br>
states are substantially the same, as is the state machine itself, they use the same<br>
numbering. However, the conditions for changing states (and the state machine<br>
operation) vary somewhat, so that all are renumbered for clarity between the two figures<br>
(1, 2, 3, 4, 5, and 6, versus 61, 62, 63, 64, and 65), as a convenience in identifying<br>
differences. Since the ASYNC FRAME state is not considered in this discussion, one<br>
state (4904) and condition (6) are no longer used in the figure.<br>
[00529] In FIG. 63, the system or client (for display or presentation) starts with state<br>
machine 5000 in the pre-selected "no sync" state 4902, as in FIG. 49. The first state<br>
change for changing states from the no-sync condition 4902 is in condition 64 which is<br>
the discovery of the sync pattern. Assuming that the CRC of the sub-frame header also<br>
passes on this packet (meets condition 61), the state of the packet processor state<br>
machine can be changed to the in-sync state 4908. A sync error, condition 62, will<br>
cause the state machine to shift to state 4910, and a second occurrence to state 4912.<br>
However, it has been discovered that any CRC failure of an MDDI packet will cause the<br>
state machine to move out of in-sync state 4908, to the one sync error state 4910.<br>
Another CRC failure of any MDDI packet will cause a move to the two sync failure<br>
state 4912. A packet decoded with a correct CRC value will cause the state machine to<br>
return to the in-sync state 4908.<br>
[00530] What has been changed is to utilize the CRC value or determination for 'every1<br>
packet. That is, to have the state machine look at the CRC value for every packet to<br>
determine a loss of synchronization instead of just observing sub-frame header packets.<br>
In this configuration or process, a loss of synchronization is not determined using the<br>
unique word and just sub-frame header CRC values.<br>
[00531] This new interface implementation allows the MDD interface link to recognize<br>
synchronization failures much more quickly, and, therefore, to recover from them more<br>
quickly, as well.<br>
[00532] To make this system more robust, the client should also add or utilize a subframe<br>
counter. The client then checks for the presence of the unique word at the time it<br>
is expected to arrive or occur in a signal. If the unique word does not occur at the<br>
correct time, the client can recognize that a synchronization failure has occurred much<br>
more quickly than if it had to wait several (here three) packet times or periods that were<br>
greater than a sub-frame length. If the test for the unique word indicates it is not<br>
present, in other words that the timing is incorrect, then the client can immediately<br>
declare a link loss of synchronization and move to the no-sync state. The process of<br>
checking for the proper unique word presence, adds a condition 65 (cond 65) to the state<br>
machine saying that the unique word is incorrect. If a sub-frame packet is expected to<br>
be received on the client and doesn't match up, the client can immediately go to the nosync<br>
state 4902, saving additional time waiting for multiple sync errors (condition 62)<br>
normally encountered traversing through states 4910 and 4912.<br>
This change uses an additional counter or counting function in the client core to<br>
count sub-frame length. In one embodiment, a count down function is used and the<br>
transfer of any packet that was currently being processed is interrupted to check for the<br>
sub-frame unique word if the counter has expired. Alternatively, the counter can count<br>
up, with the count being compared to a desired maximum or particular desired value, at<br>
which point the current packet is checked. This process protects the client from<br>
decoding packets that are incorrectly received on the client with extraordinarily long<br>
packet lengths. If the sub-frame length counter needed to interrupt some other packet<br>
that was being decoded, a loss of synchronization can be determined since no packet<br>
should cross a sub-frame boundary.<br>
IX. Packet Processing<br>
[00533] For each type of packet discussed above that the state machine receives, it<br>
undertakes a particular processing step or series of steps to implement operation of the<br>
interface. Forward link packets are generally processed according to the exemplary<br>
processing listed in Table XII below.<br>
(Table Removed) X. Reducing the Reverse Link Data Rate<br>
[00534] It has been observed by the inventors that certain parameters used for the host<br>
link controller can be adjusted or configured in a certain manner in order to achieve a<br>
maximum or more optimized (scale) reverse link data rate, which is very desirable. For<br>
example, during the time used to transfer the Reverse Data Packets field of the Reverse<br>
Link Encapsulation Packet, the MDDI_Stb signal pair toggles to create a periodic data<br>
clock at half the forward link data rate. This occurs because the host link controller<br>
generates the MDDI_Stb signal that corresponds to the MDDI_DataO signal as if it were<br>
sending all zeroes. The MDDI_Stb signal is transferred from the host to a client where<br>
it is used to generate a clock signal for transferring reverse link data from the client,<br>
with which reverse data is sent back to the host. An illustration of typical amounts of<br>
delay encountered for the signal transfer and processing on the forward and reverse<br>
paths in a system employing the MDDI, is shown in FIG. 50. In FIG. 50, a series of<br>
delay values 1.5 nsec., 8.0 nsec., 2.5 nsec., 2.0 nsec., 1.0 nsec., 1.5 nsec., 8.0 nsec., and<br>
2.5 nsec., are shown near processing portions for the Stb+/- generation, cable transferto-<br>
client, client receiver, clock generation, signal clocking, DataO+/- generation, cable<br>
transfer-to-host, and host receiver stages, respectively.<br>
[00535] Depending on the forward link data rate and signal processing delays<br>
encountered, it may require more time than one cycle on the MDDI_Stb signal for this<br>
"round trip" effect or set of events to be completed, which results in the consumption<br>
undesirable amounts of time or cycles. To circumvent this problem, the Reverse Rate<br>
Divisor makes it possible for one bit time on the reverse link to span multiple cycles of<br>
the MDDI_Stb signal. This means that the reverse link data rate is less than the forward<br>
link rate.<br>
[00536] It should be noted that the actual length of signal delays through the interface<br>
may differ depending on each specific host-client system or hardware being used.<br>
Although not required, each system can generally be made to perform better by using<br>
the Round Trip Delay Measurement Packet to measure the actual delay in a system so<br>
that the Reverse Rate Divisor can be set to an optimum value. The host may support<br>
either basic data sampling which is simper but operates at a slower speed or advanced<br>
data sampling that is more complex but supports higher reverse data rates. The client<br>
capability to support both methods is considered the same<br>
[00537] A round-trip delay is measured by having the host send a Round Trip Delay<br>
Measurement Packet to the client. The client responds to this packet by sending a<br>
sequence of ones back to the host inside of, or during, a pre-selected measurement<br>
window in that packet called the Measurement Period field. The detailed timing of this<br>
measurement was described previously. The round-trip delay is used to determine the<br>
rate at which the reverse link data can be safely sampled.<br>
[00538] The round-trip delay measurement consists of determining, detecting, or<br>
counting the number of forward link data clock intervals occurring between the<br>
beginning of the Measurement Period field and the beginning of the time period when<br>
the Oxff, Oxff, 0x00 response sequence is received back at the host from the client. Note<br>
that it is possible that the response from the client could be received a small fraction of a<br>
forward link clock period before the measurement count was about to increment. If this<br>
unmodified value is used to calculate the Reverse Rate Divisor it could cause bit errors<br>
on the reverse link due to unreliable data sampling. An example of this situation is<br>
illustrated in FIG. 51, where signals representing MDDI_Data at host, MDDI_Stb at<br>
host, forward link data clock inside the host, and a Delay Count are illustrated in<br>
graphical form. In FIG, 51, the response sequence was received from the client a<br>
fraction of a forward link clock period before the Delay Count was about to increment<br>
from 6 to 7, If the delay is assumed to be 6, then the host will sample the reverse data<br>
just after a bit transition or possibly in the middle of a bit transition. This could result in<br>
erroneous sampling at the host. For this reason, the measured delay should typically be<br>
incremented by one before it is used to calculate the Reverse Rate Divisor.<br>
[00539] The Reverse Rate Divisor is the number of MDDI_Stb cycles the host should<br>
wait before sampling the reverse link data. Since MDDI_Stb is cycled at a rate that is<br>
one half of the forward link rate, the corrected round-trip delay measurement needs to<br>
be divided by 2 and then rounded up to the next integer. Expressed as a formula, this<br>
relationship is:<br>
,. . n ,ir _, ., r (round trip_delay + lreverse _ rate __ divisor = RoundUpToNextlntegerl =<br>
\ Z J<br>
For the example given, this becomes:<br>
reverse _ rate _ divisor = RoundUpToNextlntegerl = 4<br>
[00540] If the round trip delay measurement used in this example were 7 as opposed to<br>
6, then the Reverse Rate Divisor would also be equal to 4.<br>
[00541] The reverse link data is sampled by the host on the rising edge of the Reverse<br>
Link Clock. There is a counter or similar known circuit or device present in both the<br>
host and client (display) to generate the Reverse Link Clock. The counters are<br>
initialized so that the first rising edge of the Reverse Link Clock occurs at the beginning<br>
of the first bit in the Reverse Link Packets field of the Reverse Link Encapsulation<br>
packet. This is illustrated, for the example given below, in FIG. 52. The counters<br>
increment at each rising edge of the MDDI_Stb signal, and the number of counts<br>
occurring until they wrap around is set by the Reverse Rate Divisor parameter in the<br>
Reverse Link Encapsulation Packet. Since the MDDI_Stb signal toggles at one half of<br>
the forward link rate, then the reverse link rate is one half of the forward link rate<br>
divided by the Reverse Rate Divisor. For example, if the forward link rate is 200 Mbps<br>
and the Reverse Rate Divisor is 4 then the reverse link data rate is expressed as:<br>
!_ 2QOMbps<br>
2 4<br>
= 25Mbps<br>
[00542] An example showing the timing of the MDDI_DataO and MDDI_Stb signal<br>
lines in a Reverse Link Encapsulation Packet is shown in FIG. 52, where the packet<br>
parameters used for illustration have the values:<br>
Packet Length = 1024 (0x0400) Turn Around 1 Length = 1<br>
Packet Type = 65 (0x41) Turn Around 2 Length = 1<br>
Reverse Link Flags = 0 Reverse Rate Divisor = 2<br>
Parameter CRC = Oxdb43 All Zero is 0x00<br>
Packet data between the Packet Length and Parameter CRC fields is:<br>
0x00, 0x04, 0x41, 0x00,0x02, 0x01, 0x01,0x43, Oxdb, 0x00, ...<br>
[00543] The first reverse link packet returned from the client is the Client Request and<br>
Status Packet having a Packet Length of 7 and a packet type of 70. This packet begins<br>
with the byte values 0x07, 0x00, 0x46, ... and so forth. However, only the first byte<br>
(0x07) is visible in FIG. 52. This first reverse link packet is time-shifted by nearly one<br>
reverse link clock period in the figure to illustrate an actual reverse link delay. An ideal<br>
waveform with zero host to client round-trip delay is shown as a dotted-line trace.<br>
[00544] The MS byte of the Parameter CRC field is transferred, preceded by packet<br>
type, then the all zero field. The strobe from the host is switching from one to zero and<br>
back to one as the data from the host changes level, forming wider pulses. As the data<br>
goes to zero, the strobe switches at the higher rate, only the change in data on the data<br>
line causes a change near the end of the alignment field. The strobe switches at the<br>
higher rate for the remainder of the figure due to the fixed 0 or 1 levels of the data signal<br>
for extended periods of time, and the transitions falling on the pulse pattern (edge).<br>
[00545] The reverse link clock for the host is at zero until the end of the Turn Around 1<br>
period, when the clock is started to accommodate the reverse link packets. The arrows<br>
in the lower portion of the figure indicate when the data is sampled, as would be<br>
apparent from the remainder of the disclosure. The first byte of the packet field being<br>
transferred (here 11000000) is shown commencing after Turn Around 1, and the line<br>
level has stabilized from the host driver being disabled. The delay in the passage of the<br>
first bit, and as seen for bit three, can bee seen in the dotted lines for the Data signal.<br>
[00546] In FIG. 53, one can observe typical values of the Reverse Rate Divisor based<br>
on the forward link data rate. The actual Reverse Rate Divisor is determined as a result<br>
of a round-trip link measurement to guarantee proper reverse link operation. A first<br>
region 5302 corresponds to an area of safe operation, a second region 5304 corresponds<br>
to an area of marginal performance, while a third region 5306 indicates settings that are<br>
unlikely to function properly.<br>
[00547] The round-trip delay measurement and Reverse Rate Divisor setting are the<br>
same while operating with any of the Interface Type settings on either the forward or<br>
reverse link because they are expressed and operated on in terms of units of actual clock<br>
periods rather than numbers of bits transmitted or received.<br>
XI. Turn-Around and Guard Times<br>
[00548] As discussed earlier, the Turn Around 1 field in the Reverse Link<br>
Encapsulation Packet and the Guard Time 1 field in the Round Trip Delay Measurement<br>
Packet designate values for. lengths of time that allow for the host interface drivers to be<br>
disabled before the client interface drivers are enabled. Turn Around 2 and Guard Time<br>
2 fields provide time values which allow the client drivers to be disabled before the host<br>
drivers are enabled. The Guard Time 1 and Guard Time 2 fields are generally filled<br>
with pre-set or pre-selected values for lengths that are not meant to be adjusted.<br>
Depending on the interface hardware being used, these values may be developed using<br>
empirical data and adjusted in some instances to improve operation.<br>
[00549] Several factors contribute to a determination of the length of Turn Around 1<br>
and these are the forward link data rate, and the maximum disable time of the<br>
MDDIJData drivers in the host. The maximum host driver disable time is specified in<br>
Table XI, where it shows that the drivers take about 10 nsec. maximum to disable and<br>
about 2 nsec. to enable. The minimum number of forward link clocks required for the<br>
host driver to be disabled is expressed according to the relationship:<br>
ForwardLinkDataRate ri _ . _ . , . _ ,<br>
Clocks to disable.,.,, = -- HostDriverDisableDelayn,   lAl j f&gt; rnrt &gt;~( , " lllaXn<br>
[00550] The allowed value range of Turn Around 1 is expressed according to the<br>
relationship:<br>
Turn _ Around _ 1 &gt; RoundUpToNextlntegerl - =  = -   InterfaceType Factor FWD \ 8<br>
where the Interface Type Factor is 1 for Type 1, 2 for Type 2, 4 for Type 3, and 8 for<br>
Type-IV.<br>
[00551] Combining the two equations from above, one can see that the Interface Type<br>
Factor term cancels out, and Turn Around 1 is defined as:<br>
( ForwardLifcDataRate HostDriveDisableDeby<br>
Turn_Around_l = RoundUpToNxtlntegeV ^<br>
V 8<br>
[00552] For example, a 1500 Mbps Type 3 forward link would use a Turn Around 1<br>
delay of:<br>
Turn_ Around _1 = RoundUpToNextlntegen = 2Bytes<br>
v 8 )<br>
[00553] As the round trip delay increases, the timing margin improves from the point in<br>
time when the host is disabled to the time the client is enabled.<br>
[00554] The factors that determine the length of time generally used for Turn Around 2<br>
are the forward link data rate, the maximum disable time of the MDDI_Data drivers in<br>
the client, and the round-trip delay of the communication link. The calculation of the<br>
time required to disable the client driver is essentially the same as that for the host<br>
driver discussed above, and is defined according to the relationship:<br>
, , ,. ,, ForwardLinkDataRate .. .<br>
Clocks _to_ dtsableTA2 = DisplayDnverDisableDelay nax InterfaceTypeFactormD<br>
and the allowed value range for Turn Around 2 is expressed as:<br>
/<br>
,, _ &gt;T . Clocks_to_disabl&amp;.A2 + round_trip_delay+Turn_Around_ 2 2. RoundupToMxtlntege<br>
8<br>
^ Interface'$peFactopWD J<br>
[00555] For example, a 1500 Mbps Type 3 forward link with a round-trip delay of 10<br>
forward link clocks typically uses a Turn Around 2 delay on the order of:<br>
Clocks _to_ disablerA2 =   lOn sec = 3.75<br>
Turn _ Around _2&gt; RoundUpToNextlnteger <br>
XII. Alternative Reverse Link Timing<br>
[00556] While the use of timing and guard bands discussed above work to achieve a<br>
high data transfer rate interface, the inventors have discovered a technique to allow for<br>
reverse bit lengths that are shorter than the round trip time, by changing the reverse<br>
timing discovery<br>
[00557] As presented above, the previous approach to the timing of the reverse link is<br>
configured such that the number of clock cycles is counted from the last bit of the Guard<br>
Time 1 of a reverse timing packet until the first bit is sampled on the rising edge of an<br>
IO clock. That is the clock signal(s) used to time the inputs and outputs for the MDD<br>
interface. The calculation for the reverse rate divisor is then given by:<br>
,. . D ,,r  A7 ,,  / round _trip _ delay + \reverse rate divisor = RoundUpToNextlnteger} - - - - -<br>
- - * ^ 2 J<br>
[00558] This provides a bit width equal to the round trip delay which results in a very<br>
reliable reverse link. However, the reverse link has been shown to be capable of<br>
running faster, or at a higher data transfer rate, which the inventors want to take<br>
advantage of. A new inventive technique allows utilizing additional capabilities of the<br>
interface to reach higher speeds.<br>
[00559] This is accomplished by having the host count the number of clock cycles until<br>
a one is sampled, but with the host sampling the data line on both the rising and falling<br>
edges during the reverse timing packet. This allows the host to pick the most useful or<br>
even optimal sampling point within the reverse bit to ensure that the bit is stable. That<br>
is, to find the most useful or optimal rising edge to sample data on for reverse traffic<br>
reverse encapsulation packets. The optimal sampling point depends on both the reverse<br>
link divisor and whether the first one was detected on a rising edge or a falling edge.<br>
The new timing method allows the host to just look for the first edge of the OxFF OxFF<br>
0x00 pattern sent by the client for reverse link timing to determine where to sample in a<br>
reverse encapsulation packet.<br>
[00560] Examples of the arriving reverse bit and how that bit would look for various<br>
reverse rate divisors, is illustrated in FIG. 64, along with a number of clock cycles that<br>
have occurred since the last bit of Guard Time 1. In Fig. 64, one can see that if the first<br>
edge occurs between a rising and falling edge (labeled as rise/fall), the optimal sampling<br>
point for a reverse rate divisor of one, the optimal sample point is a clock cycle edge<br>
labeled 'b', as thai is the only rising edge occurring within the period of the reverse bit.<br>
For a reverse rate divisor of two, the optimal sampling point is probably still clock cycle<br>
leading edge 'b' as cycle edge 'c' is closer to a bit edge than 'b'. For a reverse rate divisor<br>
of four, the optimal sampling point is probably clock cycle edge 'd', as it is closer to the<br>
back edge of the reverse bit where the value has probably stabilized.<br>
[00561] Returning to FIG. 64, if, however, the first edge occurs between a falling and<br>
rising edge (labeled as fall/rise), the optimal sampling point for a reverse rate divisor of<br>
one is sampling point clock cycle edge 'a', as that is the only rising edge within the<br>
reverse bit time period. For a reverse rate divisor of two. the optimal sampling point is<br>
edge 'b', and for a reverse rate divisor of four the optimal sampling point is edge 'c1.<br>
[00562] One can see that as the reverse rate divisors get larger and larger, the optimal<br>
sampling point becomes easier to ascertain or select, as it should be the rising edge that<br>
is closest to the middle.<br>
[00563] The host can use this technique to find the number of rising clock edges before<br>
the rising data edge of the timing packet data is observed on the data line. It can then<br>
decide, based on whether the edge occurs between a rising and falling edge or between a<br>
falling and rising edge, and what the reverse rate divisor is, how many additional clock<br>
cycles to add to a number counter, to reasonably ensure that the bit is always sampled as<br>
close to the middle as possible.<br>
[00564] Once the host has selected or determined the number of clock cycles, it can<br>
"explore" various reverse rate divisors with the client to determine if a particular reverse<br>
rate divisor will work. The host (and client) can start with a divisor of one and check<br>
the CRC of the reverse status packet received from the client to determine if this reverse<br>
rate functions appropriately to transfer data. If the CRC is corrupt, there is probably a<br>
sampling error, and the host can increase the reverse rate divisor and try to request a<br>
status packet again. If the second requested packet is corrupt, the divisor can be<br>
increased again and the request made again. If this packet is decoded correctly, this<br>
reverse rate divisor can be used for all future reverse packets.<br>
[00565] This method is effective and useful because the reverse timing should not<br>
change from the initial round trip timing estimate. If the forward link is stable, the<br>
client should continue to decode forward link packets even if there are reverse link<br>
failures. Of course, it is still the responsibility of the host to set a reverse link divisor<br>
for the link, since this method does not guarantee a perfect reverse link. In addition, the<br>
divisor will depend primarily on the quality of the clock that is used to generate an IO<br>
clock. If that clock has a significant amount of jitter, there is a greater possibility of a<br>
sampling error. This error probability increases with the amount of clock cycles in the<br>
round trip delay.<br>
[00566] This implementation appears to work best for Type 1 reverse data, but may<br>
present problems for Type 2 through Type 4 reverse data due to the skew between data<br>
lines potentially being too great to run the link at the rate that works best for just one<br>
data pair. However, the data rate probably does not need to be reduced to the previous<br>
method even with Type 2 through Type 4 for operation. This method may also work<br>
best if duplicated on each data line to select the ideal or an optimal clock sample<br>
location. If they are at the same sample time for each data pair, this method would<br>
continue to work. If they are at different sample periods, two different approaches may<br>
be used. The first is to select an desired or more optimized sample location for each<br>
data point, even it it is not the same for each data pair. The host can then reconstruct the<br>
data stream after sampling all of the bits from the set of data pairs: two bits for Type 2,<br>
four bits for Type 3, and eight bits for Type-IV. The other option is for the host to<br>
increase the reverse rate divisor such that the data bits for every data pair can be<br>
sampled at the same clock edge.<br>
XIII. Effects of Link Delay and Skew<br>
[00567] Delay skew on the forward link between the MDDI_Data pairs and MDDI_Stb<br>
can limit the maximum possible data rate unless delay skew compensation is used. The<br>
differences in delay that cause timing skew are due to the controller logic, the line<br>
drivers and receivers, and the cable and connectors as outlined below.<br>
A. Link Timing Analysis Limited by Skew (MDDI Type-1)<br>
1. Delay and Skew Example of a Type 1 Link<br>
[00568] A typical interface circuit similar to that shown in FIG. 41, is shown in FIG. 57<br>
for accommodating a Type 1 interface link. In FIG. 57, exemplary or typical values for<br>
propagation delay and skew are shown for each of several processing or interface stages<br>
of an MDDI Type 1 forward link. Skew in the delay between MDDI_Stb and<br>
MDDI_DataO causes the duty-cycle of the output clock to be distorted. Data at the D<br>
input of the receiver flip-flop (RXFF) stage using flip-flops 5728, 5732, changes<br>
slightly after the clock edge so that it can be sampled reliably. The figure shows two<br>
cascaded delay lines 5732a and 5732b being used to solve two different problems with<br>
creating this timing relationship. In the actual implementation these may be combined<br>
into a single delay element.<br>
[00569] Data, Stb, and Clock Recovery Timing on a Type 1 Link for exemplary signal<br>
processing through the interface are illustrated in FIG. 58.<br>
[00570] The total delay skew that is significant generally arises or comes from the sum<br>
of the skew in the following stages: transmitter flip-flop (TXFF) with flip-flops 5704,<br>
5706; transmitter driver (TXDRVR) with drivers 5708, 5710; the CABLE 5702;<br>
receiver line receiver (RXRCVR) with receivers 5722, 5724; and receiver XOR logic<br>
(RXXOR). Delayl 5732a should match or exceed the delay of the XOR gate 5736 in<br>
the RXXOR stage which is determined by the relationship:<br>
t PD - min( Delay 1)  ^ PD ~ max( XOR )<br>
[00571J It is desirable to meet this requirement so that the D input of receiver flip-flop<br>
5728, 5732 does not change before its clock input. This is valid if the hold-time of<br>
RXFF is zero.<br>
[00572] The purpose or function of Delay2 is to compensate for the hold-time of the<br>
RXFF flip-flop according to the relationship:<br>
*PD-min(Delay2) ~*H(RXFF)<br>
[00573] In many systems this will be zero because the hold time is zero, and of course<br>
in that case the maximum delay of Delay2 can also be zero.<br>
[00574] The worst-case contribution to skew in the receiver XOR stage is in the datalate/<br>
strobe-early case where Delayl is at a maximum value and the clock output from<br>
the XOR gate comes as early as possible according to the relationship:<br>
tsKEW-m!Oi(RXXOR) ~ * PD-may.(Delayl) ~ ^ PD-min(XOR)<br>
[00575] In this situation, the data may change between two bit periods, n and n+1, very<br>
close to the time where bit n+1 is clocked into the receiver flip-flop.<br>
 [00576] The maximum data rate (minimum bit period) of an MDDI Type 1 link is a<br>
function of the maximum skew encountered through all the drivers, cable, and receivers<br>
in the MDDI link plus the total data setup into the RXFF stage. The total delay skew in<br>
the link up to the output of the RXRCVR stage can be expressed as:<br>
*SKEW~aa(UNK) ~~ *SKEW-mm(TXFF) ~*~ ^SKEW-max(TXDRVR) "*" *SKEW-max(CABL) "*" ^SKEW-nwi(RXRCVR)<br>
and the minimum bit period is given by:<br>
^B/r-min ~ * SKEW-max(i/MST) ~"~ * SKEW-miui(RXXOR) ~*~ ^ PD-mz\(Delay2)<br>
In the example shown in FIG. 57, tsKEw-max(LiNK) =1.4 nsec and the minimum bit<br>
period can be expressed as:<br>
W-min -1 -4 + 0.3 + 0.2 + 0.5 = 2.4n sec, or stated as approximately 416 Mbps.<br>
B. Link Timing Analysis for MDDI Type 2, 3, and 4<br>
[00577] A typical interface circuit similar to that shown in FIGS. 41 and 57, is shown in<br>
FIG. 59 for accommodating Type 2, III, and IV interface links. Additional elements are<br>
used in the TXFF (5904), TXDRVR (5908), RXRCVCR (5922), and RXFF (5932,<br>
5928, 5930) stages to accommodate the additional signal processing. In FIG. 59,<br>
exemplary or typical values for propagation delay and skew are shown for each of<br>
several processing or interface stages of an MDDI Type 2 forward link. In addition to<br>
skew in the delay between MDDI_Stb and MDDI_DataO affecting the duty-cycle of the<br>
output clock, there is also skew between both of these two signals and the other<br>
MDDLPata signals. Data at the D input of the receiver flip-flop B (RXFFB) stage<br>
consisting of flip-flops 5928 and 5930, is changed slightly after the clock edge so it can<br>
be sampled reliably. If MDDI_Datal arrives earlier than MDDI_Stb or MDDI_DataO<br>
then MDDI_Datal should be delayed to be sampled by at least the amount of the delay<br>
skew. To accomplish this, data is delayed using the Delay3 delay line. If MDDI_Datal<br>
arrives later than MDDI_Stb and MDDI_DataO and it is also delayed by DelayS then the<br>
point where MDDI_Datal changes is moved closer to the next clock edge. This process<br>
determines an upper limit of the data rate of an MDDI Type 2, 3, or 4 link. Some<br>
exemplary different possibilities for the timing or skew relationship of two data signals<br>
and MDDI_Stb with respect to each other is illustrated in FIGS. 60A, 60B, andjSOC.<br>
[00578] In order to sample data reliably in RXFFB when MDDI_DataX arrives as early<br>
as possible, Delay3 is set according to the relationship:<br>
PD-min(Delay3) ~ * SKEW -wx.(LINK) "^^H(RXFFB) ~^~ ^PD-max(XOfl)<br>
[00579] The maximum link speed is determined by the minimum allowable bit period.<br>
This is most affected when MDDI_DataX arrives as late as possible. In that case, the<br>
minimum allowable cycle time is given by:<br>
'BIT-min tsKEW-io&amp;\(LINK) "*~ * PD-max(Dalay?,) "*~ ^ SV (RXFFB) ^PD-mia(XOR)<br>
The upper bound of link speed is then:<br>
and given that assumption:<br>
^ ' ^ SKEW-raan(LlNK) "*" * PD~mHK(XOR) ~*~ * SU (RXFFB)<br>
[00580] In the example given above, the lower bound of the minimum bit period is<br>
given by the relationship:<br>
*BiT-muttowcr-iever) = 2  1.4 +1.5 + 0.5 + 0.1 = 4.8nsec, which is approximately 208 Mbps.<br>
[00581] This is much slower than the maximum data rate that can be used with a Type<br>
1 link. The automatic delay skew compensation capability of MDDI significantly<br>
reduces the affect that delay skew has on the maximum link rate<br>
XIV. Physical Layer Interconnection Description<br>
[00582] Physical connections useful for implementing an interface according to the<br>
present invention can be realized using commercially available parts such as part<br>
number 3260-882(01) as manufactured by Hirose Electric Company Ltd. on the host<br>
side, and part number 3240-8P-C as manufactured by Hirose Electric Company Ltd. on<br>
the client device side. An exemplary interface pin assignment or "pinout" for such<br>
connectors used with a Type-I/Type 2 interfaces is listed in Table XIII, and illustrated<br>
in FIG. 61.<br>
(Table Removed) [00583] The shield is connected to the HOST_Gnd in the host interface, and a shield<br>
drain wire in the cable is connected to the shield of the client connector. However, the<br>
shield and drain wire are not connected to the circuit ground inside of a client.<br>
[00584] Interconnection elements or devices are chosen or designed in order to be small<br>
enough for use with mobile communication and computing devices, such as PDAs and<br>
wireless telephones, or portable game devices, without being obtrusive or unaesthetic in<br>
comparison to relative device size. Any connectors and cabling should be durable<br>
enough for use in the typical consumer environment and allow for small size, especially<br>
for the cabling, and relatively low cost. The transfer elements should accommodate data<br>
and strobe signals that are differential NRZ data having a transfer rate up to around 450<br>
Mbps for Type 1 and Type 2 and up to 3.6 Gbps for the 8-bit parallel Type 4 version.<br>
[00585] For internal mode applications there are either no connectors in the same sense<br>
for the conductors being used or such connection elements tend to be very miniaturized.<br>
One example is zero insertion force "sockets" for receiving integrated circuits or<br>
elements housing either the host or client device. Another example is where the host<br>
and client reside on printed circuit boards with various interconnecting conductors, and<br>
have "pins" or contacts extending from housings which are soldered to contacts on the<br>
conductors for interconnection of integrated circuits.<br>
XV. Operation<br>
[00586] A summary of the general steps undertaken in processing data and packets<br>
during operation of an interface using embodiments of the invention is shown in FIGS.<br>
54A and 54B, along with an overview of the interface apparatus processing the packets<br>
in FIG. 55. In these figures, the process starts in a step 5402 with a determination as to<br>
whether or not the client and host are connected using a communication path, here a<br>
cable. This can occur through the use of periodic polling by the host, using software or<br>
hardware that detects the presence of connectors or cables or signals at the inputs to the<br>
host (such as is seen for USB interfaces), or other known techniques. If there is no<br>
client connected to the host, then it can simply enter a wait state of some predetermined<br>
length, depending upon the application, go into a hibernation mode, or be inactivated to<br>
await future use which might require a user to take action to reactivate the host. For<br>
example, when a host resides on a computer type device, a user might have to click on a<br>
screen icon or request a program that activates the host processing to look for the client.<br>
Again, simple plug in of a USB type connection could activate host processing,<br>
depending on the capabilities and configuration of the host or resident host software.<br>
[00587] Once a client is connected to the host, or visa versa, or detected as being<br>
present, either the client or the host sends appropriate packets requesting service in steps<br>
5404 and 5406. The client could send either Client Service Request or Status packets in<br>
step 5404. It is noted that the link, as discussed above, could have been previously shut<br>
down or be in hibernation mode so this may not be a complete initialization of the<br>
communication link that follows. Once the communication link is synchronized and the<br>
host is trying to communicate with the client, the client also provides a Client<br>
Capabilities packet to the host, as in step 5408. The host can now begin to determine<br>
the type of support, including transfer rates, the client can accommodate.<br>
[00588] Generally, the host and client also negotiate the type (rate/speed) of service<br>
mode to be used, for example Type 1, Type 2, and so forth, in a step 5410. Once the<br>
service type is established the host can begin to transfer information. In addition, the<br>
host may use Round Trip Delay Measurement Packets to optimize the timing of the<br>
communication links in parallel with other signal processing, as shown in step 5411.<br>
[00589] As stated earlier, all transfers begin with a Sub-Frame Header Packet, shown<br>
being transferred in step 5412, followed by the type of data, here video and audio stream<br>
packets, and filler packets, shown being transferred in step 5414. The audio and video<br>
data will have been previously prepared or mapped into packets, and filler packets are<br>
inserted as needed or desired to fill out a required number of bits for the media frames.<br>
The host can send packets such as the Forward Audio Channel Enable Packets to<br>
activate sound devices. In addition, the host can transfer commands and information<br>
using other packet types discussed above, here shown as the transfer of Color Map, Bit<br>
Block Transfer or other packets in step 5416. Furthermore, the host and client can<br>
exchange data relating to a keyboard or pointing devices using the appropriate packets.<br>
[00590] During operation, one of several different events can occur which lead to the<br>
host or client desiring a different data rate or type of interface mode. For example, a<br>
computer or other device communicating data could encounter loading conditions in<br>
processing data that causes a slow down in the preparation or presentation of packets. A<br>
client device receiving the data could change from a dedicated AC power source to a<br>
more limited battery power source, and either not be able to transfer in data as quickly,<br>
process commands as readily, or not be able to use the same degree of resolution or<br>
color depth under the more limited power settings. Alternatively, a restrictive condition<br>
could be abated or disappear allowing either device to transfer data at higher rates. This<br>
being more desirable, a request can be made to change to a higher transfer rate mode.<br>
[00591] If these or other types of known conditions occur or change, either the host or<br>
client may detect them and try to renegotiate the interface mode. This is shown in step<br>
5420, where the host sends Interface Type Handoff Request Packets to the client<br>
requesting a handoff to another mode, the client sends Interface Type Acknowledge<br>
Packets confirming a change is sought, and the host sends Perform Type Handoff<br>
Packets to make the change to the specified mode.<br>
[00592] Although, not requiring a particular order of processing, the client and host can<br>
also exchange packets relating to data intended for or received from pointing devices,<br>
keyboards, or other user type input devices associated primarily with the client,<br>
although such elements may also be present on the host side. These packets are<br>
typically processed using a general processor type element and not the state machine<br>
(5502). In addition, some of the commands discussed above will also be processed by<br>
the general processor. (5504, 5508)<br>
[00593] After data and commands have been exchanged between the host and client, at<br>
some point a decision is made as to whether or not additional data is to be transferred or<br>
the host or client is going to cease servicing the transfer. This is shown in step 5422. If<br>
the link is to enter either a hibernation state or be shut down completely, the host sends<br>
a Link Shutdown packet to the client, and both sides terminate the transfer of data.<br>
 [00594] The packets being transferred in the above operations processing will be<br>
transferred using the drivers and receivers previously discussed in relation to the host<br>
and client controllers. These line drivers and other logic elements are connected to the<br>
state machine and general processors discussed above, as illustrated in the overview of<br>
FIG. 55. In Fig. 55, a state machine 5502 and general processors 5504 and 5508 may<br>
further be connected to other elements not shown such as a dedicated USB interface,<br>
memory elements, or other components residing outside of the link controller with<br>
which they interact, including, but not limited to, the data source, and video control<br>
chips for view display devices.<br>
[00595] The processors, and state machine provide control over the enabling and<br>
disabling of the drivers as discussed above in relation to guard times, and so forth, to<br>
assure efficient establishment or termination of communication link, and transfer of<br>
packets.<br>
XVI Display Frame Buffers<br>
[00596] Video data buffering requirements are different for moving video images<br>
compared to computer graphics. Pixel data is most often stored in a local frame buffer<br>
in the client so the image on the client can be refreshed locally.<br>
[00597] When full-motion video is being displayed (nearly every pixel in the display<br>
changes each Media Frame) it is usually preferred to store the incoming pixel data in<br>
one frame buffer while the image on the display is being refreshed from a second frame<br>
buffer. More than two display buffers may be used to eliminate visible artifacts as<br>
described below. When an entire image has been received in one frame buffer then the<br>
roles of the buffers can be swapped, and the newly received image is then used to<br>
refresh the display and the other buffer is filled with the next frame of the image. This<br>
concept is illustrated in FIG. 91A, where pixel data is written to the offline image buffer<br>
by setting the Display Update bits to "01".<br>
[00598] In other applications the host needs to update only a small portion of the image<br>
without having to repaint the entire image. In this situation it is desired to write the new<br>
pixels directly to the buffer being used to refresh the display, as illustrated in detail FIG.<br>
91B.<br>
[00599] In applications that have a fixed image with a small video window it is easiest<br>
to write the fixed image to both buffers (display update bits equal to "11") as shown in<br>
FIG. 91C, and subsequently write the pixels of the moving image to the offline buffer<br>
by setting the display update bits to "01".<br>
[00600] The following rules describe the useful manipulation of buffer pointers while<br>
simultaneously writing new information to the client and refreshing the display. Three<br>
buffer pointers exist: current_fill points to the buffer currently being filled from data<br>
over the MDDI link. just_filled points to the buffer that was most recently filled.<br>
being_displayed points to the buffer currently being used to refresh the display. All<br>
three buffer pointers may contain values from 0 to N-l where N is the number of<br>
display buffers, and N &gt; 2. Arithmetic on buffer pointers is mod N, e.g. when N=3 and<br>
current_fill=2, incrementing current_fill causes current_fill to be set to 0. In the simple<br>
case where N=2, just_filled is always the complement of current_fill. On every MDDI<br>
Media Frame boundary (Sub-frame Header Packet with the Sub-frame Count field equal<br>
so zero) perform the following operations in the order specified: set just_filled equal to<br>
current_fill, and set current_fill equal to currentjfill + 1.<br>
[00601] MDDI Video Stream Packets update the buffers according to the structure or<br>
methodology of: when Display Update Bits equal to '01', pixel data is written to the<br>
buffer specified by current_fill; when Display Update Bits equal to '00', pixel data is<br>
written to the buffer specified by just_filled; and when Display Update Bits equal to<br>
"11", pixel data is written to all buffers. The display is refreshed from the buffer<br>
specified by the being_displayed pointer. After the display refreshes the last pixel in<br>
one frame refresh epoch and before it begins to refresh the first pixel in the next frame<br>
refresh epoch the display update process performs the operation of setting<br>
being_refreshed equal to just_filled;<br>
[00602] The Video Stream Packet contains a pair of Display Update Bits that specify<br>
the frame buffer where the pixel data is to be written. The Client Capability Packet has<br>
three additional bits that indicate which combinations of the Display Update Bits are<br>
supported in the client In many cases, computer-generated images need to be<br>
incrementally updated based on user input or derived from information received from a<br>
computer network. Display Update Bit combinations "00" and "11" support this mode<br>
of operation by causing the pixel data to be written to the frame buffer being displayed<br>
or to both frame buffers.<br>
[00603] When accommodating video images, FIG. 92 illustrates how video images are<br>
displayed using a pair of frame buffers when video data is transmitted over the MDDI<br>
link with the Display Update Bits equal to "01". After a media-frame boundary is<br>
detected on the MDDI link, the display refresh process will begin refreshing from the<br>
next frame buffer when the refresh process for the frame currently being refreshed is<br>
completed.<br>
[00604] An important assumption related to FIG 92 is that the image is received from<br>
the host as a continuous stream of pixels that are transmitted in the same order that the<br>
client uses to read the pixels from the frame buffer to refresh the display (usually upperleft,<br>
reading row by row, to the bottom-right corner of the screen. This is an important<br>
detail in the cases where the Display Refresh and Image Transfer operations reference<br>
the same frame buffer.<br>
[00605] It is necessary for the display refresh frame rate to be greater than the image<br>
transfer frame rate to avoid displaying partial images. FIG. 93 shows how image<br>
fragmentation can occur with a slow display refresh rate, that is the display refresh is<br>
slower than the image transfer.<br>
[00606] In an image that contains a combination of computer graphic images and<br>
moving video pictures the video pixel data might occupy a small portion of a mediaframe.<br>
This could be significant in situations where the display refresh operation and<br>
the image transfer reference the same frame buffer. These situations are shown by a<br>
cross-hatched shading in FIG. 94, where the pixels read from the buffer to refresh the<br>
display might be the pixels written to the buffer two frames ago, or they may correspond<br>
to the frame immediately being written to the same frame buffer.<br>
[00607] The use of three frame buffers in the client will resolve the problem of the<br>
small window of contention for access to a frame buffer as shown in FIG. 95.<br>
[00608] However, there is still a problem if the display refresh rate is less than the<br>
media-frame rate over the MDDI link as shown in FIG.96.<br>
[00609] The use of a single buffer for moving video images is somewhat problematic as<br>
shown FIG. 97. With the display refresh faster than the image transfer into the buffer,<br>
the image being refreshed sometimes will show the upper portion of the frame being<br>
written and the lower portion of the image will be the frame previously transferred.<br>
With the display refresh faster than the image transfer (the preferred mode of operation)<br>
there will be more frequent instances of frames showing a similar split image.<br>
XVII. Delay Value Table<br>
[00610] The Packet Processing Delay Parameters Packet uses a table-lookup function<br>
to calculate the predicted delay to process certain commands in the client. Values in the<br>
table increase in a logarithmic fashion to provide a very wide dynamic range of delay<br>
values. An exemplary table of delay values useful for implementing embodiments of<br>
the invention is found in Table XX below, with corresponding index values versus delay<br>
values.<br>
(Table Removed) [00611] The delay is computed by performing a table lookup using the specified<br>
parameter as an index into the table. This means a delay is equal to<br>
PacketProcessingTable(index). For example: if one of the parameters from the Delay<br>
Parameters List Item is an 8-bit value equal to 134, then the delay is equal to<br>
PacketProcessingTable(134) which is 16 /isec. The value 255 indicates that the<br>
command completion time cannot be determined by calculation, and that the host will<br>
check the Graphics Busy Flags in the Client Request and Status Packet or MCCS VCP<br>
Control Parameter B7h.<br>
[00612] In some cases this delay is multiplied by the height, width, or number of pixels<br>
in the destination image and added to other delays to compute the overall packet<br>
processing delay.<br>
XVIII Multiple Client Support<br>
[00613] The current protocol version does not appear to directly support multiple client<br>
devices. However, most packets contain a reserved Client ID field that can be used to<br>
address specific client devices in a system with multiple clients. Currently, for many<br>
applications this client ID or these client IDs are set to be zero. The sub-frame header<br>
packet also contains a field to indicate whether or not the host supports a multiple client<br>
system. Therefore, there is a manner in which multiple client devices would likely be<br>
connected and addressed in future applications of the MDD interface or protocol to aid<br>
system designers to plan for future compatibility with multiple client hosts and clients.<br>
[00614] In systems having multiple clients it is useful for clients to be connected to the<br>
host using a daisy-chain of clients, or using hubs, as shown in Fig. 98, or using a<br>
combination of these techniques as shown in FIG. 99.<br>
XVIII. Addendum<br>
[00615] In addition to the formats, structures, and contents discussed above for the<br>
various packets used to implement the architecture and protocol for embodiments of the<br>
invention, more detailed field contents or operations are presented here for some of the<br>
packet types. These are presented here to further clarify their respective use or<br>
operations to enable those skilled in the art to more readily understand and make use of<br>
the invention for a variety of applications. Only a few of the fields not already<br>
discussed are discussed further here. In addition, these fields are presented with<br>
exemplary definitions and values in relation to the embodiments presented above.<br>
However, such values are not to be taken as limitations of the invention, but represent<br>
one or more embodiments useful for implementing the interface and protocol, and not<br>
all embodiments need be practiced together or at the same time. Other values can be<br>
used in other embodiments to achieve the desired presentation of data or data rate<br>
transfer results, as will be understood by those skilled in the art.<br>
A. For Video Stream Packets<br>
[00616] In one embodiment, the Pixel Data Attributes field (2 byte) has a series of bit<br>
values that are interpreted as follows. Bits 1 and 0 select how the display pixel data is<br>
routed. For bit values of 11' data is displayed to or for both eyes, for bit values '10',<br>
data is routed only to the left eye, and for bit values '01', data is routed only to the right<br>
eye, and for bit values of '00' the data is routed to an alternate display as may be<br>
specified by bits 8 through 11 discussed below.<br>
[00617] Bit 2 indicates whether or not the Pixel Data is presented in an interlace format,<br>
with a value of '0' meaning the pixel data is in the standard progressive format, and that<br>
the row number (pixel Y coordinate) is incremented by 1 when advancing from one row<br>
to the next. When this bit has a value of'!', the pixel data is in interlace format, and the<br>
row number is incremented by 2 when advancing from one row to the next. Bit 3<br>
indicates that the Pixel Data is in alternate pixel format. This is similar to the standard<br>
interlace mode enabled by bit 2, but the interlacing is vertical instead of horizontal.<br>
When Bit 3 is '0' the Pixel Data is in the standard progressive format, and the column<br>
number (pixel X coordinate) is incremented by 1 as each successive pixel is received.<br>
When Bit 3 is '!' the Pixel Data is in alternate pixel format, and the column number is<br>
incremented by 2 as each pixel is received.<br>
[00618] Bit 4 indicates whether or not the Pixel data is related to a display or a camera,<br>
as where data is being transferred to or from an internal display for a wireless phone or<br>
similar device or even a portable computer, or such other devices as discussed above, or<br>
the data is being transferred to or from a camera built into or directly coupled to the<br>
device. When Bit 4 is '0' the Pixel data is being transferred to or from a display frame<br>
buffer. When Bit 4 is T Pixel data is being transferred to or from a camera or video<br>
device of some type, such devices being well known in the art.<br>
[00619] Bit 5 is used to indicate when the pixel data contains the next consecutive row<br>
of pixels in the display. This is considered the case when Bit 5 is set equal to T.<br>
When bit 5 is set to T then the X Left Edge, Y Top Edge, X Right Edge, Y Bottom<br>
Edge, X Start, and Y Start parameters are not defined and are ignored by the client.<br>
When Bit 15 is set at a logic-one level, this indicates that the pixel data in this packet is<br>
the last row of pixels in the image. Bit 8 of the Client Feature Capability Indicators<br>
field of the Client Capability Packet indicates whether this feature is supported.<br>
 [00620] Bits 7 and 6 are Display Update Bits that specify a frame buffer where the<br>
pixel data is to be written. The more specific effects are discussed elsewhere. For bit<br>
values of '01' Pixel data is written to the offline image buffer. For bit values of '00'<br>
Pixel data is written to the image buffer used to refresh the display. For bit values of<br>
'11' Pixel data is written to all image buffers. The bit values or combination of '10' is<br>
treated as an invalid value or designation and Pixel data is ignored and not written to<br>
any of the image buffers. This value may have use for future applications of the<br>
interface.<br>
[00621] Bits 8 through 11 form a 4-bit unsigned integer that specifies an alternate<br>
display or display location where pixel data is to be routed. Bits 0 and 1 are set equal to<br>
'00' in order for the display client to interpret bits 8 through 11 as an alternate display<br>
number. If bits 0 and 1 are not equal to '00' then bits 8 through 11 are set to logic-zero<br>
levels.<br>
[00622] Bits 12 through 14 are reserved for future use and are generally set to logiczero<br>
levels. Bit 15, as discussed, is used in conjunction with bit 5, and setting bit 15 to<br>
logic-one indicates that the row of pixels in the Pixel Data field is the last row of pixels<br>
in a frame of data. The next Video Stream Packet having bit 5 set to logic-one will<br>
correspond to the first row of pixels of the next video frame.<br>
[00623] The 2-byte X Start and Y Start fields specify the absolute X and Y coordinates<br>
of the point (X Start, Y Start) for the first pixel in the Pixel Data field. The 2-byte X<br>
Left Edge and Y Top Edge fields specify the X coordinate of the left edge and Y<br>
coordinate of the top edge of the screen window filled by the Pixel Data field, while the<br>
X Right Edge and Y Bottom Edge fields specify the X coordinate of the right edge, and<br>
the Y coordinate of the bottom edge of the window being updated.<br>
[00624] The Pixel Count field (2 bytes) specifies the number of pixels in the Pixel Data<br>
field below.<br>
[00625] The Parameter CRC field (2 bytes) contains a CRC of all bytes from the Packet<br>
Length to the Pixel Count. If this CRC fails to check then the entire packet is discarded.<br>
[00626] The Pixel Data field contains the raw video information that is to be displayed,<br>
and which is formatted in the manner described by the Video Data Format Descriptor<br>
field. The data is transmitted one "row" at a time as discussed elsewhere. When Bit 5<br>
of the Pixel Data Attributes field is set at logic level one, then the Pixel Data field<br>
contains exactly one row of pixels, with the first pixel being transmitted corresponding<br>
to the left-most pixel and the last pixel transmitted corresponding to the right-most<br>
pixel.<br>
[00627] The Pixel Data CRC field (2 bytes) contains a 16-bit CRC of only the Pixel<br>
Data. If a CRC verification of this value fails then the Pixel Data can still be used, but<br>
the CRC error count is incremented.<br>
B. For Audio Stream Packets<br>
[00628] In one embodiment, the Audio Channel ED field (1 byte) uses an 8 bit unsigned<br>
integer value to identify a particular audio channel to which audio data is sent by the<br>
client device. The physical audio channels are specified in or mapped to physical<br>
channels by this field as values of 0, 1, 2, 3, 4, 5, 6, or 7 which indicate the left front,<br>
right front, left rear, right rear, front center, sub-woofer, surround left, and surround<br>
right channels, respectively. An audio channel ID value of 254 indicates that the single<br>
stream of digital audio samples is sent to both the left front and right front channels.<br>
This simplifies communications for applications such as where a stereo headset is used<br>
for voice communication, productivity enhancement apps are used on a PDA, or other<br>
applications where a simple User Interface generates warning tones. Values for the ID<br>
field ranging from 8 through 253, and 255 are currently reserved for use where new<br>
designs desire additional designations, as anticipated by those skilled in the art.<br>
[00629] The Reserved 1 field (1 byte) is generally reserved for future use, and has all<br>
bits in this field set to zero. One function of this field is to cause all subsequent 2 byte<br>
fields to align to a 16-bit word address and cause 4-byte fields to align to a 32-bit word<br>
address.<br>
[00630] The Audio Sample Count field (2 bytes) specifies the number of audio samples<br>
in this packet.<br>
[00631] The Bits Per Sample and Packing field contains 1 byte that specifies the<br>
packing format of audio data. In one embodiment, the format generally employed is for<br>
Bits 4 through 0 to define the number of bits per PCM audio sample. Bit 5 then<br>
specifies whether or not the Digital Audio Data samples are packed. As mentioned<br>
above, FIG. 12 illustrates the difference between packed and byte-aligned audio<br>
samples. A value of '0' for Bit 5 indicates that each PCM audio sample in the Digital<br>
Audio Data field is byte-aligned with the interface byte boundary, and a value of T<br>
indicates that each successive PCM audio sample is packed up against the previous<br>
audio sample. This bit is effective only when the value defined in bits 4 through 0 (the<br>
number of bits per PCM audio sample) is not a multiple of eight. Bits 7 through 6 are<br>
reserved for use where system designs desire additional designations and are generally<br>
set at a value of zero.<br>
[00632] The Audio Sample Rate field (1 byte) specifies the audio PCM sample rate.<br>
The format employed is for a value of 0 to indicate a rate of 8,000 samples per second<br>
(sps), a value of 1 indicates 16,000 sps., value of 2 for 24,000 sps, value of 3 for 32,000<br>
sps, value of 4 for 40,000 sps, value of 5 for 48,000 sps, value of 6 for 11,025 sps, value<br>
of 7 for 22,050 sps, and value of 8 for 44,100 sps, respectively, with values of 9 through<br>
255 being reserved for future use, so they are currently set to zero.<br>
[00633] The Parameter CRC field (2 bytes) contains a 16-bit CRC of all bytes from the<br>
Packet Length to the Audio Sample Rate. If this CRC fails to check appropriately, then<br>
the entire packet is discarded. The Digital Audio Data field contains the raw audio<br>
samples to be played, and is usually in the form of a linear format as unsigned integers.<br>
The Audio Data CRC field (2 bytes) contains a 16-bit CRC of only the Audio Data. If<br>
this CRC fails to check, then the Audio Data can still be used, but the CRC error count<br>
is incremented.<br>
C. For User-Defined Stream Packets<br>
[00634] In one embodiment, the 2-byte Stream ID Number field is used to identify a<br>
particular user defined stream. The contents of the Stream Parameters and Stream Data<br>
fields, are typically defined by the MDDI equipment manufacturer. The 2-byte Stream<br>
Parameter CRC field contains a 16-bit CRC of all bytes of the stream parameters<br>
starting from the Packet Length to the Audio Coding byte. If this CRC fails to check,<br>
then the entire packet is discarded. Both the Stream Parameters and Stream Parameter<br>
CRC fields may be discarded if not needed by an end application of the MDD interface,<br>
that is, they are considered optional. The 2-byte Stream Data CRC field contains a CRC<br>
of only the Stream Data. If this CRC fails to check appropriately, then use of the<br>
Stream Data is optional, depending on the requirements of the application. Use of the<br>
stream data contingent on the CRC being good, generally requires that the stream data<br>
be buffered until the CRC is confirmed as being good. The CRC error count is<br>
incremented if the CRC does not check.<br>
D. For Color Map Packets<br>
[00635] The 2-byte hClient ID field contains information or values that are reserved for<br>
a Client ID, as used previously. Since this field is generally reserved for future use, the<br>
current value is set to zero, by setting the bits to '0'.<br>
[00636] The 2-byte Color Map Item Count field uses values to specify the total number<br>
of 3-byte color map items that are contained in the Color Map Data field, or the color<br>
map table entries that exist in the Color Map Data in this packet. In this embodiment,<br>
the number of bytes in the Color Map Data is 3 times the Color Map Item Count. The<br>
Color Map Item Count is set equal to zero to send no color map data. If the Color Map<br>
Size is zero then a Color Map Offset value is generally still sent but it is ignored by the<br>
display. The Color Map Offset field (4 bytes) specifies the offset of the Color Map<br>
Data in this packet from the beginning of the color map table in the client device.<br>
[00637] A 2-byte Parameter CRC field contains a CRC of all bytes from the Packet<br>
Length to the Audio Coding byte. If this CRC fails to check then the entire packet is<br>
discarded.<br>
[00638] For the Color Map Data field, the width of each color map location is a<br>
specified by the Color Map Item Size field, where in one embodiment the first part<br>
specifies the magnitude of blue, the second part specifies the magnitude of green, and<br>
the third part specifies the magnitude of red. The Color Map Size field specifies the<br>
number of 3-byte color map table items that exist in the Color Map Data field. If a<br>
single color map cannot fit into one Video Data Format and Color Map Packet, then the<br>
entire color map may be specified by sending multiple packets with different Color Map<br>
Data and Color Map Offsets in each packet. The number of bits of blue, green, and red<br>
in each color map data item is generally the same as specified in the Color Map RGB<br>
Width field of the Display Capability Packet.<br>
[00639] A 2-byte Color Map Data CRC field contains a CRC of only the Color Map<br>
Data. If this CRC fails to check then the Color Map Data can still be used but the CRC<br>
error count is incremented.<br>
[00640] Each color map data item is to be transmitted in the order: blue, green, red,<br>
with the least significant bit of each component transmitted first. The individual red,<br>
green, and blue components of each color map item are packed, but each color map item<br>
(the least significant bit of the blue component) should be byte-aligned. Fig. 100<br>
illustrates an example of color map data items with 6 bits of blue, 8 bits of green, and 7<br>
bits of red. For this example, the Color Map Item Size in the Color Map Packet is equal<br>
147<br>
to 21, and the Color Map RGB Width field of the Client Capability Packet is equal to<br>
0x0786.<br>
E. For Reverse Link Encapsulation Packets<br>
[00641] The Parameter CRC field (2 bytes) contains a 16-bit CRC of all bytes from the<br>
Packet Length to the Turn-Around Length. If this CRC fails to check, then the entire<br>
packet is discarded.<br>
[00642] In one embodiment, the Reverse Link Flags field (1 byte) contains a set of<br>
flags to request information from the client. If a bit (for example, Bit 0) is set to a logicone<br>
level, then the host requests the specified information from the display using the<br>
Client Capability Packet. If the bit is set to a logic-zero level, then the host does not<br>
need the information from the client. The remaining bits (here Bits 1 through 7) are<br>
reserved for future use and are set to zero. However, more bits can be used as desired to<br>
set flags for the reverse link.<br>
[00643] The Reverse Rate Divisor field (1 byte) specifies the number of MDDI_Stb<br>
cycles that occur in relation to the reverse link data clock. The reverse link data clock is<br>
equal to the forward link data clock divided by two times the Reverse Rate Divisor. The<br>
reverse link data rate is related to the reverse link data clock and the Interface Type on<br>
the reverse link. In this embodiment, for a Type 1 interface the reverse data rate equals<br>
the reverse link data clock, for Type 2, Type 3, and Type 4 interfaces the reverse data<br>
rates equal two times, four times, and eight times the reverse link data clock,<br>
respectively.<br>
[00644] The All Zero 1 field contains a group of bytes, here 8, that is set equal to zero<br>
in value by setting the bits at a logic-zero level, and is used to ensure that all<br>
MDDLJData signals are at a logic-zero level for a sufficient time to allow the client to<br>
begin recovering clock using only MDDI_Stb prior to disabling the host's line drivers<br>
during the Turn-Around 1 field. In one embodiment, the length of the All Zero 1 field<br>
is greater than or equal to the number of forward link byte transmission times in the<br>
round-trip delay of the cable.<br>
[00645] The Turn-Around 1 Length field (1 byte) specifies the total number of bytes<br>
that are allocated for Turn-Around 1, establishing the first turn-around period. The<br>
number of bytes specified by the Turn-Around 1 Length parameter are allocated to<br>
allow the MDDIJData line drivers in the client to enable, before the line drivers in the<br>
host are disabled. The client enables its MDDI_Data line drivers during bit 0 of Turn148<br>
Around 1 and the host disables its outputs so as to be completely disabled prior to the<br>
last bit of Turn-Around 1. The timing of the enabling of the client driver and disabling<br>
of the host driver processes are such that one or both drive the MDDI_Data signals to a<br>
logic-zero level throughout Turn Around 1 as seen by the line receivers at the host. The<br>
MDDI_Stb signal behaves as though MDDI_DataO were at a logic-zero level during the<br>
entire Turn Around 1 period. A more complete description of the setting of Tum-<br>
Around 1 is given above.<br>
[00646] The Reverse Data Packets field contains a series of data packets transferred<br>
from the client to host. The client may send filler packets or drive the MDDI_Data lines<br>
to a logic-zero state or level when it has no data to send to the host. In this<br>
embodiment, if the MDDI_Data lines are driven to zero, the host will interpret this as a<br>
packet with a zero length (not a valid length) and the host will accept no additional<br>
packets from the client for the duration of the current Reverse Link Encapsulation<br>
Packet.<br>
[00647] The Turn-Around 2 Length field (1 byte) specifies the total number of bytes<br>
that are allocated for Turn-Around 2, for establishing a second turn-around period. The<br>
number of bytes specified by the Turn-Around Length parameter are allocated to allow<br>
the MDDI_Data line drivers in the host to enable before the line drivers in the client are<br>
disabled. The host enables its MDDI_Data line drivers during bit 0 of the first byte in<br>
Turn-Around 2, and the client disables its outputs so that they are generally completely<br>
disabled prior to the last bit of Turn-Around 2. The timing of the disabling of the client<br>
driver and the enabling of the host driver processes are such that one or both drive the<br>
MDDIJData signals to a logic-zero level throughout, or during the entire, Turn Around<br>
2 period, as seen by the line receivers in the host. The MDDI_Stb signal behaves as<br>
though the MDDI JDataO were at a logic-zero level during substantially the entire Turn<br>
Around 2 period. A description of the setting of Turn-Around 2 is given above.<br>
[00648] The Reverse Data Packets field contains a series of data packets being<br>
transferred from the client to a host. As stated earlier, Filler packets are sent to fill the<br>
remaining space that is not used by other packet types.<br>
[00649] The All Zero 2 field contains a group of bytes (8 in this embodiment) that is<br>
set equal to zero in value by setting the bits at a logic-zero level, and is used to ensure<br>
that all MDDIJData signals are at a logic-zero level for a sufficient time to allow the<br>
client to begin recovering clock using both MDDI_DataO and MDDI_Stb after enabling<br>
the host's line drivers following the Turn-Around 2 field.<br>
F. For Client Capability Packets<br>
[00650] As illustrated for one embodiment, the Protocol Version field uses 2 bytes to<br>
specify a protocol version used by the client. The initial version is currently set equal to<br>
one, and will be changed over time as new versions are generated as would be known,<br>
while the Minimum Protocol Version field uses 2 bytes to specify the minimum<br>
protocol version that the client can employ or interpret. In this case, a zero value is also<br>
a valid value. The Data Rate Capability field (2 bytes) specifies the maximum data rate<br>
the client can receive on each data pair on the forward link of the interface, and is<br>
specified in the form of megabits per second (Mbps). The Interface Type Capability<br>
field (1 byte) specifies the interface types that are supported on the forward and reverse<br>
links. A bit set to T indicates that a specified interface type is supported , and a bit set<br>
to '0' indicates that the specified type is not supported. Hosts and clients should support<br>
at least Type 1 on the forward and reverse lines. There is no requirement to support a<br>
contiguous range of interface types. For example, it would be perfectly valid to support<br>
only Type 1 and Type 3, but not Type 3 and Type 4 in an interface. It is also not<br>
necessary for the forward and reverse links to operate with the same interface type.<br>
However, when a link comes out of hibernation both forward and reverse links should<br>
commence operating in Type 1 mode until other modes may be negotiated, selected, or<br>
otherwise approved for use by both the host and client.<br>
[00651] The supported interfaces are indicated in one embodiment by selecting Bit 0,<br>
Bit 1, or Bit 2 to select either a Type 2 (2 bit), Type 3 (4 bit), or Type 4 (8 bit) mode on<br>
the forward link, respectively; and Bit 3, Bit 4, or Bit 5 to select either a Type 2, Type 3,<br>
or Type 4 mode on the reverse link, respectively; with Bits 6 and 7 being reserved and<br>
generally set to zero at this time. The Bitmap Width and Height fields, here each being<br>
2 bytes, specify the width and height of the bitmap, respectively, in pixels.<br>
[00652] The Monochrome Capability field (1 byte) is used to specify the number of bits<br>
of resolution that can be displayed in a monochrome format. If a display cannot use a<br>
monochrome format then this value is set at zero. Bits 7 through 4 are reserved for<br>
future use and are, thus, set as zero. Bits 3 through 0 define the maximum number of<br>
bits of grayscale that can exist for each pixel. These four bits make it possible to<br>
specify values of 1 to 15 for each pixel. If the value is zero then monochrome format is<br>
not supported by the display.<br>
 [00653] The Bayer Capability field uses 1 byte to specify the number of bits of<br>
resolution, pixel group, and pixel order that can be transferred in Bayer format. If the<br>
client cannot use the Bayer format then this value is zero. The Bayer Capability field is<br>
composed of the following values: Bits 3 through 0 define the maximum number of bits<br>
of intensity that exist in each pixel, while Bits 5 through 4 define the pixel group pattern<br>
that is required, while Bits 8 through 6 define the pixel order that is required; with Bits<br>
14 through 9 being reserved for future use and generally set to zero in the meantime.<br>
Bit 15 when set to one indicates that the client can accept Bayer pixel data in either<br>
packed or unpacked format. If bit 15 is set to zero this indicates that the client can<br>
accept Bayer pixel data only in unpacked format.<br>
[00654] The Color Map Capability field (3 bytes) specifies the maximum number of<br>
table items that exist in the color map table in the display. If the display cannot use the<br>
color map format then this value is set at zero.<br>
[00655] The RGB Capability field (2 bytes) specifies the number of bits of resolution<br>
that can be displayed in RGB format. If the display cannot use the RGB format then<br>
this value is equal to zero. The RGB Capability word is composed of three separate<br>
unsigned values where: Bits 3 through 0 define the maximum number of bits of blue,<br>
Bits 7 through 4 define the maximum number of bits of green, and Bits 11 through 8<br>
define the maximum number of bits of red in each pixel. Currently, Bits 14 through 12<br>
are reserved for future use and are generally set to zero. Bits 14 through 12 are reserved<br>
for future use and generally set to zero. Bit 15 when set to one indicates that the client<br>
can accept RGB pixel data in either packed or unpacked format. If bit 15 is set to a<br>
logic-zero level, this indicates that the client can accept RGB pixel data only in<br>
unpacked format.<br>
[00656] The Y Cr Cb Capability field (2 bytes) specifies the number of bits of<br>
resolution that can be displayed in Y Cr Cb format. If the display cannot use the Y Cr<br>
Cb format then this value is set equal to zero. The Y Cr Cb Capability word is<br>
composed of three separate unsigned values where: Bits 3 through 0 define the<br>
maximum number of bits in the Cb sample, Bits 7 through 4 define the maximum<br>
number of bits in the Cr sample, Bits 11 through 8 define the maximum number of bits<br>
in the Y sample, and Bits 15 through 12 are currently reserved for future use and are set<br>
to zero.<br>
[00657] The Client Feature Capability field uses 4 bytes that contain a set of flags that<br>
indicate specific features in the client that are supported. A bit set to one indicates the<br>
capability is supported, and a bit set to zero indicates the capability is not supported. In<br>
one embodiment, the value for Bit 0 indicates whether or not Bitmap Block Transfer<br>
Packet (packet type 71) is supported. The value for Bits 1, 2, and 3 indicate whether or<br>
not Bitmap Area Fill Packet (packet type 72), Bitmap Pattern Fill Packet (packet type<br>
73), or Communication Link Data Channel Packet (packet type 74), respectively, are<br>
supported. The value for Bit 4 indicates whether or not the client has the capability to<br>
make one color transparent, while values for bits Bit 5 and 6 indicate if the client can<br>
accept video data or audio data in packed format, respectively, and the value for Bit 7<br>
indicates whether or not the client can send a reverse-link video stream from a camera.<br>
The value for Bit 8 indicates whether or not the client has the ability to receive a full<br>
line of pixel data and ignore display addressing as specified by bit 5 of the Pixel Data<br>
Attributes field of the Video Stream Packet, and the client can also detect frame sync or<br>
end of video frame data using bit 15 of the Pixel Data Attributes Field.<br>
[00658] The value for Bits 11 and 12 indicate when the client is communicating either<br>
with a pointing device and can send and receive Pointing Device Data Packets, or with a<br>
keyboard and can send and receive Keyboard Data Packets, respectively. The value for<br>
Bit 13 indicates whether or not the client has the ability to set one or more audio or<br>
video parameters by supporting the VCP Feature packets: Request VCP Feature Packet,<br>
VCP Feature Reply Packet, Set VCP Feature Packet, Request Valid Parameter Packet,<br>
and Valid Parameter Reply Packet. The value for Bit 14 indicates whether or not the<br>
client has the ability to write pixel data into the offline display frame buffer. If this bit<br>
is set to a logic-one level then the Display Update Bits (bits 7 and 6 of the Pixel Data<br>
Attributes field of the Video Stream Packet) may be set to the values '01'.<br>
[00659] The value for Bit 15 indicates when the client has the ability to write pixel data<br>
into only the display frame buffer currently being used to refresh the display image. If<br>
this bit is set to one then the Display Update Bits (bits 7 and 6 of the Pixel Data<br>
Attributes field of the Video Stream Packet) may be set to the values '00'. The value<br>
for Bit 16 indicates when the client has the ability to write pixel data from a single<br>
Video Stream Packet into all display frame buffers. If this bit is set to one then the<br>
Display Update Bits (bits 7 and 6 of the Pixel Data Attributes field of the Video Stream<br>
Packet) may be set to the value '11'.<br>
[00660] The value for Bit 17 indicates when a client has the ability to respond to the<br>
Request Specific Status Packet, the value for Bit 18 indicates when the client has the<br>
ability to respond to the Round Trip Delay Measurement Packet, the value for Bit 19<br>
indicates when the client has the ability to the Forward Link Skew Calibration Packet,<br>
and the value for Bit 20 indicates when the client has the ability to respond to the VESA<br>
MCCS Virtual Control Panel (VCP) packets.<br>
[00661] The value for Bit 21 indicates when the client has the ability to interpret the<br>
Request Specific Status Packet and respond with the Valid Status Reply List Packet.<br>
The client indicates an ability to return additional status in the Valid Parameter Reply<br>
List field of the Valid Status Reply List Packet as described elsewhere.<br>
[00662] The value for Bit 22 indicates whether or not the client has the ability to<br>
respond to the Register Access Packet. Bits 9 through 10 and 23 through 31 are<br>
currently reserved for future use or alternative designations useful for system designers<br>
and are generally set equal to zero.<br>
[00663] The Display Video Frame Rate Capability field (1 byte) specifies the<br>
maximum video frame update capability of the display in frames per second. A host<br>
may choose to update the image at a slower rate than the value specified in this field.<br>
[00664] The Audio Buffer Depth field (2 bytes) specifies the depth of the elastic buffer<br>
in a Display which is dedicated to each audio stream.<br>
[00665] The Audio Channel Capability field (2 bytes) contains a group of flags that<br>
indicate which audio channels are supported by the client or client connected device. A<br>
bit set to one indicates the channel is supported, and a bit set to zero indicates that<br>
channel is not supported. The Bit positions are assigned to the different channels, for<br>
example Bit positions 0,1, 2, 3,4, 5, 6, and 7 in one embodiment, indicate the left front,<br>
right front, left rear, right rear, front center, sub-woofer, surround left, and surround<br>
right channels, respectively. Bits 8 through 14 are currently reserved for future use, and<br>
are generally set to zero. In one embodiment Bit 15 is used to indicate if the client<br>
provides support for the Forward Audio Channel Enable Packet. If this is the case, Bit<br>
15 set to a logic-one level. If, however, the client is not capable of disabling audio<br>
channels as a result of the Forward Audio Channel Enable Packet or if the client does<br>
not support any audio capability, then this bit is set to a logic-zero level or value.<br>
[00666] A 2-byte Audio Sample Rate Capability field, for the forward link, contains a<br>
set of flags to indicate the audio sample rate capability of the client device. Bit<br>
positions are assigned to the different rates accordingly, such as Bits 0,1, 2, 3,4, 5, 6,7,<br>
and 8 being assigned to 8,000, 16,000, 24,000, 32,000, 40,000, 48,000, 11,025, 22,050,<br>
and 44,100 samples per second (SPS), respectively, with Bits 9 through 15 being<br>
reserved for future or alternative rate uses, as desired, so they are currently set to '0'.<br>
Setting a bit value for one of these bits to 'I1 indicates that that particular sample rate is<br>
supported, and setting the bit to '0' indicates that that sample rate is not supported.<br>
[00667] The Minimum Sub-frame Rate field (2 bytes) specifies the minimum subframe<br>
rate in frames per second. The minimum sub-frame rate keeps the client status<br>
update rate sufficient to read certain sensors or pointing devices in the client.<br>
[00668] A 2-byte Mic Sample Rate Capability field, for the reverse link, contains a set<br>
of flags that indicate the audio sample rate capability of a microphone in the client<br>
device. For purposes of the MDDI, a client device microphone is configured to<br>
minimally support at least an 8,000 sample per second rate. Bit positions for this field<br>
are assigned to the different rates with bit positions 0, 1, 2, 3, 4, 5, 6, 7, and 8, for<br>
example, being used to represent 8,000, 16,000, 24,000, 32,000, 40,000, 48,000, 11,025,<br>
22,050, and 44,100 samples per second (SPS), respectively, with Bits 9 through 15<br>
being reserved for future or alternative rate uses, as desired, so they are currently set to<br>
'0'. Setting a bit value for one of these bits to T indicates that that particular sample rate<br>
is supported, and setting the bit to '0' indicates that that sample rate is not supported. If<br>
no microphone is connected then each of the Mic Sample Rate Capability bits are set<br>
equal to zero.<br>
[00669] The Keyboard Data Format field (here 1 byte) specifies whether or not a<br>
keyboard is connected to the client system and the type of keyboard that is connected.<br>
In one embodiment, the value established by Bits 6 through 0 is used to define the type<br>
of keyboard that is connected. If the value is zero (0) then the keyboard type is<br>
considered as unknown. For a value of 1, the keyboard data format is considered to be a<br>
standard PS-2 style. Currently values in the range of 2 through 125 are not in use,<br>
being reserved for use of system designers and interface incorporators or product<br>
developers to define specific keyboard or input devices for use with the MDD interface<br>
and corresponding clients or hosts. A value of 126 is used to indicate that the keyboard<br>
data format is user-defined, while a value of 127 is used to indicate that a keyboard<br>
cannot be connected to this client. In addition, Bit 7 can be used to indicate whether or<br>
not the keyboard can communicate with the client. The intended use of this bit is to<br>
indicate when the keyboard can communicate with the client using a wireless link. Bit 7<br>
would be set to a zero level if bits 6 through 0 indicate that a keyboard cannot be<br>
connected to the client. Therefore, for one embodiment, when the value of Bit 7 is 0,<br>
the keyboard and client cannot communicate, while if the value of Bit 7 is 1, the<br>
keyboard and client have acknowledged that they can communicate with each other.<br>
154<br>
[00670] The Pointing Device Data Format field (here 1 byte) specifies whether or not a<br>
pointing device is connected to the client system and the type of pointing device that is<br>
connected. In one embodiment, the value established by Bits 6 through 0 is used to<br>
define the type of pointing device that is connected. If the value is zero (0) then the<br>
pointing device type is considered as unknown. For a value of 1, the pointing device<br>
data format is considered to be a standard PS-2 style. Currently values in the range of 2<br>
through 125 are not in use, being reserved for use of system designers and interface<br>
incorporators or product developers to define specific pointing device or input devices<br>
for use with the MDD interface and corresponding clients or hosts. A value of 126 is<br>
used to indicate that the pointing device data format is user-defined, while a value of<br>
127 is used to indicate that a pointing device cannot be connected to this client. In<br>
addition, Bit 7 can be used to indicate whether or not the pointing device can<br>
communicate with the client. The intended use of this bit is to indicate when the<br>
keyboard can communicate with the client using a wireless link. Bit 7 would be set to a<br>
zero level if bits 6 through 0 indicate that a pointing device cannot be connected to the<br>
client. Therefore, for one embodiment, when the value of Bit 7 is 0, the pointing device<br>
and client cannot communicate, while if the value of Bit 7 is 1, the pointing device and<br>
client have acknowledged that they can communicate with each other.<br>
[00671] The Content Protection Type field (2 bytes) contains a set of flags that indicate<br>
the type of digital content protection that is supported by the Display. Currently, bit<br>
position 0 is used to indicate when DTCP is supported and bit position 1 is used to<br>
indicate when HDCP is supported, with bit positions 2 through 15 being reserved for<br>
use with other protection schemes as desired or available, so they are currently set to<br>
zero.<br>
[00672] Mfr Name - 2 bytes that form a 16-bit value that contains the EISA 3-character<br>
ID of the manufacturer, packed into three 5-bit characters in the same manner as in the<br>
VESA EDK) specification. The character 'A' is represented as 00001 binary, the<br>
character 'Z' is represented as 11010 binary, and all letters between 'A' and 'Z' are<br>
represented as sequential binary values that correspond to the alphabetic sequence<br>
between 'A' and 'Z'. The most significant bit of the Mfr Name field is unused and shall<br>
always be zero. Example: a manufacturer represented by the string "XYZ" would have<br>
a Mfr Name value of Ox633a. If this field is not supported by the client it shall be set to<br>
zero.<br>
 [00673] Product Code - 2 bytes that contains a product code assigned by the display<br>
manufacturer. If this field is not supported by the client it shall be set to zero.<br>
[00674) Reserved 4-2 bytes that contain a 16-bit unsigned integer that is reserved for<br>
future use. All bits in this field shall be set to zero. The purpose of this field is to cause<br>
all subsequent 2 byte fields to align to a 16-bit word address and cause 4-byte fields to<br>
align to a 32-bit word address..<br>
[00675] Serial Number - 4 bytes that specifies the serial number of the display in<br>
numeric form. If this field is not supported by the client it shall be set to zero.<br>
[00676] Week of Manufacture - 1 byte that defines the week of manufacture of the<br>
display. This value shall be in the range of 1 to 53 if it is supported by the client. If this<br>
field is not supported by the client it shall be set to zero.<br>
[00677] Year of Manufacture - 1 byte that defines the year of manufacture of the<br>
display. This value is an offset from the year 1990. Years in the range of 1991 to 2245<br>
can be expressed by this field. Example: the year 2003 corresponds to a Year of<br>
Manufacture value of 13. If this field is not supported by the client it is set to zero.<br>
[00678] CRC - 2 bytes that contain a 16-bit CRC of all bytes in the packet including<br>
the Packet Length.<br>
G. For Client Request and Status Packets<br>
[00679] The Reverse Link Request field (3 byte) specifies the number of bytes the<br>
client needs in the reverse link in the next sub-frame to send information to the host.<br>
[00680] The CRC Error Count field (1 byte) indicates how many CRC errors have<br>
occurred since the beginning of the media-frame. The CRC count is reset when a subframe<br>
header packet with a Sub-frame Count of zero is sent. If the actual number of<br>
CRC errors exceeds 255 then this value generally saturates at 255.<br>
[00681] The Capability Change field uses 1 byte to indicate a change in the capability<br>
of the display. This could occur if a user connects a peripheral device such as a<br>
microphone, keyboard, or display, or for some other reason. When Bits[7:0] are equal<br>
to 0, then the capability has not changed since the last Client Capability Packet was<br>
sent. However, when Bits[7:0] are equal to 1 to 255, the capability has changed. The<br>
Client Capability Packet is examined to determine the new display characteristics.<br>
H. For Bit Block Transfer Packets<br>
[00682] The Window Upper Left Coordinate X Value and Y Value fields use 2 bytes<br>
each to specify the X and Y value of the coordinates of the upper left corner of the<br>
window to be moved. The Window Width and Height fields use 2 bytes each to specify<br>
the width and height of the window to be moved. The Window X Movement and Y<br>
Movement fields use 2 bytes each to specify the number of pixels that the window is to<br>
be moved horizontally and vertically, respectively. Typically, these coordinates are<br>
configured such that positive values for X cause the window to be moved to the right,<br>
and negative values cause movement to the left, while positive values for Y cause the<br>
window to be moved down, and negative values cause upward movement.<br>
I. For Bitmap Area Fill Packets<br>
[00683] Window Upper Left Coordinate X Value and Y Value fields use 2 bytes each<br>
to specify the X and Y value of the coordinates of the upper left corner of the window to<br>
be filled. The Window Width and Height fields (2 bytes each) specify the width and<br>
height of the window to be filled. The Video Data Format Descriptor field (2 bytes)<br>
specifies the format of the Pixel Area Fill Value. The format is the same as the same<br>
field in the Video Stream Packet. The Pixel Area Fill Value field (4 bytes) contains the<br>
pixel value to be filled into the window specified by the fields discussed above. The<br>
format of this pixel is specified in the Video Data Format Descriptor field.<br>
J. For Bitmap Pattern Fill Packets<br>
[00684] Window Upper Left Coordinate X Value and Y Value fields use 2 bytes each<br>
to specify the X and Y value of the coordinates of the upper left corner of the window to<br>
be filled. The Window Width and Height fields (2 bytes each) specify the width and<br>
height of the window to be filled. The Pattern Width and Pattern Height fields (2 bytes<br>
each) specify the width and height, respectively, of the fill pattern. The Horizontal<br>
Pattern Offset field (2 bytes) specifies a horizontal offset of the pixel data pattern from<br>
the left edge of the specified window to be filled. The value being specified is to be less<br>
than the value in the Pattern Width Field. The Vertical Pattern Offset field (2 bytes)<br>
specifies a vertical offset of the pixel data pattern from the top edge of the specified<br>
window to be filled. The value being specified is to be less than the value in the Pattern<br>
Height field.<br>
 [00685] The 2-byte Video Data Format Descriptor field specifies the format of the<br>
Pixel Area Fill Value. FIG. 11 illustrates how the Video Data Format Descriptor is<br>
coded. The format is the same as the same field in the Video Stream Packet.<br>
[00686] The Parameter CRC field (2 bytes) contains a CRC of all bytes from the Packet<br>
Length to the Video Format Descriptor. If this CRC fails to check then the entire packet<br>
is discarded. The Pattern Pixel Data field contains raw video information that specifies<br>
the fill pattern in the format specified by the Video Data Format Descriptor. Data is<br>
packed into bytes, and the first pixel of each row is to be byte-aligned. The fill pattern<br>
data is transmitted a row at a time. The Pattern Pixel Data CRC field (2 bytes) contains<br>
a CRC of only the Pattern Pixel Data. If this CRC fails to check then the Pattern Pixel<br>
Data can still be used but the CRC error count is incremented.<br>
K. Communication Link Data Channel Packets<br>
[00687] The Parameter CRC field (2 bytes) contain a 16-bit CRC of all bytes from the<br>
Packet Length to the Packet Type. If this CRC fails to check then the entire packet is<br>
discarded.<br>
[00688] The Communication Link Data field contains the raw data from the<br>
communication channel. This data is simply passed on to the computing device in the<br>
display.<br>
[00689] The Communication Link Data CRC field (2 bytes) contains a 16-bit CRC of<br>
only the Communication Link Data. If this CRC fails to check then the Communication<br>
Link Data is still used or useful, but the CRC error count is incremented.<br>
L. For Interface Type Handoff Request Packets<br>
[00690] The Interface Type field (1 byte) specifies the new interface type to use. The<br>
value in this field specifies the interface type in the following manner. If the value in<br>
Bit 7 is equal to '0' the Type handoff request is for the forward link, if it is equal to T,<br>
then the Type handoff request is for the reverse link. Bits 6 through 3 are reserved for<br>
future use, and are generally set to zero. Bits 2 through 0 are used to define the<br>
interface Type to be used, with a value of 1 meaning a handoff to Type 1 mode, value of<br>
2 a handoff to Type 2 mode, a value of 3 a handoff to Type 3 mode, and a value of 4 a<br>
handoff to Type 4 mode. The values of '0' and 5 through 7 are reserved for future<br>
designation of alternative modes or combinations of modes.<br>
M. For Interface Type Acknowledge Packets<br>
[00691] The Interface Type field (1 byte) has a value that confirms the new interface<br>
type to use. The value in this field specifies the interface type in the following manner.<br>
If Bit 7 is equal to '0' the Type handoff request is for the forward link, alternatively, if it<br>
is equal to T the Type handoff request is for the reverse link. Bit positions 6 through 3<br>
are currently reserved for use in designating other handoff types, as desired, and are<br>
generally set to zero. However, bit positions 2 through 0 are used define the interface<br>
Type to be used with a value of '0' indicating a negative acknowledge, or that the<br>
requested handoff cannot be performed, values of T, '2', '3', and '4' indicating handoff to<br>
Type 1, Type 2, Type 3, and Type 4 modes, respectively. Values of 5 through 7 are<br>
reserved for use with alternative designations of modes, as desired.<br>
N. For Perform Type Handoff Packets<br>
[00692] The 1-byte Interface Type field indicates the new interface type to use. The<br>
value present in this field specifies the interface type by first using the value of Bit 7 to<br>
determine whether or not the Type handoff is for the forward or reverse links. A value<br>
of '0' indicates the Type handoff request is for the forward link, and a value of T the<br>
reverse link. Bits 6 through 3 are reserved for future use, and as such are generally set<br>
to a value of zero. However, Bits 2 through 0 are used to define the interface Type to be<br>
used, with the values 1, 2, 3, and 4 specifying the use of handoff to Type 1, Type 2,<br>
Type 3, and Type 4 modes, respectively. The use of values 0 and 5 through 7 for these<br>
bits is reserved for future use.<br>
O. For Forward Audio Channel Enable Packets<br>
[00693] The Audio Channel Enable Mask field (1 byte) contains a group of flags that<br>
indicate which audio channels are to be enabled in a client. A bit set to one enables the<br>
corresponding channel, and a bit set to zero disables the corresponding channel Bits 0<br>
through 5 designate channels 0 through 5 which address left front, right front, left rear,<br>
right rear, front center, and sub-woofer channels, respectively. Bits 6 and 7 are reserved<br>
for future use, and in the mean time are generally set equal to zero.<br>
P. For Reverse Audio Sample Rate Packets<br>
[00694] The Audio Sample Rate field(l byte) specifies the digital audio sample rate.<br>
The values for this field are assigned to the different rates with values of 0, 1, 2, 3, 4, 5,<br>
6, 7, and 8 being used to designate 8,000, 16,000, 24,000, 32,000, 40,000, 48,000,<br>
11,025, 22,050, and 44,100 samples per second (SPS), respectively, with values of 9<br>
through 254 being reserved for use with alternative rates, as desired, so they are<br>
currently set to '0'. A value of 255 is used to disable the reverse-link audio stream.<br>
[00695] The Sample Format field (1 byte) specifies the format of the digital audio<br>
samples. When Bits[l:0] are equal to '0', the digital audio samples are in linear format,<br>
when they are equal to 1, the digital audio samples are in |^-Law format, and when they<br>
are equal to 2, the digital audio samples are in A-Law format. Bits[7:2] are reserved for<br>
alternate use in designating audio formats, as desired, and are generally set equal to<br>
zero.<br>
Q. For The Digital Content Protection Overhead Packets<br>
[00696] The Content Protection Type field (1 byte) specifies the digital content<br>
protection method that is used. A value of '0' indicates Digital Transmission Content<br>
Protection (DTCP) while a value of 1 indicates High-bandwidth Digital Content<br>
Protection System (HDCP). The value range of 2 through 255 is not currently specified<br>
but is reserved for use with alternative protection schemes as desired. The Content<br>
Protection Overhead Messages field is a variable length field containing content<br>
protection messages sent between the host and client.<br>
R. For The Transparent Color Enable Packets<br>
[00697] The Transparent Color Enable field (1 byte) specifies when transparent color<br>
mode is enabled or disabled. If Bit 0 is equal to 0 then transparent color mode is<br>
disabled, if it is equal to 1 then transparent color mode is enabled and the transparent<br>
color is specified by the following two parameters. Bits 1 through 7 of this byte are<br>
reserved for future use and are typically set equal to zero.<br>
[00698] The Video Data Format Descriptor field (2 bytes) specifies the format of the<br>
Pixel Area Fill Value. FIG. 11 illustrates how the Video Data Format Descriptor is<br>
coded. The format is generally the same as the same field in the Video Stream Packet.<br>
[00699] The Pixel Area Fill Value field uses 4 bytes allocated for the pixel value to be<br>
filled into the window specified above. The format of this pixel is specified in the<br>
Video Data Format Descriptor field.<br>
S. For The Round Trip Delay Measurement Packets<br>
[00700] The 2-byte Packet Length field specifies the total number of bytes in the packet<br>
not including the packet length field, and in one embodiment is selected to have a fixed<br>
length of 159. The 2-byte Packet Type field that identifies this packet type with a value<br>
of 82, identifying a packet as a Round Trip Delay Measurement Packet. The hClient ID<br>
field, as before is reserved for future use as a Client ID, and is generally set to zero.<br>
[00701] In one embodiment, the Parameter CRC field (2 bytes) contains a 16-bit CRC<br>
of all bytes from the Packet Length to the Packet Type. If this CRC fails to check then<br>
the entire packet is discarded.<br>
[00702] The Guard Time 1 field (here 64 bytes) is used to allow the MDDI_Data line<br>
drivers in the client to enable before the line drivers in the host are disabled. The client<br>
enables its MDDI_Data line drivers during bit 0 of Guard Time 1 and the host<br>
disenables its line drivers so as to be completely disabled prior to the last bit of Guard<br>
Time 1. The host and client both drive a logic-zero level during Guard Time 1 when<br>
they are not disabled. Another purpose of this field is to ensure that all MDDI_Data<br>
signals are at a logic-zero level for a sufficient time to allow the client to begin<br>
recovering a clock or clock signal using only MDDI_Stb prior to disabling the host's<br>
line drivers.<br>
[00703] The Measurement Period field is a 64 byte window used to allow the client to<br>
respond with two bytes of Oxff, and 30 bytes of 0x0 at half the data rate used on the<br>
forward link. This data rate corresponds to a Reverse Link Rate Divisor of 1. The<br>
client returns this response immediately at the time it perceives as being the beginning<br>
of the Measurement Period. This response from the client will be received at a host at<br>
precisely the round trip delay of the link plus logic delay in the client after the beginning<br>
of the first bit of the Measurement Period at the host.<br>
[00704] The All Zero 1 field (2 bytes) contains zeroes to allow the MDDIJData line<br>
drivers in the host and client to overlap so that MDDIJData is always driven. The host<br>
enables MDDI_Data line drivers during bit 0 of Guard Time 2, and the client also drives<br>
the signal to a logic-zero level as it did at the end of the Measurement Period.<br>
[00705] The value in the Guard Time 2 field (64 bytes) allows overlap of the<br>
Measurement Period driven by the client when the round trip delay is at the maximum<br>
amount that can be measured in the Measurement Period. The Client disables its line<br>
drivers during bit 0 of Guard Time 2 and the Host enables its line drivers immediately<br>
after the last bit of Guard Time 2. The host and client both drive a logic-zero level<br>
during Guard Time 2 when they are not disabled. Another purpose of this field is to<br>
ensure that all MDDIJData signals are at a logic-zero level for a sufficient time to allow<br>
the client to begin recovering a clock signal using both MDDI_DataO and MDDI_Stb<br>
after enabling the line drivers for a host.<br>
T. For The Forward Link Skew Calibration Packets<br>
[00706] In one embodiment, the Parameter CRC field (2 bytes) contains a 16-bit CRC<br>
of all bytes from the Packet Length to the Packet Type. If this CRC fails to check then<br>
the entire packet is discarded.<br>
[00707] The Calibration Data Sequence field contains a 512 byte data sequence that<br>
causes the MDDIJData signals to toggle at every data period. During the processing of<br>
the Calibration Data Sequence, the MDDI host controller sets all MDDI_Data signals<br>
equal to the strobe signal. The client clock recovery circuit should use only MDDI_Stb<br>
rather than MDDI_Stb Xor MDDI_DataO to recover the data clock while the Calibration<br>
Data Sequence field is being received by the client Display. Depending on the exact<br>
phase of the MDDI_Stb signal at the beginning of the Calibration Data Sequence field,<br>
the Calibration Data Sequence will generally be one of the following based on the<br>
interface Type being used when this packet is sent:<br>
Type I - Oxaa, Oxaa ... or 0x55,0x55...<br>
Type n - Oxcc, Oxcc ... or 0x33,0x33...<br>
Type IE - OxfO, OxfO ... or OxOf, OxOf ...<br>
Type IV - Oxff, 0x00, Oxff, 0x00 ... or 0x00, Oxff, 0x00, Oxff ...<br>
100708] An example of the possible MDDI_Data and MDDI_Stb waveforms for both<br>
the Type 1 and Type 2 Interfaces are shown in FIGS. 62 A and 62B, respectively.<br>
XVII. Conclusion<br>
[00709] While various embodiments of the present invention have been described<br>
above, it should be understood that they have been presented by way of example only,<br>
and not limitation. Thus, the breadth and scope of the present invention should not be<br>
limited by any of the above-described exemplary embodiments, but should be defined<br>
only in accordance with the following claims and their equivalents.<br><br><br><br><br>
We Claim<br>
1.	A system for providing client supported features and capabilities to a host [202] in a<br>
mobile display digital interface (MDDI) system, the system comprising:<br>
link controller [502] [504] for adding at least one field to a client capability packet [Fig 18]<br>
for the client [204] supported features and capabilities;<br>
link controller [502] [504] for providing values to each field of the at least one field unique<br>
to at least one client [204] in the client capability packet [Fig 18]   ; and characterized in<br>
that<br>
link controller [504] for transmitting the client capability packet [Fig 18] from the at least<br>
one client [204] to the host [202] after acquisition of forward link synchronization, wherein<br>
transmission of the client capability packet [Figure 18] is required when requested by the<br>
host [202] using a reverse link flag in a reverse link encapsulation packet [Fig. 17].<br>
2.	The system as claimed in 1 wherein the link controller [504] for adding at least one field<br>
comprises an identification (ID) field of a client device.<br>
3.The system as claimed in 2 wherein the ID field comprises at least one member from the group consisting of a product code, a name of manufacturer, a serial number, a week of manufacture and a year of manufacture.<br>
4.	The system as claimed in 2 wherein the link controller [504] for adding at least one field comprises a pointing device field of a client device.<br>
5.	The system as claimed in 4 wherein the pointing device field comprises at least one member from the group consisting of a value for an existence of the pointing device, a value for a type of pointing device and a value of a communication status of the pointing device with the at least one client.<br>
6.	The system as claimed in 2 wherein the link controller [504] for adding at least one field comprises adding a keyboard device field of a client device.<br>
7.	The system as claimed in 6 wherein the keyboard device field comprises at least one member from the group consisting of a value for an existence of a keyboard device, a value for a type of keyboard device, and a value of a communication status of the keyboard device with the at least one client.<br>
8.	A method for providing client supported features and capabilities to a host [202] in a<br>
mobile display digital interface (MDDI) system, the method comprising the steps of:<br>
adding at least one field to a client capability packet [Fig 18] for the client [204]<br>
supported features and capabilities;<br>
providing values to each field of the at least one field unique to at least one client [204] in the client capability packet and characterized in that<br>
transmitting the client capability packet [Fig 18] from the at least one client to the host [202] after acquisition of forward link synchronization, wherein transmission of the client capability packet [Fig 18] is required when requested by the host [202] using a reverse link flag in a reverse link encapsulation packet [Fig. 17].<br><br>
9.	The method as claimed in 8 wherein the step of adding at least one field<br>
comprises adding an identification (ID) field of a client device [204].<br>
10.	The method as claimed in 9 wherein the ID field comprises at least one member<br>
from the group consisting of a product code, a name of manufacturer, a serial number,<br>
a week of manufacture, and a year of manufacture.<br>
11.	The method as claimed in 8 wherein the step of adding at least one field comprises<br>
adding a pointing device field of a client device [204].<br>
12.	The method as claimed in 11 wherein the pointing device field comprises at least one member from the group consisting of a value for an existence of a pointing device, a value for a type of pointing device, and a value of a communication status of the pointing device with the at least one client [204].<br>
13.	The method as claimed in 8 wherein the step of adding at least one field comprises adding a keyboard device field of a client device.<br>
14.	The method as claimed in 13 wherein the keyboard device field comprises at least one member from the group consisting of a value for an existence of a keyboard device, a value for a type of keyboard device, and a value of a communication status of the keyboard device with the at least one client [204].<br>
15.	A system for reverse data sampling in a mobile display digital interface (MDDI)<br>
system as claimed in claim 1, the system comprising:<br>
link controller [502] for sending a round trip delay measurement packet from a host<br>
[202] to a client [204];<br>
link controller [504] for sending a pulse inside of a measurement window of the round<br>
trip   delay measurement packet to the host [202] by the client [204];<br>
link controller [502] for measuring a round trip delay of the MDDI system by detecting<br>
the pulse sent inside the measurement window of the round trip delay measurement<br>
packet;<br>
link controller [502] for determining a phase of the sent pulse; and<br>
link controller [504] for determining a time to begin sampling reverse data sent by the<br>
client based on the measured round trip delay.<br>
16.	The system as claimed in 15 wherein the link controller [504] for determining a time to begin sampling is configured for adding an offset.<br>
17.	The system as claimed in 16 wherein the link controller [504] for adding an offset comprises the means for determining a phase.<br>
18.	A method for reverse data sampling in a mobile display digital interface (MDDI) system as claimed in claim 8, the method comprising the steps of:<br>
sending a round trip delay measurement packet from a host [202] to a client [204]; sending a pulse inside of a measurement window of the round trip delay measurement packet to the host [202] by the client [204];<br><br>
measuring a round trip delay of the MDDI system by detecting the pulse sent inside the<br>
measurement window of the round trip delay measurement packet;<br>
determining a phase of the sent pulse; and<br>
determining a time to begin sampling reverse data sent by the client [204] based on the<br>
measured round trip delay.<br>
19.	The method as claimed in 18 wherein the step of determining an offset within a reverse link data bit of the reverse data.<br>
20.	The method as claimed in 19 wherein the offset is determined by the determined phase.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LUFic3RyYWN0LSgwNi0wMi0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-Abstract-(06-02-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LUFic3RyYWN0LSgxMS0wOC0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-Abstract-(11-08-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LUNsYWltcy0oMTEtMDgtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-Claims-(11-08-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LUNsYWltcy0oMTgtMDEtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-Claims-(18-01-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMDYtMDItMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-Correspondence Others-(06-02-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMTEtMDgtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-Correspondence Others-(11-08-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMjMtMDEtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-Correspondence Others-(23-01-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LWNvcnJlc3BvbmRlbmNlLSBvdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-correspondence- others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlLU90aGVycy0oMTAtMTEtMjAxMCkucGRm" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-Correspondence-Others-(10-11-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LUNvcnJlc3BvbmRlbmNlLU90aGVycy0oMTgtMDEtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-Correspondence-Others-(18-01-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LWNvcnJlc3BvbmRlbmNlLW90aGVycy0xLnBkZg==" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-correspondence-others-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LURlc2NyaXB0aW9uIChDb21wbGV0ZSktKDA2LTAyLTIwMTIpLnBkZg==" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-Description (Complete)-(06-02-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LURyYXdpbmdzLSgxMS0wOC0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-Drawings-(11-08-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LUZvcm0tMS0oMDYtMDItMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-Form-1-(06-02-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LUZvcm0tMTMtKDExLTA4LTIwMTEpLnBkZg==" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-Form-13-(11-08-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LWZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LUZvcm0tMi0oMDYtMDItMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-Form-2-(06-02-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LUZvcm0tMy0oMTAtMTEtMjAxMCkucGRm" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-Form-3-(10-11-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1ERUxOUC0yMDA2LUdQQS0oMTEtMDgtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">2105-DELNP-2006-GPA-(11-08-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LXBjdC0yMTAucGRm" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-pct-210.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjEwNS1kZWxucC0yMDA2LXBjdC0zMDQucGRm" target="_blank" style="word-wrap:break-word;">2105-delnp-2006-pct-304.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="255936-electronic-time-temperature-indicator-and-logger.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="255938-method-and-system-for-redirecting-messages-between-a-host-system-and-a-mobile-data-communication-device.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>255937</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2105/DELNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>15/2013</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>12-Apr-2013</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>05-Apr-2013</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>18-Apr-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 MORHOUSE DRIVE,SAN DIEGO, CA 92121 USA.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>WILEY GEORGE</td>
											<td>5740 BRITTANY FORREST LANE, SAN DIEGO, CALIFORINA 92130 USA.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>SHEKHAR SHASHANK</td>
											<td>1597 HOLEMAN DRIVE, ERIE, INDIANA 80516 USA.</td>
										</tr>
										<tr>
											<td>3</td>
											<td>ANDERSON JON JAMES</td>
											<td>7436 AUGUSTA DRIVE, BOULDER,COLORADO 80301 USA.</td>
										</tr>
										<tr>
											<td>4</td>
											<td>STEELE BRAIN</td>
											<td>1074 ILIAD WAY, LAFAYETTE,COLORADO, 80026 USA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04L 29/06</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2004/034115</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-10-15</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/511,742</td>
									<td>2003-10-15</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/255937-a-system-for-providing-client-supported-features-and-capabilies-to-a-host-in-a-mobile-display-digitial-interface-mddi-system-and-a-method-thereof by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:06:13 GMT -->
</html>
