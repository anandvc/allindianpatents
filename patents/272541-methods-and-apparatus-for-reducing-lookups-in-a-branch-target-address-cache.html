<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/272541-methods-and-apparatus-for-reducing-lookups-in-a-branch-target-address-cache by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:00:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 272541:METHODS AND APPARATUS FOR REDUCING LOOKUPS IN A BRANCH TARGET ADDRESS CACHE</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHODS AND APPARATUS FOR REDUCING LOOKUPS IN A BRANCH TARGET ADDRESS CACHE</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A technique for reducing lookups to a branch target address cache (BTAC) is disclosed. In this technique, a branch target address is retrieved from the BTAC in response to a miss in looking up an instruction address in an instruction cache (I-cache). The branch target address is associated with the instruction address. The branch target address retrieved from the BTAC is stored in the I-cache. With this disclosed technique, subsequent instruction addresses are looked up in the I-cache, nonparallel to the BTAC, thus saving power by reducing needless BTAC lookups.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>METHODS AND APPARATUS FOR REDUCING LOOKUPS IN A BRANCH TARGET ADDRESS CACHE<br><br>
Field of the Invention<br><br>
[0001] The present invention relates generally to the field of processors and, in particular, to a method of improving branch prediction by reducing lookups in a branch target address cache.<br><br>
Background<br><br>
[0002] Microprocessors perform computational tasks in a wide variety of applications.<br><br>
Improved processor performance is almost always desirable, to allow for faster operation and/or increased functionality through software changes. In many embedded applications, such as portable electronic devices, conserving power and faster throughput are also goals in processor design and implementation. [0003] Many modern processors employ a pipelined architecture, where sequential instructions, each having multiple execution steps, are overlapped in execution. For improved performance, the instructions should flow continuously through the pipeline. Any situation that causes instructions to stall in the pipeline can detrimentally influence performance. If instructions are flushed from the pipeline and subsequently re-fetched, both performance and power consumption suffer.<br><br>
[0004] Most programs include indirect branch instructions where the actual branching behavior is not known until the indirect branch instruction is evaluated deep in the pipeline. To avoid the stall that would result from waiting for actual evaluation of the indirect branch instruction, modern processors may employ some form of branch prediction, whereby the branching behavior of indirect branch instructions is predicted early in the pipeline. Based on the predicted branch evaluation, the processor speculatively fetches (prefetches) and process instructions from a predicted address - <br><br>
either the branch target address (if the branch is predicted to be taken) or the next sequential address after the branch instruction (if the branch is predicted not to be taken). Whether an indirect branch instruction is to be taken or not to be taken is referred to as determining the direction of the branch.<br><br>
[0005] Conventional branch prediction techniques include a branch target access cache (BTAC) positioned in a fetch stage of a processor pipeline and branch prediction logic. The BTAC stores the target address of an instruction previously fetched and is indexed by the instruction's address. I-caches are conventionally populated with instructions of various instruction types which were retrieved from a higher order cache or memory. BTACs are conventionally populated after an indirect branch instruction is actually resolved further down in the processor pipeline.<br><br>
[0006] In operation, conventional branch prediction techniques perform address lookups on prefetched instructions in both a BTAC and an I-cache in parallel. If there is a miss in the BTAC, these conventional branch techniques have thus consumed power in the BTAC lookup without finding a match. If there is a hit in the BTAC, the address looked up may be considered to be an indirect branch instruction. After BTAC lookup, conventional techniques invoke the branch prediction logic to determine whether a branch target address retrieved from the BTAC should be predicted taken or not. If the branch prediction logic predicts taken, the branch prediction logic redirects instruction flow by retrieving instructions beginning from the branch target address. [0007] Any sequential instructions which entered the processor pipeline since the branch instruction are typically flushed from the pipeline. The path defined by the BTAC lookup and subsequent branch prediction is typically a critical speed path because the shorter the timing of this path the smaller the amount of instructions which need to flushed from the processor pipeline before redirecting the instruction flow. <br><br>
Consequently, it is desirable for this path to be as short as possible to minimize the power expended in flushing instructions.<br><br>
[0008] Conventional techniques for reducing the time of the critical path include reducing the size of the BTAC and/or organizing the BTAC in a multi-way fashion. However, by reducing the size of the BTAC, the number of potential hits and, thus, the probability for finding a branch target address in the BTAC is reduced, lowering the effectiveness of the BTAC as a whole. Furthermore, by organizing the BTAC into a multi-way fashion, indexing into the BTAC may become quicker but time spent comparing may be increased. In these situations, the BTAC may be slower than the I- cache, thus, becoming the limiting factor in the parallel lookup portion of the critical path. Therefore, it is recognized that apparatus and methods are needed to reduce the time for redirecting instruction flow when an indirect branch instruction is found in a processor pipeline without decreasing the effectiveness of branch prediction.<br><br>
SUMMARY<br><br>
[0009] The present disclosure recognizes that conventional branch prediction techniques often needlessly consume power when lookups are made to an I-cache and BTAC in parallel and the lookups fail in the BTAC. This recognition is more evident when there is a hit in the I-cache and a miss in the BTAC which is likely due to the I- cache typically storing all types of instructions and the BTAC typically storing branch instruction addresses.<br><br>
[0010] According to one embodiment, a method for reducing lookups to a branch target address cache (BTAC) is disclosed. In this method, a branch target address is retrieved from the BTAC in response to a miss in looking up an instruction address in an instruction cache (I-cache). The branch target address is associated with the instruction address. The branch target address retrieved from the BTAC is stored in the I-cache. With this disclosed techniques, subsequent instruction addresses are advantageously <br><br>
looked up in the I-cache, nonparallel to the BTAC, thus saving power by reducing needless BTAC lookups.<br><br>
[0011] According to another embodiment, method of storing branch instructions into an instruction cache is disclosed. This method includes looking up a branch instruction address in an instruction cache (I-cache), retrieving a branch target address from a branch target address cache (BTAC) in response to an I-cache miss, and storing the branch target address into an entry in the I-cache.<br><br>
[0012] Another embodiment relates to a system for reducing lookups to a branch target address cache (BTAC). The system includes a BTAC and an instruction cache (I-cache) configured to retrieve a branch target address from the BTAC in response to a cache miss when looking up a first branch instruction address. The I-cache is further configured to store the branch target address.<br><br>
[0013] It is understood that other embodiments of the present invention will become readily apparent to those skilled in the art from the following detailed description, wherein various embodiments of the invention are shown and described by way of illustration. As will be realized, the invention is capable of other and different embodiments and its several details are capable of modification in various other respects, all without departing from the present invention. Accordingly, the drawings and detailed description are to be regarded as illustrative in nature and not as restrictive.<br><br>
BRIEF DESCRIPTION OF THE DRAWINGS<br><br>
[0014] FIG. 1 is a functional block diagram of an exemplary processor.<br><br>
[0015] FIGS. 2A-2C (collectively FIG. 2) illustrate a listing of an exemplary code segment and exemplary contents of an I-cache and a BTAC when the I-cache does not contain the branch instruction from the code segment. <br><br>
[0016] FIG. 3 illustrates exemplary contents of the I-cache of Fig. 1 after the I-cache is populated with instruction data from the BTAC.<br><br>
[0017] FIG. 4 is a flow chart illustrating a method of storing an indirect branch instruction into an I-cache and retrieving an instruction from the I-cache of Fig. 1.<br><br>
[0018] FIG. 5 is a flow chart illustrating a method of managing an I-cache on actual branch resolution.<br><br>
[0019] FIG. 6 is a functional block diagram of two processors sharing a common<br><br>
BTAC.<br><br>
DETAILED DESCRIPTION<br><br>
[0020] FIG. 1 depicts a functional block diagram of an exemplary processor 100. The processor 100 executes instructions in an instruction execution pipeline 112 according to control logic 114. In some embodiments, the pipeline 112 may be a superscalar design, with multiple parallel pipelines as described in further detail in connection with FIG. 6. The pipeline 112 includes various registers or latches 116A-D, organized in pipe stages, and one or more execution units such as arithmetic logic unit (ALU) 118. A General Purpose Register (GPR) file 120 provides registers comprising the top of the memory hierarchy.<br><br>
[0021] Data is accessed from a data cache (D-cache) 140, with memory address translation and permissions managed by a main Translation Lookaside Buffer (TLB) 142. In various embodiments, the ITLB 124 may comprise a copy of part of the TLB 142. Alternatively, the ITLB 124 and TLB 142 may be integrated. Similarly, in various embodiments of the processor 100, the I-cache 122 and D-cache 140 may be integrated, or unified. Misses in the I-cache 122 and/or the D-cache 140 cause an access to main (off-chip) memory 144, under the control of a memory interface 146. Misses in the I- cache 122 will be described in further detail in connection with the discussion of FIG. 4. <br><br>
[0022] The processor 100 may include an Input/Output (I/O) interface 148, controlling access to various peripheral devices 150. Those of skill in the art will recognize that numerous variations of the processor 100 are possible. For example, the processor 100 may include a second-level (L2) cache for either or both the I and D caches 122, 140. In addition, one or more of the functional blocks depicted in the processor 100 may be omitted from a particular embodiment.<br><br>
[0023] Processor 100 includes a branch prediction system 143. The branch prediction system 143 includes a BTAC 141, a branch predictor (BP) circuit 126, update logic circuit 160, and an optional predecode circuit 156. The BTAC 141 is configured to store one or more entries where each entry contains a branch instruction address and a branch target address corresponding to a fetch address. The BTAC 141 may store a combination of direct and indirect branch instruction addresses. [0024] The I-cache 122 and BTAC 141 are populated over a fill path 152 when an instruction address misses in the I-cache 122 and a request to receive the corresponding instruction from higher level memory over memory interface 146 is made. Once the instruction is received from memory interface 146, in a first embodiment, optional predecode logic circuit 156 is configured to determine whether received instruction is an indirect branch instruction. If it is, the received instruction's address is looked up in BTAC 141 over path 152 to see if there is a target address associated with the received instruction's address. If there is a hit in the BTAC 141, the received instruction and corresponding target address are written to I-cache 122. A miss in I-cache 122 and a hit in BTAC 141 may occur in a situation where an indirect branch instruction is mispredicted, thus causing some type of invalidation in I-cache 122. The types of I- cache invalidation will be discussed in further detail in connection with the discussion <br><br>
of FIG. 5. If the received instruction's address is not in the BTAC 141 (e.g. a miss), the received instruction is written to I-cache 122.<br><br>
[0025] A second embodiment removes the predecode logic circuit 156. In the second embodiment, instructions received through memory interface 146 will be looked up in BTAC 141 regardless of whether the received instruction is an indirect branch instruction. In this second embodiment, instructions, like the first embodiment, are forwarded to I-cache 122 for storing. However, in the first embodiment, BTAC lookups are limited to indirect branch instructions. In either embodiment, if a branch target address is stored in BTAC 141, it will also be stored to I-cache 122. [0026] Update control logic 160 adds a target address to the entry in the BTAC 141 after actual branch resolution takes place in the later stages of pipeline 112 over path 162. BTAC 141 updates I-cache 122 over path 154 to include both the indirect branch instruction and its corresponding target address. The term "predict not taken" refers to the BP circuit 126 predicting not to redirect the pipeline 112 in accordance with the branch target address.<br><br>
[0027] With memory address translation and permissions managed by an Instruction- side Translation Lookaside Buffer (ITLB) 124, instruction prefetch unit 128 fetches instructions from an instruction cache (I-cache or 1$) 122 over path 125. If a fetched instruction is found (e.g. hit) in I-cache 122 and the fetched instruction is associated with a corresponding branch target address, the BP circuit 126 predicts whether to take or not take a code path beginning at the target address. If the BP circuit 126 predicts that the target address should be taken, instruction prefetch unit 128 adjusts its program counter to begin fetching instruction from the target address, thus, redirecting the pipeline 112 in accordance with the branch target address. If the BP circuit 126 predicts that the target address should not be taken, the program counter is incremented to begin <br><br>
fetching instruction from the next sequential address. The operation of branch prediction system 143 will be described in more detail in connection with the discussion of FIGs. 4 and 5.<br><br>
[0028] The present disclosure contemplates an embodiment of combining the BTAC 141 and the I-cache 122 into an integral component. However, there are several reasons for separating the BTAC and I-cache into distinct components. An external BTAC as disclosed is only queried or read during fills into the I-cache. A conventional BTAC which is positioned in parallel with the I-cache is accessed each time the I-cache is accessed. By limiting the consulting of the BTAC as presently disclosed, the present disclosure saves power by reducing activity in the BTAC. Furthermore, this infrequent access of the BTAC allows the BTAC 141 to be a single-ported device, thus reducing design complexity.<br><br>
[0029] FIG. 2 A illustrate a listing 210 of an exemplary code segment containing an indirect branch instruction 212 at address OxOOOB. As depicted, the target of indirect branch instruction 212 is defined by the contents of register 1 (Rl). Since the contents of Rl may vary each time indirect branch instruction 212 is executed, branch prediction system 143 is utilized to determine whether to redirect the process pipeline 112 starting with the address as specified by the contents of Rl .<br><br>
[0030] FIG. 2B illustrates exemplary contents of the I-cache 230. I-cache 230 may suitably be similar to I-cache 122. I-cache 230 includes an instruction column 232, a valid bit column 234, and a branch target address column 236. An entry in column 232 represents an instruction. By convention, a "0" value in column 234 indicates that the branch target, if any, in column 236 is invalid whereas a "1" value in column 234 indicates that the branch target in column 236 along in the same row is valid. As <br><br>
depicted, I-cache 230 at a point in time where the program counter points to address OxOOOB does not contain an entry for indirect branch instruction 212 at address OxOOOB. [0031] FIG. 2C illustrates exemplary contents of BTAC 250. BTAC 250 may suitably be similar to BTAC 141. BTAC 250 includes branch instruction address column 252 and target address column 254. Column 252 may include direct branch instruction addresses, indirect branch instruction addresses, or any combination thereof. At the point in time where the program counter points to address OxOOOB, BTAC 250 contains an indirect branch instruction address 256 and its corresponding target address. Consequently, control logic 114 will cause the branch instruction 256 and its corresponding target address in BTAC 250 to store I-cache 230 on an I-cache miss. It is recognized that other information may be stored in both the I-cache 230 and BTAC 250 and that various organizations of I-cache 230 and BTAC 250 are contemplated by the present disclosure.<br><br>
[0032] FIG. 3 illustrates the I-cache 230 after the indirect branch instruction associated with indirect branch instruction address 256 and its corresponding target address (0x2000) are stored in I-cache 230 at address OxOOOB. Consequently, the next time the processor's program counter points to address OxOOOB, an I-cache lookup will hit and the target address 0x2000 will be assigned to the processor's program counter to begin redirecting the pipeline 112 with instructions at address 0x2000. As compared with conventional BTACs, the I-cache lookup in the present disclosure is performed on a prefetched instruction without performing a lookup in the BTAC, saving power consumption by reducing the number of BTAC lookups. As demonstrated, lookups in BTAC 250 are limited to situations where a particular indirect branch instruction is not found in the I-cache 230. <br><br>
[0033] FIG. 4 is a flow chart illustrating a method 400 of storing an indirect branch instruction into an I-cache and retrieving a branch target address from the I-cache of Fig. 1. Blocks 410, 420, 450, 455, 460, 465, 470, and 480 define the process to store an indirect branch instruction and branch target address into an I-cache such as I-cache 122 of Fig. 1. Blocks 410, 420, 425, 435, 438, 440, and 445 define the process for retrieving a branch target address from an I-cache. At block 410, an I-cache for an instruction based on the instruction's address is queried. For example, the instruction address stored in a processor's program counter may be utilized to query an I-cache. At block 420, the method 400 determines whether there is a hit in the I-cache. If there is not (a cache miss), the method 400 proceeds to block 450 to retrieve the corresponding instruction data from higher level memory. At block 450, instruction data is requested from higher level memory such as a layer 2 (L2) cache or off-chip memory. At block 455, the retrieved instruction data from higher level memory is received. At block 460, instruction address is looked up in the BTAC. At block 465, the method 400 determines whether the instruction address hits in the BTAC or, in other words, matches with an instruction address stored in the BTAC. If the instruction address hits in the BTAC, the method 400 proceeds to block 470 where a predicted branch target, if any, stored in the BTAC is added to the instruction data. On a hit in the BTAC, the predicted branch target will likely be stored in the BTAC as long as the branch target address of a previous instance of the indirect branch instruction has been previously resolved. The method 400 proceeds to block 480 where the instruction data is stored in the I-cache. [0034] Returning to block 465, if the instruction address misses in the BTAC, the method 400 proceeds to block 480. This transition from block 465 to 480 indicates the situation where the queried instruction address is neither in the I-cache or the BTAC. In this situation, a branch target address will be stored in the BTAC after the resolution of <br><br>
the actual branch target for the retrieved instruction data which occurs later in the processor pipeline as discussed in further detail in connection with FIG. 6. When the actual branch target is resolved, for example, update logic circuit 160 will cause both the BTAC and the I-cache to store the resolved branch target. [0035] Both blocks 465 and 475 proceed to block 480 where the instruction data is stored in the I-cache. Otherwise, the program counter is sequentially incremented. The method 400 then proceeds to block 410 to query the next address as specified by the program counter.<br><br>
[0036] Returning to block 420, if there is a hit in the I-cache meaning there is a corresponding entry in the I-cache, method 400 proceeds to block 425. At block 425, the method 400 determines whether the corresponding entry in the I-cache has a branch target address. In one embodiment, block 425 may be accomplished by interrogating a corresponding valid bit such as one stored in the valid bit column 234 of FIG. 2. If there is no valid branch target address associated with the I-cache hit, the instruction address is not an indirect branch instruction. Thus, the method 400 proceeds to block 445 where the non-branch instruction is retrieved from the I-cache and processed in a conventional manner. The method 400 proceeds to block 410 for querying the next address from the I-cache as specified by the program counter.<br><br>
[0037] If there is a valid branch target address corresponding to the entry, the method 400 proceeds to block 435. At block 435, the method 400 predicts whether a branch target address store in the corresponding entry should be taken. In one embodiment, the branch prediction circuit 126 makes this prediction. It should be noted that one skilled in the art will appreciate branch prediction techniques may be utilizing statistics, heuristics, predetermined parameters, and the like. At block 438, the method 400 tests whether the prediction is to be taken. If it is, the method 400 proceeds to block 440 <br><br>
where the branch target address is sent to the program counter such as instruction prefetch unit 128 in order for instructions to begin being fetched from the branch target address. The method 400 proceeds to block 410 to query the next address as specified by the program counter which in this path through the flow chart is the branch target address.<br><br>
[0038] Returning to block 438, if the path is predicted not taken, the method 400 proceeds to block 445 to process the instruction stored in the cache in a conventional manner. After block 445, the method 400 proceeds to block 410 for querying the next address in the program counter which in this path through the flowchart is the sequential address following the indirect branch instruction such as address OxOOOC in FIG. 2A, for example.<br><br>
[0039] FIG. 5 is a flow chart illustrating a method 500 of managing an I-cache on actual branch resolution. The method 500 is performed for situations where the actual branch target of an indirect branch instruction is calculated for the first time and where the prediction mechanism such as the branch prediction circuit 126 mispredicts the target of the indirect branch instruction. At block 510, an actual target of an indirect branch instruction is resolved. Such branch resolution may be performed as the indirect branch instruction is processed later in the processor pipeline.<br><br>
[0040] At block 520, the method 500 determines whether the actual target matches the predicted target or, for the case of the actual target is calculated for the first time, there is no predicted target. If the actual branch target does match with the predicted branch target, neither the BTAC or I-cache need to be updated. The method 500 proceeds to block 525 where it waits for the next branch instruction before proceeding back to block 510. <br><br>
[0041] If the actual branch target does not match with the predicted target, the method 500 detects a mispredict and proceeds to block 530. At least two situations may result in a mismatch. The first situation may occur the first time an indirect branch instruction is executed after previously being stored in the BTAC and I-cache without a branch target. In the first situation, the next sequential instruction after the indirect branch instruction may have been loaded in the processor pipeline. The second situation may occur if the predicted target address is different from the actual resolved target address. In the second situation, the next instruction as indicated in the predicted target address may have been loaded in the processor pipeline.<br><br>
[0042] At block 530, the processor pipeline, in either situation, has its instructions flushed from the pipeline to restore the pipeline to the branch point which is, in this case, the address of the indirect branch instruction. Consequently, instructions loaded in the processor pipeline subsequent to the indirect branch instruction regardless of whether those instructions were loaded beginning from a predicted target address or the next sequential address after the indirect branch instruction will be flushed from the processor pipeline. At block 540, the BTAC is updated to store the actual branch target address in its branch target address field such as column 254.<br><br>
[0043] At block 550, the I-cache is managed. For example, control logic circuit 114 may include logic to implement blocks 550A-550C. Blocks 550A-550C are alternative embodiments of block 550. At block 550A, the cache line corresponding to the predicted target address is invalidated. At block 550B, the branch target of the cache line corresponding to the predicted target address is invalidated. At block 550C, the branch target address of the cache line corresponding to the predicted target address is updated to reflect the actual target address. Block 550C is preferable when the first time <br><br>
an indirect branch instruction is executed after previously being stored in the BTAC and I-cache without a branch target.<br><br>
[0044] FIG. 6 is a functional block diagram of two processors 601 and 602 sharing a common BTAC 611. The shared BTAC 611 and processors 601 and 602 are preferably embodied in a single integrated circuit chip. Processor 601 includes its own multi-stage processor pipeline 620, I-cache 610, and branch prediction circuit 615. At stage 625, actual branch resolution takes place in order to update BTAC 611 and I-cache 610 with an indirect branch instruction and branch target address as previously described in FIGs. 4 and 5, respectively. Processor 602 includes its own multi-stage processor pipeline 640, I-cache 630 and branch prediction circuit 635. At stage 645, actual branch resolution takes place in order to update BTAC 611 and I-cache 630 with an indirect branch instruction and branch target address as previously described in FIGs. 4 and 5, respectively. As depicted, actual branch resolution may be performed at different stages in the processors' pipeline. Although FIG. 6 illustrate a common BTAC shared between two processors, it is noted that the present disclosure contemplates sharing a common BTAC between three or more processors. During operation, when an address is fetched from either I-cache 610 or I-cache 630 that contains a valid branch target address, the respective pipelines 620 and 640 begin prefetching instructions beginning from the branch target address.<br><br>
[0045] The various illustrative logical blocks, modules, circuits, elements, and/or components described in connection with the embodiments disclosed herein may be implemented or performed with a general purpose processor, a digital signal processor (DSP), an application specific integrated circuit (ASIC), a field programmable gate array (FPGA) or other programmable logic component, discrete gate or transistor logic, discrete hardware components, or any combination thereof designed to perform the <br><br>
functions described herein. A general-purpose processor may be a microprocessor, but in the alternative, the processor may be any conventional processor, controller, microcontroller, or state machine. A processor may also be implemented as a combination of computing components, e.g., a combination of a DSP and a microprocessor, a plurality of microprocessors, one or more microprocessors in conjunction with a DSP core, or any other such configuration.<br><br>
[0046] The methods described in connection with the embodiments disclosed herein may be embodied directly in hardware, in a software module executed by a processor, or in a combination of the two. A software module may reside in RAM memory, flash memory, ROM memory, EPROM memory, EEPROM memory, registers, hard disk, a removable disk, a CD-ROM, or any other form of storage medium known in the art. A storage medium may be coupled to the processor such that the processor can read information from, and write information to, the storage medium. In the alternative, the storage medium may be integral to the processor.<br><br>
[0047] While the invention is disclosed in the context of embodiments, it will be recognized that a wide variety of implementations may be employed by persons of ordinary skill in the art consistent with the above discussion and the claims which follow below. <br><br><br>
CLAIMS<br><br>
WHAT IS CLAIMED IS:<br><br>
1. A method for reducing lookups to a branch target address cache (BTAC) comprising:<br><br>
retrieving a branch target address from the BTAC in response to a miss in looking up a first instruction address in an instruction cache (I-cache); and<br><br>
storing the branch target address from the BTAC in the I-cache, the branch target address associated with the first instruction address in the I-cache.<br><br>
2. The method of claim 1 further comprising:<br><br>
looking up the first instruction address in the I-cache; and<br><br>
retrieving the branch target address associated with the first instruction address in the I-cache.<br><br>
3. The method of claim 2 further comprising:<br><br>
fetching the first instruction associated with the first instruction address; and<br><br>
predicting that a second instruction to be fetched is associated with the branch target address.<br><br>
4. The method of claim 3 further comprising:<br><br>
fetching the second instruction based on the branch target address.<br><br>
5. The method of claim 4 further comprising:<br><br>
detecting a mispredict for the first instruction.<br><br>
6. The method of claim 5 further comprising: <br><br>
managing the I-cache by at least one of invalidating an I-cache line, invalidating the branch target address in the I-cache line, and updating the branch target address in the I-cache.<br><br>
7. The method of claim 5 wherein detecting a mispredict for the first instruction comprises:<br><br>
calculating an actual branch target address for the first instruction; and<br><br>
comparing the actual branch target address with the branch target address in the I-cache, wherein the actual branch target address does not match the branch target address.<br><br>
8. A method of storing branch instructions into an instruction cache (I- cache) comprising:<br><br>
looking up a branch instruction address in an instruction cache (I-cache);<br><br>
retrieving a branch target address from a branch target address cache (BTAC) in response to an I-cache miss; and<br><br>
storing the branch target address into an entry in the I-cache.<br><br>
9. The method of claim 8 further comprising:<br><br>
retrieving the branch target address from the I-cache in response to an I-cache hit.<br><br>
10. The method of claim 9 further comprising :<br><br>
predicting that a next instruction to be fetched is associated with the branch target address.<br><br>
11. The method of claim 8 further comprising:<br><br>
updating the branch target address in the I-cache on a misprediction. <br><br><br>
12. The method of claim 11 wherein updating the branch target address in the entry on a misprediction further comprises:<br><br>
determining an actual branch address of the branch instruction; and<br><br>
comparing the actual branch address with the branch target address, wherein the actual branch resolution does not match with the predicted target address.<br><br>
13. The method of claim 9 further comprising :<br><br>
predicting whether to send the branch target address to be fetched.<br><br>
14. The method of claim 13 further comprising:<br><br>
sending the branch target address to be fetched.<br><br>
15. A system for reducing lookups to a branch target address cache (BTAC) comprising:<br><br>
a branch target access cache (BTAC); and<br><br>
an instruction cache (I-cache) configured to retrieve a branch target address from the BTAC in response to a cache miss when looking up a first branch instruction address, the I-cache further configured to store the branch target address.<br><br>
16. The system of claim 15 wherein the I-cache is further configured to have the first branch instruction address in the I-cache looked up and to have the branch target address associated with the first branch instruction address retrieved from the I-cache.<br><br>
17. The system of claim 15 wherein the I-cache is configured to have the first instruction associated with the first instruction address fetched, the system further comprising: <br><br>
a branch prediction circuit configured to predict that a second instruction to be fetched is associated with the branch target address.<br><br>
18. The system of claim 17 wherein the I-cache is configured to have the second instruction based on the branch target address fetched from the I-cache.<br><br>
19. The system of claim 18 further comprising:<br><br>
update logic circuit configured to mispredict the second instruction to be fetched.<br><br>
20. The system of claim 19 further comprising:<br><br>
control logic circuit configured to manage the I-cache by at least one of invalidating an I-cache line, invalidating the branch target address in the I-cache line, and updating the branch target address in the I-cache.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=JhZwcxDm7y75P0l4RNMPDw==&amp;amp;loc=vsnutRQWHdTHa1EUofPtPQ==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=JhZwcxDm7y75P0l4RNMPDw==&amp;amp;loc=vsnutRQWHdTHa1EUofPtPQ==</a></p>
		<br>
		<div class="pull-left">
			<a href="272540-control-system-with-wireless-address-domain-to-field-device-address-domain-translation.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="272542-sanitary-napkins-with-hydrophobic-lotions.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>272541</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>240/MUMNP/2009</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>15/2016</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>08-Apr-2016</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>07-Apr-2016</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>02-Feb-2009</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 Morehouse Drive San Diego California 92121-1714 United States of America</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>MORROW, Michael William</td>
											<td>205 Boltstone Court  Cary  North Carolina 27513  United States of America</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 9/38</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2007/075996</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2007-08-15</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/464,996</td>
									<td>2006-08-16</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/272541-methods-and-apparatus-for-reducing-lookups-in-a-branch-target-address-cache by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:00:32 GMT -->
</html>
