<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/277168-multiple-field-based-code-generator-and-decoder-for-communications-systems by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:18:04 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 277168:MULTIPLE-FIELD BASED CODE GENERATOR AND DECODER FOR COMMUNICATIONS SYSTEMS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">MULTIPLE-FIELD BASED CODE GENERATOR AND DECODER FOR COMMUNICATIONS SYSTEMS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method of encoding data for transmission from a source to a destination over a communications channel is provided. The method operates on an ordered set of input symbols and includes generating a plurality of redundant symbols from the input symbols based on linear constraints. The method also includes generating a plurality of output symbols from a combined set of symbols including the input symbols and the redundant symbols based on linear combinations, wherein at least one of the linear constraints or combinations is over a first finite field and at least one other of the linear constraints or combinations is over a different second finite field, and such that the ordered set of input symbols can be regenerated to a desired degree of accuracy from any predetermined number of the output symbols.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br>
<br>
MULTIPLE-FIELD BASED CODE GENERATOR AND DECODER FOR<br>
COMMUNICATIONS SYSTEMS<br>
CROSS-REFERENCES [0001]    This application claims priority from and is a non-provisional of U.S. Provisional Patent Application No. 60/775,528 filed February 21, 2006.<br>
[0002]    The following references are included here and are incorporated by reference for all purposes:<br>
[0003]    U.S. Patent No. 6,307,487 entitled "Information Additive Code Generator and Decoder for Communication Systems" issued to Luby (hereinafter "Luby I");<br>
[0004]    U.S. Patent No. 6,320,520 issued to Luby et al. entitled "Information Additive Group Code Generator and Decoder for Communication Systems" (hereinafter "Luby IF');<br>
[00051    U.S. Patent No. 7,068,729 issued to Shokrollahi et al. entitled "Multi-Stage Code Generator and Decoder for Communication Systems" (hereinafter "Shokrollahi I");<br>
[0006]    U.S. Patent No. 6,909,383 entitled "Systematic Encoding and Decoding of Chain Reaction Codes" issued to Shokrollahi et al. (hereinafter "Shokrollahi 11");<br>
[0007]    U.S. Patent No. 6,856,263 entitled "Systems and Processes for Decoding Chain Reaction Codes through Inactivation," issued to Shokrollahi et al. (hereinafter "Shokrollahi III"); and<br>
[0008]    U.S. Patent Publication No. 2005/0219070 Al entitled "Protection of Data from Erasures Using Subsymbol Based Codes" by Shokrollahi, filed December 1, 2004 (hereinafter "Shokrollahi IV").<br>
FIELD OF THE INVENTION [0009]    The present invention relates to encoding and decoding data in communications systems and more specifically to communication systems that encode and decode data to account for errors and gaps in communicated data. Communication is used in a broad sense, and includes but is not limited to transmission of digital data of any form through space and/or time.<br>
 <br>
BACKGROUND OF THE INVENTION [0010]    Transmission of files and streams between a sender and a recipient over a communications channel has been the subject of much literature. Preferably, a recipient desires to receive an exact copy of data transmitted over a channel by a sender with some level of certainty. Where the channel does not have perfect fidelity (which covers most all physically realizable systems), one concern is how to deal with data lost or garbled in transmission. Lost data (erasures) are often easier to deal with than corrupted data (errors) because the recipient cannot always tell when corrupted data is data received in error. Many error-correcting codes have been developed to correct for erasures and/or for errors. Typically, the particular code used is chosen based on some information about the infidelities of the channel through which the data is being transmitted and the nature of the data being transmitted. For example, where the channel is known to have long periods of infidelity, a burst error code might be best suited for that application. Where only short, infrequent errors are expected a simple parity code might be best.<br>
[0011]    Data transmission is straightforward when a transmitter and a receiver have all of the computing power and electrical power needed for communications and the channel between the transmitter and receiver is clean enough to allow for relatively error-free communications. The problem of data transmission becomes more difficult when the channel is in an adverse environment or the transmitter and/or receiver has limited capability.<br>
[0012]    One solution is the use of forward error correcting (FEC) techniques, wherein data is coded at the transmitter such that a receiver can recover from transmission erasures and errors. Where feasible, a reverse channel from the receiver to the transmitter allows for the receiver to communicate about errors to the transmitter, which can then adjust its transmission process accordingly. Often, however, a reverse channel is not available or feasible or is available only with limited capacity. For example, where the transmitter is transmitting to a large number of receivers, the transmitter might not be able to handle reverse channels from all those receivers. As another example, the communication channel may be a storage medium and thus the transmission of the data is forward through time and, unless someone invents a time travel machine that can go back in time, a reverse channel for this channel is infeasible. As a result, communication protocols often need to be designed without a reverse channel or with a limited capacity reverse channel and, as such, the transmitter may have to deal with widely varying channel conditions without a full view of those channel conditions.<br>
 <br>
[0013]    The problem of data transmission between transmitters and receivers is made more difficult when the receivers need to be low-power, small devices that might be portable or mobile and need to receive data at high bandwidths. For example, a wireless network might be set up to deliver files or streams from a stationary transmitter to a large or indeterminate number of portable or mobile receivers either as a broadcast or multicast where the receivers are constrained in their computing power, memory size, available electrical power, antenna size, device size and other design constraints. Another example is in storage applications where the receiver retrieves data from a storage medium which exhibits infidelities in reproduction of the original data. Such receivers are often embedded with the storage medium itself in devices, for example disk drives, which are highly constrained in teirns of computing power and electrical power.<br>
[0014]    In such a system, considerations to be addressed include having little or no reverse channel, limited memory, limited computing cycles, power, mobility and timing. Preferably, the design should minimize the amount of transmission time needed to deliver data to potentially a large population of receivers, where individual receivers and might be turned on and off at unpredictable times, move in and out of range, incur losses due to link errors, mobility, congestion forcing lower priority file or stream packets to be temporarily dropped, etc.<br>
[0015]    In the case of a packet protocol used for data transport over a channel that can lose packets, a file, stream or other block of data to be transmitted over a packet network is partitioned into equal size input symbols, encoding symbols the same size as the input symbols are generated from the input symbols using an FEC code, and the encoding symbols are placed and sent in packets. The "size" of a symbol can be measured in bits, whether or not the symbol is actually broken into a bit stream, where a symbol has a size of M bits when the symbol is selected from an alphabet of 2' symbols. In such a packet-based communication system, a packet oriented erasure FEC coding scheme might be suitable. A file transmission is called reliable if it allows the intended recipient to recover an exact copy of the original file even in the face of erasures in the network. A stream transmission is called reliable if it allows the intended recipient to recover an exact copy of each part of the stream in a timely manner even in the face of erasures in the network. Both file transmission and stream transmission can also be somewhat reliable, in the sense that some parts of the file or stream are not recoverable or for streaming if some parts of the stream are not recoverable in a timely fashion. Packet loss often occurs because sporadic congestion causes the<br>
 <br>
buffering mechanism in a router to reach its capacity, forcing it to drop incoming packets. Protection against erasures during transport has been the subject of much study.<br>
[0016]    In the case of a protocol used for data transmission over a noisy channel that can corrupt bits, a block of data to be transmitted over a data transmission channel is partitioned into equal size input symbols, encoding symbols of the same size are generated from the input symbols and the encoding symbols are sent over the channel. For such a noisy channel the size of a symbol is typically one bit or a few bits, whether or not a symbol is actually broken into a bit stream. In such a communication system, a bit-stream oriented error-correction FEC coding scheme might be suitable. A data transmission is called reliable if it allows the intended recipient to recover an exact copy of the original block even in the face of errors (symbol corruption, either detected or undetected in the channel). The transmission can also be somewhat reliable, in the sense that some parts of the block may remain corrupted after recovery. Symbols are often corrupted by sporadic noise, periodic noise, interference, weak signal, blockages in the channel, and a variety of other causes. Protection against data corruption during transport has been the subject of much study.<br>
[0017]    Chain reaction codes are FEC codes that allow for generation of an arbitrary number of output symbols fi"om the fixed input symbols of a file or stream. Sometimes, they are referred to as fountain or rateless FEC codes, since the code does not have an a priori fixed transmission rate. Chain reaction codes have many uses, including the generation of an arbitrary number of output symbols in an information additive way, as opposed to an information duplicative way, wherein the latter is where output symbols received by a receiver before being able to recover the input symbols duplicate already received information and thus do not provide useful information for recovering the input symbols. Novel techniques for generating, using and operating chain reaction codes are shown, for example, in Luby I, Luby II, Shokrollahi 1 and Shokrollahi II.<br>
[0018]    One property of the output symbols produced by a chain reaction encoder is that a receiver is able to recover the original file or block of the original stream as soon as enough output symbols have been received. Specifically, to recover the original K input symbols with a high probability, the receiver needs approximately K-f-A output symbols. The ratio A/K is called the "relative reception overhead." The relative reception overhead depends on the number K of input symbols, and on the reliability of the decoder.<br>
 <br>
(0019]    It is also known to use multi-stage chain reaction ("MSCR") codes, such as those described in Shokrollahi I and/or II and developed by Digital Fountain, Inc. under the trade name "Raptor" codes. Multi-stage chain reaction codes are used, for example, in an encoder that receives input symbols from a source file or source stream, generates intermediate symbols fi-om the input symbols and encodes the intermediate symbols using chain reaction codes. More particularly, a plurality of redundant symbols is generated from an ordered set of input symbols to be communicated. A plurality of output symbols are generated from a combined set of symbols including the input symbols and the redundant symbols, wherein the number of possible output symbols is much larger than the number of symbols in the combined set of symbols, wherein at least one output symbol is generated from more than one symbol in the combined set of symbols and from less than all of the symbols in the combined set of symbols, and such that the ordered set of input symbols can be regenerated to a desired degree of accuracy from any predetermined number, N, of the output symbols. It is also known to use the techniques described above to encode and decode systematic codes, in which the input symbols are includes amongst the possible output symbols of the code. This may be achieved as described in Shokrollahi II by first applying a transformation to the input symbols followed by the steps described above, said enhanced process resulting in the first output symbols generated by the code being equal to the input symbols. As will be clear to those of skill in the art of error and erasure coding, the techniques of Shokrollahi II may be applied directly to the codes described or suggested herein.<br>
[0020]    For some applications, other variations of codes might be more suitable or otherwise<br>
preferred.<br>
[0021]    The MSCR codes and chain reaction codes described above are extremely efficient in terms of their encoding and decoding complexity. One of the reasons for their efficiency is that the operafions that are performed are linear operafions over the field GF(2), i.e., the simple field over one bit where the operation of adding two field elements is simply the logical XOR operation, and the operation of multiplying two field elements is simply the logical AND operation. Generally these operations are performed over multiple bits concurrently, e.g., 32 bits at a time or 4 bytes at a time, and such operations are supported natively on all modem CPU processors. On the other hand, when used as erasure EEC codes, because the operations are over GF(2), it turns out that the chance that the receiver can decode all the input symbols goes down by at most approximately one-half for each additional symbol received beyond the first K, where K is the number of original input<br>
 <br>
symbols. For example, if K+A encoding symbols are received then the chance that the recover process fails to recover the K original input symbols is at least 2. What would be a more desirable behavior is if the chance of decoding failure decreased more rapidly as a function of A.<br>
[0022]    There are other erasure and error-correcting FEC codes that operate over larger fields, for example Reed-Solomon codes that operate over GF(4), or over GF(8), or over GF(256), or more generally over GF(2) for any L &gt; 1, and also LDPC codes that operate over larger fields. The advantage of such FEC codes is that, for example in the case of erasure FEC codes, the chance of decoding failure decreases much more rapidly as a function of A than FEC codes over GF(2). On the other hand, these FEC codes are typically much less efficient in terms of encoding and decoding complexity, and one of the primary reasons for that is because the operations over larger fields are much more complex and/or are not natively supported on modem CPUs, and the complexity typically grows as the field size grows. Thus, the FEC codes that operate over larger finite fields are oflen much slower or impractical compared to FEC codes that operate over GF(2).<br>
[0023]    Thus, what is needed are erasure and error-correcting FEC codes that are extremely efficient in terms of their encoding and decoding complexity with the property that the chance of decoding failure decreases very rapidly as a function of the number of symbols received beyond the minimal number needed by an ideal FEC code to recover the original input symbols.<br>
BRIEF SUMMARY OF THE INVENTION [0024]    According to one embodiment of the invention, a method of encoding data for transmissions from a source to a destination over a communications channel is provided. The method operates on an ordered set of input symbols and may generate zero or more redundant symbols from the input symbols, each redundant symbol being equal to a linear combination of a number of the input symbols with coefficients taken from one or more finite fields, wherein the finite field used may differ as between different input symbols and between different redundant symbols. The method includes generation of a plurality of output symbols from the combined set of symbols including the input symbols, and the redundant symbols if there are any redundant symbols, wherein each output symbol may be generated from one or more of the combined input and redundant symbols, wherein each output symbol is generated as a linear combination of a number of the input and redundant symbols with<br>
 <br>
coefficients taken from one or more finite fields wherein the finite field used may differ as between different input and redundant symbols, between different output symbols and between the output symbols and the redundant symbols and such that the ordered set of input symbols can be regenerated to a desired degree of accuracy from any predetermined number of the output symbols.<br>
[0025]    The methods can also be used to generate output symbols, wherein the number of possible output symbols that can be generated from a fixed set of input symbols may be much larger than the number of input symbols.<br>
(0026|    According to another embodiment of the invention, the method includes receiving at a destination at least some of the output symbols sent from a source over a communicafions channel, where the transmission over the channel may result in the loss or corruption of some of the sent symbols, and where some of the received symbols may be known to be correctly received and information about the degree of corruption of symbols may also be provided. The method includes regenerating at the destination the ordered set of input symbols to a desired degree of accuracy that depends on how many symbols are received and the knowledge of the corruption of the received symbols.<br>
[0027]    This embodiment can also include receiving at a destination at least some of the output symbols, wherein the number of possible output symbols that can be received may be much larger than the number of input symbols.<br>
[0028]    According to another embodiment of the invention, a method of encoding data for transmission from a source to a destination over a communications channel is provided. The method operates on an ordered set of input symbols and includes generating a plurality of redundant symbols from the input symbols. The method also includes generating a plurality of output symbols from a combined set of symbols including the input symbols and the redundant symbols, wherein the operation applied in the generation of output symbols is over a small finite field (for example GF(2)) and such that the ordered set of input symbols can be regenerated to a desired degree of accuracy from any predetermined number of the output symbols. The plurality of redundant symbols is generated from the ordered set of input symbols, wherein the operations to generate the redundant symbols is over a finite field that ij not GF(2) (for example, GF(256)) or is over a mix of more than one finite field (for example, some operations over GF(2), some operations over GF(256)).<br>
 <br>
(0029]    According to still another embodiment of the invention, a system for receiving data transmitted from a source over a communications channel is provided using similar techniques. The system comprises a receive module coupled to a communications channel for receiving output symbols transmitted over the communications channel, wherein each output symbol is generated from at least one symbol in the combined set of symbols including the input symbols and the redundant symbols, wherein the operation applied in the generation of output symbols is over a small finite field (for example GF(2)) and such that the ordered set of input symbols can be regenerated to a desired degree of accuracy from any predetermined number of the output symbols, wherein the input symbols are from an ordered set of input symbols, wherein the redundant symbols are generated from the input symbols and wherein the plurality of redundant symbols is generated from the ordered set of input symbols, wherein the operations to generate the redundant symbols is over a finite field that is not GF(2) (for example, GF(256)) or is over a mix of more than one finite field (for example, some operations over GF(2), some operations over GF(256)).<br>
(0030]    According to yet another embodiment of the invention, a computer data signal embodied in a carrier wave is provided.<br>
[0031]    Numerous benefits are achieved by way of the present invention. For example, in a specific embodiment, the computational expense of encoding data for transmission over a channel is reduced. In another specific embodiment, the computational expense of decoding such data is reduced. In yet another specific embodiment, the error probability of the decoder is reduced, while keeping the computational expense of encoding and decoding low. Depending upon the embodiment, one or more of these benefits may be achieved. These and other benefits are provided in more detail throughout the present specification and more particularly below.<br>
(0032]    A fiirther understanding of the nature and the advantages of the inventions disclosed herein may be realized by reference to the remaining portions of the specification and the attached drawings.<br>
 <br>
BRIEF DESCRIPTION OF THE DRAWINGS (0033]    Fig. 1 is a block diagram of a communications system according to one embodiment of the present invention.<br>
[00341    Fig- 2 is a block diagram an encoder according to one embodiment of the present invention.<br>
|0035]    Fig. 3 is a simplified block diagram of a method of generating redundant symbols according to one embodiment of the present invention.<br>
[0036]    Fig. 4 is a simplified block diagram of the basic operation of a static encoder according to one embodiment of the present invention.<br>
[0037)	Fig. 5 is a simplified block diagram of a dynamic encoder according to one<br>
embodiment of the present invention.<br>
(0038)	Fig. 6 is a simplified block diagram of a basic operation of a dynamic encoder<br>
according to one embodiment of the present invention.<br>
[0039]    Fig. 7 is a simplified block diagram of a static encoder according to one embodiment of the present invention.<br>
[0040]    Fig. 8 is a simplified block diagram of the basic operation a static encoder according to one embodiment of the present invention.<br>
[0041]    Fig. 9 is a simplified diagram of a method for calculating encoding parameters according to one specific embodiment of a static encoder.<br>
[0042]    Fig. 10 is a simplified flow diagram of a static encoder according to another embodiment of the present invention.<br>
[0043]    Fig. 11 is a simplified block diagram of a decoder according to one embodiment of the present invention.<br>
[0044]    Fig. ] 2 is a simplified flow diagram of an operation of a decoder according to one embodiment of the present invention.<br>
[0045]    Fig. 13 is a simplified flow diagram of an operation of a decoder according to another embodiment of the present invention.<br>
 <br>
[0046]    Fig. 14 is a simplified flow diagram of an operation of a decoder according to yet another embodiment of the present invention.<br>
10047]    Fig. 15 is a simplified block diagram of a dynamic decoder according to one embodiment of the present invention,<br>
|0048)    Fig. 16 is a simplified block diagram of a static decoder according to one embodiment of the present invention.<br>
[0049]    Fig. 17 illustrates source symbol from sub-symbol mappings.<br>
[0050)    Fig. 18 illustrates possible settings of file download parameters for vanous file sizes.<br>
[0051]    Fig. 19 illustrates possible settings of streaming parameters for various source block sizes.<br>
|0052]    Fig. 20 illustrates a form of a matrix that represents a relationship between source and intermediate symbols.<br>
{0053)    Fig. 21 illustrates a degree distribution for the degree generator.<br>
[0054]    Fig. 22 illustrates a form of the matrix. A that can be used for decoding.<br>
|0055]    Fig. 23 illustrates a block decomposition of the matrix A that can be used for decoding.<br>
|0056)    Fig. 24a illustrates a block decomposition of the matrix X that can be used for decoding.<br>
10057]    Fig. 24b illustrates a block decomposition of the matrix X after several steps of the first phase of the decoding process.<br>
[0058]    Fig. 25 illustrates a block decomposition of the matrix X after some elimination steps.<br>
[0059]    Fig. 26 illustrates a block decomposition of a sub-matrix of X after further elimination steps.<br>
[0060]    Fig. 27 illustrates a block decomposition of the matrix A after elimination and deletion steps.<br>
 <br>
(0061)    Fig. 28 illustrates a block decomposition of the matrix A after further elimination and deletion steps.<br>
[0062]    Fig. 29 illustrates a block decomposition of the matrix A after further elimination<br>
steps.<br>
10063]    Fig. 30 illustrates a block decomposition of the matrix A after yet fijrther elimination steps.<br>
(0064J    Fig. 31 shows a table of code failure probabilities for a (120,100) code constructed according to one preferred embodiment of the invention.<br>
J0065)    Fig. 32 shows a table of code failure probabilities for a (110,100) code constructed according to one preferred embodiment of the invention.<br>
f0066)    The detailed description is followed by three appendices: Appendix A contains example values for systematic indices J(K); Appendix B.l contains example values for table Vo; and Appendix B.2 contains example values for table Fj.<br>
DETAILED DESCRIPTION OF SPECIFIC EMBODIMENTS (0067)    The inventions described herein make use of mathematical operations for encoding and decoding based on operations in one or more finite fields. Finite fields are finite algebraic structures for which the four arithmetic operations are defined, and which form a field with respect to these operations. Their theory and their construction are well understood by those of skill in the art.<br>
[0068]    In the description that follows we shall require a multiplication process to be defined between the elements of a finite field and symbols which represent or are derived from the data to be encoded or decoded. Three distinct types of symbols are considered in this description: input symbols comprise information known to the sender which is to be communicated to the receiver, redundant symbols comprise symbols which are derived from the input symbols and output symbols comprise symbols which are transmitted by the sender to the receiver. Of the many possibilities for defining such a multiplication process, we concentrate on two particular ones: simple transformations, and interleaved transformations.<br>
Simple transformations<br>
[0069]    In this case, the multiplication process is defined between an element a from a finite<br>
field GFCZ**) and a symbol 5' that is M bits in length. As used herein, "symbol" refers to a<br>
 <br>
pieceof data that is typically smaller than the source block. The size of a symbol can often be measured in bits, where a syinbol has the size ofM bits and the symbol is selected from an alphabet of 2   symbols. In applications of reliable transmission of information over packet networks, for example, the size of a symbol could be equal to the packet size, or it could be smaller, so that each packet contains one or more syinbols.<br>
(0070)    In the case of simple transformation, the symbol Sis interpreted as an element of GF(2'*), and the multiplication a*S is defined as the normal multiplication in the field GF(2). The operation performed on the symbol is called a "simple transfomiation" of the symbol. As an illustrative example, consider the field GF(4). Elements of GF(4) can be represented with 2 bits, for example according to their binary expansion. The field GF(4) has four field elements 00, 01, 10, 11, wherein addition is the normal exclusive-or of bit strings, and multiplication is defined via the table:<br>
 <br>
[0071J    According to the above multiplication table the result of 10*01 would be 10, since 01 is the multiplicative neutral element (sometimes called the idenfity element) of the field.<br>
Interleaved transformations<br>
[0072]    To illustrate interleaved transformations, we will make use of the mathematical concept of a ring. As is well-known to those of ordinary skill in the art, a ring is a set on which two operations, addition and multiplicafion, are defined such that these operafions satisfy the distributive laws. Moreover, the set considered with addifion alone fornas an abelian group, i.e., the result of an addition is independent of the ordering of the summands, there is a neutral element 0 for addition, and for each element there is another element such that the sum of these elements is 0. The other requirement is that the multiplication has a neutral element 1, such that multiplicafion of any element with 1 does not change the value of that element. For a general ring, we do not require that any nonzero element has a multiplicative inverse, nor do we require that multiplication is commutative. When both these conditions are satisfied, however, then we call the ring a "field." This notation is a standard one in the area of algebra.<br>
 <br>
10073]    A mapping (symbol-wise sum) is a logical construct implementable in hardware, software, data storage, etc. that maps pairs of symbols of the same size to another symbol of that size. We denote this mapping by ®, and the image of this map on the pair (S,T) of symbols by 5 © T. An example of such a mapping is the bit-wise exclusive-or (XOR),<br>
[0074]    Another construct used here is that of the "action" of a special type of sets on symbols. Suppose that is a set equipped with a commutative addition operation "+" that has a neutral element and that, for every element, contains its additive inverse. Such a set is also commonly called an abelian group. An "action" of this group on the set of symbols is a mapping that maps a pair, comprising a group element r and a symbol S, to another symbol. We denote the image by r*S where this mapping respects addition in the group, i.e., for every pair of elements a and b in the group A, {a-b)*S'= a*S © b*S. If A is a ring and the action also respects multiplication in A, where the multiplication operator in A is •, i.e., (a»b)*S -a*{b*S), then this action is the desired multiplication process between elements of a finite field and symbols. In this setting we say that the field "operates" on the set of symbols. The operation performed on symbols in this way is called an "interleaved transformation."<br>
{0075]    There are abundant examples of such multiplication processes. A few examples are mentioned below. This list of examples is meant for illustrative purposes only, and should not be considered an exhaustive list, nor should it be construed to limit the scope of this invention.<br>
[0076]    The field GF(2) with field elements 0 and 1, with addition being exclusive-or (XOR) and multiplication being the logical operation AND, operates on the set of symbols by defining ] * S =" S, and 0*5=0, wherein S denotes an arbitrary symbol and 0 denotes the symbol that is entirely zeros.<br>
[0077]    The field GF(4) can operate on symbols of even size in the following way: for such a symbol S we denote by iS[0] and S[ 1 ] its first and second half, respectively, so that S = (5[0],S[1]) is the concatenation of 5[0] and [l]. Then, we define<br>
 <br>
 <br>
[0078]    It can be verified quickly that this is indeed a valid operation. It can be seen that the multiplication table of the field describes an operation that coincides with the operation defined above in the case of 2-bit symbols.<br>
[0079)    Alternatively, the field GF(4) can operate on symbols of even size in the following way; for such a symbol S we denote by S[0] the concatenation of the bits at even positions within S and similariy we denote by 5[1 ] the concatenation of the bits at odd positions within S (where positions are numbered sequentially starting with zero). For two equal length bit strings A and B, let (A | B) be defined to be the bit string C of twice the length where the bit in position 2*i of C is the bit in position / of A and the bit in position 2*/+l of C is the bit in position ;■+] of 5. Then, we define<br>
 <br>
[0080]    It can be verified quickly that this is indeed a valid operation. It can be seen that all the operations defined above are the same in the case of 2-bit symbols.<br>
[0081]    The interleaved transformations described above can be viewed as a particular case of an interleaved transformation in which the binary length of an element of the field coincides with the length of the sjTnbols in bits, and the operation of field elements on symbols is the same as the multiplication in the finite field.<br>
[0082]    More generally, if AT is an extension field of GF(2) of degree d, then an operation of the field can be defined on symbols whose size is divisible by d. Such an operation is described in the paper "An XOR-based erasure resilient coding scheme", by Bloemer, Kalfane, Karpinksi, Karp, Luby, and Zuckerman, published as Technical Report Number TR-95-048 of the International Computer Science Institute in Berkeley, 1995. This scheme uses the so-called "regular representation" of the field Kasdxd matrices with binary entries.<br>
[0083]    For these generalizations, the first interleaved transformation partitions 5, a string that is d*I bits in length, into d equal-size parts, where the first part 5'[0] is the first I bits of 5, S[\] is the next /bits of S, and S[d-\] is the last /bits of S. The transformation operates on the d parts ofS and produces d parts that are concatenated together to form the result of the operation. Alternatively, the second interleaved transformation partitions 5 into d equal-size parts, where the first part S[0] is the concatenation of each dih bit ofS starting at position 0 in<br>
 <br>
S, the second part 5[1] is the concatenation of each dih bit of 5 starting at position 1 in 5, the dth part S[d-\] is the concatenation of each dlh bit of 5 starting at position L-] in S. This second transformation operates on the <: of the same as first transformation and produces parts that are interleaved together to fonn result operation.></:>
10084)    Note that the first interleaved transformation can be computed by XORing consecutive bits of the original string S together, and this is a benefit for software implementations where typically a CPU supports such operations natively. On the other hand, the values of the bits in particular positions in the result of the operation depend on the length of the original string S, and this is somewhat of a disadvantage if one wants to implement the operation in hardware that supports variable length symbols, as the operation of the hardware needs to be different depending on the symbol length. Note that the second interleaved transformation involves XORing non-consecutive bits of the original string together, and this is somewhat of a disadvantage for software implementations where typically a CPU does not support such XORs as a native operation. Nevertheless, software operations that work on the finite field elements of the symbol directly can be implemented rather efficiently in software, and thus the software implementations of the second interleaved transformation are possible. Furthermore, for the second interleaved transformation the values of the bits in particular positions in the result of the operation does not depend on the length of the original string S, and this is a benefit if one wants to implement the operation in hardware that supports variable length symbols, as the operation of the hardware can be independent of the symbol length. Thus, the second interleaved transformation does have some overall advantages over the first interleaved transformation.<br>
Linear transformations<br>
[0085]    The concept of a "linear transformation" can be defined with reference to the simple or interleaved transformations. For given integers m and n, a linear transformation induced by the operation maps vectors of n symbols into vectors of m symbols using the space of matrices with entries in the specified field. A matrix over the field F is a 2-dimensional collection of entries, whose entries belong to F. If a matrix has m rows and n columns, then it is commonly referred to as an m x « matrix. The pair {m,n) is called the "format" of the matrix. Matrices of the same format can be added and subtracted, using the addition and subtraction in the underiying field or ring. A matrix of format (m,n) can be multiplied with a matrix of format (n,k) as is commonly known.<br>
 <br>
In operation, if 5 denotes a matrix with format (m,n), and By.k] denotes the entry of fi at position 0,), and if 5 denotes the column vector comprising the symbols S\, Sj, ■■■, S„, and X denotes the column vector comprising the symbols X], Xi, ...,X,„, then the transformation can be expressed as<br>
X = B®S. [00861    Thus, the following relationship is valid:<br>
for all; from 1 to m, Xj = B\j]*S © B[j,2]*Sz ® ... © B[i,n]*S„ wherein "*" denotes either a simple or an interieaved transformation.<br>
(0087]    The above formula describes a process for calculating A" from B and S in an encoder or decoder, referred to as a "simple transformation process" that can be performed by the steps of:<br>
1.	Setytol,andA}toO.<br>
2.	For values ofk from 1 to « do Xj = - ® B[j,k]*Sk-<br>
3.	Incrementy by 1. \ij is larger than m. then stop, otherwise go to step 2.<br>
[0088]    Such linear transformations are commonplace in a variety of applications. For example, when using a linear code to encode a piece of data, or source block, S could be the source symbols of the source block to be encoded, Z could be the encoded version of S, and B could be a generator matrix for the code. In other applications, for example where the code used is systematic, could be the redundant symbols of the encoding oiS, while B could be the matrix describing the dependency of the redundant symbols on the source symbols.<br>
[0089]    As will be known to those of skill to in the art, methods are known to perform the operations described above either through the provision of instructions executed within a general-purpose processor, through hardware designed specifically to perform such operations or through a combination of both. In all cases, the cost of the operations, in terms of the number of instructions required, the amount of hardware required, the cost of the hardware, the electrical power consumed by the operation and/or the time required to perform the operation is generally larger when larger finite fields are used. In particular, in the case of the field GF(2), the operations required are equivalent to bit-wise AND and XOR operations which are widely provided within general-purpose processors and simple, fast and inexpensive to implement in hardware where required. By contrast, operations using larger<br>
 <br>
finite fields than GF(2) are rarely provided directly in general-purpose processors and require either specialized hardware or a number of processor instructions and memory operations to perform.<br>
Multi-field Erasure and Error Correction Codes<br>
[0090]    Numerous specific embodiments of multi-field erasure and error correction codes are described herein by reference to a generalized matrix description. This approach is adopted as a descriptive tool only and does not represent a unique way to describe the embodiments described herein, nor should it be construed to limit the scope of this invention. In the generalized description, a matrix is constructed whose elements are taken from one or more finite fields. Different elements may be taken from different finite fields, with the property that there is a single field in which all the fields can be embedded and specific such embeddings are chosen. Some or all of the output symbols may be identical to some of the input or redundant symbols, or may be distinct from the input and redundant symbols depending on the particular embodiment chosen as will be illustrated further below.<br>
[0091]    A one-to-one correspondence is made between the input symbols of the code and some of the columns of the matrix. A further one-to-one correspondence is made between the redundant symbols of the code and the remaining columns of the matrix. Furthermore, a number of rows of the matrix equal to the number of redundant symbols are designated as static rows. Remaining rows of the matrix are designated as dynamic rows. A one to one correspondence is made between the dynamic rows of the matrix and the output symbols of the code. In this description, static rows represent constraints which are required to hold between the input and the redundant symbols and the static rows fully define the relationship between input and redundant symbols such that knowledge of the input symbols and the static rows is sufficient to construct the redundant symbols. Dynamic rows represent the output symbols which are actually sent on the channel. In many codes, the input and/or redundant symbols themselves are sent and this is represented in this descripfion by adding a dynamic row for each input and redundant symbol that is to be transmitted, said dynamic row having a non-zero entry in the column corresponding to the required input or redundant symbol and zero entries in the remaining columns. In some embodiments, the non-zero entry is the identity. In other embodiments, this non-zero entry need not be the identity element.<br>
[0092]    A matrix of the form described above may be used to determine a method of encoding data for transmission from a source to a destination over a communications channel.<br>
 <br>
the method comprising generating a plurality of redundant symbols from an ordered set of input symbols, wherein each redundant symbol is generated based on a set of linear constraints over one or more of the input symbols and other redundant symbols with coefficients over finite fields, said linear constraints corresponding to the static rows of the matrix description, generating a plurality of output symbols from the combined set of input and redundant symbols, wherein each output symbol is generated as a linear combination of one or more of the combined set of input and redundant symbols with coefficients chosen from finite fields, said linear constraints corresponding to the dynamic rows of the matrix description and sending at least some of the plurality of generated output symbols.<br>
|0093]    Conversely, a method comprising the above steps may be described in terms of a matrix of the kind described above in which the static rows correspond to the linear constraints over one or more of the input symbols and redundant symbols and the dynamic rows correspond to the linear combinations of the input and redundant symbols which are used to form the output symbols. In practice, embodiments of the method described above may not involve explicit or implicit representation or construction of the matrix described.<br>
[0094]    As is well-known, in the case that all elements of the matrix are taken from the field GF(2), then a large class of well-known error-correction and erasure-corrections codes can be described in this way. For example, for the case of Low-Density Parity Check (LDPC) codes, including for example those described in the paper entitled "Design, Evaluation and Comparison of Four Large Block FEC Codecs, LDPC, LDGM, LDGM Staircase and LDGM Triangle, plus a Reed-Solomon Small Block FEC Codec" by V. Roca and C. Neumann published as INRIA Research Report RR-5225, June 2004, available at www.inrialpes.fr (refened to hereinafter as "Roca"), the generalized matrix can be constructed from the parity check matrix by designating every row of the parity check matrix as a static row and adding a further dynamic row for each input and redundant symbol as described above. Another example might use the single-stage chain reaction codes described in Luby I and Luby II, in which the number of static rows in the matrix is zero and the dynamic rows comprise a standard chain reaction matrix. Another example is the use of MSCR codes, in which case the generalized description here is equivalent to the standard matrix presentation of such codes.<br>
[0095]    Other codes over larger fields can also be described in this way. For example, Reed-Solomon codes such as those derived from Vandermonde matrices in which the input<br>
 <br>
symbols are the source symbols, the generalized matrix is equal to the Vandermonde matrix and all rows are dynamic, where in this case each entry is a finite field element from a field that has at least as many elements in its multiplicative group as there are rows and columns in total, e.g., the finite field GF(256) when the number of rows and columns in total is less than 256. Another example is systematic Reed-Solomon codes over a finite field such as GF(256) which are derived ft'om Vandermonde matrices in which case the input symbols are the source symbols, the redundant symbols are the parity symbols, and the matrix is the rows corresponding to the parity symbols within the systematic form of the Vandermonde matrix with all such rows considered static and additional dynamic rows are added for each source and parity symbol as described above since these are exactly the symbols sent over the channel<br>
(0096)    As is well-known to those of skill in the art of error and erasure correcting codes, desirable properties of error and erasure correcting include low encoding complexity, low decoding complexity, low decoding error probability and low error floor. The complexity of a code is a measure of the computational resources required to encode or decode the code. Low complexity is of especial value in applications where encoding or decoding is to be performed by resource constrained devices such as mobile terminals, consumer electronics devices, storage devices or devices which may process many encoding or decoding operations simultaneously. Computational complexity is a function in part of the density of the matrix used to encode and decode the code and of the size of the finite field firom which the matrix elements are taken. Dense matrices generally result in higher complexity and this has led to many designs of codes based on sparse matrices, for example Low Density Parity Check codes and chain reacfion codes. Larger finite fields also result in higher complexity, which has led to many designs of code based on small fields, most commonly GF(2).<br>
[0097]    Error probability in this context is the probability that completely successful decoding is not possible. Error probability for a given error correcting or erasure correcfing code is a function of the information received over the channel, and the specific algorithm used for decoding. In the case of erasure correction codes the error probability is one whenever fewer symbols are received than the number of input symbols. Ideal erasure codes have the property that the error probability is zero whenever the number of symbols received is greater than or equal to the number of input symbols. Other codes have non-zero probability of failure in this case.<br>
 <br>
[0098]    It is known that ideal erasure codes can be constructed using dense matrices, in particular Reed-Solomon codes. However, in the case of Reed-Solomon codes the size of the field required is a fimction of the code size, which is the sum of the number of input and redundant symbols, and this fact, together with the density of the matrix results in generally high computational complexity, especially as the code size grows. Furthermore, in the case of low density codes, it is known that larger finite fields can be used to reduce error probability for error correction codes (as is demonstrated for example in the paper "Low Density Parity Check Codes over GF(q)" by M.C. Davey and D.J.C. MacKay, which has appeared in the IEEE Communications Letters, volume 2, number 6, pages 165-167, 1998) and for erasure codes. Additionally, it is known that introduction of a small number of high density matrix rows or columns into a low density code can improve the error probability, providing a compromise between error probability and complexity [MSCR codes and chain reaction codes]. However, a disadvantage of all such codes is that there is always a significant trade¬off between low complexity and low error probability.<br>
[0099]    For many FEC codes, i.e., LDPC codes and chain reaction codes and MSRC codes, as more output symbols than the number of input symbols are received, the error probability for successfial decoding decreases exponentially at some rate. The error floor of such a code is the error probability at which receipt of additional output symbols decreases the error probability at a much slower rate than when the number of received output symbols first exceeds the number of input symbols. It is known that use of a small number of high density rows or columns and/or the use of a larger finite field for the matrix can result in lower error floor at the cost of higher computational complexity. A disadvantage of many known error and erasure correction codes with low complexity is that the error floor is higher than desirable.<br>
[0100]    Herein, novel methods are described for construction of error correction and erasure correction codes which address some of the disadvantages mentioned above. Methods for efficient encoding and decoding of such codes are presented with relation to specific embodiments described herein by way of example.<br>
[0101]    The choice of fields for the matrix elements from a set of more than one possible field as described herein permits the design of codes which retain the low computational complexity of codes over small fields with the low error probability and error floor of codes over larger fields and thus represents a significant advantage over the state of the art.<br>
 <br>
(0102)    In one preferred embodiment which will be described in more detail below, for the majority of the rows the entries are chosen from GF(2) and for the remainder of the rows the entries are chosen fi-om GF(256). In another embodiment, for each row exactly one entry is chosen from GF(256) and the remaining elements are chosen from GF(2).<br>
10103]    There are many other possible embodiments of use of elements from more than one field that result in an improvement in the trade-off between computational complexity and error probability and error floor compared to codes known in the art in which all elements are selected from the same field.<br>
I0104J    As used herein, the term "file" refers to any data that is stored at one or more sources and is to be delivered as a unit to one or more destinations. Thus, a document, an image, and a file from a file server or computer storage device, are all examples of "files" that can be delivered. Files can be of known size (such as a one megabyte image stored on a hard disk) or can be of unknown size (such as a file taken from the output of a streaming source). Either way, the file is a sequence of input symbols, where each input symbol has a position in the file and a value.<br>
10105]    As used herein, the term "stream" refers to any data that is stored or generated at one or more sources and is delivered at a specified rate at each point in time in the order it is generated to one or more destinations. Streams can be fixed rate or variable rate. Thus, an MPEG video stream, AMR audio stream, and a data stream used to control a remote device, are all examples of "streams" that can be delivered. The rate of the stream at each point in time can be known (such as 4 megabits per second) or unknown (such as a variable rate stream where the rate at each point in time is not known in advance). Either way, the stream is a sequence of input symbols, where each input symbol has a position in the stream and a value.<br>
[0106]    Transmission is the process of transmitting data from one or more senders to one or more recipients through a channel in order to deliver a file or stream. A sender is also sometimes referred to as the encoder. If one sender is connected to any number of recipients by a perfect channel, the received data can be an exact copy of the input file or stream, as all the data will be received correctly. Here, we assume that the channel is not perfect, which is the case for most real-world channels. Of the many charmel imperfections, two imperfections of interest are data erasure and data incompleteness (which can be treated as a special case of data erasure). Data erasure occurs when the channel loses or drops data. Data<br>
 <br>
incompleteness occurs when a recipient does not start receiving data until some of the data has already passed it by, the recipient stops receiving data before transmission ends, the recipient chooses to only receive a portion of the transmitted data, and/or the recipient intermittently stops and starts again receiving data. As an example of data incompleteness, a moving satellite sender might be transmitting data representing an input file or stream and start the transmission before a recipient is in range. Once the recipient is in range, data can be received until the satellite moves out of range, at which point the recipient can redirect its satellite dish (during which time it is not receiving data) to start receiving the data about the same input file or stream being transmitted by another satellite that has moved into range. As should be apparent from reading this description, data incompleteness is a special case of data erasure, since the recipient can treat the data incompleteness (and the recipient has the same problems) as if the recipient was in range the entire time, but the channel lost all the data up to the point where the recipient started receiving data. Also, as is well known in communication systems design, detectable errors can be considered equivalent to erasures by simply dropping all data blocks or symbols that have detectable errors.<br>
(0107]    In some communication systems, a recipient receives data generated by multiple senders, or by one sender using multiple connections. For example, to speed up a download, a recipient might simultaneously connect to more than one sender to transmit data concerning the same file. As another example, in a multicast transmission, multiple multicast data streams might be transmitted to allow recipients to connect to one or more of these streams to match the aggregate transmission rate with the bandwidth of the channel connecting them to the sender. In all such cases, a concern is to ensure that all transmitted data is of independent use to a recipient, i.e., that the multiple source data is not redundant among the streams, even when the transmission rates are vastly different for the different streams, and when there are arbitrary patterns of loss.<br>
[0108]    In general, a communication channel is that which connects the sender and the recipient for data transmission. The communication channel could be a real-time channel, where the channel moves data from the sender to the recipient as the channel gets the data, or the communication channel might be a storage channel that stores some or all of the data in its transit from the sender to the recipient. An example of the latter is disk storage or other storage device. In that example, a program or device that generates data can be thought of as the sender, transmitting the data to a storage device. The recipient is the program or device that reads the data from the storage device. The mechanisms that the sender uses to get the<br>
 <br>
data onto the storage device, the storage device itself and the mechanisms that the recipient uses to get the data from the storage device collectively form the channel. If there is a chance that those mechanisms or the storage device can lose data, then that would be treated as data erasure in the communication channel.<br>
10109]    "When the sender and recipient are separated by a communication channel in which symbols can be erased, it is preferable not to transmit an exact copy of an input file or stream, but instead to transmit data generated from the input file or stream (which could include all or parts of the input file or stream itself) that assists with recovery of erasures. An encoder is a circuit, device, module or code segment that handles that task. One way of viewing the operation of the encoder is that the encoder generates output symbols from input symbols, where a sequence of input symbol values represents the input file or a block of the stream. Each input symbol would thus have a position, in the input file or block of the stream, and a value. A decoder is a circuit, device, module or code segment that reconstructs the input symbols from the output symbols received by the recipient. In multi-stage coding, the encoder and the decoder are further divided into sub-modules each performing a different task.<br>
[0110]    In embodiments of multi-stage coding systems, the encoder and the decoder can be further divided into sub-modules, each performing a different task. For instance, in some embodiments, the encoder comprises what is referred to herein as a static encoder and a dynamic encoder. As used herein, a "static encoder" is an encoder that generates a number of redundant symbols from a set of input symbols, wherein the number of redundant symbols is determined prior to encoding. Examples of static encoding codes include Reed-Solomon codes, Tornado codes, Hamming codes, Low Density Parity Check (LDPC) codes, etc. The term "static decoder" is used herein to refer to a decoder that can decode data that was encoded by a static encoder.<br>
[0111]    As used herein, a "dynamic encoder" is an encoder that generates output symbols from a set of input symbols and possibly a set of redundant symbols. In one preferred embodiment described here, the number of possible output symbols is orders of magnitude larger than the number of input symbols, and the number of output symbols to be generated need not be fixed. One example of such a dynamic encoder is a chain reaction encoder, such as the encoders described in Luby I and Luby 11. The term "dynamic decoder" is used herein to refer to a decoder that can decode data that was encoded by a dynamic encoder.<br>
 <br>
[0112]    Embodiments of multi-field coding need not be limited to any particular type of input symbol. Typically, the values for the input symbols are selected from an alphabet of 2' symbols for some positive integer M. In such cases, an input symbol can be represented by a sequence of M bits of data from the input file or stream. The value of M is often determined based on, for example, the uses of the application, the communication channel, and/or the size of the output symbols. Additionally, the size of an output symbol is often determined based on the application, the channel, and/or the size of the input symbols. In some cases, the coding process might be simplified if the output symbol values and the input symbol values were the same size (i.e., representable by the same number of bits or selected from the same alphabet). If that is the case, then the input symbol value size is limited when the output symbol value size is limited. For example, it may be desired to put output symbols in packets of limited size. If some data about a key associated with the output symbols were to be transmitted in order to recover the key at the receiver, the output symbol would preferably be small enough to accommodate, in one packet, the output symbol value and the data about the key.<br>
[0113]    As an example, if an input file is a multiple megabyte file, the input file might be broken into thousands, tens of thousands, or hundreds of thousands of input symbols with each input symbol encoding thousands, hundreds, or only few bytes. As another example, for a packet-based Internet channel, a packet with a payload of size of 1024 bytes might be appropriate (a byte is 8 bits). In this example, assuming each packet contains one output symbol and 8 bytes of auxiliary information, an output symbol size of 8128 bits ((1024 -8)*8) would be appropriate. Thus, the input symbol size could be chosen as M=(1024 - 8) * 8, or 8128 bits. As another example, some video distribution systems use the MPEG packet standard, where the payload of each packet comprises 188 bytes. In that example, assuming each packet contains one output symbol and 4 bytes of auxiliary information, an output symbol size of 1472 bits ((188 - 4) * 8), would be appropriate. Thus, the input symbol size could be chosen as M = (188 - 4) * 8, or 1472 bits. In a general-purpose communication system using multi-stage coding, the application-specific parameters, such as the input symbol size (i.e., M, the number of bits encoded by an input symbol), might be variables set by the application.<br>
[0114]    As another example, for a stream that is sent using variable size source packets, the symbol size might be chosen to be rather small so that each source packet can be covered<br>
 <br>
with an integral number of input symbols that have aggregate size at most slightly larger than the source packet.<br>
[0115J    Each output symbol has a value. In one preferred embodiment, which we consider below, each output symbol also has associated therewith an identifier called its "key." Preferably, the key of each output symbol can be easily determined by the recipient to allow the recipient to distinguish one output symbol from other output symbols. Preferably, the key of an output symbol is distinct from the keys of all other output symbols. There are various forms of keying discussed in previous art. For example, Luby 1 describes various forms of keying that can be employed in embodiments described herein.<br>
[0116]    Multi-field Multi-stage coding is particularly useful where there is an expectation of<br>
data erasure or where the recipient does not begin and end reception exactly when a<br>
transmission begins and ends. The latter condition is referred to herein as "data<br>
incompleteness." Regarding erasure events, multi-stage coding shares many of the benefits<br>
of chain reaction coding described in Luby I. In particular, multi-stage codes may be<br>
fountain codes, or rateless codes, in which case many times more distinct output symbols<br>
than there are input symbols can be generated for a set of fixed-value input symbols, and any<br>
suitable number of distinct output symbols can be used to recover the input symbols to a<br>
desired degree of accuracy. These conditions do not adversely affect the communication<br>
process when multi-field multi-stage coding is used, because the output symbols generated<br>
with multi-field multi-stage coding are informafion additive. For example, if a hundred<br>
packets are lost due to a burst of noise causing data erasure, an extra hundred packets can be<br>
picked up after the burst to replace the loss of the erased packets. If thousands of packets are<br>
lost because a receiver did not tune into a transmitter when it began transmitting, the receiver<br>
could just pickup those thousands of packets from any other period of transmission, or even	:<br>
firom another transmitter. With multi-field multi-stage coding, a receiver is not constrained to<br>
pickup any particular set of packets, so it can receive some packets from one transmitter,<br>
switch to another transmitter, lose some packets, miss the beginning or end of a given<br>
transmission and still recover an input file or block of a stream. The ability to join and leave<br>
a transmission without receiver-transmitter coordination helps to simplify the communication<br>
process.<br>
[0117]    In some embodiments, transmitting a file or stream using multi-field multi-stage coding can include generating, forming or extracting input symbols from an input file or<br>
 <br>
block of a stream, computing redundant symbols, encoding input and redundant symbols into one or more output symbols, where each output symbol is generated based on its key independently of all other output symbols, and transmitting the output symbols to one or more recipients over a channel. Additionally, in some embodiments, receiving (and reconstructing) a copy of the input file or block of a stream using multi-field multi-stage coding can include receiving some set or subset of output symbols from one of more data streams, and decoding the input symbols from the values and keys of the received output symbols.<br>
[0118]    Suitable FEC erasure codes as described herein can be used to overcome the above-cited difficulties and would find use in a number of fields including multimedia broadcasting and multicasting systems and services. An FEC erasure code hereafter referred to as "a multi-field multi-stage chain reaction code" has properties that meet many of the current and future requirements of such systems and services.<br>
[0119]    Some basic properties of multi-field multi-stage chain reaction codes are that, for any packet loss conditions and for delivery of source files of any relevant size or streams of any relevant rate: (a) reception overhead of each individual receiver device ("RD") is minimized; (b) the total transmission time needed to deliver source files to any number of RDs can be minimized (c) the quality of the delivered stream to any number of RDs can be maximized for the number of output symbols sent relative to the number of input symbols, with suitable selection of transmission schedules. The RDs might be handheld devices, embedded into a vehicle, portable (i.e., movable but not typically in motion when in use) or fixed to a location.<br>
[0120]    The amount of working memory needed for decoding is low and can still provide the above properties, and the amount of computation needed to encode and decode is minimal. In this document, we provide a simple and easy to implement description of some variations of multi-field multi-stage chain reaction codes.<br>
[0121]    Multi-field Multi-stage chain reacfion codes are fountain codes, i.e., as many encoding packets as needed can be generated on-the-fly, each containing unique encoding symbols that are equally useful for recovering a source file or block of a stream. There are many advantages to using fountain codes versus other types of FEC codes.   One advantage is that, regardless of packet loss conditions and RD availability, fountain codes minimize the number of encoding packets each RD needs to receive to reconstruct a source file or block of<br>
 <br>
a stream. This is true even under harsh packet loss conditions and when, for example, mobile RDs are only intermittently tumed-on or available over a long file download session.<br>
[0122]    Another advantage is the ability to generate exactly as many encoding packets as needed, making the decision on how many encoding packets to generate on-the-fly while the transmission is in progress. This can be useful if for example there is feedback from RDs indicating whether or not they received enough encoding packets to recover a source file or block of a stream. When packet loss conditions are less severe than expected the transmission can be terminated early. When packet loss conditions are more severe than expected or RDs are unavailable more often than expected the transmission can be seamlessly extended.<br>
[0123]    Another advantage is the ability to inverse multiplex. Inverse multiplexing is when a RD is able to combine received encoding packets generated at independent senders to reconstruct a source file or block of a stream. One practical use of inverse multiplexmg is described in below in reference to receiving encoding packets from different senders.<br>
[0124]    Where future packet loss, RD availability and application conditions are hard to predict, it is important to choose an FEC solution that is as flexible as possible to work well under unpredictable conditions. Multi-stage chain reaction codes provide a degree of flexibility unmatched by other types of FEC codes.<br>
[0125]    A further advantage of multi-field multi-stage codes is that the error probability and error floor of the codes is much lower than those of previously known codes with equivalent computational complexity. Equally, the computational complexity of multi-field multi-stage chain reaction codes is much lower than that of previously known codes with equivalent error probability and/or error floor.<br>
[0126]    Another advantage of multi-field multi-stage chain reaction codes is that parameters such as symbol size and field sizes can be chosen flexibly to achieve any desired balance between computational complexity and error probability and/or error floor.<br>
Aspects of the invention will now be described with reference to the figures.<br>
System Overview<br>
[0127]    Fig. 1 is a block diagram of a communications system 100 that uses multi-stage coding. In communications system 1 GO, an input file 101, or an input stream 105, is provided to an input symbol generator 110. Input symbol generator 110 generates a sequence of one or<br>
 <br>
more input symbols (1S(0), IS(1), 1S(2), ...) from the input file or stream, with each input symbol having a value and a position (denoted in Fig, 1 as a parenthesized integer). As explained above, the possible values for input symbols, i.e., its alphabet, is typically an alphabet of 2*' symbols, so that each input symbol codes for M bits of the input file or stream. The value of M is generally determined by the use of communication system 100, but a general purpose system might include a symbol size input for input symbol generator 110 so that M can be varied from use to use. The output of input symbol generator 110 is provided to an encoder 115.<br>
[0128]     Static key generator 130 produces a stream of static keys So, Si, .... The number of the static keys generated is generally limited and depends on the specific embodiment of encoder 115. The generation of static keys will be subsequently described in more detail. Dynamic key generator 120 generates a dynamic key for each output symbol to be generated by the encoder 115. Each dynamic key is generated so that a large fraction of the dynamic keys for the same input file or block of a stream are unique. For example, Luby I describes embodiments of key generators that can be used. The outputs of dynamic key generator 120 and the static key generator 130 are provided to encoder 115.<br>
[0129]    From each key I provided by dynamic key generator 120, encoder 115 generates an output symbol, with a value B(I), from the input symbols provided by the input symbol generator. The operation of encoder 115 will be described in more detail below. The value of each output symbol is generated based on its key, on some function of one or more of the input symbols, and possibly on or more redundant symbols that had been computed fi-om the input symbols. The collection of input symbols and redundant symbols that give rise to a specific output symbol is referred to herein as the output symbol's "associated symbols" or just its "associates". The selection of the function (the "value function") and the associates is done according to a process described in more detail below. Typically, but not always, M is the same for input symbols and output symbols, i.e., they both code for the same number of bits.<br>
[0130]    In some embodiments, the number K of input symbols is used by the encoder 115 to select the associates. If K is not known in advance, such as where the input is a streaming file, K can be just an estimate. The value K might also be used by encoder 115 to allocate storage for input symbols and any intermediate symbols generated by encoder 115.<br>
 <br>
|0131)    Encoder 115 provides output symbols to a transmit module 140. Transmit module 140 is also provided the key of each such output symbol from the dynamic key generator 120, Transmit module 140 transmits the output symbols, and depending on the keying method used, transmit module 140 might also transmit some data about the keys of the transmitted output symbols, over a channel 145 to a receive module 150. Channel 145 is assumed to be an erasure channel, but that is not a requirement for proper operation of communication system 100. Modules 140, 145 and 150 can be any suitable hardware components, software components, physical media, or any combination thereof, so long as transmit module 140 is adapted to transmit output symbols and any needed data about their keys to channel 145 and receive module 150 is adapted to receive symbols and potentially some data about their keys from channel 145. The value of K, if used to determine the associates, can be sent over channel 145, or it may be set ahead of time by agreement of encoder 115 and decoder 155.<br>
(0132]    As explained above, channel 145 can be a real-time channel, such as a path through the Internet or a broadcast link from a television transmitter to a television recipient or a telephone connection from one point to another, or channel 145 can be a storage channel, such as a CD-ROM, disk drive, Web site, or the like. Channel 145 might even be a combination of a real-time channel and a storage channel, such as a channel formed when one person transmits an input file from a personal computer to an Internet Service Provider (ISP) over a telephone line, the input file is stored on a Web server and is subsequently transmitted to a recipient over the Internet.<br>
[0133]    Because channel 145 is assumed to be an erasure channel, communications system 100 does not assume a one-to-one correspondence between the output symbols that exit receive module 150 and the output symbols that go into transmit module 140. In fact, where channel 145 comprises a packet network, communications system 100 might not even be able to assume that the relative order of any two or more packets is preserved in transit through channel 145. Therefore, the key of the output symbols is determined using one or more of the keying schemes described above, and not necessarily determined by the order in which the output symbols exit receive module 150.<br>
[0134]    Receive module 150 provides the output symbols to a decoder 155, and any data receive module 150 receives about the keys of these output symbols is provided to a dynamic key regenerator 160. Dynamic key regenerator 160 regenerates the dynamic keys for the received output symbols and provides these dynamic keys to decoder 155. Static key<br>
 <br>
generator 163 regenerates the static keys So, S], ... and provides them to decoder 155. The static key generator has access to random number generator 135 used both during the encoding and the decoding process. This can be in the form of access to the same physical device if the random numbers are generated on such device, or in the form of access to the same algorithm for the generation of random numbers to achieve identical behavior. Decoder 155 uses the keys provided by dynamic key regenerator 160 and static key generator 163 together with the corresponding output symbols, to recover the input symbols (again IS(0), IS{1), IS(2), ,..). Decoder 155 provides the recovered input symbols to an input file reassembler 165, which generates a copy 170 of input file 101 or input stream 105.<br>
[0135]    One property of the output symbols produced by a chain reaction encoder is that a receiver is able to recover the original file or block of the original stream as soon as enough output symbols have been received. Specifically, to recover the original K input symbols with a high probability, the receiver needs approximately K+A output symbols. The ratio A/K is called the "relative reception overhead." The relative reception overhead depends on the number K of input symbols, and on the reliability of the decoder. Luby 1, Luby II and Shokxollahi I provide teachings of systems and methods that can be employed in certain embodiments. It is to be understood, however, that these systems and methods are not required of the present invention, and many other variations, modifications, or alternatives can also be used.<br>
An Encoder<br>
(0136]    Fig. 2 is a block diagram of one specific embodiment of encoder 115 shown in Fig. 1. Encoder 115 comprises a static encoder 210, adynamic encoder 220, and a redundancy calculator 230. Static encoder 210 receives the following inputs: a) original input symbols IS(0), IS(l), ..., IS(K-l) provided by the input symbol generator 110 and stored in an input symbol buffer 205; b) the number K of original input symbols; c) static keys So, S], ... provided by the static key generator 130; and d) a number R of redundant symbols. Upon receiving these inputs stafic encoder 205 computes R redundant symbols RE(0), RE(l),..., RE(R-l) as will be described below. Typically, but not always, the redundant symbols have the same size as the input symbols. In one specific embodiment, the redundant symbols generated by static encoder 210 are stored in input symbol buffer 205. Input symbol buffer 205 may be only logical, i.e., the file or block of the stream may be physically stored in one place and the positions of the input symbols within symbol buffer 205 could only be renamings of the positions of these symbols within the original file or block of the stream.<br>
 <br>
|0137]    Dynamic encoder receives the input symbols and the redundant symbols, and generates output symbols as will be described in further detail below. In one embodiment in which the redundant symbols are stored in input symbol buffer 205, dynamic encoder 220 receives the input symbols and redundant symbols from input symbol buffer 205.<br>
[0138]    Redundancy calculator 230 computes the number R of redundant symbols from the number K of input symbols. This computation is described in further detail below.<br>
Overview of Static Encoder<br>
[0139]    The genera! operation of static encoder 210 is shown with reference to Figs. 3 and 4. Fig. 3 is a simplified flow diagram illustrating one embodiment of a method of statically encoding. In a step 305, a variable j, which keeps track of how many redundant symbols have been generated, is set to zero. Then, in a step 310, a first redundant symbol RE(0) is computed as a function Fo of at least some of the input symbols IS(0), ..., IS(K-l). Then, in a step 315, the variable j is incremented. Next, in a step 320, it is tested whether all of the redundant symbols have been generated (i.e., is j greater than R-1?). If yes, then the flow ends. Otherwise, the flow proceeds to step 325. In step 325, RE(j) is computed as a function Fj of the input symbols IS(0), ..., IS(K-l) and of the previously generated redundant symbols RE(0), ..., RE(j-l), where Fj need not be a function that depends on every one of the input symbols or every one of the redundant symbols. Steps 315, 320, and 325 are repeated until R redundant symbols have been computed.<br>
[0140]    Referring again to Figs. 1 and 2, in some embodiments, static encoder 210 receives one or more static keys So, S|, ... from static key generator 130. In these embodiments, the static encoder 2 ] 0 uses the static keys to determine some or all of functions Fo, F), ..., Fj.j. For example, static key So can be used to determine function Fo, static key S| can be used to determine function Fi, etc. Or, one or more of static keys So, S|, ... can be used to determine function FQ, one or more of static keys So, Sj, ... can be used to determine function F|, etc. In other embodiments, no static keys are needed, and thus static key generator 130 is not needed.<br>
[0141]    Referring now to Figs. 2 and 3, in some embodiments, the redundant symbols generated by static encoder 210 can be stored in input symbol buffer 205. Fig. 4 is a simplified illustration of the operation of one embodiment of static encoder 210. Particularly, static encoder 210 generates redundant symbol RE(j') as a function Fj of input symbols 18(0), ..., IS(K-l), RE(0), ..., RE(j-l), received from input symbol buffer 205, and stores it back<br>
 <br>
into input symbol buffer 205. The exact form of tlie functions Fo, Fi, ..., FR.| depends on the particular application. Typically, but not always, functions Fo, F|, ..., FR.| include an exclusive OR of some or all of their corresponding arguments. As described above, these functions may or may not actually employ static keys generated by static key generator 130 of Fig, 1. For example, in one specific embodiment described below, the first few functions implement a Hamming code and do not make any use of the static keys So, S|, ..., whereas the remaining functions implement a Low-Density Parity-Check code and make explicit use of the static keys.<br>
Overview of Multi-Stage Encoder<br>
(0142)     Referring again to Fig. 2, dynamic encoder 220 receives input symbols IS(0),...,IS(K-1) and the redundant symbols RE(0),...,RE(R-1) and a key 1 for each output symbol it is to generate. The collection comprising the original input symbols and the redundant symbols will be referred to as the collection of "dynamic input symbols" hereafter. Fig. 5 is a simplified block diagram of one embodiment of a dynamic encoder, including a weight selector 510, an associator 515, a value function selector 520 and a calculator 525   As shown in Fig. 5, the K+R dynamic input symbols are stored in a dynamic symbol buffer 505. In effect, dynamic encoder 500 performs the action illustrated in Fig. 6, namely, to generate an output symbol value B(I) as some value function of selected input symbols.<br>
|0143]    Fig. 7 is a simplified block diagram of one specific embodiment of a static encoder. Static encoder 600 comprises a parameter calculator 605, a Low-density parity-check (LDPC) encoder 610, and a high-density-parity-check (HDPC) encoder 620. LDPC encoder 610 is coupled to receive the input symbols IS(0), ..., IS(K-l) from an input symbol buffer 625, the number K of input symbols, and the parameter E. In response, LDPC encoder 610 generates E redundant symbols LD(0),...,LD(E-1) according to the LDPC code. Next, HDPC encoder 620 is coupled to receive the plurality of K+E symbols IS(0),.. .,IS(K-1),LD(0),..., LD(E and the parameter D to generate D redundant symbols HA(0), HA(l), .,., HA(D-l) according to the HDPC code.<br>
[0144]    Fig. 8 illustrates the operation of one embodiment that employs the static encoder shown in Fig. 7.<br>
(0145]    Fig. 9 is a simplified flow diagram illustrating one embodiment of a parameter calculator, such as parameter calculator 605 of Fig. 7, that calculates parameter D and E as described above, when the HDPC code is a Hamming code. First, in a step 705, parameter D<br>
 <br>
is initialized to one. Then, in step 710, it is determined whether 2*-0-1 is less than K. If no, then the flow proceeds to step 730, If yes, the flow proceeds to step 720, where the parameter D is incremented. Then, the flow proceeds back to step 710. Once D has been determined, then, in step 730, the parameter E is calculated as R - D - 1.<br>
|0146]    Fig. 10 is a simplified flow diagram of such an encoder according to one embodiment of the present invention, which will now be described. First, in step 805, a variable i is initialized to zero. Variable i keeps track of the number of redundant symbols already generated. In step 810, a number t is calculated as the smallest odd integer greater than or equal to K/2. In step 815, values P|, P2, .-., Pi are generated based on K, t, and a static key S,. The values P|, P2, .-., Pt indicate the positions of input symbols that will be used to generate a redundant symbol. In one particular embodiment, an associator such as associator 515 of Fig. 5 is used to generate P|, P2, ..., Pi. In particular, the value t can be provided as the W(l) input, the value K can be provided as the K+R input, and the static key Si can be provided as the key I input. It should be noted that many different values of t would yield similar coding effects, and thus this particular choice is only an example. In step 820, the value of RE(i) is computed as the XOR of the values IS(P,), 1S(P2),...,IS(P,). In step 825, the variable i is incremented by one to prepare computation of the next redundant symbol, and in step 830, it is determined whether all the redundant symbols have been computed. If not, then the flow returns to step 815,<br>
[0147]    Fig. 11 is a simplified block diagram illustrating one embodiment of a decoder according to the present invention. Decoder 900 can be used, for example, to implement decoder 155 of Fig. 1.<br>
|0148]    Decoder 900 comprises a dynamic decoder 905 and astatic decoder 910. Input symbols and redundant symbols recovered by dynamic decoder 905 are stored in a reconstruction buffer 915. Upon complefion of dynamic decoding, static decoder 910 attempts to recover any input symbols not recovered by dynamic decoder 905, if any. In particular, static decoder 910 receives input symbols and redundant symbols from reconstrucfion buffer 915.<br>
[0149]    Fig. 12 is a simplified flow diagram illustrating one embodiment of a method for decoding according to the present invenfion. In step 1005, Q output symbols are received by the decoder. The value of Q can depend on the number of input symbols and the specific dynamic encoder used. The value of Q can also depend on the desired degree of accuracy to<br>
 <br>
which the decoder can recover the input symbols. For example, if it is desired that the decoder can recover all of the input symbols with a high probability, then Q should be chosen to be larger than the number of input symbols. Particularly, in some applications, when the number of input symbols is large, Q can be less than 3% larger than the number of original input symbols, in other applications, when the number of input symbols is small, Q can be at least 10% larger than the number of input symbols. Specifically, Q can be chosen as the number K of input symbols plus a number A, where A is chosen to ensure that the decoder can regenerate all of the input symbols with a high probability. Determination of the number A is described in more detail below. If it is acceptable for the decoder to be unable to decode all of the input symbols (either sometimes or always), then Q can be less than K+A, equal to K, or even less than K. Clearly, one aim of an overall coding system will often be to decrease the number Q as much as possible, while maintaining good probabilistic guarantees on the success of the decoding process with respect to the desired degree of accuracy.<br>
[0150]     In step 1010, dynamic decoder 905 regenerates input symbols and redundant symbols from the Q received output symbols. It is to be understood, that steps 1005 and 1010 can be performed substantially concurrently. For example, dynamic decoder 905 can begin regenerating input symbols and redundant symbols prior to the decoder receiving Q output symbols.<br>
[0151]    After dynamic decoder 905 has processed Q output symbols, then it is determined whether the input symbols have been recovered to a desired degree of accuracy. The desired degree of accuracy may be, for example, all of the input symbols, or some number, percentage, etc., less than all of the input symbols. If yes, then the flow ends. Ifno, then the flow proceeds to step 1020. In step 1020, static decoder 910 attempts to recover any input symbols that dynamic decoder 905 was unable to recover. After static encoder 910 has processed the input symbols and redundant symbols recovered by dynamic encoder 905, then the flow ends.<br>
[0152]    Fig. 13 is a simplified flow diagram illustrating another embodiment of a method for decoding according to the present invention. This embodiment is similar to that described with respect to Fig. 11, and includes steps 1005, 1010, 1015, and 1025 in common. But, after step 1025, the flow proceeds to step 1030, in which it is determined whether the input symbols have been recovered to a desired degree of accuracy. If yes, then the flow ends. If no, then the flow proceeds to step 1035. In step 1035, one or more additional output symbols<br>
 <br>
are received. Then, the flow proceeds back to step 1010, so that dynamic decoder 905 and/or static decoder 910 can attempt to recover the remaining unrecovered input symbols.<br>
10153)    Fig. 14 is a simplified flow diagram illustrating yet another embodiment of a ' method for decoding according to the present invention. In step 1055, output symbols are received by the decoder, and in step 1060, dynamic decoder 905 regenerates input symbols and redundant symbols from the received output symbols. Then, in step 1065, it is determined whether dynamic decoding should be ended. This determination can be based on one or more of the number of output symbols processed, the number of input symbols recovered, the current rate at which additional input symbols are being recovered, the time spent processing output symbols, etc.<br>
|0154j     In step 1065, if it is determined that dynamic decoding is not to be stopped, then the flow proceeds back to step 1055. But, if in step 1065, it is determined to end dynamic decoding, then the flow proceeds to step 1070. In step 1070, it is determined whether the input symbols have been recovered to a desired degree of accuracy. If yes, then the flow ends. If no, then the flow proceeds to step 1075. In step 1075, static decoder 910 attempts to recover any input symbols that dynamic decoder 905 was unable to recover. After static encoder 910 has processed the input symbols and redundant symbols recovered by dynamic encoder 905, the flow ends.<br>
[0155]    Fig. 15 shows one embodiment of dynamic decoder according to the present invention. Dynamic decoder 1100 includes similar components as those of dynamic encoder 500 shown in Fig. 5. Decoder 1100 is similar to embodiments of chain reaction decoders described in Luby I and Luby II. Dynamic decoder 1100 comprises a weight selector 510, an associator 515,3 value function selector 520, an output symbo] buffer 1105, a reducer 1115, a reconstructor 1120 and a reconstruction buffer 1125.<br>
(0156]    Fig. 16 is a simplified block diagram illustrating one embodiment of a static decoder. This embodiment can be used when the data is encoded with a static encoder such as described with reference to Fig. 7. Static decoder 1200 comprises a LDPC decoder 1205 and a Hamming decoder 1210. The LDPC decoder 1205 receives input symbols and redundant symbols from a reconstruction buffer 1215, and attempts to reconstruct those symbols of reconstruction buffer 1215 unrecovered after the decoding step of the dynamic decoder. In some embodiments, reconstruction buffer 1215 is reconstruction buffer 1125 (Fig. 15).<br>
 <br>
[0157)    Many variations of LDPC decoders and HDPC decoders are well known to those skilled in the art, and can be employed in various embodiments according to the present invention. In one specific embodiment, HDPC decoder is implemented using a Gaussian elimination algorithm. Many variations of Gaussian elimination algorithms are well known to those skilled in the art, and can be employed in various embodiments according to the present invention.<br>
A Variation of HDPC coding<br>
[0158]    Another type of HDPC encoding is now described. In this embodiment of HDPC encoding, the mathematical operation for creating redundant symbols from a given set of data is based on operations in a finite field.<br>
[0159]    In this embodiment of HDPC coding, the elements of a finite field are used to obtain redundant symbols HD[0],...,HD[D-1]. These symbols are obtained by defining a multiplicafion process between the symbols IS[0],...,IS[K-1], LD[0],...,LD[E-1] and elements of the finite field as described above.<br>
HDPC coding<br>
[0160]     When using an HDPC code, the code might be described by a generator matrix over a finite field GF(2'). Where the code is systematic, which is the case in a preferred embodiment, the generator matrix can be described using only the relationship between the K+E input symbols IS[0],...,1S[K-]],LD[0],...,LD[E-1] and the redundant symbols HD[0],...,HD[D-1]. This matrix, called G, is of format Dx(K+E). If ;denotes the column vector comprising the symbols HD[0],...,HD[D-]] and 5denotes the column vector comprising the symbols IS[0],.. .,IS[K-1],LD[0],...,LD[E-1], then we haveX = G®S. More specific embodiments for the matrix G and various methods for efficient computation of the symbols are described below.<br>
Variations<br>
(0161J    Multi-stage chain reaction codes as described above are not systemafic codes, i.e., all of the original source symbols of a source block are not necessarily among the encoding symbols that are sent. However, systematic FEC codes are useful for a file download system or service, and very important for a streaming system or service. As shown in the implementation below, a modified code can be made to be systemafic and still maintain the fountain code and other described properties.<br>
 <br>
(0162|    One reason why it is easy to construct a variety of supplemental services using multi-stage codes is that it can combine received encoding symbols from multiple senders to reconstruct a source file or stream without coordination among the senders. The only requirement is that the senders use differing sets of keys to generate the encoding symbols that they send in encoding packets to the code. Ways to achieve this include designating different ranges of the key space to be used by each such sender, or generating keys randomly at each sender.<br>
[0163]    As an example of the use of this capability, consider providing a supplemental service to a file download service that allows multi-stage chain reaction codes that did not receive enough encoding packets to reconstruct a source file from the file download session to request additional encoding packets to be sent from a make-up sender, e.g., via a HTTP session. The make-up sender generates encoding symbols from the source file and sends them, for example using HTTP, and all these encoding symbols can be combined with those received from the file download session to recover the source file. Using this approach allows different senders to provide incremental source file delivery services without coordination between the senders, and ensuring that each individual receiver need receive only a minimal number of encoding packets to recover each source file.<br>
[0164]    Decoding of multi-stage chain reaction codes as described above may require a relatively large overhead when the number of source symbols is small, for example in the order of hundreds to a few thousands source symbols. In such a case, a different decoder is preferred, for example a decoder disclosed in Shokrollahi 111. As shown in the implementation below, a modified decoding algorithm can be designed for the class of codes disclosed herein that uses features of the codes and concepts disclosed in Shokrollahi III, and provides low decoding error probability for very small numbers of source symbols, while maintaining efficiency in the decoding.<br>
Implementations of Various Stages of Multi-field Multi-Stage Codes<br>
FEC Scheme definition<br>
[0165]    A packet using these techniques might be represented with header information such<br>
as an FEC Payload ID of four octets comprising a Source Block Number (SBN) (16 bit<br>
integer identifier for the source block that the encoding symbols within the packet relate to)<br>
and an Encoding Symbol ID (ESI) (16 bit integer identifier for the encoding symbols within<br>
the packet). One suitable interpretafion of the Source Block Number and Encoding Symbol<br>
 <br>
Identifier is defined in Sections B below. FEC Object Transmission information might comprise the FEC Encoding ID, a Transfer Length (f) and the parameters T, Z, N and A defined in below. The parameters T and Z are 16 bit unsigned integers, A' and A are 8 bit unsigned integers. If needed, other integer sizes might be used.<br>
[01661 An FEC encoding scheme for forward error correction is defined in the sections below. It defines two different FEC Payload ID formats, one for FEC source packets and another for FEC repair packets, but variations for nonsystematic codes are also possible,<br>
[0167]    The Source FEC payload ID might comprise a Source Block Number (SBN) (16 bit integer identifier for the source block that the encoding symbols within the packet relate to) and an Encoding Symbol ID (ESI) (16 bit integer identifier for the encoding symbols within the packet), while the Repair FEC Payload ID might comprise a Source Block Number (SBN) (16 bit integer identifier for the source block that the repair symbols within the packet relate to), an Encoding Symbol ID (ESI) (16 bit integer identifier for the repair symbols within the packet), and a Source Block Length (SBL) (16 bits, representing the number of source symbols in the source block. The interpretation of the Source Block Number, Encoding Symbol Identifier and Source Block Length is defined below.<br>
[0168]    FEC Object Transmission information might comprise the FEC Encoding ID, the maximum source block length, in symbols, and the symbol size, in bytes. The symbol size and maximum source block length might comprise a four octet field of Symbol Size (7) (16 bits representing the size of an encoding symbol, in bytes), and a Maximum Source Block Length (16 bits representing the maximum length of a source block, in symbols).<br>
[0169]    The sections below specify the systematic multi-field MSCR forward error correction code. Multi-field MSCR codes are fountain codes, i.e., as many encoding symbols as needed can be generated by the encoder on-the-fly from the source symbols of a block. The decoder is able to recover the source block from any set of encoding symbols only sHghtly more in number than the number of source symbols. The code described in this document is a systematic code, that is, the original source symbols are sent unmodified firom sender to receiver, as well as a number of repair symbols.<br>
 <br>
B. 1      Definitions. Symbols and abbreviations<br>
B.1.1   Definitions<br>
[0170]    For the purposes of this description, the following terms and definitions apply.<br>
Source block: a block of K source symbols which are considered together for MSCR<br>
encoding purposes.<br>
Source symbol: the smallest unit of data used during the encoding process. All source<br>
symbols within a source block have the same size.<br>
Encoding symbol: a symbol that is included in a data packet. The encoding symbols<br>
comprise the source symbols and the repair symbols. Repair symbols generated from a source<br>
block have the same size as the source symbols of that source block.<br>
Systematic code: a code in which the source symbols are included as part of the encoding<br>
symbols sent for a source block.<br>
Repair symbol: the encoding symbols sent for a source block that are not the source<br>
symbols. The repair symbols are generated based on the source symbols.<br>
Intermediate symbols: symbols generated from the source symbols using an inverse<br>
encoding process . The repair symbols are then generated directly from the intermediate<br>
symbols. The encoding symbols do not include the intermediate symbols, i.e., intermediate<br>
symbols are not included in data packets.<br>
Symbol: a unit of data. The size, in bytes, of a symbol is known as the symbol size.<br>
Encoding symbol group: a group of encoding symbols that are sent together, i.e., within the<br>
same packet whose relationship to the source symbols can be derived from a single Encoding<br>
Symbol ID.<br>
Encoding Symbol ID: information that defines the relationship between the symbols of an<br>
encoding symbol group and the source symbols.<br>
Encoding packet: data packets that contain encoding symbols<br>
Sub-block; a source block is sometime broken into sub-blocks, each of which is sufficiently<br>
small to be decoded in working memory. For a source block comprising K source symbols,<br>
each sub-block comprises K sub-symbols, each symbol of the source block being composed<br>
of one sub-s3Tnbol from each sub-block.<br>
Sub-symbol: part of a symbol. Each source symbol is composed of as many sub-symbols as<br>
there are sub-blocks in the source block.<br>
Source packet: data packets that contain source symbols.<br>
Repair packet: data packets that contain repair symbols.<br>
 <br>
 <br>
<br>
[0172]    B. 1.3 Abbreviations<br>
For the purposes of the present document, the following abbreviations apply:<br>
ESI:	Encoding Symbol ID<br>
LDPC:	Low Density Parity Check<br>
LT:	Luby Transform<br>
SBN:	Source Block Number<br>
SBL:	Source Block Length (in units of symbols)<br>
B.2.     Overview<br>
|0I73]    The MSCR forward error correction code can be applied to both file delivery and streaming applications. MSCR code aspects which are specific to each of these applications are discussed in Sections B.3 and B.4 of this document.<br>
[0174]    A component of the systematic MSCR code is the basic encoder described in Section B.5. First, it is described how to derive values for a set of intermediate symbols from the original source symbols such that knowledge of the intermediate symbols is sufficient to reconstruct the source symbols. Secondly, the encoder produces repair symbols which are each the exclusive OR of a number of the intermediate symbols. The encoding symbols are the combination of the source and repair symbols. The repair symbols are produced in such a way that the intermediate symbols and therefore also the source symbols can be recovered from any sufficiently large set of encoding symbols.<br>
[0175]    This document defines the systematic MSCR code encoder. A number of possible decoding algorithms are possible. An efficient decoding algorithm is provided in Section B.6.<br>
[0176]    The construction of the intermediate and repair symbols is based in part on a pseudorandom number generator described in Section B.5. This generator is based on a fixed set of 512 random numbers that are available to both sender and receiver. An example set of numbers are those provided in Appendices B.l and B.2.<br>
[0177]    Finally, the construction of the intermediate symbols from the source symbols is governed by a "'systematic index". An example set of values for the systematic index is shown in Appendix A for source block sizes from 4 source symbols to KMAX = 8192 source symbols.<br>
B.3.     File download<br>
B.3.1.  Source block construction<br>
B.3.1,1.	General<br>
[0178]    In order to apply the MSCR encoder to a source file, the file may be broken into Z &gt;<br>
1 blocks, known as source blocks. The MSCR encoder is applied independently to each<br>
source block. Each source block is identified by a unique integer Source Block Number<br>
(SBN), where the first source block has SBN zero, the second has SBN one, etc. Each source<br>
block is divided into a number, K, of source symbols of size kbytes each. Each source<br>
symbol is identified by a unique integer Encoding Symbol Identifier (ESI), where the first<br>
source symbol of a source block has ESI zero, the second has ESI one, etc.<br>
(0179) Each source block with K source symbols is divided into N 1 sub-blocks, which are small enough to be decoded in the working memory. Each sub-block is divided into K sub-symbols of size T.<br>
[01801    Note that the value of K is not necessarily the same for each source block of a file and the value of T' may not necessarily be the same for each sub-block of a source block. However, the symbol size T'\s the same for all source blocks of a file and the number of symbols, k is the same for every sub-block of a source block. Exact partitioning of the file into source blocks and sub-blocks is described in B.3.1.2 below.<br>
[01811    Fig. 17 shows an example source block placed into a two dimensional array, where each entry is a T'-byte sub-symbol, each row is a sub-block and each column is a source symbol. In this example, the value of T' is the same for every sub-block. The number shown in each sub-symbol entry indicates their original order within the source block. For example, the sub-symbol numbered K contains bytes T' K through T-(K+1)-1i of the source block. Then, source symbol / is the concatenation of the ith sub-symbol from each of the sub-blocks, which corresponds to the sub-symbols of the source block numbered i, K+i, 2-K+i,..., (N-1)K+i.<br>
B.3.1.2 Source block and sub-block partitioning<br>
[0182] The construction of source blocks and sub-blocks is determined based on five input parameters, F, A,T,Z and N and a function Partition[]. The five input parameters are defined as follows:<br>
F	the size of the file, in bytes<br>
A	a symbol alignment parameter, in bytes<br>
 <br>
T	the symbol size, in bytes, which preferably is a multiple of A<br>
Z	the number of source blocks<br>
N	the number of sub-blocks in each source block<br>
[0183]    These parameters might be set so that ceil(ceil(F/7)/Z) 
[0184]    The function Partition[] takes a pair of integers (/, J) as input and derives four integers (4,1$, Ji, Js) as output. Specifically, the value of Parti tion[/, /] is a sequence of four integers (7, Is, JL, JS), where It = ceil(///), Is = floor(///), Ji = I- Is- J and Js = J- JL-Partition[] derives parameters for partitioning a block of size 1 into J approximately equal sized blocks. Specifically, JL blocks of length //. and Js blocks of length Is.<br>
[0185]    The source file might be partitioned into source blocks and sub-blocks as follows:<br>
Let,<br>
K, = ceil(F/7)<br>
(KL, KS, Zi, Zs) = Partition[„ Z ] (TL, TS, NL, NS) = Partition[7y.4, N]<br>
[0186]    Then, the file might be partitioned into Z = Zi + Zs contiguous source blocks, the first ZL source blocks each having length Ki-ThyXes and the remaining Zs source blocks each having ATsT bytes.<br>
[0187]    IfKi ■T&gt; F then for encoding purposes, the last symbol might be padded at the end v\\h K, -T- F zero bytes.<br>
[0188]    Next, each source block might be divided into N = NL + NS contiguous sub-blocks, the first Nl sub-blocks each comprising K contiguous sub-symbols of size of TL -A and the remaining Ns sub-blocks each comprising K contiguous sub-symbols of size of Ts -A. The symbol alignment parameter .4 ensures that sub-symbols are always a multiple of A bytes.<br>
[0189]    Finally, the mth symbol of a source block comprises the concatenation of the mth sub-symbol from each of the N sub-blocks.<br>
 <br>
B.3.2. EncodinR packet construction<br>
B.3.2.1.	Genera!<br>
[0190]    Each encoding packet contains a Source Block Number (SBN), an Encoding<br>
Symbol ID (ESI) and encoding symbol(s). Each source block is encoded independently of<br>
the others. Source blocks are numbered consecutively from zero. Encoding Symbol ID<br>
values from Olo K-\ identify the source symbols. Encoding Symbol IDs from K onwards<br>
identify repair symbols.<br>
B.3.2.2	Encoding packet construction<br>
101911    Each encoding packet preferably either contains source symbols (source packet) or contains repair symbols (repair packet). A packet may contain any number of symbols from the same source block. In the case that the last symbol in the packet includes padding bytes added for FEC encoding purposes then these bytes need not be included in the packet. Otherwise, only whole symbols might be included.<br>
[0192]    The Encoding Symbol ID, X, carried in each source packet is the Encoding Symbol ID of the first source symbol carried in that packet. The subsequent source symbols in the packet have Encoding Symbol IDs, X+l to X+G-\, in sequential order, where G is the number of symbols in the packet.<br>
[0193]    Similarly, the Encoding Symbol ID, X, placed into a repair packet is the Encoding Symbol ID of the first repair symbol in the repair packet and the subsequent repair symbols in the packet have Encoding Symbol IDs ..Y+l to X+G-] in sequential order, where G is the number of symbols in the packet.<br>
[0194]    Note that it is not necessary for the receiver to know the total number of repair packets. The G repair symbol triples (c?[0], a[0], b[0]),..., {d[G-\], a[G-\], b[G-l]) for the repair symbols placed into a repair packet with ESI X are computed using the Triple generator defined in B.5.3.4 as follows:<br>
For each f = 0, ..., G-1 {d[i],a[i],b[i])-Tnp[K+i]<br>
[0195]    The G repair symbols to be placed in repair packet with ESI X are calculated based on the repair symbol triples as described in Section B.5.3 using the intermediate symbols C and the LT encoder LTenc[K, C, {d[i], a[i], b[i])].<br>
 <br>
B.3.3.   Transport<br>
[0196]    This section describes the information exchange between the MSCR encoder/decoder and any transport protocol making use of MSCR forward error correction for file delivery.<br>
|0197j    The MSCR encoder and decoder for file delivery require the following information from the transport protocol: the file size, F, in bytes, the symbol alignment parameter, A, the symbol size, T, in bytes, which is a multiple of A, the number of source blocks, Z, the number of sub-blocks in each source block, N. The MSCR encoder for file delivery additionally requires the file to be encoded, F bytes.<br>
[0198)    The MSCR encoder supplies the transport protocol with encoding packet infonnation comprising, for each packet, the SBN, the ESI and the encoding symbol(s). The transport protocol might communicate this information transparently to the MSCR decoder.<br>
B.3.4.  Details of Specific Examples for Parameters<br>
B.3.4.1 Parameter derivation algorithm<br>
[0199]    This section provides examples for the derivation of the four transport parameters,<br>
A, T, Z and A that provide good results. These are based on the following input parameters:<br>
F	the file size, in bytes<br>
W	a target on the sub-block size, in bytes<br>
P	the maximum packet payload size, in bytes, which is assumed to be a multiple of <br>
A	the symbol alignment factor, in bytes<br>
-MAX	the maximum number of source symbols per source block.<br>
Kmn	a minimum target on the number of symbols per source block<br>
GMAX a maximum target number of symbols per packet<br>
[0200]    Based on the above inputs, the transport parameters T, Z and A are calculated as follows:<br>
Let,<br>
G = min {ceil(P -KMJN/F), PI A, GMAX) - the approximate number of symbols per packet T = f[oox{PI{A-G))-A<br>
Ki = ceil(F/7) - the total number of symbols in the file Z = ceil(A:, IKMAX)<br>
 <br>
A' min{cei!(ceil(/:,/Z)'7yff), 77/i} (0201]    The values of G and A' derived above should be considered as lower bounds. It may be advantageous to increase these values, for example to the nearest power of two. in particular, the above algorithm does not guarantee that the symbol size, T, divides the maximum packet size, P, and so it may not be possible to use the packets of size exactly P. If, instead, G is chosen to be a value which divides PIA, then the symbol size, T, will be a divisor of P and packets of size P can be used.<br>
[0202]    Suitable values for the input parameters might be W= 256 KB, A - 4, KMJN = 4, and GMAX=' 1-<br>
B.3.4.2 Examples<br>
10203)    The above algorithm leads to transport parameters as shown in Fig. 18, assuming<br>
the above values for W, A, KMIN and GMAX are used and with P = 512.<br>
B.4.     Streaming<br>
B.4.1.  Source block construction<br>
[0204]    A source block is constructed by the transport protocol, for example as defined in<br>
this document, making use of the Systematic MSCR Forward Error Correction code. The<br>
symbol size, T, to be used for source block construction and the repair symbol construction<br>
are provided by the transport protocol. The parameter Tmight be set so that the number of<br>
source symbols in any source block is at most KMAX-<br>
[0205]    An example of parameters that work well are presented in section B.4.4.<br>
B.4.2. Encoding packet construction<br>
[0206]    As described in B.4.3., each repair packet contains the SBN, ESI, SBL and repair symbol(s). The number of repair symbols contained within a repair packet is computed from the packet length. The ESI values placed into the repair packets and the repair symbol triples used to generate the repair symbols are computed as described in Section B.3.2.2.<br>
B.4.3. Transport<br>
[0207]    This section describes the information exchange between the MSCR encoder/decoder and any transport protocol making use of MSCR forward error correction for streaming. The MSCR encoder for streaming might use the following information from the transport protocol for each source block: the symbol size, T, in bytes, the number of symbols in the source block, K, the Source Block Number (SBN) and the source symbols to<br>
 <br>
be encoded, A'-7'bytes. The MSCR encoder supplies the transport protocol with encoding packet information comprising, for each repair packet, the SBN, the ESI, the SBL and the repair symbol{s). The transport protocol might communicate this information transparently to the MSCR decoder.<br>
B.4,4.  Selection of Parameters<br>
[0208]    A number of methods for parameter selection can be used. Some of those are<br>
described below in detail.<br>
B.4.4.1 Parameter derivation algorithm<br>
[0209]    This section explains a derivation of the transport parameter T, based on the<br>
 <br>
[0210]    A requirement on these inputs is that ceil(5/P) 
Let G = min{max { cei\{P-KMw/B), f\oor{PJPma.x) ],PI, GMAX]     - the number of symbols per SPI<br>
T=i\oox{PI{A-G))-A<br>
[0211]    The value of Tderived above should be considered as a guide to the actual value of 7 used. It may be advantageous to ensure that T divides into P, or it may be advantageous to set the value of T smaller to minimize wastage when full size repair symbols are used to<br>
 <br>
recover partial source symbols at the end of lost source packets (as long as the maximum number of source symbols in a source block does not exceed KMAX)- Furthermore, the choice of r may depend on the source packet size distribution, e.g., if all source packets are the same size then it is advantageous to choose Tso that the actual payload size of a repair packet P', where P' is a multiple of T, is equal to (or as few bytes as possible larger than) the number of bytes each source packet occupies in the source block.<br>
[0212]    Suitable values for the input parameters might heA = 16, KM//' 4 and GMAX= 4.<br>
B.4.4.2 Examples<br>
[0213)    The above algorithm leads to transport parameters as shown in Fig. 19, assuming<br>
the above values for A, KMIN and GMAX and assuming P = 1424.<br>
B.5.     Systematic Multi-field MSCR encoder<br>
B.5.1. Encoding overview<br>
[0214]    The systematic MSCR encoder is used to generate repair symbols from a source<br>
block that comprises K source symbols.<br>
[0215]     Symbols are the fundamental data units of the encoding and decoding process. For each source block (sub-block) all symbols (sub-symbols) are the same size. The atomic operation performed on symbols (sub-symbols) for both encoding and decoding is the exclusive-or operation.<br>
Let C'[0],..., C'[K-\] denote thei source symbols. Let C[0],,.., C[L-1] denote Z, intermediate symbols.<br>
[0216]    The first step of encoding is to generate a number, L&gt; K, of intermediate symbols from the K source symbols. In this step, K source triples {d[0], a[0], b[0]), ..., {d[K-l], a[K-1 ], b[K-\]) are generated using the Trip[] generator as described in Section B.5.4.4. The K source triples are associated with the K source symbols and are then used to determine the L intermediate symbols C[0], ..., C[Z--1] from the source symbols using an inverse encoding process. This process can be can be realized by a MSCR decoding process.<br>
[0217]    Certain "pre-coding relationships" preferably hold within the L intermediate symbols. Section B.5.2 describes these relationships and how the intermediate symbols are generated from the source symbols.<br>
 <br>
(0218]    Once the intermediate symbols have been generated, repair symbols are produced and one or more repair symbols are placed as a group into a single data packet. Each repair symbol group is associated with an Encoding Symbol ID (ESI) and a number, G, of encoding symbols. The ESI is used to generate a triple of three integers, {d, a, b) for each repair symbol, again using the Trip[] generator as described in Section B.5.4.4. This is done as described in Sections B.3 and B.4 using the generators described in Section B.5.4. Then, each {d,a,b)-in\&gt;\e is used to generate the corresponding repair symbol from the intermediate symbols using the LTEnc[A', C[0],..., C[L-1], {d,a,b)] generator described in Section B.5.4.3.<br>
B.5.2. First encoding step: Intermediate Symbol Generation<br>
B.5.2.1 General<br>
[0219)    The first encoding step is a pre-coding step to generate the L intermediate symbols<br>
C[0], ..., C[L-1] from the source symbols C'[0], ..., C'[i<r-1 the intermediate symbols are></r-1>
uniquely defined by two sets of constraints:<br>
1.	The intermediate symbols are related to the source symbols by a set of source<br>
symbol triples. The generation of the source symbol triples is defined in Section B.5.2.2<br>
using the Trip[] generator as described in Section B.5.4.4.<br>
2.	A set of pre-coding relationships hold within the intermediate symbols themselves.<br>
[0220]    These are defined in Section B.5.2.3. The generation of the L intermediate symbols<br>
is then defined in Section 5.2.4.<br>
B.5.2.2 Source symbol triples<br>
[0221]    Each of the K source symbols is associated with a triple {d{i], a[i], b{i\) for 0 
For each i,0<i></i>
B.5.2.3 Pre-coding relationships<br>
[0222]    The pre-coding relationships amongst the L intermediate symbols are defined by<br>
expressing the last L-K intermediate symbols in terms of the first K intermediate symbols.<br>
 <br>
[0223]    The last L-K intermediate symbols C[AT),.. .,C[Z--1 ] compmt SLDPC symbols and HHDPCsymbols The values of S and //are determined from K as described below. Then L~ K+S+H.<br>
 <br>
[0225]    For the construction of the H HDPC symbols, the system uses the field GF(256).<br>
The field can be represented with respect to the irreducible polynomial/= x+x'*+x+x+over the field GF(2). Let a denote the element x modulo/ As is well-known to those of<br>
ordinary skill in the art, the element a is primitive, i.e., the 255 first powers of a coincide<br>
with the 255 nonzero elements of GF(256). In one embodiment, the system choose K+S<br>
integers a[0],...,a[K+S-]], and denote by (3[0], ..., f&gt;[K+S-l] the elements a"'"',..., a"-'.<br>
Further, we choose//further integers b[0],...,b[H-\] and denote by r[0],,..,r[//-l] the<br>
elements	Further preferred embodiments of the present invention will<br>
 <br>
specify specific choices for these integers. However, it should be noted that are many equivalent choices of these integers. Let g[i] = i  (floor(//2)) for all positive integers i. Note that g[i] is the Gray sequence, in which each element differs from the previous one in a single bit position. Furthermore, let g[f,k] denote thej" element,y=0, 1, 2, ..., of the subsequence of [/] whose elements have exactly k non-zero bits in their binary representation. As is well-known to those of skill in the art, the sequence g'D./c] has the property that the binary representations of g[j,k] and g[j+\,k] differ in exactly two positions. We denote these positions by p[/\k,\] and p\j,k,2].<br>
10226]    The values of the HDPC symbols are defined as the values of C[K+S],..., C[L-\] after the following process.<br>
[0227]    We initialize a symbol U as 0. The size of this symbol is the same as the common size of source, LDPC, and HDPC symbols.<br>
[0228]    Next, for a variable h ranging from 0 to K+S-2, we perform the following: The variable [/is updated as [/= L/* p[/2]'"Q/j], At the same time, we set C[A:+5+p[/;//',I]] = C[K+S+p[jjr,l]]  U, and C[K+S+p[;JT,2]] = C[K+S+p[jJfr,2]] " U-<br>
[0229]    In a further step, we transform U into [/ * p[K+S-1 ] "QK+S-1 ].<br>
[0230]    Next, for a variable h ranging from 0 to H-l we update C[K+S+h] = C[K+S+h] r[h] * U. This completes the description of the HDPC coding process.<br>
[0231]    In a preferred embodiment, the system chooses the following integers a[Ol...,a[K+S-ll and blOl-.-M-i]- a[0]=a[l]= ... =a[K+S-]] = 1 and b[0]=], b[I]=2, ... b[i] = i+1, etc. Advantageously, in this preferred embodiment, the construction of the HDPC symbols can be performed using only the action of the primitive element, a, along with bit¬wise exclusive OR operations between symbols. The choice of irreducible polynomial give above admits highly efficient implementation of the action of a, thereby reducing the computational complexity of the HDPC construction algorithm. As will be apparent to those of skill in the art, the construction algorithm described above can easily be adapted to perfonn the required decoding operations within a multi-stage code decoder, thus realizing the above mentioned reduction in computafional complexity at the decoder as well.<br>
 <br>
B.5.2.4Intermediate symbols<br>
B.5.2.4.1	Definition<br>
[0232]    Given the A: source symbols C\0], C\]], ..., C'[K-\] theL intermediate symbols<br>
C[0], C[l],..., C[L-1] are the uniquely defined symbol values that satisfy the following<br>
conditions;<br>
1.	The A: source symbols C'[0], C'[ 1 ], ..., C'[K-1 ] satisfy the K constraints Cy] = LTEnc[A:, (C[0],..., C[L-\]), {d[i], a[/], b[i])l for all /, 0<i></i>
2.	The I intermediate symbols C[0], C[l], ..., C[L-\] satisfy the pre-coding relationships defined in B.5.2.3.<br>
B.5.2.4.2	Calculation of intermediate symbols<br>
[0233J    This subsection describes a possible method for calculation of the L intermediate<br>
symbols C[0], C[\],..., C[L-l] satisfying the constraints in B.5.2.4.1<br>
10234]    The generator matrix G for a code which generates A output symbols fi-om K input symbols is an //xA'matrix over GF(2), where each row corresponds to one of the output symbols and each column to one of the input symbols and where the /" output symbol is equal to the sum of those input symbols whose column contains a non-zero entry in row /.<br>
[0235]    Then, the L intermediate symbols can be calculated as follows:<br>
Let<br>
C denote the column vector of the L intermediate symbols, C[0], C[l],..., C[L-\].<br>
D denote the column vector comprising S+H zero symbols followed by the K source symbols<br>
C'[OlCm,...,ClK-l]<br>
Then the above constraints define an LxL matrix over GF{2), A, such that:<br>
AC = D<br>
The matrix A can be constructed as follows:<br>
Let:<br>
GLDPC be WIQSXK generator matrix of the LDPC symbols. So,<br>
GLDPC ■ (C[0], ..., C[K-\]f = {Cm, ..., C{KSA]f<br>
GHDPC be the H x {K+S) generator matrix of the Half symbols, So,<br>
GHDPC® (C[0], ..., C[S+K-\]f - {C[K+S\, ..., ClK+S+H-l])"<br>
Is be the 5 X 5 identity matrix<br>
1H be theHxH identity matrix<br>
OSKH be the SxH zero matrix<br>
 <br>
GLT be Ihc KxL generator matrix of the encoding symbols generated by the LT Encoder.<br>
So,<br>
GLT- (C[0], ■••, C[I-l]f = (C'[0], C[\],--, C'[K-\])"<br>
i.e., Gijij = 1 if and only if C[0 is included in the symbols which are XORed to produce<br>
LTEm[K, (C[0], ..., C[I-1]), {d[i], «[/], b[i])].<br>
Then;<br>
The first S rows of A are equal to GLDPC I h iZsxw.<br>
The next H rows of A are equal to GHDPC I IH.<br>
The remaining K rows of A are equal to GLT-<br>
{0236]    The matrix A is depicted in Fig. 20. The intermediate symbols can then be<br>
calculated as:<br>
C = A'D<br>
10237]    The source triples are generated such that for any K matrix A has full rank and is therefore invertible. This calculation can be realized by applying a MSCR decoding process to the AT source symbols CIO], C'[]], ..., ClK-1] to produce the L intermediate symbols C[0], C[l],...,qi-1].<br>
[0238]    To efficiently generate the intermediate symbols from the source symbols, an efficient decoder implementation such as that described in Section B.6 might be used. The source symbol triples are designed to facilitate efficient decoding of the source symbols using that algorithm.<br>
B.5.3. Second encoding step: Chain reaction encoding<br>
[0239]    In the second encoding step, the repair symbol with ESI Z is generated by applying the generator LTEnc[A:, (C[0], C[l],..., C[i-1]), {d, a, b)] defined in Section B.5.4 to theZ intermediate symbols C[0], C[l], ..., C[L-\] using the triple (d, a, b)=Tnp[K,X] generated according to Sections B.3.2.2 and B.4.2.<br>
B.5.4. Generators B.5.4.1 Random Generator<br>
[0240]    The random number generator Rand[X, /, m] is defined as follows, where X is a non-negative integer, i is a non-negative integer and w is a positive integer and the value produced is an integer between 0 and m-1. Let VQ and Vi be arrays of 256 entries each, where each entry is a 4-byte unsigned integer. Suitable arrays of random numbers are provided in Appendices B.l and B.2 by way of example only and should not be construed to limit the<br>
 <br>
scope of the invention. Given those assumptions, Rand[X, /, m] = {Vo[{X+ i) % 256]  V-i[{floor(X/256)H- /) % 256]) % m. As used herein, unless otherwise indicated, "random" should be assumed to include "pseudorandom" and "essentially random".<br>
B.5.4.2Degree Generator<br>
(0241]    The degree generator Deg[v] is defined as follows, where v is an integer that is at<br>
least 0 and less than 2 = 1048576.<br>
10242)    In Fig. 21, find the index; such thaty[/-l ] 
Deg[v] = d\j]<br>
B.5.4.3	Chain reacfion Encoding Symbol Generator<br>
[0243]    The encoding symbol generator LTEnc[A:, (C[0], C[l],..., C[I-1]), {d, a, b)] takes the following inputs:<br>
[0244] K is the number of source symbols (or sub-symbols) for the source block (sub-block). Let L be derived from K as described in Section B.5.2, and let L' be the smallest prime integer greater than or equal to L.<br>
[0245]    (C[0], C[l],..., C[Z.-1]) is the array of L intermediate symbols (sub-symbols) generated as described in Section B.5.2<br>
[0246]    {d, a, b) is a source triple determined using the Triple generator defined in Section B.5.3.4, whereby d is an integer denoting an encoding symbol degree, a is an integer between 1 and L '-1 inclusive and b is an integer between 0 and L '-1 inclusive.<br>
[0247]    The encoding symbol generator produces a single encoding symbol as output, according to the following algorithm:<br>
While {h&gt;L)Aob{h + a) % L'<br>
LTEnc[i, (C[0], C[l],..., QL-l]), {d, a, bj\ = C[fe].<br>
Fory= l,...,min((i-l,L-l) do<br>
b{hd)%L'<br>
While (6&gt; I) do i = (i + a) %L'<br>
LTBnc[K, (C[0], Ql],..., C[L-\]% (d,a, b)] = LTEnc[K, (C[0], C[l],..., C[L-\]), (d, a, b)] <br>
C[b]<br>
 <br>
B,S.4.4Triple generator<br>
[02481    The triple generator Tnp[KyX] takes the following inputs:<br>
K	The number of source symbols<br>
X	An encoding symbol ID<br>
Let<br>
L be determined from K as described in Section B.5.2<br>
L' be the smallest prime that is greater than or equal to L<br>
Q = 65521, the largest prime smaller than 2'.<br>
J(K) be the systematic index associated with K. The systematic index is a number chosen<br>
such that the process below, together which the remaining processed for construction of the<br>
matrix A described herein results in a matrix B which is invertible. Suitable systematic<br>
indices are provided in Appendix A by way of example only and should not be construed as<br>
to limit the scope of the invention.<br>
[0249}    The output of the triple generator is a triples, {d, a, b) determined as follows:<br>
 <br>
B.6.1 General<br>
[0250]    This section describes an efficient decoding algorithm for the MSCR codes described in this specification. Note that each received encoding symbol can be considered as the value of an equation amongst the intermediate symbols. From these simultaneous equations, and the known pre-coding relationships amongst the intermediate symbols, any algorithm for solving simultaneous equations can successfully decode the intermediate symbols and hence the source symbols. However, the algorithm chosen has a major effect on the computational efficiency of the decoding.<br>
 <br>
B.6.2 Decoding a source block<br>
B.6.2.1 General<br>
[0251]    It is assumed that the decoder knows the structure of the source block it is to<br>
decode, including the symbol size, T, and the number K of symbols in the source block.<br>
[0252]    From the algorithms described in Sections B.5, the MSCR decoder can calculate the total number L = K+S+H of pre-coding symbols and determine how they were generated from the source block to be decoded. In this description it is assumed that the received encoding symbols for the source block to be decoded are passed to the decoder. Furthermore, for each such encoding symbol it is assumed that the number and set of intermediate symbols whose exclusive-or is equal to the encoding symbol is passed to the decoder. In the case of source symbols, the source symbol triples described in Section B.5,2.2 indicate the number and set of intermediate symbols which sum to give each source symbol.<br>
[0253]    Let N&gt;K be the number of received encoding symbols for a source block and let M = S+H+N. The following Mx L matrix A can be derived from the information passed to the decoder for the source block to be decoded. Let C be the column vector of the L intermediate symbols, and let D be the column vector ofM symbols with values known to the receiver, where the last S+H of the M symbols are zero-valued symbols that correspond to LDFC and HDPC symbols (these are check symbols for the LDPC and HDPC symbols, and not the LDPC and HDPC symbols themselves), and the remaining N of the M symbols are the received encoding symbols for the source block. Then, A is the matrix that satisfies AC = D, where here • denotes matrix multiplication over G(256). The matrix A has a block structure, as shown in Figure 23. The block structure comprises a matrix F with Arrows and L columns, a matrix E with S rows and L-S-H columns, a 5 by -S identity matrix I, a matrix O with 5 rows and H columns that are entirely zeros, a matrix B with H rows and L-H columns, and a if by //identity matrix J. The submatrix B has entries defined over the field GF(256), while the matrices E and F have 0/1 entries, i.e., entries in the field GF(2). The matrix F defines the dynamic coding process, the matrix E defines the LDPC coding process described above, and the matrix B defines the HDPC coding process. In particular, Y[iJ] - 1 if the intermediate symbol corresponding to indexy is exclusive-ORed into the or encoding symbol corresponding to index / in the encoding. For all other i andy, F[y] = 0. Similarly, £[/,;■] = 1 if the intermediate symbols corresponding to index 7 is exclusive-ORed into the LDPC symbol corresponding to index i. Finally, B[/,/] = p if the result of the action of p on the<br>
 <br>
intermediate sjonbols corresponding to index/' is exclusive-ORed into the HDPC symbol corresponding to index /.<br>
(0254]    Decoding a source block is equivalent to decoding C from known A and D. It is clear that C can be decoded if and only if the rank of A over GF(256) is L. Once C has been decoded, missing source symbols can be obtained by using the source symbol triples to determine the number and set of intermediate symbols which are exclusive-ORed to obtain each missing source symbol.<br>
[0255]    The first step in decoding C is to fonn a decoding schedule. In this step A is converted, using Gaussian elimination (using row operations and row and column reorderings) and after discarding M- L rows, into the L by L identity matrix. The decoding schedule comprises the sequence of row operations and row and column re-orderings during the Gaussian elimination process, and only depends on A and not on D. The decoding of C from D can take place concurrently with the forming of the decoding schedule, or the decoding can take place afterwards based on the decoding schedule.<br>
[0256]    The correspondence between the decoding schedule and the decoding of C is as follows. Let c[0] = 0, c[l] = 1 ...,c[i-l] = L-\ and d[0] = 0, [1] = \...,d[M-\] = MA initially.<br>
[0257]     Each time row / of A is exclusive-ORed into row /' in the decoding schedule then in the decoding process symbol D[i5?[0] is exclusive-ORed into symbol D[(i[/']] . We call this operation a GF(2)-row operation.<br>
[0258]    Each time a multiple a (for some a in GF(256)) of row i of A is exclusive-ORed into row /' in the decoding schedule, then in the decoding process symbol a * I&gt;[(i[i]] is exclusive-ORed into symbol D[c?[z']]. We call this operation a GF(256)-row operation. Note that a GF(2)-row operation is a particular case of a GF(256)-row operation in which the element a is 1.<br>
[0259]    Each time row i is exchanged with row /' in the decoding schedule then in the decoding process the value of c?[/] is exchanged with the value of rf[/'].<br>
[0260]    Each time column/ is exchanged with column/' in the decoding schedule then in the decoding process the value of c[/] is exchanged with the value of c[/'].<br>
 <br>
|0261J    From this correspondence it is clear that the total number of exclusive-ORs of symbols in the decoding of the source block is related to the number of row operations (not exchanges) in the Gaussian elimination. Since A is the L by L identity matrix after the Gaussian elimination and after discarding the last M- L rows, it is clear at the end of successftjl decoding that the I symbols D[(i[0]], D[d[\\],...,D{d[L-\]] are the values of the I symbols C[c[0]], C[c[l]],..., qc[I-l]].<br>
[0262]    The order in which Gaussian elimination is performed to form the decoding schedule has no bearing on whether or not the decoding is successful. However, the speed of the decoding depends heavily on the order in which Gaussian elimination is performed. (Furthennore, maintaining a sparse representation of A is crucial, although this is not described here). It is also clear that it is more efficient to perform GF(2)-row operations rather than GF(256)-row operations. Therefore, when performing the Gaussian elimination, it is better to pivot on rows of the matrix A which with elements taken from the field GF(2). It is also advantageous to leave the elimination of the rows of the matrix corresponding to the HDPC symbols to the end of the Gaussian elimination process. The remainder of this section describes an order in which Gaussian elimination could be performed that is relatively efficient.<br>
B.6.2.2 First Phase<br>
[0263]    Referring to Figure 23, we denote by X the matrix comprising F, E, I and 0 as<br>
depicted in Figure 24a.<br>
T[0264] he first phase of the Gaussian elimination the matrix X is conceptually partitioned into submatrices. The submatrix sizes are parameterized by non-negative integers / and u which are initialized to 0. The submatrices of X are:<br>
(1)	The submatrix defined by the intersection of the first i rows and first i columns. This is the identity matrix at the end of each step in the phase.<br>
(2)	The submatrix defined by the intersection of the first / rows and all but the first / columns and last w columns. All entries of this submatrix are zero.<br>
(3)	The submatrix defined by the intersection of the first / columns and all but the first / rows. All entries of this submatrix are zero.<br>
(4)	The submatrix U defined by the intersection of all the rows and the last u columns.<br>
 <br>
(5)       The submatrix V formed by the intersection of all but the first i columns and the<br>
last u columns and all but the first / rows. |0265)    Fig. 22 illustrates the submatrices of X. At the beginning of the first phase V = X. In each step, a row of X is chosen. The following graph defined by the structure of V is used in detennining which row of X is chosen. The columns that intersect V are the nodes in the graph, and the rows that have exactly 2 ones in V are the edges of the graph that connect the two columns (nodes) in the positions of the two ones. A component in this graph is a maximal set of nodes (columns) and edges (rows) such that there is a path between each pair of nodes/edges in the graph. The size of a component is the number of nodes (columns) in the component. The graph is denoted by Y in the following.<br>
[0266]    There are at most L steps in the first phase. The phase ends when V either disappears or becomes the zero matrix-. In each step, a row of X is chosen as follows;<br>
[0267]    If all entries of V are zero then no row is chosen and the first phase ends.<br>
O[0268] therwise, let r be the minimum integer such that at least one row of X has exactly r ones in V.<br>
If r=l, then choose the row with exactly one 1 in V.<br>
If r = 2 then choose any row with exactly 2 ones in V that is part of a maximum size<br>
component in the graph defined by Y.<br>
If r &gt; 2 then choose a row with exactly r ones in V with minimum original weight among all<br>
such rows.<br>
[0269]    After the row is chosen in this step the first row of X that intersects V is exchanged<br>
with the chosen row so that the chosen row is the first row that intersects V. The columns of<br>
X among those that intersect V are reordered so that one of the r ones in the chosen row<br>
appears in the first column of V and so that the remaining r-1 ones appear in the last columns<br>
of V. Then, the chosen row is exclusive-ORed into all the other rows of X below the chosen<br>
row that have a one in the first column of V. In other words, we perform a GF(2)-row<br>
operation in this step. Finally, i is incremented by 1 and u is incremented by r-\, which<br>
completes the step.<br>
[0270]    Let V denote the number of columns of the matrix V at the end of this phase. After permuting the columns of the matrix B so that the columns of V correspond to the last v columns of X, the matrix X will have the form given in Figure 24b.<br>
 <br>
B.6.2.3 Second Phase<br>
I0271J    We modify the matrix U so it comprises additionally the last v rows of the matrix X, and we replace w accordingly by u+v. The submatrix U is further partitioned into the first / rows, Uuppci. and the remaining N+S - i rows, Uiowcr, as depicted in Fig. 25. Gaussian elimination is performed in the second phase on Uiower- After this step, the matrix U|o-wer will have the form given in Fig. 26, i.e., after a permutation of the rows and columns, the intersection of the first s rows with the first s columns is an identity matrix, called I, the last m rows are zero, and the intersection of the first s rows with the last us columns forms the matrix W. Note that s+m equals the number N+S-i of rows of the matrix Uiower- If the value of .s is u, then the next phase may be skipped. If the value of m is larger than H-v, then a decoding error is returned, since the rank of the matrix A is less than L in this case. The last m rows of the matrix X are discarded, so that after this phase A has the form given in Fig. 27. In this figure, Bi, ..-, B3 are matrices with //rows each and entries in GF(256). Next, GF(256)-row operations are performed on the matrices Bi and B2 to zero them out. TTiis may be done in one of two ways. In a first method, the first / rows of A are used to zero out the matrix B) by means of GF(256)-row operations. The next s rows of A are then used to zero out the matrix Bj. In a second method, rows / to l+s-1 inclusive are used to zero out the first 5 columns of Uupper by means of GF{2)-row operations and then the first i+s rows of X are used to zero out both Bj and 82 by means of GF(256)-row operations. As is apparent to those of ordinary skill in the art, the method algorithm described above for construction of the HDPC symbols leads to a similar algorithm for zeroing out of the matrix Bj (in the first method) or both Bi and B2 (in the second method). This algorithm requires calculation of the action of a GF(256) element on a symbol only once per matrix column plus once per row of H. Thus, the second method described above results in overall fewer operations to zero out the matrices Bi and B2.<br>
[0272]    After this step, the matrix A has the form given in Fig. 28. The matrix T has //rows and us columns. Gaussian elimination is performed on the matrix T to transform it into an identity matrix, followed by H-u+s rows. If this is not possible, i.e., if the rank of T is smaller than us, then a decoding error is flagged. At the end of this stage the matrix A has the form given in Fig. 29, after discarding the last H-u+s rows. In this figure, 1 denotes a i' by 5 identity matrix, and J denotes a us by us identity matrix.<br>
 <br>
B.6.2.4Third Phase<br>
[0273]    After the second phase the portions of A which need to be zeroed out to finish converting A into the L by L identity matrix are W and all u columns of Uupper, in the case that the first method of zeroing out B) and B2 has been followed, or W and the last u-s columns of Uupper, in the case that the second method of zeroing out B| and B2 has been followed. In the former case, since the matrix W is generally of small size, it can be zeroed out using elementary GF(2)-row operations. After this step, the matrix A has the form given in Fig. 30. In both cases, the remaining portion of the matrix to be zeroed out is now rectangular. In the former case it is of size / rows and u columns, in the latter case it is of size i+s rows and u-s columns. In the following we shall use /' for the number of rows in this matrix and u' for the number of columns and denote the matrix by 0.<br>
[0274]    The number of rows ;' of the remaining submatrix U is generally much larger than the number of columns u '. There are several methods which may be used to zero out tj efficiently. In one method, the following precomputation matrix U' is computed based on, the last u rows and columns of A, which we denote !„ and then U' is used to zero out V. The u rows of I„ are partitioned into ceil(w/z) groups of z rows each, for some integer z. Then, for each group of 2 rows all non-zero combinations of the z rows are computed, resulting in 2- 1 rows (this can be done with 2'-z-l  exclusive-ors of rows per group, since the combinations of Hamming weight one that appear in !„ do not need to be recomputed). Thus, the resulting precomputation matrix U' has ceil(w/2) -2'- 1 rows and u columns. Note that U' is not formally a part of matrix A, but will be used subsequently to zero out Uupper- In a preferred embodiment, z=8.<br>
[0275]    For each of the i' rows of U, for each group of z columns in the U submatrix of this row, if the set of z column entries in U are not all zero then the row of the precomputation matrix U' that matches the pattern in the z columns is exclusive-ORed into the row, thus zeroing out those z columns in the row at the cost of exclusive-oring one row of U' into the row.<br>
[0276]    After this phase A is the Lhy L identity matrix and a complete decoding schedule has been successfiiily formed. Then, the corresponding decoding comprising exclusive-ORing known encoding symbols can be executed to recover the intermediate symbols based on the decoding schedule.<br>
 <br>
(0277)    The triples associated with all source symbols are computed according to B.5.2.2. The triples for received source symbols are used in the decoding. The triples for missing source symbols are used to determine which intermediate symbols need to be exclusive-ORed to recover the missing source symbols.<br>
Multi-Field, Single-Staee Chain Reaction Encoders/Decoders<br>
[0278]    Multi-field, single-stage (MFSS) codes have useful properties that are disclosed or suggested herein. Novel arrangements for MFSS codes, encoders and decoders are described herein. In one embodiment, data is encoded for transmission from a source to a destination in which each output symbol is generated as a linear combination of one or more of the input symbols with coefficients taken from finite fields and, for each output symbol:<br>
-	selecting according to a random process an integer greater than zero, d, known as the degree of the output symbol,<br>
-	selecting according to a random process, a set of size d of input symbols, this set of input symbols to be known as the neighbor set of the output symbol,<br>
-	selecting a set of finite fields, such that for at least one output symbol this set contains at least two finite fields,<br>
-	selecting for each input symbol in the neighbor set of the output symbol a finite field from the selected set of possible finite fields,<br>
-	selecting for each input symbols in the neighbor set of the output symbol, according to a random process, a non-zero element from the finite field selected above.<br>
[0279]    The random process for selecting the degrees of the output symbols may be a process described in Luby I and Luby 11 in which the degree is selected according to a degree distribution. The random process for selecting the input symbols to associate with each output symbol maybe a process described in Luby I and Luby I] in which the input symbols '      are selected randomly and uniformly. As used herein "random" may include "pseudorandom", "biased random" and the like.<br>
[0280]    The set of possible finite fields may be the set { GF(2), GF{256)).<br>
[0281]    The process for selecting the finite field may be based on a parameter di, such that for output symbols of degree less than cf/, the field GF(2) is chosen for all input symbols in )      the neighbor set of the output symbol and for output symbols of degree di or greater than the<br>
 <br>
field GF(256) is chosen for at least one, some or all of the members of the neighbor set of the output symbol and the field GF(2) is chosen for the remaining elements of the neighbor set, if any.<br>
(0282J    The process for selecting the finite field element from the selected field may the simple random process in which an element is chosen uniformly at random from amongst the non-zero elements of the field.<br>
[0283]    A decoder receiving data encoded by an MFSS encoder as described above might decode the output symbols to regenerate the input symbols by forming a matrix representation of the code according to the method described above, this matrix including no stafic rows and one dynamic row for each output symbol of the code, and then applying Gaussian Elimination to find the inverse of this matrix, ensuring that at each stage of the Gaussian Eliminafion process pivot rows of minimal degree are chosen.<br>
[02841    As will be clear to those of ordinary skill in the art, many of the well-know,n properties of the codes described in Luby I and Luby II are equally applicable to the codes described above and in particular the choice of an appropriate degree distribution can ensure that with high probability the Gaussian Elimination process is able to identify a row of remaining degree one and thus the decoding process operates as a chain reaction process as described in Luby I and Luby II.<br>
[0285]    This MFSS code has several further advantages over codes known in the art. Firstly, the inclusion of elements from the field GF(256) reduces significantly the probability that any given received output symbol is not information additive with respect to previously received output symbols. As a result, the decoding error probability of this code is much lower than previous codes. For example, in some instances, the failure probability of the codes described in Luby I and Luby II is improved upon.<br>
[0286]    An advantage of this code over other codes based on large fields is that output symbols of low degree will generally be processed first by the Gaussian Elimination process and as a result the inclusion of elements from GF(256) need not be considered until later in the decoding process. Since operations over GF(256) are relatively expensive compared to those over GF{2), this results in greatly reduced computational complexity compared to codes where many or ail of the symbols are constructed using elements from GF(256) or other large finite fields.<br>
 <br>
[0287]    A further advantage over other codes based on large fields is that for those output symbols generated using the larger field, only one element of the neighbor set has a coefficient which is taken from the larger field and as a result only one operation between a symbol and a finite field element is required for each such output symbol. This results in low overall computational complexity.<br>
[0288]    It is known that using inner codes and outer codes to encode input symbols using two (or more) coding procedures leads to a simple code scheme that provides benefits often found in more complex codes. With the use of inner codes and outer codes, source symbols are first encoded using one of the codes and the output of the first encoder is provided to a coder that codes according to the other code and that result is output as the output symbols. Using an MFSS is, of course, different from the use of inner/outer codes. For one, the output symbols are derived from neighbor sets of input codes. In many of the embodiments described herein, each output symbol is a linear combination of input symbols. With multi¬stage codes, each output symbol might be a linear combination of input symbols and/or redundant and/or intermediate symbols.<br>
Dense Multi-Field Codes and Encoders/Decoders for Such Codes<br>
[0289]    In a variation of the teachings described above, the matrix representation of the code is a dense matrix. As is well known, error correction codes can be constructed from dense random matrices over finite fields. For example, a generalized matrix may be constructed in which there are no static rows and each dynamic row comprises elements from GF(2'), with each element chosen randomly. A fixed rate code may then be constructed in which each output symbol corresponds to one of the dynamic rows and is generated as the linear combination of those input symbols for which there is a non-zero element in the corresponding column of this row of the matrix, using these elements as coefficients in the linear combinafion process.<br>
[0290]    It is well known to those of skill in the art that the probability that a randomly chosen matrix with K rows and K+A columns with coefficients that are independently and randomly chosen from GF(2') has a rank that is smaller than K is at most 2"*'. Therefore, the decoding error probability of a code with K input and KIR output symbols in which the output symbols are generated independently and randomly from the input symbols using randomly chosen coefficients from GF(2') is at most 2'', if the number of encoded symbols received is K+A.<br>
 <br>
10291]    In the case ofg=\, the code described above has the advantage of reasonable computational complexity, since all operations are within the field GF(2) and thus correspond to conventional XOR operations. However, in this case the lower bound on the failure probability of 2"' once A additional symbols have been received is much higher than desirable.<br>
(0292] In the case of 17=8, the code described above has the advantage of a lower failure probability (bounded by 2" ' for additional syinbols received). However, in this case all operations are within the field GF(256) and are thus relafively computationally expensive.<br>
[0293]    A ftirther embodiment allows decoding error probabilities close to those achievable using large values ofg to be achieved with computational complexity close to that achievable with small values ofg. In this embodiment, output symbols are generated as linear combinations of input symbols with coefficients taken from either GF(20 or GF(2') where/? 
10294]    Data received at a desdnafion can be decoded by determining the linear relationships between received output symbols and the input symbols of the code and solving this set of linear relationships to determine the input symbols.<br>
[0295]    The decoding error probability of this code is at most that of the code in which all coefficients are chosen from the field GF(2) and may be significantly lower depending on the number of symbols generated using coefficients from the larger field GF(2). However, since most of the output symbols are generated using coefficients from GF(20, the computational complexity of encoding is only slightly greater than that of a code in which all symbols are generated using coefficients from GF(20- Furthermore, the method of decoding I      may be so arranged that symbols generated with coefficients form GF(2'} are processed first and thus the majority of the decoding operatons are performed with operations exclusively in GF(2'). As a result, the computational complexity of the decoding method is similarly close to that for codes constructed using only GF(2). In a particular preferred embodiment, jo=l and g=8.<br>
}      Some Properties of Some Multi-Field Codes<br>
[0296]    In most of the examples described above, the input and output symbols encode for the same number of bits and each output symbol is placed in one packet (a packet being a unit<br>
 <br>
of transport that is either received in its entirety or lost in its entirety). In some embodiments, the communications system is modified so that each packet contains several output symbols. The size of an output symbol value is then set to a size determined by the size of the input symbol values in the initial splitting of the file or blocks of the stream into input symbols, based on a number of factors. The decoding process remains essentially unchanged, except that output symbols arrive in bunches as each packet is received.<br>
|0297]    The setting of input symbol and output symbol sizes is usually dictated by the size of the file or block of the stream and the communication system over which the output symbols are to be transmitted. For example, if a communication system groups bits of data into packets of a defined size or groups bits in other ways, the design of symbol sizes begins with the packet or grouping size. From there, a designer would determine how many output symbols will be carried in one packet or group and that determines the output symbol size. For simplicity, the designer would likely set the input symbol size equal to the output symbol size, but if the input data makes a different input symbol size more convenient, it can be used.<br>
[0298]    The above-described encoding process produces a stream of packets containing output symbols based on the original file or block of the stream. Each output symbol in the stream is generated independently of all other output symbols, and there is no lower or upper bound on the number of output symbols that can be created. A key is associated with each output symbol. That key, and some contents of the input file or block of the stream, determines the value of the output symbol. Consecutively generated output symbols need not have consecutive keys, and in some applications it would be preferable to randomly generate the sequence of keys, or pseudorandomly generate the sequence.<br>
[0299]    Multi-stage decoding has a property that a block of K equal-sized input symbols can be recovered from K+A output symbols on average, with very high probability, where A is small compared to K. For example, in the preferred embodiment first described above, when K = 100, Fig. 31 shows the probability of failing to decode from K+A output symbols chosen randomly fi-om among the first 120 output symbols generated, and the table of Fig. 32 shows the probability of failing to decode from K+A output symbols chosen randomly fi-om among the first 110 output symbols generated.<br>
[0300]    Since the particular output symbols are generated in a random or pseudorandom order, and the loss of particular output symbols in transit is generally unrelated to the values of the symbols, there is only a small variance in the actual number of output symbols needed<br>
 <br>
to recover the input file or block. In many cases, where a particular collection of K+A output symbols are not enough to decode the a block, the block is still recoverable if the receiver can receive more output symbols from one or more sources.<br>
[0301]    Because the number of output symbols is only limited by the resolution of I, well more than K+A output symbols can be generated. For example, if I is a 32-bit number, 4 billion different output symbols could be generated, whereas the file or block of the stream could include K=50,000 input symbols. In some applications, only a small number of those 4 billion output symbols may be generated and transmitted and it is a near certainty that an input file or block of a stream can be recovered with a very small fraction of the possible output symbols and an excellent probability that the input file or block can be recovered with slightly more than K output symbols (assuming that the input symbol size is the same as the output symbol size).<br>
{0302J    In some applications, it may be acceptable to not be able to decode all of the input symbols, or to be able to decode all of input symbols, but with a relatively low probability. In such applications, a receiver can stop attempting to decode all of the input symbols after receiving K+A output symbols. Or, the receiver can stop receiving output symbols after receiving less than K+A output symbols. In some applications, the receiver may even only receive K or less output symbols. Thus, it is to be understood that in some embodiments of the present invention, the desired degree of accuracy need not be complete recovery of all the input symbols.<br>
[0303]    Further, in some applications where incomplete recovery is acceptable, the data can be encoded such that all of the input sjmibols cannot be recovered, or such that complete recovery of the input symbols would require recepfion of many more output symbols than the number of input symbols. Such an encoding would generally require less computational expense, and may thus be an acceptable way to decrease the computational expense of encoding.<br>
[0304]    It is to be understood that the various functional blocks in the above-described figures may be implemented by a combination of hardware and/or software, and that in specific implementations some or all of the functionality of some of the blocks may be combined. Similarly, it is also to be understood that the various methods described herein may be implemented by a combinafion of hardware and/or software.<br>
 <br>
10305]    The above description is illustrative and not restrictive. Many variations of the invention will become apparent to those of skill in the art upon review of this disclosure. The scope of the invention should, therefore, be determined not with reference to the above description, but instead should be determined with reference to the appended claims along with their full scope of equivalents.<br>
 <br>
APPENDIX A. VALUES FOR SYSTEMATIC INDICES JiK) [0306]    For each value oK, the systematic index J{K) is designed to have the property that the set Dfsource symbol triples (40], fl[0]&gt;[0]), ..., (4L-1], «[I-l], 6[L-]]) are such that the! intermediate symbols are uniquely defined, i.e., the matrix A in Section B.5.2.4.2 has full rank and is therefore invertible. The following is a list of suitable systematic indices for values of AT between 4 and 8192 inclusive and is provided byway of example. The order of the values is in reading order, i.e., from the first number on the first line through the last number on the first line, followed by the first number on the second line, and so on.<br>
 <br>
 <br>
 <br>
<br>
 <br>
<br>
 <br>
<br>
 <br>
<br>
 <br>
<br>
 <br>
<br>
 <br>
<br>
 <br>
<br>
 <br>
<br>
 <br>
<br>
 <br>
<br>
 <br>
<br>
 <br>
<br>
 <br>
<br>
 <br>
<br>
<br>
<br>
WHAT IS CLAIMED IS:<br>
1.	A method of encoding data for transmission from a source to a destination<br>
over a communications channel that is expected to perform as an erasure channel at least<br>
partially, the method comprising:<br>
obtaining an ordered set of input symbols representing the data to be encoded; selecting a plurality of field arrays of values, wherein each field array is derived from a<br>
finite field array and at least two different finite field arrays are represented; generating a data structure that represents a coefficient matrix that represents at least two<br>
of the plurality of field arrays, wherein at least two of those field arrays are derived<br>
from finite field arrays different from each other; generating output symbols as linear combinations of input symbols, wherein the<br>
particular combinations are according to the data structure that represents the<br>
coefficient matrix; and using the generated output symbols and an encoding for the data.<br>
2.	The method of claim 1, wherein the data structure that represents a coefficient matrix is a two-dimensional array of cell values, each cell value representing a coefficient of one input symbol in the generation of one output symbol such that when a coefficient is not zero or zero modulo some base, the value of the corresponding output symbol depends on the value of the corresponding input symbol.<br>
3.	The method of claim 1, wherein the data structure that represents a coefficient matrix is a set of rules that specify coefficient values, and further wherein a rule indicates that a coefficient is not zero or zero modulo some base, the value of the corresponding output symbol depends on the value of the corresponding input symbol.<br>
4.	The method of claim 1, wherein the number of unique output symbols that can be generated from the set of input symbols, for any set of fixed values for the input symbols, is independent of the field array sizes.<br>
5.	The method of claim 1, wherein the generation of a data structure that represents a coefficient matrix that represents at least two of the plurality of field arrays, wherein at least two of those field arrays are derived from finite field arrays different from each other is a generation that uses a first field array derived from a first finite field array and a second field array derived from a second finite field array, wherein the first finite field array<br>
 <br>
and the second finite field array are different, and further wherein the first finite field and the second finite field are each selected from the field set consisting of GF(2), GF(4), GF{16), GF(256).<br>
6.	The method of claim 5, wherein the first finite field array is GF(2) and the second finite field array is GF(256).<br>
7.	The method of claim 5, wherein the first finite field array is GF(2) and the second finite field array is GF(4).<br>
8.	The method of claim 5, wherein the first finite field array is GF(4) and the second finite field array is GF(16).<br>
9.	The method of claim 5, wherein the first finite field array is GF(16) and the second finite field array is GF(256).<br>
<br>
10.	The method of claim 5, wherein the first finite field array is smaller than the second finite field array.<br>
11.	The method of claim 5, wherein the first finite field array is larger than the second finite field array.<br>
] 2. A method of decoding data from a transmission received at a destination from a source over a communications channel that is expected to perform as an erasure channel at least partially, the method comprising:<br>
receiving at least some of a plurality of output symbols generated from an ordered set of input symbols that were encoded into the plurality of output symbols wherein each output symbol was generated as a linear combination of one or more of the input symbols with coefficients chosen from finite fields, wherein at least one coefficient is a member of a first finite field and at least one other coefficient is a member of a second finite field and is not a member of the first finite field; and regenerating the ordered set of input symbols to a desired degree of accuracy from reception of any predetermined number of the output symbols.<br>
13. The method of claim 12, wherein the number of unique output symbols that could have been generated from the set of input symbols, for any set of fixed values for the input symbols, was independent of the field array sizes.<br>
 <br>
14.	The method of claim 12, wherein the finite fields are such that a first finite field array and a second finite field array are different and the first finite field and the second finite field are each selected from the field set consisting of GF(2), GF(4), GF(] 6), GF(256).<br>
15.	The method of claim 14, wherein the first finite field array is GF{2) and the second finite field array is GF(256).<br>
16.	The method of claim 14, wherein the first finite field array is GF(2) and the second finite field array is GF(4).<br>
17.	The method of claim 14, wherein the first finite field array is GF(4) and the second finite field array is GF{16).<br>
18.	The method of claim 14, wherein the first finite field array is GF(16) and the second finite field array is GF(256).<br>
19.	The method of claim 14, wherein the first finite field array is smaller than the second finite field array.<br>
20.	The method of claim 14, wherein the first finite field array is larger than the second finite field array.<br>
21.	A method of encoding data for transmission from a source to a destination<br>
over a communications channel that is expected to perform as an erasure channel at least<br>
partially, the method comprising:<br>
obtaining an ordered set of input symbols representing the data to be encoded; selecting a plurality of field arrays of values, wherein each field array is derived from a<br>
finite field array and at least two different finite field arrays are represented; generating a data structure that represents a coefficient matrix that represents at least two<br>
of the plurality of field arrays, wherein at least two of those field arrays are derived<br>
from finite field arrays different from each other; generating a plurality of redundant symbols from the ordered set of input symbols,<br>
wherein each redundant symbol is generated based on a set of linear constraints over<br>
one or more of the input symbols and other redundant symbols with coefficients<br>
over finite fields;<br>
 <br>
generating output symbols as linear combinations of input symbols, wherein the particular combinations are according to the data structure that represents the coefficient matrix;<br>
generating a plurality of output symbols from the combined set of input and redundant symbols, wherein each output symbol is generated as a linear combination of one or more of the combined set of input and redundant symbols with coefficients chosen from finite fields;<br>
using the generated output symbols and an encoding for the data.<br>
22.	The method of claim 21, wherein the number of redundant symbols that can be generated from the set of input symbols, for any set of fixed values for the input symbols, is independent of the field array sizes.<br>
23.	The method of claim 21, wherein the finite fields are such that a first finite field array and a second finite field array are different and the first finite field and the second finite field are each selected from the field set consisting of GF(2), GF(4), GF(1,6), GF(256).<br>
24.	A method of decoding data from a transmission received at a destination from a source over a communications channel that is expected to perform as an erasure channel at least partially, the method comprising;<br>
receiving at least some of the plurality of output symbols generated from a combined set of input and redundant symbols, wherein each output symbol is generated as a linear combination of one or more of a combined set of input and redundant symbols with coefficients chosen from finite fields,<br>
wherein the plurality of redundant symbols is generated from the ordered set of input symbols, wherein each redundant symbol is generated based on a set of linear constraints over one or more of the input symbols and other redundant symbols Vi'ith coefficients over finite fields,<br>
wherein at least one coefficient is a member of a first finite field and at least one other coefficient is a member of a second finite field and is not a member of the first finite field; and<br>
regenerating the ordered set of input symbols to a desired degree of accuracy from reception of any predetermined number of the output symbols.<br>
 <br>
25.	The method of claim 24, wherein the number of unique output symbols that could have been generated from the set of input symbols, for any set of fixed values for the input symbols, was independent of the field array sizes.<br>
26.	The method of claim 24, wherein the first finite field is GF(2).<br>
27.	The method of claim 24, wherein the second finite field is GF(256).<br>
28.	The method of claim 24, wherein the second finite field is GF(4).<br>
29.	The method of claim 24, wherein the first finite field is GF(4).<br>
30.	The method of claim 24, wherein the first finite field is GF(16).<br>
31.	The method of claim 24, wherein the second finite field is GF(] 6).<br>
 <br>
</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=b0Tgye8DgvDuYCvoJrcnzA==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=b0Tgye8DgvDuYCvoJrcnzA==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==</a></p>
		<br>
		<div class="pull-left">
			<a href="277167-additive-composition-comprising-an-amidized-or-imidized-polymer.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="277169-method-and-apparatus-for-optically-filtering-a-communication-signal.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>277168</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>5002/CHENP/2008</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>48/2016</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>18-Nov-2016</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>15-Nov-2016</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>19-Sep-2008</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>DIGITAL FOUNTAIN, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>39141 CIVIC CENTER DRIVE, FREMONT, CA 94538</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>SHOKROLLAHI, M. AMIN</td>
											<td>5780 CHANDLER COURT, SAN JOSE, CA 95123</td>
										</tr>
										<tr>
											<td>2</td>
											<td>LUBY,MICHAEL, G;</td>
											<td>1133 MILLER AVENUE,BERKELEY, CA 94708</td>
										</tr>
										<tr>
											<td>3</td>
											<td>WATSON, MARK,</td>
											<td>43 MALLORCA WAY, SAN FRANCISCO, CA 94123</td>
										</tr>
										<tr>
											<td>4</td>
											<td>MINDER, LORENZ,</td>
											<td>39141 CIVIC CENTER DRIVE, FREMONT, CA 94538</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04B14/04</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US07/62302</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2007-02-16</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/674,655</td>
									<td>2007-02-13</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/775,528</td>
									<td>2006-02-21</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/277168-multiple-field-based-code-generator-and-decoder-for-communications-systems by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:18:05 GMT -->
</html>
