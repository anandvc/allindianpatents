<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/201001-data-processing-system-and-method-for-anticipating-instruction-execution by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 02:41:43 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 201001:DATA PROCESSING SYSTEM AND METHOD FOR ANTICIPATING INSTRUCTION EXECUTION</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">DATA PROCESSING SYSTEM AND METHOD FOR ANTICIPATING INSTRUCTION EXECUTION</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>DATA PROCESSING SYSTEM AND METHOD FOR ANTICIPATING INSTRUCTION EXECUTION A data processing system indicates that an instruction does not have available data because of a cache miss or because of a non-cache-miss delay. When the instruction is not able to access the available data and a cache miss results, instructions which are dependent on the issued instruction are not issued. However, if the load execution is delayed because of a non-cache-miss delay, then the instructions which are dependent on the issued instruction are also issued in anticipation of a successful load instruction execution in a next timing cycle. Through the use of this issuing mechanism, the efficiency of the data processing system is increased as an execution unit is better able to utilize its pipeline. AU97O7g0O20 040497 vlO 312:7047-P140US</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FOR ANTICIPATING INSTRUCTi9N-E?aBetmON<br>
-TECHNICAL FIEtD""<br>
The present invention relates in general to data processing systems, and in particular, to instruction scheduling mechanisms in pipelined data processing systems.<br>
BACKGROUND INFORMATION<br>
High performance processors currently used in data processing systems today may be capable of "superscalar" operation and may have "pipelined" elements.  A superscalar processor has multiple elements which operate in parallel to process multiple instructions in a single processing cycle.  Pipelining involves processing instructions in stages, so that the pipelined stages may process a number of instructions concurrently.  In a typical first stage, referred to as a "instruction fetch" stage, an instruction is fetched from memory.  Then, in a "dispatch" stage, the instruction is decoded into different control bits, which designate a type of<br><br>
functional unit for performing the operations specified by the instruction, source operands for the operation, and destination registers for results of operations.  The decoded instruction is dispatched to an issue queue where instructions wait for data and an available execution unit.  Next, in the "issue" stage, an instruction in the issue queue is issued to a unit having an "execution stage."  The execution stage processes the operation as specified by the instruction.  Executing an operation specified by an instruction includes accepting one or more operands and producing one or more results.<br>
A "completion" stage addresses program order issues which arise from concurrent instruction execution, wherein multiple, concurrently executed instructions may deposit results in a single register.  The completion stage also handles issues arising from instructions dispatched after interrupted instruction deposits results in a same destination registers.  In the completion stage, an instruction waits for the point at which there is no longer a possibility of an interrupt before storing a data value, so that a depositing of a result will not violate a program order.  At this point, the instruction is considered "complete."  It should be noted that buffers to store execution results before results are deposited into the destination register and buffers to back up contents at specified checkpoints are provided in the instance an interrupt reverts the register content to its pre-checkpoint value.  Either types of buffers may be utilized in a particular implementation.  At completion, the results of the execution buffer and the holding<br><br>
buffer will be deposited into the destination register and the back-up buffer will be released.<br>
Pipelined data processing systems typically implement load instructions to load information from a storage location to a register in a pipelined fashion. Typically, such load instructions execute in one cycle and, therefore, do not adversely affect the timing associated with pipelined flow of the data processor. However, under certain conditions, execution of the load instruction will take more than one cycle and, thus, the timing of the pipeline flow will be adversely affected. One of the conditions which may require a load operation to execute in more than one cycle occurs when an address of the load instruction must be translated. Address translation requires a look-up and address compare operation using a translation lookaside buffer (TLB).  When an address translation operation involving a TLB is executed by a data processing system, an extra cycle is required for control signals corresponding to the load instruction to access the TLB.  If there is a corresponding real address stored in the TLB, then the address translation is considered successful.  However, if there is no corresponding entry in the TLB, then a table walk operation is initiated.  Such a table walk operation requires all page table entries to be fetched from a memory.  The table walk operation consumes a substantial number of cycles during execution of a load operation.<br>
Additionally, a load operation may take more than one cycle when the load instruction is made to an address which is not aligned.  An address is not aligned when data for that load instruction spans across the address boundary for which the<br><br>
data processing system is designed.  In this case, an additional cycle is required to assemble data that spans the boundary of the fetch address.  Unlike a load operation which requires address translation and may take an undetermined number of cycles to execute, an unaligned load operation only requires a fixed number of additional cycles.<br>
During operation of a typical data processor, an instruction issuing algorithm issues instructions with available operands to execution units for execution.  If a load executes, but its data is not in the cache, then subsequent instructions which depend on the load instruction are marked as not having available data and are not issued to the execution unit.  When data required for a load instruction is not in a cache at the time the load instruction executes, a "cache miss" results.  A cache miss operation indicates that the data is not accessible from a cache memory which may be quickly accessed.  When a cache miss occurs, the processor is forced to initiate a memory request for the load data.  As previously mentioned, this memory request may take several cycles to complete.    However, before the cache miss condition is detected, issued logic already marks the instruction which depends on the load operation as "ready" for execution.  When the cache miss condition is reported, the issue logic must reset the mark made on the instruction to indicate that the instruction that depends on the load is not ready for execution.  A reset operation typically takes several cycles to perform.  This reset operation is utilized even when the execution of the load instruction is delayed by a cycle.  That is, the issue logic does not distinguish a condition that<br><br>
causes a multiple cycle delay for the data (i.e., a cache miss) from a condition which causes a single cycle delay (i.e., translation buffer access or an unaligned access).  By not distinguishing the two conditions, the issue logic forces all instructions that depend on the load that has delayed a cycle to incur the same penalty as a load operation delayed for more than one cycle, due to the reset operation.<br>
Therefore, a need exists for a mechanism in a data processing system which more efficiently utilizes the resources of the data processing system when an instruction is delayed by a minimum number of cycles.<br><br>
SUMMARY OF THE INVENTION<br>
The previously mentioned needs are fulfilled with the present invention. Accordingly, there is provided, in a first form, a data processing system.  The data processing system includes a queue for storing a plurality of instructions and a local execution cluster for executing a first one of the plurality of instructions. The local execution cluster selectively asserts a first control signal to indicate a first extended period of time is required to retrieve a first data value.  A state machine is connected to the local execution cluster for providing a second control signal to enable the local execution cluster to maintain a current state for a preselected time period when the first control signal is asserted.<br>
Additionally, there is provided, in a second form, a method for anticipating instruction execution in a data processing system.  The method includes the steps of storing of plurality of instructions in queue, executing a first one of the plurality of instructions in a local execution cluster, and selectively asserting a first control signal to indicate a first extended period of time as required to retrieve a first data value in response to execution of the first one of the plurality of instructions. Additionally, the method includes a step for providing a second control signal from a state machine to enable the local execution cluster to maintain a current state for a preselected time period when the first control signal is asserted.<br>
Furthermore, there is provided, in a third form, a program storage device readable by a machine, tangibly embodying a program of instructions executable<br><br>
by the machine to perform method steps for anticipating instruction execution in a data processing system.  The method steps include storing a plurality of instructions in a queue, executing a first one of the plurality of instructions in a local execution cluster, and selectively asserting a first control signal to indicate a first extended period of time as required to retrieve a first data value in response to execution of the first one of the plurality of instructions.  The method also includes the step of providing a second control signal from a state machine to enable the local execution cluster to maintain a current state for a preselected time period when the first control signal is asserted.<br>
These and other features, and advantages, will be more clearly understood from the following detailed description taken in conjunction with the accompanying drawings.  It is important to note the drawings are not intended to represent the only form of the invention.<br><br>
Accordingly, the present invention provides a data processing system, comprising: a queue tor storing a plurality of instructions; a local execution cluster for executing a first one of the plurality of instructions, the local execution cluster selectively asserting a first control signal to indicate a first extended period of time is required to retrieve a first data value; and circuitry coupled to the local execution cluster for providing a second control signal to enable the local execution cluster to maintain a current state for a preselected time period when the first control signal is asserted.<br>
Accordingly, the present invention also provides a method for anticipating instruction execution in a data processing system, comprising the steps of: storing a plurality of instructions in a queue: executing a first one of the plurality of instructions in a local execution cluster; selectively asserting a first control signal to indicate a first extended period of time is required to retrieve a first data value in response to execution of the first one of the plurality of instructions: and providing a second control signal to enable the local execution cluster to maintain a current state for a preselected time period when the first control signal is asserted.<br><br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
For a more complete understanding of the present invention, and the advantages thereof, reference is now made to the following descriptions taken in conjunction with the accompanying drawings, in which:<br>
FIGURE 1 illustrates, in block diagram form, a data processing system in accordance with one embodiment of the present invention;<br>
FIGURE 2 illustrates, in block diagram form, a CPU in accordance with one embodiment of the present invention;<br>
FIGURE 3 illustrates, in block diagram form, a location within a pre-execution queue of the present invention;<br>
FIGURE 4 illustrates, in partial logic diagram form, a control logic circuit in accordance with one embodiment of the present invention;<br>
FIGURE 5 illustrates, in timing diagram form, a first operation executed by the data processing system of the present invention;<br>
FIGURE 6 illustrates, in timing diagram form, a second operation executed by the data processing system in accordance with one embodiment of the present invention;<br>
FIGURE 7 illustrates, in timing diagram form, a third operation executed by the data processing system in accordance with one embodiment of the present invention; and<br><br>
FIGURE 8 illustrates, in timing diagram form, an operation executed by a prior art system.<br><br>
DETAILED DESCRIPTION<br>
The present invention implements a data processing system which indicates that an instruction does not have available data because of a cache miss or because of some other reason to an instruction issuing algorithm.   When the instruction is not able to access the available data and a cache miss results, instructions which are dependent on the issued load instruction are not issued.  However, if the load execution is delayed because of another reason, then the instructions which are dependent on the issued toad instruction are also issued in anticipation of a successful load instruction execution in the next cycle.  Through the use of this issuing mechanism, the efficiency of the data processing system is increased as an execution unit is better able to utilize its pipeline.<br>
The foregoing description provided a brief overview of operation of the present invention.  However, the following description will provide more detailed information regarding the connectivity of the elements of the present invention, as well as a more detailed description of operation of the present invention.<br>
Description of Connectivity<br>
One embodiment of the present invention is illustrated in FIGURE 1. Referring first to FIGURE 1, an example is shown of a data processing system 100 which may be used for the invention.  The system has a central processing unit (CPU) 110.  The history buffer 228 is included in CPU 110.  The CPU 110 is<br><br>
coupled to various other components by system bus 112.  Read only memory ("ROM") 116 is coupled to the system bus 112 and includes a basic input/output system ("BIOS") that controls certain basic functions of the data processing system 100.  Random access memory ("RAM") 114, I/O adapter 118, and communications adapter 134 are also coupled to the system bus 112.  I/O adapter 118 may be a small computer system interface ("SCSI") adapter that communicates with a disk storage device 120.  Communications adapter 134 interconnects bus 112 with an outside network enabling the data processing system to communication with other such systems.  Input/Output devices are also connected to system bus 112 via user interface adapter 122 and display adapter 136.  Keyboard 124, track ball 132, mouse 126 and speaker 128 are all interconnected to bus 112 via user interface adapter 122.  Display monitor 138 is connected to system bus 112 by display adapter 136.  In this manner, a user is capable of inputting to the system throughout the keyboard 124, trackball 132 or mouse 126 and receiving output from the system via speaker 128 and display 138. Additionally, an operating system such as AIX ("AIX" is a trademark of the IBM Corporation) is used to coordinate the functions of the various components shown in FIGURE 1.<br>
Preferred implementations of the invention include implementations as a computer system programmed to execute the method or methods described herein, and as a computer program product. According to the computer system implementation, sets of instructions for executing the method or methods are<br><br>
resident in the random access memory 114 of one or more computer systems configured generally as described above.  Until required by the computer system, the set of instructions may be stored as a computer program product in another computer memory, for example, in disk drive 120 (which may include a removable memory such as an optical disk or floppy disk for eventual use in the disk drive 120).  Further, the computer program product can also be stored at another computer and transmitted when desired to the user's work station by a network or by an external network such as the Internet.  One skilled in the art would appreciate that the physical storage of the sets of instructions physically changes the medium upon which it is stored so that the medium carries computer readable information.  The change may be electrical, magnetic, chemical or some other physical change.  While it is convenient to describe the invention in terms of instructions, symbols, characters, or the like, the reader should remember that all of these and similar terms should be associated with the appropriate physical elements.<br>
Note that the invention describes terms such as comparing, validating, selecting or other terms that could be associated with a human operator.  However, for at least a number of the operations described herein which form part of the present invention, no action by a human operator is desirable.  The operations described are, in large part, machine operations processing electrical signals to generate other electrical signals.<br><br>
One embodiment of the present invention is illustrated in FIGURE 2. FIGURE 2 provides a block diagram of a pipelined CPU 110 in accordance with one embodiment of the present invention.  Pipelined CPU 110 comprises an instruction fetch unit (IFU) 202, a memory subsystem (MSS) 216, an instruction dispatch unit (IDU) 222, a floating point unit (FPU) 242, and an instruction execution unit (IEU) 250.<br>
IFU 202 comprises an instruction cache 204, an instruction queue (IQ) 206, an instruction decode (Idecode) circuit 208, a condition register unit 210, and a branch (BR) unit 214.  Memory subsystem 216 comprises a second level (L2) cache 218, and a bus interface unit (BIU) 220.  Floating point unit 242 comprises a floating point unit 0 (FP0) 244, a floating point queue (FPQ) 246, and a floating point unit 1 (FP1) 248.  IEU 250 comprises a plurality of fixed-execution units, ExOE 252, ExOL 254, ExlE 256, and ExlL 258.  It should be noted that each of the execution units labeled ExOE 252 and ExlE 256 are referred to as early execution units.   Similarly, the execution units labeled ExOL 254 and ExlL 258 are referred to as the late execution units.  Additionally, IEU 250 comprises a store/complex execution unit 260, a LO load (data cache) unit 264, and a memory management unit (MMU) 262.  IEU 250 is coupled to translation shadow array (TSA) 275 and a translation look-aside buffer (TLB) 274.<br>
IDU 222 comprises a target identification (TID) generation circuit 224, a plurality of general purpose registers (GPR) 226, a history buffer 228, a pre-execution queue (PEQ) unit 230, a store/complex pre-execution queue (SPEQ)<br><br>
unit 232, and a condition register queue (CRQ) 234.  Additionally, IDU 222 comprises an interrupt handling mechanism 236, an interruptible instruction table (IIT) circuit 238, and a group identification (GID) circuit 240.  It should be noted that PEQ 230, SPEQ 232 and CRQ 234 each comprise some similar features. The foregoing discussion provides a description of connectivity of the elements utilized in implementing one embodiment of the present invention.  A description of operation of each of these elements will subsequently be provided in greater detail.  During the following description of the implementation of the present invention, the terms "assert" and "negate" and various grammatical forms thereof, are used to avoid confusion when dealing with a mixture of "active high" and "active low" logic signals.   "Assert" is used to refer to the rendering of a logic signal or register bit into its active, or logically true, state.   "Negate" is used to refer to the rendering of a logic signal or register bit into its inactive, or logically false state.<br>
Description of Operation<br>
To clearly point out novel features of the present invention, the following discussion omits or only briefly describes conventional features of information processing systems which are apparent to those skilled in the relevant art.  It is assumed that those skilled in the relevant art are familiar with superscalar processors.  In particular, it is assumed that those skilled in the art are familiar<br><br>
with processors which operate in an in-order dispatch, out-of-order execution, and in-order completion fashion.<br>
The following discussion describes a pre-execution queue utilized in a pipelined processor and circuitry used to control operation of this queue.<br>
FIGURE 1 illustrates an example of a data processing system 100 which may be used to implement one embodiment of the present invention.  Data processing system 100 has a CPU 110, which is illustrated in greater detail in FIGURE 2.  It should be noted that CPU 110 is a pipelined machine.   Specifically, CPU 110 comprises various registers, buffers, memories, and other units formed by integrated circuitry.  Furthermore, CPU 110 operates according to reduced instruction set computing (RISC) techniques.  Additionally, CPU 110 processes instructions according to processor cycles which are synchronized, in some aspects, to an internal clock (not illustrated in detail herein).<br>
During operation, instructions are processed in CPU 110 in a sequence of logical, pipelined stages, as has been previously described.  However, it should be well understood that the functions of these stages, as implemented in the preferred embodiment of the present invention, may be merged together.  Therefore, this particular division of stages should not be taken as a limitation, unless such a limitation is indicated herein.<br>
Refer now to FIGURE 2 for a description of operation of CPU 110. During operation, a memory, such as instruction cache 204 or another memory unit (not illustrated herein) provides instructions to IQ 206 in a "fetch" stage of<br><br>
operation.  From IQ 206, instructions are provided to PEQ 230 in a "dispatch" stage of operation.  PEQ 230 stores instructions and data to be sent to each of the plurality of execution units, ExOE 252, ExOL 254, ExlE 256, and ExlL 258.  It should be noted that the execution units described herein may be divided into two clusters.   A first cluster comprises execution units, ExOE 252 and ExOL 254. Furthermore, the second cluster comprises the execution units labeled ExlE 256 and ExlL 258.  Furthermore, in the first cluster, ExOE 252 is referred to as an early unit of the first cluster.  Additionally, ExlE 256 is referred to as the early unit of the second cluster.  Similarly, ExOL 254 is referred to as the late unit of the first cluster and ExlL 258 is referred to as the late unit of the second cluster.<br>
In both the first and second clusters, it should be noted that the early unit in that cluster can forward a result to the late unit in the same cluster to be used in the same cycle.  For example, an instruction executing in early execution unit ExOE 252, in cycle "n" can forward the result to late unit ExOL 254 in the same cluster, so that a dependent instruction may use that result and execute in late unit ExOL 254 in the same cycle n.   State another way, there is zero cycle forwarding in the implementation of the execution units described herein.  Additionally, the late unit in a cluster can forward a result to the early unit in the same cluster so that the result is available for execution in the early unit during the cycle after a result is generated.   Stated another way, there is one cycle forwarding within a cluster.  For example, an instruction executing in late unit ExOL 254 in cycle n can forward the result to the early unit ExOE 252 in the same cluster, so that a<br><br>
dependent instruction can use that result and execute in early execution unit, ExOE 252, in a timing cycle n+1.<br>
The early unit in a cluster (local cluster) can forward the result to the execution units in another cluster (remote cluster) so that the result is available for execution in the remote cluster during a first cycle after the result is generated. For example, an instruction executing in early execution unit ExOE 252 of the first cluster in a first timing cycle n, can forward the result to either early unit, ExlE 256 or late unit ExlL 258 of the second cluster, so that a dependent instruction can use that result and execute in either of ExlE 256 or ExlL 258 in cycle n+1.<br>
Additionally, it should be noted that the late unit in a local cluster can forward the result to the execution units of a remote cluster one cycle after the result is generated.  Therefore, there would be two-cycle forwarding between clusters.  For example, an instruction executing in late unit ExOL 254 of the first cluster in cycle n can forward the result to either early unit ExlE 256 or late unit ExlL 258 of the second cluster, so that a dependent instruction can use that result and execute in either ExlE 256 or ExlL 258 in cycle n+2.  It should be noted that all units in both the first and second clusters can forward their result to GPR 226 and PEQ 230 one cycle after the result is generated.  Furthermore, it should be noted that a load instruction can execute only in the late unit of a cluster.<br>
For all execution units and the clusters to operate efficiently, PEQ 230 must account for non-uniform forwarding of result data by each of the execution units<br><br>
within and between the clusters when scheduling instructions to be sent to each of the clusters.  In addition, PEQ 230 must schedule only instructions of operands which are available.  It should be noted, however, that out-of-order issuing is allowed.<br>
PEQ 230 must also provide a fast recovery method for recovering when a speculative execution is scheduled, but aborted.  For example, instructions may be scheduled on the assumption that a particular branch instruction will take a certain path, and instead, the branch instruction takes an alternative path.  There is also the possibility that an exception will occur between two scheduled instructions. Furthermore, PEQ 230 must only schedule certain instructions, such as load instructions into the late unit of a cluster.  Lastly, PEQ 230 must implement the above operations in a simplified manner to meet the cycle time requirements of CPU 110 and data processing system 100.<br>
During instruction queuing and issuing, PEQ 230 acts as a reservation station and holds instructions and their data to be issued to the first and second clusters of execution units.  A set of latches implements a priority array (not illustrated herein) to track the relative ages of instructions in PEQ 230.<br>
FIGURES 3 and 4 shows the fields for each entry of PEQ 230. Each entry consists of an opcode and other controls 320, RA data 322, and RB data 324. Bits that are associated with each PEQ entry are as follows:<br>
•	V: indicates whether entry is valid.<br><br>
•	L: indicates whether instruction is a load instruction.<br>
•	RT (instruction target is GPR); U: indicates whether field is valid<br>
TID: indicates target ID of GPR to which instruction will be sent. TID is the pointer to be used for operand interlock.  TID also is the instruction identifier.<br>
•	RA (instruction source is GPR):<br>
DLO, DL1: indicates whether the RA field to be accessed by the instruction is dependent on load data from cluster 0 or cluster 1, respectively.<br>
U: indicates whether field is valid<br>
W: indicates whether RA field is loaded (if RA is not used, this bit is set to 1 at dispatch).<br>
CO, CI: indicates whether operand is dependent on the instruction being executed in the late unit of the cluster (CO for cluster zero, bit CI for cluster one).  These bits are active for one cycle to steer this instruction to the unit that has the data. CD (0:1):  CO, CI bits delayed by a cycle.  PEQ uses CD to reset the* W hit if Hnta is mnri&gt;lftrt    Thftsft hits are active for one cvcle<br><br>
unless they are forced to hold their value for one cycle by state<br>
machine 274.<br>
TID:  the target ID of the GPR which will provide the necessary<br>
operand.<br>
•	RB (instruction source is GPR):<br>
DLO, DL1: indicates whether the RB field to be accessed by the<br>
instruction is dependent on load data from cluster 0 or cluster 1,<br>
respectively.<br>
U: indicates whether field is valid.<br>
W: indicates whether RB field is loaded (if RB is not used, this bit<br>
is set to 1 at dispatch).<br>
CO, CI: indicates that operand is dependent on the instruction being<br>
executed in the late unit of the cluster (CO for cluster zero, CI for<br>
cluster one).  These bits are active for one cycle to steer this<br>
instruction to the unit that has the data.<br>
CD(0:1): CO, CI bits delayed by a cycle.  PEQ uses CD to reset W<br>
bit if data is canceled.  These bits are active for one cycle unless<br>
they are forced to hold their value for one cycle by state machine<br>
274.<br>
TID: target ID of the GPR which will provide the necessary<br>
operand.<br><br>
FIGURE 4 also shows the following PEQ instruction state indicators, which are the combinations of individual bits described above to specify the state of each entry in PEQ:<br>
CI(0): indicates that instruction is dependent on the instruction being executed in a late unit 254.  This bit is the "OR" of the CO bits of the two operands.<br>
•	CI(1): indicates that instruction is dependent on the instruction being executed in the late unit 258. This bit is the "OR" of the CI bits of the two operands.<br>
•	RV: indicates that instruction is ready for execution.  This bit is the combination of the two operand available bits W queue entry valid bit V, and the two C bits (note that an instruction is not ready if it depends on operands that are being generated in both late units).<br>
LI: indicates that instruction is a load.<br>
During operation, the CI(0) value indicates that the instruction is dependent on the instruction being executed in late execution unit ExOL 254.  Similarly, the CI(1) bit indicates that the instruction is dependent on the instruction being<br><br>
executed in late execution unit ExlL 258.  The RV bit indicates that the instruction is ready for execution.  It should be noted that an instruction will not be considered "ready" if the instruction depends on operands that are being generated in both late execution units ExOL 254 and ExlL 258.  The LI bit indicates that the instruction is a load operation.<br>
By using the aforementioned bits, PEQ 230 is able to designate characteristics about each of the instructions dispatched thereto by IQ 206.  It should be noted that when IQ 206 dispatches instructions to PEQ 230, the instructions are dispatched in the order of oldest to newest and the order of all entries in PEQ 230 is marked by a priority array (not illustrated herein). Furthermore, the previously mentioned priority array is set to reflect an age of the instructions relative to other instructions in PEQ 230.<br>
Upon receipt by PEQ 230, an instruction is marked to indicate a variety of characteristics, as described above with respect to the other control data value 320, RA data value 322, and RB data value 324.  In one embodiment of the present invention, PEQ 230 marks an instruction which depends on a load by asserting the DL bit.  When the load operation or an instruction that depends on a load instruction is issued, the TID of that instruction is compared with all the TIDs of the operands in PEQ 230.  The TID of that instruction is provided by RT TID 336 of the issued instruction.  It should be noted that the TID (target identifier) is a value which is unique to the instruction and is assigned sequentially with respect to previously assigned TID values in TID generator 224.  Therefore, an instruction<br><br>
can be uniquely identified by its TID and a sequence by which the instructions are dispatched can be inferred from a comparison of the TIDs of the instructions.  It should be noted that the TID will remain associated with the assigned instruction until the instruction is completed and the TID is retired.<br>
After the TIDs are compared against all TIDs of the operands stored within PEQ 230, if the TIDs match, then the W, C, and DL bits of the matching operand within PEQ 230 is asserted.<br>
When an instruction is issued, a two bit DL field is created.  This DL field subsequently "tags" along with the instruction. This field is referred to as the "issue DL" field and is determined in the following manner.  If the issuing instruction is a load instruction, then the DL bit 0 is asserted if the load instruction is being issued to cluster 0.  The DL bit 1 is asserted if the load instruction is being issued to cluster 1.  Furthermore, DL bits of the RA and RB operands are logically OR'ed together bit by bit to form an issue DL field.  When the TID of the issuing instruction matches the TID of the RA or RB filed of an entry within PEQ 230, the issue DL field bits are copied into DLO and DL1 out of the RA or RB field of the corresponding PEQ entry.  Additionally, in this situation, the corresponding DL bits of the RA and RB operands are asserted from the issue DL field.  The issue DL field "tags" along with the instruction so that execution units may examine it to determine if the instruction should be aborted, as the corresponding load data is not available.  When a load data associated with the load instruction is not in the first Level cache, a cache miss condition has occurred.<br><br>
This cache miss condition is signalled by the execution unit negating a data valid signal for the load instruction. It should be noted that there are two valid signals, one for cluster 0 and one for cluster 1.<br>
When the valid signals from cluster 0 and cluster 1 are negated, all entries in PEQ 230 are examined for operands which have an asserted DLO bit and a COO bit pair or an asserted DL1 bit and a CD1 bit. If the above condition is satisfied, then the corresponding W bit is negated to indicate that data is not available due to a cache miss operation.  When the W bit is negated, dependent instructions will be blocked from being issued to an appropriate cluster for execution.  When a load is executed and its data is not available, but the data is predicted to be available in a next cycle, a stretched execution operation occurs.   Such a stretched execution operation will subsequently be described in greater detail.  When execution is stretched, the W bits of the dependent operands are not negated and the C bits are copied from the CD bits to indicate a cluster from which the load data will be available.  The W bit remains asserted to indicates that the dependent instruction is available for issuing to an appropriate execution unit as indicated by a corresponding C bit.<br>
It should be noted that the execution units indicate that a data retrieval operation will be "stretched" by asserting a Re-exec signal to state machine 274 of JDU 222.  The execution unit ExOL 254 provides a Re-exec 0 signal to state machine 274 and the execution unit ExlE 256 provides a Re-exec 1 signal to state machine 274.  Each of the execution units asserts a corresponding Re-exec signal<br><br>
when a load instruction is executed and the execution unit determines that the load instruction needs extra cycles to execute.   Such extra cycles are required when a load operation is not able to access its required data from translation shadow array (TSA) 275.  It should be noted that translation shadow array 275 comprises a table of previous address translations which allows an execution unit to access a real address, without performing a translation operation upon every access.  However, when an effective address does not exist in the TSA, a full translation using a translation lookaside buffer (TLB) 274 must be used.  To perform this full address translation using TLB 274, an extra cycle is required.  Therefore, when TLB 274 is utilized to perform an address translation operation, one extra cycle is required and a corresponding one of the execution units performing the load operation will assert a respective one of the Re-exec signals.  Furthermore, it should be noted that there are other conditions for which the execution of a load operation may be stretched for one or more cycles.  One example of such a condition is an unaligned load operation.<br>
Examples of handling expected data from stretched execution operations of the present invention are illustrated in each of FIGURES 5-8.  In the examples illustrated in FIGURES 5-8, assume that the following sequence is being executed by CPU 110:<br>
1.        Load instruction; and<br><br>
2.        II (Instruction which depends on the load instruction.  The instruction is stored in a first location within PEQ 230, labeled PEQ 1).<br>
FIGURE 5 illustrates a case in which a load operation executes successfully in one cycle.  The load is represented by L within FIGURE 5.  In FIGURE 5, the load instruction is issued in cycle 1, executed in cycle 2, and data is available in cycle 3.  The availability of data is indicated by the assertion of the Data Valid signal.  Furthermore, when the load instruction is issued in cycle 1, the W bit of PEQ1 is asserted in cycle 2 to indicate the data for instruction II will be available. When the W bit of PEQ1 is asserted, II may be selected or issuing.  Furthermore, the C bit in PEQ1 is asserted to indicate that instruction II is dependent on the instruction executing in cluster 0.<br>
Furthermore, the DL bit is asserted in PEQ1 of PEQ 230 to indicate that II is dependent on a load operation.  Furthermore, in cycle 3, the CD 0 bit associated with II in PEQ1 is asserted as a result of CO being asserted in a previous cycle. When CD 0 is asserted, state machine 274 is signalled to check for Load Data Valid signal provided from cluster 0.  The Load Data Valid signal is asserted when the CD 0 value is asserted to indicate that the load successfully produces data and a W bit in a first PEQ entry.  In this situation, the W bit in the first PEQ entry does not need to be negated.<br><br>
FIGURE 6 illustrates a load operation wherein the load data is not stored in the first level cache and a cache miss occurs.  The load instruction is issued in cycle 1, executed in cycle 2, and receives information that data is not available in cycle 3.  The II instruction is issued in cycle 2, but not executed in cycle 3, because the load data is not available.  Subsequently, in cycle 3, the W bit of PEQ 1 is reset, since its CD bit, which indicates that PEQ 1 is waiting for data in the unit that the load executes, is active and the data valid bit is not active.  The II instruction is reissued in cycle n and executes in cycle n+1 when data comes back from memory.<br>
FIGURE 7 illustrates the mechanism of the present invention.  In FIGURE 7, the load operation requires an extra cycle for performing a full address translation operation using TLB 274.  Additionally, it should be noted that other operations require such an extra cycle.  In FIGURE 7, a load instruction is issued in cycle 1, executed in cycle 2, and data is not available in cycle 3.  However, the Re-exec signal is active in cycle 3 to indicate that the execution unit which is executing the load instruction did not encounter a cache miss signal, but does need an extra cycle for execution.  In this case, state machine 274 provides control information to PEQ 230, so that PEQ 230 acts as if the operand data is ready and does not negate the W bit in cycle 3.   State machine 274 examines the CD bits in PEQ 230.  In this example, state machine 274 detects that CD 0 associated with II in PEQ 1 is asserted in cycle 3.  Subsequently, state machine 274 checks the Load Data Valid signal from cluster 0, which is negated.  However, the Re-exec signal<br><br>
from cluster 0 is asserted in cycle 3.  Therefore, state machine 274 directs PEQ 230 to:<br>
1.	refrain from negating the associated W bit;<br>
2.	assert the CO bit; and<br>
3.	prevent the CD 0 value from being negated.<br>
By executing these operations, state machine 274 holds the state of II in PEQ 230 to reflect that the data processing system is waiting for confirmation of valid data from the load instruction in cluster 0.  PEQ 230 reissues II in cycle 3 and II executes in cycle 4.  Additionally, it should be noted that stretching the execution of a load instruction is not restricted to one cycle.  The execution unit can stretch the execution of a load more than one cycle if it is desirable.<br>
FIGURE 8 is provided herein to illustrate a prior art result when a similar operation is executed in a data processing system, which does not have the method or apparatus of the present invention.  As illustrated in FIGURE 8, a load operation requires an extra timing cycle.  In this case, the load instruction is issued in cycle 1, executed in cycle 2, and it is determined the data is not available in cycle 3.  An II instruction is issued in cycle 2, but not executed in cycle 3, because the load data is not available.  In cycle 3, the W bit of PEQ 1 is reset, since its CD bit, which indicates that it is waiting for data in the unit that the load executes, is asserted and the data valid bit is negated.  Furthermore, the W bit of PEQ1 is active in cycle 5, as the load executed successfully in cycle 4.   The II instruction is then issued in cycle 5.  It should be noted that this adds two cycles,<br><br>
when compared to the methodology of the present invention.   In data processing systems where pipelined processing is used to reduce an amount of time required to execute instructions, a single cycle may have a significant impact on the performance of a data processing system.<br>
As has been described herein, the data processing system and methodology of the present invention improves performance of a pipelined data processing system by recognizing that the probability that a load will execute successfully in a next cycle after a TSA miss operation is very high.  Furthermore, the data processing system and methodology of the present invention improves performance of unaligned load operations.<br>
While there have been described herein the principles of the invention, it is to be clearly understood to those skilled in the art that this description is made by way of example only and not as a limitation to the scope of the invention. Accordingly, it is intended, by the appended claims, to cover all modifications of the invention which fall within the true spirit and scope of the invention.<br><br><br>
WE CLAIM:<br>
1.	A data processing system, comprising: a queue for storing a plurality of instructions; a local execution cluster for executing a first one of the plurality of instructions, the local execution cluster selectively asserting a first control signal to indicate a first extended period of time is required to retrieve a first data value; and circuitry coupled to the local execution cluster for providing a second control signal to enable the local execution cluster to maintain a current state for a preselected time period when the first control signal is asserted.<br>
2.	The data processing system as claimed in claim 1 wherein the circuitry provides a third control signal to the local execution cluster to enable the local execution cluster to terminate execution of the first one of the plurality of instructions when the first control signal is negated.<br>
3.	The data processing system as claimed in claim 1, comprising: a translation look¬aside buffer for storing a first plurality of data values; and a cache memory for storing a second plurality of data values.<br>
4.	The data processing system as claimed in claim 3 wherein the first control signal is asserted when the first one of the plurality of instructions accesses the translation look¬aside buffer.<br>
5.	The data processing system as claimed in claim 3 wherein the first control signal is negated when the first one of the plurality of instructions accesses the cache memory.<br>
6.	The data processing system as claimed in claim 1, comprising: a register for storing a write bit to indicate availability of the first data value, wherein the write bit is asserted to indicate that the first data value is available for use in execution of the first<br><br>
one of the plurality of instructions and the<br>
data value is unavailable for use in execution of the first one of the plurality of<br>
instructions.<br>
7.	The data processing system as claimed in claim 6■wherein the circuitry enables the register to maintain the write bit in a current state when the first control signal is asserted.<br>
8.	The data processing system as claimed in claim 1, comprising: a remote execution unit for executing a second one of the plurality of instructions, wherein the second one of the plurality of instructions is dependent on the first one of the plurality of instructions.<br>
?. The data processing system as claimed in claim 8, comprising: a register for storing a dependent bit to indicate when the second one of the plurality of instructions is iependent on the first one of the plurality of instructions.<br>
10. A method for anticipating instruction execution in a data processing system, ;omprising the steps of: storing a plurality of instructions in a queue: executing a first Hie of the plurality of instructions in a local execution cluster; selectively asserting a first ;ontrol signal to indicate a first extended period of time is required to retrieve a first data /alue in response to execution of the first one of the plurality of instructions; and &gt;roviding a second control signal to enable the local execution cluster to maintain a :urrent state for a preselected time period when the first control signal is asserted.<br>
1. The method as claimed in claim 10, comprising the step of: providing a third :ontrol signal to the local execution cluster to enable the local execution cluster to erminate execution of the first one of the plurality of instructions when the first control ignal is negated.<br><br>
12.	The method as claimed in claim 10, comprising the steps of: storing a first plurality<br>
of data values in a translation look-aside buffer; and storing a second plurality of data<br>
values in a cache memory.<br>
13.	The method as claimed in claim 12, comprising the step of:asserting the first control signal when the first one of the plurality of instructions accesses the translation look-aside buffer.<br>
14.	The method as claimed in claim 10, comprising the step of: negating the first control signal when the first one of the plurality of instructions accesses the cache memory.<br>
15.	The method as claimed in claim 10, comprising the steps of: storing a write bit in a register to indicate availability of the first data value; asserting the write bit to indicate that the first data value is available for use in execution of the first one of the plurality of instructions; and resetting the write bit to indicate that the first data value is unavailable for use in execution of the first one of the plurality of instructions.<br>
16.	The method as claimed in claim 15, comprising the step of: enabling the register to maintain the write bit in a current state when the first control signal is asserted.<br>
17.	The method as claimed in claim 10, comprising the step of: executing a second one of the plurality of instructions in a remote execution unit, wherein the second one of the plurality of instructions is dependent on the first one of the plurality of instructions.<br>
18.	The method as claimed in claim 17, comprising the step of:   storing a dependent<br><br>
bit in a register to indicate when the second one of the plurality of instructions is dependent on the first one of the plurality of instructions.<br>
19.	A program storage device readable by a machine, tangibly embodying a program of instructions executable by the machine to perform method steps for anticipating instruction execution in a data processing system, said method steps comprising: storing a plurality of instructions in a queue; executing a first one of the plurality of instructions in a local execution cluster; selectively asserting a first control signal to indicate a first extended period of time is required to retrieve a first data value in response to execution of the first one of the plurality of instructions; and providing a second control signal to enable the local execution cluster to maintain a current state for a preselected time period when the first control signal is asserted.<br>
20.	The method steps as claimed in claim 19, comprising the step of: providing a third control signal to the local execution cluster to enable the local execution cluster to terminate execution of the first one of the plurality of instructions when the first control signal is negated.<br>
21.	The method steps as claimed in claim 19, comprising the steps of: storing a first plurality of data values in a translation look-aside buffer; and storing a second plurality of data values in a cache memory.<br>
22.	The method steps as claimed in claim 21, comprising the step of: asserting the first control signal when the first one of the plurality of instructions accesses the translation look-aside buffer.<br>
23.	The method steps as claimed in claim 19, comprising the step of: negating the first control signal when the first one of the plurality of instructions accesses the cache memory.<br><br>
24.	The method steps as claimed in claim 19, comprising the steps of: storing a write bit in a register to indicate availability of the first data value; asserting the write bit to indicate that the first data value is available for use in execution of the first one of the plurality of instructions; and resetting the write bit to indicate that the first data value is unavailable for use in execution of the first one of the plurality of instructions.<br>
25.	The method steps as claimed in claim 24, comprising the step of: enabling the register to maintain the write bit in a current state when the first control signal is asserted.<br>
26.	The method steps as claimed in claim 19, comprising the step of: executing a second one of the plurality of instructions in a remote execution unit, wherein the second one of the plurality of instructions is dependent on the first one of the plurality of instructions.<br>
27.	The method steps as claimed in claim 26, comprising the step of: storing a dependent bit in a register to indicate when the second one of the plurality of instructions is dependent on the first one of the plurality of instructions.<br>
28.	A data processing system, substantially as herein described with reference to the accompanying drawings.<br>
29.	A method for anticipating instruction execution in a data processing system, substantially as herein described with reference to the accompanying drawings.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGFic3RyYWN0LWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">607-mas-1998 abstract-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">607-mas-1998 abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGFzc2lnbm1lbnQucGRm" target="_blank" style="word-wrap:break-word;">607-mas-1998 assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGNsYWltcy1kdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">607-mas-1998 claims-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">607-mas-1998 claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">607-mas-1998 correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGNvcnJlc3BvbmRlbmNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">607-mas-1998 correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGRlc2NyaXB0aW9uIChjb21wbGV0ZWQpLWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">607-mas-1998 description (completed)-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGRlc2NyaXB0aW9uIChjb21wbGV0ZWQpLnBkZg==" target="_blank" style="word-wrap:break-word;">607-mas-1998 description (completed).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">607-mas-1998 drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGZvcm0tMTkucGRm" target="_blank" style="word-wrap:break-word;">607-mas-1998 form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">607-mas-1998 form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGZvcm0tMjYucGRm" target="_blank" style="word-wrap:break-word;">607-mas-1998 form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGZvcm0tNC5wZGY=" target="_blank" style="word-wrap:break-word;">607-mas-1998 form-4.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IGZvcm0tNi5wZGY=" target="_blank" style="word-wrap:break-word;">607-mas-1998 form-6.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IG90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">607-mas-1998 others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA3LW1hcy0xOTk4IHBldGl0aW9uLnBkZg==" target="_blank" style="word-wrap:break-word;">607-mas-1998 petition.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="201000-a-process-for-the-manufacture-of-an-inorganic-organic-composite-membrane.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="201002-a-process-of-preparing-a-resin-composition-for-optical-fiber-loose-tubes.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>201001</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>607/MAS/1998</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>30/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>24-Jul-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td></td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>24-Mar-1998</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTERNATIONAL BUSINESS MACHINES CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>ARMONK, NEW YORK 10504.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>HOICHI CHEONG</td>
											<td>6104 SIERRA ARBOR COURT, AUSTIN, TEXAS 78759</td>
										</tr>
										<tr>
											<td>2</td>
											<td>PAUL JOSEPH HORDAN</td>
											<td>2003 PAYNE AVENUE, AUSTIN, TEXAS 78757</td>
										</tr>
										<tr>
											<td>3</td>
											<td>HUNG QUI LE</td>
											<td>16310 DORMAN DRIVE, AUSTIN, TEXAS 78717</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F9/06</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>08/840,921</td>
									<td>1997-04-25</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/201001-data-processing-system-and-method-for-anticipating-instruction-execution by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 02:41:44 GMT -->
</html>
