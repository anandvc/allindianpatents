<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/227973-a-method-for-receiving-and-handling-requests-from-a-client-application-to-a-server-resource by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:30:19 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 227973:A METHOD FOR RECEIVING AND HANDLING REQUESTS FROM A CLIENT APPLICATION TO A SERVER RESOURCE</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD FOR RECEIVING AND HANDLING REQUESTS FROM A CLIENT APPLICATION TO A SERVER RESOURCE</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>An embodiment of the invention provides an ability to configure the dispatch policy in an application or transaction server. For servlets and JSP&#x27;s this is configured on a per-URL (Uniform Resource Locator) basis, RMI and Ern it is configured on a per-method basis. Available dispatch options include the ability to execute the request in the same thread that read the request or to enqueue it on a queue which feeds a pool of worker threads. Using this configuration one can control various quality of service parameters of the requests. Requests may be expedited by executing them directly in the thread which read them, thus skipping the queue. Alternatively, some requests may be throttled by assigning them to a queue which is tended by only a limited number of threads.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
SYSTEM FOR APPLICATION SERVER MESSAGING WITH MULTIPLE DISPATCH POOLS<br>
COPYRIGHT NOTICE A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.<br>
Claim of Priority:<br>
[0001]	This application claims priority from provisional application<br>
"SYSTEM FOR APPLICATION SERVER MESSAGING WITH MULTIPLE DISPATCH POOLS", Application No. 60/327,543, filed October 5, 2001, and incorporated herein by reference.<br>
Field of the Invention:<br>
[0002]	An embodiment of the invention relates generally to<br>
application and transaction servers and particularly to a system for supporting message queuing and threads with multiple dispatch pools.<br>
Cross References:<br>
[0003]	This application is related to Provisional Patent Application<br>
"SYSTEM FOR APPLICATION SERVER MESSAGING WITH ASYNCHRONOUS QUEUES", Application Number 60/327,530, Inventors: Adam Messinger and Don Ferguson, filed October 5, 2001<br><br>
and Utility Patent Application "SYSTEM FOR INTEGRATING JAVA SERVLETS   WITH   ASYNCHRONOUS   MESSAGES",   Application<br>
Number, Inventors: Adam Messinger, Sam Pullara and Dave<br>
Brown, filed October 3, 2002 both applications are incorporated by reference herein.<br>
Background:<br>
[0004]	The   Java   2   Platform,    Enterprise    Edition   (J2EE)<br>
specification, developed by Sun Microsystems, Inc., in collaboration with leaders from throughout the enterprise software arena, defines one of the current standards for developing multi-tier enterprise applications. J2EE provides a component-based approach to the design, development, assembly, and deployment of enterprise applications, which both reduces the cost and enables fasten design and implementation. The J2EE platform gives the developer a multi-tiered distributed application model, the ability to reuse components, a unified security model, and flexible transaction control. Not only can they deliver innovative customer solutions to market faster than ever, but the resultant platform-independent J2EE component-based solutions are not tied to the products and application program interfaces (APIs) of any one vendor.<br>
[0005]	The J2EE specification defines the following kinds of<br>
components: application client components; Enterprise JavaBeans (EJB); servlets and Java Server Pages (JSP) (also called Web components); and applets. A multi-tiered distributed application model implies that the application logic is divided into components according to function, and different application components may make up a J2EE<br><br>
application on the same or different servers. Where an application component is actually installed depends on which tier in the multi-tiered J2EE environment the application component belongs. These tiers are depicted in Figure 1. As shown therein an application server tier 104 is used to develop EJB containers and/or presentation containers such as servlets, JSP, and html pages 114. These in turn are used as an interface between a client tier 102, where the clients 108 and client applications are deployed, and a backend tier 106, used for hosting enterprise or legacy applications such Enterprise Resource Planning (ERP) systems.<br>
[0006]	Client tier-These can be browsers, Java-based programs,<br>
or other Web-enabled programming environments running within the<br>
client tier, both inside and outside of corporate firewalls.<br>
[0007]	Application  Server tier -  Normally this tier hosts a<br>
combination of presentation logic and business logic to support client<br>
requests. Presentation logic is supported via JSP pages and servlets<br>
that display HTML pages, while business logic is supported via Remote<br>
Method Invocation (RMI) objects and EJBs 112. EJBs rely upon the<br>
containerenvironmentfortransactions, lifecycle and state management,<br>
resource pooling, security, etc., which together make up the run time<br>
environment in which the beans are executed.<br>
[0008]	Back-end tier - This is generally a combination of existing<br>
applications and data stores. It is also referred to as the Enterprise Information Systems (EIS) tier, since it may include such systems as Enterprise Resource Planning (ERP), mainframe transaction processing, database systems, and other legacy information systems.<br><br>
[0009]	Since  the  components   of  a   J2EE   application   run<br>
separately, and often on different devices, there needs to be a way for client and application server tier code to look up and reference other code and resources. Client and application code can, for example, use the Java Naming and Directory Interface (JNDI) 116 to look up user-defined objects such as enterprise beans, and environment entries such as the location of the Java Database Connector (JDBC) DataSource objects, which in turn are used for looking up resources in backend tier, and message connections.<br>
[0010]	Application behavior such as security and transaction<br>
management can be configured at deployment time on Web and<br>
enterprise bean components. This deployment time feature decouples<br>
application logic from the configuration settings that might vary with the<br>
assembly. The J2EE security model lets a developer configure a Web<br>
or enterprise bean component so that system resources are accessed<br>
only by authorized users. For example, a Web component can be<br>
configured to prompt for a user name and password. An Enterprise<br>
Bean component can be configured so that only persons in specific<br>
groups can invoke certain kinds of its methods. Alternatively, a servlet<br>
component might be configured to have some of its methods accessible<br>
to everyone, and a few methods accessible to only certain privileged<br>
persons in an organization. The same servlet component can be<br>
configured for another environment to have all methods available to<br>
everyone, or all methods available to only a select few.<br>
[0011]	Some application servers, such as the WebLogic Server<br>
product from BEA Systems, Inc., San Jose, California, use an Access Control List (ACL) mechanism that allows for fine-grained control of the<br><br>
usage of components running on the server. Using an ACL, a developer can define at the Java Method level what can, or cannot, be executed by which user or group of users. This ACL mechanism covers anything that runs on the application server except for EJBs, which have their own access control mechanism defined in the EJB specification. Security realms allow the administrator to import information from existing authorization or authentication systems into the ACL.<br>
Java Servlets<br>
[0012]	A servlet is a program that extends the functionality of a<br>
Web server. A servlet receives a request from a client, dynamically generates the response (possibly querying databases to fulfill the request), and then sends the response containing an HTML or XML document to the client. Servlets are similar to CGI but are typically easier to write, since servlets use Java classes and streams. They execute faster because servlets are compiled to Java byte code and at run time the servlet instance is kept in memory, each client request spawning a new thread. Servlets make it easy to generate data to an HTTP response stream in a dynamic fashion. Each client request is performed as a new connection, so flow control does not come naturally between requests. To allow for this session management maintains the state of specific clients between requests. In some application servers, servlets make use of the HTTP session object to save their state between method requests. This object can be replicated in a clustered environment for failover purposes.<br><br>
Java Server Pages<br>
[0013]	JSP pages are a text-based, presentation-centric way to<br>
develop servlets. JSP pages offer all the benefits of servlets, and when combined with a JavaBeans class, provide an easy way to keep content and display logic separate. Both JSP pages and servlets are more desirable than Common Gateway Interface (CGI), because they are platform-independent, and use less overhead. JSP pages can be used with JavaBeans classes to define Web templates for building a Web site made up of pages with a similar look and feel. The JavaBeans class performs the data rendering, so the templates have no Java code. This means they can be maintained by an HTML editor. Simple Web-based application using a JSP page can be used to bind content to application logic using custom tags or scriptlets instead of a JavaBeans class. Custom tags are bundled into tag libraries that are imported into a JSP page. Scriptlets are small Java code segments embedded directly in the JSP page.<br>
Database Access Services (JDBC)<br>
[0014]	JDBC acts as a bridge to relational databases, and is<br>
modeled on the ODBC (Open Database Connectivity) specification. It decouples the database from the program code through the use of drivers. Some implementations of JDBC provide support for advanced data types, and also support the functionality of scrollable result sets and batch updates.<br><br>
Java Messaging Services (JMS)<br>
[0015]	JMS  is the J2EE  mechanism  used to  support the<br>
exchange of messages between Java programs. This is how Java<br>
supports  asynchronous communication,  wherein the  sender and<br>
receiver don't need to be aware of each other and thus can operate<br>
independently. JMS currently supports two messaging models:<br>
[0016]	Point to point - which is based on message queues. In this<br>
model message producer sends a message to a queue. A message consumer can attach itself to a queue to listen for messages. When a message arrives on the queue, the consumer takes it off the queue and responds to it. Messages can be sent to just one queue and will be used by just one consumer. Consumers have the option to filter messages to specify the exact message types they want.<br>
[0017]	Publish and subscribe - which allows producers to send<br>
messages to a topic and for all the registered consumers for that topic to retrieve those messages. In this case, many consumers can receive the same message.<br>
Java IDL and Multi-Threaded Servers<br>
[0018]	In the CORBA world, attempts have been made to allow<br>
CORBA objects to use an Interface Definition Language (IDL) to specify a contract, i.e., how they are going to interact with other objects. With Java IDL, contracts may be defined between the Java world and the CORBA world. Starting with Sun!s Java Development Kit (JDK) Version 1.2, an Object Request Broker (ORB) allows Java applications to invoke remote CORBA objects via the Internet InterORB (HOP) protocol. In a multi-threaded CORBA server, event queues provide a method for<br><br>
implementing threading policies on that CORBA server. In practice the event queues support the desired threading policy for CORBA requests, and integrate the processing of non-CORBA events within the threading policy. A multi-threaded CORBA server, such as the Orbix server from lona Software, can for example implement policies which determine how many threads are created, when those threads are created, and which requests are handled by which threads. Implementing a particular policy typically involves creating a number of queues and worker threads and programming a logic to determine which queue to use for each incoming event.<br>
[0019]	Multi-threaded CORBA servers can thus process several<br>
CORBA requests concurrently.   One primary advantage of this is to<br>
increase overall throughput. Threading policies can be customized for<br>
different needs, depending on how the work of handling requests should<br>
be shared between them. These options include the following:<br>
[0020]	One thread per operation: In this scenario a new thread is<br>
created to handle  each incoming  request. This option provides<br>
maximum concurrency, but sometimes creates too many threads if the<br>
server receives a large number of concurrent requests at peak load.<br>
[0021]	Use of a thread pool: In this scenario requests are queued<br>
and handled by the first available thread in a pool of threads. The maximum number of threads, and hence the server load, is restricted by limiting the size of the pool.<br>
[0022]	One thread per object: Following this option one or more<br>
request queues are maintained for each object. This option provides full concurrency between objects but serializes access to each individual object.<br><br>
[0023]	One thread per client: A request queue is maintained for<br>
each client. This option ensures equal treatment of clients, by controlling the number of thread resources allocated to each.<br>
Threading in J2EE Servers<br>
[0024]	One problem with current threading policies as used in<br>
J2EE-based transaction and application servers is the concept or<br>
prioritization of requests. Although threading policies can be designed<br>
for maximum throughput in terms of request management these are few<br>
options in terms of request prioritization. Many current server products<br>
use a pool of threads for reading requests from clients from the network.<br>
Once a complete request is read into the queue it must be dispatched<br>
for execution in the server. But there is little to allow a developer to<br>
prioritize the complete requests prior to dispatch.<br>
[0025]	Prioritization of requests is a commonly desired feature,<br>
but is difficult to implement because of concerns about the complexity it adds to the underlying server code and because of new problems, such as priority inversion, which it can create. The addition of multiple queues would provide the software administrator or developer with a priority mechanism that manages these concerns better than a true priority scheme would.<br>
[0026]	Throttling  of requests  is another feature commonly<br>
requested by application server customers. This is commonly requested where part of the workload requires a large amount of memory, CPU time, or other resource. The system can not process many of these requests simultaneously.<br><br>
[0027]	Many application servers provide dispatch options that<br>
allow a request to execute in the same thread that read the request or to enqueue it on a queue which feeds a pool of worker threads. Using this configuration one can control various quality of service parameters of the requests. For instance requests may be expedited by executing them directly in the thread which read them thus skipping the queue. Alternately some requests may be throttled by assigning them to a queue which is tended by only a limited number of threads.<br>
Summary:<br>
[0028]	To address these demands an embodiment of the<br>
invention provides a system or mechanism for use with an application<br>
server, that enhances the servers threading model, i.e. the policy by<br>
which threads are assigned to perform work requests. Embodiments of<br>
the invention can be used with a wide range of application servers,<br>
including, for example, the WebLogic Server product from BEA<br>
Systems, Inc., San Jose, California. An application server, or any<br>
server, designed to use an embodiment of the invention employs a<br>
threading model which uses multiple thread pools - including an<br>
asynchronous pool (sometimes referred to as reader threads) and a<br>
synchronous pool (referred to as execute threads). This combination of<br>
pools allows the system to prioritize requests. The design also<br>
successfully tolerates user code that performs blocking operations.<br>
[0029]	In one embodiment of the invention, the asynchronous<br>
thread pool waits on an asynchronous input mechanism (referred to herein as a multiplexor, or muxer) for asynchronous read results to become available. Once a result is available, a thread from the pool<br><br>
looks at the message and dispatches it by making the appropriate callbacks. The dispatch callbacks usually queue the request for later processing by the synchronous thread pool. However, certain non-blocking, priority requests are services directly in the callback. By aggressively accepting input, these high priority requests do not wait to be read while lower priority requests run.<br>
[0030]	The synchronous thread pool waits on a queue of<br>
requests. Once a request is available a thread from the synchronous<br>
pool takes the request from the queue, processes it, and sends out the<br>
result. While processing the request, the thread may execute code, such<br>
as sending out the result, which causes the thread to block.<br>
[0031]	The addition of asynchronous output and asynchronous<br>
responses alleviates some of the need for thread process tuning, which is a common task in traditional systems. In addition, an embodiment of the invention allows for configuration of multiple synchronous thread pools so as to provide more fine-grained control over the processing of different request types.<br>
[0032]	An embodiment of the invention also supports the ability<br>
to provide multiple execute queues within a single server. These queues are individually similar to current execute queues. Each execute queue has a pool of worker threads assigned to pulling work from the queue. In accordance with one embodiment of the invention, each server has one default execute queue and either zero, or one or more, custom execute queues. The addition of multiple queues provides several benefits over traditional systems, including support for prioritization, throttling of requests and reduced queue contention. Queues can be independently allocated for high priority and low priority requests. The<br><br>
system administrator can then tune the number of threads assigned to these queues until the required throughput for each class of work is achieved.<br>
Brief Description of the Figures:<br>
[0033]	Figure 1 shows an illustration of a J2EE compatible server<br>
architecture that can utilize an embodiment of the present invention.<br>
[0034]	Figure 2 shows a threading model in accordance with an<br>
embodiment of the invention.<br>
[0035]	Figure 3 shows an illustration of a multiple dispatch queue<br>
system in accordance with an embodiment of the invention.<br>
[0036]	Figure 4 shows an illustration of a multiple thread dispatch<br>
system in accordance with an embodiment of the invention.<br>
[0037]	Figure 5 shows a flowchart of a multiple dispatch process<br>
in accordance with an embodiment of the invention.<br>
Detailed Description:<br>
[0038]	Broadly described, an embodiment of the invention<br>
provides extensions for a flexible dispatch policy system for use with transaction, application and messaging servers, and particularly for use with RMI (Remote Method Invocation), EJB (Enterprise Java Bean) and Servlets. An application server transaction server, or messaging server (all commonly hereinafter simply referred to as application server), that incorporates an embodiment of the invention uses a pool of threads for reading requests from clients from the network. Once a complete request is read, it must be dispatched for execution in the server. An embodiment of the invention provides the ability to configure this<br><br>
nspatcn policy, hor serviets tnis is configured on a per-UKL (uniTorm Resource Locator) basis. For RMI and EJB the dispatch policy is configured on a per method basis.<br>
'0039]	Dispatch options provided by an embodiment of the<br>
nvention allow the request to be executed in the same thread that read he request, or alternatively to be enqueued on a queue which feeds a )ool of worker threads. Using this variable dispatch configuration one can control various quality of service parameters of the requests. For example, requests may be expedited by executing them directly in the hread which read them, thus skipping the queue. Alternately some 'equests can be throttled by assigning them to a queue which is tended by only a limited number of threads.<br>
|0040]	An embodiment of the invention provides new features<br>
elated to application server messaging but which can be used with any<br>
server type that requires messaging of some sort. At the core of every<br>
server's design is the threading model, the policy by which threads are<br>
assigned to perform work requests. In accordance with an embodiment<br>
Df the invention, the server employs a threading model which uses two<br>
hread pools an asynchronous pool (reader threads) and a synchronous<br>
)ool (execute threads). This combination of pools and flexibility in<br>
jispatch options allows an administratorto effectively prioritize requests,<br>
vhile tolerating user code that performs blocking operations.<br>
0041]	Figure 2 shows an illustration of a thread pool 206 as<br>
provided by an embodiment of the invention that is used to pass equests to a server resource 205. The server includes configuration nformation for each resource that determines the dispatch policy 211 to be used with a particular resource.    In accordance with one<br><br>
embodiment, the asynchronous thread pool 208 waits on an asynchronous input mechanism 202 (sometimes referred to as a muxer) for asynchronous read results to become available. Once a result is available, a thread from the pool looks at the message and dispatches it by making the appropriate callbacks. The dispatch callbacks usually queue the request for later processing by a synchronous thread pool. However certain non-blocking, priority requests are serviced directly in the callback. By allowing the asynchronous thread pool to aggressively accepting input, high priority requests 212 do not wait to be read while low priority requests 216 run. Since these threads should never block there are usually a low number of them, perhaps only one per CPU. Embodiments of the invention additionally provide the ability for the asynchronous thread pool to perform network output operations. This particular feature is described in more detail in Provisional Patent Application "SYSTEM FOR APPLICATION SERVER MESSAGING WITH ASYNCHRONOUS QUEUES", Application Number 60/327,530, Inventors: Adam Messinger and Don Ferguson, filed October 5, 2001 and Utility Patent Application "SYSTEM FOR INTEGRATING JAVA SERVLETS   WITH   ASYNCHRONOUS   MESSAGES",   Application<br>
Number	, Inventors: Adam Messinger, Sam Pullara and Dave<br>
Brown, filed October 3, 2002 both applications are incorporated by reference herein..<br>
[0042]	As shown in Figure 2, the synchronous thread pool 210<br>
waits on a queue of requests 204. Once a request is available, a thread from the pool takes the request from the queue, processes it, and sends out the result 216 to the resource 205. While processing the request the thread may execute code, such as sending out the result, which causes<br><br>
the thread to block. The number of threads should therefore be tuned so that there is always one thread per CPU that is in the runnable state. Appropriate tuning of a server is important for performance reasons. The addition of asynchronous output and asynchronous responses as used in an embodiment of the invention alleviates some of the need for this tuning. An embodiment of the invention also provides an administrator until the ability to configure multiple synchronous thread pools so as to provide more fine-grained control over the processing of different request types.<br>
Dispatch<br>
[0043]	Dispatch is the process of taking a server request and<br>
passing it to the appropriate place to be serviced. In an application server or server that may use an embodiment of the invention, there are typically two types of dispatch, direct dispatch and queued dispatch. The server request may be any signal from the server including for example the result of input read from the network, a time trigger, or the continuation of some other piece of work.<br>
[0044]	In  direct dispatch,  the thread which  generated  the<br>
incoming message also processes that message. The dispatching thread is not replaced with another thread while it is processing the request so it is important that the work to be performed will not block the dispatching thread for any significant amount of time. For example if socket readerthreads are blocked servicing requests then the server will not be able to handle any new incoming messages and will be unresponsive to further input. Similarly if time trigger threads are blocked then important timing events in the server will not be delivered.<br><br>
For this reason direct dispatch is typically made available through<br>
internal APIs, and is used only for high-priority system-level messages.<br>
[0045]	Figure 3 shows a traditional execute queue mechanism.<br>
As shown therein, a request from the client directed to a particular<br>
resource, such as a Uniform Resource Locator (URL) or a database, is<br>
queued on an execute queue 304. A set of one or more worker threads<br>
306, 308 or thread processes retrieve the entries 310 from the queue<br>
and execute them against the resource, returning the result to the client.<br>
The problem with this mechanism is that the queue operates on a first<br>
in / first out manner, and there is no way to prioritize particular entries so<br>
as to process one entry in the queue before another.<br>
[0046]	In queued dispatch, the dispatching thread puts the<br>
incoming message on a queue where it will later be dequeued and serviced by a worker thread. In some embodiments there is only one execute queue, and one pool of execute threads assigned to dequeue and service requests from that queue. Other embodiments can use multiple execute queues. The queue length may be bounded or unbounded, although when the queue length is unbounded care must be taken to prevent problems with memory usage. Typically all user requests are dispatched to a queue rather than directed.<br>
Multiple Queues<br>
[0047]	Figure 4 shows how multiple queues provided by an<br>
embodiment of the invention are used to build a dispatch policy. As shown in Figure 4, requests from the client are passed to a queue socket selected from a plurality of queue sockets 402, 404, 406. The sockets operate in parallel, allowing entries on one socket to be<br><br>
performed at the same time, or prior to, those in another socket. This separate and parallel operation allows the system to prioritize the requests. A set of one or more asynchronous threads 412,414,416 are used to service the socket requests and to provide access to the resource. Groups of asynchronous threads (e.g. 412 and 414) can be shared between groups of sockets (e.g. 404 and 406). Alternatively, a socket 402 may have a dedicated thread 416, to allow for reliable or high priority servicing of the particular requests within that socket. Application servers embodying or incorporating an embodiment of the invention support the ability to have multiple execute queues in a single server. Typically, each execute queue has a pool of worker threads assigned to pulling work from the queue. In one embodiment each server has one default execute queue, and either zero or one or more custom execute queues. The addition of multiple queues provides several benefits, including support for prioritization, throttling of requests and reduced queue contention.<br>
Request Prioritization<br>
[0048]	As  described  above,  prioritization  of requests  is  a<br>
commonly desired feature. Traditionally this was a difficult area to address because of concerns about the complexity it might add to the underlying code, and because of additional problems, such as priority inversion, which it could create. As used in an embodiment of the invention, the addition of multiple queues provides a priority mechanism that manages these concerns better than a "true" priority scheme would. If the administrator so desires then queues can be independently allocated for high priority and low priority requests. The administrator<br><br>
can then tune the number of threads assigned to these queues until the required throughput for each class of work is achieved.<br>
Request Throttling<br>
[0049]	Throttling of requests is a feature commonly requested by<br>
application server users. Throttling is important in those instances where part of the workload requires a large amount of memory, CPU time, or other resource. Typically the system can not process many of these requests simultaneously. An embodiment of the invention provides mechanisms for request throttling in that all of these types of requests can be sent to a queue which is configured with the proper amount of threads to ensure that system resources are conserved.<br>
Reduction in Queue Contention<br>
[0050]	Queue contention is a problem in benchmarks of heavily<br>
loaded systems serving multiple short requests. An embodiment of the invention provides a mechanism to successfully tackle this problem by spreading the workload out over several queues, queue contention can be reduced. Requests be distributed across the queues in such a manner as to maximize throughput.<br>
[0051 ]	Figure 5 shows a flowchart of the multiple queue dispatch<br>
policy in accordance with an embodiment of the invention. As shown therein, in step 502, a request to access a particular resource is received by the server. This may be a request to access, for example, a particular service, a URL, or a database. In step 504, a dispatch thread places the request on one of the multiple message queues or sockets. The combination of providing a default execute queue, and<br><br>
multiple customer execute queues, allows, in step 506, the system or system administrator the ability to prioritize the request, by specifying which socket or queue it should be placed in. In step 508, a worker thread retrieves the request from the appropriate message queue, and, in step 510, the request is processed at the server, and the result returned to the client.<br>
RMI and HTTP Implementation<br>
[0052]	In accordance with one embodiment of the invention a<br>
typical Remote Method Invocation (RMI) implementation is adapted to<br>
take advantage of multiple queues. The RMI descriptor is generalized<br>
to allow a per-method queuing policy to be set. This functionality<br>
provides a mechanism to specify direct or queued dispatch. In one<br>
embodiment for use with Java Virtual Machines (JVM's), a<br>
RequestDispatcher message is dispatched to the RJVM level. The<br>
RJVM then queries its RuntimeDescriptor and determines which<br>
dispatch policy should be applied to the request.<br>
[0053]	Adapting a servlet implementation to take advantage of<br>
multiple queues can be similarly performed. In one embodiment the meta data describing the dispatch policy can be placed in the servlet's deployment descriptor. The point at which requests are normally queued is to a point where the servlet to be invoked has been determined. At this point the appropriate dispatch policy can be determined, and appropriate action taken. HTTP tunneling mechanisms can also be modified to use this mechanism. In some implementations, timing services may be adapted to take advantage of the multiple queues. Additions to any API may also be made to allow the specification of the<br><br>
dispatch policy for a particular timer. This can be integrated with current direct dispatch mechanisms that services the trigger directly in the timing thread.<br>
[0054]	In  a   particular application  server,   several     internal<br>
implementations use queued dispatch to process work ancillary to the request currently being processed. This is often done to prevent holding locks longer than necessary, but with the addition of multiple queues can also be used to differentiate between priorities of work by queuing the ancillary request in a different queue.<br>
[0055]	Additionally many customers have requested the ability to<br>
perform this same queued dispatch of ancillary requests. In one embodiment the invention allows users to queue a java.lang.Runnable function on a specified queue. This Runnable is then wrapped in an ExecuteRequest and placed on the desired queue.<br>
Configuring Execute Queues &amp; Thread Pools<br>
[0056]	To allow configuration of the execute queues and thread<br>
pools, an embodiment of the invention provides a set of commands and syntaxes. The following section provides a guide to configuring servlets, jsps, ejbs, and rmi objects to use these pools in accordance with one embodiment of the invention. It will be evident that an embodiment of the invention is not limited to the particular implementations described below which are given for purposes of illustration, but instead can be used with other implementations and with other application servers or servers.<br><br>
Configuring Execute Queues<br>
[0057]	In the server configuration (for example the config.xml file),<br>
the developer can define the set of ExecuteQueues via an "ExecuteQueues" tag in the Server configuration, e.g.:<br><br>
[0058]	The example shown above would result in the creation of<br>
an execute queue named testqueue, with an associated pool of four (4) execute threads.<br>
Configuring a Serviet to use an ExecuteQueue<br>
[0059]	To configure a serviet, the developer or administrator can<br>
use the serviet init parameters to set the queue name, for example via the tag "wl-dispatch-policy" in systems that use web.xml files for configuration. The web.xml file contains an init-param section like the exemplary one shown below:<br><br><br><br>
Priorities and Quality of Service<br>
[0062]	Some embodiments of the invention allow for setting the<br>
priority of threads within a particular thread pool. In accordance with one embodiment of the invention however no mechanism is provided to allow the configuration to set the priority of the threads in the pool. This is intentional since the semantics of thread scheduling varies between platforms, and the system is less likely to run into starvation/priority inversion problems if all execute threads have the same priority. However, one can still dispatch high-priority traffic to a lightly used queue, or to one with a larger number of execute threads, and achieve the goal of servicing high priority requests faster without explicit use of<br><br>
thread priorities.<br>
[0063]	A topic closely related to prioritization is quality of service<br>
(QOS). Using the dispatch policy one can guarantee a certain type of request will have a certain number of threads. This can be useful if there are some types of requests which must continue to be processed at a fixed rate, regardless of any other load on a machine.<br>
Deadlock Avoidance<br>
[0064]	A good reason to use a separate execute queue is to<br>
avoid deadlock conditions. When the servicing of a request requires additional execute requests to complete, a separate queue can be configured for the additional requests. For example, consider the situation in which a servlet "a" reads from a JMS queue "b". If all of the server's execute threads are executing servlet "a", then there will be no execute threads left to deliver messages from queue "b", so none of the work can progress. This situation can be avoided by defining a separate queue for servlet "aH.<br>
Throttling and optimizing throughput<br>
[0065]	Another good reason to use a separate queue is to throttle<br>
requests which use some fixed pool of resources. For example, if a<br>
particular job uses a lot of memory it may be more optimal to dispatch<br>
it to a queue with a limited number of associated threads. In this way<br>
the system can limit the maximum number of jobs of this type which are<br>
running simultaneously, and minimize any risk of the server running out<br>
of memory.<br>
[0066]	A related use is to separate those requests which require<br><br>
access to a resource from one particular pool, from those requests in another pool which don't require access. For example, consider a case where a server is serving two EJBs. EJB 'a' uses a connection pool to access a database, while EJB 'b' performs only some in-memory work (or perhaps uses a different pool.) If the number of threads is greater than the number of connections in the pool, then the system may encounter a situation wherein several threads are blocked trying to get a connection from the pool while processing requests for 'a'. At the same time there may be other requests for 'b' sitting in the queue which could proceed if only there were free execute threads. By dispatching 'a1 and 'b' requests to different queues one can avoid this situation.<br>
Performance Considerations<br>
[0067]	Having multiple execute queues is a very powerful tool, but<br>
should be used or configured with care. Some of the things the administrator should consider include:<br>
Wasteful use of resources: Because each queue is assigned a fixed number of threads it is possible to have many threads doing nothing while requests on other queues sit idle. Threads are not cheap resources, so allocating extra threads should be avoided.<br>
Livelocks and priority inversion: While judicious use of separate queues can reduce the chance of deadlocks as explained above, they also introduce a new class of possible problems which can be quite difficult to debug. As a trivial example it is possible that two remote calls made from the same client to the same server, but dispatched to separate queues, will return in a different order than anticipated.<br><br>
[0068]	The foregoing description of the present invention has<br>
been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Obviously, many modifications and variations will be apparent to the practitioner skilled in the art. The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalence.<br><br><br><br>
Claims:<br>
What is claimed is:<br>
1.	A system for receiving and handling requests from a client<br>
application to a server resource, comprising:<br>
a server request interface for that receives requests from a client to access a server resource;<br>
a plurality of execute queues, configured to queue requests for access to the server resource; and,<br>
a dispatch policy configured on a per-resource basis to queue specific requests on a selected one of said queues.<br>
2.	The system of claim 1 wherein the request specifies a quality of<br>
service to be provided to the client application in accessing the<br>
resource.<br>
3.	The system of claim 1 wherein threads are used to service the<br>
queues.<br>
4.	The system of claim 1 wherein multiple queues can be configured for each resource in a configuration file.<br>
5.	The system of claim 1 wherein the server specifies by the dispatch policy either direct dispatch or queued dispatch.<br>
6.	The system of claim 1 wherein the resource is a servlet.<br><br>
7.	The system of claim 1 wherein the resource is a Java Servlet<br>
Page.<br>
8.	The system of claim 1 wherein the resource is associated with a particular queue name.<br>
9.	The system of claim 1 wherein each queue has a plurality of associated threads, the number of which threads can be configured to allow for prioritization of requests associated with that queue.<br>
10.	The system of claim 1 wherein the plurality of execute queues uses an asynchronous thread pool and a synchronous thread pool.<br>
11.	A method for receiving and handling requests from a client application to a server resource, comprising the steps of:<br>
receiving requests from a client to access a server resource;<br>
queuing the request on one of a plurality of execute queues, that can be configured to queue requests for access to the server resource, in accordance with a dispatch policy that can be configured on a per-resource basis to queue specific requests on a selected one of said queues.<br>
12.	The method of claim 11 wherein the request specifies a quality<br>
of service to be provided to the client application in accessing the<br>
resource.<br><br>
13.	The method of claim 11 wherein threads are used to service the<br>
queues.<br>
14.	The method of claim 11 wherein multiple queues can be configured for each resource in a configuration file.<br>
15.	The method of claim 11 wherein the client application specifies either direct dispatch or queued dispatch.<br>
16.	The method of claim 11 wherein the resource is a servlet.<br>
17.	The method of claim 11 wherein the resource is a Java Servlet<br>
Page.<br>
18.	The method of claim 11 wherein the resource is associated with a particular queue name.<br>
19.	The method of claim 11 wherein each queue has a plurality of associated threads, the number of which threads can be configured to allow for prioritization of requests associated with that queue.<br>
20.	The method of claim 11 wherein the plurality of execute queues uses an asynchronous thread pool and a synchronous thread pool.<br><br>
21.	A system for receiving and handling requests from a client application to a server resource, substantially as herein described with reference to the accompanying drawings.<br>
22.	A method for receiving and handling requests from a client application to a server resources, substantially as herein described with reference to the accompanying drawings.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQgYWJzdHJhY3QgZ3JhbnRlZC5wZGY=" target="_blank" style="word-wrap:break-word;">955-chenp-2004 abstract granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQgY2xhaW1zIGdyYW50ZWQucGRm" target="_blank" style="word-wrap:break-word;">955-chenp-2004 claims granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQgZGVzY3JpcHRpb24gKGNvbXBsZXRlKSBncmFudGVkLnBkZg==" target="_blank" style="word-wrap:break-word;">955-chenp-2004 description (complete) granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQgZHJhd2luZ3MgZ3JhbnRlZC5wZGY=" target="_blank" style="word-wrap:break-word;">955-chenp-2004 drawings granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQgZm9ybSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">955-chenp-2004 form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQgcGV0aXRpb24ucGRm" target="_blank" style="word-wrap:break-word;">955-chenp-2004 petition.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQgcG93ZXIgb2YgYXR0b3JuZXkucGRm" target="_blank" style="word-wrap:break-word;">955-chenp-2004 power of attorney.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">955-chenp-2004-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQtY29ycmVzcG9uZG5lY2Utb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">955-chenp-2004-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQtY29ycmVzcG9uZG5lY2UtcG8ucGRm" target="_blank" style="word-wrap:break-word;">955-chenp-2004-correspondnece-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQtZGVzY3JpcHRpb24oY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">955-chenp-2004-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">955-chenp-2004-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQtZm9ybSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">955-chenp-2004-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQtZm9ybSAzLnBkZg==" target="_blank" style="word-wrap:break-word;">955-chenp-2004-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQtZm9ybSA1LnBkZg==" target="_blank" style="word-wrap:break-word;">955-chenp-2004-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQtb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">955-chenp-2004-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTU1LWNoZW5wLTIwMDQtcGN0LnBkZg==" target="_blank" style="word-wrap:break-word;">955-chenp-2004-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="227972-2-4-5-trisubstituted-thiazolyl-compounds-composition-and-process-for-preparation-thereof.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="227974-biofuel-cell.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>227973</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>955/CHENP/2004</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>10/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>06-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>27-Jan-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>05-May-2004</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>BEA SYSTEMS, INC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2315 NORTH FIRST STREET, SAN JOSE, CALIFORNIA 95131</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>MESSINGER, ADAM</td>
											<td>317 29TH STREET -APT.306, SAN FRANCISCO, CALIFORNIA 94131</td>
										</tr>
										<tr>
											<td>2</td>
											<td>FERGUSON, DON,</td>
											<td>1648 GREAT HIGHWAY, SAN FRANCISCO, CA 94122,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 15/173</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US02/31724</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-10-04</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/327,543</td>
									<td>2001-10-05</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>10/264,439</td>
									<td>2002-10-03</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/227973-a-method-for-receiving-and-handling-requests-from-a-client-application-to-a-server-resource by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:30:20 GMT -->
</html>
