<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/264536-efficient-evaluation-of-queries-using-translation by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:50:19 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 264536:EFFICIENT EVALUATION OF QUERIES USING TRANSLATION</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">EFFICIENT EVALUATION OF QUERIES USING TRANSLATION</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Techniques are provided for processing a query including receiving the query, where the query specifies certain operations; determining that the query includes a first portion in a first query language and a second portion in a second query language; generating a first in-memory representation for the first portion; generating a second in-memory representation for the second portion; generating a third in-memory representation of the query based on the first in-memory representation and the second in-memory representation; and performing the certain operations based on the third in-memory representation.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>EFFICIENT EVALUATION OF QUERIES USING TRANSLATION<br>
FIELD OF THE INVENTION<br>
[0001]       The present invention relates to query processing. The invention relates more<br>
specifically to efficient evaluation of queries using translation.<br>
BACKGROUND OF THE INVENTION<br>
[0002]       The approaches described in this section could be pursued, but are not necessarily approaches that have been previously conceived or pursued. Therefore, unless otherwise indicated herein, the approaches described in this section are not prior art to the claims in this application and are not admitted to be prior art by inclusion in this section. [0003]       Relational database management systems (RDBMSs) store information in tables, where each piece of data is stored at a particular row and column. Information in a given row generally is associated with a particular object, and information in a given column generally relates to a particular category of information. For example, each row of a table may correspond to a particular employee, and the various columns of the table may correspond to employee names, employee social security numbers, and employee salaries. [0004]       A user retrieves information from and makes updates to a database by interacting with a database application. The user's actions are converted into a query by the database application. The database application submits the query to a database server. The database server responds to the query by accessing the tables specified in the query to determine which information stored in the tables satisfies the query. The information that satisfies the query is retrieved by the database server and transmitted to the database application. Alternatively, a user may request information directly from the database server by<br><br>
constructing and submitting a query directly to the database server using a command line or graphical interface.<br>
[0005]       Queries submitted to the database server must conform to the syntactical rules of a particular query language. One popular query language, known as the Structured Query Language (SQL), provides users a variety of ways to specify information to be retrieved. Another query language based on the Extensible Markup Language (XML) is XML Query Language (XQuery). XML Query language may have multiple syntactic representations. For instance, one of them is a human-readable version and another is an XML representation (XQueryX). XQuery is described in "XQuery 1.0: An XML Query Language." W3C Working Draft July 23, 2004 at www.w3.org/TR/xquery. XQueryX is described in "XML Syntax for XQuery 1.0 (XQueryX)." W3C Working Draft 19 December 2003 at www.w3.org/TR/xqueryx. Another related technology, XPath, is described in "XML Path Language (XPath) 2.0." W3C Working Draft 12 November 2003 at www.w3.org/TR/xpath20.   XQuery and XQueryX may use XPath for path traversal. [0006]       To implement XQuery support in RDBMSs, one approach, referred as coprocessor approach, is to embed a general purpose XQuery processor inside an RDBMS engine and have the XQuery processor execute XQuery on behalf of the RDBMS SQL processor. The coprocessor approach has the SQL processor treat the XQuery coprocessor as a black box. During the execution of the SQL statement, the SQL processor handles the XQuery portion of the query by passing the text of the XQuery portion of the query, and the necessary XML values, as input to the XQuery processor. The XQuery processor then returns the results of processing the XQuery portion of the query to the SQL processor and the SQL processor performs any other appropriate operations specified by the query.<br><br>
[0007]       The coprocessor approach has numerous problems. First, the XQuery processor is not aware of any of the underlying techniques for storing XML data. Therefore, the XQuery processor needs fully materialized XML as input. Consequently, the XML input needed by the XQuery processor must be constructed or materialized by the RDBMS. Often the XML input needed for the XQuery is stored in the database and may be "shredded" into one or component XML elements, and those XML elements may be stored in one or more relational or object relational tables. Under these conditions, the process of materializing the XML data is time and resource consuming, and therefore makes the coprocessor approach inefficient.<br>
[0008]       A second problem with the coprocessor approach is that the XQuery portion of an incoming query cannot be optimized with the SQL portion of the incoming query (and vice-versa). Specifically, the XQuery processor is not able to optimize the SQL portion of the query; and the SQL processor is not able to optimize the XQuery portion of the query. Therefore, the SQL and XQuery parts of the query are separately optimized (if at all), which is suboptimal. In addition, the underlying storage of the data needed in the XQuery portion of the query will be stored in a form other than XML (such as being shredded into multiple XMLType columns). Since the XQuery processor is not aware of the form in which the underlying data is stored, the XQuery processor is not able to optimize execution of the XQuery operations based on storage information.<br>
[0009]       A third problem with the coprocessor approach occurs when an XQuery processor is invoked multiple times, where the output of a first XQuery becomes the input to a second XQuery in the original query. For example, in the case where the output of a first XQuery must be passed as input to a second XQuery, the output of the first XQuery must be generated as XML. This dictates that the XQuery processor, after determining the result of<br><br>
the first XQuery, must materialize the result as XML in an XML document and send the XML document to the SQL processor. The SQL processor then passes the XML document back to the XQuery processor along with the second XQuery. The XQuery processor will then retrieve and process the second XQuery with the XML document. This constitutes numerous wasted communication and computational steps and wasted bandwidth. [0010]       Therefore, there is clearly a need for techniques that overcome the shortfalls of the co-processor approach described above.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0011]       The present invention is illustrated by way of example, and not by way of<br>
limitation, in the figures of the accompanying drawings and in which like reference numerals<br>
refer to similar elements and in which:<br>
[0012]       FIG. 1 is a block diagram that depicts a system for efficient evaluation of queries<br>
using translation.<br>
[0013]       FIG. 2 is a flow diagram that depicts a process for efficient evaluation of queries<br>
using translation.<br>
[0014]       FIG. 3 is a block diagram that illustrates a computer system upon which an<br>
embodiment of the invention may be implemented,<br>
DETAILED DESCRIPTION<br>
[0015]       Techniques for efficient evaluation of queries using translation are described. In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, that the present invention may be practiced without these specific details.<br><br>
In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.<br>
1.0       INTRODUCTION<br>
[0016]       The techniques described herein are in no way limited to any particular embodiment or aspect of the embodiment. One example embodiment of the techniques described herein is a database server that accepts queries in SQL, XQuery, and XQueryX. This embodiment is described for illustrative purposes only.<br>
[0017]       When the database server receives a query, it determines whether any portion of the query is in a query language other than SQL (e.g. XQuery or XQueryX). For each such portion, the database server parses the portion and compiles the portion into an abstract syntax tree (AST) in an abstract syntax related to the non-SQL query language. Such ASTs are referred to herein as "non-SQL ASTs" or as AST related to particular query languages, such as XQuery ASTs. The non-SQL AST is then converted into an AST in an abstract syntax related to SQL. Such ASTs are referred to herein as "SQL ASTs." This is repeated for each portion of the query that is in a non-SQL query language (e.g. XQuery or XQueryX). Each portion of the query in the SQL is also compiled into an SQL AST. The database server then combines all of the ASTs corresponding to each portion of the query. This combined AST can then be optimized and executed or stored for later execution. [0018]       The techniques described herein apply, at least, to queries that have one or more portions of the query in one or more declarative query languages. Declarative query languages allow one to specify information to be retrieved from a data source without needing to specify how the information is to be retrieved.<br><br>
2.0 XML DATABASE OPERATIONS<br>
[0019]       Some RDBMSs and object-relational database systems (ORDBMS) support "XML" or "XMLType" as a native datatype. Using XMLType, users can store XML documents in databases via the use of XML tables or XMLType columns of tables. Furthermore, users can convert their relational data into XMLType views via the use of SQL/XML publishing functions, such as XMLElement, XMLConcat, etc. XQuery can be used in SQL through a function such as XMLQuery, which enables queries on XMLType values. The XMLTable function enables one to convert XML values (possibly from one or more XMLType columns, or values returned from an XQuery) into a virtual relational table. Consider an example where a table called "purchaseOrder" is an XMLType table with each row storing a purchaseOrder XML document instance. Each XML document instance has contents similar to the following:<br><purchaseorder><shippingaddress>345y 35 Ave, Berkeley, CA 94613<shippingaddress><items><br><lineitem><name>XQuery Book</name><price>46 <lineitem><name> SQL/XML Guide</name><price> 78</price><lineitem></lineitem></lineitem></price></lineitem></items></shippingaddress></shippingaddress></purchaseorder><br>
[0020]       The following SQL statement, with XQuery embedded in the XMLQuery<br>
function, finds the ShippingAddress of all the purchaseOrder XML document instances<br>
which have a purchase item whose price is greater than forty-five:<br>
select xmlqueryCfor $i in/PurchaseOrder where $i/itemsAineitem/price &gt; 45 return $i/ShippingAddress' passing value(p) returning content) from purchaserOrder p;<br>
[0021]       Here is an example of converting the XML document instance into relational<br>
tables via XMLTable construct:<br>
select xt.name, xt.price<br><br>
from purchaseOrderp, xmltable('/PurchaseOrder/items/lineitem'passing value(p)<br>
columns<br>
name varchar2(20)path 'name', price number path 'price') xt;<br>
3.0       SYSTEM OVERVIEW<br>
[0022]       FIG. 1 is a block diagram that depicts a system for efficient evaluation of queries using translation.<br>
[0023]       The system illustrated in FIG. 1 includes a database server 150. The database server 150 is a logical machine. The database server 150 includes a non-SQL parser unit 110a, an SQL parser unit 110b, a compiler unit 120, a translator unit 130, and a further query processing unit 140. Each of the units 110a, 110b, 120, 130, and 140 may be a logical machine. Each logical machine may run on separate physical computing machines or may be running on the same physical computing machine as one or more of the other logical machines. Various embodiments of computers and other physical and logical machines are described in detail below in the section entitled Hardware Overview. In one embodiment, each of the units 110-140 are software units running on one or more processors on one or more computers, and those one or more processors on one or more computers make up the database server 150. The database server 150 may include other software units not described herein. The units 110-140 may all be part of the same software program or may be part of separate software programs. That is, a single software program may perform the functionality of two or more of the units 110-140. Alternatively, a first software program may perform some of the functions for a particular unit 110-140 and a second software program may perform other functions for the particular unit 110-140. [0024]       The non-SQL parser unit 110a takes a non-SQL query, or portion of a query, as input and converts it to a second representation (such as SQL). For example, the non-SQL parser unit 110a may be an XQueiy parser unit 110a that takes as input an XQuery query and<br><br>
converts it into an XQueryX representation. The compiler unit 120 takes a query as input and produces an in-memory representation of the query. For example, the compiler unit 120 may take as input an XQueryX query and compile that into an XQuery AST. In one embodiment, the compiler unit may take as input queries in more than one query language, and queries of each query language are compiled into different formats of in-memory representation. For example, an SQL query may be compiled into an SQL AST, whereas an XQueryX query may be compiled into an XQuery AST. Alternatively, queries in one or more different query languages may be compiled into similar or the same format of in-memory representation. In alternative embodiments, there are separate parser units 110a and 110b and compiler unit 120 for each query language. For example, there may be an XQuery parser unit 110a and an SQL parser unit 110b.<br>
[0025]       The translator unit 130 converts among the various formats of in-memory representations. For example, the translator unit 130 may convert an XQuery AST into an equivalent SQL AST, or vice-versa.<br>
[0026]       The further query processing unit 140 takes an in-memory representation as input and provides query optimization, storage, and / or, execution of the query based on the in-memory representation of the query. The further query processing unit 140 may also perform the step of combining one or more in-memory representations of queries or parts of a query and performing query optimization, storage, and / or execution of the query or queries based on the combined in-memory representations.<br>
[0027]       The database server 150 is communicatively coupled to a database 160. The database 160 may be a relational database, an object-oriented database, a file, a repository, or any form of structured data stored on a machine-readable medium. The database server 150 may perform (e.g. using the further query processing unit 140) certain operations required by<br><br>
the query against the database 160 based on the in-memory representations produced by the compiler unit 120, translator unit 130, or further query processing unit 140. In various embodiments, coupling is accomplished by optical, infrared, or radio signal transmission, direct cabling, wireless networking, local area networks (LANs), wide area networks (WANs), wireless local area networks (WLANs), the Internet, or any appropriate communication mechanism.<br>
4.0       FUNCTIONAL OVERVIEW<br>
[0028]       FIG. 2 is a flow diagram that depicts a process for efficient evaluation of queries<br>
using translation.<br>
[0029]       In step 205, a query is received. The query may be in any appropriate format.<br>
For example, the query may be in SQL, XQuery, or XQueryX. The query may also utilize a<br>
language for addressing parts of a markup language document, such as XPath. The query<br>
may contain one or more "portions". Each of the portions may be in the different formats<br>
than each of the other portions. For example, in the context of FIG. 1, the database server<br>
150 may receive a query that contains both SQL and XQuery portions:<br>
selectxmlquery(lfor $i in/PurchaseOrder where $i/items/lineitem/price &gt; 45 return $i/ShippingAddress' passing value(p) returning content) from purchaserOrder p;<br>
where the outer portion of the query is in SQL and the portion of the query inside the<br>
xmlquery(...) is in XQuery. The query may also be in a single format.<br>
[0030]       In step 207, the query is processed in order to detect whether there are portions of<br>
the query in one or more query languages. Once the portions of the query are detected in<br>
step 207, then checks are performed to determine whether the query contains XQuery (step<br>
210) or SQL (step 230). In other embodiments, other checks would be performed to<br>
determine whether the query contained statements in other particular query languages (e.g.<br><br>
XQueryX) and steps similar to those for XQuery (steps 210-225) or SQL (steps 230-245) would be performed for queries in each of those other query languages. [0031]       In step 210, a check is performed to determine whether the query contains XQuery. Detecting that a query contains operations to be performed in XQuery may include searching for and finding an XQuery indicator or function call. For example, the non-SQL parser unit 110a may parse the query and detect an XMLQuery function and thereby determine that the query contained within the parentheses is in XQuery format. In various embodiments, step 210 also includes determining whether the query contains XQueryX or XPath and the subsequent steps 220-225 are performed on any XQueryX or XPath queries or subqueries that are found.<br>
[0032]       If the query contains no XQuery, then step 242 is performed. Step 242 is described below. Alternatively, if the query does not contain XQuery or SQL statements and, moreover, contains only elements that are not recognizable by the database server 150, then a message may be sent to the query submitter or a system administrator indicating that the format of the query is not recognizable.<br>
[0033]       If the query does contain XQuery, then the XQuery portion of the query is parsed and compiled into an XQuery AST in step 220. The XQuery portion of the query may be parsed using any appropriate parser. The parsed XQuery is then compiled into an in-memory representation of the XQuery, The in-memory representation of the XQuery portion of the query is formatted in a way that is compatible with the later steps. The techniques described herein are not limited to any particular in-memory representation. The examples herein will use an abstract syntax tree. ASTs capture the semantic meanings of queries while removing syntactic details.<br><br>
[0034]       The AST for the portion of the query in XQuery will be in a particular abstract syntax related to XQuery. In step 225, the XQuery AST for the XQuery portion of the query is converted into an equivalent SQL AST in a particular abstract syntax related to SQL. Each term in the AST is converted in turn. In one embodiment, the elements at the "leaves" or deepest level of the AST are converted from the XQuery-related abstract syntax to the SQL-related abstract syntax. Then the nodes on the next lowest level are converted. The "higher" levels of the AST are processed one level at a time and from the bottom up. Alternatively, one or more of the leaves of the AST are converted and the parent nodes of these leaves are converted once all of their child nodes in the AST are converted. Details of what XQuery statements are converted to which SQL statements are given in the section entitled XQuery Translation and in '706. Once the XQuery AST has been converted into an equivalent SQL AST, then the equivalent SQL AST may later be combined with any other SQL ASTs in step 245 (described below).<br>
[0035]       After step 225 is performed, then, in step 242, a check is performed to determine whether any other portions of the query need to be processed. If there are more portions of the query to process, then step 207 is performed. Alternatively, if there are more portions of the query to process, steps 210 or 230 may be performed. If there are no more portions of the query to process, then step 245 is performed. In general, any portion of the original query that is in a language supported by the database server 150 may be processed. For example, if a query has a first XQuery portion, a second XQuery portion, and an SQL portion, then steps 210-225 are be performed for each of the first XQuery portion and the second XQuery portions and steps 230-240 are performed for the SQL portion of the query. The compiled portions of the query are then combined (described below with respect to steps 245-255).<br><br>
[0036]       In step 230, a check is performed to determine whether the query contains SQL. For example, the SQL parser unit 110b may parse the query (in step 207) and detect an SQL portion of the query and thereby determine that the query contains SQL (in step 230). If the query does not contain SQL, then step 242 is performed. Step 242 is described above. If the query does contain SQL, then in step 240, the SQL portions of the query are parsed and compiled into an SQL AST. Various embodiments of parsing and compiling queries in XQuery are given above in relation to step 220. Techniques for parsing and compiling queries in SQL (or any query language) are similar to those described for XQuery but may use an SQL parser and SQL syntax rules for the parsing.   The resulting in-memory representation, such as an SQL AST, contains the semantics of the SQL portion of the query in an abstract syntax related to SQL.<br>
[0037]       After step 240 is performed, then, in step 242, a check is performed to determine whether any other portions of the query need to be processed. Once any XQuery portions of the query have been parsed, compiled, and converted to an SQL AST and any SQL portions of the query have been parsed and compiled into an SQL AST, then the ASTs representing the different portions of the query may be combined in step 245. Combining the ASTs may comprise forming a new AST for the query and pointing to or copying the ASTs representing the different portions of the query. Alternatively, one or more of the ASTs representing the different portions of the query may point to or incorporate one or more of the other ASTs representing the different portions of the query. The combined AST is in an SQL-related abstract syntax and represents the entire query. For example, in the context of FIG. 1, the further query processing unit 140 combines the ASTs produced in steps 225 and 240. [0038]       In step 250, the combined AST is used as a basis for optimization of the query. Since the entire query is represented in a single abstract syntax, any appropriate single-<br><br>
abstract-syntax optimization technique may be used to optimize the query. In step 255 the optimized query is executed or stored for later execution.<br>
[0039]       Various embodiments of the techniques described herein enable a query that contains subqueries in multiple query languages to be stored or executed based on an AST in a single abstract syntax. One of the benefits of embodiments of these techniques is that, since the AST that represents the query is in a single abstract syntax, the entire query may be optimized as if it were originally written in a single query language.<br>
[0040]       Various embodiments of the techniques described herein enable a query to arrive in a first query language (e.g. XQuery) and for the query to be processed and translated into an equivalent form of a second query language (e.g. SQL). This may be beneficial when the processing or optimization techniques available for the second query language are in some way preferable to those of the first query language. For example, consider a system that does not have XQuery optimizers, but does have SQL query optimizers. Using the techniques described herein, if a query arrives in the XQuery format, the query may be processed and an SQL AST may be generated. The SQL AST may then be optimized using SQL query optimizers. The optimized, equivalent query (as represented by the optimized, SQL AST) may then be executed in place of the original XQuery, thereby saving query processing time. [0041]       In the examples discussed herein, the database server 150 receives the non-SQL query or portions of a query and converts them to SQL. The techniques described herein, however, are not limited to such embodiments. For example, in other embodiments, a middle-tier server that acts as middleware between a database application and a database server 150 may perform the conversions as described herein. The converted SQL query would then be sent to and executed on the database server 150.<br><br>
[0042]       The techniques described herein are presented in terms of a conversion from one abstract syntax to another. In other embodiments of the techniques described herein, the portion of a query in a first syntax (e.g. XQuery) may be converted to a second syntax (e.g. SQL), before it is compiled into an abstract syntax.<br>
5.0      XQUERY TRANSLATION<br>
[0043]       As noted above, the techniques described herein provide for converting an AST in one abstract syntax into an AST of another abstract syntax. Below is a description of the conversion between XQuery ASTs and SQL ASTs.<br>
5.1.      TRANSLATION OF EXPRESSIONS<br>
[0044]       XQuery expressions are rewritten to their equivalent SQL expressions. For<br>
instance a literal in XQuery gets mapped to a string or numeric literal (OPNTSTR) in SQL.<br>
The following table lists the mapping of general expressions in to their SQL equivalents.<br>
Section 5.2 describes the mapping of individual XQuery operators and functions to SQL<br>
operators.<br>
5.1.1.   EFFECTIVE BOOLEAN VALUE<br>
[0045]       The effective Boolean value (EFB) of a sequence is computed implicitly during<br>
processing of the following types of expressions:<br>
•	Logical expressions (and, or)<br>
•	The fhrnot function<br>
•	The WHERE clause of a FLWOR expression<br>
•	Certain types of predicates, such as a[b]<br>
•	Conditional expressions (if)<br>
•	Quantified expressions (some, every)<br>
[0046]       The effective Boolean value returns "false" in the following cases. Otherwise it<br>
returns "true".<br><br>
•	An empty sequence<br>
•	The Boolean value false<br>
•	A zero-length value of type xs:string or xdtuntypedAtomic<br>
•	A numeric value that is equal to zero<br>
•	The xs: double or xs: float value NaN<br>
[0047]	Example rule: To map EFB( expr) to SQL, the following rules are applied:<br>
i)	Translate expr to its SQL equivalent.<br>
ii)        If the static type of expr indicates that the quantifier is 1 (i.e. singleton expr) then<br>
i.	If the type is Boolean and the SQL type is also Boolean (i.e. it is<br>
mapped to one of the logical operators), then nothing to do<br>
ii.        If the type is Boolean and SQL type is number, then add  IS NOT NULL (case <expr> when 1 then 1 else null)<br>
iii.       If the type is numeric then add IS NOT NULL (case <expr> when 0 then 0 when NaN then 0 else 1)<br>
iv.        If the type is any other scalar, then add IS NOT NULL( expr )<br>
iii)       If the static type of expr indicates that the quantifier is * or + then<br>
i.	If the type is number or Boolean - convert the collection to a subquery<br>
and add the following subquery expression on top - EXISTS( select * from (select count(*) cnt, sum(value(p))sm from table(xmlsequence(<expr>)) x where (x.cnt — 1 andx.sm = 1) or (x.cnt&gt; I))<br>
ii.        For all other types map it to IS NOT NULL (<expr>) in case the<br><expr> is a non-subquery operand or to EXISTS( <expr> ) if expr is an SQL subquery.<br>
5.1.2.   ATOMIZATION OF VALUES<br>
[0048]       Atomization and conversion to scalar values are required in a number of places.<br>
Atomization is determined by the static type analysis. In XQuery this is represented using the<br>
fn:data() function.<br>
[0049]       The result of fn:data() is the sequence of atomic values produced by applying the<br>
following rules to each item in the input sequence:<br>
•	If the item is an atomic value, it is returned.<br>
•	If the item is a node, its typed value is returned.<br>
[0050]       Atomization is used in processing the following types of expressions:<br>
•	Arithmetic expressions<br><br>
•	Comparison expressions<br>
•	Function calls and returns<br>
•	Cast expressions<br>
•	Computed element and attribute constructors.<br>
[0051]	When rewriting atomization, if the underlying SQL object is an XMLType (or<br>
node) an OPTXT2SQLT operator is used to convert the node value to the equivalent SQL<br>
type.<br>
[0052]       Example rule: Whenever atomization is required and the underlying SQL object's<br>
type is not scalar, add the OPTXT2SQLT operator with the desired type. OPTXT2SQLT<br>
takes the input XML and the SQL type to convert the result to and atomizes the value to the<br>
result.<br>
5.1.3.	LITERAL EXPRESSIONS<br>
[0053]       Literal Expressions in XQuery are translated to SQL literals. Boolean are mapped<br>
as numbers 0 &amp; 1. For example, the expression "1" is mapped to STRTCONS with value<br>
"1". Numeric literals are mapped to SQL literals of type NUMBER and string literals are<br>
mapped to SQL literals with type VARCHAR2.<br>
[0054]       Example rule: Map XQuery literals to SQL literals with the appropriate type<br>
information. In case of a string literal, if it is &gt; 4K, then map to a set of concat operations<br>
with an empty_clob in the beginning.<br>
Big_String_Literal -&gt; empty_clob() || 4kliterall || 4kliteral2 ... || literaln OPTTCA(OPTTCA(OPTTCA(OPTECLOB, literal 1), literal),... literaln)<br>
5.1.4.	BUILT-IN TYPE CONSTRUCTOR, CAST EXPRESSIONS<br>
[0055]       The XQuery CAST and type constructors are mapped to SQL TO_CHAR, TO_NUMBER and XMLCast. XMLCast is used for casting explicitly to user-defined simple types (e.g. hatsize) and for converting simple scalar types to XML values (for passing into functions etc.).<br><br>
[0056]       The following table explains the mapping of XML datatypes to their SQL equivalents. The constructor column is used to check the validity of the value (e.g. byte may be 
[0057]       Example rule: Check datatype to which to cast. If the input is a constant, then check the bounds and raise an error if appropriate. Else if it is a numeric datatype add the TO^NUMBER and the bounds check. If it is a date type, convert it to the TIMESTAMP_TZ with the appropriate format.<br><br><br><br>
5.1.5.   SEQUENCE CONSTRUCTORS<br>
[0058]       XMLConcat() is used for concatenating sequences. However, XML constructors<br>
are needed for converting scalar values to XMLType. For example, the sequence constructor<br>
(1, 2, 3) is mapped to XMLConcat( XMLCast(l), XMLCast(2), XMLCast(3)).<br>
[0059]       Example rule: Iterate over all the input of the sequence constructor. For each<br>
expression, convert it into its SQL equivalent. If the result type is a simple scalar, add an<br><br>
XMLCast operand on top of it. Create an XMLConcat() to concatenate the result into a single XMLType.<br>
5.1.6.	RANGE EXPRESSION<br>
[0060]       Range expressions may be handled by using an operator OPTXNRNG(). See the range operator in operator listing.   This range operator returns an XMLType containing a list of integers. [0061]       Example rule: Map to the OPTXNRNG operator.<br>
5.1.7.	SET EXPRESSIONS (UNION, INTERSECT, MINUS, EXCEPT)<br>
[0062]       Set operations are transformed to value operation in case of unions on values. If XMLType(Seq) may be mappable to SQL UNION, INTERSECT, MINUS, and / or EXCEPT constructs, and doing so may eliminate duplicates among nodes. [0063]       Example rule: Map the set expressions to the SQL UNION, INTERSECT, MINUS, and EXCEPT constructs. The order/map method is used on the XMLType to perform node level operations.<br>
5.1.8.	ARITHMETIC EXPRESSIONS<br>
[0064]       Static typing ensures that input may be numerical values or atomization and type casts are added. The translation simply converts it to the SQL arithmetic expression. [0065]       Example rule: Convert the XQuery arithmetic expression to its SQL equivalent. See operators table for detailed mapping of the various operators.<br>
5.1.9.	VALUE COMPARISON EXPRESSIONS<br>
[0066]       Static typing ensures that input may be scalar values or atomization and type casts are added. The translation simply converts it to the SQL comparison expression.<br><br>
[0067]       Example rule: Convert the XQuery comparison expression to its SQL equivalent. See operators table for detailed mapping of the various operators.<br>
5.1.10. GENERAL COMPARISON EXPRESSIONS<br>
[0068]       Static typechecking may convert any general comparison expression to a value<br>
comparison if possible. If both sides are non collection values and the types are compatible<br>
they are converted to value comparison. For example, the expression, $po/PoNo = 21 may<br>
be converted to $po/PoNo eq 21 if the type quantifier of $po/PoNo is not a collection (*, +<br>
etc.).<br>
[0069]       If the static type information for both the sides are known compatible scalar types<br>
(e.g. integer *) they are mapped to EXISTS subqueries. For example, $po//LineItems = 21<br>
may get mapped to EXISTS(select * from TABLE(XMLSEQUENCE( <xpath-conv-for></xpath-conv-for>
$po//LineItems&gt;)) x where value(x) = 21).<br>
[0070]       If the static type is unknown (untypedAtomic *) then the equivalent general<br>
comparison operator is used.<br>
[0071]       Example rule: Given exprl GCOMP expr2, check the compatibility of the static<br>
types of the two expressions.<br>
•	If the type of both sides is untypedAtomic, they are both converted to a VARCHAR2 type.<br>
•	If one side is untypedAtomic and the other is a numeric value, then the untypedAtomic value is converted to the BINARYDOUBLE.<br>
[0072]       Now check the quantifier for the type (e.g. quantifier (integer *) is *). For example:<br>
•	If the quantifier for both sides is a singleton (empty or ?) then map the GCOMP to the SQL value comparison operator.<br>
•	If exprl quantifier type is a collection (* or +) and expr2 quantifier is a singleton then map to<br>
EXISTS( select null from TABLE(XMLSEQUENCE( exprl) x<br>
Where value(x) VCOMP expr2 )   (VCOMP is the value comparison<br><br>
equivalent)<br>
e.g. $po//LineItemNo 
EXISTS( select null from TABLE(XMLSEQUENCE( $po//LineItemNo) x<br>
Where value(x) 
•	If expr2 quantifier type is a collection (* or +) and exprl quantifier is a singleton<br>
then map to<br>
EXISTS( select null from TABLE(XMLSEQUENCE( expr2 ) x<br>
Where exprl VCOMP value(x) )   (VCOMP is the value comparison equivalent)<br>
e.g. 20 
EXISTS( select null from TABLE(XMLSEQUENCE( $po//LineItemNo) x<br>
Where 20 
•	If both expressions are collections then map the expression to<br>
EXISTS( select null from TABLE(XMLSEQUENCE( exprl ) x<br>
Where EXISTS (select null from TABLE(XMLSEQUENCE( exprl<br>
)y<br>
Where value(x) VCOMP value(y)))<br>
e.g. $pol//LineItemNo 
EXISTS( select null from TABLE(XMLSEQUENCE( $pol//LineItemNo ) x<br>
Where EXISTS (select null from TABLE(XMLSEQUENCE( $po2//LineItemNo) y<br>
Where value(x) 
5.1.11.	NODE COMPARISON EXPRESSIONS<br>
[0073]       Node comparisons are handled by using the order method on XMLType. They are<br>
mapped to the SQL value comparison operators.<br>
[0074]       Example rule: Map to the SQL value comparison operators as described herein.<br>
5.1.12.	ORDER COMPARISON EXPRESSIONS<br>
[0075]       Order comparison expressions are used in the FLWOR order by clause. These are mapped to the SQL order by clause.<br><br>
[0076]       Example rule: Map Order comparison expressions to SQL order by clause expressions.<br>
5.1.13.	LOGICAL EXPRESSIONS (AND, OR, NOT)<br>
[0077]       XML logical expressions are mapped to SQL logical expressions. SQL has 3-valued logic, but empty sequences are mapped to NULL and this works for non-constraint operations. Constraints may be an important issue, since a NULL value from a constraint is treated as matching the constraint.<br>
[0078]       Example rule: Map logical expressions to SQL logical expressions (AND, OR). In case when the logical expression appears as a top-level expression (outside of the WHERE clause or IF clause) then add a CASE Expression to the result. E.g. if the query is the expressions "a  30", map it to CASE WHEN (a  30) then 1 else 0.<br>
5.1.14.	FLWOR EXPRESSION<br>
[0079]       FLWOR expressions are mapped to SQL select expressions. The LET clauses are mapped as common sub expressions in the SQL query. The RHS of the for-clause is mapped to the from-clause, the where-clause is mapped to the SQL where-clause and the return-clause is mapped to the SQL select-clause. If node identities are to be preserved in the query, then the query block is marked as NO_MERGE.<br>
for <var>    in <rhs-exprl>, <var2> in <rhs-expr2> where <cond-expression> order by <ol>,  <o2>..  <on> return <ret-expr><br>
is mapped to<br>
select /*+ NO_MERGE */ XMLAGG( <sql-ret-expr> ) from TABLE(XMLSEQUENCE( <sql-rhs-exprl> ) as "varl" TABLE(XMLSEQUENCE( <sql-rhs-expr2> ) as "var2" where <sql-cond> order by <sql-ol>, <sql-o2>, .. <sql-on><br><br>
[0080]       Example 1: Simple FLWOR clause<br>
for $i in (1,2,3) where $i &gt; 1 return $i+ 2<br>
is mapped to<br>
select xmlagg (XMLCast (XMLCast (value C$i") as number) + 1 as xml)) from table (xmlsequence ( xmlconcat ( cast (1 as xmltype (sequence)),<br>
cast (2 as xmltype(sequence)),<br>
cast (3 as xmltype (sequence))))<br>
returning sequence) as "$i" where XMLCast(valueC$i") as number) &gt; 1;<br>
[0081]   Example 2. FLWOR clause with XPath expressions:<br>
for $i in doc("foo.xml")/PurchaseOrder where $i/PoNo = 21 return <a>{$i}</a><br>
becomes<br>
select xmlagg(XMLElement(MA", value T$i"))) from table(xmlsequence( extract ( select extract(Res,'/Contents/*') from resource_view where equals_path(res,' /foo.xml') = 1),<br>
VPurchaseOrder'))) "$i" where XMLCast ( OPTXATG (value r$i", VPoNo') as number) = 21<br>
5.1.14.1.    LET CLAUSE HANDLING<br>
[0082]       A LET clause expression is inlined into the query expression (and marked as<br>
common subexpression) if node identities need not be preserved. Otherwise a subquery is<br>
created with the LET clause expressions as it's select list. The subquery is marked as non-<br>
mergeable to prevent view merging.<br>
[0083]       Example with node identities preserved:<br>
for $i in doc("foo.xml")/PurchaseOrder//LineItems let $j   : = doc (xxbaditems.xml") //Badltems where $i/ItemNo eq $j/ItemNo return   ($i,   $j/Badltem)<br>
becomes<br>
select xmlagg (xmlconcat r$i", OPTXATGr$j",' /Badltem')) )<br><br><br><br>
where XMLCast (OFEXATGr$i'V /ItemNo') as number) = XMLCast (OPTXATG r$j",' /ItemNo') as number)) ;<br>
[0085]       Example technique: Since preventing view merging may adversely affect query performance, the WHERE clause for the FLWOR expression is first searched to see if it includes any of the LET variable. If not, then the LET clause may be evaluated as a result of the FLWOR clause (along with the return).<br>
[0086]       For example in the following query,<br>
for $i in doc("foo.xml")/PurchaseOrder//LineItems<br>
let $j   := count(doc("baditems.xml")//BadIterns[ItemNo = $i/ItemNo])<br>
where $i/ItemNo &gt; 200<br>
return $j<br>
$j is often used in the return clause and not in the WHERE clause - so that the WHERE<br>
clause may be evaluated before the LET clause. This query is equivalent to<br>
for $j in<br>
for $i in doc("foo.xml")/PurchaseOrder//LineItems<br>
where $i/IterriNo &gt; 200<br>
return<br>
count(doc("baditems.xml")//BadIterns[ItemNo = $i/ItemNo] return $j<br>
[0087]       Example rules: Normalize Type declarations: If the FOR or LET clause involves any type declaration, check the static type of the expression corresponding to the clause. If it is the same or a subtype of the declared type then ignore the type declaration. If it is a supertype of the declared type, then add a TREAT expression on the expression and map it to SQL. Otherwise raise an error. For <var> <type> := <expr> is normalized to for <var> := TREAT<expr> as <type> and then mapped to SQL.<br>
[0088]       Convert all expressions in the FOR, WHERE, LET and RETURN clauses to their SQL equivalent. Map the FOR clause expressions to SQL FROM clauses (joins). If node identity need not be preserved, then inline the LET clause expression wherever it is referenced. For example:<br>
For <varl> in <exprl>,     <var2> in <expr2><br><br>
let <var3> in <expr3><br>
where <cond-referencing-var3> return <expr4><br>
is mapped to<br>
select xmlagg(<expr4>)   /* inline var3 references with expr3 */ from table(xmlsequence( <exprl> )  as 'Varl" , table(xmlsequence( <expr2>)   as Mvar2",.» where <cond-referencing-var3>      /* inline var3 references with expr3 */<br>
[0089]       Otherwise, if node identity is to be preserved, examine the LET clauses in the<br>
FLWOR expression to determine if they may be evaluated before the WHERE clause, by<br>
checking whether the variables defined in the LET clauses are used in the WHERE clause.<br>
Add a NO_MERGE hint on the inner query block to indicate that view merging should not<br>
happen.<br>
[0090]       If the LET clause needs to be evaluated before the WHERE clause, map the LET<br>
clause expression as a select list subquery and map the WHERE clause to the SQL WHERE<br>
clause of the outer query block. For example:<br>
For <varl> in <exprl>,     <var2> in <expr2> let <var3> in <expr3><br>
where <cond-referencing-var3> return <expr4><br>
is mapped to<br>
select xmlagg( <expr4>    ) from       (select /*+ NOJYERGE */<br>
value("varl")   as uvarl", value("var2")  as "var2",   .. <expr3> as "var3" from table(xmlsequence( <exprl> )  as "varl" , table (xmlsequence ( <expr2>)   as "var2",.' ) where <cond-referencing-var3><br>
) [0091]       If the LET clause need NOT be evaluated before the WHERE clause, map the<br>
LET clause expression as a select list subquery, but map the WHERE clause to the SQL<br>
WHERE clause of the inner query block. For example:<br>
For <varl> in <exprl>,     <var2> in <expr2><br><br>
let <var3> in <expr3><br>
where <cond-not-referencing-var3> return <expr4-refecencing-var3><br>
is mapped to<br>
select xmlagg(<expr4-referencing-var3>  ) from<br>
(select /*+ NO MERGE */<br>
value ("Varl")   as "varl", value Tvar2")  as "var2",   .. <expr3> as "var3" from table(xmlsequence( <exprl> )  as "varl"  ,<br>
table(xmlsequence( <expr2>)   as "var2",.. where <cond-referencing-var3> )<br>
5.1.15. PATH EXPRESSIONS<br>
[0092]       Path expressions are mapped to SQL expressions. An operator OPTXATG is used to extract out individual nodes in the path expression. It represents a single step traversal. Static typechecking is used to optimize some of the path expression conversion.<br>
5.1.15.1.    PATH STEPS WITHNAME TEST<br>
[0093]       This represents the standard XPath 1.0 path expressions. Simple path traversals<br>
with name tests are rewritten to the OPTXATG operator. Static type checking is used to<br>
figure out the type and cardinality of the various steps. This is later used for translation.<br>
Predicates are mapped to relational WHERE clauses after normalization. General<br>
comparisons involving collection elements are mapped to subqueries involving value<br>
comparisons. If there is no static type checking information available, then each step is<br>
assumed to produce an untypedAny.<br>
[0094]       OPTXATGs are further optimized (or collapsed) based on the input arguments.<br>
For example:<br>
$i/PurchaseOrder/PoNo<br>
is mapped to<br><br>
OPTXATG(OPTXATG($i, 'PurchaseOrder'), 'PoNo').<br>
[0095]       OPTXATGs are further optimized (or collapsed) based on the input arguments. For example the expression,<br>
(<b>3 3 </b>)/A/B is mapped to<br>
OPTXATG(OPTXATG(XMLElement("A", XMLElement("B",33)), 'A'), <b></b>
[0096]       The XATG that extracts A and the XMLElement() creating A are collapsed and the result is XMLElement("B", 333) which corresponds to the result <b>33</b>. [0097]       In a second example, path predicates are mapped to relational predicates:<br>
$i/PurchaseOrder/PoNo eq 21 gets mapped to<br>
XMLCast ( OPTXATG ( OPTXATG   (  $i  ,   'PurchaseOrder' ),   'PoNo')   as number)   = 21<br>
[0098]       The previous mapping is only valid if during static type checking the type of PoNo is an atomic value that may be cast to a number. If there is no schema information available, then the static type information may only yield the fact that PoNo is of xs:anyType. The XMLCast in this case may perform atomization of the values and raise error if the input (PoNo) is not a single atomic value or element castable to a number. [0099]       If the general comparison operator (=) was used and the type information is not known, then it has to be treated as a collection comparison. In this case, the path predicate is rewritten to a TABLE subquery using the value comparison. For example:<br>
$i/PurchaseOrder/PoNo = 21 gets mapped to<br>
EXISTS(  select null<br>
from table(xmlsequence(OPTXATG( OPTXATG   (  $i  , 'PurchaseOrder'),   'PoNo'))))   x<br>
where XMLCast( value(x)   as number)   = 21  )<br><br>
[0100]       A path expression that involves predicates in the path step itself is also handled in a similar fashion. For example:<br>
$i/PurchaseOrder[PoNo eq 21] gets mapped to<br>
select OPTXATG(  $i,   'PurchaseOrder')<br>
from dual<br>
where XMLCast( OPTXATG( OPTXATG ( $i , 'PurchaseOrder'), APoNo')<br>
as number) = 21<br>
and in the case of general comparison with no schema inputs,<br>
$i/PurchaseOrder[PoNo =21] gets mapped to<br>
select XMLAGG(value(v))<br>
from table(xmlsequence(OPTXATG($1, 'PurchaseOrder')) v<br>
where exists(<br>
select null from<br>
table(xmlsequence(OPTXATG( value($v), 'PoNo'))) x<br>
where XMLCast(value(x) as number) = 21);<br>
5.1.15.2.	PATH STEPS WITH KIND TEST<br>
[0101]       Kind test involve checking the type of the node (e.g. text()? processing-instruction() etc.). XQuery adds more sets of type check such as the name and schema type of the node. For example, $i/element(foo, bar) indicates that the child element named foo of type bar needs to be extracted. The OPTXATG operator is enhanced to take in a node type in addition to the node name for extraction.<br>
5.1.15.3.	PATH STEPS WITH FILTER EXPRESSIONS<br>
[0102]       Filter expressions are handled by normalizing the path expression and pushing the path expression into the context node. For example, $i/PurchaseOrder/(for $j in Lineltems return count($j/Orders) may be normalized into (for $j in $i/PurchaseOrder/LineItems return count($j/Orders)).<br><br>
[0103]       Example rule: For each step of the path expression map it to an SQL operator as follows:<br>
a)	If the step is a name test, then map it to the OPTXATG operator. <expr><step><qname-or-wildcard> maps to OPTXATG( <expr>, <step>, <localname>, <namespace>)<br>
b)	If the step is a kind test, then map it to the OPTXATG operator with type information <expr><step><type> is mapped to OPTXATGf <expr> , <step>, <type> )<br>
c)	If the step is a filter step, then normalize the expression as follows - <expr><step><filterexpr> is normalized to (for $m in <expr> return <filterexpr> with the context node in the filter expr changed to $m. This is then rewritten to SQL.<br>
[0104]       For example, $i/PurchaseOrder/(for $j in Lineltems return count($j/Orders)) is normalized into for $m in $i/PurchaseOrder return (for $j in $m/LineItems return count($j/Orders)) and then mapped to SQL.<br>
[0105]       For predicates in the path expression, the static type of the expression containing the predicate may be checked as followed:<br>
a)	If the static type indicates that the expression results in a collection (quantifier = * or +), then create a subquery with the expression and map the predicate to the WHERE clause.<br>
b)	Else if the static type indicates that the expression results in a singleton node, map to a<br>
5.1.16. CONDITIONAL EXPRESSIONS<br>
[0106]       If-then-else expressions are mapped to the SQL CASE WHEN Expressions. [0107]       Example rule: Given if<exprl> then <expr2> else <expr3>. Add the effective Boolean value operator to exprl if necessary (as determined by the static type checking), and map the expression to CASE WHEN <exprl> then <expr2> else <expr3>.<br><br>
5.1.17. QUANTIFIED EXPRESSIONS<br>
[0108]       Quantified expressions may be mapped into SQL EXISTS clauses. For example<br>
to find all purchaseorders where at least one of the lineitem number is present in the bad<br>
items list,<br>
for $1 in ora:viewr("po TAB")//PurchaseOrder where some $j in $i//LTneItem satisfies<br>
for $k in ora:view ("bad_iterns'7) where $k//ItemNo = $j/ItemNo return $k,<br>
where "ora:viewQ" is an XQuery function that returns the data from a relation table in XML<br>
form, may be mapped to<br>
select valueP$I") from "po_TAB" "$I" where exists(<br>
select( select "$k"<br>
from (select value (p) "$k" from "bad_items" p) where OPTXATGr$k",'//ItemNo') = OPTXATGr$j",' /ItemNo')<br>
) from (<br>
select value("$j") as w$j"<br>
from table(xmlsequence(OPTXATG(value ("$1"), V/Lineitem')))<br>
)<br>
5.1.18. DIRECT ELEMENT CONSTRUCTOR EXPRESSION<br>
[0109]       Element constructors are mapped to XMLElement() operator. Attributes inside the element are mapped to the XMLAttributes() clause in the XMLElement() operator. [0110]       Example,<br><a>  {  "21"     }  </a> is mapped to XMLelement (NAME M"",   '21')   and <a b="21">22</a> is mapped to XMLElement (NAME 'A', XMLAttributes(21 as "b"),   x22')<br>
[0111]       Example rule: Map any element constructor to XMLElement() using XMLAttributes() for attribute construction.<br><br>
5.1.19.	COMPUTED ELEMENT CONSTRUCTOR EXPRESSION<br>
[0112]       Computed element constructor is also mapped to XMLElement(). Any computed attribute constructor that is a child of the element constructor is optimized and mapped to the XMLAttributes() clause. The XMLElement() operator is relaxed to allow dynamic element names. The operator may also be modified to make free standing attribute children to become<br>
the element's attributes.<br>
element  {"a"  }   {  "21"  } is mapped to<br>
XMLElement(NAME EXPR  Aa',   '1') and<br>
element  {"a"  }   {<br>
Attribute b  {  "21"  } {22}<br>
} is mapped to<br>
XMLElement(NAME EXPR  'a',  XMLAttributes('21's "a"),   '22') [0113]       Example rule: Map any computed element constructor to XMLElement() and map<br>
child attribute constructors to XMLAttribute().<br>
5.1.20.	COMPUTED ATTRIBUTE CONSTRUCTOR EXPRESSION<br>
[0114]       Attribute constructors are handled by allowing the XMLAttribute() as a top level SQL function.<br>
Attribute "a"  {  "21"     }   is mapped to<br>
XMLAttribute(21 as "a") [0115]       Example rule: Map Attribute constructors to XMLAttribute.<br><br>
5.1.21.	OTHER XML CONSTRUCTION EXPRESSIONS<br>
[0116]       Example rule: The XML constructors are mapped to the equivalent SQL/XML standard functions.<br><br>
5.1.22.	TYPESWITCH EXPRESSION<br>
[0117]       Typeswitch expressions are similar to if-then-else except that they switch on the type of the input. The typechecking may be performed using an SQL operator OPTXTYPCHK that checks the XQuery type of the input returning 1 if the type matches. If the static type information of the expression is known the typeswitch may be optimized away completely. The OPTXTYPCHK operator may be optimized away for most of the cases where the static type check information may optimize the type checking. [0118]       Example rule: Map Typeswitch to Case expression and use the OPTXTYPCHK<br>
to check the type of the input. Given<br>
typeswitch <expr><br>
case <varl> as <typel> return <exprl> case <var2> as <type2> return <expr2><br>
default <exprn> [0119]       Check the static type of <expr>. Let this be etype. Now for each Case expression<br>
match the etype with the type-i in the Case expression. If the two types are the same or etype<br>
is a subtype of type-i, then optimize the typeswtich expression away and return the SQL<br>
equivalent of expr-i. If type-i is a subtype of etype then map the entire typeswitch expression<br>
to the SQL expression of the form<br>
Case when OPTXTYPCHK(<expr>,   <typel>)   = 1 then <exprl><br><br>
When OPTXTYPCHK(<expr>,   <type2>)   = 1 then <expr2> else <exprn> [0120]       If no type-i is in the type hierarchy of etype then return the SQL equivalent of the<br>
default expression exprn.<br>
5.1.23.	INSTANCEOF EXPRESSION<br>
[0121]       InstanceOf expression may be evaluated using the OPTXTYPCHK operator and<br>
may be optimized using the static type of the input expression.<br>
[0122]       Example rule: Given <exprl> instanceOf<typel>. Check if the static type of<br><exprl> is the same or a subtype of <typel>. If so, then remove the expression. If the static<br>
type is a supertype of typel then map to OPTXTYPCHK(<exprl>, <typel> ). Else it is an<br>
error.<br>
5.1.24.	CASTABLE EXPRESSION<br>
[0123]       Castable expressions are used to check if the input is castable to the given form. They may be mapped to SQL using an OPTCASTABLE operator that may be used to determine if the expression is castable to the other type. Note that this expression may be removed if the static type of the input is the same or a subtype of the input. [0124]       Example rule: Map <expr> castable as <type> is mapped to OPTXTYPCHK(<expr>, <type>)<br>
5.1.25.	TREAT EXPRESSION<br>
[0125]       Treat expressions are mapped to Case expressions.<br>
[0126]       Example rule: Map treat <expr> as <type> to CASE WHEN OPTXTYPCHK(<br><expr>3 <type> ) = 1 then <expr> else error()nd.<br><br>
5.1.26.	VALIDATE EXPRESSION<br>
[0127]       Validate expressions are mapped to the XMLValidate() function. The XMLValidateO is an SQL operator that takes in a schema type (local or global) and returns the validated XML value back or an error.<br>
[0128]       Example rule: Map validate <type><expr> to XMLvalidate(<expr>, <type>) [0129]       Validate expressions may also be mapped to an XMLIsValid() function.<br>
5.1.27.	AGGREGATE EXPRESSION<br>
[0130]       XQuery allows aggregates to be present anywhere in the query. This is not directly supported by SQL. For example, the following XQuery returns all purchaseorders that have more than 21 lineitems in them.<br>
for $i in doc("Po-xml")<br>
where count($i/PurchaseOrder/Lineitems) &gt; 21<br>
return $i<br>
[0131]       Aggregates are rewritten using a subquery to compute the aggregate.<br>
select x.res<br>
from (select res from resource__view where<br>
equalsj?ath(res,'Po.xml') = 1) x<br>
where (<br>
select count(value(z))'from table(xmlsequence(OPTXATG(OPTXATG(x.res , ^PurchaseOrder'),   'Lineitems')))   z )    &gt;21;<br>
[0132]       Example rule: When mapping Functions &amp; Operators (F&amp;O) to SQL expressions, if the F&amp;O is an aggregate then map it to an SQL Subquery. Map agg-func ( <expr> ) to (select sql-agg-func(value(p)) from table (xmlsequence(<expr>)) p) .<br>
5.1.28. POLYMORPHIC OPERATOR<br>
[0133]       Since XQuery allows overloading of arithmetic and comparison function to<br>
handle a variety of datatypes, the mapping to an SQL operator may vary depending on the<br><br>
run-time input types of the operands. XQuery operators utilizing such overloading are called "polymorphic operators."<br>
[0134]       For example, consider, the following XQuery expression:<br>
declare $b xs:boolean external; (if ($b) then 3.3 else xs:date("2001-08-25")) + (if ($b) then 44 else xdt:yearMonthDuration('T5Y0M") [0135]       Depending on the value at run time for the external variable $b, the addition in XQuery can be translated to decimal addition (in this case, it adds decimal value 3.3 and 44) or can be translated to date addition with yearMonthDuration (in this case, it adds five years and zero months to the date '2001-08-25* which yields the date '2006-08-25'). [0136]       Therefore, the determination as to whether this expression is mapped to the SQL decimal operator or SQL date addition operator may only be made at run time.   To support this, the techniques described herein map arithmetic expressions, whose input data type is polymorphic as determined from static type check, into polymorphic SQL arithmetic operators. A polymorphic SQL arithmetic operator can dispatch to the appropriate SQL arithmetic operator at run time depending on the run time input types. [0137]       Similar translations are used for polymorphic XQuery comparison functions as well. Polymorphic XQuery comparison functions are mapped to polymorphic SQL value comparison operators.<br>
[0138]       As noted above, it may be beneficial to use polymorphic operator translation if the input types may vary during XQuery compile time. Furthermore, non-polymorphic XQuery expressions, such as 3.3 + 44, may still be directly translated it into non-polymorphic SQL expressions, e.g. using SQL decimal addition operators, instead of the polymorphic SQL operators.<br><br>
5.1.29.	XQUERY USER-DEFINED AND EXTERNAL FUNCTIONS<br>
[0139]       XQuery supports user-defined functions written in XQuery and external functions whose implementation is outside of the XQuery environment. For example, the body of a function may be written in a programming language such as the Java programming language. [0140]       User-defined XQuery functions may be translated into Oracle PL/SQL (Procedural Language/Structured Query Language) functions. This may be performed by translating the body of a user-defined XQuery function from an XQuery expression into a PL/SQL expression. Additionally, an invocation of an XQuery function may be translated into an invocation of a PL/SQL function in SQL.<br>
[0141]       The techniques described herein also support external user-defined functions in XQuery. For example, if the body of a function is written in the Java programming language, then the function may be mapped to an equivalent external user-defined function using an SQL external user-defined function written in the target language (for example, a Java user-defined SQL function). Therefore, an external user-defined function in XQuery, implemented in Java, C, PL/SQL, or any other appropriate language, may be translated into a user-defined PL/SQL function, written in Java, C, PL/SQL, or any other appropriate language supported by the SQL system.<br>
5.1.30.	XQUERY MODULE<br>
[0142]       XQuery supports modules. XQuery modules are fragments of XQuery code that can be independently created and imported or loaded into an XQuery processor.   XQuery modules may be translated into Oracle PL/SQL packages that may be independently created and loaded into the database server.<br><br>
5.2.      MAPPING OF FUNCTIONS &amp; OPERATORS<br>
[0143]       The following table illustrates the mapping of XQuery operators and standard<br>
functions (F&amp;O) to existing or new SQL operators.<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
[0144]       The following SQL operators are also provided to perform XQuery related operations: OPTXTYPCHK performs type checking on the input so that it conforms to the given XQuery type (e.g. xs:integer). OPTXATG performs an XPath extraction operation. OPTXT2SQLT is used for casting XML type to SQL (XMLCast (xmltype expr as sqltype). OPTSQL2XMLT is used for casting SQL types to XML (XMLCast ( sql-expr as xml-type)).<br>
5.3.      EXPRESSION MAPPING EXAMPLES<br>
[0145]       Some of the common expressions and their mapping are explained with examples<br>
in this section.<br>
[0146]       For example, Repository Queries (doc):<br>
for $i in doc("/public/purchaseorder.xml") where $i/PurchaseOrder/@Id eq 2001 return <po pono="{$i/PurchaseOrder/@Id}/"><br>
which is rewritten to<br>
select XMLAgg(XMLElement("PO", XMLAttributes(<br>
XMLCast (OPTXATG( OPTXATGr"$i".res/ /PurchaseOrder') ,' /@Id')<br><br>
as number)<br>
as "pono"))) from (select res<br>
from resource_view<br>
where equals_path(res,'/public/purchaseorder.xml') = 1) "$i" where XMLCast(OPTXATG("$i".res,' /PurchaseOrder/@Id') as number) = 2001;<br>
gets rewritten to<br>
select XMLAgg(XMLElement("PO" XMLAttributes(<br>
XMLCast(OPTXATG(OPTXATG(res,'/PurchaseOrder'), '@Id') as number)<br>
as "pono"))) from resource_view<br>
where equalsjpath(res,'/public/purchaseorder.xml') = 1 and XMLCast (OPTXATG (res//Pur chaseOrder/@ Id') as number) = 2001;<br>
[0147]   For example, Repository (Collection):<br>
for $i in collection("/public") where $i/PurchaseOrder/@Id gt 2001 return <po pono="{$i/PurchaseOrder/@Id}/"><br>
becomes<br>
select XMLAgg(XMLElementPPO", XMLAttributes (<br>
XMLCast (OPTXATG(w$i".xmlv,' /PurchaseOrder/@Id') as number) as "pono"))) from table(xmlsequence(select XMLAgg(res) as xmlv<br>
from resource_view<br>
where underjoath(res,'/public') = 1) "$i" where XMLCast(OPTXATG T$i"-xmlv,'/PurchaseOrder/@Id') as number) &gt; 2001));<br>
[0148]  For example, SQL Table Queries:<br>
for $emp in ora:view(x'EMP"),<br>
$dept in ora:view(xxDEPT") where $emp/ROW/DEPTNO = $dept/ROW/DEPTNO return ($erip/ROW/ENAME, $dept/ROW/DNAME)<br>
becomes<br>
select XMLAgg(<br>
XMLConcat (XMLCast (OPTXATG ("$emp". xmlv,' /ROW/ENAME') as number),<br>
XMICast (OPTXATG ("$dept".xmlv,' /ROW/DNAME') as number)))<br>
from (select XMLElement ("PROW" %XMLForest (empno, ename, sal, deptno))<br>
as xmlv from emp ) "$emp",<br>
(select XMLElement("ROW",XMLForest(deptno, dname) as xmlv from dept) "$dept"<br><br>
where XMLCast (OPTXATG("$enp".xmlv/ /ROW/DEPTNO') as number) XMLCast (OPTXATG r$dept".xmlv,' /ROW/DEPTNO) as number) ;<br>
which gets rewritten into<br>
select XMLAgg (XMLConcat (e. ename, d. dname)) from emp e, dept d where e.deptno =d.deptno;<br>
6.0       EXAMPLE ALTERNATIVES<br>
[0149]       In the embodiments described herein, XQuery and XQueryX were presented as examples of query languages for querying XML language sources and SQL was presented as an example of a query language for querying relational databases. The techniques are in no way limited to those query languages. Any other query language may be used. [0150]       The techniques described herein present unique solutions for efficient evaluation of queries using translation. The techniques, however, are not limited to queries made on markup languages data sources. In other embodiments, any query language may be used. Queries in the query language may then be parsed and compiled into first form of in-memory representation. The first form of in-memory representation may then be converted into a second form of in-memory representation and processed further as described above. [0151]       The techniques described herein provide that the various formats of queries are first parsed and compiled into ASTs or other in-memory representations. These in-memory representations are then converted to a particular abstract syntax. In other embodiments, the elements of a query in a first syntax (e.g. XQuery) are parsed, compiled, and immediately converted to the particular format element-by-element. In the embodiment, there may not necessarily exist, at any particular time, an in-memory representation of the entire portion of the query in the first format.<br><br>
7.0       HARDWARE OVERVIEW<br>
[0152]       FIG. 3 is a block diagram that illustrates a computer system 300 upon which an embodiment of the invention may be implemented. Computer system 300 includes a bus 302 or other communication mechanism for communicating information, and a processor 304 coupled with bus 302 for processing information. Computer system 300 also includes a main memory 306, such as a random access memory (RAM) or other dynamic storage device, coupled to bus 302 for storing information and instructions to be executed by processor 304. Main memory 306 also may be used for storing temporary variables or other intermediate information during execution of instructions to be executed by processor 304. Computer system 300 further includes a read only memory (ROM) 308 or other static storage device coupled to bus 302 for storing static information and instructions for processor 304. A storage device 310, such as a magnetic disk or optical disk, is provided and coupled to bus 302 for storing information and instructions.<br>
[0153]       Computer system 300 may be coupled via bus 302 to a display 312, such as a cathode ray tube (CRT), for displaying information to a computer user. An input device 314, including alphanumeric and other keys, is coupled to bus 302 for communicating information and command selections to processor 304. Another type of user input device is cursor control 316, such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor 304 and for controlling cursor movement on display 312. This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.<br>
[0154]       The invention is related to the use of computer system 300 for implementing the techniques described herein. According to one embodiment of the invention, those<br><br>
techniques are performed by computer system 300 in response to processor 304 executing one or more sequences of one or more instructions contained in main memory 306. Such instructions may be read into main memory 306 from another machine-readable medium, such as storage device 310. Execution of the sequences of instructions contained in main memory 306 causes processor 304 to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software. [0155]       The term "machine-readable medium" as used herein refers to any medium that participates in providing instructions to processor 304 for execution. Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media. Non-volatile media includes, for example, optical or magnetic disks, such as storage device 310. Volatile media includes dynamic memory, such as main memory 306. Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus 302. Transmission media can also take the form of acoustic or light waves, such as those generated during radio-wave and infrared data communications. [0156]       Common forms of machine-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punchcards, papertape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read. [0157]       Various forms of machine-readable media may be involved in carrying one or more sequences of one or more instructions to processor 304 for execution. For example, the instructions may initially be carried on a magnetic disk of a remote computer. The remote<br><br>
computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system 300 can receive the data on the telephone line and use an infrared transmitter to convert the data to an infrared signal. An infrared detector can receive the data carried in the infrared signal and appropriate circuitry can place the data on bus 302. Bus 302 carries the data to main memory 306, from which processor 304 retrieves and executes the instructions. The instructions received by main memory 306 may optionally be stored on storage device 310 either before or after execution by processor 304.<br>
[0158]       Computer system 300 also includes a communication interface 318 coupled to bus 302. Communication interface 318 provides a two-way data communication coupling to a network link 320 that is connected to a local network 322. For example, communication interface 318 may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface 318 may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface 318 sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.<br>
[0159]       Network link 320 typically provides data communication through one or more networks to other data devices. For example, network link 320 may provide a connection through local network 322 to a host computer 324 or to data equipment operated by an Internet Service Provider (ISP) 326. ISP 326 in turn provides data communication services through the world wide packet data communication network now commonly referred to as the "Internet" 328. Local network 322 and Internet 328 both use electrical, electromagnetic<br><br>
or optical signals that carry digital data streams. The signals through the various networks and the signals on network link 320 and through communication interface 318, which carry the digital data to and from computer system 300, are exemplary forms of carrier waves transporting the information.<br>
[0160]       Computer system 300 can send messages and receive data, including program code, through the network(s), network link 320 and communication interface 318. In the Internet example, a server 330 might transmit a requested code for an application program through Internet 328, ISP 326, local network 322 and communication interface 318. [0161]       The received code may be executed by processor 304 as it is received, and/or stored in storage device 310, or other non-volatile storage for later execution. In this manner, computer system 300 may obtain application code in the form of a carrier wave. [0162]       In the foregoing specification, embodiments of the invention have been described with reference to numerous specific details that may vary from implementation to implementation. Thus, the sole and exclusive indicator of what is the invention, and is intended by the applicants to be the invention, is the set of claims that issue from this application, in the specific form in which such claims issue, including any subsequent correction. Any definitions expressly set forth herein for terms contained in such claims shall govern the meaning of such terms as used in the claims. Hence, no limitation, element, property, feature, advantage or attribute that is not expressly recited in a claim should limit the scope of such claim in any way. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.<br><br>
CLAIMS<br>
A method of processing a query, comprising:<br>
receiving the query, wherein the query specifies certain operations: determining that the query comprises a first portion that specifies first one or more of the certain operations in a first query language and a second portion that specifies seeond one or more of the certain operations in a second query language: generating a first in-memory representation for the first portion: generating a second in-memory representation for the second portion, wherein the second in-memory representation represents at least one query element, supported by the seeond query language, that is not understood by a query processor for the first query language: prior to performing any of the certain operations, generating a third in-memory<br>
representation of the query based on the first ui-inemory representation and a fourth in-memory representation, wherein the third in-memory representation specifies all of the certain operations, and wherein generating the third in-memory representation comprises:<br>
generating the fourth in-memory representation based on the second in-memory representation, wherein the fourth in-memory representation represents only query elements that are supported by the first query language and understood by the query processor for the first query lanuuaue: and performing the certain operations based on the third in-memory representation.<br>
2.	The method of Claim 1. wherein the first in-memory representation and the third<br>
in-memory representation are formatted in a first abstract syntax and the second in-memorv representation is formatted in a second abstract syntax, and wherein the fourth in-memory representation is formatted in the first abstract syntax.<br><br>
3.	The method of Claim 2. wherein the second in-memory representation comprises one<br>
or more in-memory representations of query elements in the second abstract syntax, and wherein generating the fourth in-memory representation comprises:<br>
determining a second set of one or more equivalent in-memory representations of query elements in the first abstract syntax for the one or more in-memory representations of query elements in the second abstract syntax: and generating the fourth in-memory representation in the Jlrst abstract syntax based on the second set of one or more equivalent in-memory representations of query elements in the first abstract syntax.<br>
4.	The method of Claim 3. wherein each in-memory representation of query elements in the one or more in-memory representations of query elements in the second abstract syntax corresponds to one or more in-memory representations of query elements in the second set of one or more equivalent in-memory representations of query elements in the first abstract syntax.<br>
5.	The method of Claim 1  wherein one or more of the first in-memory representation, the second in-memory representation, and the third in-memory representation are represented in memory as abstract syntax trees.<br>
6.	The method of Claim 1. wherein the first query language is Structured Querv<br>
Language.<br>
7.	The method of Claim 1. where in the second query language is a markup query<br>
language.<br>
K.	The method of Claim I. wherein the second query language is XQuery.<br>
c).	The method of Claim L wherein the second query language is XQueryX.<br><br>
10).        The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract svmax and the second abstract syntax is an XQuery-related abstract syntax: wherein the second portion comprises an X Query aggregation in the second abstract syntax: and wherein the step of generating the fourth in-memory representation comprises generating an SQL subquen in the first abstract syntax to compute the aggregation, said SQL subquery being generated based on the XQuery aggregation in the second abstract syntax.<br>
1 1.       The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax: wherein the second portion comprises a literal expression in the second abstract syntax: and wherein the slep of generating the fourth in-memory representation comprises generating an SQL literal in the first abstract syntax based on the literal expression in the second abstract syntax.<br>
12.       The method of Claim 2, wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax: wherein the second portion comprises an XQuery cast expression in the second abstract syntax; and wherein the step of generating the fourth in-memory representation comprises generating one of an SQL cast function and an SQL convert function in the first abstract syntax based on the XQuery cast expression in the second abstract syntax.<br>
1 3.        The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax; wherein the second portion comprises a set expression in the second abstract syntax: and wherein the step of generating the fourth in-memory representation comprises generating one of an SQL I INION. an SqL MINI !S. and an SQL INTLRSLCT in the first abstract syntax based on the set expression in the second abstract syntax.<br>
14.       The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract s\ntax and the second abstract syntax is an XQuery-related abstract syntax: wherein the second porlion comprises an XQuery arithmetic expression in the second abstract syntax: and wherein the step of generating the fourth in-memorv representation comprises generating an<br><br>
SOL arithmetic expression in the first abstract syntax based on the XQuery arithmetic expression in the second abstract syntax.<br>
1 5.	i he method of Claim 2. wherein the first abstract syntax is an SQL-related abstract<br>
s\nlax and the second abstract syntax is an XQuery-related abstract syntax; wherein the second portion comprises an XQuery comparison in the second abstract syntax: and wherein the step of generating the fourth in-memory representation comprises generating an SQL comparison in the first abstract syntax based on the XQuery comparison in the second abstract syntax.<br>
16.       The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax: wherein the second portion comprises an XQuery FLWOR order by clause in the second abstract syntax: and wherein the step of generating the fourth in-memory representation comprises generating an SQL order by clause in the first abstract syntax based on the XQuery FLWOR order by clause in the second abstract syntax.<br>
1 7.       The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax: wherein the second portion comprises an XML logical expression in the second abstract syntax: and wherein the step of generating the fourth in-memory representation comprises generating an SQL logical expression element in the first abstract syntax based on the XML logical expression in the second abstract syntax.<br>
1 X.	The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract<br>
syntax and the second abstract syntax is an XQuery-related abstract syntax: wherein the second portion comprises an XML FLWOR expression in the second abstract syntax: and wherein the step of generating the fourth in-memory representation comprises generating an SQL select expression element in the first abstract syntax based on the XML FLWOR expression in the second abstract syntax.<br><br>
19).       The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax: wherein the second portion comprises an XML Path expression in the second abstract syntax; and wherein the step of generating the fourth in-memory representation comprises generating an SQL path expression in the first abstract syntax based on the XML Path expression in the seeond abstract syntax.<br>
20.	The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax; wherein the second portion comprises an XML if-then-else expression in the second abstract syntax; and wherein the step of generating the fourth in-memory representation comprises generating an SQL case-when expression in the first abstract syntax based on the XML if-then-else expression in the second abstract syntax.<br>
21.	The method of Claim 2, wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax; wherein the second portion comprises an XML quantified expression in the second abstract syntax: and v\ herein the step of generating the fourth in-memory representation comprises generating an SQL Exists expression in the first abstract syntax based on the XML quantilled expression in the second abstract syntax.<br>
22.	The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax: wherein the second portion comprises an SQL / XML construction expression in the second abstract syntax; and w herein the step of generating the fourth in-memory representation comprises generating an SQL construction expression in the first abstract syntax based on the SQL/ XML construction expression in the second abstract syntax.<br>
2.T        The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax: wherein the second portion comprises an XML operator in the second abstract syntax; and wherein the<br><br>
step of generating the fourth in-memory representation comprises generating an SQL operator in the first abstract syntax based on the XML operator in the second abstract syntax.<br>
24.	!lie method of Claim 2. wherein the first abstract syntax is an SQL-related abstract<br>
syntax and the second abstract syntax is an XQuery-related abstract syntax: wherein the second portion comprises an XQuery sequence type operation in the second abstract syntax; and wherein the step of generating the fourth in-memory representation comprises generating an SQL type operation in the first abstract syntax based on the XQuery sequence type operation in the second abstract syntax.<br>
25.	The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax; wherein the second portion comprises an XQuery type constructor in the second abstract syntax: and wherein the step of generating the fourth in-memory representation comprises generating an SQL scalar constructor in the first abstract syntax based on the XQuery type constructor in the second abstract syntax.<br>
26.	The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax; wherein the second portion comprises an XQuery validate operation in the second abstract syntax: and wherein the step of generating the fourth in-memory representation comprises generating one of an SQL/XML Is V' alicl operation and an SQL/XML Validate operation in the first abstract syntax based on the XQuery validate operation in the second abstract syntax.<br>
27.	The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax: wherein the second portion comprises a polymorphic XQuery arithmetic operator in the second abstract syntax: and wherein the step of generating the fourth in-memory representation comprises generating a polymorphic SQL arithmetic operator in the first abstract syntax based on the polymorphic XQuery arithmetic operator in the second abstract syntax.<br><br>
28.	The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract<br>
syntax and the second abstract syntax is an XQuery-related abstract syntax; wherein the<br>
second portion comprises a polymorphic XQuery comparison operator in the second abstract<br>
syntax; and wherein the step of generating the fourth in-memory representation comprises<br>
generating a polymorphic SQL value comparison operator in the first abstract syntax based<br>
on the polymorphic XQuery comparison operator in the second abstract syntax.<br>
29.	The method of Claim 2. wherein the first abstract syntax is an SQL-relaied abstract<br>
syntax and the second abstract syntax is an XQuery-related abstract syntax; wherein the<br>
second portion comprises an XQuery function call in the second abstract syntax: and wherein<br>
the step of generating the fourth in-memory representation comprises generating an SQL<br>
function call in the first abstract syntax based on the XQuery function call in the second<br>
abstract syntax.<br>
30.	The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax; wherein the second portion comprises a user-defined XQuery function in the second abstract syntax; and wherein the step generating the fourth in-memory representation comprises generating a user-defined PL/SQL function in the first abstract syntax based on the user-defined XQuery function in the second abstract syntax.<br>
31.	The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax; wherein the second portion comprises an external XQuery function in the second abstract syntax; and wherein the slep of generating the fourth in-memory representation comprises generating an external SQL function in the first abstract syntax based on the external XQuery function in the second abstract syntax.<br>
32.	The method of Claim 2. wherein the first abstract syntax is an SQL-related abstract syntax and the second abstract syntax is an XQuery-related abstract syntax: wherein the second portion comprises an XQuery module in the second abstract syntax; and wherein the<br><br>
step of generating the fourth in-memory representation comprises generating a PL/SQL package in the first abstract syntax based on the XQuery module in the second abstract syntax.<br>
33)       A method of processing a query comprising:<br>
receiving the query, wherein the query specifies certain operations and is querying data stored in a markup language:<br>
generating a first in-memory representation of the query, wherein the first in-memory representation represents at least one query element that is not understood by a relational query processor:<br>
prior to performing any of the certain operations, generating a second in-memory<br>
representation based on the first in-memory representation, wherein the second in-memory representation is in the same form as would have been produced by processing an equivalent query that is querying a relational database, wherein the second in-memory representation does not represent any query elements that are not understood by the relational query processor, and wherein the second in-memory representation specifies all of the certain operations: and performing the certain operations based on the second in-memory representation.<br>
34.	The method of Claim 33. wherein the step of performing the certain operations<br>
comprises performing the certain operations by executing commands specified in the second<br>
m-memon representation against the relational database.<br>
35.	A computer-readable medium carrying one or more sequences of instructions which,<br>
when executed by one or more processors, causes the one or more processors lo perform the<br>
method recited in any one of Claims 1-34.<br><br></po></po></expr></expr></type></expr></expr></type></expr></type></expr></type></expr></type></expr></type></expr></typel></exprl></typel></exprl></typel></exprl></exprn></expr2></type2></expr></exprl></typel></expr></expr></exprn></expr2></type2></var2></exprl></typel></varl></expr></expr3></expr2></exprl></expr3></expr2></exprl></filterexpr></expr></filterexpr></step></expr></type></step></expr></type></step></expr></namespace></localname></step></expr></qname-or-wildcard></step></expr></cond-referencing-var3></expr2></exprl></expr3></expr4-referencing-var3></expr4-refecencing-var3></cond-not-referencing-var3></expr3></var3></expr2></var2></exprl></varl></cond-referencing-var3></expr2></exprl></expr3></expr4></expr4></cond-referencing-var3></expr3></var3></expr2></var2></exprl></varl></cond-referencing-var3></expr2></exprl></expr4></expr4></cond-referencing-var3></expr3></var3></expr2></var2></exprl></varl></type></expr></var></expr></type></var></sql-on></sql-o2></sql-ol></sql-cond></sql-rhs-expr2></sql-rhs-exprl></sql-ret-expr></ret-expr></on></o2>
</ol></cond-expression></rhs-expr2></var2></rhs-exprl></var></expr></expr></expr></expr></expr></expr></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgICBBU1NJR05NRU5UICAgMTItMDgtMjAxMy5wZGY=" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006     ASSIGNMENT   12-08-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgICBGT1JNLTEgICAgMTItMDgtMjAxMy5wZGY=" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006     FORM-1    12-08-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgICBGT1JNLTMgICAxMi0wOC0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006     FORM-3   12-08-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgICBGT1JNLTUgIDEyLTA4LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006     FORM-5  12-08-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgIEFNRU5ERUQgICBDTEFJTVMgICAgMTItMDgtMjAxMy5wZGY=" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006    AMENDED   CLAIMS    12-08-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgIEFNRU5ERUQgIFBBR0VTICAgT0YgU1BFQ0lGSUNBVElPTiAgIDEyLTA4LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006    AMENDED  PAGES   OF SPECIFICATION   12-08-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgIENPUlJFU1BPTkRFTkNFICBPVEhFUlMgIDI1LTA3LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006    CORRESPONDENCE  OTHERS  25-07-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgIEVYQU1JTkFUSU9OICBSRVBPUlQgUkVQTFkgUkVDRUlWRUQgICAxMi0wOC0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006    EXAMINATION  REPORT REPLY RECEIVED   12-08-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgIE9USEVSICAgUEFURU5UICBET0NVTUVOVCAgICAxMi0wOC0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006    OTHER   PATENT  DOCUMENT    12-08-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgIE9USEVSUyAgIDI5LTExLTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006    OTHERS   29-11-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgIFBPV0VSICAgT0YgQVRUT1JORVkgIDEyLTA4LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006    POWER   OF ATTORNEY  12-08-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgQU1FTkRFRCBDTEFJTVMgICAyOS0xMS0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006   AMENDED CLAIMS   29-11-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgQU1FTkRFRCBDTEFJTVMgIDAxLTAxLTIwMTQucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006   AMENDED CLAIMS  01-01-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgQ09SUkVTUE9OREVOQ0UgT1RIRVJTICAgMjktMTEtMjAxMy5wZGY=" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006   CORRESPONDENCE OTHERS   29-11-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgQ09SUkVTUE9OREVOQ0UgT1RIRVJTIDE3LTA0LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006   CORRESPONDENCE OTHERS 17-04-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgRVhBTUlOQVRJT04gUkVQT1JUIFJFUExZIFJFQ0VJVkVEICAwMS0wMS0yMDE0LnBkZg==" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006   EXAMINATION REPORT REPLY RECEIVED  01-01-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgT1RIRVIgUEFURU5UIERPQ1VNRU5UICAwMS0wMS0yMDE0LnBkZg==" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006   OTHER PATENT DOCUMENT  01-01-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgUE9XRVIgT0YgQVRUT1JORVkgICAyOS0xMS0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006   POWER OF ATTORNEY   29-11-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICAgUE9XRVIgT0YgQVRUT1JORVkgIDI4LTExLTIwMTQucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006   POWER OF ATTORNEY  28-11-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICBBTUVOREVEIENMQUlNUyAgMjgtMTEtMjAxNC5wZGY=" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006  AMENDED CLAIMS  28-11-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICBBTUVOREVEIFBBR0VTIE9GIFNQRUNJRklDQVRJT04gIDI4LTExLTIwMTQucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006  AMENDED PAGES OF SPECIFICATION  28-11-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICBDT1JSRVNQT05ERU5DRSBPVEhFUlMgIDA3LTEyLTIwMTAucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006  CORRESPONDENCE OTHERS  07-12-2010.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICBFWEFNSU5BVElPTiBSRVBPUlQgUkVQTFkgUkVDRUlWRUQgIDI4LTExLTIwMTQucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006  EXAMINATION REPORT REPLY RECEIVED  28-11-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICBFWEFNSU5BVElPTiBSRVBPUlQgUkVQTFkgUkVDRUlWRUQgMDEtMTItMjAxNC5wZGY=" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006  EXAMINATION REPORT REPLY RECEIVED 01-12-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICBGT1JNLTEgIDA3LTEyLTIwMTAucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006  FORM-1  07-12-2010.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1jaGVucC0yMDA2ICBmb3JtLTEgMTAtMDUtMjAxMC5wZGY=" target="_blank" style="word-wrap:break-word;">4734-chenp-2006  form-1 10-05-2010.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICBGT1JNLTEzICAwNy0xMi0yMDEwLnBkZg==" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006  FORM-13  07-12-2010.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICBGT1JNLTEzICAxMC0wNS0yMDEwLnBkZg==" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006  FORM-13  10-05-2010.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICBGT1JNLTE4ICAwNi0wNS0yMDA4LnBkZg==" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006  FORM-18  06-05-2008.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICBGT1JNLTMgIDA4LTA1LTIwMDcucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006  FORM-3  08-05-2007.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICBGT1JNLTMgIDIxLTA2LTIwMDcucGRm" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006  FORM-3  21-06-2007.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1DSEVOUC0yMDA2ICBQT1dFUiBPRiBBVFRPUk5FWSAgMTAtMDUtMjAxMC5wZGY=" target="_blank" style="word-wrap:break-word;">4734-CHENP-2006  POWER OF ATTORNEY  10-05-2010.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1jaGVucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">4734-chenp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1jaGVucC0yMDA2LWFzc2lnbmVtZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">4734-chenp-2006-assignement.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1jaGVucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">4734-chenp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1jaGVucC0yMDA2LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">4734-chenp-2006-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1jaGVucC0yMDA2LWRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">4734-chenp-2006-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1jaGVucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">4734-chenp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1jaGVucC0yMDA2LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">4734-chenp-2006-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1jaGVucC0yMDA2LWZvcm0gMjYucGRm" target="_blank" style="word-wrap:break-word;">4734-chenp-2006-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1jaGVucC0yMDA2LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">4734-chenp-2006-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1jaGVucC0yMDA2LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">4734-chenp-2006-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDczNC1jaGVucC0yMDA2LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">4734-chenp-2006-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="264535-transducer-detection-method-and-system-for-ibp-monitor.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="264537-method-and-device-for-measuring-circulation-quantity-of-bed-material-in-circulating-fluidized-bed-combustor.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>264536</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>4734/CHENP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>02/2015</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>09-Jan-2015</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>02-Jan-2015</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>22-Dec-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>ORACLE INTERNATIONAL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>500 ORACLE PARKWAY, REDWOOD SHORES, CA 94065, USA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>LIU, MEN, HUA</td>
											<td>1017 WAYNE WAY, SAN MATEO, CA 94403, USA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>ARORA, VIKAS</td>
											<td>8 LOCKSLEY AVENUE, #4F, SAN FRANCISCO, CA 94122, USA</td>
										</tr>
										<tr>
											<td>3</td>
											<td>KOTSOVOLOS, SUSAN, M.</td>
											<td>1319 EATON AVENUE , SAN CARLOS, CA 94070, USA</td>
										</tr>
										<tr>
											<td>4</td>
											<td>KRISHNAPRASAD, MURALIDHAR</td>
											<td>34136 SUMMERWIND TERRACE, FREMONT, CA 94555, USA</td>
										</tr>
										<tr>
											<td>5</td>
											<td>MANIKUTTY, ANAND</td>
											<td>764 MARLIN AVENUE, APT. 4, FOSTER CITY, CA 94404, USA</td>
										</tr>
										<tr>
											<td>6</td>
											<td>WARNER, JAMES</td>
											<td>280 EASY STREET, #309, MOUNTAIN VIEW, CA 94043, USA</td>
										</tr>
										<tr>
											<td>7</td>
											<td>ZHANG, HUI, X</td>
											<td>34290 KENWOOD DRIVE, FREMONT, CA 94555, USA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 17/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US05/21259</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-06-09</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/582,706</td>
									<td>2004-06-23</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>10/948,523</td>
									<td>2004-09-22</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/264536-efficient-evaluation-of-queries-using-translation by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:50:20 GMT -->
</html>
