<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/218376-a-process-device-for-identifying-candidate-virtual-addresses-for-prefetching by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:46:48 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 218376:A PROCESS DEVICE FOR IDENTIFYING CANDIDATE VIRTUAL ADDRESSES FOR PREFETCHING</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A PROCESS DEVICE FOR IDENTIFYING CANDIDATE VIRTUAL ADDRESSES FOR PREFETCHING</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A process device for identifying candidate virtual addresses for prefetching, comprising:- - a processing unit - a cache memory, the cache memory to receive fill content requested by a processing unit, the fill content including a cache line; - a content prefetcher coupled with the cache memory, the content prefetcher to receive a copy of the cache line; - a virtual address predictor associated with the content prefetcher, the virtual address predictor to retrieve an effective address from the cache line; - read an address-sized word from the cache line, the cache line including a number of address-sized words; - compare an upper n bits of the address-sized word with an upper N bits of the effective address of the cache line; and - if the upper N bits of the address-sized word match the upper N bits of the effective address, identify the address-sized word as a candidate virtual address and generate a prefetch request for the candidate virtual address; and - an arbiter coupled with the content prefetcher, the arbiter to issue a prefetch request for the candidate virtual address.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>[0001]       This application is related to application no. XX/XXX,XXX, entitled "Method	<br>
and Apparatus for Content-Aware Prefetching", filed concurrently herewith.	<br>
FIELD OF THE INVENTION [0002]       The invention relates generally to processors and, more particularly, to a method and apparatus for content-aware prefetching.<br>
BACKGROUND OF THE INVENTION [0003]       A conventional processor typically operates at a much faster speed than the main memory to which the processor is coupled. To overcome the inherent latency of main memory, which usually comprises dynamic random access memory (DRAM), a memory hierarchy is employed. The memory hierarchy includes one or more levels of cache, each cache comprising a relatively fast memory device or circuitry configured to hold data recently accessed - or expected to be accessed - by the processor. The purpose of the cache is to insure most data needed by a processor is readily available to the processor without accessing the main memory, as the process of accessing main memory is very slow in comparison to the speed of the processor or the speed at which the processor can access a cache.<br>
[0004]       Typically, a memory hierarchy comprises multiple levels of cache, wherein each level is faster than next lower level and the level closest to the processor exhibits the highest speed and performance. A cache may be located on the processor itself- i.e., an "on-chip" cache - or a cache may comprise an external memory device - i.e., an "off-<br>
chip" cache. For example, a processor may include a high level on-chip cache - often times referred to as an "L1" cache - wherein the processor is coupled with a lower level off-chip cache - which is often referred to as an "L2" cache. Alternatively, a processor may include an on-chip L1 cache, as well as an on-chip L2 cache. Of course, a memory hierarchy may include any suitable number of caches, each of the caches located on-chip or off-chip.<br>
[0005]       As noted above, each level of cache may hold data recently accessed by the processor, such recently accessed data being highly likely - due to the principles of temporal and spatial locality -to be needed by the processor again in the near future. However, system performance may be further enhanced - and memory latency reduced -by anticipating the needs of a processor. If data needed by a processor in the near future can be predicted with some degree of accuracy, this data can be fetched in advance - or "prefetched" - such that the data is cached and readily available to the processor. Generally, some type of algorithm is utilized to anticipate the needs of a processor, and the value of any prefetching scheme is dependent upon the degree to which these needs can be accurately predicted.<br>
[0006]       One conventional type of prefetcher is commonly known as a "stride" prefetcher. A stride prefetcher anticipates the needs of a processor by examining the addresses of data requested by the processor - i.e., a "demand load" - to determine if the requested addresses exhibit a regular pattern. If me processor (or an application executing thereon) is stepping through memory using a constant offset from address to address - i.e., a constant stride - the stride prefetcher attempts to recognize this constant stride and prefetch data according to this recognizable pattern. Stride prefetchers do, however, exhibit a significant drawback. A stride prefetcher does not function well when the<br>
address pattern of a series of demand loads is irregular - i.e., there is not a constant stride - such as may occur during dynamic memory allocation.<br>
[0007]       Another method of data prefetching utilizes a translation look-aside buffer (TLB), which is a cache for virtual-to-physical address translations. According to this method, the "fill contents" - i.e., the requested data- associated with a demand load are examined and, if an address-sized data value matches an address contained in the TLB, the data value likely corresponds to a "pointer load" - i.e., a demand load in which the requested data is an address pointing to a memory location - and is, therefore, deemed to be a candidate address. A prefetch request may then be issued for the candidate address. Because the contents of the requested data - as opposed to addresses thereof- are being examined, this method may be referred to as content-based, or content-aware, prefetching. Such a content-aware prefetching scheme that references the TLB (or, more generally, that references any external source or index of addresses) has a significant limitation: likely addresses are limited to those cached in the TLB, and this constraint significantly reduces the number of prefetch opportunities. Also, this content-aware prefetching scheme requires a large number of accesses to the TLB; thus, additional ports must be added to the TLB to handle the content prefetcher overhead.<br>
BRIEF DESCRIPTION OF THE DRAWINGS [0008]      FIG. 1 is a schematic diagram of an exemplary embodiment of a system including a processor having a content prefetcher.<br>
[0009]       FIG. 2 is a schematic diagram of an exemplary embodiment of a processor including an embodiment of a content prefetcher having a virtual address predictor. [0010]       FIG. 3 is a flow chart illustrating an embodiment of a method of content-aware prefetching.<br>
[0011]       FIG. 4 is a flow chart illustrating another embodiment of the method of<br>
content-aware prefetching.<br>
[0012]       FIG. 5 is a flow chart illustrating a further embodiment of the method of<br>
content-aware prefetching.<br>
[0013]       FIG. 6 is a flow chart illustrating an embodiment of a method of identifying<br>
candidate virtual addresses.<br>
[0014]       FIGS. 7 through 9 are schematic diagrams, each further illustrating the method<br>
shown in FIG. 6.<br>
[0015]       FIG. 10 is a schematic diagram illustrating an embodiment of a process for<br>
comparing an address-sized word in a cache line with the cache line"s effective address.<br>
[0016]       FIG. 11 is a flow chart illustrating another embodiment of the method of<br>
identifying candidate virtual addresses.<br>
[0017]       FIG. 12 is a schematic diagram illustrating another embodiment of the process<br>
for comparing an address-sized word in a cache line an effective address thereof.<br>
[0018]       FIG. 13 is a flow chart illustrating a farther embodiment of the method of<br>
identifying candidate virtual addresses.<br>
DETAILED DESCRIPTION OF THE INVENTION [0019]      Referring to FIG. 1, a system 100 includes a bus 110 having a processor 200 coupled therewith. The processor 200 may comprise any suitable processing device or circuitry. In one embodiment, as will be discussed below, the processor 200 includes only on-chip cache. However, in an alternative embodiment, the processor 200 may include off-chip cache 170 - which may be provided alone or in combination with on-chip cache -coupled with the processor 200.<br>
[0020]       A main memory 120 is coupled with the bus 110, the main memory 120 comprising, for example, dynamic random access memory (DRAM). The main memory 120 may contain data and/or instructions to be used by the processor 200 while executing an application. A read only memory (ROM) 130 may also be coupled with the bus 110. The ROM 130 may store instructions for execution on processor 200. Further, a data storage device 140, such as a hard disk drive or other suitable non-volatile memory, may be coupled with the bus 110.<br>
[0021]       The system 100 may also include one or more output devices 150 coupled with the bus 110. Common output devices 150 include video monitors, printers, and audio output devices (e.g., a sound card and/or speakers). The system 100 may further include one or more input devices 160 coupled with the bus 110. Typical input devices include keyboards, pointing devices such as a mouse, as well as scanners and other data entry devices. It should be understood that the system 100 may include other components in addition to those illustrated in FIG. 1, which have been omitted for clarity, including a removable storage media (e.g., floppy disk drive, CD-ROM drive), a network interface, a chip set coupled with the processor, as well as additional signal lines and busses. [0022]       Referring now to FIG. 2, the processor 200 includes a CPU (central processing unit) core 210. Coupled with the CPU core 210 is a first level on-chip cache, or "LI cache," 220. A second level on-chip cache, or "L2 cache," 230 is also disposed in the processor 200. An arbiter, which will be referred to herein as the "L2 arbiter" 240, is coupled with each of the L1 and L2 caches 220,230. Another arbiter, which will be referred to herein as the "bus arbiter" 250, is coupled with the L2 cache. The bus arbiter 250 is also coupled with a bus interface unit 260. The bus interface unit 260 couples the processor 200 with bus 110, thereby enabling communication between processor 200 and<br>
main memory 120. The L1 and L2 caches 220, 230 may each comprise any suitable type of memory or circuitry.<br>
[0023]       The L1 cache 220 and L2 cache 230, in conjunction with main memory 120, provide a memory hierarchy for CPU core 210. Generally, the L1 cache 220 exhibits the highest speed relative to the CPU core 210, whereas the main memory 120 exhibits the lowest relative speed. The L2 cache 230 operates much faster than the main memory 120, but may be slower than LI cache 220. The data storage device 140 (see FIG. 1) may also be considered a part of the memory hierarchy, the data storage device 140 being the slowest element in the hierarchy. Each of the L1 and L2 caches 220, 230 store data and/or instructions recently accessed, or expected to be accessed, by CPU core 210. [0024]      During operation, if the CPU core 210 request data - i.e., a "demand load" or a "demand request" - the L1 cache 220 is accessed to determine whether it contains the requested data and, if so, the data is provided to the CPU core 210. If the L1 cache 220 does not contain the requested data- i.e., a "cache miss" - the demand request is passed to the L2 arbiter 240. The L2 arbiter 240 then provides the demand request to the L2 cache 230, and the L2 cache 230 is accessed to determine whether it contains the requested data. If the L2 cache 230 contains the requested data, the requested data - i.e., the "fill content" - is forwarded to the L1 cache 220 and on to the CPU core 210. If the demand load is not met by the L2 cache 230, the load is passed to the bus arbiter 250. The bus arbiter 250 will transmit the demand request off-chip to main memory 120. If the main memory 120 holds the requested data, the fill content is passed up the memory hierarchy to the CPU core 210. If the main memory 120 can not satisfy the demand request, data storage device 140 may be accessed. Each of the L2 and bus arbiters 240,250 includes a buffer memory, and the L2 and bus arbiters 240, 250 may buffer a demand request if multiple loads are in<br>
progress. During memory request arbitration, the L2 and bus arbiters 240, 250 may also buffer prefetch requests, as will be explained below.<br>
[0025]       A process executing in CPU core 210 may access a virtual address space. Typically, such a virtual address space is maintained by a memory management unit, or MMU (not shown in figures). To access virtually addressed data, the virtual address (or addresses) must be mapped to a physical address - i.e., an actual location in main memory 120. Thus, it should be understood that, as data traverses the memory hierarchy, the data may undergo a virtual-to-physical address translation. For example, the L1 cache 220 may be virtually indexed and the L2 cache 230 physically indexed; therefore, if there is a cache miss at LI cache 220, a virtual-to-physical address translation is required before accessing the L2 cache 230.<br>
[0026]       As suggested above, system performance can be enhanced by anticipating the needs of CPU core 210 and prefetching any data that is likely to be imminently requested by the CPU core 210. The processor 200 may include a stride prefetcher 270 coupled with the L2 arbiter 240 and L2 cache 230. The stride prefetcher 270 monitors the L1 miss traffic - i.e., demand loads that have missed at LI cache 220 - as well as the L2 miss traffic - i.e., demand loads that have missed at L2 cache 230 - and attempts to detect a constant stride in the requested addresses. If a constant stride is detected, prefetch (PF) requests are provided to the L2 arbiter 240 based upon the detected stride. However, as suggested above, the stride prefetcher 270 does not function adequately when the address pattern of successive demand requests is irregular and there is not a constant stride (e.g., which may occur during dynamic memory allocation).<br>
[0027]       The processor 200 also includes a novel content prefetcher 290. The content prefetcher 290 is coupled with the L2 cache 230 and receives a copy of all fill content directed to L2 cache 230, the fill content including one or more cache lines. More<br>
generally, however, the content prefetcher 290 may be coupled with any level in the<br>
memory hierarchy of a processor and receives a copy of all fill content directed thereto.<br>
Further, although the content prefetcher 290 of processor 200 is coupled with an on-chip<br>
L2 cache 230, it should be understood that the content prefetcher 290 may also be coupled<br>
with an off-chip cache, such as the off-chip cache 170 illustrated in FIG. 1. The content<br>
prefetcher 290 is also coupled with the L2 arbiter 240.<br>
[0028]      The content prefetcher 290 includes a virtual address predictor 295. As<br>
previously described, the content prefetcher 290 receives a copy of each cache line<br>
received at L2 cache 230. The virtual address predictor 295 examines a cache line and<br>
differentiates candidate virtual addresses from other data values and random bit patterns<br>
contained in the cache line without reference to any external address source - i.e., a TLB -<br>
which may unnecessarily constrain the range of potential address and, hence, the potential<br>
prefetch opportunities. The virtual address predictor 295 comprises any suitable circuitry<br>
and/or instructions capable of identifying candidate virtual addresses in a cache line based<br>
upon the data contained in the cache line itself, without accessing an external address<br>
reference.<br>
[0029]       Operation of the content prefetcher 290 and virtual address predictor 295 may<br>
be better understood with reference to a method 300 of content-aware prefetching shown<br>
in FIG. 3. Referring to reference numeral 310 in FIG. 3, fill content is received at L2<br>
cache 230. A copy of the fill content is provided to the content prefetcher 290, as denoted<br>
at 320. The fill content includes a cache line (or, alternatively, the fill content includes<br>
two or more cache lines). As shown at reference numeral 330, the cache line is scanned<br>
for candidate virtual addresses. If a candidate virtual address is identified by virtual<br>
address predictor 295 - see reference numeral 340 - the content prefetcher 290 generates a<br>
prefetch request corresponding to the identified candidate virtual address, as illustrated by<br><br>
reference numeral 350. The content prefetcher 290 then provides a the prefetch request to<br>
the L2 arbiter 240 - see reference numeral 360 - which may buffer and/or issue to main<br>
memory 120 a prefetch request based upon memory request arbitration, as will be<br>
described below.<br>
[0030]       The above-described process is continued until the entire cache line has be<br>
scanned. When the entire cache line has been scanned - see reference numeral 370 - and<br>
all candidate virtual addresses contained in the cache line identified, the scan of the cache<br>
line is complete, as shown at 380. As will be described in greater detail below, the entire<br>
cache line - or a portion thereof- may be scanned in parallel.<br>
[0031]       As described above, a copy of all fill content directed to the L2 cache 230 is<br>
provided to the content prefetcher 290. Thus, for each demand request issued by the CPU<br>
core 210 resulting in a cache miss at L2 cache 230 - or, more generally, resulting in a<br>
cache miss at the level of cache with which the content prefetcher 290 is coupled - the<br>
content prefetcher 290 will receive a copy of the requested data. The fill contents<br>
associated with demand requests that have missed at some level of cache in the memory<br>
hierarchy may be referred to as the "demand reference stream." However, other fill<br>
content will be directed to the L2 cache 230 as a result of prefetch requests issued by the<br>
L2 arbiter 240 (or bus arbiter 250) - i.e., the "prefetch reference stream" - and a copy of<br>
fill content associated with the prefetch reference stream is also provided to the content<br>
prefetcher 290. Thus, by examining fill content associated with the demand reference<br>
stream as well as that fill content associated with the prefetch reference stream, the content<br>
prefetcher 290 includes a recurrence component and may provide prefetch requests based<br>
upon prior prefetch requests. Such a recurrence component allows the content prefetcher<br>
290 to follow a recursive path within a data structure, such as a "linked data structure"<br>
(i.e., a data structure in which each element contains a pointer to the next element of the<br>
structure). A prefetch request provided by the content prefetcher 290 based upon a prior<br>
prefetch request may be referred to as a "chained" prefetch request.<br>
[0032}       When the L2 arbiter 240 receives a prefetch request from the content prefetcher<br>
290 - the prefetch request corresponding to a candidate virtual address identified by the<br>
virtual address predictor 295 - the L2 arbiter 240 may buffer the prefetch request and<br>
delay it issuance. Buffering of prefetch requests (as well as, in some instances, demand<br>
requests) in the L2 arbiter may be (and, in most instances, is) necessary due to the low<br>
bandwidth of bus 110 and the slow access speed of main memory 120. Accordingly, the<br>
L2 arbiter 240, as well as the bus arbiter 250, may implement a prioritizing scheme to<br>
determine which among multiple prefetch requests, as well as multiple demand requests,<br>
contained in its buffer should be issued first. This process of prioritizing memory requests<br>
and issuing demand or prefetch requests according to each request"s priority may be<br>
referred to as memory request arbitration.<br>
[0033]       Demand requests generally should be accorded the highest priority, as a<br>
demand request corresponds to data currently needed by the CPU core 210. Prefetch<br>
requests are generally accorded a priority lower than that of demand requests; however,<br>
not all prefetch requests in a recursive chain of prefetch requests are as likely to represent<br>
data imminently needed by the CPU core 210 - i.e., they are more speculative - and,<br>
therefore, should be assigned differing priorities. That the content prefetcher 290 provides<br>
a recursive component providing a chain of prefetches - the first in the chain based upon<br>
the fill content associated with a demand request and each successive prefetch request in<br>
the chain based upon the fill content resulting from a previous prefetch - leads to notion of<br>
a "request depth." If a demand request is, for example, assigned a request depth of zero<br>
(0), a prefetch request resulting from the fill content associated with a demand request is<br>
assigned a request depth of one (1), and each successive chained prefetch is assigned a<br>
request depth equal to one (1) more than the prefetch request upon which the chained prefetch request is based.<br>
[0034]       The above-described request depth provides a measure of confidence in a prefetch request and may be used by the L2 arbiter 240, as well as by the bus arbiter 250, during memory request arbitration to determine the priority of a prefetch request. Memory requests with the lowest request depth may be assigned the highest priority and issued first by the L2 arbiter 240 (or bus arbiter 250). Demand requests have a request depth of, for example, zero and are assigned the highest priority. Prefetch requests resulting from fill content associated with a demand load are assigned the next highest priority. A chained prefetch requests is assigned a priority commensurate with its request depth, the assigned priority inversely proportional to the request depth. Accordingly, chained prefetch requests exhibiting a higher request depth are assigned a lower priority, as they are likely to be more speculative. A chained prefetch request having a request depth greater than a predefined threshold - a threshold at which confidence in the prefetch request is low - are squashed and a prefetch request is not issued by an arbiter. Prefetch requests of the same priority (i.e., the same request depth) are scheduled for issuance by the L2 arbiter 240 (or bus arbiter 250) in a first-come-first-served manner.<br>
[0035]       A method 400 of content-aware prefetching and determining a priority of each prefetch request is illustrated in FIG. 4. It should be noted that the method 400 shown in FIG. 4 includes many elements identical to the method 300 of FIG. 3, and like elements retain the same reference numeral in FIG. 4.<br>
[0036]      Referring to reference numeral 310 in FIG. 4, fill content is received at L2 cache 230, and a copy of the fill content is provided to the content prefetcher 290 (see reference numeral 320). The fill content includes a cache line (or, alternatively, the fill content includes two or more cache lines). The cache line is then scanned for candidate<br><br>
virtual addresses, as denoted at 330. If a candidate virtual address is identified by virtual address predictor 295 - see reference numeral 340 - the content prefetcher 290 generates a prefetch request for that address, as shown at 350.<br>
[0037]       Referring now to reference numeral 410 in FIG. 4, the content prefetcher 290 determines a request depth of the prefetch request, as described above. If the request depth is greater than the predefined threshold - see reference numeral 420 - the prefetch request is squashed, as denoted at 440. If the request depth does not exceed the predefined threshold, a priority is assigned to the prefetch - see reference numeral 430 - wherein the priority is based upon the request depth, as previously described. [0038]      Once a priority is assigned to the prefetch request, the content prefetcher 290 provides the prefetch request to the L2 arbiter 240, as shown at 360. The L2 arbiter 240 enqueues the prefetch request in buffer memory pending memory request arbitration based upon the priority of each prefetch request held in its buffer. Again, demand requests have the highest priority and are issued first by the L2 arbiter 240 (and bus arbiter 250). Prefetch requests, which have a priority lower than demand requests, are issued by the L2 arbiter 240 (or bus arbiter 250) in accordance with their respective priority. Again, the priority of a prefetch request is based upon that prefetch request"s request depth. The process is continued until the entire cache line has been scanned and, when the entire cache line has been scanned (see reference numeral 370) and all candidate virtual addresses contained in the cache line identified, the scan of the cache line is complete, as shown at 380.<br>
[0039]       A further embodiment of a method 500 of content-aware prefetching is illustrated in FIG. 5. It should be noted that the method 500 shown in FIG. 5 includes many elements identical to the method 300 of FIG. 3, and like elements retain the same reference numeral in FIG. 5. Also, the method 500 of content-aware prefetching is similar<br>
to the method 300 illustrated in FIG. 3, and a detailed description of those elements previously described is not repeated.<br>
[0040]       Referring to reference numeral 510, if a candidate virtual address has been identified (see reference numeral 340), both of the L2 and bus arbiters 240,250 are polled to see if a matching memory request is currently in-flight - i.e., a memory request corresponding to the candidate virtual address has already been issued. If a matching memory request is in-flight, the prefetch request is squashed, as shown at reference numeral 530. In the event a prefetch request is squashed due to an in-flight memory request, scan of the cache line continues (see reference numerals 330, 370). [0041]       Prefetch requests are enqueued in a memory buffer of the L2 arbiter 240 (or bus arbiter 250) pending memory request arbitration, as previously described. In some instances, the L2 arbiter"s buffer may become full. If no buffer space is available in the L2 arbiter 240 - see reference numeral 520 - the prefetch request is squashed, as illustrated at reference numeral 530. In the event a prefetch request is squashed due to a lack of available buffer space, the scan of the cache line may continue - see reference numerals 330, 370 - as memory space may again become available in the L2 arbiter"s buffer.<br>
[0042]       As set forth above, the virtual address predictor 295 of content prefetcher 290 differentiates - without reference to an external address source, such as a TLB, which may limit the range of prefetch opportunities - candidate virtual addresses from data values and random bit patterns contained within a cache line. A method of identifying candidate virtual addresses, as may be implemented by virtual address predictor 295, is now disclosed. It should be noted that the method of identifying candidate virtual addresses "looks" for virtual addresses - as opposed to physical address - because likely addresses contained in fill content directed to the CPU core 210 are in the virtual address space, even<br>
though a virtual-to-physical address translation may have taken place within the memory hierarchy.<br>
[0043]       The method of identifying candidate virtual addresses is based on the premise that if a pointer load - i.e., a demand load in which the requested data is an address pointing to a memory location - is loaded from memory, there is a strong likelihood that the address of the pointer load will be the effective address of a future demand request. Central to this premise is the idea that the base address of a data structure is provided via a pointer load, and any data value within that structure that shares this base address can be interpreted as a pointer to another member of the same data structure. Assuming that all demand requests potentially include pointer loads, any address-sized word contained within a cache line returned in response to a demand request that shares this base address is deemed a candidate virtual address. If a number of upper bits of the address-sized word match the same number of upper bits in the effective address of the cache line, these matching upper bits suggests that the address-sized word and the effective address of the cache line were computed from the same base address and, therefore, the address-sized word likely corresponds to the effective address of a future demand load. [0044]       An exemplary embodiment of a method 600 of identifying candidate virtual addresses is illustrated in FIG. 6. Referring to reference numeral 610, the virtual address predictor 295 receives a cache line. The cache line is included in fill content received at the content prefetcher 290 - see FIG. 3, items 310, 320 - the fill content received at content prefetcher 290 comprising a copy of fill content directed to L2 cache 230, as noted above. The effective address of the cache line is then retrieved, as denoted by reference numeral 620. The cache line is scanned - see FIG. 3, reference numeral 330 - and an address-sized word is read (or otherwise accessed) from the cache line, as illustrated by reference numeral 630. An address-sized word corresponds to thirty-two (32) bits, or four<br>
(4) bytes, for a typical processor; however, an address-sized word may be of any suitable length.<br>
[0045]       The process of reading an address-sized word (or words) from a cache line is further illustrated in FIGS. 7 through 9. Referring to FIG. 7, an exemplary cache line 700 comprises sixty-four (64) bytes 705. It should be understood, however, that a cache line may be of any suitable length (e.g., 128 bytes). A first address-sized word 710 (i.e., the first four bytes) may be read from the cache line. A second address-sized word 720 may be read from the cache line, wherein the start of the second address-sized word 720 is separated from the start of the first address sized word 710 by an offset 708 of one (1) byte. Similarly, a third address-sized word 730 may be read from the cache line, the third address-sized word 730 and second address-sized word 720 separated by an offset of one (1) byte. Other address-sized words may be read from the cache line in a similar fashion until the final address-sized word 790 is read from the cache line. [0046]       The process of scanning a cache line illustrated in FIG. 8 is similar to that illustrated in FIG. 7; however, the offset has been increased and the number of address-sized words read from the cache line decreased. A cache line 800 includes, for example, sixty-four (64) bytes 805. Address-sized words 810, 820, 830,... 890 are read from the cache line 800, the start of each address-sized word separated from the preceding address-sized word by an offset 808 of two (2) bytes. Thus, the granularity of the cache line scan can be varied by changing the offset 808, 708, thereby altering the number of address-sized words that will be examined. Also, as suggested above, the cache line 800 (or 700) may be scanned in parallel, wherein the entire cache line is scanned at once. It should be understood, however, that when the amount of data that can be read from the cache line is limited by, for example, bus width, the cache line may be scanned in portions, each<br>
portion being scanned in parallel.<br>
[0047]       Referring to FIG. 9, a cache line 900 comprises sixty-four (64) bytes 905. A<br>
first address-sized word 910 is read from the cache line 900, the first address-sized word<br>
including the first four bytes of the cache line 900. A second address-sized word 920 is<br>
read from the cache line, wherein the start of the second address-sized word 920<br>
corresponds to the end of the first address-sized word 910. Stated another way, the first<br>
and second address-sized words 910, 920 are separated by an offset of four (4) bytes,<br>
which is also the length of each address-sized word to be read from the cache line 900. A<br>
third address-sized word 930 read from the cache line 900 is similarly offset by four bytes<br>
from the preceding address-sized word.<br>
[0048]       A data structure stored in memory wherein each element of the data structure is<br>
read starting at a word boundary is said to be "memory aligned" or J-byte aligned. For<br>
example, the cache line 900 illustrated in FIG. 9 is "4-byte aligned," whereas the cache<br>
line 800 of FIG. 8 is 2-byte aligned. As will be explained below, such memory aligned<br>
data exhibits certain characteristics which the virtual address predictor 795 may<br>
advantageously utilize during operation.<br>
[0049]       Referring again to FIG. 6, once an address-sized word has been read from the<br>
cache line, a certain number of the upper bits of the address-sized word are compared<br>
against the same number of upper bits in the effective address of the cache line, as denoted<br>
at 640. Specifically, an N number of the upper bits of the address-sized word are<br>
compared with the upper N bits of the effective address of the cache line. This process is<br>
better illustrated with reference to FIG. 10. The upper N bits of the effective address 1010<br>
of a cache line are compared against the upper N bits of an address-sized word 1020<br>
contained in the cache line. The upper N bits of each of the effective address 1010 and the<br>
address-sized word 1020, respectively, may be referred to as the compare bits 1030. The<br>
upper N bits, or compare bits 1030, may comprise any suitable number of bits. By way of<br>
example, for a 32 bit address-sized word, the N compare bits may comprise between 8 and 12 bits.<br>
[0050]       A bit pattern can be interpreted as a pointer load, a data value, or simply random bits. An address-sized word is deemed to be a pointer to a member of a data structure if the upper N bits thereof match the upper N bits of the effective address of the cache line, which suggests that the address-sized word and the effective address of the cache line were computed from the same base address. If the upper N bits of the address-sized word match the upper N bits of the effective address of the cache line - see reference numeral 650 - the address-sized word is identified as a candidate virtual address, as shown at 660, and the content prefetcher 290 may provide a prefetch request for the identified candidate address (see FIGS. 3 through 5). If the upper N bits do not match, the address-sized word is discarded, as illustrated by reference numeral 670. The above-described process - see reference numerals 630,640, 650, 660,670 - is applied to each address-sized word read from the cache line during the cache line scan.<br>
[0051]       A further embodiment of the method of identifying candidate virtual addresses is illustrated in FIG. 11. As previously described, a cache line may be memory aligned. For example, a data structure may be 2-byte aligned, 4-byte aligned, 8-byte aligned, 16-byte aligned, or, more generally, J-byte aligned. If the data in a cache line is J-byte aligned, a certain number of the least significant bits (see FIG. 10, reference numeral 1090) of any candidate virtual address will be zero (0). By way of example, for 2-byte aligned data the least significant bit will be zero, for 4-byte aligned data the two least significant bits will be zero, for 8-byte aligned data the three least significant bits will be zero, and for 16-byte aligned data the four least significant bits will be zero. More generally, for J-byte aligned data, the K least significant bits will be zero. The virtual address predictor 295 can use the assumption of memory aligned data to disqualify<br>
candidate virtual address. Assuming memory alignment, if any of the K least significant bits of an address-sized word are non-zero, the address-sized word can be disqualified as a candidate virtual address. Referring to FIG. 11, which illustrates a method 1100 substantially similar to the method 600 shown in FIG. 6 (all like elements retaining the same reference numeral), if any of the K least significant bits of the address-sized word read from the cache line are non-zero - see reference numeral 1110 - the address-sized word is discarded, as shown at 670.<br>
[0052]       The method 600 (as well as the method 1100) of identifying candidate virtual addresses described above generally functions for any bit pattern contained in the upper bits of the effective address of the cache line, with two exceptions: where the upper N bits are all O"s and where the upper N bits are all 1 "s (in which case a negative number can potentially be misidentified as a candidate virtual address). However, rather than not predicting when the compare bits of an effective address are all O"s or all l"s, additional filter bits can be used in the comparison to distinguish candidate virtual addresses from data values or random bit patterns. Referring to FIG. 12, the compare bits 1230 of an effective address 1210 of a cache line are either all l"s or all O"s. If the upper N bits of an address-sized word 1220 of the cache line match the upper N bits of the effective address (which are either all l"s or all O"s), additional filter bits 1240 of the address-sized word are examined. The filter bits 1240 comprise the next M bits after the upper N bits or compare bits 1230. If the compare bits 1230 are all O"s and a non-zero bit is found in the filter bit range of an address-sized word, or if the compare bits 1230 are all l"s and a non-one bit is found in the filter bit range of the address-sized word, the address-sized word is deemed a candidate virtual address.<br>
[0053]       A method 1300 of identifying candidate virtual addresses utilizing filter bits is illustrated in FIG. 13. The method 1300 is similar to the method 600 of identifying<br>
candidate virtual addresses shown and described with respect to FIG. 6, and like elements retain the same reference numeral. As shown at reference numeral 610, the virtual address predictor 295 receives a cache line. Again, the cache line is included in a copy of fill content received at the content prefetcher 290. The effective address of the cache line is then retrieved, as shown at reference numeral 620. The cache line is scanned and an address-sized word is read (or otherwise accessed) from the cache line, as denoted by reference numeral 630. Referring to reference numeral 640, the upper N bits of the address-sized word are then compared with the upper N bits of the effective address. [0054]       If the compare bits of the address-sized word and effective address of the cache line match - see reference numeral 650 - and the upper N bits of the effective address are all 0"s - see reference numeral 1310 - the next M filter bits of the address-size word are examined. Referring to reference numeral 1320, if any one of the next M filter bits of the address-sized word is a non-zero bit, the address-sized word is a candidate virtual address (see reference numeral 660). If a non-zero bit is not found in the filter bit range, the address-sized word is discarded, as shown at 670. Similarly, if the compare bits of the address-sized word and effective address match - see reference numeral 650 - and the upper N bits of the effective address are all l"s - see reference numeral 1330 - the next M filter bits of the address-sized word are examined. As illustrated at reference numeral 1340, if any one of the next M filter bits of the address-sized word is a non-one bit, the address-sized word is a candidate virtual address (see reference numeral 660). If a non-one bit is not found in the filter bit range, the address-sized word is discarded, as denoted at 670.<br>
[0055]       The filter bit range may comprise any suitable number of bits. By way of example, for a 32-bit address-sized word, a filter bit range of between 1 and 4 bits is<br>
believed suitable. Employing no filter bits would result in no virtual address prediction<br>
when the compare bits of the effective address of a cache line are all O"s or ail l"s, whereas<br>
increasing the number of filter bits relaxes the requirements for potential candidate virtual<br>
addresses.<br>
[0056]      Embodiments of a content prefetcher 290 having a virtual address predictor<br>
295 - as well as a method 600,1100, 1300 of identifying candidate virtual addresses -<br>
having been herein described, those of skill in the art will appreciate the advantages<br>
thereof. A virtual address predictor identifies candidate virtual addresses within a copy of<br>
fill content received from a cache without resort to an external source or index of<br>
addresses - e.g., a TLB - and the range of potential prefetches is, therefore, not<br>
unnecessarily limited. The virtual address predictor may provide a recursive component,<br>
resulting in chained prefetches, and a priority can be assigned to a prefetch based upon the<br>
request depth of that prefetch. A method of identifying candidate virtual addresses<br>
differentiates candidate virtual addresses from data values and random bit patterns by<br>
comparing the upper N bits of an address-sized word read from a cache line with the upper<br>
N bits of the cache line"s effective address. If the compare bits match, the address-sized<br>
word is identified as a candidate virtual address and a prefetch request may be enqueued<br>
for that address; otherwise, the address-sized word is discarded. In a further embodiment,<br>
a filter bit range within an address-sized word is examined where the upper N bits of the<br>
cache line"s effective address are all l"s or all O"s, thereby minimizing false predictions,<br>
such as may occur when fill content includes a multiple negative numbers. Also, the<br>
method of identifying candidate virtual address may take advantage of memory aligned<br>
data to easily eliminate address-sized words that are not likely to correspond to a virtual<br>
address.<br>
[0057]       The foregoing detailed description and accompanying drawings are only<br>
illustrative and not restrictive. They have been provided primarily for a clear and<br>
comprehensive understanding of the present invention and no unnecessary limitations are to be understood therefrom. Numerous additions, deletions, and modifications to the embodiments described herein, as well as alternative arrangements, may be devised by those skilled in the art without departing from the spirit of the present invention and the scope of the appended claims.<br><br><br><br><br><br><br>
We Claim:<br>
1.       A process device (200) for identifying candidate virtual addresses for prefetching, comprising: -<br>
a processing unit (210)<br>
a cache memory (230), the cache memory to receive fill content<br>
requested by a processing unit (210), the fill content including a<br>
cache line;<br>
a  content prefetcher  (290)  coupled  with  the  cache  memory<br>
(230), the content prefetcher (290) to receive a copy of the cache<br>
line;<br>
a virtual address predictor (295) associated with the content<br>
prefetcher (290), the virtual address predictor to<br>
retrieve an effective address from the cache line;<br>
read an address-sized word from the cache line, the cache line<br>
including a number of address-sized words;<br>
compare an upper N bits of the address-sized word with an<br>
upper N bits of the effective address of the cache line; and<br>
if the upper N bits of the address-sized word match the upper N<br>
bits of the effective address, identify the address-sized word as a<br>
candidate virtual address and generate a prefetch request for<br>
the candidate virtual address; and<br>
an arbiter (240) coupled with the content prefetcher (290), the<br>
arbiter to issue a prefetch request for the candidate virtual<br><br>
address.<br>
The device as claimed in claim 1, wherein the virtual address predictor (295) to discard the address-sized word if the upper N bits of the address-sized word do not match the upper N bits of the effective address.<br>
The device as claimed in claim 1, wherein the upper N bits comprises from 8 to 12 bits.<br>
The device as claimed in claim 1, wherein the cache line is memory aligned, the virtual address predictor (295) to discard the address-sized word if any one of K least significant bits of the address-sized word is non-zero.<br>
The device as claimed in claim 4, wherein the cache line is one of 2-byte aligned, 4-byte aligned, 8-byte aligned, and 16-byte aligned.<br>
The device as claimed in claim 4, wherein the K least significant bits comprises from 1 to 4 bits.<br>
The device as claimed in claim 1, wherein the virtual address predictor (295) to:<br>
examine M number of filter bits of the address-sized word if<br>
each  of the upper N bits of the effective address is a zero bit; and<br>
if one of the M filter bits is a non-zero bit, identify the address-sized word as a candidate virtual address.<br>
8.	The device as claimed in claim 7, wherein the virtual address predictor (295) to discard the address-sized word if each of the M filter bits is a zero-bit.<br>
9.	The device as claimed in claim 7, wherein the M filter bits comprises from 1 to 4 bits.<br>
10.	The device as claimed in claim 1, wherein the virtual address<br>
predictor (295) to:<br>
examine M number of filter bits of the address-sized word if each  of the upper N bits of the effective address is a one bit; and<br>
if one of the M filter bits is a non-one bit, identify the address-sized word as a candidate virtual address.<br>
11.	The device as claimed in claim 10, wherein the virtual address<br>
predictor (295) to discard the address-sized word if each of the M filter<br>
bits is a one bit.<br>
12.     The device as claimed in claim 10, wherein the M filter bits comprises from 1 to 4 bits.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWFzc2lnbm1lbnQucGRm" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWNvbXBsZXRlIHNwZWNpZmljYXRpb24gKGFzIGZpbGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-complete specification (as file).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWNvbXBsZXRlIHNwZWNpZmljYXRpb24gKGdyYW50ZWQpLnBkZg==" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-complete specification (granted).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1ERUxOUC0yMDA0LUNvcnJlc3BvbmRlbmNlLU90aGVycyAoMjktMDEtMjAxMCkucGRm" target="_blank" style="word-wrap:break-word;">1539-DELNP-2004-Correspondence-Others (29-01-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWNvcnJlc3BvbmRlbmNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWZvcm0tMTkucGRm" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1ERUxOUC0yMDA0LUZvcm0tMjYtKDI5LTAxLTIwMTApLnBkZg==" target="_blank" style="word-wrap:break-word;">1539-DELNP-2004-Form-26-(29-01-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LWdwYS5wZGY=" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LXBjdC0yMTAucGRm" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-pct-210.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LXBjdC0yMjAucGRm" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-pct-220.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LXBjdC0zMDQucGRm" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-pct-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LXBjdC00MDkucGRm" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-pct-409.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LXBjdC00MTYucGRm" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-pct-416.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LXBldGl0aW9uLTEzNy5wZGY=" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-petition-137.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzOS1kZWxucC0yMDA0LXBldGl0aW9uLTEzOC5wZGY=" target="_blank" style="word-wrap:break-word;">1539-delnp-2004-petition-138.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="218375-vehicle-management-system.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="218377-process-for-preparing-a-water-blown-polyurethane-foam.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>218376</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1539/DELNP/2004</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>19/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>09-May-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>31-Mar-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>03-Jun-2004</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTEL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2200 MISSION COLLEGE BOULEVARD, SANTA CLARA, CA 95052 (USA).</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>ROBERT COOKSEY,</td>
											<td>368C NE AUTUMN ROSE WAY, HILLSBORO, OREGON 97124 U.S.A</td>
										</tr>
										<tr>
											<td>2</td>
											<td>STEPHAN JOURDAN,</td>
											<td>14664 NW RICH COURT, PORTLAND, OREGON 97229 (USA).</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F12/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US02/38706</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-12-02</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/000,549</td>
									<td>2001-11-30</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/218376-a-process-device-for-identifying-candidate-virtual-addresses-for-prefetching by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:46:49 GMT -->
</html>
