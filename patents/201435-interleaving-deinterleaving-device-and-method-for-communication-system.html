<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/201435-interleaving-deinterleaving-device-and-method-for-communication-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:38:02 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 201435:INTERLEAVING/DEINTERLEAVING DEVICE AND METHOD FOR COMMUNICATION SYSTEM</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">INTERLEAVING/DEINTERLEAVING DEVICE AND METHOD FOR COMMUNICATION SYSTEM</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method for interleaving input data having a size other than a multiple of 2m (m&gt;l) is disclosed. The method comprises sequentially storing input data in a memory; adding an offset value to the input data size to provide a virtual address having a size of 2m where (m&gt;l); defining a plurality of address generation areas each having a size of 2m where (m&gt;l), and generating random addresses in the address generation areas; and reading the input data from the memory using the random addresses generated from the address generation areas.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>BACKGROUND OF THE INVENTION<br>
1.	Field of the Invention<br>
       The present invention relates generally to an interleaving/deinterleaving device and method, and in particular, to an interleaving/deinterleaving device and method for a turbo encoder used in radio communication systems such as satellite, ISDN (Integrated Services Digital Network), digital cellular, W-CDMA (Wideband Code Division Multiple Access), IMT-2000 and W-ATM (Wideband Asynchronous Transfer Mode) communication systems.<br>
2.	Description of the Related Art<br>
       In a turbo encoder, interleaving is performed to randomize information input to the encoder and to improve the distance property of a codeword. In particular, it is expected that the turbo encoder will be used in a supplemental channel (or traffic channel) of an IMT-2000 (or CDMA-2000) communication system and in a data channel of UMTS (Universal Mobile Telecommunication System) proposed by ETSI (European Telecommunication Standards Institute). Thus, a method for embodying an interleaver for this purpose is required. In addition, the use of turbo encoders results in an increase in the reliability of a digital communication system, and in particular, to a performance improvement of existing and future digital mobile communication systems.<br>
       The turbo encoder encodes an input frame of L information bits into parity symbols using two simple parallel concatenated codes, wherein recursive systematic convolutional (RSC) codes are typically used for component codes.<br>
       FIG. 9 shows a common turbo encoder, which is disclosed in detail in US patent No. 5,446,474  issued on August 29, 1995, which is hereby incorporated by<br><br>
                                                            - 9 â€” reference.<br>
       Referring to FIG. 9, the turbo encoder includes a first component encoder 11 for encoding input frame data, an interleaver 12 for interleaving the input frame data, and a second component encoder 13 for encoding an output of the interleaver 12. A known RSC encoder is typically used for the first and second component encoders 11 and 13. Further, the interleaver 12 has the same size as the input information bit frame, and rearranges the sequence of the information bits provided to the second component encoder 13 to reduce a correlation between the information bits.<br>
       For the internal interleaver (or a turbo interleaver) 12 of the turbo encoder, there are proposed various interleavers such as PN (Pseudo Noise) random interleaver, random interleaver, block interleaver, non-linear interleaver, and S-random interleaver. However, so far, such interleavers are mere algorithms designed to improve their performances in terms of scientific researches rather than implementation. Therefore, when implementing an actual system, the hardware implementation complexity must be taken into consideration. A description will now be made of properties and problems associated with the conventional interleaver for the turbo encoder.<br>
       Performance of the turbo encoder is dependent upon the internal interleaver. In general, it is not possible to design an interleaver guaranteeing an optimal performance because an increase in interleaver size causes a geometric increase in calculations. Therefore, in general, the interleavers are implemented by determining conditions satisfying several given criteria. The criteria are as follows:<br>
       Distance Property : The distance between adjacent codeword symbols should be maintained to a certain extent. Since this has the same function as a codeword distance property of the convolutional code, it is preferable that the interleaver should be designed to have the longer distance, if possible.<br>
       Weight Property : A weight of a codeword corresponding to a non-zero information word should be higher than a threshold value. Since this has the same function as the minimum distance property of the convolutional code, it is preferable that the interleaver should be designed to have the greater weight, if possible.<br><br>
- 3 -<br>
       Random Property : A correlation factor between output word symbols after interleaving should be much lower than a correlation factor between original input word symbols before interleaving. That is, randomization between the output word symbols should be completely performed. This makes a direct effect on the quality of extrinsic information generated in continuous decoding.<br>
       Although the above three design criteria are applied to the turbo interleaver, the properties are not definitely analyzed. According to experiments, the random interleaver is superior in performance to the block interleaver. However, the random interleaver is disadvantageous in that an increase in the variety and size of the frame causes an increase in the required memory capacity for storing an interleaver index (i.e., mapping rule or address). Therefore, taking the hardware size into consideration, it is preferable to employ an enumeration method for reading data stored at a corresponding address by generating an address at every symbol clock using an index generating rule rather than a look-up table method for storing the interleaver index.<br>
       In conclusion, when various interleaver sizes are required and the hardware implementation complexity is limited in the IMT-2000 or UTMS system, the turbo interleaver should be designed to guarantee the optimal interleaver performance by taking the limitations into consideration. That is, it is necessary to define an address generating rule and then perform interleaving/deinterleaving according to the address generating rule. Of course, the interleaver should be designed to completely satisfy the above stated turbo interleaver's properties.<br>
       The IMT-2000 or UMTS specification has not yet given any definition to the turbo interleaver. The forward link and the reverse link defined by the IMT-2000 specification have various types of logical channels and various interleaver sizes. Therefore, in order to meet this variety requirement, there is required an increase in memory capacity. For example, in a N=3 forward link transmission mode, an interleaver of various sizes ranging from 144 bits/frame to 36864 bits/frame may be used.<br>
To sum up, the prior art has the following disadvantages.<br><br>
- 4 -<br>
       First, for the conventional internal interleaver of the turbo encoder, PN random interleavers, random interleavers, block interleavers, non-linear interleavers, and S-random interleavers may be used. However, such interleavers are mere algorithms designed to improve their performances in terms of scientific researches rather than implementation. Therefore, when implementing an actual system, the hardware implementation complexity of such interleavers must e considered. However, this is not specifically defined.<br>
       Second, since a controller (CPU or host) of the transceiver should store interleaving rules according to the respective interleaver sizes in the existing interleaving method using a look-up table, a host memory requires a separate capacity in addition to an interleaver buffer. That is, when the frame size becomes varies and increases in size, an increased memory capacity for storing the interleaver index (i.e., mapping rule or address) is required.<br>
       Third, it is not easy to implement an interleaver satisfying both the distance property and the random property.<br>
       Fourth, a detailed turbo interleaver design specification for the turbo encoder of the CDMA-2000 forward link is not established yet.<br>
SUMMARY OF THE INVENTION<br>
       It is, therefore, an object of the present invention to provide a device and method for implementing an interleaver which can solve the problems of the conventional interleaver.<br>
       It is another object of the present invention to provide an interleaving/deinterleaving device and method satisfying all the properties of a turbo encoder, including the distance property, weight property and random property, in a communication system.<br>
       It is further another object of the present invention to provide a device and method for performing interleaving using a virtual address area having a size of<br><br>
- 5 -<br>
2mxN (where N is an integer, and M is larger than 1 and the number of shift register) by adding a specific value to an input data size value, in a communication system.<br>
       To achieve the above objects, there is provided a method for interleaving input data having a size other than multiples of 2m(m&gt;l). The method comprises sequentially storing input data in a memory; adding an offset value to the input data size to provide a virtual address having a size of 2m; defining a plurality of address generation areas each having a size of 2m, generating random addresses in the address generation areas; and reading the input data from the memory using the random addresses generated from the address generation areas.<br>
BRIEF DESCRIPTION OF THE/DRAWINGS<br>
       The above and other objects, features and advantages of the present invention will become more apparent from the following detailed description when taken in conjunction with the accompanying drawings in which:<br>
       FIG. 1 is a block diagram illustrating an interleaving device in a communication system according to an embodiment of the present invention;<br>
       FIG. 2 is a block diagram illustrating a deinterleaving device in a communication system according to an embodiment of the present invention;<br>
       FIG. 3 is a diagram illustrating that the invalid symbols interleaved according to an offset value exist between interleaved symbols in case of interleaving with a virtual address area in which the offset value is added to input data;<br>
       FIG. 4 is a diagram illustrating a connection of the output symbols after removing the invalid symbols of FIG. 3;<br>
       FIG. 5 is a diagram illustrating a PN generator having a generator polynomial of (1+x+x6);<br>
       FIG. 6 is a block diagram illustrating a unit for generating an interleaving read address according to an embodiment of the present invention;<br>
       FIG. 7 A is a detailed block diagram of the random address generator shown in FIG. 6;<br>
       FIG. 7B is a diagram illustrating another example of a counter 716 in the random address generator of FIG. 7 A;<br>
       FIG. 8 is a flow chart illustrating a procedure for generating an interleaving read address according to an embodiment of the present invention; and<br><br>
                          - 6 -FIG. 9 is a block diagram of a turbo encoder according to the Prior Art.<br>
DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT<br>
       A preferred embodiment of the present invention will be described herein below with reference to the accompanying drawings. In the following description, well-known functions or constructions are not described in detail since they would obscure the invention in unnecessary detail.<br>
       The invention proposes an optimal interleaving/deinterleaving device satisfying properties (including distance property, weight property and random property) of the turbo interleaver.<br>
       To this end, if the size of the input frame data is not a multiple of 2m (m&gt;l), an address generator of the novel turbo interleaver adds OSV(offset value) which is a certain value, such that the number of consecutive zero bits from the LSB becomes one among from 1 to 64 when the frame size is expressed as a binary value, in order to determine a virtual address size N. In order to express the determined virtual address size N in terms of Ngx2m, an area number Ng and a value 'm' are determined through experiments to optimally satisfy the interleaver properties. Thereafter, a PN address is generated according to partial address generation areas of size 2m  to interleave the whole input frame data. For example, when the frame size is 376 (==101111000), an offset value which can be added such that the number of consecutive zero bits from the LSB becomes the certain value is 8 (=1000).<br>
       Here, unnecessary read addresses are generated due to the added offset values, and these addresses are referred to as invalid addresses. If the offset value is added to the input data size value such that the input frame should be expressed in terms of power of 2, an increase in the size of the input frame causes a great increase of the size of the offset value thereby making it difficult to process the invalid address. Further, an increase in area number may cause deterioration of the random property. The term "area" as used herein refers to each address generation area when an interleaving address area is uniformly divided, and the term "group" refers to an address area grouped by the offset values.<br><br>
- 7 -<br>
       The interleaver according to the present invention permutes the sequence of input information bits using a PN offset controlled method and provides the permuted information bits to the second component encoder. Therefore, an interleaving according to the present invention requires an interleaver memory (comprised of an input data buffer and an output data buffer) for storing input information bits, an offset controlled PN interleaving (OCPNI) block (comprised of a partial reversal interleaver and a comparator) for finally changing the sequence of the input information bits, and an up/down counter. In addition, for the first and second component encoders, the turbo encoder can use not only the conventional component encoder, but also a component encoder specified by the CDMA-2000 system and a component encoder specified by the UMTS system. Further, the interleaver according to the present invention can be applied to not only an internal interleaver of a serial turbo encoder but also a channel interleaver.<br>
       FIGS. 1 and 2 show an interleaver and a deinterleaver according to an embodiment of the present invention, respectively.<br>
       Referring to FIG. 1, an interleaver for interleaving frame data output from the first component encoder will be described. An address generator 111 generates a read address for changing the sequence of input data bits according to an input frame data size L and an input clock, and provides an interleaver memory 112 with the generated read address. The interleaver memory 112 sequentially stores input data in a write mode of operation, and outputs the stored data according to the read address provided from the address generator 111 in a read mode of operation. A counter 113 counts the input clock and provides the clock count value to the interleaver memory 112 as a write address. As describe above, the interleaver sequentially stores input data in the interleaver memory 112 in the write mode of operation, and outputs the data stored in the interleaver memory 112 according to the read address provided from the address generator 111 in the read mode of operation. Alternatively, it is also possible to change the sequence of the input data bits before storing them in the interleaver memory in the write mode of operation, and sequentially read the stored data in the read mode of operation.<br>
       Referring to FIG. 2, a deinterleaver will be described. An address generator 211 generates a write address for restoring the sequence of input data bits to the<br><br>
- 8 -<br>
original sequence according to an input frame data size L and an input clock, and provides a deinterleaver memory 212 with the generated write address. The deinterleaver 212 stores input data according to the write address provided from the address generator 211 in the write mode of operation, and sequentially outputs the stored data in the read mode of operation. A counter 213 counts the input clock and provides the clock count value to the deinterleaver memory 212 as a read address.<br>
       As described above, the deinterleaver has the same structure as the interleaver and has the reverse operation of the interleaver. The deinterleaver is merely different from the interleaver in that the input data has different sequences in both the read and write modes. Therefore, for convenience, the description below will now be made with reference to the interleaver only.<br>
       It is preferable to derive a conclusion through a great number of simulations in order to implement an interleaver having excellent structural properties. In general, when the frame size is larger than a given value, a random interleaver has average performance. Therefore, it is preferable to design an interleaver having a similar performance to the random interleaver. To this end, the embodiment of the present invention uses a linear feedback shift register (LFSR) which generates a PN sequence, and uses a random address generated therefrom. However, this method has several problems, namely, the PN sequence has a period of 2m-l, and most frame sizes are not expressed in terms of power of 2.<br>
       To solve these problems, a read address is generated by adding the offset value (OSV) to the input data size L when the input data size L is not a multiple of 2m (m&gt;l) in order to determine a virtual address size N in accordance with an algorithm of Equation (1) below.<br>
       Now, a description will be made of a software interleaving method according to an embodiment of the present invention. When the input data size L is not a multiple of 2m (m&gt;l), a virtual address size N is calculated by adding the offset value OSV to the input data size L, and interleaving is performed by an offset controlled PN interleaving algorithm of Equation (1).<br>
[Equation 1]<br><br><br>
- 9 -<br>
{N=L+OSV; /*Find N=2mx Ng*/<br>
for(ADDRESS_WRITE=0;ADDRESS_WRITE
{for(g=0;g
{ADDRESS_READ=[PNg(ADDRESS_WRITE)-l]+g*2m;<br>
if(ADDRES S_RE AD
ADDRESS_READ=ADDRESS_READ-OFFSET(ADDERSS_RE'AD);}<br>
}<br>
}<br>
/*Overwrite ADDRESS_READ with the same address as ADDRESS_WRITE*/<br>
for(g=0;g
{ADDRESS_WRITE=2m-l;<br>
ADDRESS_READ-ADDRESS_WRITE+g*2m-OFFSET(ADDRESS_WRITE);}<br>
/*OFFSET Generation Algorithm*/<br>
function OFFSET(ADDRESS_READ)<br>
{<br>
if(ADDRESS_READ<gth></gth>
elseif(GTH[0]<address_read></address_read>
elseif(GTH[l]<address_read></address_read>
elseif(GTH[2]<address_read></address_read>
elseif(GTH[3]<address_read></address_read>
eIseif(GTH[4]<address_read></address_read>
eIseif(GTH[5]<address_read></address_read>
else OFFSET=7;<br>
}<br>
}<br>
       The read address ADDRESSJREAD generated by the algorithm of Equation (1) is mapped with the original address on a one-to-one basis. Such an interleaver has the distance property as well as the PN interleaver's property. In Equation (1), OFFSET(I) is a function of determining to which group the ADDRESS_READ belongs using thresholds determined by the offset value, and then shifting the address by the corresponding specific value.<br>
       If data is read by addressing the corresponding address of the interleaver memory without shifting the address by the specific value, invalid data will be read due to the offset value. That is, in addition to the ADDRESS_READ corresponding<br><br>
- 10 -<br>
to the input data of [0..L-1], there exist 8 ADDRESSREADs corresponding to the offset [L..N-1] between the interleaving sequences. This is shows in FIG. 3. If those are read as they are, N symbols which are higher in number by 8 than L symbols to be actually transmitted will be transmitted. Therefore, the succeeding address should be connected after removing the address existing between the interleaving sequences. This is illustrated in FIG. 4.<br>
       Referring to FIG. 4, the invalid symbols from L to N-l exist between the interleaved sequences. Therefore, it is necessary to output the interleaved symbols in succession except for the invalid symbols. For this, an offset controlled method is used. That is, ADDRESSREAD corresponding to the last 8 symbols out of [L..N-1] are regularly determined according to an interleaving rule. Therefore, it is possible to previously know the positions of the interleaved invalid symbols. First, assume that addresses for 8 tail symbols are Dl, D2, D3,.., D8 (i.e., L...N-1), and an interleaving address corresponding to Di (i=1...8) is Tk=PIRB(Di), where k=1...8. Of course, it is not always that T1<t2 for d1 and the interleaving address is arranged in a given order. therefore convenience assume that an index controlled to arrange order of t1 defined as using this tj then n areas are divided into groups on basis above each ti becomes threshold distinguishing boundary thereof. here addresses should be connected except values. example by subtracting from address_read address_read-0 go address_read-1 gl ... address_read-7 g7 all generated will have values among></t2>
       In addition, before applying the algorithm of Equation (1), several parameters should be previously determined. The parameters described below were determined through experiments. Such parameters are variable depending on initial seeds of a PN generator for generating a PN sequence, but have nothing to do with the performance of the interleaver. Therefore, the initial seeds are fixed to predetermined values. In Tables 1 and 2 below, p(x) is a primitive polynomial of the PN generator determined on a Galois field GF(2), wherein the leftmost bit indicates a coefficient of 0th degree and the rightmost bit indicates a coefficient of the highest degree.    That   is,   p(x)=[l 100001]    indicates   p(x)=l+x+x6.   A   PN   generator<br><br>
-11 -<br>
corresponding to the generator polynomial p(x)=l+x+x6 is illustrated in FIG. 5.<br>
       In general, in the initialization process, the initial seeds corresponding to the respective areas are loaded on m shift register cells. Thereafter, the register values are updated every clock by the connected line, and after update, a 6-bit address is generated by the combination of the values (0/1) stored in the register. That is, when the content of the lowest degree is p[l] and the content of the highest degree is p[m], PNg(ADDRESS_WRITE) indicates an address obtained by converting the shift register's binary value of (p[l]p[2]...p[m-l]p[m]) to a decimal number (=p[l]2m'1 + ... + p[m]2Â°) when clocking is performed at an initial time by write address ADDRESS_WRITE. In addition, the address generated from the PN generator has a period of 2m-l. Further, since the initial seeds are not zero, all the generated addresses have the vales within a range of {l<k therefore has the value within range of in this case since number addresses generated by pn generator is smaller one than required last address every area overwritten and then used as address_read. equation relation expresses follows:></k>
ADDRESS_WRITE-ADDRESS_WRITE+g*2m-OFFSET(ADDRESS_WRITE);<br>
       Now, a description will be made of a hardware implementation of the algorithm of Equation (1). FIG. 6 shows the detailed structure of the address generator for reading the data sequentially stored in the interleaver memory 112 according to an embodiment of the present invention.<br>
       Referring to FIG. 6, the address generator 111 will be described. A random address generator 121 outputs random addresses generated by a plurality of PN generators. A comparator 122 compares the random addresses output from the random address generator 121 with the threshold values GTH (threshold values for grouping the address areas) previously determined by the offset value, to output a group value select signal and the random addresses. Further, when the comparator 122 compares the random addresses output from the random address generator 121 with group threshold values GTH determined by the offset value, and when any one of them is identical, the comparator 122 deletes the random address at that time. A<br><br>
- 12 -<br>
selector 123 selects a group value according to the select signal. A subtracter 124 subtracts a specific group value of the selector 123 from the random address output from the comparator 1,22, in order to generate a read address for reading data from the interleaver memory 112<br>
       A detailed structure of the random address generator 121 is illustrated in FIG. 7A. Referring to FIG. 7A, PN generators 711-7N1 generate PN sequences for changing the sequence of data bits stored in the corresponding address generation areas, and provide the generated PN sequences to a first multiplexer 712. Here, the PN generators 711-7N1 each are initialized to different values. A counter 716 outputs select signals for selecting an output of the first multiplexer 712. If it is assumed that the address area number is Ng, the counter 716 outputs select signals of O...Ng-l. Here, the select signals can be generated either sequentially or randomly. For random generation, the select signals are randomly generated according a given pattern determined through experiments. The first multiplexer 712 selects the outputs of the PN generators 711-7N1 according to the select signals provided from the counter 716. Here, output data of the first multiplexer 712 is subtracted by 1 at a subtractor 718 and then applied to a second multiplexer 713. This is to map the random addresses from '0' by subtracting '1' from all the generated values, since the PN generators 711-7N1 cannot generate an address value of '0'. An area counter 715 generates a count value corresponding to the address generation area size, and provides a comparator 714 with the generated count value. The comparator 714 provides the second multiplexer 713 with a select signal ' 1' when a count value provided from the area counter 715 corresponds to an area size 2m-l. The second multiplexer 713 selects the output of the first multiplexer 712 when the count value generated by the area counter 715 according to the select signal corresponds to an area size-2, and selects the output of the area size 2m-l (area size-1) provided from the comparator 714 when the count value generated by the area counter 715 reaches the area size-1. An address buffer 717 stores output data of the counter 716 in an upper address area, and stores output data of the second multiplexer 713 in a lower address area. The address stored in the read address buffer 717 is provided to the comparator 122 of FIG. 6. The comparator 122 then determines to which group the address belongs, and provides the corresponding group select signal to the selector 123. The selector 123 selectively outputs the group values according to the select signal, and the subtracter 124 subtracts the selected group value from the address output from the<br><br>
- 13 -<br>
comparator 122 and provides the interleaver memory 112 with a final read address in order to read data corresponding to the read address from the interleaver memory 112.<br>
       Now referring to FIGS. 6 and 7A, a description will be made of a procedure for generating a read address. The PN generators 711-7N1 generate PN sequences by shifting stored state values using the clock , and the first multiplexer 712 selects the state values of the PN generators 711-7N1 according to the select signal provided from the counter 716. After selecting the state values, the PN generators 771-7N1 generate the PN sequences again by shifting stored state values using the clock. The PN sequence output from the first multiplexer 712 is subtracted by T and then provided to the second multiplexer 713. The PN sequence is provided to the lower area of the address buffer 717 before the area count value 1/NgxCLK reaches the address generation area size 2m-l. Meanwhile, when the area count value 1/NgxCLK reaches the address generation area size value 2m-l, the value 2m-l is provided to the lower area of the address buffer 717. Further, in the upper area of the address buffer 717, are stored the vales indicating the area (an address generation area corresponding to the presently selected PN generator), output from the counter 716. The address stored in the address buffer 717 is provided to the comparator 122, which determines to which group the address belongs and provides the corresponding group select signal to the selector 123. The address is then output to the subtracter 124. The selector 123 then selectively outputs the corresponding group value according to the select signal, and the subtracter 124 subtracts the corresponding group value from the address value output from the comparator 124 and provides the read address to the interleaver memory 112. Meanwhile, when there is no group to which the address belongs, i.e., when the address corresponds to the threshold values by the offset value, the comparator 122 deletes the address and regards the address as an invalid address. The interleaver memory 112 then outputs the data stored in the corresponding address according to the provided read address.<br>
       In this embodiment, the invalid address GTH generated by the offset values is deleted in the comparator 122. However, as an alternative embodiment, there is a method for not originally selecting the PN sequence corresponding to the offset value generated from the last PN generator 7N1. In this case, the delete function of the comparator 122 is unnecessary.<br><br>
- 14 -<br>
       Referring to FIG. 7B, a counter 720 monitors the state value of the last PN generator 7N1, and when it is determined that the state value is an invalid value by the offset value, the counter 720 outputs an enable signal to the selector 721. The selector 721 then provides the multiplexer 712 with a select signal (s=0) for selecting the first PN generator. When the PN generators are sequentially selected, the selector 721 outputs a select signal of '0', and when the PN generators are selected at random, the selector 721 outputs a select signal for selecting the next PN generator. That is, generation of the invalid address is avoided by not originally selecting an invalid value by the offset value generated from the last PN generator.<br>
       FIG. 8 shows a procedure for generating an interleaving address based on the algorithm of Equation (1). Referring to FIG. 8, the address generator (or CPU) 121 calculates respective parameter values for interleaving in step 811. When an input frame size L is expressed as a binary value, the address generator 121 determines a virtual address size N by adding a certain value (or offset value) so that the number of consecutive zero bits from the LSB becomes the certain value. Further, when the virtual address size N is expressed in terms of a power of 2 (i.e., 2mxNg), the multiplier 'm' and the area number Ng are determined through experiments. The parameters are determined in the design process, and stored in a look-up table. During interleaving, the values are read from the look-up table.<br>
       Thereafter, the address generator 121 initializes the write address ADDRESSJWRITE to '0' in step 813, and initializes an area index 'g' to '0' in step 815. After initialization, in step 817, the address buffer 121 generates a random address using a PN sequence in accordance with an equation of ADDRESS_READ = [(PNg(ADDRESS_READ_WRITE)-l]+g*2m, where PNg(ADDRESS_READ_ WRITE) denotes a function for generating a PN sequence, and subtracting '1' therefrom maps the generated PN sequence from '0'. Further, adding 'g*2m' maps the generated PN sequence to the respective areas. That is, for the area index g=0, the generated PN sequence is mapped to an area 0, and for the area index g=l, the generated PN sequence is mapped to an area 1.<br>
       In step 819, the address generator 321 generates the final read address using the calculated random address in accordance with an equation of (ADDRESS__READ=ADDRESS_READ-OFFSET(ADDRESS_READ).  The  above<br><br>
- 15 -<br>
equation indicates that the read address is calculated by determining to which group the read address belongs and then subtracting an offset value corresponding to the group. Here, the group is distinguished by the group threshold value (i.e., invalid address) generated by the offset value. For example, when the read address corresponds to a group 1, the address generator 121 subtracts T from the final read address. Otherwise, when the read address corresponds to a group 2, the address generator 121 subtracts '2' from the final read address.<br>
       Thereafter, in step 821, the address generator 121 examines whether the area index g has reached the area number Ng-1. When it is judged that the area index has reached the area number-1, the address generator 121 proceeds to step 823. Otherwise, when the area index has not reached the area number Ng-1, the address generator 121 proceeds to step 825 to increase the area index by ' Is and return to step 817.<br>
       Upon detecting that the area index has reached the area number Ng-1, the address generator 121 examines in step 823 whether the write address ADDRESS_WRITE has reached to a value 2m-2 (i.e., the number of addresses that one PN generator can generate). Here, the write address corresponds to the area count. When it is determined that the write address has reached the value 2m-2, the address generator 121 goes to step 829. Otherwise, when the write address has not reached the 2m-2, the address generator 121 proceeds to step 827 to increase the write address by T and return to step 815.<br>
        Upon detecting that the write address has reached the value 2m-2, the address generator 121 maps the write address to the read address using an equation of ADDRESSJWTUTE = 2m-l, ADDRESS_READ = ADDRESS_WRITE + g*2m-OFFSET(ADDRESS_WRITE) in step 829, and then ends the program. That is, the last write address is used as a read address.<br>
       Tables 1 and 2 below show OCPNI design parameters for each rate set when the novel interleaving scheme as applied to the IMT-2000 system.<br><br><br><br>
- 16 -<br>
[Table 1]<br>
[Table 2]<br>
       Table 3 below shows OCPNI read addresses for an interleaver having a size of N=376 and generated based on Table 1.<br><br><br>
- 17 -<br>
[Table 3]<br>
       As described above, the present invention proposes a method for minimizing the memory capacity required for performing random interleaving while satisfying the random property, distance property and weight property for data interleaving. Further, the proposed offset controlled interleaving method has solved the problem of the existing PN interleaving method in which the interleaver size cannot be expressed in terms of a power of 2 and an increase in the interleaver size results in low memory utilization efficiency. In addition, the novel interleaver is suitable for an IMT-2000 system in which the interleaver size of each logical channel is not expressed in terms of a power of 2 and is very large. In the existing interleaving method, various interleaving rules for the respective interleaver sizes should be stored in the controller (CPU or host) of the transceiver so that a host memory requires a separate memory capacity in addition to the interleaver memory. However, the invention can decrease the hardware complexity by implementing an interleaver capable of enumeration. In addition, the invention proposes a very simple transmission method for the interleaver/deinterleaver and minimizes the use of memory. That is, the novel interleaver requires an interleaver memory capacity corresponding to the frame size L. Finally, the novel interleaver satisfies all the properties of the turbo interleaver, thereby guaranteeing an average performance or over.<br><br>
- 18 -<br>
       While the invention has been shown and described with reference to a certain preferred embodiment thereof, it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined by the appended claims.<br><br><br>
WE     CLAIM:<br>
                                    - 19 -CLAIM:<br>
	1.	A method for interleaving input data having a size other than a<br>
multiple of 2m (m&gt;l), comprising the step of:<br>
        adding an offset value to the input data size so that a virtual address size<br>
becomes a multiple of 2m.	<br>
	The method as claimed in claim 1, further comprising the steps of:   <br>
     sequentially storing the input data in a memory;<br>
         defining a plurality of address generation areas each having a size of 2n<br>
where (m&gt;l) and generating random addresses in the address generation areas; and<br>
	reading  the  input data  from  the  memory using the  random  addresses<br>
fenerated from the address generation areas.<br>
	3.	The method as claimed in claim 2, wherein the random addresses are<br>
PN (Pseudo Noise) sequences.<br>
4.	The method as claimed in claim 1, wherein the offset value is a<br>
certain value to be added to a binary value obtained by converting the input data size into the binary value, such that the number of consecutive zero bits from the least significant bit (LSB) of the binary value becomes at least more than one.<br>
	A method for interleaving input data having a size other than a<br>
multiple of 2m (m&gt;l), comprising the steps of:<br>
sequentially storing input data in a memory;<br>
       adding an offset value to the input data size to provide a virtual address having a size of 2m where (m&gt;l);<br>
defining a plurality of address generation areas each having a size of 2m;<br>
generating random addresses in the address generation areas; and<br>
      reading the input data from the memory using the random addresses generated from the address generation areas.<br>
6.	The method as claimed in claim 5, wherein the random addresses are<br>
PN sequences.<br><br>
- 20 -<br>
7.	The method as claimed in claim 5, wherein the offset value is a<br>
certain value to be added to a binary value obtained by converting the input data size into the binary value, such that the number of consecutive zero bits from the least significant bit (LSB) of the binary value becomes at least more than one.<br>
	A device for interleaving input data having a size other than a<br>
m<br>
ultiple of 2m (m&gt;l), comprising:<br>
	a memory for sequentially storing input data; and<br>
       an address generator for adding an offset value to the input data size to provide a virtual address having a size of 2m where (m&gt;l), defining a plurality of address generation areas each having a size of 2m where (m&gt;l), and generating random addresses in the address generation areas;<br>
       wherein the input data is read from the memory using the random addresses generated from the address generation areas.<br>
       9. The device as claimed in claim 8, wherein the random addresses are<br>
generated by a PN generator.<br>
       10. The device as claimed in claim 8, wherein the offset value is a<br>
certain value to be added to a binary value obtained by converting the input data size<br>
into the binary value, such that the number of consecutive zero bits from the least<br>
significant bit (LSB) of the binary value becomes at least more than one.<br>
       11. The device as claimed in claim 8, wherein the address generator uses<br>
the last addresses of the address generation areas as the read address.<br>
       12. The device as claimed in claim 8, wherein the address generator<br>
comprises:<br>
       a random address generator having a plurality of PN generators each generating random addresses corresponding to the address generation areas;<br>
       a comparator for dividing the virtual address area into a plurality of groups according to the addresses corresponding to the offset value, and determining to which group a random address from the random address generator belongs; and<br>
       an operator for subtracting a specific value corresponding to the group determined by the comparator from the random address provided from the random<br><br>
                                - 21 -address generator, to generate the read address.<br>
       13. The device as claimed in claim 12, wherein the PN generators each<br>
have different initial state values.<br>
       14. The device as claimed in claim 8, wherein the address generator<br>
comprises:<br>
       a plurality of PN generators for generating random addresses corresponding to the respective address generation areas;<br>
       a counter for generating a select signal for selecting one of the PN generators;<br>
       a selector for selecting a state value, of a selected one of the PN generators according to the select signal output from the counter; and<br>
       an address buffer for assembling the read address by combining bits corresponding to the select signal from the counter and bits output from the selector.<br>
       15. The device as claimed in claim 14, wherein the PN generators have<br>
different initial values.<br>
       16. The device as claimed in claim 14, wherein the counter outputs the<br>
select signal for sequentially selecting the PN generators.<br>
       17. The device as claimed in claim 14, wherein the counter outputs the<br>
select signal for selecting the PN generators at random.<br>
       18. The device as claimed in claim 16, wherein the counter monitors the<br>
last PN generator, and does not select, when a state value of the last PN generator<br>
corresponds to the offset value, the last PN generator to select the next PN generators.<br>
       19. The device as claimed in claim 17, wherein the counter monitors the<br>
last PN generator, and skips, when a state value of the last PN generator corresponds<br>
to the offset value, the last PN generator to select the next PN generators.<br>
         A turbo encoding device comprising: a first component encoder for encoding input data;<br><br>
- 22 -<br>
       an interleaver for sequentially storing the input data in a memory, adding an offset value to a size of the input data so that a virtual address size becomes multiples of 2m where (m&gt;l), defining a plurality of address generation areas each having a size of 2m where (m&gt;l), generating random addresses in the address generation areas, and reading the input data from the memory using the random address generated from the address generation areas; and<br>
a second component encoder for encoding the data read from the interleaver.<br>
       21. The turbo encoding device as claimed in claim 20, wherein the offset value is a certain value to be added to a binary value obtained by converting the input data size into the binary value, such that the number of consecutive zero bits from the least significant bit (LSB) of the binary value becomes at least more than one.<br>
A method for interleaving input data having a size other than a multiple of 2m (m&gt;l) is disclosed. The method comprises sequentially storing input data in a memory; adding an offset value to the input data size to provide a virtual address having a size of 2m where (m&gt;l); defining a plurality of address generation areas each having a size of 2m where (m&gt;l), and generating random addresses in the address generation areas; and reading the input data from the memory using the random addresses generated from the address generation areas.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
		<br>
		<div class="pull-left">
			<a href="201434-compression-moulding-semi-crystalline-polymers.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="201436-chroman-derivatives-and-a-process-for-preparing-the-same.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>201435</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2000/00230/KOL</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>07/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>16-Feb-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>16-Feb-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>21-Aug-2000</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SAMSUNG ELECTRONICS CO. LTD.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>416 MAETAN-DONG, PALDAL-GU, SUWON-SHI KYUNGKI-DO, 442-370 KOREA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>MIN-GOO KIM</td>
											<td>973-3 YOUNGTONG-DONG, PALTAL-GU, SUWON-SHI, 442-470 KYONGGI-DO, KOREA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>BEONG-JO KIM</td>
											<td>MUJIGAE 201, #201 KUMI-DONG, PUNTANG-GU, SONGNAM-SHI, 463-50 KYONGGI-DO, KOREA</td>
										</tr>
										<tr>
											<td>3</td>
											<td>YOUNG-HWAN LEE</td>
											<td>237-7 CHONGJA-DONG, PUNTANG-GU, SONGNAM-SHI, 463-010, KYONGGI-DO, KOREA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H03M13/27</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/KR99/00795</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>1999-12-21</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>57959/1998</td>
									<td>1998-12-21</td>
								    <td>Republic of Korea</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/201435-interleaving-deinterleaving-device-and-method-for-communication-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:38:03 GMT -->
</html>
