<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/264089-method-and-system-for-indentifying-input-data-in-a-repository-data by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:38:15 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 264089:METHOD AND SYSTEM FOR INDENTIFYING INPUT DATA IN A REPOSITORY DATA</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD AND SYSTEM FOR INDENTIFYING INPUT DATA IN A REPOSITORY DATA</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Systems and methods enabling search of a repository for the location of data that is similar to input data, using a defined measure of similarity, in a time that is independent of the size of the repository and linear in a size of the input data, and a space that is proportional to a small fraction of the size of the repository. The similar data segments thus located are further analyzed to determine their common (identical) data sections, regardless of the order and position of the common data sections in the repository. Remote operations are accomplished with significantly reduced system bandwidth by implementing remote differencing operations.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
SYSTEMS AND METHODS FOR SEARCHING AND STORAGE OF DATA<br>
FIELD OF THE INVENTION<br>
[001]  This invention relates to systems and methods for searching data to identify data already stored and for storing new data efficiently based on the date already stored. These systems and methods are useful, as an example, for generating and maintaining a large scale data repository in backup and restore systems.<br>
BACKGROUND INFORMATION<br>
[002] Storing large amounts of data efficiently, in terms of both time arid space, is of paramount concern in the design of a backup and restore system, particularly where a large repository of digital data must be preserved. For example, a user or group of users might wish to periodically (e.g., daily or weekly) backup all of the data stored on their computers) to a repository as a precaution against possible crashes, corruption or accidental deletion of important data. It commonly occurs that most of the data, at times more than 99%, has not been changed since the last backup has been performed, and therefore much of the current data can already be found in the repository, with only minor changes. If this data in the repository that is similar to the current backup data can be located efficiently, then there is no need to store the data again, rather, only the changes need be recorded. This process of storing common data once only is known as data factoring.<br>
[003] A large-scale backup and restore system that implements factoring may have one petabyte (PB) or more in its repository. For example, banks that record transactions performed by customers, or Internet Service Providers that store email for multiple users, typically have a repository size ranging from hundreds of gigabytes to multiple petabytes. It may be recalled that 1 PB = 1024 TB (terabyte), 1 TB = 1024 GB (gigabyte), 1 GB = 1024 MB<br><br>
(megabyte), 1 MB = 1024 KB (kilobyte), 1 KB = 1024 bytes. In other words, a petabyte (PB) is 250 bytes, or about 1015 bytes.<br>
[004] In such large systems, the input (backup) data stream to be added to the repository may be, for instance, up to 100 GB or more. It is very likely that this input data is similar to, but not exactly the same as, data already in the repository.   Further, the backup data stream may not be arranged on the same data boundaries (e.g., block alignment) as the data already in the repository. In order to make a subsequent factoring step more efficient, the backup and restore system must be able to efficiently find the location of the data in the repository that is sufficiently similar to the input stream without relying on any relative alignment of the data in the repository and the data in the input stream. The backup and restore system must also be able to efficiently add the input stream to the repository and remove from the repository old input streams that have been deleted or superseded.<br>
[005] Generally, it can be assumed that data changes are local. Thus, for instance, if 1 % of the data has been changed, then such changes are concentrated in localized areas and in those areas there are possibly major changes, while the vast majority of the data areas have remained the same. Typically (although not necessarily) if, for example, 1 % of the data has changed, then viewing the data as a stream of 512-byte blocks rather than as a stream of bytes, a little more than 1 % of the blocks have changed. However, because there is no predetermined alignment of the data in the input stream and repository, finding the localized data changes is a significant task.<br>
[006] Searching for similar data may be considered an extension of the classical problem of pattern matching, in which a text Tof length n is searched for the appearance of a string P of length m. Typically, text length n is much larger than search string length m. Many publications present search methods which attempt to solve this problem efficiently, that is, faster than the naive approach of testing each location in text Tto determine if string P appears there. By preprocessing the pattern, some algorithms achieve better complexity, for example see:<br><br>
Knuth D.E., Morris J.H., Pratt V.R., Fast Pattern Matching In Strings, SIAM Journal on Computing 6 (1977) 323-350.<br>
Boyer R.S., Moore J.S., A Fast String Searching Algorithm, Communications of the ACM 20(1977)762-772.<br>
Karp R., Rabin M., Efficient Randomized Pattern Matching Algorithms, IBM Journal of Research and Development 31  (1987)249-260.<br>
[007] AB of these algorithms work in time that is of order 0{n + m)t which means that the search time grows linearly with the size of text. One problem with these algorithms is that they are not scalable beyond some restrictive fimiL For example, if searching a 1GB text (the size of about 300 copies of the King James Bible) can be done in 1 second, searching a one Petabyte text would require more than 12 days of CPU time. A backup and restore system with one Petabyte (PB) or more in its repository could not use such an algorithm. Another disadvantage of the above algorithms is that they announce only exact matches, and are not easily extended to perform approximate matching.<br>
[008] Instead of preprocessing the pattern, one may preprocess the text itself, building a data structure known as a suffix tree; this is described in the following publications:<br>
Weiner P., Linear Pattern Matching Algorithm, Proceedings of the 14th IEEE Symposium on Switching and Automata Theory, (1973) 1-11.<br>
Ukkonen E„ On-Line Construction Of Suffix Trees, Algorithmica 14(3) (1995) 249-260.<br>
[009] If preprocessing is done off-line, then the preprocessing time may not be problematic. Subsequent searches can be then performed, using a suffix tree, in time 0(m) only (i.e., depending only on the pattern size, not on the text size). But again, only exact matches can be found; moreover, the size of the suffix tree, though linear in the size of the text, may be prohibitive, as it may be up to 6 times larger than the original text.<br><br>
[010] For backup and restore, it would be desirable to use an algorithm for approximate pattern matching because it will usually be the case that not an exact replica of the input data can be found in the repository, but rather a copy that is strictly speaking different, but nevertheless very similar, according to some defined similarity criterion. Approximate pattern matching has been extensively studied, as described in:<br>
Rscher M.J., Paterson M.S., String Matching And Other Products, in Complexity of Computation, R.M. Karp (editor), SIAM-AMS Proceedings 7 (1974) 113-125.<br>
Landau G.M., Vishkin U., Fast Parallel And Serial Approximate String Matching, Journal of Algorithms 10(2) (1989)157-169.<br>
Navarro G., A Guided Tour To Approximate String Matching, ACM Computing Surveys, 33(1) (2001) 31-88.<br>
[011] One recent algorithm works in time Oyn^jklogk), where n is the<br>
size of the text and k is the number of allowed mismatches between the pattern and the text; see for example:<br>
Amir A., Lewenstein M., Porat E., Faster Algorithms For String Matching With K Mismatches, Journal of Algorithms 50(2) (2004) 257-275.<br>
[012]   For large-scale data repositories, however, 0[n^klogk) is not an<br>
acceptable complexity. An input data stream entering the backup and restore system may be, for instance, of length up to 100GB or more. If one assumes that an almost identical copy of this input stream exists in the repository, with only 1 % of the data changed, there are still about 1 GB of differences, that is k = 230 bytes. To find the locations of approximate matches in the repository, this algorithm will consume time proportional to about 180,000 times the size of the text n. This is unacceptable where our premise is text length n alone is so large, that an algorithm scanning the text only once, may be too slow.<br><br>
[013]  Another family of algorithms is based on hashing functions. These are known in the storage industry as CAS (Content Addressed Storage), as described in:<br>
Mouiton G. H., Whitehill S. B., Hash File System And Method For Use In A Commonality Factoring System, US Pat. No. 6,704,730.<br>
[014]  The general paradigm is as follows: The repository data is broken into blocks, and a hash value, also called a fingerprint or a signature, is produced for each block; all of these hash values are stored in an index. To locate some given input data, called the version, the given input data is also broken into blocks and the same hash function (that has been applied to the reposrtory blocks) is applied to each of the version blocks. If the hash value of a version block is found in the index, a match is announced.<br>
[015]  The advantage of CAS over the previous methods is that the search for similar data is now performed on the index, rather than on the repository text itself, and if the index is stored using an appropriate data structure, the search time may be significantly reduced. For instance, if the index is stored as a binary tree, or a more general B-tree, the search time will only be 0(log (n / s)), where n is the size of the text, and s is the size of the blocks. If the index is stored in a sorted list, an interpolation search of the sorted list has an expected time of OQog (log(n / s))). If the index is stored in a hash table, the expected time could even be reduced to 0(1), meaning that searching the index could be done in a constant expected time, in particular in time independent of the size of the repository text.<br>
[016]  There are, however, disadvantages to this scheme. As before, only exact matches are found, that is, only if a block of input data is identical to a block of repository data will a match be announced. One of the requirements of a good hash function is that when two blocks are different, even only slightly, the corresponding hash values should be completely different, which is required to assure a good distribution of the hash values. But in backup and restore applications, this means that if two blocks are only<br><br>
approximately equal, a hashing scheme will not detect their proximity. Searching in the vicinity of the found hash value will also not reveal approximate matches. Moreover, an announced match does not necessarily correspond to a real match between two blocks: a hash function h is generally not one-to-one, so one can usually find blocksXand Ysuch that X*Y and KX) = K Y).<br>
[017]  Stffl further, the bandwidth requirements needed for repository updates and the transmission of data over a network also present opportunities for improvement.<br>
[018]  These problems create a dilemma of how to choose the size s of the blocks: if a large block size is chosen, one achieves a smaller index (since the index needs to store n I s elements) and the probability of a false match is reduced, but at the same time, the probability of finding a matching block is reduced, which ultimately reduces the compression ratio (assuming the hashing function is used in a compression method, which stores only non-matching blocks, and pointers to the matching ones). If, on the other hand, a small block size is chosen, the overall compression efficiency may increase, but the probability of a false match also increases, and the increased number of blocks may require an index so large that the index itself becomes a storage problem.<br>
[019]   In summary, many elegant methods have been suggested to address these problems, but they all ultimately suffer from being not scalable, in reasonable time and space, to the amount of data in a large sized data repository.<br>
SUMMARY OF THE INVENTION<br>
[020]  The present invention is directed to systems and methods for efficient data searching, storage and/or reduction. Further, an amount of data transmitted between systems is reduced by implementing robust indexing and remote differencing processes.<br><br>
[021]  Systems and methods consistent with one embodiment of the invention can search a repository of binary uninterpretted data for the location of data that is similar to an input data, using a defined measure of similarity, and can do so in time that is independent of the size of the repository and linear in the size of the input data, and in space that is proportional to a small fraction of the size of the repository.<br>
[022]  Systems and methods consistent with other embodiments of the invention can fLffther analyze the similar data segments of the repository and input data and efficiently determine their common (identical) sections, regardless of the order and position of the common data in the repository and input, and do so in time that is linear in the segments' size and in constant space.<br>
[023]  A system and method according to certain embodiments provides for reducing the amount of network bandwidth used to store data. The system/method eliminates the need to send data through the network that may already exist at the destination. In one embodiment, a data repository is located at a first location. A second location has new data that it desires to store on the repository. A comparison of the new data and data already at the repository is performed. Advantageously, rather than sending all of the new data to the repository for comparison, and possibly wasting bandwidth by sending data that is already stored at the repository, the comparison of the new data with the repository data is accomplished by sending a representation of the new data, of a size much smaller than the entire new data, but with sufficient information on which a comparison of the new data to the repository data can be based in order to determine similarities or differences.<br>
[024]   In one embodiment, a method comprises identifying input data in repository data wherein the repository data comprise repository data chunks and the input data comprise input data chunks, and wherein each repository data chunk has a corresponding set of one or more repository data chunk distinguishing characteristics (RDCs), the method includes the steps of, for each input data chunk: determining a set of one or more input data chunk<br><br>
distinguishing characteristics (IDCs); comparing the determined set of IDCs to one or more sets of RDCs; and identifying a repository data chunk that is similar to the input data chunk as a function of the comparing of the determined set of IDCs to the one or more sets of RDCs.<br>
[025]  In one embodiment, the input data is located at a first location and the repository data is located at a remote location, and the method further comprises: determining the set of IDCs at the first location; transmitting the determined set of IDCs from the first location to the remote location; and comparing the determined set of IDCs to the one or more sets of RDCs at the remote location.<br>
[026]  in another embodiment, the first location is a first computer and the remote location is a remote computer different from the first computer, the first and remote computers being in networked communication with one another, and the repository data is stored in a data repository accessed through the remote computer.<br>
[027]   Identifying similarity of a set of IDCs to a set of RDCs is a function of a similarity threshold and the similarity threshold is met when a predetermined number of the distinguishing characteristics in the set of IDCs is found in a set of RDCs.<br>
[028]  Determining a set of distinguishing characteristics comprises: identifying one or more data portions within a respective data chunk; and calculating a mathematical hash value for each one or more data portion of a respective data chunk.<br>
[029]  In accordance with another embodiment of the present invention, a method of searching in repository data for data that are similar to an input data comprises dividing the repository data into one or more repository chunks; and, for each repository chunk, calculating a corresponding set of repository distinguishing characteristics (RDCs), each set of RDCs comprising at least one distinguishing characteristic; maintaining an index associating each set of RDCs and the corresponding repository chunk; dividing the input data into one or more input chunks, and for each input chunk: calculating a corresponding set of input distinguishing characteristics<br><br>
(IDCs), the set of IDCs comprising at least one distinguishing characteristic; comparing the set of IDCs to one or more sets of RDCs stored in the index; and if a similarity threshold j of the distinguishing characteristics in the set of IDCs is found in a set of RDCs stored in the index, determining that a similarity exists between the input chunk and the corresponding repository chunk.<br>
[030]   Each of the sets of RDCs and the sets of IDCs is obtained by: partitioning the respective data chunk into a plurality of seeds, each seed being a smaller part of the respective data chunk and ordered in a seed sequence; applying a hash function to each of the seeds to generate a plurality of hash values, wherein each seed yields one hash value; selecting a subset of the plurality of hash values; determining positions of the s'eeds within the seed sequence corresponding to the selected subset of hash values; applying a function to the determined positions to determine corresponding other positions within the seed sequence; and defining the set of distinguishing characteristics as the hash values of the seeds at the determined other positions.<br>
[031]  Another embodiment is a system for identifying input data in repository data wherein the repository data comprise repository data chunks and the input data comprise input data chunks, and wherein each repository data chunk has a corresponding set of one or more repository data chunk distinguishing characteristics (RDCs), the system comprising: means for, for each input data chunk, determining a set of one or more input data chunk distinguishing characteristics (IDCs); means for, for each input data chunk, comparing the determined set of IDCs to one or more sets of RDCs; and means for, for each input data chunk, identifying a repository data chunk that is similar to the input data chunk as a function of the comparing of the determined set of IDCs to the one or more sets of RDCs.<br>
[032]   The system, in one embodiment, may further comprise: means for, for each input data chunk, determining one or more differences between the input data chunk and the identified similar repository data chunk by comparing the full data of the respective chunks.<br><br>
[033]  The means for determining a set of distinguishing characteristics, in one embodiment, comprises: means for identifying one or more data portions within a respective data chunk; and means for calculating a mathematical hash value for each one or more data portion of a respective data chunk.<br>
[034]   In another embodiment, the system further comprises: means for detemwiing the k largest mathematical hash values in a set, k being a predetermined nimber; means for identifying a respective data portion for each of the k largest hash values; and means for determining a set of distinguishing characteristics to be the mathematical hash values of a next sequential data portion relative to each data portion corresponding to each of the k largest mathematical hash values.<br>
[035]  The distinguishing characteristics are determined by one of: a hash function; a rolling hash function; and a modular hash function and the sets of RDCs are stored in an index as at least one of: a binary tree, a B tree, a sorted fist, and a hash table.<br>
[036]  A system for searching in repository data for data that are similar to an input data, the system comprising: means for dividing the repository data into one or more repository chunks; means for, for each repository chunk, calculating a corresponding set of repository distinguishing characteristics (RDCs), each set of RDCs comprising at least one distinguishing characteristic; means for maintaining an index associating each set of RDCs and the corresponding repository chunk; means for dividing the input data into one or more input chunks, and for each input chunk: calculating a corresponding set of input distinguishing characteristics (lDCs), the set of IDCs comprising at least one distinguishing characteristic; comparing the set of IDCs to one or more sets of RDCs stored in the index; and if a similarity threshold j of the distinguishing characteristics in the set of IDCs is found in a set of RDCs stored in the index, determining that a similarity exists between the input chunk and the corresponding repository chunk.<br><br>
[037]  Each of the sets of RDCs and the sets of IDCs is obtained by: partitioning the respective data chunk into a plurality of seeds, each seed being a smaller part of the respective data chunk and ordered in a seed sequence; applying a hash function to each of the seeds to generate a plurality of hash values, wherein each seed yields one hash value; selecting a subset of the plurality of hash values; determining positions of the seeds within the seed sequence corresponding to the selected subset of hash values; applying a function to the determined positions to determine corresponding other positions within the seed sequence; and defining the set of distinguishing characteristics as the hash values of the seeds at the determined other positions.<br>
[038]  The subset of hash values is selected by identifying the k largest hash values; and the function applied to determine the corresponding other positions is to identify a next seed in the seed sequence.<br>
[039]  In yet another embodiment, a computer-readable medium encoded with computer-executable instructions that cause a computer to perform a method comprising identifying input data in repository data wherein the repository data comprise repository data chunks and the input data comprise input data chunks, and wherein each repository data chunk has a corresponding set of one or more repository data chunk distinguishing characteristics (RDCs), the method including the steps of, for each input data chunk: determining a set of one or more input data chunk distinguishing characteristics (IDCs); comparing the determined set of IDCs to one or more sets of RDCs; and identifying a repository data chunk that is similar to the input data chunk as a function of the comparing of the determined set of IDCs to the one or more sets of RDCs,<br>
[040]   Further, a computer-readable medium is encoded with computer-executable instructions that cause a computer to perform a method of searching in repository data for data that are similar to an input data, the method comprising: dividing the repository data into one or more repository chunks; for each repository chunk, calculating a corresponding set of repository distinguishing characteristics (RDCs), each set of RDCs comprising<br><br>
at least one distinguishing characteristic; maintaining an index associating each set of RDCs and the corresponding repository chunk; dividing the input data into one or more input chunks, and for each input chunk: calculating a corresponding set of input distinguishing characteristics (IDCs), the set of IDCs comprising at least one distinguishing characteristic; comparing the set of IDCs to one or more sets of RDCs stored in the index; and if a similarity threshold j of the distinguishing characteristics in the set of IDCs is found in a set of RDCs stored In the index, determining that a similarity exists between the input chunk and the corresponding repository chunk.<br>
[041]  Still further, the computer-readable medium further comprises computer-executable instructions to perform the step of obtaining each of the sets of RDCs and the sets of IDCs by: partitioning the respective data chunk into a plurality of seeds, each seed being a smaller part of the respective data chunk and ordered in a seed sequence; applying a hash function to each of the seeds to generate a plurality of hash values, wherein each seed yields one hash value; selecting a subset of the plurality of hash values; determining positions of the seeds within the seed sequence corresponding to the selected subset of hash values; applying a function to the determined positions to determine corresponding other positions within the seed sequence; and defining the set of distinguishing characteristics as the hash values of the seeds at the determined other positions.<br>
[042]  The subset of hash values is selected by identifying the k largest hash values; and the function applied to determine the corresponding other positions is to identify a next seed in the seed sequence.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[043]   The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate various embodiments and aspects of the present invention and, together with the description, serve to explain certain principles of the invention. In the drawings:<br><br>
[044]   Fig. 1 illustrates a general system architecture of an exemplary backup and restore system, which may be useful in certain described embodiments of the invention;<br>
[045]   Fig. 2 is a flowchart showing exemplary steps for processing an input version data stream in accordance with an embodiment of the invention;<br>
[046]   Fig. 3 is a more detailed sequence of steps for processing data chunks of an input version stream, according to one embodiment;<br>
[047]   Fig. 4 is a more detailed a sequence of steps for finding a position of a version chunk in a repository, according to one embodiment;<br>
[048]   Fig. 5 illustrates schematically a correspondence between seeds in a version chunk and seeds in a repository chunk, according to one embodiment<br>
[049]   Fig. 6 is a representation of a three-dimensional graph illustrating the results of a similarity search in a particular example, showing how the distinguishing characteristics may be substantially preserved despite changes to the data;<br>
[050]   Fig. 7 is a schematic representation of corresponding intervals in a version and repository, defining the symbols used in an embodiment of the binary difference algorithm;<br>
[051]   Fig. 8 is a schematic representation of corresponding intervals of a version and repository, showing anchor sets;<br>
[052]   Fig. 9 is a flowchart showing exemplary steps for calculating anchor sets and performing a binary difference process on each anchor set, in accordance with an embodiment of an invention;<br>
[053]   Fig. 10 is a more detailed sequence of steps for processing the anchor sets, according to one embodiment;<br>
[054]   Fig. 11 is a schematic representation of a version and repository, illustrating the anchors in an anchor set according to one embodiment of the invention;<br>
[055]   Fig. 12 is a schematic representation of the same version and repository of Fig. 11, illustrating the step of expanding the matches around the anchors;<br><br>
[056] Fig. 13 is a schematic representation of the same version and repository of Fig. 11, illustrating the step of calculating hash values between expanded anchor matches in the repository;<br>
[057] Fig. 14 is a schematic illustration of the same version and repository of Fig. 11, illustrating the step of expanding matches and the correspondence of matches in the version and repository;<br>
[058]   Fig. 15 illustrates an exemplary system environment;<br>
[059]   Fig. 16 illustrates an alternate general system architecture;<br>
[060]   Fig. 17 is a flowchart showing exemplary steps for updating a remote repository using minimal bandwidth; and<br>
[061] Fig. 18 is a flowchart showing exemplary steps for transferring version data from one system to another.<br>
DETAILED DESCRIPTION<br>
[062]  As used in the following embodiments, a repository is a collection of digital data stored in memory and/or storage of a computer reference] there is no limit on its size and the repository can be of the order of one or more PB. In particular applications, the data is stored as binary uninterpretted data. The input data can be of the same type or different from the repository data; the input data is also called the version. In particular applications, the version and repository are each broken into chunks. The chunk size m is a parameter, e.g. 32 MB. The term seed refers to a consecutive sequence of data elements, such as bytes. The seed size s is also a parameter, e.g. 512 bytes, or (in other non-limiting examples) 4 KB or even 8 KB. Generally, the seed size s is much smaller than the chunk size m.<br>
[063]   In accordance with certain embodiments of the invention a hash function is used. A hash function maps elements of some large space into elements of some smaller space by assigning elements of the first space a numeric value called the hash value. The hash function is usually an arithmetic function that uses as input some numeric interpretation of the base elements in the first space. A "good" hash function will, most of the time,<br><br>
produce a statistically unrelated hash value for even the slightest change in the elements of the first space.<br>
[064]  In the following embodiments a modular hash function is used. This use, however, is a non-limiting example. As is well known, a modular hash function has the property that if the hash value of s consecutive base elements in some stream is known, then the hash value of the s base elements in the stream that start one base element later (and are thus overlapping with the previous sequence of base elements) can be calculated in 0(1) operations. In this way, all the hash values of all the seeds in a chunk<br>
can be calculated in O(m) operations rather than in 0(m*s). Because of this property, this hash function is called a rolling hash function. Note that the present invention is not bound by the use of rolling hash functions in particular or hash functions in general.<br>
[065]  An index is a data structure that facilitates efficient searching. It should be space efficient For some applications (such as the current embodiment) it should support efficient dynamic operations, such as insertion and deletion. An index may be implemented by a hash table, so that searching, insertion and deletion are supported in 0(1) operations each. In accordance with certain embodiments of the invention described below, the index is indexed by a key, which is a hash value of some seed, and each key value identifies the seed (or seeds) from which it was generated.<br>
[066]   In Fig. 1 there is shown a generalized storage system architecture in accordance with an embodiment of the invention. The invention is, of course, not bound by this specific system architecture. In Fig. 1, a storage area network SAN (12) connects four backup servers (11) to a server (13). Server (13) includes a virtual tape interface (14) and RAM memory (15); an index (16) is stored in RAM (15). The server (13) is connected to a repository (17) which is stored in one or more (possibly external) secondary storage units.<br>
[067]   It should be noted that the present invention is not limited to a storage area network (SAN) and its specific technical characteristics, e.g., Fibre Channel. One of ordinary skill in the art will understand that any<br><br>
network technology may be used to facilitate networked communication among the servers including, but not limited to, Internet Protocol (IP) and TCP/IP. While Fig. 1 and the descriptions to follow refer to a SAN, this is only for explanatory purposes and should not be used to limit any embodiment of the present invention unless explicitly set forth in the claims.<br>
[068]   In Rg. 2 a flow chart (20) illustrates the steps of a system life cycle in accordance with an embodiment of the invention. As is shown, the process starts with an empty index (21). The content and purpose of the index is detailed below. Next the system enters a wait state until a version (22) is received, and thereafter the version is processed (23) in a manner described in greater detail below. After processing the version, the system returns to a wait state (22) until another version is received. The sequence (22, 23) proceeds as long as more input versions are received. The input version may or may not update the repository and/or the index. In one factoring application described herein, if an input version is recognized as a new one (not sufficiently similar to data in the repository) it is incorporated into the repository as is. If, on the other hand, the input version is recognized as sufficiently similar to already existing data in the repository, it is factored with the repository data, and only the unmatched parts of the version are stored. As is apparent from the foregoing, the longer the system operates, the larger the size of the repository. In certain applications, the repository size ranges from hundreds of gigabytes to multiple petabytes. It is thus necessary to locate or identify the repository data that is sufficiently similar to the input data in an efficient manner; otherwise, the processing time will be too long and the system not economically or commercially feasible.<br>
[069]   By way of analogy, as an alternative method of explanation and not meant to be limiting, consider a scenario with two documents, document A and document B, that are very different from one another. In an initialized system, i.e., an empty repository, according to an embodiment of the invention, each of documents A and B is divided into chunks or sections and stored (chunks are discussed below in more detail). For ease of explanation in this scenario, the chunks are sized such that each of documents A and B is<br><br>
four chunks long - with two chunks in each half. The eight chunks are then stored in the repository. It should be noted that, in accordance with this embodiment, these chunks are not stored on a filename basis. These chunks are stored such that the repository is able to recreate the documents from the chunks.<br>
[070]  Assume next, that a new document C is created by cutting and pasting the first half erf document A (into document C) followed by cutting and pasting the last half of document B (into document C) with no other additional data added. One can see that document C will have substantial similarity to each of documents A and B, but will also have substantially differences from each document.<br>
[071]  The present embodiment will break document C into its four chunks and search the repository for similar chunks. Similar chunks will be identified, between the first two chunks of document C and the first two chunks of Document A, and between the last two chunks of document C and the last two chunks of document B. As the system only identifies similar chunks, and not exact chunks, the system will then determine any differences (factoring) between similar chunks. Here, the similar chunks are identical. Thus, in this scenario, document C is effectively already stored (as A and B chunks) and the space necessary to store it, i.e., to be able to recreate it and retrieve it, is much less than storing the entire document C. In a filename based system, the four chunks of document C would be stored again (as document C), which would be redundant as these chunks are already stored in the system.<br>
[072]  To recreate document C, the system, according to the present embodiment, will retrieve the two chunks that have been stored for the first half of document A and the two chunks that have been stored for the second half of document B.<br>
[073]   In another scenario, a new document D is created by cutting and pasting the first half of document A (into document D) followed by cutting and pasting the last half of document B (into document D). Subsequently, the title of the document is changed from "The Life of John Adams" to "The Loan to<br><br>
Jobs Apple" with no other changes being made. Once again, one can see that there are substantial similarities between documents A and D and between documents B and D, but also substantial differences as well.<br>
[074]  The present system will break document D into its four chunks and then look for similar chunks that are already stored. In this case, the system wiD faid the frst two chunks from document A and the last two chunks from document B as being similar to the chunks of document D. Next, the system wiD determine that that there are differences between the first chunk of document D and its respective similar chunk. The differences, i.e., the changed locations in the title, will be determined. Thus, document D will be represented in the repository as the first two chunks from document A and the last two chunks from document B but with an identification, i.e., the delta or difference, of where and how the first chunk from document D differs from the identified similar chunk - the first chunk that was, in this example, associated with document A. The amount of space, therefore, needed to represent document D is then much less than storing all of document D in the repository.<br>
[075]  While the foregoing simple scenarios were described with reference to filenames, i.e., documents, various embodiments of the present invention may be transparent to any file system as the comparisons are functions of the chunks and characteristics to be described in further detail below. With the present system, it is possible that documents A, B, C and D are not associated with the same user, as in a file-based or filename-based system, but similarity can be determined and efficient storage can still be accomplished. A backup system, or one attempting to find similarities, based on a file system would be unable to determine the similarities between portions of document A, document B, document C and document D in the above scenarios. Advantageously, the present invention is transparent to most known file systems.<br>
[076]   Fig. 3 details one method of processing a version (step 23 in Fig. 2) in accordance with an embodiment of the invention. When a version is received (31) it is divided into smaller chunks (32), say 32 MB per chunk. The<br><br>
first input chunk is selected (33); the input chunk is processed to find a sufficiently similar chunk in the repository and its position (34). This step (34) is described with reference to Fig. 4 in greater detail below. Having found a similar repository chunk, the version chunk is further processed (35), which, according to this embodiment, entails factoring the version chunk with the repository. This process is repeated for additional chunks of the input version (34 to 37), until there are no more chunks in the version and processing is done (38).<br>
[077]   in accordance with a different embodiment of the invention, given that an input chunk is matched with certain repository data, the following input chunk is first tested to match the repository data succeeding the matched repository chunk, thus proceeding directly to its application specific processing (35). If, on the other hand, the following input chunk fails this test, it is fully processed to find its similar repository data (34, 35). Synchronization Algorithm and Factoring<br>
[078]   Fig. 4 illustrates one sequence of steps for efficiently finding a position of a sufficiently similar chunk in the repository (step 34 of Fig. 3), and subsequent factoring steps, in accordance with an embodiment of the invention. The algorithm used to find the similar repository chunk to the input (version) chunk is referred to herein as a synchronization algorithm, because its output includes common points in the repository and version, which are useful in later processing for effectively aligning (on the same data boundaries) what was previously two unaligned data segments.<br>
[079]  An input chunk of size m, say 32 MB, is processed (41) in the following manner. First, a set of k distinguishing characteristics of the version chunk (42) are calculated, where k is a parameter of this algorithm as explained below (typically of the order of a few tens), and where k« m (chunk size). In accordance with one embodiment (and as will be further described below with respect to a specific example), the set of k distinguishing characteristics can be calculated as follows (not shown in Fig.4);<br><br>
(1)	Calculate a hash value for every seed of the input<br>
data chunk. The seeds can be of any size s substantially smaller than string length m, say 4 KB. By this non-limiting embodiment, the hash value for every seed is calculated using a rolling hash function which moves in each iteration by one byte forward. A hash value is calculated in each fteraflon with respect to the 4 KB seed size accommodated within this range. By this example, where the input chunk size m = 32 MB and seed size s =4 KB, there are 33,550,337 (32 MB - 4 KB + 1) hash values obtained for each chunk, one at every possible byte offset in the chunk. A rolling hash function has the advantage that once the hash value for a seed of s bytes is known, calculating the hash function for the next s bytes (i.e. s bytes shifted by one byte with respect to the previous s bytes and thus having s -1 overlapping bytes) can be done in 0(1) operations, rather than O(s). Note that the invention is not bound by the use of hash functions, nor by hash functions of the rolling type.<br>
(2)	Next, the k maximum hash values, i.e., the largest<br>
hash values in descending order, of respective k seeds, are selected from among the (33,550,337) calculated hash values; these k seeds constitute the k maximum seeds. Thereafter, the k hash values of respective k seeds that follow by one byte (and overlap by s -1 bytes) the k maximum seeds, respectively, are selected. These k seeds constitute the k distinguishing seeds and their corresponding hash values constitute the k input<br><br>
distinguishing characteristics. Note that the maximum values themselves have a probabilistic distribution that is not uniform. However, if a good hash function is used, the probabilistic distribution of the following k values will be very close to uniform and therefore substantially better for the intended application. By uniform distribution it is meant that the k distinguishing characteristics are substanfiaRy uniformly distributed as numbers on some range of numbers.<br>
[080]   Note that the invention is not bound by calculating the distinguishing characteristics in the manner described above. Any selection that yields, to a high extent, robust, and well spread characteristics, and is repeatable for a given chunk, can be used in this embodiment of the invention. [081]  Definitions:<br>
[082]   Robust: the characteristics assigned to a chunk will remain fairly constant given that the chunk undergoes modest changes (e.g., in up to 25% of its seeds).<br>
[083]  Well spread: the characteristic locations are well spread (substantially uniformly) over the chunk (geographically spread).<br>
[084]   Repeatable: a certain form of a chunk will substantially always be assigned the same characteristics.<br>
[085]    Such methods may consider only a subset of the chunk's seeds. For instance, the selection of characteristics can be at intervals in the chunk the distance between which is defined by an arithmetic or geometric sequence, in accordance with a certain embodiment. Other methods consider all of the chunk's seeds, such as the foregoing method described.<br>
[086]   In accordance with this embodiment, a minimum geographic (positional) spread between the characteristics can be enforced, thus<br><br>
improving coverage. In general, any repeatable selection based on mathematical characteristics of the calculated seed values is applicable.<br>
[087]   For example, one may choose the k minimal hash values, i.e., the smallest hash values, or the k hash values closest to the median of all the hash values calculated in the chunk, or even the k hash values closest to some predetermined constant Another example is choosing the k characteristics as the sum of pairs, such that the first pair consists of the minimal value and the maximal value, the second pair consists of the second minimal value and the second maximal value, etc. Other variants are applicable, depending upon the particular application.<br>
[088]  Also, instead of using a one byte shift of the seed corresponding to a maximal value, one could use some other predetermined constant shift, or even different shifts depending on the position and/or on the calculated hash value. The example of using maximum hash values and one byte shifts is thus only one possible embodiment<br>
[089]  A specific example of this one procedure for calculating the distinguishing characteristics is given below.<br>
[090]   In this embodiment, the repository is associated with an index which stores, in respect of each repository chunk, n distinguishing characteristics where n 
[091]   For a better understanding of an index structure, Fig. 5 illustrates graphically an index (44) and the correspondence between a set (e.g., five) of distinguishing characteristics (55i-59i) in an input chunk (51) and a corresponding set (five) of distinguishing characteristics (55r-59r) in a<br><br>
substantially similar repository chunk (52), in accordance with an embodiment of the invention. The repository chunk 52 forms part of a repository (53), which here stores a huge number of chunks 50. The distinguishing characteristics are, as previously described, a selected set of hash values generated from well-spread seeds that are indicated by the five triangles (55i) to (590 in the input ditaik (51). The same five distinguishing characteristics (55rto 59r) are shown in the substantially similar repository chunk (52). The index (44) holds the disimguishing characteristics of the repository chunks (including the five of chunk (52)) and associated position data, (e.g. the relative location of the chunk (52) in the repository). Thus, during a similarity search, when the values of a repository chunk (52) are found as matching those of an input chunk (51), the location of the sought chunk (52) within the repository will be readily known by extracting the associated position data. The index (44) grows continuously as new versions are incorporated into the repository and the hash values associated with the chunks of each version (calculated in a manner described above) are added to the index.<br>
[092]   Returning to Fig. 4, the index (44) is searched for the hash values of the distinguishing characteristics until at most n matches are found (step 43). More specifically, each of the k distinguishing characteristics of the input chunk set is searched in the index in an attempt to find matches, and this continues until at most n distinguishing characteristics are matched. Lety (/ 
[093]   Note that the computational complexity for finding these j matches is low since it requires searching the index (by this example, a hash table) at most k times, each time with complexity of 0(1).<br>
[094]   In one embodiment, a version chunk that has j &gt; 2 matching distinguishing characteristics is considered as matched with one or more repository chunks. On the other hand, a version chunk that has j
 <br>
distinguishing characteristics is considered to be unmatched with any of the repository chunks. A single match (j=1) is considered not statistically significant because its occurrence may not be a rare event for very large repositories.<br>
[095]   It should be noted that a distinguishing characteristic of the version chunk may match multiple distinguishing characteristics of the repository chunks. It is also possible that two version distinguishing characteristics are matched with two repository distinguishing characteristics which are well apart from each other, and may belong to two separate repository chunks. It then arises from the foregoing that a version chunk may be matched with multiple repository chunks. For each such repository chunk /, let hi be the number of such matching distinguishing characteristics. In one embodiment, a level of similarity between the repository chunk / and the version chunk is measured by the ratio between hj and n; where this ratio exceeds a threshold, the repository chunk can be considered sufficiently similar to the version chunk (step 45 in Fig. 4).<br>
[096]   Consider, for example, a version that has undergone some changes compared to an older version of binary data stored in a repository. Normally, such changes are reflected in a small percentage of the seeds undergoing some local changes. The net effect is that for a given chunk, most of it is left intact Since the positions of the distinguishing characteristics of the chunk are chosen to be properly spread (geographically across the chunk), the local change will affect only a few, if any, of the distinguishing characteristics and the rest will not change. In other words, this representation method is robust, since even a large percentage of localized change(s) will still leave many distinguishing characteristics intact. Statistically, in certain embodiments, if the search finds a repository chunk with at least two matches (meaning that in the latter example j &gt;= 2), then the repository and version chunks are sufficiently similar to be worth comparing further.<br>
[097]   In select embodiments, to improve the uniform spread of the distinguishing characteristics upon the version chunk (which may eventually also be a part of the repository), the chunk is further divided into u sub-<br><br>
chunks. For each sub-chunk k/u distinguishing characteristics are computed, that constitute together k distinguishing characteristics.<br>
[098]   In select embodiments, to improve the significance of each match of distinguishing characteristics, a list of highly recurring distinguishing characteristics is maintained. When a distinguishing characteristic is calculated for a number of version chunks that exceeds some threshold, it is considered to belong to some systematic pattern in the data, thus yielding reduced distinguishing information. It is then added to a list of recurring values, to avoid its usage as it occurs for succeeding chunks. Upon calculation of a distinguishing characteristic, its value is checked for existence in the list, and if it exists, it is discarded and another distinguishing characteristic is computed in its place.<br>
[099]   In the described embodiment, more than n and up to k distinguishing characteristics are possibly searched for in the index, whilst only n are stored in the index with respect to each repository chunk. By this embodiment, there are two possible effects on maximum hash values that may be caused by changes to the version chunk with respect to the repository: 1) a maximum hash value could disappear because the data that comprises its corresponding seed has been modified; and 2) changed data could introduce a higher maximum value, displacing a still existing maximum. In cases involving the second effect, searching for more distinguishing characteristics provides more stability since a prior maximum has not disappeared, it has only been displaced. These two effects are reasons for selecting the maximum values in descending order, and/or for choosing k &gt; n.<br>
[0100] Fig. 6 shows an example of how the distinguishing characteristics may be substantially preserved, despite changes to the data. In this example, the data is mp3 data, the repository size is 20 GB, the version size is tens of thousands of chunks, the chunk size is 32 MB, and the number of distinguishing characteristics calculated for each chunk is 8. In the three-dimensional representation of the search results shown, the horizontal axis (width) denotes the number of keys (distinguishing characteristics) found, and the number searched. The left margin axis (depth) denotes the percentage of<br><br>
data seeds changed, in the version. The right margin axis (height) denotes the number of chunks for which keys were searched and found. Thus, each row (in depth) shows the effect on the number of distinguishing characteristics given some percentage of the seeds that were changed.<br>
[0101] For example, in the 5th row, 10% of the data was changed, yet the mean of about 5,000 chunks had 7 of their 8 distinguishing characteristics intact, and over 95% of these chunks had 4 or more of their 8 distinguishing characteristics still present In the 4th through 1st rows, where respectively 5%, 3%, 2% and 1% of the data was changed, the preservation of distinguishing characteristics is progressively greater.   As the percent data change increases, setting a lower threshold (number of minimal matches of distinguishing characteristics in the repository and input) will allow more findings of similar data. In this example, where the peak for a 25% data change (8th row) is centered at about 4 keys found, if the threshold is set at 4 (out of k input distinguishing characteristics) then the similarity search will return substantially all repository locations where up to 25% of the data is changed. If for the same 25% data change the threshold is set higher, e.g., at 6, then the search will return a much lower percentage of similar repository locations. Thus, a graph such as Fig. 6, can assist the user in selecting the values for;, k, m, and n in a particular application.<br>
[0102] Returning again to Fig. 4, where one or more sufficiently similar repository chunks are found, the position of each matched repository chunk is extracted from the index (45-46). It is recalled that the position data of the repository chunk (associated with the j found hash values) can be readily retrieved from the index. The succeeding steps may use one or more of the matched repository chunks, and may rank the repository chunks by their level of similarity. In this embodiment, there follows a factoring step involving the version chunk and its matched repository chunks (47), that leads to a storage-efficient incorporation of the version chunk in the repository. In such a factoring backup and restore system, the further steps involve identifying the common (identical) and uncommon (not identical) data in the version and repository, and storing only the uncommon data of the version (keeping the<br><br>
stream consistent by using appropriate pointers), hence saving storage. For example, in a typical backup and restore system, the data may have changed by 1 % between backups. The second backup can be added to the repository by adding only 1% of its data to the repository, and maintaining pointers to where the rest of the data can be found, effectively saving 99% of the space required.<br>
[0103] In a next step (48) of this embodiment, the distinguishing characteristics of the matched parts of the repository are removed from the index. This step is performed in order to eliminate from the index any reference to the "old" parts, now replaced with a more updated version of the new input chunk. In a next step (49), the n most significant distinguishing characteristics of the new chunk are added to the index. In this embodiment, a distinguishing characteristic A is more significant than another distinguishing characteristic B if the hash value of the maximal seed of A is greater than that of B. Note that this is done at substantially no cost, since n is small and removing and inserting each one of the n values to the hash table may be performed at 0(1) operations. Processing of the version chunk is now done (404).<br>
[0104] In Fig. 4, if no match has been found (i.e.,/ less than some threshold of matches found) (401-402), the new version chunk is processed by some alternate process since similar repository data was not found (403). In one example, the version chunk can be stored in the repository without factoring. In accordance with an index update policy of the present embodiment, the distinguishing characteristics of the version chunk are added to the index (49). The process (404) is then terminated (in either match success or match fail route described above), until a new version chunk is processed.<br>
[0105] Note that the invention is not bound by the foregoing example of an index update policy. For other applications it might be appropriate to keep all of the distinguishing characteristics of both the version chunk and all its matching repository parts; or alternatively, avoid the addition of the version chunk's distinguishing characteristics; or, possibly, update the index with<br><br>
some mixture of the version and the repository chunks' distinguishing characteristics.<br>
[0106] Specifically in this embodiment, where the version chunk's distinguishing characteristics replace all of the matched repository parts' features, another index, called a reverse index, can be used to identify all of the distinguishing characteristics (some possibly not matched with the version chunk's distinguishing characteristics) associated with the relevant repository parts. The reverse index is keyed by the locations in the repository, and maps these locations to their associated distinguishing characteristics. This reverse index also facilitates maintaining the consistency of the main index, in cases of deletion of parts of the repository.<br>
[0107] Also note that the invention is not bound by this embodiment where the index starts empty. For other applications it might be appropriate to load the index based on an existing body of repository data, via the foregoing process of dividing the repository into chunks, calculating their distinguishing characteristics, and building the index based on this information. In such a case, the index may or may not be further updated by the incoming version chunks, according to some update policy of the type mentioned above.<br>
[0108] It is emphasized that the computational complexity of searching the repository for data that is similar to the version data is proportional to the size of the version, O(version), and is designed to be independent of the size of the repository. This search requires, in accordance with the non-limiting embodiments described above, no more than k hash table searches of 0(1) each per version chunk. Since k 
[0109] Furthermore, it is emphasized that the space needed for the index is proportional to the ratio between the number of distinguishing characteristics stored per chunk of repository, and the size of the chunk, i.e.,<br><br>
the ratio between n and m. By one embodiment, where n is 8 and m is 32 MB, and the space needed to store each distinguishing characteristic is 16 bytes, a total of 128 bytes is stored in the index for each 32 MB of repository, a ratio of better than 250,000:1. Stated differently, a computer system with a Random Access Memory (RAM) of 4GB can hold in its memory the index needed for a 1 PB reposftory, facilitating rapid searching of the index and hence the rapid finding of similar data in a very large repository for an arbitrary input chunk.<br>
[0110] It should be noted that once similar chunks are found based on identifying matched distinguishing characteristics in the manner described above, it may be of interest to identify the exact differences between the similar chunks. In such cases, a more detailed comparison (or supplemental) algorithm may be applied, for comparing the full data of the respective chunks (and not only the n distinguishing characteristics). Typical, yet not exclusive, examples of such algorithms are binary difference and byte-wise factoring types of algorithms. An improved binary difference algorithm is described below, which can advantageously be used in select embodiments.<br>
[0111] The supplemental algorithm may be less efficient (in terms of computational resources) compared to the synchronization (similarity search) algorithm just described. The degraded efficiency may stem from the fact that in the supplemental algorithm all of the data of a given repository chunk is processed, whereas in the similarity search algorithm only partial data associated with the chunk is processed (i.e., data that included the distinguishing characteristics). However, because the supplemental algorithm is applied to only one repository chunk of size m (e.g., 32 MB), or possibly to a few such repository chunks that have already been found to be sufficiently similar to an input chunk, the degraded performance may be relatively insignificant in select applications. This is especially true compared to the alternative of executing the supplemental algorithm on an entire repository, especially one as large as 1 PB or more.<br>
[0112] The foregoing embodiment of the similarity search algorithm exemplifies the use of an index to resolve a type of nearest neighbor query,<br><br>
for which the most similar repository chunks to the input version chunk are sought. This embodiment by no means limits the invention. The index can be used to resolve other kind of queries, such as range queries; the particular type of query being determined by the specific application.<br>
[0113] For a better understanding of the foregoing similarity search, there foltows a description which exemplifies certain embodiments of the invention. The invention is not bound by this example. For convenience of description the repository includes a single chunk and the example will illustrate how an input chunk is classified as sufficiently similar to the repository chunk. EXAMPLE 1 Step 1: Build the index for the repository<br>
[0114] This example uses the following repository string: "Begin-at-the-beginaing-and-go-on~ till -you-come- to- the-end; -then-stop ." Note that this step is a by-product of previous iterations of the algorithm. It is included here explicitly for clarity of the example. Step 1a: Calculate the Hashes<br>
[0115] The example uses a rolling hash function to calculate the hash values at every byte offset It uses a modular hash function, which utilizes, for the sake of illustration, the prime number 8388593; the hash function used is h{X) =Xmod 8388593. In this example, the seed size is 8 bytes. Input string: ItBegin-at-the-beginning-and-go-on-till-you-come-to-the-end; -then-stop."<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
Step 2d: Match<br>
[0122] The version hash values 5615355 (version position 18), 6310941 (version position 35) and 614663 (version position 6) were found in the index. They correspond to positions in the repository 18, 46 and 6 respectively. A match is declared: the algorithm identified that "start-at-t±ie-beginning-and-contin-iie-to-the-eiid; -then-cease." is similar data to ^egin-at-the-begiTVQ±ag-and-go-on-till-you-coine-to-the-end;-then-stop.", and it found the corresponding positions.<br>
[0123] Note that by this example, the threshold for similarity (being the number of minimal matches of distinguishing characteristics) isy &gt;2. Had this threshold been set to 4, the chunks would not be regarded sufficiently similar, since only three matches were found. Note also that by this example n was set to 4, meaning the number of distinguishing characteristics of a repository chunk is 4, and A* was set to 8, meaning the number of distinguishing characteristics calculated for a version chunk is 8. By setting k&gt; n, the search returns the repository location of the number 7735648, which was moved from fourth maximal value in the repository to fifth maximal value in the input and thus would not have been found if k was set to 4 (k = n).<br>
[0124] This example illustrates how to find similar chunks in a degenerated case of a repository holding only one chunk. However, even for an index storing distinguishing characteristics of numerous chunks, the search procedure would still be very efficient, since search within the index (e.g., here stored as a hash table) is done in a very efficient manner, even for a large index. Note also that the data stored in respect of each index entry is small (in this example the hash value and position), and accordingly in many applications the index can be accommodated within the internal fast memory (RAM) of the computer, obviating the need to perform slow I/O operations, thereby further expediting the search within the index. Complexity (of synchronization algorithm)<br><br>
[0125] The time needed to calculate the hashes of the seeds of a version chunk is linear in the size of the chunk because a rolling hash is used.<br>
The time needed to calculate the k maxima is 0(m*log(/c)), which is<br>
reasonable because k is small. The time needed to search the index for the k<br>
distinguishing characteristics, if the index is a binary tree, is 0(/c*log(r)), where<br>
r = {R*k) I m is the number of entries in the index, where R is the size of the repository (up to about 250), k is small (typically 23) and m is the chunk size (typically 225), so r is typically 228, and log(r) = 28. Since k is small, searching the index overall is acceptable. The time needed to search the index for the k distinguishing characteristics, if the index is represented as a hash table, is<br>
/c*0(1). Therefore the chunk search time is dominated by the time rt takes to calculate and order the maxima, namely 0(m*log(/c)), and hence is equivalent to a small number of linear scans of the version chunk. Since k is small, the overall search time is acceptable. Note that this result is a fraction of the<br>
complexity of the brute force algorithm, which is 0(R*m), the product of the<br>
size of the repository R with the size of the chunk m.<br>
[0126] The complexity of the time needed to insert a version chunk into the index is the same as that for searching the index. No extra time is needed to calculate the n distinguishing characteristics since these were already calculated.<br>
[0127] The space requirements for this algorithm are those needed by the index. Each entry has for the given example parameters of 16 bytes, including key (distinguishing characteristic) and position data, and there are 228 (the value of r calculated above) of them in 1PB, so a 4 GB index is needed to manage 1 PB of repository data.<br>
[0128] The system according to the present embodiment may be executed on a suitably programmed computer. Likewise, the invention contemplates a computer program being readable by a computer for executing the method of the invention. The invention further contemplates a machine-readable memory tangibly embodying a program of instructions executable by the machine for executing the method of the invention.<br><br>
Binary Difference Algorithm<br>
[0129] A new binary difference algorithm is now described that efficiently computes the common sections of two data intervals. In the described embodiment, the algorithm uses the output of the previously described similarity search (synchronization) algorithm, that specifies for a given version chunk the locations of several pairs of matching distinguishing characteristics in the version and repository data. A pair of locations of matching distinguishing characteristics (one in the repository and one in the version) is herein denoted as an anchor. The anchors are used for alignment and to prune from further processing repository intervals that are not likely to contain matches with the version, and thus focus on the repository intervals that are most similar to the version chunk. This reduces the processing time of the algonthm.<br>
[0130] Based on the anchors, corresponding intervals are defined as pairs of version and repository intervals that are most likely to contain matching sections (identical data). The binary difference process is used on each of these interval pairs. Using the analog of sliding windows, instead of positioning the repository and version windows in matching offsets, we position them according to the anchors (possibly in non-matching offsets).<br>
[0131] One advantage of the present algorithm is use of a seed step size on one interval of the interval pair. While known binary difference or delta algorithms move in byte steps on both intervals, the present algorithm moves in, for example, byte steps only on one interval (the version interval), and in seed size (e.g. multiple byte) steps on the other interval (the repository interval). This technique speeds up processing and reduces space requirements, while not lessening the matching rate (since matches are expanded both backward and forward). Another advantage of the present algorithm is that, while known binary delta algorithms produce both add and copy directives, the present algorithm can be used to produce only copy directives, in sorted order. The add directives can then be implicitly deduced,<br><br>
as needed, from the copy directives, thus decreasing the storage required for the algorithm's output.<br>
[0132] The following table defines the symbols used in the present embodiment, while Figs. 7-8 illustrate the elements graphically.<br><br>
[0133] Fig. 9 is high-level (overview) flow chart showing the steps of one embodiment of the binary difference process operating on an anchor set. Fig. 10 is a more detailed flow chart showing the algorithm operating within an anchor set. Figs. 11-14 show an example of operating on a version interval and repository interval in accordance with this embodiment.<br>
[0134] The inputs in the described embodiment are a version chunk, an array of hash values at byte offsets associated with the version chunk, and a set of anchors linking the version chunk and the repository data. The latter two inputs are produced by the synchronization (similarity search) algorithm. The output of the binary difference algorithm is a set of pairs of matching (i.e.<br><br>
identical) intervals in the version chunk and repository data. A pair of matching intervals is denoted as a copy interval. Each copy interval may be coded as a copy directive, containing the start offsets of the associated intervals in the version and repository, and the interval size. The copy directives refer to separate (non-overlapping) version intervals, and are produced by the algorithm sorted in ascending version offset order.<br>
[0135] In Fig. 9, a flow chart (80) illustrates the steps of performing one embodiment of the binary difference algorithm. As is shown, the process starts by receiving as input the anchors from the similarity search and the version chunk's hash values at byte offsets (81). Next, the anchor sets are calculated (82); this may be accomplished as described in Step 1 below. Then, using the first anchor set (83), the binary difference algorithm is performed on the anchor set; this may be accomplished as described with respect to Fig. 10. This process is repeated for additional anchor sets (84-86), until there are no more anchor sets in the version and processing is done (87).<br>
[0136] A more detailed description is now given with respect to Figs. 10-14. In Fig. 10, a flowchart (90) illustrates one embodiment of the binary difference algorithm operating on an anchor set (step 84 in Fig. 9). Figs. 11-14 show a sequence of operations on one interval of a version chunk 120 and corresponding repository data 118. The interval is denoted as a current anchor set 122, and includes a plurality of locations of distinguishing characteristics 124 of version chunk 120, some of which have matching distinguishing characteristics 125 in repository data 118.<br>
[0137] Step 1 - Compute anchor sets (82 in Fig. 9): sort the anchors by ascending order of their version offsets. Traverse the ordered anchors and<br>
associate them with anchor sets as follows: a pair of successive anchors A. and AM are in the same anchor set if they have the same repository offset estimator, here for example given by: | [O(A]M )- O{A? )]- [O(A^ )- O{A? )] | 
where C is a constant selected for desired performance characteristics (discussed further below in regard to complexity). As long as successive<br><br><br><br><br><br>
buffer (step 102 in Fig. 10), and the next seed to be processed (step 104 in Fig. 10) is the first seed positioned after the anchor match in the version. If no<br>
anchor match is reached and the end of Iv. is also not reached (step 103 in<br>
Fig. 10), then the next seed to be processed in Iy (step 104 in Fig. 10) is the<br>
next unmatched seed defined as follows: if the current seed was not matched then the next unmatched seed starts one byte after the first byte of the current seed; if on the other hand the current seed was matched and expanded, then the next unmatched seed is the one starting one byte after the last byte of the<br>
last seed included in the said expansion. If the end of Iv. is reached (step 103<br>
in Fig. 10), then the processing of this anchor set ASj and associated<br>
corresponding intervals is done (step 105 in Fig. 10). If there is no next anchor set (step 85 in Fig. 9), the binary difference processing of the version chunk is complete (step 87 in Fig. 9). Otherwise processing continues to the next<br>
anchor set AS.^ (step 86 in Fig. 9) from step 2 detailed above.<br>
Complexity (binary difference)<br>
[0144] Storage: The embodiment of the binary difference algorithm described here uses a fixed sized hash table (RHashT), whose maximum size is proportional to the size of a chunk divided by the seed size, since the chunk size is an upper limit on the size of the repository interval. Hence the table size is sub-linear in the chunk size. In addition, temporary storage for the copy directives of the anchor matches is required. This is proportional to the number of anchors in a chunk, i.e. the number of its distinguishing characteristics, which is small. Therefore, the total storage requirements of the algorithm are sub-linear in the length of the chunk.<br>
[0145] Time: The phase of expanding the anchor matches (step 95) and loading the repository hash values into RHashT (step 96) takes one linear pass on the corresponding intervals. The phase of searching for the version hash values in RHashT (step 98) and expanding their found matches (step<br><br>
99) resembles the greedy algorithm, whose worst case time is quadratic in the corresponding interval length. However, by restricting the length of the hash table chains to a fixed size, the average time for this phase is between 1 to the length of the hash chain - linear passes on the corresponding intervals. Note that the running time is also a function of the amount of resemblance (identical data) between the version and repository intervals (the more resemblance, the less time required). There is also extra time taken by processing overlaps of successive corresponding intervals. It follows that the average total time required is 2 linear passes on the corresponding intervals.<br>
[0146] The systems and methods disclosed herein may be embodied in various forms including, for example, a data processor, such as a computer. Moreover, the above-noted features and other aspects and principles of the present invention may be implemented in various environments. Such environments and related applications may be specially constructed for performing the various processes and operations according to the invention or they may include a general-purpose computer or computing platform selectively activated or reconfigured by code to provide the necessary functionality. The processes disclosed herein are not inherently related to any particular computer or other apparatus, and may be implemented by a suitable combination of hardware, software, and/or firmware. For example, various general-purpose machines may be used with programs written in accordance with teachings of the invention, or it may be more convenient to construct a specialized apparatus or system to perform the required methods and techniques.<br>
[0147] Systems and methods consistent with the present invention also include computer readable media that include program instruction or code for performing various computer-implemented operations based on the methods and processes of the invention. The media and program instructions may be those specially designed and constructed for the purposes of the invention, or they may be of the kind well known and available to those having skill in the computer software arts. Moreover, the computer readable media may be in the form of a signal on a carrier wave or may be in the form of a storage<br><br>
media such as a disk. Examples of program instructions include, for example, machine code, such as produced by a compiler, and files containing a high level code that can be executed by the computer using an interpreter.<br>
[0148] As shown in Fig. 15, a data processor 300 receives input 305 and may include a central processing unit 320, a storage module 350, and/or an input/output (I/O) module 330. The I/O module 330 may include one or more input/output devices including a display 335, a keyboard, a mouse, an input storage device, a printer 336, and a network interface 338. The network interface permits the data processor to communicate through a network, such as a communications channel. The central processing unit may include, for example, one or more of the following: a central processing unit, a coprocessor, memory, registers, and other processing devices and systems as appropriate.<br>
[0149] A storage device may be embodied by a variety of components or subsystems capable of providing storage, including, for example, a hard drive, an optical drive, a general-purpose storage device, a removable storage device, and/or memory.<br>
[0150] Various embodiments of the methods and systems of the invention described herein are useful for identifying data in an input stream that already exists in a repository. Products utilizing such systems and methods include backup-to-disk products to save disk storage space by not repeatedly storing backup data that has not changed since the previous time it was backed up. This saves the end user disk space when storing multiple backups in the same repository.<br>
[0151] The systems and methods of the present invention may be included in storage equipment, intelligent switches, servers, and software applications. The methods and systems may be bundled with derivative products including other components. Service providers can utilize the systems and methods to offer the described capabilities as a service. The systems and methods may be particularly useful in the data protection market, e.g., for backup and recovery, replication, vaulting and media management. Other implementations may include use in primary storage.<br><br>
[0152] The systems and methods described herein relate to managed storage medium and representation of data in a managed repository. This may include disks, tapes and any other form of storage medium that may become commercially viable over time. The invention is not limited to the use of disks or fixed media, but is also applicable to removable media. For example, a removable disk may be used as a target output device; it may be managed in a similar way to tape, both being removable media.<br>
[0153] One approach to design of a system which includes removable media such as tapes, is to have a disk operate as a store for those chunks or elements that are most referenced, and have the least referenced chunks moved onto tape media. This could be balanced by a management system that takes into consideration the newness of any chunk. Also, the system may move related repository chunks to tape as a whole set to be archived and restored from.the archive as a set. This would multiply the advantages of the invention. For example, if 100 pieces of media were required to be used without the invention then, for example, ten pieces of media may only be required after utilization of the invention. The media may comprise virtual media that describes itself as a repository.<br>
[0154] Various embodiments of the synchronization algorithm and binary difference algorithm described herein have execution time that is linear with respect to a size of the version and space that is constant (depending on the size of the chunk and the anchor set). The reuse of calculated values between the algorithms saves computing time.<br>
[0155] The described embodiments also illustrate the use of two memory hierarchies. The synchronization algorithm computes and temporarily stores a set of representation (e.g., hash) values for the input data, from which a set of distinguishing characteristics is derived for identifying similar data regions in the repository, and which distinguishing characteristics are stored in an index once the input data is deposited in the repository. The representation values of the input data in temporary storage can then be used in the binary difference algorithm for identifying exact data matches with the repository data. The binary difference algorithm computes a<br><br>
set of representation (e.g., hash) values for the data regions of interest in the repository, and temporarily stores such values in memory, for comparison with the representation values of the input data. By processing corresponding intervals of the repository data and input data, a relatively small amount of memory can be used for storing representation values. Also, the matched data segments are produced in positional order of input data, which saves on sorting time and storage requirements.<br>
[0156] Furthermore, the embodiments described herein of the synchronization algorithm and binary difference algorithm scale to a petabyte size repository. In various embodiments, the ratio of the repository size to the index size is up to 250,000:1, enabling a 4 GB index to represent 1 PB repository, and enabling this index to fit into the memory of commercially-available, commodity-type computers. Where a hash table is used as the index, searching the index is a constant time and constant space 0(1) operation, and makes the find process independent of the size of the repository, for repositories of up to 1 PB. If the repository is not limited to 1 PB, then a binary tree or B-tree can be used for the index. The size of the index is still smaller than the repository by a factor of 250,000:1, and searching the index is an operation that takes O(log(m/250,000)), where m is the size of the repository. For a 1PB repository, m is 250, so log(m/250,000) is 32.<br>
[0157] The systems and methods described herein can provide a data storage system that implements large-scale lossless data reduction of an input data with respect to a repository by partitioning the input data into parts that are in the repository and those that are not. The partitioning is done by a two-step process:<br>
(1) for each chunk of input data, find all regions in the repository that contain data that is similar to it,<br>
where the find process also provides a rough estimate of the similarity, providing the ability to grade levels of similarity.<br><br>
Where the find process can be done using an index and memory even though the repository is very large, where the ratio of the repository size to index size can be up to 250:000:1, and<br>
where within each region found, the search finds one or more actual places that are corresponding, and (2) for all the regions found, choose the most similar region in the repository and binary difference it by<br>
reading that part of the repository into memory,<br>
comparing the input chunk to the part of the repository to find the exact changes while using the actual corresponding places as guide, the output of which is the partition identified above. The data in the input data that was found in the repository does not need to be stored again. The characteristics of the input data can be added to the index.<br>
[0158] The embodiments of the binary difference algorithm described herein have a number of advantages. The matched distinguishing characteristics provided by the similarity search (of the index) form the frame of reference for the binary difference process, as well as the logical partitions within this frame (e.g., the anchors). The binary difference algorithm requires only one hash table, and this hash table is small, since it stores only one value for every seed of the repository data segment of interest. The representation values of the input data at every sub-seed step (e.g., byte) are known, since they were calculated during the index search. The incremental cost of the binary difference process is small, and it is linear in the size of the input data. Because the repository hash table is searched at every sub-seed interval (e.g., byte), the binary difference search finds misaligned data.<br>
[0159] In various embodiments, the binary difference method can be used for performing a linear time and constant space 0(1) process for comparing the input data and the region of the repository that were identified to be similar. The process uses previously calculated results of the similarity search, and only one repository hash table that is smaller than the identified<br><br>
region in the repository by a factor of the seed size. The binary difference process finds identical data even if it has been swapped or misaligned. It finds all identical data that is at least seed size length, where the hash table is sufficiently large. The process elicits a list of sub-regions in the input data that were found, in the order of their appearance in the input data.<br>
[0160] In another embodiment of the present invention, the version data, or new data, may be located on one system or computer whereas the repository may be located on another system or computer different from the first system. In such a scenario, the delta information must be determined via communication between the first system and the second or remote system. As described in the foregoing, large amounts of data are being managed and, therefore, the bandwidth used in the system must be minimized wherever possible. In accordance with one aspect of the present invention, a minimum amount of bandwidth is used to accomplish the updating of the repository located remotely from the new or version data.<br>
[0161] As shown in Fig. 16, a system (1600) similar to that which is shown in Fig. 1 includes a network (1601), which, as above, can be a SAN or a network based on TCP/IP, to provide communication between a server A (1602), a server B (1604), a server C (1606) and a server D (1608). For explanatory purposes only, server B (1604) has coupled to it a repository B (17), while server D (1608) has coupled to it a repository D (17). The repository D (17) may be a full or partial mirror, backup or replication copy of the repository B (17) and thus has the same information stored thereon. Server A (1602) and server C (1606) do not have respective repositories.<br>
[0162] In one explanatory scenario, the server A (1602) has the new or version data and the repository B (17) has stored on it the repository data and chunks as described above.<br>
[0163] In the explanatory scenario, server A (1602) has new data that needs to be stored in repository B (17). From the foregoing description, it is understood that the set of distinguishing or identifying characteristics of the new data would be calculated, forwarded to the server B (1604) for use to search the index to find the locations of the repository data that are similar to<br><br>
the new or version data, the older or similar data from the repository B (17) is retrieved and the new data and the old data are compared to determine the delta or differences.<br>
[0164] As server A (1602) contains the new data, in order to determine the delta, one could decide that the similar data from repository B (17) has to be transmitted through to the server A (1602). This transmission could represent, however, a large percentage of the bandwidth of the network (1601). Once the server A (1602) has determined the delta, in order to update the repository B (17), the delta information must be transmitted from server A (1602) through the network (1601) to the server B (1604) to be used to update the repository B (17).<br>
[0165] In accordance with one aspect of an embodiment of the present invention, the bandwidth necessary to update the repository B (17) is reduced. Advantageously, the similar data from repository B (17) is not transmitted to server A (1602) in order to determine the delta information.<br>
[0166] The process of updating the repository B (17) with minimal bandwidth usage, in accordance with one embodiment of the present invention, will now be described with respect to the method (1700), as shown in Fig. 17. At step (1702), the set of characteristics for the version or new data on server A (1602) is calculated locally at the server A (1602). The server A (1602) transmits the calculated set of characteristics to server B (1604) at step (1704.) The remote server, in this case server B (1604), searches for matches to the received characteristics to identify one or more similar data chunks held in repository B (17), step (1706.) If a match is found in step (1708,) control passes to step (1710) where the server B (1604) retrieves the similar data chunk from the repository B (17).<br>
[0167] To determine the delta between the new data and the identified similar remote data that was found in repository B (17), step (1712), a modified version of a remote differencing procedure of low communication cost, e.g., the rsync utility, is used. By using a modified existing remote differencing procedure such as rsync, the amount of network bandwidth that is used to identify the delta information is significantly reduced.<br><br>
[0168] The modified remote differencing procedure determines the differences between the new data and the identified similar remote data without all of the new data and all of the identified similar data having to be on the same system. As a result of the modified procedure, the amount of data that has to be transmitted over the network is reduced. In operation, any one of a number of different remote differencing processes can be modified for this application.<br>
[0169] Thus, in one embodiment of the modified remote differencing process, hashes of the new data and the identified similar remote data are calculated, using the same algorithm, by the local system, server A (1602), and the remote system (17), server B, respectively. These hashes are then compared and those hashes that differ represent portions of respective data that are different. The data for the differing portions are then conveyed from server A to server B for storage on the repository B. The generating and comparing of hashes reduces the amount of data bandwidth necessary to determine the differences in the data.<br>
[0170] Subsequent to step (1712), the delta data has been identified and if it is determined, at step (1714,) that the repository B (17) is to be updated, control passes to step (1716) where the remote repository B (17) is updated as per the description above.<br>
[0171] Returning to step (1708), if no matches are found, control passes to step (1714) where the determination to update the repository B (17) is made, and if no update is to be performed, then control passes to step (1718.)<br>
[0172] In another operating scenario, it may be the situation where server A (1602) has new or version data that it needs to convey to server C (1602). As shown in the system (1600), neither of server A (1602) nor server C (1606) includes a repository. Where the amount of new data may be quite large, in one embodiment of the present invention the amount of data bandwidth necessary to convey the new data from server A (1602) to server C (1606) is minimized.<br><br>
[0173] A method (1800) for transmitting new data from server A (1602) to server C (1606) using a minimal amount of the bandwidth of the network (1601) will be described with respect to Fig. 18. Steps (1702-1712) are the same as have already been described above with respect to Fig. 17. Subsequent to step (1712), at step (1802,) server A (1602) sends the delta information, and identifier information of the similar data, to the second system, i.e., server C (1606). The identifier information of the similar data would include information regarding the location of the repository on which the repository data is located, in this case, repository B (17), an address of repository B (17) which may be an IP address of server B (1604), information regarding the specific repository chunk or chunks that have been identified as being similar, e.g., a reference label, and a timestamp identifier to synchronize the state of repository B (17) from which the differences or delta information was generated at step (1712). This timestamp information may be necessary to ensure that subsequent operations by server C (1606) are with respect to repository B (17) having a same state at which the differences were determined in step (1712).<br>
[0174] At step (1804,) the second system, server C (1606), would use the information received from server A (1602) to retrieve from repository B (17) the identified similar data chunks. In one embodiment, server C (1606) may request the entire identified repository chunk and replace those portions that are changed with the delta information received from server A (1602) or server C (1606) may request from repository B (17) only those portions of the repository data that have not changed and then combine with the delta information from server A (1602) to arrive at the new data from server A (1602).<br>
[0175] Advantageously, server A (1602) is able to convey the new data to server C (1606) using a minimal amount of bandwidth by only transmitting the delta information along with identifier information for the similar data that is stored at the repository B (17).<br>
[0176] An alternate embodiment of the method 1600, see Fig. 18, will now be described. In this alternate scenario, the receiving server C (1606), at<br><br>
step (1804), accesses repository D (17) instead of accessing repository B (17) in order to recreate the data sent from server A (1602). Server C (1606) may be aware that the repository D (17) has the same data as that in repository B (17) and may, for any number of reasons, determine that obtaining the similar data from repository D (17) is a better choice. These reasons could include any one or more of: system load characteristics; system availability; system response time, and system quality service level contracts. The coordination between server C (1606) and the system D (1608) and repository D (17) would be the same as that between server C (1606) and server B (1604) and repository B (17) described above. Once server C (1606) retrieves the information from repository D (17), repository D (17) may be updated to reflect the current data that was received from server A (1602) via server C (1606).<br>
[0177] In yet another embodiment, once server B (1604) and repository B (17) have been updated with the difference data from server A (1602), the repository D (17) can be updated by a transaction with server B (1604) and repository B (17).<br>
[0178] Of course, one of ordinary skill in the art will understand that server C (1606) and server D (1608) may be configured to be the same computer for reasons of system simplification or efficiency.<br>
[0179] Other embodiments of the invention will be apparent to those skilled in the art from consideration of the specification and practice of the invention disclosed herein. It is intended that the specification and examples be considered as exemplary only, with the scope of the invention being indicated by the appended claims.<br>
[0180] What is claimed is:<br><br><br><br><br><br><br><br><br><br>
CLAIMS<br>
1.	A method comprising identifying input data in repository data<br>
wherein the repository data comprise repository data chunks and the input<br>
data comprise input data chunks, and wherein each repository data chunk has<br>
a corresponding set of one or more repository data chunk distinguishing<br>
characteristics (RDCs), the method including the steps of, for each input data<br>
chunk:<br>
determining a set of one or more input data chunk distinguishing characteristics (IDCs);<br>
comparing the determined set of IDCs to one or more sets of RDCs; and<br>
identifying a repository data chunk that is similar to the input data chunk as a function of the comparing of the determined set of IDCs to the one or more sets of RDCs.<br>
2.	The method of claim 1, further comprising:<br>
determining one or more differences between the input data chunk and the identified similar repository data chunk by comparing the full data of the respective chunks.<br>
3.	The method of claim 1, wherein the input data is located at a<br>
first location and the repository data is located at a remote location, the<br>
method further comprising:<br>
determining the set of IDCs at the first location;<br>
transmitting the determined set of IDCs from the first location to the remote location; and<br>
comparing the determined set of IDCs to the one or more sets of RDCs at the remote location.<br>
4.	The method of claim 3, further comprising:<br><br>
determining one or more differences between the input data chunk and the identified similar repository data chunk without transmitting all of the first data chunk to the remote location and without transmitting all of the identified similar repository data chunk to the first location.<br>
5.	The method of claim 4., further comprising:<br>
updating the remote location with the one or more determined<br>
differences.<br>
6.	The method of claim 5, wherein:<br>
the first location is a first computer and the remote location is a remote computer different from the first computer, the first and remote computers being in networked communication with one another; and<br>
the repository data is stored in a data repository accessed through the remote computer.<br>
7.	The method of claim 1, wherein identifying similarity of a set of I DCs to a set of RDCs is a function of a similarity threshold.<br>
8.	The method of claim 7, wherein the similarity threshold is met when a predetermined number of the distinguishing characteristics in the set of IDCs is found in a set of RDCs.<br>
9.	The method of claim 8, wherein determining a set of distinguishing characteristics comprises:<br>
identifying one or more data portions within a respective data chunk; and<br>
calculating a mathematical hash value for each one or more data portion of a respective data chunk.<br>
10.	The method of claim 9, further comprising:<br><br>
determining the k largest mathematical hash values in a set, k being a predetermined number;<br>
identifying a respective data portion for each of the k largest hash values; and<br>
determining a set of distinguishing characteristics to be the mathematical hash values of a next sequential data portion relative to each data portion corresponding to each of the k largest mathematical hash values.<br>
11.	The method of claim 2, further comprising storing the determined differences in a repository.<br>
12.	The method of claim 11, wherein determining one or more differences comprises at least one of: determining a binary difference; and byte-wise factoring.<br>
13.	The method of claim 1, wherein the distinguishing characteristics are determined by one of: a hash function; a rolling hash function; and a modular hash function.<br>
14.	The method of claim 1, wherein the sets of RDCs are stored in an index as at least one of: a binary tree, a B tree, a sorted list, and a hash table.<br>
15.	The method of claim 1, wherein each of the repository data chunks and the input data chunks comprises a plurality of seeds, each seed being a consecutive sequence of base elements and having the same seed size s, and wherein the distinguishing characteristics are hash values of a selected subset of the seeds of the respective chunk.<br>
16.	The method of claim 15, wherein the seeds comprise overlapping seeds.<br><br>
17.	The method of claim 1, wherein the method is used for at least one of: data factoring; and data backup.<br>
18.	The method of claim 1, wherein the determining similar repository chunk step is conducted in a time independent of a size of the repository and linear in a size of the input data.<br>
19.	A method of searching in repository data for data that are similar to an input data, the method comprising:<br>
dividing the repository data into one or more repository chunks;<br>
for each repository chunk, calculating a corresponding set of repository distinguishing characteristics (RDCs), each set of RDCs comprising at least one distinguishing characteristic;<br>
maintaining an index associating each set of RDCs and the corresponding repository chunk;<br>
dividing the input data into one or more input chunks, and for each input chunk:<br>
calculating a corresponding set of input distinguishing<br>
characteristics (IDCs), the set of IDCs comprising at least one<br>
distinguishing characteristic;<br>
comparing the set of IDCs to one or more sets of RDCs stored<br>
in the index; and<br>
if a similarity threshold j of the distinguishing characteristics in<br>
the set of IDCs is found in a set of RDCs stored in the index,<br>
determining that a similarity exists between the input chunk and the<br>
corresponding repository chunk.<br>
20.	The method according to claim 19, wherein each of the sets of<br>
RDCs and the sets of IDCs is obtained by:<br>
partitioning the respective data chunk into a plurality of seeds, each seed being a smaller part of the respective data chunk and ordered in a seed sequence;<br><br>
applying a hash function to each of the seeds to generate a plurality of hash values, wherein each seed yields one hash value;<br>
selecting a subset of the plurality of hash values;<br>
determining positions of the seeds within the seed sequence corresponding to the selected subset of hash values;<br>
applying a function to the determined positions to determine corresponding other positions within the seed sequence; and<br>
defining the set of distinguishing characteristics as the hash values of the seeds at the determined other positions.<br>
21.	The method of claim 20, wherein:<br>
the subset of hash values is selected by identifying the k largest hash values; and<br>
the function applied to determine the corresponding other positions is to identify a next seed in the seed sequence.<br>
22.	The method of claim 19, further comprising:<br>
determining one or more differences between the input data chunk and the identified similar repository data chunk by comparing the full data of the respective data chunks.<br>
23.	The method of claim 22, further comprising:<br>
storing the determined differences in a same repository in which the repository data is stored.<br>
24.	The method of claim 19, wherein the input data is located at a<br>
first location and the repository data and the index are located at a remote<br>
location, the method further comprising:<br>
determining the set of IDCs at the first location; transmitting the determined set of IDCs from the first location to the remote location;<br><br>
comparing the determined set of I DCs to the one or more sets of RDCs at the remote location; and<br>
determining one or more differences between the input data chunk and the identified similar repository data chunk without transmitting all of the input data chunk to the remote location and without transmitting all of the identified similar repository data chunk to the first location.<br>
25.	The method of claim 24, further comprising:<br>
storing the determined differences at the remote location.<br>
26.	The method of claim 19, wherein the method is used for at least one of: data factoring, and data backup.<br>
27.	A system for identifying input data in repository data wherein the repository data comprise repository data chunks and the input data comprise input data chunks, and wherein each repository data chunk has a corresponding set of one or more repository data chunk distinguishing characteristics (RDCs), the system comprising:<br>
means for, for each input data chunk, determining a set of one or more input data chunk distinguishing characteristics (IDCs);<br>
means for, for each input data chunk, comparing the determined set of IDCs to one or more sets of RDCs; and<br>
means for, for each input data chunk, identifying a repository data chunk that is similar to the input data chunk as a function of the comparing of the determined set of IDCs to the one or more sets of RDCs.<br>
28.	The system of claim 27, further comprising:<br>
means for, for each input data chunk, determining one or more differences between the input data chunk and the identified similar repository data chunk by comparing the full data of the respective chunks.<br><br>
29.	The system of claim 27, wherein the input data is located at a<br>
first location and the repository data is located at a remote location, the<br>
system further comprising:<br>
means for determining the set of I DCs at the first location;<br>
means for transmitting the determined set of IDCs from the first location to the remote location; and<br>
comparing the determined set of IDCs to the one or more sets of RDCs at the remote location.<br>
30.	The system of claim 29, further comprising:<br>
means for determining one or more differences between the input data chunk and the identified similar repository data chunk without transmitting all of the first data chunk to the remote location and without transmitting all of the identified similar repository data chunk to the first location.<br>
31.	The system of claim 30, further comprising:<br>
means for updating the remote location with the one or more determined differences.<br>
32.	The system of claim31, wherein:<br>
the first location is a first computer and the remote location is a remote computer different from the first computer, the first and remote computers being in networked communication with one another; and<br>
the repository data is stored in a data repository accessed through the remote computer.<br>
33.	The system of claim 27, wherein identifying similarity of a set of IDCs to a set of RDCs is a function of a similarity threshold.<br>
34.	The system of claim 33, wherein the similarity threshold is met when a predetermined number of the distinguishing characteristics in the set of IDCs is found in a set of RDCs.<br><br>
35.	The system of claim 34, wherein means for determining a set of<br>
distinguishing characteristics comprises:<br>
means for identifying one or more data portions within a respective data chunk; and<br>
means for calculating a mathematical hash value for each one or more data portion of a respective data chunk.<br>
36.	The system of claim 35, further comprising:<br>
means for determining the k largest mathematical hash values in a set, k being a predetermined number,<br>
means for identifying a respective data portion for each of the k largest hash values; and<br>
means for determining a set of distinguishing characteristics to be the mathematical hash values of a next sequential data portion relative to each data portion corresponding to each of the k largest mathematical hash values.<br>
37.	The system of claim 28, further comprising means for storing the determined differences in a repository.<br>
38.	The system of claim 37, wherein means for determining one or more differences comprises at least one of:<br>
means for determining a binary difference; and means for byte-wise factoring.<br>
39.	The system of claim 27, wherein the distinguishing characteristics are determined by one of: a hash function; a rolling hash function; and a modular hash function.<br>
40.	The system of claim 27, wherein the sets of RDCs are stored in an index as at least one of: a binary tree, a B tree, a sorted list, and a hash table.<br><br>
41.	The system of claim 27, wherein each of the repository and input data chunks comprises a plurality of seeds, each seed being a consecutive sequence of base elements and having the same seed size s, and wherein the distinguishing characteristics are hash values of a selected subset of the seeds of the respective chunk.<br>
42.	The system of claim 41, wherein the seeds comprise overlapping seeds.<br>
43.	The system of claim 27, wherein the system is used for at least one of: data factoring; and data backup.<br>
44.	The system of claim 27, wherein determining a similar repository chunk is conducted in a time independent of a size of the repository and linear in a size of the input data.<br>
45.	A system for searching in repository data for data that are similar to an input data, the system comprising:<br>
means for dividing the repository data into one or more repository chunks;<br>
means for, for each repository chunk, calculating a corresponding set of repository distinguishing characteristics (RDCs), each set of RDCs comprising at least one distinguishing characteristic;<br>
means for maintaining an index associating each set of RDCs and the corresponding repository chunk;<br>
means for dividing the input data into one or more input chunks, and for each input chunk:<br>
calculating a corresponding set of input distinguishing<br>
characteristics (IDCs), the set of IDCs comprising at least one<br>
distinguishing characteristic;<br><br>
comparing the set of IDCs to one or more sets of RDCs stored in the index; and<br>
if a similarity threshold j of the distinguishing characteristics in the set of IDCs is found in a set of RDCs stored in the index, determining that a similarity exists between the input chunk and the corresponding repository chunk.<br>
46.	The system of claim 45, wherein each of the sets of RDCs and<br>
the sets of IDCs is obtained by:<br>
partitioning the respective data chunk into a plurality of seeds, each seed being a smaller part of the respective data chunk and ordered in a seed sequence;<br>
applying a hash function to each of the seeds to generate a plurality of hash values, wherein each seed yields one hash value;<br>
selecting a subset of the plurality of hash values;<br>
determining positions of the seeds within the seed sequence corresponding to the selected subset of hash values;<br>
applying a function to the determined positions to determine corresponding other positions within the seed sequence; and<br>
defining the set of distinguishing characteristics as the hash values of the seeds at the determined other positions.<br>
47.	The system of claim 46, wherein:<br>
the subset of hash values is selected by identifying the k largest hash values; and<br>
the function applied to determine the corresponding other positions is to identify a next seed in the seed sequence.<br>
48.	The system of claim 45, further comprising:<br>
means for determining one or more differences between the input data chunk and the identified similar repository data chunk by comparing the full data of the respective data chunks.<br><br>
49.	The system of claim 48, further comprising:<br>
means for storing the determined differences in a same repository in which the repository data is stored.<br>
50.	The system of claim 45, wherein the input data is located at a<br>
first location and the repository data and the index are located at a remote<br>
location, the system further comprising:<br>
means for determining the set of IDCs at the first location;<br>
means for transmitting the determined set of IDCs from the first location to the remote location;<br>
means for comparing the determined set of IDCs to the one or more sets of RDCs at the remote location; and<br>
means for determining one or more differences between the input data chunk and the identified similar repository data chunk without transmitting all of the input data chunk to the remote location and without transmitting all of the identified similar repository data chunk to the first location.<br>
51.	The system of claim 50, further comprising:<br>
means for storing the determined differences at the remote location.<br>
52.	The system of claim 45, used for at least one of: data factoring, and data backup.<br>
53.	A computer-readable medium encoded with computer-executable instructions that cause a computer to perform a method comprising identifying input data in repository data wherein the repository data comprise repository data chunks and the input data comprise input data chunks, and wherein each repository data chunk has a corresponding set of one or more repository data chunk distinguishing characteristics (RDCs), the method including the steps of, for each input data chunk:<br><br>
determining a set of one or more input data chunk distinguishing characteristics (IDCs);<br>
comparing the determined set of IDCs to one or more sets of RDCs; and<br>
identifying a repository data chunk that is similar to the input data chunk as a function of the comparing of the determined set of IDCs to the one or more sets of RDCs.<br>
54      The computer-readable medium of claim 53, further comprising computer-executable instructions to perform the steps of:<br>
determining one or more differences between the input data chunk and the identified similar repository data chunk by comparing the full data of the respective chunks.<br>
55.	The computer-readable medium of claim 53, wherein the input<br>
data is located at a first location and the repository data is located at a remote<br>
location, further comprising computer-executable instructions to perform the<br>
steps of:<br>
determining the set of IDCs at the first location;<br>
transmitting the determined set of IDCs from the first location to the remote location; and<br>
comparing the determined set of IDCs to the one or more sets of RDCs at the remote location.<br>
56.	The computer-readable medium of claim 55, further comprising<br>
computer-executable instructions to perform the steps of:<br>
determining one or more differences between the input data chunk and the identified similar repository data chunk without transmitting all of the first data chunk to the remote location and without transmitting all of the identified similar repository data chunk to the first location.<br><br>
57.	The computer-readable medium of claim 56, further comprising<br>
computer-executable instructions to perform the steps of:<br>
updating the remote location with the one or more determined differences.<br>
58.	The computer-readable medium of claim 57, wherein:<br>
the first location is a first computer and the remote location is a remote computer different from the first computer, the first and remote computers being in networked communication with one another; and<br>
the repository data is stored in a data repository accessed through the remote computer.<br>
59.	The computer-readable medium of claim 53, wherein identifying similarity of a set of IDCs to a set of RDCs is a function of a similarity threshold.<br>
60.	The computer-readable medium of claim 59f wherein the similarity threshold is met when a predetermined number of the distinguishing characteristics in the set of IDCs is found in a set of RDCs.<br>
61.	The computer-readable medium of claim 60, wherein determining a set of distinguishing characteristics comprises:<br>
identifying one or more data portions within a respective data chunk; and<br>
calculating a mathematical hash value for each one or more data portion of a respective data chunk.<br>
62.	The computer-readable medium of claim 61, further comprising<br>
computer-executable instructions to perform the steps of:<br>
determining the k largest mathematical hash values in a set, k being a predetermined number;<br><br>
identifying a respective data portion for each of the k largest hash values; and<br>
determining a set of distinguishing characteristics to be the mathematical hash values of a next sequential data portion relative to each data portion corresponding to each of the k largest mathematical hash values.<br>
»<br>
63.	The computer-readable medium of claim 53, further comprising<br>
computer-executable instructions to perform the step of storing the determined differences in a repository.<br>
64.	The computer-readable medium of claim 63, wherein determining one or more differences comprises at least one of: determining a binary difference; and byte-wise factoring.<br>
65.	The computer-readable medium of claim 53, wherein the distinguishing characteristics are determined by one of: a hash function; a rolling hash function; and a modular hash function.<br>
66.	The computer-readable medium of claim 53, wherein the sets of RDCs are stored in an index as at least one of: a binary tree, a B tree, a sorted list, and a hash table.<br>
67.	The computer-readable medium of claim 53, wherein each of the repository and input data chunks comprises a plurality of seeds, each seed being a consecutive sequence of base elements and having the same seed size s, and wherein the distinguishing characteristics are hash values of a selected subset of the seeds of the respective chunk.<br>
68.	The computer-readable medium of claim 67, wherein the seeds comprise overlapping seeds.<br><br>
69.	The computer-readable medium of claim 53, wherein the method is used for at least one of: data factoring; and data backup.<br>
70.	The computer-readable medium of claim 53, wherein the determining similar repository chunk step is conducted in a time independent of a size of the repository and linear in a size of the input data.<br>
71.	A computer-readable medium encoded with computer-executable instructions that cause a computer to perform a method of searching in repository data for data that are similar to an input data, the method comprising:<br>
dividing the repository data into one or more repository chunks;<br>
for each repository chunk, calculating a corresponding set of repository distinguishing characteristics (RDCs), each set of RDCs comprising at least one distinguishing characteristic;<br>
maintaining an index associating each set of RDCs and the corresponding repository chunk;<br>
dividing the input data into one or more input chunks, and for each input chunk:<br>
calculating a corresponding set of input distinguishing<br>
characteristics (IDCs), the set of IDCs comprising at least one<br>
distinguishing characteristic;<br>
comparing the set of IDCs to one or more sets of RDCs stored<br>
in the index; and<br>
if a similarity threshold j of the distinguishing characteristics in<br>
the set of IDCs is found in a set of RDCs stored in the index,<br>
determining that a similarity exists between the input chunk and the<br>
corresponding repository chunk.<br>
72.	The computer-readable medium of claim 71, further comprising<br>
computer-executable instructions to perform the step of obtaining each of the<br>
sets of RDCs and the sets of IDCs by:<br><br>
partitioning the respective data chunk into a plurality of seeds, each seed being a smaller part of the respective data chunk and ordered in a seed sequence;<br>
applying a hash function to each of the seeds to generate a plurality of hash values, wherein each seed yields one hash value;<br>
selecting a subset of the plurality of hash values;<br>
determining positions of the seeds within the seed sequence corresponding to the selected subset of hash values;<br>
applying a function to the determined positions to determine corresponding other positions within the seed sequence; and<br>
defining the set of distinguishing characteristics as the hash values of the seeds at the determined other positions.<br>
73.	The computer-readable medium of claim 72, wherein:<br>
the subset of hash values is selected by identifying the k largest hash values; and<br>
the function applied to determine the corresponding other positions is to identify a next seed in the seed sequence.<br>
74.	The computer-readable medium of claim 71, further comprising<br>
computer-executable instructions to perform the step of:<br>
determining one or more differences between the input data chunk and the identified similar repository data chunk by comparing the full data of the respective data chunks.<br>
75.	The computer-readable medium of claim 74, further comprising<br>
computer-executable instructions to perform the step of:<br>
storing the determined differences in a same repository in which the repository data is stored.<br>
76.	The computer-readable medium of claim 71, wherein the input<br>
data is located at a first location and the repository data and the index are<br><br>
located at a remote location, further comprising computer-executable instructions to perform the steps of:<br>
determining the set of IDCs at the first location;<br>
transmitting the determined set of IDCs from the first location to the remote location;<br>
comparing the determined set of IDCs to the one or more sets of RDCs at the remote location; and<br>
determining one or more differences between the input data chunk and the identified similar repository data chunk without transmitting all of the input data chunk to the remote location and without transmitting all of the identified similar repository data chunk to the first location.<br>
77.	The computer-readable medium of claim 76, further comprising<br>
computer-executable instructions to perform the step of:<br>
storing the determined differences at the remote location.<br>
78.	The computer-readable medium of claim 71, wherein the<br>
method is used for at least one of: data factoring, and data backup.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICAgIENPUlJFU1BPTkRFTkNFICBPVEhFUlMgIDEyLTA2LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007    CORRESPONDENCE  OTHERS  12-06-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICAgQU1FTkRFRCBDTEFJTVMgIDMwLTA5LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007   AMENDED CLAIMS  30-09-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICAgQVNTSUdOTUVOVCAgMDEtMTAtMjAxMy5wZGY=" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007   ASSIGNMENT  01-10-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICAgQ09SUkVTUE9OREVOQ0UgT1RIRVJTIDAxLTEwLTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007   CORRESPONDENCE OTHERS 01-10-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICAgRk9STS0xICAwMS0xMC0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007   FORM-1  01-10-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICAgRk9STS0yICAwMS0xMC0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007   FORM-2  01-10-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICAgRk9STS0zICAzMC0wOS0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007   FORM-3  30-09-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICAgRk9STS02ICAwMS0xMC0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007   FORM-6  01-10-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICAgT1RIRVIgUEFURU5UIERPQ1VNRU5UICAzMC0wOS0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007   OTHER PATENT DOCUMENT  30-09-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICAgT1RIRVJTICAzMC0wOS0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007   OTHERS  30-09-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICAgUE9XRVIgT0YgQVRUT1JORVkgIDAxLTEwLTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007   POWER OF ATTORNEY  01-10-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICBBTUVOREVEIFBBR0VTIE9GIFNQRUNJRklDQVRJT04gIDA0LTA0LTIwMTQucGRm" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007  AMENDED PAGES OF SPECIFICATION  04-04-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICBFWEFNSU5BVElPTiBSRVBPUlQgUkVQTFkgUkVDRUlWRUQgIDA0LTA0LTIwMTQuLnBkZg==" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007  EXAMINATION REPORT REPLY RECEIVED  04-04-2014..pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICBFWEFNSU5BVElPTiBSRVBPUlQgUkVQTFkgUkVDRUlWRUQgIDMwLTA5LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007  EXAMINATION REPORT REPLY RECEIVED  30-09-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICBGT1JNLTEgIDA0LTA0LTIwMTQucGRm" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007  FORM-1  04-04-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICBGT1JNLTMgIDA0LTA0LTIwMTQucGRm" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007  FORM-3  04-04-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DSEVOUC0yMDA3ICBPVEhFUlMgIDA0LTA0LTIwMTQucGRm" target="_blank" style="word-wrap:break-word;">1094-CHENP-2007  OTHERS  04-04-2014.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1jaGVucC0yMDA3IGFzc2lnbm1lbnQgMDgtMDgtMjAwNy5wZGY=" target="_blank" style="word-wrap:break-word;">1094-chenp-2007 assignment 08-08-2007.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1jaGVucC0yMDA3IGNvcnJlc3BvbmRlbmNlIG90aGVycyAwOC0wOC0yMDA3LnBkZg==" target="_blank" style="word-wrap:break-word;">1094-chenp-2007 correspondence others 08-08-2007.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1jaGVucC0yMDA3IG90aGVycyAwOC0wOC0yMDA3LnBkZg==" target="_blank" style="word-wrap:break-word;">1094-chenp-2007 others 08-08-2007.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1jaGVucC0yMDA3LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1094-chenp-2007-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1jaGVucC0yMDA3LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1094-chenp-2007-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1jaGVucC0yMDA3LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">1094-chenp-2007-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1jaGVucC0yMDA3LWRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">1094-chenp-2007-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1jaGVucC0yMDA3LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1094-chenp-2007-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1jaGVucC0yMDA3LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">1094-chenp-2007-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1jaGVucC0yMDA3LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">1094-chenp-2007-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1jaGVucC0yMDA3LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">1094-chenp-2007-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1jaGVucC0yMDA3LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">1094-chenp-2007-pct.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTA5NC1DaGVucC0yMDA3LVBldGl0aW9uICB1bmRlciBSdWxlIDEzNy0xMigyKS5wZGY=" target="_blank" style="word-wrap:break-word;">1094-Chenp-2007-Petition  under Rule 137-12(2).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="264088-method-for-adjusting-a-water-temperature-and-a-pasteurisation-tunnel.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="264090-projection-display-system.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>264089</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1094/CHENP/2007</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>50/2014</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>12-Dec-2014</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>04-Dec-2014</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>15-Mar-2007</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTERNATIONAL BUSINESS MACHINES CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>ARMONK, NEW YORK 10504.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>HIRSCH, Michael</td>
											<td>12B Ha-atzmaut Street, 76804 Mazkeret Batya</td>
										</tr>
										<tr>
											<td>2</td>
											<td>BITNER, Haim</td>
											<td>3 Hativat Golani Street, 43333 Raanana</td>
										</tr>
										<tr>
											<td>3</td>
											<td>ARONOVICH, Lior</td>
											<td>17 Hachula Street, Apartment 8, 52255 Ramat-Gan</td>
										</tr>
										<tr>
											<td>4</td>
											<td>ASHER, Ron</td>
											<td>8 Sasha Argov Street, 69620 Tel-Aviv</td>
										</tr>
										<tr>
											<td>5</td>
											<td>BACHMAT, Eitan</td>
											<td>30 Yasur Street, Lehavim</td>
										</tr>
										<tr>
											<td>6</td>
											<td>KLEIN, Shmuel, T.</td>
											<td>31B Hashomrim Street, 76230 Rehovot</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F17/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2005/033363</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-09-15</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/194,086</td>
									<td>2005-07-29</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>10/941,632</td>
									<td>2004-09-15</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/264089-method-and-system-for-indentifying-input-data-in-a-repository-data by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:38:16 GMT -->
</html>
