<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/260857-a-method-and-integrated-circuit-for-issuing-a-next-instruction-of-a-program by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 02:09:13 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 260857:A METHOD AND INTEGRATED CIRCUIT FOR ISSUING A NEXT INSTRUCTION OF A PROGRAM</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD AND INTEGRATED CIRCUIT FOR ISSUING A NEXT INSTRUCTION OF A PROGRAM</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>An instruction memory unit comprises a first memory structure operable to store program instructions, and a second memory structure operable to store program instructions fetched from the first memory structure, and to issue stored program instructions for execution. The second memory structure is operable to identify a repeated issuance of a forward program redirect construct, and issue a next program instruction already stored in the second memory structure if a resolution of the forward branching instruction is identical to a last resolution of the same. The second memory structure is further operable to issue a backward program redirect construct, determine whether a target instruction is stored in the second memory structure, issue the target instruction if the target instruction is stored in the second memory structure, and fetch the target instruction from the first memory structure if the target instruction is not stored in the second memory structure.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT, 1970<br>
(39 of 1970)<br>
&amp;<br>
THE PATENTS RULES, 2003<br>
COMPLETE SPECIFICATION<br>
(See section 10, rule 13)<br><br>
INSTRUCTION MEMORY UNIT AND METHOD OF<br>
OPERATION"<br>
QUALCOMM  INCORPORATED<br>
an American company of 5775 Morehouse Drive, San Diego, California 92121 (United States of America)<br>
The following specification particularly describes the invention and the manner in which it is to be performed.<br><br>
WO 2006/110886	 	PCT/US2006/013948<br>
INSTRUCTION MEMORY UNIT AND METHOD OF OPERATION<br>
BACKGROUND<br>
I.	Field of the Invention<br>
[0001] The present disclosure pertains generally to digital signal processors, and more specifically to an instruction queue and method of operation.<br>
II.	Background<br>
[0002] Digital signal processors are specialized microprocessors that are capable of executing operations with speed. Digital signal processors (DSPs) are commonly embedded in a variety of devices such as mobile telephones, personal digital assistants, and portable computing systems. The reduction of power consumption in these portable and mobile devices is an important design goal in order to maximize battery life. As functionality for these mobile devices expand to include multimedia and graphics applications, power consumption has become one of the most significant design and implementation considerations.<br>
SUMMARY<br>
[0003] A consideration for reducing power consumption in digital signal processors is the energy used in the instruction memory unit when instructions are fetched from memory, instruction cache and instruction queue for execution, and when the fetched instructions are predecoded and decoded. Because digital signal processor programs typically spend the majority of time executing program loops, this characteristic may be exploited to reduce power consumption by the instruction memory unit.<br>
[0004] In one aspect of an embodiment, a method comprises issuing a backward program redirect construct containing a backward branch path from an instruction queue, determining whether the backward branch path is being taken, determining whether a target instruction indicated by the backward branch path is already stored in the instruction queue in response to the backward branch path is being taken, issuing the target instruction from the instruction queue in response to it being already stored in the instruction queue, and fetching the target instruction from an instruction cache coupled<br><br>
WO 2006/110886	 	PCT/US2006/013948<br>
to the instruction queue in response to the target instruction not already stored in the instruction queue.<br>
[0005] In another aspect of an embodiment, a method comprises issuing a forward program redirect construct containing a forward branch path from an instruction queue, determining whether a last resolution of the forward program redirect construct reaches the same result as a current resolution of the forward program redirect construct, and issuing a next instruction from the instruction queue in response to same result being reached by the last and current resolution of the forward program redirect construct.<br>
[0006] In yet another aspect of an embodiment, an instruction memory unit comprises a first memory structure operable to store program instructions, a second memory structure coupled to the first memory structure and operable to store program instructions fetched from the first memory structure, and operable to issue stored program instructions for execution. The second memory structure is operable to identify a repeated issuance of a forward branch instruction, and issue a next program instruction already stored in the second memory structure in response to a resolution of the forward branching instruction identical to a last resolution of the same forward branching instruction. The second memory structure is further operable to issue a backward branch instruction stored in the second memory structure, determine whether a target instruction thereof is stored in the second memory structure, issue the target instruction in response to the target instruction is stored in the second memory structure, and fetch the target instruction from the first memory structure in response to the target instruction not stored in the second memory structure.<br>
[0007] Therefore, program loop executions are "captured" so that program loops may be executed from the instruction queue without having to fetch instructions out of the instruction cache for every iteration of the loop. As the instruction queue is much smaller than the instruction cache, significant power savings and speed may be achieved by avoiding the instruction cache during these program loop iterations. Further, because instructions in the instruction queue are already predecoded, there is additional power savings in not using the instruction decoding logic for program loop execution during instruction queue operating mode. As described above, the operation of the instruction memory unit in instruction queue or instruction cache operating mode does not require any software code in the program instructions to provide advanced notice to<br><br>
WO 2006/110886	 	PCT/US2006/013948<br>
the instruction memory unit that a program loop execution is forthcoming and that special loop execution may take place.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0008] FIGURE 1 is a simplified block diagram of an embodiment of an instruction memory architecture of a digital signal processor;<br>
[0009] FIGURE 2A is a diagrammatical representation of exemplary contents of a portion of a main memory containing instructions 10 to 18;<br>
[0010] FIGURE 2B-D are diagrammatical representations of exemplary contents of an embodiment of an instruction queue (IQ) during three instruction execution scenarios;<br>
[0011] FIGURE 3 is an exemplary format of an embodiment of an instruction queue address;<br>
[0012] FIGURE 4 is a flowchart of an embodiment of a method of instruction queue operations when backward branching or zero overhead loop is encountered; and<br>
[0013] FIGURE 5 is a flowchart of an embodiment of a method of instruction queue operations when forward branching or jump is encountered.<br>
DESCRIPTION OF SPECIFIC EMBODIMENTS<br>
[0014] Because the reduction of power consumption has become a vital design goal for mobile devices, design engineers are looking at all aspects of the device for opportunities to minimize total power use. One area of opportunity is the power consumed by the digital signal processor, and more specifically the power consumed by the digital signal processor during program loop execution. Digital signal processors may spend over 80% of the time executing program loops. These program loops may be of various sizes but most are small program loops containing fewer than ten program instructions, for example. When the number of times a loop is executed is deterministic such as a FOR loop, the zero-overhead loop construct is typically used. When the number of loop iteration is unknown such as a WHILE loop, a backward branch instruction is typically used.    The instruction memory unit described herein and<br><br>
WO 2006/110886	 	PCT/US2006/013948<br><br>
operation thereof exploit these digital signal processor execution characteristics to reduce power consumption and increase execution speed.<br>
[0015] FIGURE 1 is a simplified block diagram of an embodiment of an instruction memory unit of a digital signal processor. The digital signal processor includes a main memory 10 where program instructions reside. In order to improve processing speed, an instruction buffering scheme is used. An instruction cache (1$) 12 with faster access speed is used to store instructions fetched from the main memory 10. An instruction queue (IQ) 14, with an even faster access speed, is used to queue up program instructions that will be immediately executed in an execution engine 16. Typically, the instruction queue 14 has a smaller storage capacity than the instruction cache 12, and even smaller storage capacity than the main memory 10. The power consumption of the instruction queue 14 during memory access is generally less than that of the instruction cache 12 and the main memory 10. The execution engine 16 may be a processor that specializes in arithmetic computations such as a digital signal processor. In one embodiment, the execution engine 16 may support interleaved multi-threading to take advantage of high clock speed and maximum core and memory utilization.<br>
[0016] FIGURE 2A is a diagrammatical representation of exemplary contents of a portion 20 of the main memory 10 containing instructions 10 to 18. Of these instructions, instruction 12 is a forward program redirect construct, such as a conditional forward branch instruction or a jump forward instruction with a positive offset. For simplicity, all program redirect constructs that have a forward path are hereinafter referred to as forward program redirect constructs. The forward program redirect construct, 12, jumps to instruction 16 if a predetermined condition is met. Instruction 17 is a conditional backward branch instruction, a jump instruction with a negative offset, or a zero overhead loop. For simplicity, all program redirect instructions that has a backward path are hereinafter referred to as a backward program redirect construct. The backward program redirect construct 17 jumps back to instruction 10 if a predetermined condition is met. Other instructions, 10, II, 13 through 16, and 18 are sequential instructions where execution of these instructions leads to the next instruction in memory.<br>
[0017] The instruction memory unit may operate in at least two modes: instruction cache mode and instruction queue mode.   During the instruction cache mode, the<br><br>
WO 2006/110886	 	PCT/US2006/013948<br><br>
instruction to be executed must be fetched from the instruction cache 12 into the instruction queue 14. During the instruction queue operating mode, the instructions to be executed are already loaded into the instruction queue 14 from the instruction cache 12, such as during iterations of a loop so that access to the instruction cache may be avoided. This strategy speeds up the operation of the instruction memory unit, and reduces power consumption by the instruction memory unit. Details of the operating modes of the instruction memory unit are set forth below.<br>
[0018] FIGURES 2B-D are diagrammatical representations of exemplary contents of an embodiment of an instruction queue during three instruction execution scenarios. In FIGURE 2B, the instruction queue 14 has been loaded with instructions with the conditional forward branch being taken as the execution path. Therefore, 16 is loaded into the instruction queue 14 immediately after 12. Referring also to FIGURE 3, an exemplary instruction queue address and control portion 27 of an instruction queue entry is shown. The instruction queue address and control format 27 may include an instruction address (IA) field 28 and a T-bit field 29. A program counter maintains the address of the current instruction address during execution. The T-bit may be used to indicate whether a forward branch was taken. The T-bit is updated during forward program redirect construct resolution. Therefore, when 16 is loaded into the instruction queue entry 3, the T-bit is set for entry 2 where the forward program redirect construct is stored. Instruction 17 is then loaded into entry 4. When instruction 17 is issued, the backward branch is taken. This causes a lookup for instruction 10 in the instruction queue 14. Because instruction 10 is in the instruction queue 14, the instruction memory unit is put into an instruction queue operation mode where the needed instructions are already loaded into the instruction queue 14 and no access to the instruction cache 12 is necessary. The instruction queue is simply sequentially read to obtain the next instructions, as indicated by an instruction queue read pointer that is sequentially incremented. When instructions 10, II, and then 12 are executed again, if the branch forward path is taken again, execution jumps to the next instruction in the instruction queue 14 in entry 3, which is 16.<br>
[0019] If in this iteration the branch forward path is not taken but was taken in the prior iteration as indicated by a T-bit that is set, then execution leaves the instruction queue mode and returns to an instruction cache mode. The T-bit is reset to indicate that<br><br>
WO 2006/110886	 	PCT/US2006/013948<br>
the current branch is not taken. The sequential instructions after instruction 12, instructions 13 through 17 are loaded into entries 3 through 7 of the instruction queue 14, as shown by the contents 24 of the instruction queue shown in FIGURE 2C. When instruction 17, a conditional backward branch, is issued, a look up is done to determine whether the target instruction is in the instruction queue 14. Since instruction 10 is already in the instruction queue, execution enters into instruction queue operating mode. If at instruction 12 the forward branch path is taken this time, the instruction memory unit enters into instruction cache operating mode since the T-bit for entry 2 indicates that branch forward was not taken the previous time. The T-bit is now set. Once again, instruction 16 is loaded into entry 3 and instruction 17 is loaded into entry 4, as shown by the instruction queue contents 26 in FIGURE 2D. If the backward branch path of instruction 17 is not taken, the instruction memory unit operating mode stays in the instruction cache mode, and 18 is loaded into entry 5 of the instruction queue from the instruction cache. Similarly, instructions 19 and 110 are loaded into entries 6 and 7 of the instruction queue.<br>
[0020] If the backward branch path of instruction 17 is not taken while the operating mode is in the instruction queue mode, then the operating mode becomes the instruction cache mode and instructions 18 through 110 are also loaded into the instruction queue from the instruction cache.<br>
[0021] If at FIGURE 2D the backward branch path of instruction 17 is taken while the operating mode is in the instruction cache mode, then the operating mode becomes the instruction queue mode and the instruction queue is as shown in FIGURE 2B.<br>
[0022] FIGURE 4 is a flowchart of an embodiment of a method of instruction queue operations when a backward program redirect construct is encountered. In block 30, an instruction is fetched or issued from the instruction queue 14. In block 32, a determination is made as to whether that instruction is a backward branch with an immediate offset or zero overhead loop instruction. If not, execution continues normally in the instruction cache operating mode. A check may be made at this time to determine if the issued instruction is a forward program redirect construct, as shown in FIGURE 5, if this has not already been done. If the instruction is a backward program redirect construct and the branching path is taken, as determined in block 33, then a determination is made as to what the target instruction for the instruction is in block 34.<br><br>
WO 2006/110886	 	PCT/US2006/013948<br>
In block 36, a determination is made as to whether the target instruction is already in the instruction queue. If the target instruction is not in the instruction queue, then the instruction is read from the instruction cache in block 40, and the instruction memory unit operating mode is instruction cache mode. If the target instruction is in the instruction queue, then the target instruction is the next instruction to be issued in block 38.<br>
[0023] FIGURE 5 is a flowchart of an embodiment of a method of instruction queue operations when a forward program redirect construct is encountered. In general, a forward loop is "captured" if a prior resolution of a forward program redirect construct results in the same manner as the present forward branch resolution. In other words, if the current forward program redirect construct resolution generates the same result as the last resolution, then the instructions needed for program execution are already in the instruction queue, and access to the instruction cache is not needed. No lookup in the instruction queue is required.<br>
[0024] Referring to FIGURE 5, in block 50 an instruction is read from the instruction cache 12 and stored in the instruction queue 14 during the instruction cache operating mode. A determination is made as to whether that instruction is a forward program redirect construct in block 52. If not, execution continues normally. A check may be made at this time to determine if the issued instruction is a backward program redirect construct, as shown in FIGURE 4, if this has not already been done. If the issued instruction is a forward program redirect construct, then a determination of whether the T-bit in its instruction queue address is set is made in block 54. If the T-bit is set, then it means that the previous time this instruction was issued, the forward branch path was taken. If the forward branch is again taken this time, as determined in block 56, then the target instruction should already be in the instruction queue and issued in block 58. The instruction memory unit continues to operate in the instruction queue operating mode. If the forward branch is not taken this time, then the T-bit is reset and the next instruction to be issued is read from the instruction cache in block 60, and the instruction memory unit operates in the instruction cache operating mode.<br>
[0025] If the T-bit is not set, as determined in block 54, then during the previous pass the forward branch path was not taken. The target instruction for the present forward program redirect construct is resolved in block 62. In block 64, a determination<br><br>
WO 2006/110886	 	PCT/US2006/013948<br>
is made as to whether the forward branch path is being taken this time. If the forward branch is being taken, then the T-bit of the instruction queue address of the forward program redirect construct is set in block 66. The target instruction is then read from the instruction cache in block 68. This execution path results because the previous forward branch path was not taken (as indicated by the T-bit) and then taken this time. Therefore, the instruction queue does not contain the needed instructions and must be fetched from the instruction cache. If in block 64 it is determined that the forward branch path is not being taken this time, then the next instruction is already in the instruction queue, which is issued in block 70. This execution path results because the previous forward branch path was not taken (as indicated by the T-bit) and then also not taken this time. Therefore, the instruction queue already contains the needed instructions. Therefore, if the current and last resolution of the forward program redirect construct is identical and the instruction memory unit is operating in the instruction queue mode, then the next set of instructions are already in the instruction queue, which may be accessed by sequentially incrementing the instruction queue read pointer. During the instruction queue operating mode, no access to the instruction cache is necessary and significant savings in power consumption and greater speed are possible. If the current resolution is different from the previous resolution or if there is a program redirection instruction other than the forward program redirect construct, then the instruction memory unit transitions out of the instruction queue mode and into the instruction cache mode. The instruction cache is then accessed to fetch the target instruction.<br>
[0026] Although not described herein, one or more pointers may be used to note the location(s) of instruction queue entries to issue and load instructions during the processes shown in FIGURES 4 and 5 and described above. The term "main memory" is used herein to refer to a memory device or structure that is used as the main storage for program instructions. The term "instruction cache" is used herein to refer to a memory device or structure that possesses a faster access speed than main memory and is of a smaller size than the main memory. The term "instruction queue" is used herein to refer to a memory device or structure that possesses a faster access speed than the instruction cache and is of a smaller size than the instruction cache. Although the invention is described herein in the context of a main memory-instruction cache-instruction cache three-tiered hierarchy, this invention may be extended to embodiments<br><br>
WO 2006/110886	 	PCT/US2006/013948<br>
having two-tiered or multi-tiered instruction memory hierarchy. Although the instruction queue 14 is shown to have a storage size of eight entries, this invention should not be so limited. The logic or code module associated with the processes shown in FIGURES 4 and 5 may reside in the instruction queue or in read-only memory or other memory structures of the digital signal processor.<br>
[0027] It may be seen from the foregoing that program loop executions are "captured" so that program loops may be executed from the instruction queue without having to fetch instructions out of the instruction cache for every iteration of the loop. As the instruction queue is much smaller than the instruction cache, significant power savings and speed may be achieved by avoiding the instruction cache during these program loop iterations. Further, because instructions in the instruction queue are already predecoded, there is additional power savings in not using the instruction decoding logic for program loop execution during instruction queue operating mode. As described above, the operation of the instruction memory unit in instruction queue or instruction cache operating mode does not require any software code in the program instructions to provide advanced notice to the instruction memory unit that a program loop execution is forthcoming and that special loop execution may take place.<br>
[0028] Although embodiments of the present disclosure have been described in detail, those skilled in the art should understand that they may make various changes, substitutions and alterations herein without departing from the spirit and scope of the present disclosure. Accordingly, all such changes, substitutions and alterations are intended to be included within the scope of the present disclosure as defined in the following claims. In the claims, means-plus-function clauses are intended to cover the structures described herein as performing the recited function and not only structural equivalents, but also equivalent structures.<br><br>
WO 2006/110886	 	PCT/US2006/013948<br><br><br>
  We Claim:<br>
WHAT IS CLAIMED IS:<br>
1.	A method comprising:<br>
issuing a backward program redirect construct containing a backward branch path from an instruction queue;<br>
determining whether the backward branch path is being taken;<br>
determining whether a target instruction indicated by the backward branch path is already stored in the instruction queue in response to the backward branch path being taken;<br>
issuing the target instruction from the instruction queue in response to it being already stored in the instruction queue; and<br>
fetching the target instruction from an instruction cache coupled to the instruction queue in response to the target instruction not already stored in the instruction queue.<br>
2.	The method of claim 1, further comprising continuing to issue instructions sequentially from the instruction queue in response to the target instruction being already stored in the instruction queue.<br>
3.	The method of claim 1, further comprising:<br>
issuing a forward program redirect construct containing a forward branch path from the instruction queue;<br>
determining whether a last resolution of the forward program redirect construct reaches the same result as a current resolution of the forward program redirect construct; and<br>
issuing a next instruction from the instruction queue in response to same result being reached by the last and current resolution of the forward program redirect construct.<br><br>
WO 2006/110886	 	PCT/US2006/013948<br>
4.	The method of claim 3, wherein issuing a next instruction from the instruction queue comprises incrementing a read pointer and issuing the next instruction pointed to by the incremented read pointer.<br>
5.	The method of claim 3, further comprising fetching a next instruction from an instruction cache coupled to the instruction queue in response to a different result being reached by the last and current resolution of the forward program redirect construct.<br>
6.	The method of claim 5, wherein determining whether a last resolution of the forward program redirect construct reaches the same result as a current resolution comprises determining whether at least one predetermined field of the forward program redirect construct has a predetermined value.<br>
7.	The method of claim 5, wherein determining whether a last resolution of the forward program redirect construct reaches the same result as a current resolution comprises determining whether a T-bit of the forward program redirect construct is set.<br>
8.	A method comprising:<br>
issuing a forward program redirect construct containing a forward branch path from an instruction queue;<br>
determining whether a last resolution of the forward program redirect construct reaches the same result as a current resolution of the forward program redirect construct; and<br>
issuing a next instruction from the instruction queue in response to same result being reached by the last and current resolution of the forward program redirect construct.<br>
9.	The method of claim 8, further comprising setting a predetermined field<br>
of the forward program redirect construct in response to the forward branch path is<br>
being taken.<br><br>
WO 2006/110886	 	PCT/US2006/013948<br>
10.	The method of claim 9, wherein determining whether a last resolution of<br>
the forward program redirect construct reaches the same result as a current resolution<br>
comprises:<br>
determining whether the current resolution of the forward program redirect construct results in the forward branch path is being taken; and<br>
determining whether the predetermined field of the forward program redirect construct was set from the last resolution of the forward program redirect construct.<br>
11.	The method of claim 8, wherein issuing a next instruction from the instruction queue comprises incrementing a read pointer and issuing the next instruction pointed to by the incremented read pointer.<br>
12.	The method of claim 8, further comprising fetching a next instruction from an instruction cache coupled to the instruction queue in response to a different result being reached by the last and current resolution of the forward program redirect construct.<br>
13.	The method of claim 8, wherein determining whether a last resolution of the forward program redirect construct reaches the same result as a current resolution comprises determining whether at least one predetermined field of the forward program redirect construct has a predetermined value.<br>
14.	The method of claim 8, further comprising:<br>
issuing a backward program redirect construct containing a backward branch path from an instruction queue;<br>
determining whether the backward branch path is being taken;<br>
determining whether a target instruction indicated by the backward branch path is already stored in the instruction queue in response to the backward branch path being taken;<br><br>
WO 2006/110886	 	PCT/US2006/013948<br>
issuing the target instruction from the instruction queue in response to it being already stored in the instruction queue; and<br>
fetching the target instruction from an instruction cache coupled to the instruction queue in response to the target instruction not already stored in the instruction queue.<br>
15.	The method of claim 14, further comprising continuing to issue instructions sequentially from the instruction queue in response to the target instruction being already stored in the instruction queue.<br>
16.	An integrated circuit comprising:<br>
a first memory structure operable to store program instructions;<br>
a second memory structure coupled to the first memory structure and operable to store program instructions fetched from the first memory structure, and operable to issue stored program instructions for execution;<br>
the second memory structure operable to identify a repeated issuance of a forward program redirect construct, and issue a next program instruction already stored in the second memory structure in response to a resolution of the forward branching instruction identical to a last resolution of the same forward program redirect construct; and<br>
the second memory structure further operable to issue a backward program redirect construct stored in the second memory structure, determine whether a target instruction thereof is stored in the second memory structure, issue the target instruction in response to the target instruction being stored in the second memory structure, and fetch the target instruction from the first memory structure in response to the target instruction not stored in the second memory structure.<br>
17.	The integrated circuit of claim 16, wherein the first memory structure has<br>
an access speed slower than the second memory structure and consumes more power<br>
than the second memory structure.<br><br>
WO 2006/110886	 	PCT/US2006/013948<br>
18.	The integrated circuit of claim 16, wherein the second memory structure comprises a plurality of program instruction entries for storing the program instructions, and an address and control entry for each program instruction entry.<br>
19.	The integrated circuit of claim 16, wherein the control entry comprises a predetermined field for logging whether a resolution of the forward branching instruction is identical to the last resolution of the same forward branching instruction.<br>
20.	The integrated circuit of claim 16, further comprising a third memory structure operable to store program instructions and from which the first memory structure fetches selected program instructions.<br>
21.	A memory device comprising:<br>
means for issuing a backward program redirect construct containing a backward branch path from an instruction queue;<br>
means for determining whether the backward branch path is being taken;<br>
means for determining whether a target instruction indicated by the backward branch path is already stored in the instruction queue in response to the backward branch path being taken;<br>
means for issuing the target instruction from the instruction queue in response to it being already stored in the instruction queue; and<br>
means for fetching the target instruction from an instruction cache coupled to the instruction queue in response to the target instruction not already stored in the instruction queue.<br>
22.	The memory device of claim 21, further comprising means for continuing to issue instructions sequentially from the instruction queue in response to the target instruction being already stored in the instruction queue.<br>
23.	The memory device of claim 21, further comprising:<br>
means for issuing a forward program redirect construct containing a forward branch path from the instruction queue;<br><br>
WO 2006/110886								PCT/US2006/013948<br><br>
means for determining whether a last resolution of the forward program redirect construct reaches the same result as a current resolution of the forward program redirect construct; and<br>
means for issuing a next instruction from the instruction queue in response to same result being reached by the last and current resolution of the forward program redirect construct.<br>
24.	The memory device of claim 23, wherein means for issuing a next instruction from the instruction queue comprises means for incrementing a read pointer and issuing the next instruction pointed to by the incremented read pointer.<br>
25.	The memory device of claim 23, further comprising means for fetching a next instruction from an instruction cache coupled to the instruction queue in response to a different result being reached by the last and current resolution of the forward program redirect construct.<br>
26.	The memory device of claim 25, wherein means for determining whether a last resolution of the forward program redirect construct reaches the same result as a current resolution comprises means for determining whether at least one predetermined field of the forward program redirect construct has a predetermined value.<br><br><br><br>
ABSTRACT <br>
Title: "INSTRUCTION MEMORY UNIT AND METHOD OF OPERATION"<br>
An instruction memory unit comprises a first memory structure operable to store program instructions, and a second memory structure operable to store program instructions fetched from the first memory structure, and to issue stored program instructions for execution. The second memory structure is operable to identify a repeated issuance of a forward program redirect construct, and issue a next program instruction already stored in the second memory structure if a resolution of the forward branching instruction is identical to a last resolution of the same. The second memory structure is further operable to issue a backward program redirect construct, determine whether a target instruction is stored in the second memory structure, issue the target instruction if the target instruction is stored in the second memory structure, and fetch the target instruction from the first memory structure if the target instruction is not stored in the second memory structure.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LUFCU1RSQUNUKDIxLTEwLTIwMTEpLnBkZg==" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-ABSTRACT(21-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWFic3RyYWN0LmRvYw==" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-abstract.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LUNMQUlNUyhBTUVOREVEKS0oMTItMy0yMDE0KS5wZGY=" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-CLAIMS(AMENDED)-(12-3-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LUNMQUlNUyhBTUVOREVEKS0oMjEtMTAtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-CLAIMS(AMENDED)-(21-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LUNMQUlNUyhNQVJLRUQgQ09QWSktKDEyLTMtMjAxNCkucGRm" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-CLAIMS(MARKED COPY)-(12-3-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWNsYWltcy5kb2M=" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-claims.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LUNPUlJFU1BPTkRFTkNFKDIzLTItMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-CORRESPONDENCE(23-2-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWNvcnJlc3BvbmRlbmNlKDI1LTMtMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-correspondence(25-3-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWNvcnJlc3BvbmRlbmNlLXJlY2VpdmVkLnBkZg==" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-correspondence-received.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LUNPUlJSRVNQT05ERU5DRSgyNy0xMi0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-CORRRESPONDENCE(27-12-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LURSQVdJTkcoMjEtMTAtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-DRAWING(21-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LUZPUk0gMSgyMS0xMC0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-FORM 1(21-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LUZPUk0gMTMoMjEtMTAtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-FORM 13(21-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWZvcm0gMih0aXRsZSBwYWdlKS0oMTctMTAtMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-form 2(title page)-(17-10-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LUZPUk0gMihUSVRMRSBQQUdFKS0oMjEtMTAtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-FORM 2(TITLE PAGE)-(21-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LUZPUk0gMygyMy0yLTIwMTEpLnBkZg==" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-FORM 3(23-2-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWZvcm0gMygyNS0zLTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-form 3(25-3-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LUZPUk0gUENULUlCLTM3MygyMS0xMC0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-FORM PCT-IB-373(21-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LUZPUk0gUENULUlTQS0yMzcoMjEtMTAtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-FORM PCT-ISA-237(21-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWZvcm0tMi5kb2M=" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-form-2.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWZvcm0tMjYucGRm" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LWZvcm0tcGN0LWliLTMwNC5wZGY=" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-form-pct-ib-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LXBjdC1zZWFyY2ggcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-pct-search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LVBFVElUSU9OIFVOREVSIFJVTEUgMTM3KDIxLTEwLTIwMTEpLnBkZg==" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-PETITION UNDER RULE 137(21-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LVBST1NFQ1VUSU9OIEhJU1RPUlkgT0YgVVMgRE9DVU1FTlQoMjEtMTAtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-PROSECUTION HISTORY OF US DOCUMENT(21-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LVJFUExZIFRPIEVYQU1JTkFUSU9OIFJFUE9SVCgyMS0xMC0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-REPLY TO EXAMINATION REPORT(21-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LVJFUExZIFRPIEhFQVJJTkcoMTItMy0yMDE0KS5wZGY=" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-REPLY TO HEARING(12-3-2014).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1NVU1OUC0yMDA3LVNQRUNJRklDQVRJT04oQU1FTkRFRCktKDIxLTEwLTIwMTEpLnBkZg==" target="_blank" style="word-wrap:break-word;">1712-MUMNP-2007-SPECIFICATION(AMENDED)-(21-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTcxMi1tdW1ucC0yMDA3LXdvIGludGVybmF0aW9uYWwgcHVibGljYXRpb24gcmVwb3J0KDE3LTEwLTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">1712-mumnp-2007-wo international publication report(17-10-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="260856-composite-semipermeable-membrane-production-process-thereof-and-element-fluid-separation-equipment-and-treatment-method-for-boron-containing-water-using-the-same.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="260858-a-process-for-preparation-of-ramipril.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>260857</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1712/MUMNP/2007</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>22/2014</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>30-May-2014</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>26-May-2014</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>17-Oct-2007</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 MOREHOUSE DRIVE, SAN DIEGO, CALIFORNIA 92121,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>AHMED MUHAMMAD</td>
											<td>12340 ALAMEDO TRACE CIRCLE, #2204, AUSTIN, TEXAS 78727</td>
										</tr>
										<tr>
											<td>2</td>
											<td>CODRESCU LUCIAN</td>
											<td>12505 GLACIER PARKE COVE, AUSTIN, TEXAS 78726</td>
										</tr>
										<tr>
											<td>3</td>
											<td>PLONDKE ERICH</td>
											<td>12012 CARMEL PARK LANE, AUSTIN, TEXAS 78727</td>
										</tr>
										<tr>
											<td>4</td>
											<td>ANDERSON WILLIAM C</td>
											<td>3104 KITTOWA COVE, AUSTIN, TEXAS 78746</td>
										</tr>
										<tr>
											<td>5</td>
											<td>JONES PHILLIP M</td>
											<td>3820 LAGOONA DRIVE, ROUND ROCK, TEXAS 78681</td>
										</tr>
										<tr>
											<td>6</td>
											<td>LESTER ROBERT ALLAN</td>
											<td>2366 MASONWOOD WAY, ROUND ROCK, TEXAS 78681</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F9/38</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2006/013948</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2006-04-11</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/104,115</td>
									<td>2005-04-11</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/260857-a-method-and-integrated-circuit-for-issuing-a-next-instruction-of-a-program by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 02:09:14 GMT -->
</html>
