<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/202409-print-engine-controller-to-work-in-multiples-and-a-printhead-driven-by-multiple-print-engine-controllers by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:03:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 202409:PRINT ENGINE/CONTROLLER TO WORK IN MULTIPLES AND A PRINTHEAD DRIVEN BY MULTIPLE PRINT ENGINE/CONTROLLERS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">PRINT ENGINE/CONTROLLER TO WORK IN MULTIPLES AND A PRINTHEAD DRIVEN BY MULTIPLE PRINT ENGINE/CONTROLLERS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A print controller configured to be with one or more further print controllers to drive an ink drop printhead, the print controller comprising an interface at which to receive compressed page data; image decoders to decode compressed image planes in the received compressed page data; a compositor to composite respective strips of the decoded image planes; and a printhead interface to output the composite strip to a printhead, characterised in that the printhead interface includes a multi-segment printhead interface outputting printhead formatted data; and a synchronization signal generator outputting a synchronization ,signal to couple the print controllers to synchronize their respective composite strips at the printhead.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>The inveniiori relates to a prini engine/controller adapted to work together with a number of prim engine/controliera in driving a printhead and to a printhead driven by multiple print engine/controllers,<br>
BACKGROUND OF THE mVENTION m the prior art a single print engine/controller controls a single printhead. However this solution does not scale well for wider format prinlheads, for high resolution input images, or for faster printing. For wide format printheads the controller chip has to be made to run faster in order to print the same number of printlines, each of which is now longer. Or if the printhead is lo run faster the print controller has to be run at a faster clock speed. Or if the input image has a higher resolution then the controller chip has to have more buffers internally or run faster or both in order to process the effectively larger input image since it is a higher resolution,<br>
A range of printer t}pes have evolved wherein an image is constructed from ink selectively applied to a page in dot format. In US patent number 6045710 titled "Self-aligned construction and manufacturing process for monolithic printheads" to the inventor Kia Silverbrook there is set out an assessment of the prior art to drop on demand printers along with its manufacturing process.<br><br>
The disclosures of these co-pending applications are incorporated herein by cross-reference.<br>
In addition, various methods, systems and apparatus relating to the present invention are disclosed in<br>
the following co-pending PCT applications filed simultaneously by the applicant or assignee of the present<br>
invention: PCT/AUOO/00755, PCT/AU00/00756 and PCT/AUOO/00757,<br><br>
The disclosures of these co-pending applications are incorporated herein by cross-reference. Each application is temporarily identified by its docket number. This will be replaced by the corresponding PCT application numbers when available.<br>
Of particular note are co-pending PCT application numbers patent appiications PCT/AUOO/00591, PCT/AUOO/00578, PCT/AU00/00579, PCT/AUOO/00592 and PCT/AU00/00590, v,hich describe a microelectomechanical drop on demand printhead hereafter referred to as a Memjet printhead.<br>
The Memjet printhead is developed from printhead segments that are capable of producing, for example, 1600 dpi bi-level dots of liquid ink across the full width of a page. Dots are easily produced in isolation, allowing dispetsed-dot dithering to be exploited to its fullest. Color planes might be printed in perfect registration, allowing ideal dot-on-dot printing. The printhead enables high-speed printing using m i croc I ectro mechanical ink drop technology.<br>
In addition, co-pending PCT applications PCT/AUOO/00516, PCT/AU00/00517, PCT/AUO0/00511, and PCT/AUOO/00755, PCT/AUOO/00756 and PCT/AUOO/00757 describe a print engine/controller suited to driving the above referenced page wide printhead.<br>
A single print engine/controller (PEC) cliip is capable of driving a printhead of the above referenced type, printing a dithered version of a 320ppi contone image over a 12 inch printhead. It is desirable to be able to print higher resolution images for higher quality output. It is desirable to be able to run the printhead faster.<br>
SUMMARY OF THE INVENTION<br>
The invention resides in a print engine/controller configured to be coupled with others to drive an ink drop printhead comprising:<br>
an inlerface at which to receive compressed page data;<br>
image decoders to decode compresised image planes in the received compressed page data;<br>
a half-toner/compositer to composite respective strips of the decoded image planes: and<br>
a printhead interface to output the composite strip to a printhead<br>
the printhead interface including:<br>
a multi-segment printhead interface outputting printhead formatted data; and<br>
a synchronization signal generator outputting a synchronization signal to couple print<br>
engine/controllers to synchronize their respective strips at the printhead,<br>
A Memjet printhead is a multi-segment printhead, where each segment of the printhead has physical connections. For example Memjet printheads can be constructed from multiple chips, each of which contains a single printhead segment, or can be constructed from multiple chips each of which contains more than one segment. The wiring is the same in both cases, and the logical connectivity is the same in both cases - multiple segments combining lo form a wider printhead.<br>
The present invention advantageously uses multiple copies of the same print engine controller chip to drive a multi-segment printhead, each responsible for a strip of the page, all synchronized from a master chip, A variety of configurations can be built depending on the required application. For example, given a 12-segmeni printhead, a single print engine/controller (PEC) can be used to run the entire printhead at a contone resolution of 320 ppi and at a maximum line speed of 30,000 lines per second. If double speed is to be achieved, 2 PECs can control 6 segments each, still running at 320 ppi contone resolution. But the effective speed has been doubled. Similarly, if the contone resolution is to be pushed to 640 ppi, 2 PECs can run the printhead at 30,000 lines per<br><br>
second.<br><br>
Synchronization can also be readily used for simultaneous duplex printing. One PEC prints 12 inches (15 segments) on one side of a page, whiie a second PEC simultaneously prints the second side of the page. As long as there is a single Master PEC chip giving the synchronization signals, combinations of PECs can be achieved.<br>
Driving a single printhead from multiple chips is advantageous lo produce wider pages, faster prints, higher input resolution, or combinations of all three.<br>
To use multiple PECs, the same page can be given to multiple PECs. Different PECs then deal with strips of the page data, producing the total page in a faster time and/or higher resolution. A simple way of sending data to the printhead from multiple PECs is simply to have each PEC responsible for a given number of printhead segments.<br>
The programming of individual PECs for strips within the overall page is organized in a margin unit within a half-ioner/composiler within each PEC. A tag encoder within each print engine/controller is able lo deal with a sUip of a page and is capable of producing a parliai tag when lagged pages are desirable.<br>
When several PECs are used in unison, such as in a duplexed configuration or in a printhead configuration that consists of more than 15 Memjet segments, they are synchronized via a shared line sync signal. Only one Printhead Controller Chip, selected via an exlemal master/slave pin, generates the line sync signal onto the shared line. Tlie internals of PEC allow for printing a single strip of a page ii: conjunction with other PECs. This includes generation of partial Netpage lags and page descriptions. However it is up to the external page provider lo allocate the various strips to each PEC correctly.<br>
BRIEF DESCRIPTION OF THE DRAWINGS FIG.  1 is a diagram illustrating data flow and the functions performed by the print engine controller, FIG. 2 shows the print engine controller in the context of the overall printer system architecture. FIG. 3 illustrates the prim engine controller architecture.<br>
FIG. 4 illustrates the external interfaces to the halftoner/compositor unit (I ICU) of FIG. 3. FIG. 5 is a diagram showing internal circuitry to the HCU of FIG. 4. FIG. 6 shows a block diagram illustrating the process within the dot merger unit of FIG. 5. FIG, 7showsadiagramillustratingtheprocesswithin the dot reorganization unit of FIG, 5, FIG, 8 shows a diagram illustrating the process within the line loader/format unit (LLFU) of FIG, 5, FIG, 9 is a diagram showing internal circuitry to generate color data in the LLFU of FIG, 8, FIGs, lOand 11 UiustratecomponenisoftheLLFUseenin FIG, 9. FIG,  12 is a diagram showing internal cireuitrj" to a printhead interface. FIG,  13 is a diagram ofa dot counter used in the printhead interface,<br>
DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS<br>
A typically 12 inch printhead width is controlled by one or more print engine/controllers (PECs), as described below, to allow full-bleed printing of both A4 and Letter pages. Six channels of colored ink are the expected niaximum in the present priming envitonmeni, these being;<br>
CMY, for regular color printing,<br>
•	K, for black text and other black printing,<br>
IR (infrared), for tag-enabled applications.<br><br>
Because before the next page<br>
the printer is to be capable of fast printing, a fixative will he required to enable the ink to dry ,   ge has completed printing at higher speeds.   Other\^"ise the pages might bleed on each other. In lower speed printing environmenis the fixative will not be required.<br>
A PEC might be built in a single chip to interface with a printhead. It will contain four basic levels of functionality.<br>
receiving compressed pages via a serial interface such as IEEE 1394<br>
a print engine for producing a page from a compressed form. The print engine functionality includes<br>
expanding the page image, dithering the contone layer, compositing the black layer over the contone layer,<br>
optionally adding infrared tags, and sending the resultant image to the printhead,<br>
"	a print controller for controlling the printhead and stepper motors,<br>
"	two standard low-speed serial ports for communication with the two QA chips. "Note thai there must<br>
be two ports and not a single port to ensure strong security during the authentication procedure.<br>
In Figure 1 is seen the flow of data to send a document from computer system to printed page, A document is received al U and loaded to memory buffer 12 wherein page layouts may be effected and any required objects might be added. Pages from memory 12 are rasterized at 13 and compressed at 14 prior to transmission to the print engine controller 10, Pages are received as compressed page images within the print engine controller 10 into a memory buffer [5, from which they are fed to a page expander 16 wherein page images are retrieved. Any requisite dither might be applied to any contone layer at 17. Any black bi-level layer might be composited over the contone layer at 18 together with any infrared tags at 19, The composited page data is printed at 20 to produce page 21.<br>
The print engine/controller lakes the compressed page image and starts the page expansion and print¬ing in pipeline fashion. Page expansion and printing is preferably pipelined because it is impractical to store a sizable bi-level CMYK+IR page image in memory.<br>
The first stage of the pipeline expands a JPEG-com pressed contone CMYK layer (see below), expands a Group 4 Fax-compressed bi-level dither matrix selection map (see below), and expands a Group 4 Fax-compressed bi-level black layer (see below), all in parallel. In parallel wUh this, the tag encoder encodes bi-level IR tag data from the compressed page image. The second stage dithers the contone CMYK layer using a dither matrix selected by the dither matrix select map, composites the bi-level black layer over the resuhing bi-level K layer and adds the IR layer to the page. A fixative layer is also generated at each dot position wherever there is a need in any of C, M, Y, K, or IR channels. The last stage prints the bi-level CMYK+IR data through the printhead via a printhead interface (see below).<br>
In FIG. 2 is seen haw the print engine/controller 10 fits within the overall printer system architecture. The various components of the printer system might include<br>
a Print Engine/Conli-o/ler (PEC)- A PEC chip 10, or chips, is responsible for receiving the compressed page images for storage in a memory buffer 24, performing the page expansion, black layer compositing and sending the dot data to the printhead 23. It may also communicate with QA chips 25,26 and<br><br><br>
Preferably a 64 MBit (8 MByle) memory buffer is used to store the compressed page image. While one page is being written to the buffer another is being read (double buffering). In addition, the PEC uses the memory to buffer the calculated dot information during the printing of a page. During the ptinting of page .V, the buffer is used for:<br><br>
Reading compressed page A"<br>
Reading and writing the bi-level dot information for page (V<br>
•	Writing compressed page A"+/<br>
Preferably a PEC chip will incorporate a simple micro-controller CPU core 35 to perform the foliovving functions:<br>
perform QA chip authentication protocols via serial interface 36 between prim pages<br>
run the stepper motor via a parallel interface 91 during a print (the stepper motor requires a 5 kHz process)<br>
•	synchronize the various portions of the PEC chip during a print<br>
provideameansof interfacing with external data requests (programming registers etc.)<br>
provide a means of interfacing with printhead segment low-speed data requests (such as reading the characterization vectors and writing pulse profiles)<br>
•	provide a means of writing the portrait and landscape tag structures to external DRAM<br>
Since all of the image processing is performed by dedicated hardware, the CPU does not have to process pixels. As a result, the CPU can be extremely simple. A wide variety of CPU known cores are suitable: it can be any processor core with sufficient processing power fo perform the required calculations and control functions fast enough. An example of a suitable core is a Philips 805! micro-controller running at about ! MHz. Associated with the CPU core 35 may be a program ROM and a small program scratch RAM, The CPU communicales with the other units within the PEC chip via memory-mapped J/O. Particular address ranges may map to particular units, and within each range, to particular registers within that particular unit This includes the serial 36 and parallel 91 interfaces, A small program flash ROM may be incorporated into the PEC chip. Its size depends on the CPU chosen, but should not be more than 8KB. Likewise, a small scratch RAM area can be incorporated into the PEC chip. Since the program code does not have to manipulate images, there is no need for a large scratch area. The RAM size depends on the CPU chosen (e.g. stack mechanisms, subroutine calling conventions, register sizes eta), but should not be more than about 2 KB,<br>
A PEC chip using the above teferenced segment based page wide ptinthead can reproduce black at a full dot resolution (typically 1600 dpi), but reproduces contone color at a somewhat lower resolution using halftoning. The page description is therefore divided into a black bi-level layer and a contone layer. The black bi-level layer is defined to composite over the contone layer. The black bi-level layer consists of a bitmap containing a I-bit opacity for each pixel. This black layer matte has a resolution that is an integer factor of the printer"s dot resolution. The highest supported resolution is 1600 dpi, i,e. the printer"s fiill dot resolution. The contone layer consists of a bitmap containing a 32-bil CMYK color for each pixel, where K is optional. This contone image has a resolution that is an integer factor of the printer"s dot resolution. The highest supported resolution is 320 ppi over 12 inches for a single PEC, i,e, one-fifth the printer"s dot resolution. For higher contone resolutions multiple PECs are required, with each PEC producing an strip of the output page. The contone resolution is also typically an integer factor of the black bi-level resolution, to simplify calculations in the RIPs,   This is not a requirement, however.   The black bi-lcvel layer and the contone layer are both in<br><br>
In FIG. 3 is seen the print engine architecture. The print engine"s page expansion and printing pipeline consists of a high speed serial inierface 27 (such as a standard IEEE 1394 inlerface), a standard JPEG decoder 28. a standard Group 4 Fax decoder, a custom halftoner/compositor unit 29, a custom tag encoder 30, a line loader/foTmatter unit 31, and a custom inierface 32 to the printhead 33, The decoders 28,88 and encoder 30 are buffered to the hajftoner/composiior 29. The tag encoder 30 establishes an infrared lag or tags to a page according lo protocols dependent on what uses might be made of the page and the actual content of a tag is not the subject of the present invention.<br>
The print engine works in a double buffered way. One page is loaded into DRAM 34 via DRAM interface 89 and data bus 90 from the high speed serial interface 27 while the previously loaded page is read from DRAM 34 and passed through the print engine pipeline. Once the page has finished printing, then the page just loaded becomes the page being printed, and a new page is loaded via the high-speed serial interface 27. At the first stage the pipeline expands any J PEG-com pressed contone (CMYK) layer, and expands any of two Group 4 Fax-com pressed bi-level data streams. The two streams are the black layer (although the PEC is actually color agnostic and this bi-level layer can be directed to any of the output inks), and a matte for selecting betv.een dithev matrices for contc-ne dithering (see below). At the second stage, in parallel with the first, is encoded any tags for later rendering in either IR or black ink. Finally the third stage dithers the contone layer, and composites position tags and the bi-level spotl layer over the resulting bi-level dithered layer. The data stream is ideally adjusted to create smooth transitions across overlapping segments in the printhead and ideally it is adjusted to compensate for dead nozzles in the printhead. Up to 6 channels of bi-level data are produced from this stage. Note that not all 6 channels vnay be present on the printhead, Fov example, the printhead may be CMY only, with K pushed into the CMY channels and IR ignored. Alternatively, the position lags may be printed in K if IR ink is not available (or for testing purposes). The resultant bi-level CMYK.-IR dot-data is buffered and formatted for printing on the printhead 33 via a set of line buffers (see below). The majority of these line buffers might be ideally stored on the off-chip DRAM 34, The final stage prints the 6 channels of bi-level dot data via the printhead inietface 3 2,<br>
Compression is used in a printing system that employs the PEC, This is to reduce bandwidth requirements between a host and PEC, as well as to reduce memory requirements for page storage. At 267 ppi. a Lener page of contone CMYK data has a size of 25MB. Using lossy contone compression algorithms such as JPEG (see below), contone images compress with a ratio up to 10:1 without noticeable loss of quality, giving a compressed page size of 2.5MB, At 800 dpi, a Letter page of bi-level data has a size of 7MB, Coherent data such as text compresses very well. Using lossless bi-level compression algorithms such as Group 4 Facsimile (see below), ten-point text compresses with a ratio of about 10;i, giving a compressed page size of 0,8MB. Once dithered, a page of CMYK contone image data consists of 114MB of bi-level data. The two-layer compressed page image format described below exploits the relative strengths of lossy JPEG contone image compression and lossless bi-level text compression. The format is compact enough to be storage-efficient, and simple enough to allow straightforward real-time expansion during printing. Since text and images normally don"t overlap, the normal worst-case page image size is 2.5MB (i.e. image only), while the normal best-case page image size is 0.8MB (i.e. text only). The absolute wotst-case page image size is 3.3ME (i.e. test over image). Assuming a quarter of an average page contains images, the average page image size is ! ,2MB,<br><br>
A uroup 3 Facsimile compression algorithm (see ANSI/EIA 538-1988, Facsimile Coding Schemes md Codmg Control FuncHons for Group 4 Facsimile Equipment. August 1988) can be used lo lossJessJy compresses bi-le^"el data for transmission over slow and noisy telephone Imes. The bi-levd data represents scanned black text and graphics on a white background, and the algorithm is tuned for this class of images (it is expiititly unt tuned, for example, for haifiomd bi-level images). The ID Group 3 algorithm run length-en codes each scanline and then Huffman-encodes the resuking mnlengths. Runlengths in the range 0 to 63 are coded wilh terminating codes. Runtcngtl^s in the range 64 to 2623 arc coded with make-up codes, each Tepiesenting a multiple of 64, followed by a tenninating code. Runlengths exceeding 2623 are coded with mnUiple make-up codes followed by a lerminaling code. The Huffman tables are fixed, but are separately luned for black and while runs (except for make-up codes above 1728. which are common). When possible, the 2D Group 3 algorithm encodes a scanline as a set of short edge deltas (0, ±1, ±2, ±3) wilh reference lo the previous scanline. The delta symbols are entropy-encoded (so that the zero delta symbol is only one bit long etc.) Edges within a 2D-encoded line that can"t be delta-encoded are run length-encoded, and are identified by a prefix. ID- and 2D-encoded lines are marked differently, ID-encoded lines are generated at regular intervals, whether actually required or not, to ensure that the decoder can recover from line noise with minimal image degradation, 2D Group 3 achieves compression ratios of up to 6:1 (see Urban, S.J., "Review of standards for electronic imaging for facsimile systems". Journal of Electronic Imaging, Vol.1(1), January 1992, pp.5-21).<br>
A Group 4 Facsimile algorithm (see ANSI/EIA 538-1988, Facsimile Coding Schemes and Coding Control Functions for Group 4 Facsimile Equipment, August 1988) tosstessiy compresses bi-level data for transmission over error-free communications lines (i.e. the lines are truly error-free, or error-correction is done at a lo%ver proioco! level). The Group 4 algorithm is based on the 2D Group 3 algorithm, with the essential modification that since transmission is assumed to be error-free, ID-encoded lines are no longer generated at regular intert"als as an aid to error-recovery. Group 4 achieves compression ratios ranging from 20:1 to 60:1 for the CCITT set of test images. The design goals and performance of the Group 4 compression algorilhm qualify it as a compression algorithm for the bi-Ievel layers. However, its Huffman tables are tuned to a lower scanning resolution (100-400 dpi), and it encodes runlengths e;iceeding 2623 awkwardly. At 800 dpi, our maximum runlenglh Is currently 6400. Although a Group 4 decoder core would be available for use in PEC, il might not handle runlengths exceeding those normally encountered in 400 dpi facsimile applications, and so would require modification. The (typically 1600 dpi) black layer is losslessly compressed using G4Fa^ at a typical compression ratio exceeding 10:1. A (typically 320dpi] dither matrix select layer, which matches the contone color layer, is losslessly compressed using G4Fax at a typical compression ratio exceeding 50:1.<br>
The Group 4 Fax (G4 Fax) decoder is responsible for decompressing bi-leve! data. Bi-level data is limited lo a single spot color (Upically black for text and line graphics), and a dither matrix select bit-map for use in subsequent dithering of the contone data (decompressed by the JPEG decoder). The input to the G4 Vax decoder is 2 planes of bi-level data, read from the external DRAM, The output of the G4 Fax decoder is 2 planes of decompressed bi-leve! data. The decompressed bi-level data is sent to the Halftoner/Compositot Unit (HCU) for the next stage in the printing pipeline. Two bi-level buffers provides the means for transferring the bi-le\el data between the G4 Fax decoder atid tiie HCU. Each decompressed hi-level layer is output to two line buffets. Each buffer is capable of holding a full 12 inch line of dots at the expected maximum resolution. Having two line buffers allows one line lo be read by the HCU while the olher line is being written to by the G4 Fax decoder. This is important because a single bi-level line is typically less than 1600 dpi, and must therefore be expanded in both the dot and line dimensions. If the buffering were less than a full line, the G4 Fax decoder<br><br>
Spot color 1 is designed to allow high resolution dot data &amp;r a single color plane of the output image. While the conlone layers provide adequate resolution for images, spot color I is targeted ai applications such as text and line graphics (typically black). When used as text and line graphics, the typical compression ratio exceeds 10:1, Spot color 1 allows variable resolution up to 1600dpi for maximum print quality. Each of the two line buffers is therefore total 2400 bytes (12 inches x 1600 dpi = 19.200 bits).<br>
The resolution of the dither raatrsx select map should ideally match the conlone resolution. Consequently each of the two line buffers is therefore 480 byles (3840 bits), capable of storing 12 inches at 320 dpi. When the map matches the contone resolution, the tipical compression ratio exceeds 50:1,<br>
In order to provide support for:<br>
800 dpi spot color 1 layer (typically black)<br>
•	320 dpi diiher matrix select layer<br>
the decompression bandwidth requirements are 9,05 MB/sec for I page per second performance (regardless of whether the page width is 12 inches or 8,5 inches), and 20 MB/sec and 14,2 MB/sec for 12 inch and 8,5 inch page widths respectively during maximum printer speed performance (30,000 lines per second). Given that the decompressed data is output to a line buffer, the G4 Fax decoder can readily decompress a line from each of the outputs one at a time.<br>
The G4 Fax decoder is fed directly from the main memory via the DRAM interface. The amount of compression deteimines the bandwidth requirements to the external DRAM. Since G4 Fax i5 lossless, the complexity of the image impacts on the amount of data and hence tbe bandwidth, typically an 800 dpi black lexi/"graphics layer exceeds 10:i compression, so the bandwidth required to print 1 page per second is 0.78 MB/sec, Similarly, a typical 330 dpi dither select matrix compresses at more than 50:1, resulting in a 0,025 MB/sec bandwidth. The fastest printing speed configuration of 320 dpi for didier select matrix and 800 dpi for spot color I requires bandwidth of 1.72 MB/sec and 0.056 MB/sec respectively. A total bandwidth of 2 MB/sec should therefore be more than enough for the DRAM bandwidth.<br>
The G4 Fa?i decoding functionality is implemented by means of a G4 Fax Decoder core, A wide variety of G4Fax Decoder cores are suitable: it can be an&gt; core with sufficient processing power to perform the required calculations and control ftjnctions fast enough, !t must be capable of handling runlengths exceeding those norstially encounteted in 400 dpi facsimile applications, and so may require modification,<br>
A JPEG compression algorithm (see ISO/IEC 19018-1:1994, Information technology - Digital compression and coding of continuous-tone still images: Requirements and guidelines. 1994) lossily compresses a contone image at a specified quality level It introduces imperceptible image degradation at compression ratios below 5:1. and negligible image degradation at compression ratios below 10:1 (see Wallace, G.K.,, "The JPEG Still Picture Compression Standard", Communications of the ACM, Vol,34, No,4, April 1991, pp,30-44), JPEG tj"pically first transforms the image into a color space that separates luminance and chrominance into separate color channels.   This allows the chrominance channels to be sub-sampied without appreciable loss because of<br><br>
me human visual system"s relatively greater smsitiviiy lo luminance than chrominance. After this firsl slep, each color channel is compressed separately. The image is divided into 8x8 pixe! blocks. Each block is then transformed into the frequency domain via a discrete cosine Iransfomi (DCT). This Iran sfo mi at ion has the effect of concentrating image energy in relatively lower-frequency coefficients, which allows higher-frequency coefficients to be more crudely quantized, TTiis quantization is the principal source of compression in JPEG, Further compression is achieved by ordering coefficients by frequency to maximize Ihe likelihood of adjacent zero coefficients, and then run length-encoding runs of zeroes. Finally, Ihe runlenglhs and non-zero frequency coefficients are entropy coded, Decompression is the inverse process of compression.<br>
The CMYK (or CMY) contone layer is compressed to a planar color JPEG bytesttearo. If luminance/chrominance separation is deemed necessary, either for the purposes of table sharing or for chrominance sub-sampling, then CMYK, is convened to YCrCb and Cr and Cb are duly sub-sampled. The JPEC b^testream is complete and self-contained, l! contains all data required for decompression, including quantization and Huffman tables.<br>
The JPEG decoder is responsible for performing the on-the-fiy decompression of the contone data layer. The input to Ihe JPEG decoder is up to 4 planes of conlone data. This will tj"plcally be 3 planes, representing a CMY contone image, or 4 planes representing a CMYK conlone image. Each color plane can be in a different resolution, although typically all color planes will be the same resolution. The conlone layers are read fi^om the external DRAM. The output of the JPEG decoder is the decompressed contone data, separated into planes. The decompressed contone image is sent to the halftoner/compositor unit (HCU) 29 for the next stage in the printing pipeline. The 4-pIane contone buffer provides the means for transferring the conlone data between the JPEG decoder and the HCU 29.<br>
Each color plane of the decompressed contone data Is output to a set of two line buffers (see below). Each line buffer is 3840 bytes, iuid is therefore capable of holding 12 inches of a single color plane"s pixels at 320 ppi. The line buffering allows one line buffer to be read by the HCU while the other line buffer is being written lo by the JPEG decoder. This is important because a single conlone line is typically less than 1600 ppi, and must therefore be expanded in both die dot anrf line dimensions. If the buffering were less than a full line, the JPEG decoder would have to decode ihe same line multiple times - once for each output 600dpi dotline. Although a variety of resolutions is supported, there is a tradeoff between the resolufion and available handwidlii. As resolution and number of colors increase, bandwidth requirements also increase. In addition, the number of segments being targeted hy the PEC chip also affects the bandwidth and possible resolutions. Note that since the contone image is processed in a planar format, each color plane can be stored at a different resolution (foi example CMY may be a higher resolution than the K plane). The highest supported contone resolution is 1600ppi (matching the printer"s full dot tesolution). However there is only enough output line buffer memory to hold enough contone pixels for a 320ppi line of length 12 inches. If the iuU 12 inches of output was required at higher contone resolution, multiple PEC chips would be required, although it should be noted that the final output on the printer will still only be bi-levei. With support for 4 colors at 320ppi, the decompression output bandwidth requirements are 40 MB/sec for 1 page per second performance (regardless of whether the page width is 12 inches or 8.5 inches), and 88 MB/sec and 64 MB/sce for 12 inch and 8.5 inch page widths respectively during maximum printer speed performance (30,000 lines per second).<br>
The JPEG decoder is fed directly from the main memory via the DRAM interface.   The amount of<br><br><br>
The JPEG funclionalily is implemented by means of a JPEG core. A -Aide variety of JPEG cores are suiubk-, il can be any JPEG core with sufficient processing power to perform the required calculations and control functions fast enough. For example, the BTG X-Match core has decompression speeds up to 140 MBytes/sec, which allows decompression of 4 color planes at contone resolutions up to 40Qppi for the maximum printer speed (30,000 lines at 1600dpi per second), and 800ppi for} page/sec printer speed. Note that the core needs to only support decompression, reducing the requirements that are imposed by more generalized JPEG compression/decompression cores. The size of the core is expected to be no more than 100,000 gates, Givai that the decompressed data is output to a line buffer, the JPEG decoder can readily decompress an entire line for each of the color planes one at a lime, thus saving on context switching during a line and simplilying the control of the JPEG decoder. 4 contexts must be kept (I context for each color plane), and includes current address in the externa! DRAM as well as appropriate JPEG decoding parameters,<br>
Jn FIG. 4 the halfloner/composiior unit (HCU) 29 combines the functions of halftoning the contone (typically CMYK) Saver to a bi-levcl version of the same, and compositing the spotl bi-leve! layer over the appropriate halftoned contone Iayer(s), If there is no K ink in the printer, the HCU 29 is able to map K io CMY dots as appropriate. It also .selects between two dither matrices on a pixel by pixel basis, based on the corresponding value in the ditlier matrix select map. The input to the HCU 29 is an expandeii contone layer (from the JPEG decoder unit) dirough buffer 37, an expanded bi-level spoil layer through buffer 38, an expanded dither-matrix-select bitmap at typically ihe same resolution as the contone layer through buffer 39, and tag data at luil dot resolution through buffer 40. The HCU 29 uses up to two dither matrices, read from the external DRAM 34, The output from the HCU 29 to the line loader/formal unit (LLFU) at 41 is a sa of printer resolution bi-level image lines in up to 6 color planes. Typically, the contone layer is CMYK or CMY, and Ihe bi-leve! spotl layer is K.<br>
In FIG. 5 is seen the HCU in greater detail. Once started, the HCU proceeds until it detects an end-of-pagt condition, or unti! it is explicitly stopped via its control register. The first task of the HCU is lo scale, in the respective scale units such as the scale unit 43, all data, received in the buffer planes such as 42. to printer resolution both horizontally and vertically.<br>
The scale unit provides a means of scaling contone or bi-level data lo printer resolution both hori^onlally and vertically. Scaling is achieved by replicating a data value an integer number of times in both dimensions. Processes hy which to scale data vv"ill be familiar to those skilled in the art.<br>
Two control bits are provided to the scale unit 43 by the margin unit 57: advance dol and advance tine. The advance dot bit allows the state machine to generate multiple instances of the same dot data (useful for page margins and creating dot data for overlapping segments in the printhead). The advance line bit allows the Slate machine to control when a particular line of dots has been finished, thereby allowing truncation of data<br><br>
according to printer margins. It also saves the scale unit from requiring special end-oWine logic, Ttie input to the scale unit is a foil line buffer. The line is used seal, factor iimc&gt; to effect vertical up-scaling via line replication, and within each line, each value is used scale factor times to effect horizontal up-scaling via pixel replication. Once ihe input line has been used scale fador times (the advance line bit has been set scale facio&gt;-times), the input bufler select bit of Ihe address i.s toggled (double buffering). The logic for the scale unit is the same for Ihe 8-bit and 1-bit case, since the scale unit oniy generates addresses.<br>
Since each of the contone layers can be a different resolution, they are scaled independently. The bi-level spoil layer at buffer 45 and Ihe dither matrix select layer at buffer 46 also need to be scaled. The bi-level tag data at buffer 47 is established at the correct resolution and does not need to be scaled. The scaled-up dither matrix select bit is used by the dither matrix access unit 48 to select a single 8-bit value from the two dither matrices. The 8-bit value is output to the 4 comparators 44, and 49 to 51, which simply compare it to the specific 8-bit contone value. The generation of an actual dither matrix is dependent on the structure of the printhead and the general processes by which to generate one will be familiar to those skilled in the art. If the contone value is greater than the 8-bit dither matrix value a 1 is output. If not, then a 0 is output. These bits are then all ANDed at 52 to 56 with an inPage bit from the margin unit 57 (whether or not the particular dot is inside the printable area of the page). The final stage in the HCU is the compositing stage. For each of the 6 output layers there is a single dot merger unit, such as unit 58, each with 6 inputs. The single output bit from each dot merger unit is a combination of any or all of the input bits. This allows the spot color to be placed in any output color plane (including infrared for testing purposes}, black to be merged into cyan, magenta and yellow (if no black ink is present in the printhead), and tag dot data to be placed in a visible plane. A fixative color plane can also be readily generated. The dot reorg unit (DRU) 59 is responsible for taking the generated dot stream for a given color plane and organizing it into 32-bit quantifies so that the output is in segment order, and in dot order within segments. Minimal reordering is required due to the fact that dots for overlapping segments are not generated in segment order.<br>
Two control bits are provided to the scale units by Ihe margin unit 57: advance dot and advance line. The advance dot bit allows the state machine to generate multiple instances of the same dot data (useful for page margins and creating dot data for overlapping segments in the printhead). The advance line bit allows the slate machine to control when a particular line of dots has been finished, thereby allowing truncation of data according to printer margins. It also saves the scale unit from requiring special end-of-line logic.<br>
The comparator unit contains a simple 8-bit "greater-lhan" comparator. It is used to determine whether the 8-bit contone value is greater than the 8-bit dither matrix value. As such, the comparator unit lakes two 8-bit inputs and produces a single 1-bit output.<br>
In FIG. 6 is seen more detail of the dot merger unit \X provides a means of mapping the bi-level dithered data, the spoti color, and the tag data to output inks in the actual printhead. Each dot merger unit takes 6 1-bit inputs and produces a single bit output thai represents the output dot for that color plane. The output bit at 60 is a combination of any or all of the input bits. This allows the spot color to be placed in any output color plans (including infrared for testing purposes), black to be merged into cyan, magenta and yellow (in Ihe case of no black ink in the printhead), and tag dot data to be placed in a visible plane. An output for fixative can readily be generated by singly combining all of the input bits. The dot merger unit contains a 6-bit ColorMask register<br><br>
61 that is used a. , mask against the 6 input bi.s.   Each of the i.put bits „ ANDed with tl.e corresponding ColorMask register bit, and the resuitani 6 bits are then ORed together to form the final output bit.<br>
In FIG. 7 is seen the dot reorg unit (DRU) which is responsible for taking the generated dot stream for a given color plane and organizing it into 32-bit quantities so that the output is in segment order, and in dot order within segrrents. Minimal reordering is required due to the fact that dots for overlapping segments are not generated in segment order. The DRU contains a 32-bit shift register, a regular 32-bit register, and a regular 16-bit register. A 5-bit counter keeps track of the number of bits processed so far. The dot advance signal from the dither matrix access unit (DMAU) is used to instruct the DRU as to which bits should be output<br>
In FIG, 7 register(A.) 62 is clocked every cycle. It contains the 32 most recent dots produced by the dot merger unit (DMU), The full 32-bit value is copied to register(B) 63 every 32 cycles by means of a WriteEnable signal produced by the DRU slate machine 64 via a simple 5-bil counter. The 16 odd bits (bits I, 3, 5. 7 elcl from register(B) 63 are copied to register(C) 65 with the same WriteEnable pulse, A 32-bit multiplexor 66 then selects between the following 3 outputs based upon 2 bits from the state machine:<br>
•	the full 32 bits from register B<br>
•	A 32-bit value made up from the 16 even bits of register A (bits 0, 2,4, 6 etc) and the 16 even bits of register B, The 16 even bits from register A form bits 0 to 15, while the 16 even bits from register B form bits 16-31,<br>
•	A 32-bit value made up from the 16 odd bits of registers (bits 1,3, 5, 7 etc.) and the 16 bits of register C. The bits of register C form bits 0 to 15, while the odd bits from register B form bits 16-13.<br>
The slate machine for the DRU can be seen in Table 1, ll stem in stele 0, It changes slate every 32 cycles. During the 32 cycles a single noOverlap bit collects the AND of all the dot advance bits for those 32 cycles {noOverlap = dot advance for cjcle 0, and noOverlap = noOverlap AND dot advance for cycles I to 31),<br><br><br><br>
The margin unit (MU) 57, in FIG. 5, is responsible for turning adva&gt;,ce dot and advance line signals from tlie ditlier matrix access unit (DMAU) 48 into general control signals based on the page margins of the current page, It is also responsible for generating the end of page condition. The MU keeps a counter of dot and line across the page. Both are set to 0 at the beginning of the page. The dot counter is advanced by I each time the MU receives a doi advance signal from the DMAU. When the MU receives a line advance signal from the DMAU, the line counter is incremented and the dot counter is reset to 0, Each cycle, the current line and dot values arc compared to the margins of the p%c, and appropriate output doi advance, line advance and M"ithin margin signals are given based on these mavgins. The DMAU contains the only substantial memory" requirements for the HCl!.<br>
in FIG. 8 is seen the line loader / format unit (LLFU). It receives dot information from the HCU, loads the dots for a given print line into appropriate buffer storage (some on chip, and some in external DRAM 34) and formats them into the order required for the printhead. A high level block diagram of the LLFU in terms of its external interface is shown in FIG. 9. The input 67 to the LLFU is a set of 6 32-bit words and a DataValid bit, all generated by the HCU, The output 68 is a set of 91) bits representing a maximum of 15 printhead segments of 6 colors. Nolatlte output bits may be valid, depending on how many colors are actually used in the prinihead.<br>
The physical placement of firing nozzles on the printhead referenced above, noszles in two offset rows, means that odd and even dots of the same color are for two different lines. The e\"en dots are for line L, and the odd dots are for line L-2. In addition, there is a number of lines between the dots of one color and the dots of another. Since the 6 color planes for the same dot position arc calculated at one lime by the HCU, there is a need to delay the dot data for each of the color planes until the same dot is positioned under the appropriate color nozzle<br>
The size of each buffer line depends on the width of the printhead. Since a single PEC generates dots for up to 15 printhead segments, a single odd or even buffer line is therefore 15 sets of 640 dots, for a total of 9600 bits(1200 bytes). For example, the buffers required for color 6 odd dots totals almost 45 KBytes,<br>
The entire set of requisite buffers might be provided on the PEC chip when manufacturing techniques are capable. Othewise, the buffers for colors 2 onward may be stored in external DRAM, This enables the PEC 10 be -valid even though the distance between color planes may change in the future. It is trivial to keep the even dots for color 1 on PEC, since everything is printed relative to that particular dot line (no additional line buffers are needed). In addition, the 1 halMines required for buffering color I odd dots saves substantial DRAM bandwidth. The various line buffers (on chip and in DRAM) need to be pre-loaded with all Os before the page is printed so that it has clean edges. The end of the page is generated autoniatically by the HCU so it will have a clean edge.<br>
In FIG !0 is seen a block diagram for Color N OESplit (see Oesplit 70 of FIG, 9), and the block diagram for each of the two buffers E and F, 71,72 in FIG.  9 can be found in FlGs,   10 and 11, Buffer EF is a<br><br>
double buffered mechaiiism for transferring dala to the printhead inierface (PHI) 32 in FIG- 3. Buffers E and F therefore have identical structures. During the processing of a line of dots, one of the two buffers is written to while the other is being read from. The two buffers are logical!&gt; swapped upon receipt of the Mne-sync signal from the PHI. Both buffers E and F are composed of 6 sub-buffers, 1 sub-bu(YcT per color, as shown in FIG. ! 1, the color I sub-buffer numbered 73. The size of each sub-buffer is 2400 bytes, enough to hold 15 segments at 1280 dots per segment. The memory is accessed 32-bits at a time, so there are 600 addresses for each sub-buffer (requiring 10 bits of address). All the even dots are placed before the odd dots in each color"s sub-buffer. If there is any unused space (for printing to fewer than 15 segments) it is located at the end of each color"s sub-buffer. The amount of meitiory aauaify used from each sub-buffer is directSy related to the number of segments actually addressed by the PEC, For a 15 segment printhead there are 1200 bytes of even dots followed by 1200 bytes of odd dots, with no unused space. The number of sub-buffers gainfully used is directly related to the number of colors used in the printhead. The maximum number of colors supported is 6.<br>
The addressing decoding circuitry for each of buffers E and F is such that in a given cycle, a single 32-bit access can be made to ail 6 sub-buffers - either a read from all 6 or a write to one of the 6. Only one bit of the 32-bit5 read from each color buffer is selected, for a total of 6 output bits. The process is shown in FIG. 11. 15 bits of address allow the reading of a particular bit by means of 10-bits of address being used to select 32 bits, and 5-bils of address choose 1-bil from those 32. Since all color sub-buffers share this logic, a single ! 5-bit address gives a total of 6 bits out, one bit per color. Each sub-buffer 73 to 78 has its own WriteEnable line, to allow a single 32-bil value to be writteri to a particular color buffer in a given cycle. The individual WrileEnables are generated by ANDing the single WriteEnable input with the decoded form of CotorSelect. The 32-bits of Datain on line 79 are shared, since only one buffer will actually clock the data in.<br>
Address generation for reading from buffers E and F is s\raightfor.vard. Each cycle generates a bit address that is used to fetch 6 bits representing 1-bit per color for a particular segment. By adding 640 to the current bit address, we advance to the next segment"s equivalent dot. We add 640 (no! 1280) since the odd and even dots are separated in the buffer. We do this NumSegments times to retrieve the data representing the even dots, and transfer those bits to the PHI. When NumSegmenis = 15, the number of bits is 90 (15 ;. 2 x NumSegments cycles. When NvmSegmenis = 15, the number of cycles is 19,200 cycles. Note tiial regardless of the number of colors actually used in the printhead, 6 bits are produced in a given read cycle (one bit from each color"s buffer).<br>
In addition, we generate the TlVriieEnable control signal for writing to the 90-bit Transfer register 90 in FIG. 9, Since the LLFU starts before the PHI, we must transfer the first value before the Advance pulse from the PHI. We must also generate the next value in readiness for the first Advance pulse. The solution is to transfer the first value to the Transfer register after NumSegmems cycles, and then to stall hiumSegmenis cycles later, wailing for the Advance pulse to start the next hlumSegments cycle group. Onte the first Advance pulse arrives, the LLFU is synchronized to the PHL<br>
The read process for a single dotline is shown in the following pseudocode:<br>
DoneFirst = FALSE<br><br>
WantToXfer = FALSE<br>
For DotlnSegmentO = 0 to 1279<br>
If (DotlnSegmentO:bitO == 0)<br>
CurrAdr = DotlnSegmentO (high bits) (puts in range 0 to 639) Endlf<br>
XfersRemaining = NumSegments Do<br>
WantToXfer = (XfersRemaining == 0)<br>
TWriteEnable = (WantToXfer AND NOT DoneFirst) OR PHi:ADVANCE<br>
DoneFirst = DoneFirst OR TWriteEnable<br>
Stall = WantToXfer AND (NOT TWriteEnable)<br>
SWriteEnable = NOT(Stall)<br>
If (SWriteEnable)<br>
Shift Register = Fetch 6 bits from EFSense[ReadBufferl:CurrAclr CurrAdr = CurrAdr+ 640 XfersRemaining = XfersRemaining -1 Endlf Until (TWriteEnable) EndFor<br>
Wait until BufferEF Write process has finished EFSense = NOT (EFSense)<br>
While read process is transfeiiing data from E or T to Xht PHI, a write process is pieparing the next dot-lmc in the other buffer.<br>
The data being written to E or 1" is color I data generated by tite HCU, and color 2-6 data from buffer D (supplied from DRAM). Color 1 data is written to EF whenever the HClfs OutputValid flag is set, and color 2-6 data is written during other limes from register C.<br>
BufferOE, 81 in FIG. 9 is a 32-bit register used to hold a single HCU-gcnerated set of contiguous 32 dots for color 1. While the dots are contiguous on the page, the odd and even dots arc printed at different times.<br>
Buffer AB 82 is a double buffered mechanism for delaying odd dot data for color 1 by 2 dodines. Buffers A and B therefore have identical structures. During the processing of aline of di)is, one ofthe two butTers is read from and then written to. The two buffers are logically swapped after the entire dot line has been processed. A single bit Slag ABSznse delermines wliich of the two buffers ate read frotti and written to.<br>
The HCU provides 32-bits of color I data whenever the outptit valid control flag is set, which is every 32 cycles after the first flag has been sent for the line. The 32 bits define a contiguous set of 32 dots for a single dot line -16 evendois(bitsO, 2, 4etc,), and 16 odd dots (bits 1,3, 5 etc). The output valid control flag is used as a WiiteEnable control for the OE, register 81, We process the HCU data every 2 OutputValid sigtials. The 16 even bits of HCU color I data are combined with the 16 even bits of register OE, to make 32-bits of even color<br><br>
1 data. Similarlv, the 16 odd bils of HOJ color 1 data are combined wilh the 16 odd bits of register OE, to make 33-bits of odd color 1 data. Upon receipt of the first OuipuiVaiid signal of the group of two, we read buffer AB to transfer the odd data to color 1,73 in FIG,  1! within buffer EF. Upon receipt of the second OutputValid signal of the group of two, we write the 32-bitS of odd data lo the same location in buffer AS thai we read ftom previously, and we write the 32-bits of even data to color 1 within buffer EF,<br>
The HCU provides 32 bits of data per color plane whenever the OutputValid control flag is set. This occurs every 32 cycles except during certain startup times. The 32 bits define a contiguous set of 32 dots for a single dot line- 16 even dots (bits 0. 2, 4 etc.), and 16 odd dots (bits 1, 3, 5 etc).<br>
While buffer 0E| (83 in FIG. 10) is used to store a single 32-bit value for color i, buffers OEj to OE^ are used to store a single 32-bit value for colors 2 to 6 respectively. Just as the data for color 1 is split into 32-bils representing COIOT \ odd dots and 32-bits reprssenting toSor 1 even dots every 64 cycles (once every two OutputValid flags), the remaining color planes are also split into even and odd dots.<br>
However, insteadof being written directly to buffer EF, the dot data is delayed by a number of lines, and is written out to DRAM via buffer CD (84 in FIG. 9). While the dots for a given line are written to DRAM, the doisfor a previous line are read from DRAM and written to buffer EF (71,72). This process must be done interleaved with the process writing color 1 to buffer EF.<br>
Every time an OutputValid flag is received from the HCU on line 85 in FiG.  10, the 32-bJts of color N data are written to buffer OE].. (83). Every second OutputValid flag, the combined 64-bit value is written to color buffer N (86). This happens in parallel for all color planes 2-6, Color Buffer N (86) contains 40 sets of 64-bits (320 b&gt;"tes) to enable the dots for two complete segments to be stored. This allows a complete segment generation time (20 X 64= 1280 cycles) for the previous segment"s data (both odd and even dots) to be written out to DRAM, Address generation for writing is straightforward. The Co lorN Write En able signal on line 87 is given every second OutputValid flag. The address starts at 0, and increments every second OutputValid flag until 39. Instead of advancing to 40, the address is reset to 0, thus providing the double-buffering scheme. This works so long as the reading does not occur during the OutputValid flag, and that the previous segment"s data can be written to DRAM in the time it takes to generate a single segment"s data. The process is shown in ihe following pseudocode:<br>
adr = 0<br>
firstEncountered = 0 While (NOT AdvanceLine)<br>
If (HCU_OutputVaIid) AND (first En countered)) CobrNWriteEnable = TRUE ColorNAdr = adr If (adr ~= 39)<br>
adr = 0 Else<br>
adr = adr + 1 Endtf Else<br><br>
ColorNWriteEnable = FALSE Endlf<br>
If {HCU_OutpulVa;id)<br>
firsfEncountered = NOT(firslEncountered) Endlf EndWhile<br>
Address generalion for reading is trickier, since it is lied to tlie timing for DRAM" access (both reading and writing), buffer EF access, and therefore color i generation. It is more ftilly explained below.<br>
Address generation for buffers C, D. E, F, and colorN are all tied to the timing of DRAM access, and must not interfere with color 1 processing with regards to buffers E and F. The basic principle is that the data for a single segment of color N (either odd or even dots) is transferred from the DRAM to buffer EF via buffer CD, Once the data has been read from DR.A&gt;I those dots are replaced based on the values in ColorBufferN. This is done for each of the colors in odd and even dots. After a complete segment"s worth of dots has accumulated (20 sets of 64 cycles), then the process begins again. Once the data for all segments in a given Printline has been transferred from and to DRAM, the current address for that color"s DRAM buffer is advanced so that it will be the appropriate number of lines until the panicular data for the color"s line is read back from DRAM. In this respect then, the DR^A-M acts as a form of FIFO. Consequently color N (either odd or even) is read from DRAM into buffer D while copying color N (same odd/even sense) lo buffer C, The copying of dala to buffer C takes 20 or 21 cycles depending on whether the OutputValid flag occurs during the 20 transfers. Once both tasks have fmished (typically the DRAM access v^ill be the siower task), the second part of t!ic process begins. The data in buffer C is written to DRAM (the same locations as were just read) and the data in buffer D is copied to buffer EF (again, tto color N data is transferred to buffer EF while the OutputValid flag is set since color I data is being transferred). When both tasks have finished the same process occurs for the other sense of color N (either odd or even), and then for each of the remaining colors. The entire double process happens 10 times. The addresses for each of the current lines in DRAM arc then updated for the next line"s processing to begin.<br>
In terms of bandwidth, the DRAM access for dot data buffers consumes the great majority of all DRAM access from PEC. For each print line we read an entire dot line for colors 2-6, and write an entire dot line for colors 2-6, For the maximum of 15 segments this equates to 2 " 5 x 15 x 1280 bits = 192,000 bits |24,00O bytes) per print line. For the fastest printing system (30,000 hnes per second) this equates to 687 MB/sec. For I page per second printing the bandwidth required is 312 MB/sec. Since the bandwidth is so high, the addresses of the various half-lines for each color in DRAM should be optimized for the memory type being used. In an RDRAM memory system for example, the very first half-line buffer is aligned for each color to a 1KByte boundary to maximize page-hits on DRAM access. As the various segments are processed it is necessary to ensure that if the start of the next segment was going to be aligned at byte 960 within the 1KByte page, then the 640-bh access v.ould span 2 pages, Therefore the variable DRAMMaxVal is used lo check for this case, and if il occurs, the address is rounded up tor the next half-line buffer to be page-aligned. Consequently the only waste is 64 byles per 13 segmetils, but have the advantage of the 640-bit access completely within a single page.<br><br>
The address generation process can be considered as NumSegments worth of 10 sets of: 20 x 32-bil reads followed by 20 v 32-bil writes, and it can be seen in tiie following pseudocode:<br>
EFStartAdr = 0<br>
Do NumSegments times:<br>
For CurrCoior = 0 to MaxHaifColors DRAMStartAddress = ColorCurrAdr[CurrColor] While reading 640 bits from DRAMStartAddress tnlo D(&gt;= 20 cycles) ColorNAdr = 0 While (ColorNAdr [= 20)<br>
lf(NOTHCU_OutputValic()<br>
Transfer ColorNBuffer[ColorNAdr|CurrColor_bitO] to C[ColorNAdrI ColorHAdr = ColorNAdr + 1 Endlf EndWhile EndWhile - wait until read has finished<br>
While writing 640 bits from C into DFiAMStartAddress (&gt;=20 cycles) ColorNAdr = 0 EFAdr = EFStartAdr While (ColorNAdr != 20)<br>
lf{NOTHCU_OutputValid)<br>
Transfer D[ColorNAdr] to EF[CurrColor|EFAdr]<br>
If ((ColorNAdr == 19) AND (CurrCoior == NumHalfColors))<br>
EFStartAdr = EFAdr+1 Else<br>
EFAdr = EFAdr+1 Endlf<br>
ColorNAdr = ColorNAdr + 1 Endlf EndWhile EndWhile - wait until write has finished If (DRAMStartAddress == DRAMMaxVal)<br>
ColorCurrAdr[currColor] = round up DRAMStartAddress to next 1 KByte page Else<br>
ColorCurrAdr[cvJrrColor] = DRAMStartAddress + 640 bits Endlf If (Segment == maxSegmenls)<br>
If (ColorCurrRoW[CurrColor] == ColorMaxRow[CurrCDlor]) Colore urrRow[currColor] = ColorStartRow[cjrrColor] ColQrCurrAdr[cutrColof] = ColorStartAdr[currColor) Else<br>
ColorStartRowIcurrColor] = ColorCurrRow[currColorJ + 1 Endlf<br><br>
Endlf EndFor EndDo Wait until next Advance signal from PH/<br>
Note that the MaxI laiffiolors register h one less than the number of colors in terms of odd and even colors treated separately, but not including cM(.i 1. l--or example, ii&gt; terms of a standard 6 color printing system there are 10 (colors 2-6 In odd and even), and so MaxHalfCoIors should be set to 9.<br>
The LLFU requires INumSegmems cycles to prepare the first ISO bits of data for the printhead interface (PHI) 32. Consequently the printhead should be started and the first LineSync pulse must occur this period of time after the LLFU has started. This allows the initial Transfer value to be valid and the next 90-bit value to be ready to be loaded into the Transfer register.<br>
The printhead interface (PHI) 32 is the means by which the processor loads the printhead with the dots to be printed, and controls the actual dot printing process. It takes input from the LLFU and outputs data to the printhead itself. The PHI is capable of dealing with a variety of printhead lengths and formats. In terms of broad operating customizations, the PHI is parameterized according to Table 33:<br>
Table 33. Basic printing parameters<br><br>
The internal strucmre of the PHI allows for a maximum of 6 colors, 8 segments per transfer, and a maximum of 2 segment groups. Tliis is sufficient for a 15 segment (8.5 inch) printer capable of printing M/Lettet at full bleed. Multiple PECs can be connected together to produce wider prints as necessary.<br>
The printhead interface (PHI) contains:<br>
a LineSyncGen unit (LSGU), which provides synchronization signals for multiple PEC chips (allows side-by-side printing and front/back printing) as well as stepper motors.<br>
•	a Memjet interface (MJl), which transfers data to the Memjet printhead.<br>
In FIG. 12 is seen the internal structure of the printhead interface (PHI) 32. In the PHI there are two LSGUs 89,90. The first LSGU 90 produces LineSyncO (LSO), which is used to control the Memjet Interface (MJ!) in all synchronized chips. The second LSGU 89 produces LineSyncI (LSI) which is used to pulse the paper drive stepper motor,<br>
A Master/Slave pin on the chip at 91 allows multiple chips to be connected together for side-by-side priming, front/back printing etc. via a Master/Slave relationship. When the Master/Slave pin is attached to V^p, the chip is considered to be the Master, and LineSync pulses generated by the LineSyncGen unit 90 is enabled onto the two tri-state LineSync common line LineSyncO, shared by all the chips via two tri-state enables 92,<br><br>
When ihc Master/Slave pin is attached to GND. the chip is considered lobe the Slave, and LineSync pulses generated by the two LineSyncGen units 89,90 are not enabled onto the common LineSync lines. In this way, flie Master chip"s LineSync pulses are used by all PHIs on all the connected chips.<br>
The LineSyncGen units (LSGU) 89,90 are responsible for generating the synchionkation pulses required for printing a page. Each LSGU produces an external LineSync signal to enable line synchronization. A generator inside the LGSU generates a LineSync pulse when told lo "go", and then every so many cycles until told to stop. The LineSync piilse defines the stan of the next line. The exact number of cycles between LineSync pulses is determined by the CyclesBetweenPulses register, one per generator. It must be at least long enough to allow one line to print and another line to load, but can be longer as desired (for example, to accommodate special requirements of paper transport circuitry). If the CyelesBetweenPulses register is set to a number less than a line print lime, the page will not print properly since each LineSync pulse will arrive before the particular line has finished printing.<br>
The following interface registers are contained in the LSGLl:<br>
Table 34. LineSyncGen Unit registers<br><br>
The LineSync pulse is not used directly from the LGSU, The I.ineSyncO pulse is enabled onto a tri-state LineSyncO line 97 only if the Master/Slave pin at 91 is set to Master, Consequently the LineSync pulse is otviy used in the form as generated by the Master PEC (pulses generated by Slave PECs are ignored).<br>
The Memjet interface (MJI) 93 transfers data to the Memjei printhead at 94, and tells the Memjei interface when lo start printing the next line of data. It is also used to enable feedback from a specified segment. The Memjet printhead 95 icself is responsible for controlling the firing sequence of its nozzles, with firing profiles programmed via the I^C serial interface 36 in FIG. 3. The MJI contains a state machine that follows the printhead loading order described in Section 18.1, and it may include functionality for a preheat cycle and a cleaning cycle. Dot counts for each color are also kept by the MJI (see below).<br>
The Mil loads data into the printhead from a choice of 2 data sources;<br>
All Is. This means that all nozzles will fire during a subsequent Print cycle, and is the<br>
standard mechanism for loading the printhead for a preheat or cleaning cycle.<br>
*	Fromlhe90-bit input held in the Transfer register of theLLFU. This is the standard means<br>
of printing an image.   In a first transfer, the first 48 bits are sent to the printhead, and in a second<br>
transfer, the last 42 bits are sent to the printhead with the top 6 bits 0. Once all 90 bits have been sent,<br>
a I-bit "Advance"control pulse is sent to theLLFU.<br>
The MJI knows how many lines it has to print for the page. When the MJI is told to -go", it waits for a LineSync pulse before it starts the first line (via an NPSync pulse to the printhead). Once it has finished 1 oading.fprinting a line, it waits until the next LineSynt pulse before starting the next line. The MJI stops once<br><br>
the specified number of lines has been loaded/printed, and ignores any further l.ineSync pulses. The MJI is therefore directly connected to the LLFU 31 (see FIGs 3 and 4) at 96, LineSyncO at 97 (shared between all synchronized chips), and the external Memjetprinthead 95, The MJI accepts 90 bits of data from the LLFU. Of these 90 bils, only the bits corresponding to (he number of segments and number of colors wiU be valid. Tlie MJI"s state machine does not care which bits are valid and which bits are not valid - it merely passes the bits out to the prinlhead. The data lines and control signals coming out of the MJ! are wired to the pinouts of the chip as described below.<br>
The MJI has a number of connections to the printhead, including a maximum of 6 colors, clocked in to a maximum of 8 segments per transfer (o a maximum of 2 segment groups. Table 35 lists the connections, with the sense of input and output with respect to the MJI. The names correspond to the pin connections on the printhead.<br><br>
The MJI maintains a count of the number of dots of each color fired from the printhead. The dot count for each color is a 32-bit value, individually cleared under processor control. At 32-bits length, each dot count can hold a maximum coverage dot count of 17 8-inch x 12-inch pages, although in typical usage, the dot count will be read and cleared after each page or half-page. The dot counts are used by the processor to update a QA chip in order to predict when the ink cartridge runs out of ink. The processor knows the volume of ink in the cartridgefor each ofthe colors from the QA chip. Counting the number of drops eliminates the need for ink sensors, and prevents the ink channels from running dry. An updated drop count is written to the QA chip after each page. A new page will aai be printed unless there is enough ink left, and alloivs the user lo change ihe ink without getting a dud half-printed page which must be reprinted.<br>
In FIG. 13 is seen the layout of a dot counter for Color N. All 6 dot counters are preferably identical in structure. The dot counter takes the color N data at 98, from the HCU, into a 15 line to 4 line encoder 99. The four line output ofthe encoder 99 is to an adder 100 and Color N Dot Count 101 ou^utling a 32 bit count at 102. The counter 101 might be cleared by abft on line 103, Loading of the counter 101 is clocked by a bit on 104.<br>
The processor communicates with the MJI via a register set, Tbe registers allow the processor to parameterize a print as well as receive feedback about print progress. The following registers are contained in the MJI;<br><br>
Table 56. Memjet interface registers<br><br>
Register Name<br>
Print Parameters<br>
Description<br>
SegmentsPerXfer<br>
rile number of segments io write to each transfer. This also equals the number of cycles to wait between each transfer (before generating the next Advance pulse). Each transfer ras MaxCoiors x SegmentsPerXfer valid bits.<br>
SegmenlGroups<br>
rhe number of segment groups in the prinlhead. This equals the number of times thai SegmentsPerXfer cycles must elapse before a single dot has been writien to each segment of the prinlhead. The MJI does this 1280 times to completely transfer all the Jala for the line to the printhead.<br>
Num Lines<br>
rhe number of Load/Print cycles to perform.<br>
Monitoring the Print (read only from point of view of processor)<br>
Status<br>
The Memjet Interface"s Status Register<br>
LinesRemaining<br>
The number oflines remaining to be printed. Only valid while Go=l. Starting value is NumLines and counts down to 0.<br>
FransfersRemaining<br>
The number of sets of SegmentGroups transfers remaining before the Printhead is i^nsidered loaded for the current line. Starts at 1280 and counts down to Q. Only valid while Go=l.<br>
SegGroupsRemaining<br>
The number of segment groups remaining in the current set of transfers of I dot to each segment. Starts at SegmentGroups and counts down to 0. Only valid while Go=l,<br>
Sense Segment<br>
The 8-bit value to place on the Dl lines during a subsequent feedback CCEn pulse. Only 1 of the 8 bits should be set, corresponding to one of the (maximum) 8 segments. See SenseSelecl for how to determine which of the segment groups to sense.<br>
SelAlWozzies<br>
If non-zero, the 48-bit value written to ftie printhead during the LoadDots process is all<br>
Is, so that all nozzles will be fired during the subsequent PrintDots process. This is used<br>
during the preheat and cleaning cycles.<br>
If 0, the 48-bit value written to the prinlhead comes from the LLFU. This is the case<br>
during the actual printing of regular images.	<br><br>
Actions<br>
Reset<br>
Sense Select<br>
Go<br>
ClearCounts<br><br>
A write io this register resets the MJI, stops any loading or printing processes, and loads all registers with 0. The MJI also places a pulse on the RESET line connected to the printhead.<br>
A write to this register with any value clears the FeedbackValid bit of the Status register, and the remaining action depends on the values in the LoadingDots and PrintingDots status bits. If either of the status bits are set. the Feedback bit is cleared and nothing more is done. If both status bits are clear, a pulse is given simultaneously on both CCEn lines with all Dn bits 0. This stops any existing feedback. Depending on the two low-order bits writien lo ^enseSelect register, a pulse is given on CCEnl or CCEn2 . with the Dl bits set according to :he SenseSegment register. Once the sense line has been tested, the value is placed in the PHSense registers, and ihe Feedback bit of the Status register is set<br>
A write of 1 to this bit starts the LoadDoIs / PrintDots cycles, which commences with a wail for the first LineSync pulse. A total of NumLines lines are printed, each line being loaded/printed afier the receipt of a LineSync pulse. The loading of each line consists oi SegmentGroups 48-bit transfers. As each line is printed, LinesRemaining decrements, and FransfersRemaining is reloaded with SegmentGroups again, and an NPSync pulse is given to the printhead. The status register contains print status information. Upon completion ol NumLines, the loading/printing process stops, the Go bit is cleared, and any further LineSync pulses are ignored. During the final print cycle, nothing is loaded into the printhead. A write of Q to this bit stops the prim process, but does not clear any other registers.<br>
A write to this register clears the ColorlDolCounl, Color2DolCount, Color3DotCount.<br>
Color4DotCounl, Color5DotCount, and Color6DotCounl registers if bits 0, 1, 2, 3, 4, 5, or 6<br>
respectively are set. Consequently a write of Q has no ctTect.	<br><br>
Feedback<br>
PHSense<br>
Read only feedback of the printhead"s sense from the last CCEn pulse sent to segment<br>
SenseSegment. Is only valid if the FeedbackValid bit of the Status register is set.	<br>
Color! DotCount<br>
Readonly 32-bit count of color I dots sent to the printhead.<br>
Color2DotCount<br>
Read only 32-bit count of colorZ dots sent to the printhead.<br>
Color3 DotCount<br>
Readonly 32-bit count of color3 dots sent to the printhead<br>
Coior4 DotCount<br>
Read only 32-bil count of color4 dots sent to the printhead<br>
ColorSDotCount<br>
Read only 32-bit count of colorS dots sent to the printhead<br>
Color6DotCouni<br>
Read only 32-bit count of color6 dots sent to the printhead The MW s Status register is a 16-bit register with bit interpretations as follows;<br>
Table 37. MJI Status register<br><br><br>
The following pseudocode illustrates the logic required to load a printhcad for a single line. Note that loading commences only after the LineSync pulse arrives. This is to ensure the data for the line has been prepared by the LLFU and is valid for the first transfer to the printhead.<br>
Wait for LineSync<br>
For TransfersRemaining = 1260 to 0 For I = 0 to SegmentGroups If (SetAllNozzles)<br>
Set all Dn lines to be 1 Else If (1 = 0)<br>
Place first 48 bits of LLFU"s 90 bit Transfer register on 48 Dn lines<br>
Else<br>
Place last 42 bits of LLFU"s 90 brt Transfer register on 48 Dn lines<br>
Endlf<br>
Pulse SCIk<br>
Wait SegmentsPerXfer cycles Send ADVANCE signal EndFor EndFor<br>
Cleaning and preheat cycles are simply accomplished by setting appropriate registers in the MJI and programming the printhead"s firing pulse profiles,<br>
SetAllNoziles= 1<br>
Set the firing pulse profile to either a low duration (in the case of the preheat mode) or to an<br>
appropriate drop ejection duration for cleaning mode.<br>
&gt;	Set NumLinea to be the nutnber of times the nozzles should be fired<br>
Set the Go bit and then wait for the Go bit to be cleared when the print cycles have completed.<br>
The LSGU must also be programmed to send LineSync pulses at the correct frequency.<br>
Throughout the specification the aim has been to describe the preferred embodiments of the invention uithout limiting the invention to any one embodiment or specific collection of features. Persons skilled in the art may realize variations from the specific embodiments that will nonetheless fall within the scope of the invention.<br><br><br><br>
WE CLAIM:<br>
1.	A print controller configured to be coupled with one or more further print<br>
controllers to drive an ink drop printhead, the print controller comprising:<br>
an interface at which to receive compressed page data;<br>
image decoders to decode compressed image planes in the received compressed<br>
page data;<br>
a compositor to composite respective strips of the decoded image planes; and<br>
a printhead interface to output the composite strip to a printhead,<br>
characterised in that the printhead interface includes:<br>
a multi-segment printhead interface outputting printhead formatted data; and<br>
a synchronization signal generator outputting a synchronization signal to<br>
couple the print controllers to synchronize their respective composite strips at<br>
the printhead.<br>
2.	The print controller as claimed in claim 1 wherein the printhead interface accepts its own synchronization signal as a master controller to all print controllers or that of another print controller as a slave.<br>
3.	The print controller as claimed in claim 2 wherein prmthead interface includes an input at which a signal determines if the print controller is a master controller or a slave.<br><br>
4.	The print controller as claimed in anyone of claims 1 to 3 wherein the compositor scales input image planes under control of a margin unit set to establish print data for a strip of the image,<br>
5.	The print controller as claimed in claim 1 with the addition of a tag encoder to calculate respective strips of a tag image plane.<br>
6.	A print controller as claimed in claim 1, wherein;<br>
the image decoders include:<br>
a contone image decoder to decode any compressed continuous tone image planes in the received compressed page data; and<br>
a bi-level decoder to decode any compressed bi-level image plane and/or dither data in the received compressed page data; and<br>
the compositor includes a dot merger unit controlled by a color mask to effect integration of the image planes with what inks are provided in the printhead.<br>
7.	The print controller as claimed in claim 6 wherem the compositor further includes a margin unit to apply margin data to the respective image planes during the composite process to generate print data in strips.<br>
8.	An inkdrop printer with a printhead driven by multiple print controllers, each print controller being configured as claimed in claim 1, wherein:<br>
one printhead interface of one print controller is arranged to generate the synchronization signal to synchronize the print controllers to drive the printhead at<br><br>
anyone or more of higher speed, higher input resolution, higher number of color planes, higher outlet resolution or wider format.<br>
9.	The printer as claimed in claim 8 wherein each printhead interface accepts its own<br>
synchronization signal as a master controller to all print controllers or that of another<br>
print controller as a slave.<br>
10.	The printen as claimed in claim 9 wherein each printhead interface<br>
includes an input at which a signal determines if the print controller is a master<br>
controller or a slave.<br>
11.	The inkdrop printer as claimed in claim 8, wherein:<br>
the image decoders include:<br>
a contone image decoder to decode any compressed continuous tone image planes in the received compressed page data; and<br>
a bi-level decoder to decode any bi-level image planes and/or dither data in the received compressed page data;<br>
the compositor is arranged to composite any bi-level image plane over any continuous tone image plane wherein the page data in the image planes is scaled under control of a margin unit to establish data for a strip of the image; and<br>
the printhead receives strip form print data in parallel from the multiple print controllers.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgYWJzdHJhY3QgZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che abstract duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgY2xhaW1zIGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che claims duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgY29ycmVzcG9uZGVuY2Ugb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che correspondence others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgY29ycmVzcG9uZGVuY2UgcG8ucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che correspondence po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgZGVzY3JpcHRpb24gKGNvbXBsZXRlKSBkdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che description (complete) duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgZm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgZm9ybS0xOS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgZm9ybS0yNi5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgZm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgZm9ybS00LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che form-4.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgcGN0LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che pct.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMjA1Ny1jaGUgcGV0aWl0b24ucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-2057-che petiiton.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="202408-a-pump-assembly-for-a-print-engine.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="202410-a-method-of-controlling-the-firing-of-nozzles-in-a-printhed-a-printhed-and-a-printer-including-same.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>202409</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2002/2057/CHE</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>05/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>02-Feb-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>05-Oct-2006</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>12-Dec-2002</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>M/S. SILVERBROOK RESEARCH PTY LTD</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>393 Darling Street Balmain, NSW 2041</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>LAPSTUN, Paul</td>
											<td>13 Duke Avenue Rodd Point, NSW 2046</td>
										</tr>
										<tr>
											<td>2</td>
											<td>WALMSLEY, Simon, Robert</td>
											<td>Unit 3 9 Pembroke Street Epping, NSW 2121</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04N 1/387</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/AU2000/000754</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-06-30</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td></td>
									<td></td>
								    <td>NA</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/202409-print-engine-controller-to-work-in-multiples-and-a-printhead-driven-by-multiple-print-engine-controllers by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:03:43 GMT -->
</html>
