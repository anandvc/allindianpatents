<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/221493-method-of-generating-a-stream-cipher-using-multiple-keys by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:34:49 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 221493:METHOD OF GENERATING A STREAM CIPHER USING MULTIPLE KEYS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD OF GENERATING A STREAM CIPHER USING MULTIPLE KEYS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method of generating a stream cipher having length x bytes, the method comprising the steps of: i) selecting a number n representing a number of sub- keys, and n unique prime numbers mn each representing a unique non-repeating sub-key length mn bytes; ii) generating n unique random numbers, each having non-repeating length mn bytes; iii) generating a n+1 st random number R; iv) for each byte whose position in said n random number is p, where p= Modmn(R), consecutively applying a function to each p byte of each of said n random numbers to generate a value; v) incrementing the value of p by 1; and vi) repeating step iv) and v) and concatenating each said value produced in step iv) to the previous value produced in step iv) until said stream cipher of X bytes in length has been produced.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT, 1970<br>
(39 OF 1970)<br>
COMPLETE SPECIFICATION<br>
(See Section 10)<br>
METHOD  OF  GENERATING A<br>
STREAM CIPHER USING<br>
MULTIPLE  KEYS<br>
(a)	BOREN, Stephen Laurence, Canadian National, residing at #209-188 Milross Avenue Vancouver British Columbia V6A 4J4, Canada<br>
(b)	BRISSON, Andre Jacques, Canadian National, residing   at #701-1736 West, 10th Avenue, Vancouver British     Columbia V6J2A6, Canada<br>
The  following  Specification  describes  the  nature  of  this invention and the manner in which it is to be performed:-<br><br>
Original <br>
Granted<br>
13-6-2005<br><br><br>
13/6/2005<br><br>
Method of Generating a Stream Cipher Using Multiple Keys<br>
Cross-Reference to Related Applications<br>
 	This application is a continuation-in-part of United States patent<br>
Application no. 10/299,847 filed November 20, 2002, which is pending.<br>
Technical Field<br>
	The invention relates to the field of encryption methods and more<br>
particularly    to a method of generating a stream cipher to encrypt electronic communications which may be extremely long.<br>
Background Art<br><br>
Various methods of encryption to provide secure electronic communications are well known in the art. In symmetric methods of encryption, the sender and the recipient use the same code or key to encrypt and decrypt the message.    The only completely secure cipher<br>
        which cannot possibly be broken or deciphered is the One-Time Pad (OTP). A OTP takes a stream of bits that contains the plaintext message, and a secret random bit-stream of the same length as the plaintext (the key). To encrypt the plaintext with the key, each pair of bits from the key and plaintext is sequentially acted on by the   exclusive-or function to<br>
       obtain the ciphertext bit. The ciphertext cannot be deciphered if the key is truly random and the key is kept secret from an unauthorised party. The<br><br><br>
problem with this method is that the key should be at least the same length as the message.   If a shorter key is used and repeated then the cipher can be broken.    In some cases the data which needs to be encrypted is extremely large. <br>
There is therefore a need for a method of generating a random key, or OTP, which is of variable length and that allows for encryption of very large amounts of data.<br>
        Disclosure of Invention<br>
The present invention therefore provides a method of generating a stream cipher having length x bytes, the method comprising the steps of i) selecting a number n of sub-keys each having a unique non-repeating<br>
       length mn bytes; ii) generating n random numbers, one for each sub-key, each having length mn bytes; iii) generating a n+lst random number R; iv) set p= Modmn(R); v) for each byte whose position in the nth random number is p applying a function to all n bytes to generate a value; vi) concatenating the value to the end of the stream cipher; vii) set p=p+l;<br>
       and viii) repeating step v), vi) and vii) until the stream cipher is x bytes in length. Preferably the selected length m of each sub-key is a prime number. The method may also include the further step of applying a delinearization function to the stream cipher.<br>
According to one aspect of the invention, each of the n random<br>
       numbers is generated by: i) generating a n + 2nd random number which is not a perfect square; ii) calculating the square root of the n + 2nd random<br><br><br>
number; iii) generating a n + 3rd random number; iv) commencing with a digit whose position in the n + 2nd random number is calculated based on the n + 3rd random number, taking finite strings of digits sequentially and converting each finite string into a byte; v) concatenating each byte      sequentially until the selected length mn of said each of the n random numbers has been reached.<br>
The invention further provides a computer program product, an article for carrying out the method, and a data processing system for         carrying out the method.<br>
Brief Description of Drawings<br>
In  drawings  which  disclose  a  preferred  embodiment  of the         invention:<br>
Fig. 1 is a schematic illustration of a computer system for carrying out the method of the invention; and Fig. 2 is a flow chart illustrating the method of the invention.  <br>
Best Mode(s) For Carrying Out the Invention<br>
Fig. 2 illustrates by way of a flowchart the method of generating<br>
        the encryption key of the present invention.   In particular an encryption<br>
key, a non-repeating stream cipher of indefinite length referred to herein<br><br><br>
as the Super Key, is formed by combining sub-keys. Any number n of sub keys K1, K2, ..., K can be specified depending on the application. The greater the number of sub-keys, the greater the length of the non¬repeating Super Key. The length of each sub key is a prime number of       bytes (preferably with prime numbers larger than 10).<br>
The first step in the process is to determine how large a Super Key, or stream cipher, to deploy. The number n of sub-keys and the non¬repeating length m, of each sub-key, in bytes, are selected. The sub-keys<br>
       each have a unique non-repeating length, that is, no two sub-keys are of the same non-repeating length. Preferably the sub-key non-repeating lengths are prime numbers of bytes. Preferably the length of the sub-keys, in bytes, are prime numbers in the range 2, 3, 5, ..., 1021, as there are 172 different prime numbers in this range. The selection may be done<br>
        by manually entering the number of sub- keys and their prime number nori-repeating lengths. Alternatively, the number of keys and their prime number non-repeating lengths is programmed into an application, or a program randomly selects the number of sub-keys and their non-repeating length. For n sub-keys K„, the non-repeating length of the Super Key will<br>
         be Size (Kj) X Size (K2) X Size (K3) ..:X Size (Kn). For example, assume 10 sub- keys of the following prime number non-repeating lengths are used:<br>
Sub Key 1 = 13 bytes = K,<br>
         Sub Key 2-     17 bytes-= K2<br>
Sub Key 3 = 19 bytes= K3-<br><br><br>
Sub Key 4 = 23 bytes = K4 Sub Key 5 = 29 bytes = K5 Sub Key 6 = 31 bytes-K6 Sub Key 7 = 37 bytes = K7 Sub Key 8 = 41 bytes = KS Sub Key 9 = 43 bytes = K9 Sub Key 10 = 47 bytes = K10<br>
The resulting non-repeating'Super Key length is 13X 17 X 19 X 23 X 29 X 31 X 37 X 41 X 43 X 47 = 266,186,053,068,611 bytes. Thus, using a small number of sub-keys, each of small prime number non-repeating length results in an extremely long non-repeating Super Key. The total definition for the size of the Super Key above is contained in 300 bytes (the sum of the lengths of the non-repeating sub-keys) and the header (number of sub-keys and their lengths). Thus the total definition for a Super Key will be a fraction of the size of the Super Key.<br>
While preferably the non-repeating length of each sub-key is a prime number of bytes, to improve the randomness of the resulting cipher, the method will also work if non-prime nuniber lengths are used, as long as the resulting cipher is very large.<br>
To select the number of sub-keys, preferably this is calculated by talcing the first two digits generated by a random stream, MODed by 50 and adding 50 to provide a number of keys between 50 and 99.<br><br><br>
Each sub-key of the multi-key process may be created as follows First a random number which is not a perfect square is generated, preferably by a highly random source. Preferably it is an integer in the range of 500 to 700 digits. This serves as a "first seed value" O. It is     verified that the selected value 0 is not a perfect square. If it is, then additional random values will be generated until one meets this criterion. The second seed value is a 32-bit value that is used to seed the rand function of the computer. Random number generators that are included in the operating systems of most computers are pseudo-random and not      very robust. Tliese values, however, are sufficient as a starting point. The second random number P is also generated from the computer's rand function. It is then MODed by 100 to set the starting point. The square root Q of the first seed value O is calculated, resulting in an irrational number Q (one that extends infinitely after the decimal point and is non-     repeating). The resultant string of digits after the decimal point is potentially infinite in length and is highly random. The computer discards the digits in front of the decimal and computes the number Q up to P digits after the decimal. Then, starting at the Pth digit of Q after the decimal point, the computer sequentially selects 4 digits at a time, and      calculates the Mod 256 value of the 4 digits. This results in an 8-bit value. This value is used as the first byte of the sub-key. This process is repeated 4 digits at a time, continuing with the next digits in sequence, until a string of random data equal to the prime number non-repeating length of the sub-key being created is completed. This process is         repeated for all the sub keys until the non-repeating length for all the sub keys are created.    Each sub-key then is formed by talcing the non-<br><br><br>
repeating string of bytes thus created, and repeating it as often as necessaiy to form a sub-key of sufficient length to create the Super Key in combination with the other sub-keys.<br>
	The algorithm for generating the sub-keys can be described as<br>
follows:<br>
1. Treat seed1 as the decimal representation of an integer in the range of 500-700 digits.          2. Let X:= seedl<br>
3.	Let Y: = -Jx is the irrational number generated by square rooting X<br>
4.	Let Z\, Z2, Z3, Z4,.. be the digits after the decimal point in the decimal<br>
representation of Y. Each Z1 is in the range 0,..,9.<br>
5.	Call srand(seed2). // only the first time<br>
          6. Call rand() to get the irrational starting point, start.<br>
7.	Let start :=rand() mod 100. start is in the range 0,1,..,99.<br>
8.	Throw away Zi and Z2 all the way to Zstart.<br>
9.	Let tmp := 10*Z(Start+i) + Z(start+2)  Throw away those used values.<br>
10.	Let n := 50 + (tmp mod 50). n is in the range 50,51,..,99.<br>
      '     ll.For i:=l,2,..,n,do:<br>
12.	Letj = 3*(i-1)<br>
13.	Let tmp be the next byte from the Z stream.<br>
14.	Let tmp := 100*Zj+I + 10*Zj+2 + Zj+3<br>
15.	Let t := 172 - (tmp mod 172). t is in the range 1,2,.., 172.            16.     Let u be the tth prime among the sequence 2,3,5,.., 1021'."""""<br><br>
17.	If u is equal to any of I1, l2,.., 1{M}, set t to (t+l)mod 172 goto 16<br>
18.	Setlj = u.<br>
19.	Next I: goto 11 until all subkey sizes are set.<br>
20.Fori"l,2,..,n, do:<br>
         21.  Forj:=0,l,2J..,li,do:<br>
22.	Let k:=4*j<br>
23.	Let tmp be the next byte from the Z stream.<br>
24.	Let tmp := (1000*Zk + 100*Zk+1 + 10*Zk+2 + Zk+3) mod 256<br>
25.	Let s):-tmp<br>
         26.  Next j : Next subkey byte<br><br><br>
27. Next.I: Next subkey 28.For i:=0,l,2,..,255,do:<br>
29.	Let j:=4*i<br>
30.	Let tmp := (1000*Zj + 100*Zj+1 + 10*Zj+2 + Zj+3) mod 256<br>
        31.  If tmp is equal to any of S[0], S[l],.., S[i-1], set to (tmp+l)mod 256 goto 31<br>
32.	SetS[i]:=tmp.<br>
33.	Next i<br>
34.	Let offset := ZjZj+i...Z,-+9<br>
          35. Return n, (l1,!2,../), (sl,s2,..,sn), S[256] and offset.<br>
36.	Save in keyfile and add seed1 and start value to DB<br>
37.	Increment seedl and goto 2 //repeat until enough keys are created<br>
	Once all the sub-keys are created as above, the Super Key (cipher)<br>
is created to the length required. This means the Super Key will continue to be created to encrypt the associated data to be encrypted, and continues to be created only until all the data is encrypted. First a random number R ("third seed value", or the starting offset for the Super Key, as opposed<br>
       to the starting point P for the number Q) is generated. Starting with any one of the n sub-keys, having length mn, the Modmn of R is calculated and the Modmn(R)th byte of each sub-key is consecutively exclusive-or'd (X/OR'd) with the corresponding Modmn(R)th byte of every other sub-key.   For example, if R=100, and the length of the first sub-key is 91<br>
       bytes and the second sub-key 43 bytes, then the 3rd byte of sub-key 1 is selected and X|OR'd with the 14th byte of sub-key 2 and corresponding bytes of the other remaining sub-keys selected in the same way based on R. The process is repeated until all the selected bytes from each sub-key have been X/OR'd.   The resulting value may then be put through a<br>
        substitution cipher or another deimearization function to delinearize the<br><br><br>
Super Key stream, as described further below. The resultant binary value is then added to the Super Key by concatenation. The next, subsequent byte of sub-key 1 is then X|OR'd with the next byte of sub-key 2 and so on. Again the process is repeated until all the selected bytes from each      sub-key have been X/OR'd and delinearized. The resulting binary value of each function is again added to the Super Key by concatenation. While the XOR function is preferred, it will be apparent that other functions can be applied. For example, mathematical functions of addition or subtraction can be used.   As each byte of the Super Key is<br>
       generated, the corresponding byte of the plaintext message is then encrypted with the con'esponding byte of the Super Key by the exclusive-or function or some other mathematical function. Once all the bytes of the plaintext message have been encrypted the generation of the Super Key terminates. The encrypted message can then be decrypted applying<br>
         the inverse of the encrypting function to it and the Super Key.<br>
To illustrate further the generation of the Super Key from the sub-keys, let sf denote the j-th byte of the i-th "sub key".  Let £{l) denote<br>
 the length of the i-th sub-key.  For example, we might have ix    = 13,<br>
    17, and so on. Create from the "sub key" i the unending sequence of bytes<br><br><br><br>
Let s j  denote the j'-th. byte of the above sequence, if j is any natural number 0 to co; the lowest value of j in the subscript of is Rmodulo<br>
  where R is a random number. Then, they'-thbyte of the "Super Key," call it Zj, is defined by <br><br>
Here, " " denotes the XOR operation. The first byte of the Super Key is: <br><br>
Where Rmod  returns an integer in the range 0,1,2,...,           The "SuperKey" has a j value that ranges from 0 to<br><br>
Let P0,P1,P2,P3,-. be the bytes of the plaintext, and C0,C1,... the bytes of the ciphertext, in order. Also, zo,z1,... denotes the bytes of the "Super       Key" (computed as already described above). We define the ciphertext by Ci := P; xor S[z]. The ciphertext C is formed by concatenating the bytes Co,C1,..,and then C is returned as the result of the encryption process. Decryption works in reverse in the obvious manner.<br><br><br>
To encrypt an L-byte plaintext, an L-byte Super Key is generated, and a big number counter T is used to count the number of bytes in the plaintext. The output is an L-byte ciphertext. To decrypt the ciphertext, the same big number counter T is used and the output is the L-byte plaintext.<br>
In order to reduce the linearity of the ciphertext using the present method, a further step may be applied to the Super Key before the plaintext message is encrypted. In the preferred embodiment, a substitution cipher is applied to the Super key, and the resultant string is then used to encrypt the plaintext message. For example, an array of 256 unique bytes is created, from 1 to 256 ordered randomly. The first byte in the Super Key then has substituted for it the value of the x+1 st byte in the Super Key, where x is the first value in the 256 byte array. The second byte in the Super Key then has substituted for it the value of the y+2nd byte in the Super Key, where y is the second value in the 256 byte array, and so on. The 256-byte array can be formed from one of the sub-keys, plugging in bytes from a sub-key into the array so long as they don't repeat a previous entry in the array.<br>
The linearity of the cipher text can be reduced also by applying the substitution cipher to the encrypted message (ciphertext) however it is more effective to apply the substitution cipher to the Super Key prior to encrypting. Other utilities besides a substitution cipher can be used to break linearity, such as invertible non-mear function (INLF) utilities<br><br><br>
available from SANDIA labs.   These are useful to provide protection against the Berlekamp-Massey attack.<br>
While preferably the random non-repeating string which forms        each sub-key is generated as described above, the method will also work if the non-repeating string of each sub-key is simply generated by a random number generator to form each sub-key, as long as the overall resultant length of the Super key is sufficiently large so that the resultant Super Key is at least double the size of the data to be encrypted.<br><br>
The foregoing method can be used to produce a personal security system whereby the key is used to encrypt personal files that the user wishes to secure. In that case no method of distribution of the key will be required.     As    each    file    is    encrypted    a    new    file    named<br>
    {OLDFILENAME}.{OFFSET}.wn. The OLDFILENAME includes the extension to allow for easy decryption and maintaining the same file format for functionality. As each file is encrypted, it is immediately decrypted and compared to the original and then both the test copy and the original file are deleted using a clean sweep deletion process (entire<br>
        file rewritten as 0's and then 1 's and then deleted).<br>
A preferred key file format is defined as follows:<br>
typedef struct wnkeyfiletype {             char field[2]; //must be WN to identify file format<br>
long version; // file type version number to allow changes<br>
BIGNLTMBER	offset; // the offset is a large number stored as a<br>
// string of decimal digits delineated by '""s<br><br><br>
long numsk; // the number of subkeys long sklen[numsk];                // the individual subkey lengths char skl[sklen[l]]; // the 1st subkey char skl [slden[2]];//the 2nd subkey            char skl[sklen[3]];//the 3rd subkey<br>
char sknumsk[sklen[numsk]]; // the numskth subkey<br>
char substit[256]; // the substitution cipher key } WNKEYFILE; <br>
The foregoing key file format is standard. The only different value is the<br>
offset that is stored in a string of decimal digits that are delineated by '"s.<br>
An example of this would be "987654321", this allows for values ranging<br>
up to 1000 digits long which prevents the reuse of sections of the key<br>
         stream if the offset is implemented properly.<br>
The present invention is described above as a computer-implemented method, for example to encrypt and decrypt communi¬cations between computers 14 and 16 over network 12.  It may also be<br>
       embodied as a computer hardware apparatus, computer software code or a combination of same. The invention may' also be embodied as a computer-readable storage medium embodying code for implementing the invention. Such storage medium may be magnetic or optical, hard or floppy disk, CD-ROM, firmware or other storage media.  The invention<br>
        may also be embodied on a computer readable modulated carrier signal.<br>
As will be apparent to those skilled in the art in the light of the foregoing disclosure, many alterations and modifications are possible in the practice of this invention without departing from the spirit or scope<br><br><br>
WHAT IS CLAIMED IS;<br>
1.      A method of generating a stream cipher having length x bytes, the<br>
method comprising the steps of:<br>
          i)       selecting a number n representing a number of sub-<br>
keys, and n unique prime numbers mn each representing a unique non-repeating sub-key length mn bytes;<br>
ii)      generating n unique random numbers, each having<br>
non-repeating length mn bytes;<br>
         iii)     generating a n+1 st random number R;<br>
iv)     for each byte whose position in said n random<br>
number is p, where p= Modmn(R), consecutively applying a<br>
function to each p byte of each of said n random numbers to<br>
generate a value;<br>
         v)      incrementing the value of p by 1; and<br>
             vi) repeating step iv) and v) and concatenating each said value produced in step iv) to the previous value produced in step iv) until said stream cipher of X bytes in length has been produced.<br>
        2.      The method of claim 1 wherein said selected length mn of each said sub-key is a prime number greater than 10.<br>
3.      The method of claim 1 wherein said function applied consecutively<br>
to each said p bytes of said n random numbers is the exclusive-or<br>
function, which is applied by obtaining the result of applying the<br>
     exclusive-or function initially to the nth and the n+lst pair of p<br>
AMENDED SHEET<br><br>
bytes where n=l and then consecutively incrementing n by 1 and applying the exclusive-or function to said result and the next pth byte.<br>
The method of claim 1 comprising the further step of applying a delinearization function to said stream cipher.<br>
The method of claim 4 wherein said delinearization function is a substitution cipher.<br>
The method of claim 1 wherein each of said n random numbers are generated by:<br>
i)       generating a n + 2nd random number which is not a perfect square;<br>
ii)     calculating the square root of said n + 2nd random number;<br>
iii)     generating a n + 3rd random number;<br>
iv)     commencing with a digit whose position in said n + 2nd random number is calculated based on said n + 3rd random number, taking finite strings of digits sequentially and converting each said finite string into a byte;<br>
v)      concatenating each byte sequentially until the selected length mn of said each of said n random numbers has been reached.<br>
The method of claim 6 wherein said finite strings of digits are at least 4 digits long.<br>
AMENDED SHEET<br><br><br>
8.      The method of claim 7 wherein said finite string is converted into a. byte by applying a mod function.<br>
       9.      The method of claim 8 wherein said finite string is converted into a byte by applying a mod 256 function.<br><br><br>
Date:-13th June 2005<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtY2xhaW1zKGdyYW50ZWQpLSgxMy02LTIwMDUpLmRvYw==" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-claims(granted)-(13-6-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtY2xhaW1zKGdyYW50ZWQpLSgxMy02LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-claims(granted)-(13-6-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtY29ycmVzcG9uZGVuY2UoNC0xMC0yMDA3KS5wZGY=" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-correspondence(4-10-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtY29ycmVzcG9uZGVuY2UoaXBvKS0oMjAtNi0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-correspondence(ipo)-(20-6-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtZm9ybSAxKDEzLTYtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-form 1(13-6-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtZm9ybSAxOCgxOC0xMS0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-form 18(18-11-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtZm9ybSAyKGdyYW50ZWQpLSgxMy02LTIwMDUpLmRvYw==" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-form 2(granted)-(13-6-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtZm9ybSAyKGdyYW50ZWQpLSgxMy02LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-form 2(granted)-(13-6-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtZm9ybSAyNig1LTUtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-form 26(5-5-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtZm9ybSAzKDEwLTYtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-form 3(10-6-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtZm9ybSAzKDI1LTctMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-form 3(25-7-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtZm9ybSA1KDEwLTYtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-form 5(10-6-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtZm9ybS1wY3QtaXNhLTIxMCgxMi02LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-form-pct-isa-210(12-6-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjA2LW11bW5wLTIwMDUtZm9ybS1wY3QtaXNwZWEoMTgtMS0yMDA3KS5wZGY=" target="_blank" style="word-wrap:break-word;">606-mumnp-2005-form-pct-ispea(18-1-2007).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="221492-a-process-for-preparing-a-composition-for-manufacturing-textured-soluble-container-and-a-container-manufactured-therefrom.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="221494-a-method-of-scheduling-transmissions-in-a-wireless-communication-system-network-and-apparatus-thereof.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>221493</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>606/MUMNP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>42/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>17-Oct-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>24-Jun-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>13-Jun-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>BOREN,STEPHEN LAURENCE</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>#209-188 MILROSS AVENUE VANCOUVER BRITISH COLUMBIA V6A 4J4,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>BOREN,STEPHEN LAURENCE</td>
											<td>#209-188 MILROSS AVENUE VANCOUVER BRITISH COLUMBIA V6A 4J4,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>BRISSON, ANDRE JACQUES</td>
											<td># 701-1736 WEST, 10TH AVENUE, VANCOUVER BRITISH COULMBIA V6J2A6,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04L 9/22</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/CA2003/001538</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2003-10-06</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/299,847</td>
									<td>2002-11-20</td>
								    <td>Canada</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/221493-method-of-generating-a-stream-cipher-using-multiple-keys by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:34:50 GMT -->
</html>
