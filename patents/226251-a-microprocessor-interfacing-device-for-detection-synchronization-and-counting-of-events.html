<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/226251-a-microprocessor-interfacing-device-for-detection-synchronization-and-counting-of-events by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:19:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 226251:&quot;A MICROPROCESSOR INTERFACING DEVICE FOR DETECTION, SYNCHRONIZATION AND COUNTING OF EVENTS&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;A MICROPROCESSOR INTERFACING DEVICE FOR DETECTION, SYNCHRONIZATION AND COUNTING OF EVENTS&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>An improved microprocessor Interfacing system for the detection, synchronization and counting of events for performance monitoring and diagnostics in digital communication comprises detecting the system events and storing such events in a register by means of event detection and storage, synchronizing the said events and adapting to count update to update the count values by means of update signal synchronization and means for event update and reading and initializing the count values by the microprocessor through an interfacing circuit processor read, wherein the system and processor clock detects, synchronize and count the system events enabling the microprocessor read interface to count event values over count update to complete read operation in a single cycle without using any wait states.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>The subject invention relates to a system for detection, synchronization and counting of the system events for performance monitoring and diagnostics in digital communication systems with the help of an improved microprocessor interface system and process thereof.<br>
The main embodiment of the invention resides in an innovative microprocessor interfacing system.<br>
In the subject invention, the system events are detected and stored in a register. The stored events are then synchronized and adapted to the count update and microprocessor read interface circuit. The respective event count value is then updated. The event count is read and initialized by a microprocessor through an interfacing circuit. Priority is given to the processor to read count values over count update to complete the read operation in a single read cycle without using any wait states. The system of the subject application is implemented in a Static Random Access Memory (SRAM ) based Field Programmable Gate Array (FPGA) with an improved hardware design and an improved performance of overall microprocessor read cycle time.<br>
The object of the subject invention is to evolve a system and method of detection, synchronization and counting of system events for performance monitoring and diagnostics in digital communication systems with the help of an improved microprocessor read interface means.<br>
The object of the subject application is also to develop a hardware prototyping to be used in off the shelf programmable logic devices such as Field Programmable Gate Arrays (FPGA) &amp; programmable logic devices (PLDs) and which can also be implemented in the Application Specific Integrated Circuit (ASIC).<br>
Specifically, the subject invention is suitable for performance monitoring and management of digital communication systems where typically events are in form of preamble of data/control frames and mostly occur once in one frame.<br>
BACKGROUND OF THE INVENTION:<br>
In digital communication system, events are often monitored for evaluating, diagnostics and improving system performance. Also, event monitoring in digital communication system is usually done to ascertain quality of performance of digital transmission. This is done to have details about the digital communication equipment's performance as such equipment usually has a transmitter and receiver. At the receiver end, the correctness or quality of the frame transmission is judged by monitoring various events in form of preamble of frame like LOF (loss of frame), AIS (Alarm indicating signal) and the like, which are usually transmitted in such digital communication system. The event monitoring thus provides options for receiver for corrective action, system diagnostics and even quality of transmission.<br>
Event monitoring and performance evaluation of digital communication system as done conventionally is by using software with aid of processor hardware. Moreover, the available mechanism are based on event counting, scheduling and running software subroutines, which takes much of processor time. This is usually done with the help of microprocessor/microcomputer based design with necessities many step process. To start with, such digital hardware raises an interrupt to the processor which in turn, read the relevant occurrence of events and accordingly places such events and counting on to memory for diagnostics. Even otherwise, a dedicated hardware like timer or counter is often required which provides useful information to processor for such diagnostics. These schemes result in loss of many system clock cycles due to generation of exact timing cycle of processor for synchronizing the operation. Also, this at times is time inefficient process leading to system throughput degradation.<br>
The U.S. Patent number 4,341,9501 teaches a method of synchronizing the READ and Count or update function of a microprocessor. This is however done at transistor level, which may be costly solution as the availability of cost-effective implementation options like Field Programmable Gate Array (FPGA) and programmable logics are more suited.<br>
Also efforts are made using prescaler event counter as disclosed in U.S.Patent No. 4,849,924, where an event prescaler is used which uses Random Access Memory (RAM). Though, the event prescaler is primarily designed for computer based system, however, such prescaler does not provide a processor interface and is based on conventional design mechanism.<br>
U.S.Patent No. 5,426,741 discloses the multiprocessor based bus events monitoring system, where a dedicated bus event processor with the aid of Field Programmable Gate Array (FPGA) for user configuration for type of events was used along with event counter banks. However, this system was found to be having much more complicated system.<br>
In U.S.Patent No. 5,089,957, the RAM and incremental block are used to design the counter values. This patent teaches the use of a interrupt access generated by the external controller to access the count values by selecting the interrupt priority signals. This patent also teaches the priority based event counting scheme or mechanism.<br>
There have been vast studies and implementations thereof about synchronization of signal of various clock domains. However, the problems of metastability in the conventional systems is persistently found.<br>
To overcome the problems associated with the conventionally available systems, the subject invention focuses on utilizing processor clock cycles for maximal use as the said method provides means of event counting, update and necessary information to microprocessor.<br>
The subject invention has successfully overcome the wastage of microprocessor's cycle time as the processor reads the requisite information from the described hardware at its ease without using the wait cycles.<br>
The subject invention also provides option for setting up a pre-defined saturation value of event counts, which can be read by the processor.<br>
The subject invention may be used in any digital communication system such as Synchronous Digital Hierarchy (SDH) Systems, Asynchronous Transfer Mode (ATM), Digital Satellite communication System, and Standard digital Communication equipment for performance monitoring. Also, the present invention may be widely used in fabricating test equipment such as logic analyzer, and the like. More over, such equipment will be cost-effective, efficient and robust in hardware fabrication. They will be easily implemented in hardware while designs are at design prototyping and debugging level. Such an implementation may be embedded as design module core of digital hardware in form of Application Specific Integrated Circuit (ASIC). The scheme may be even implemented in Static Random Access Memory (SRAM) based Field Programmable Gate Array (FPGA) /programmable logic.<br>
The present invention deals with detection, synchronization, counting of system events and a microprocessor read interface to event count values, which may occur in any digital communication system. Such event detection and counting is used in performance monitoring, diagnostics. Each event has a count value, which is stored in a memory/RAM. Every event occurrence is counted. The count values are incremented or updated periodically by an<br>
update signal. The system gives priority to processor to read count values over count update. This allows processor to read an event count in a single read cycle without adding wait states. A count value once read by processor is initialized to zero. Also if a count value reaches to a predefined saturated value, a saturation flag is set which may be used to interrupt the microprocessor. The count value remains at its saturation value till the processor reads it.<br>
The system has three major blocks, (a) Event detection and storage, (b) Update signal synchronization and (c) Event update and processor read. The system uses both system and processor clock to perform these functions.<br>
Events are detected in an event detection register. When a periodic update signal arrives, the events are loaded and stored in event storage register and event detection register is cleared. Thus, event detection register gets ready to detect new sets of events. Also at the same time of clearing event detection register, if an event has occurred, it is detected and processed in the next update cycle. The above operation of event detection and storage is done using system clock.<br>
The updated signal is synchronized with processor clock and update enable and load enable signals are generated using processor clock.<br>
The event count update is done using processor clock. Events are loaded to a shift register using load enable signal thus adapting to the microprocessor clock. Then events are shifted out from Most Significant Bit(MSB) to Least Significant Bit (LSB). The LSB of the shift register is used as increment enable signal to increment the respective event count value. At the same time, event address is generated using a counter, which addresses the event count locations of count memory Random Access Memory (RAM). The output of the count memory Random Access Memory (RAM) is fed to an increment block. If the increment enable is high, the event count value is incremented<br>
and written back to the count memory Random Access Memory (RAM). Hence, only those count values will be incremented for which an event has occurred in a pre-defined sequence. Other count values, for which no event has occurred, remains at their respective count values. If a count value reaches a pre-defined saturation value, a saturation flag is set. Once all the events are shifted out and updated, the update operation is over. If count value is already at its saturation value, it remains unaffected. If processor read cycle is initiated during count update cycle, the update process is suspended till the processor read is over and then it continues from the same point where it stopped. Also, count value is initialized to zero, once it is read by the processor.<br>
The system describes an efficient and compact method of implementing detection and counting of system events and their interfacing to a microprocessor. The system uses a memory for storing count values, which optimizes area in comparison to using counters for each event in an Static Random Access Memory (SRAM) based Field Programmable Gate Array (FPGA). For example, Xilinx FPGA architecture allows implementing a 16x1 RAM in only half Configurable Logic Block (CLB). So 16 count values of 8 bits can be stored in a 16x8 RAM, which occupies 4 Configurable Logic Blocks(CLB) in an Field Programmable Gate Array (FPGA). The memory address for event count location is generated using a counter instead of a 16 to 4 address encoder. The counter takes less area than encoder in an Field Programmable Gate Array (FPGA). The system uses tri-state buffers to select event count address or microprocessor address bus to access the count memory RAM. The system uses two sets of registers, one for event detection and another for storing the events. This ensures that events are stable in event store register while adapting the events to the microprocessor clock and no event is lost even if they occur during the update operation. The system synchronizes only one signal, i.e. update-step with processor clock and generates load enable signal to load events from event store register to event shift register using processor clock. So, instead of sensing or<br>
synchronizing processor signals to stop count update cycle, the system adapts events to the processor clock. This allows the system to update event counts using processor clock and whenever processor initiates read cycle, the count update cycle is suspended and priority is given to processor to read a count values in a single read cycle without inserting wait states. In systems implemented in an FPGA where processor clock is of the order of system clock or greater than system clock, where it is not possible to synchronize the processor control signals without using wait states, the present system described here, works efficiently and optimizes the system performance. The system described in the said invention even works for the systems where processor clock speed is less than the system clock.<br>
Accordingly, the present invention relates to an improved microprocessor interfacing system for the detection , synchronization and counting of events for performance monitoring and diagnostics in digital communication comprises a means for event detection and storage, means for update signal synchronization , means for event update and processor read, wherein the system and processor clock detects, synchronize and count the system events enabling the microprocessor read interface to count event values over count update to complete read operation in a single cycle without using any wait states.<br>
The present invention also relates to a method for detecting , synchronizing and counting of events for performance monitoring and diagnostics in digital communication comprises detecting the system events, storing such events in a register, synchronizing the said events and adapting to count update to update the count values, reading and initializing the count values by the microprocessor through an interfacing circuit, wherein priority is given to micro processor to read count values over count update to complete read operation in a single cycle without using any wait states.<br>
In an improved microprocessor interfacing system of the subject, the means for event detection and storage are the event detection and storage block comprising an event detection block, an event store block, a logic gate and an update step signal generation block, the means for update signal synchronization consists of plurality of synchronous set or reset registers. The synchronous set or reset registers are at least four in number.<br>
The means for event update and processor read consists of RAM count, N-input AND logic block, an inverter logic gate, a plurality of tri-state buffer, event shift register, clear update enable generation block, saturation flag generation block, update RAM generation and count address block.<br>
The tristate buffer used are four bit tri state buffer and eight bit tri state buffer.<br>
The process comprises detecting the system events, storing such events in a register, synchronizing the said events and adapting to count update to update the count values, reading and initializing the count values by microprocessor through an interfacing circuit, wherein priority is given to micro processor to read count values over count update to complete read operation in a single cycle without using any wait states.<br>
The count values are incremented or updated periodically by an update signal. The said count values once read by the said microprocessor is initialized to zero.<br>
The subject application may better be understood with reference to the accompanying drawings, which are for illustrative purposes. Hence, the same should not construed to restrict the scope of the invention.<br>
BRIEF DESCRIPTION OF THE ACCOMPANYING DRAWINGS<br>
Figure 1 relates to the top-level block diagram of event detection, synchronization, and update with microprocessor read interface system;<br>
Figure 2 relates to the detailed block diagram of the system showing three major blocks (1A) event detection and storage, (1B) synchronization and (1C) event update and microprocessor read interface block;<br>
Figure 3 relates to the detailed diagram of sub-blocks with their interconnectivity of event detection block and storage block;<br>
Figure 4 relates to the detailed diagram of the synchronization block;<br>
Figures 5 and 6 relates to the detailed block diagram of event update and microprocessor read interface block;<br>
Figures 7 and 8 relates to the detailed timing diagram illustrating the event detection, storage and synchronization of update step signal;<br>
Figure 9 relates to the timing diagram of a typical microprocessor read cycle;<br>
Figure 10 relates to the timing diagram of event update operation as described in the embodiment of the invention.<br>
DETAILED DESCRIPTION OF THE INVENTION<br>
In figure 1, the top level block diagram of an event detection, synchronization, counting and microprocessor read interface system (1), receives N events event pulse (2), update (3), processor address signals (4), read/write-(5), chip select signal (6), system clock (7) and processor clock (8), as input signals. The output signals of the system (1) are processor data (9) and set flag (10). The input signals which includes event pulse (2), update pulse (3), and system clock pulse (7), are generated by the digital communication system.<br>
The digital system operates with the clock signal (7). The input signals processor address (4), read/write-(5), chip select signal (6), and microprocessor clock (8) are generated by microprocessor. The microprocessor operates with the microprocessor clock signal (8). The output signals, processor data (9) and set flag (10) are read by the microprocessor. The event pulse signal (2) corresponds to N events occurred in the data communication system. The update signal (3) is a periodic signal generated by the digital communication system during each data frame cycle indicating the start of the update operation. The signal (4) is the address bus of the microprocessor, which gives the address of the count value to be read by the microprocessor. The signal (9) is the data bus of the microprocessor, which receives the count value to be read by the microprocessor. Signal (5) indicates the read/write operation initiated by the microprocessor. When signal (5) goes to logic "1", it indicates the processor read operation and when (5) is logic low or logic "0", it is the processor write operation. The signal (6) is the chip select signal used to select system (1) to access the count value i.e. when (6) goes to logic high, it shows that one of the count values has reached a predefined saturation value. The system (1) uses rising edge of the (7) &amp; (8) clock signals to implement the design.<br>
The system (1) consists of Event Detection &amp; Storage (1A), Synchronization (1B) and Event Update &amp; Microprocessor Read Interface (1C) blocks as shown in figure 2. The input signals to 1A are event pulse (2), update (3), system clock (7) and load event (14). The output signals generated by (1A) are event store (11) and update step signal (12). The input to (1B) are update step (12), processor clock (8) and update over (15) signals. The outputs generated by (1B) are update enable signal (13) and load event signal (14). The input to (1C) block is event store (11), processor clock ( 8), update enable signal (13), load event (14), processor address (4), read/write-(5) and chip select (6) signals. The output of (1C) is update over (15), processor data (9) and set flag (10) signals.<br>
The (1A) block further consists of Event Detection (1A1), Event Store (1A2), N input OR logic gate (1A3) and Update Step Signal Generation (1A4) blocks as shown in figure 3. The event pulse (2), update (3), and system clock (7) signals are input to the event detection(1A1). (16) signal is output of (1A1). When an event, say mth event has occurred, a pulse is generated on the corresponding 2(mth) bit of 2 i.e. it goes to logic high for one clock cycle of signal (7) as shown by timing diagram in figure 7. This sets the respective bit (16) (mth)of output signal (16) of (1A1) to logic high. The signal (16) is also fed to (1A3) as input and output of (1A3) is event occurred (17) signal. If any of the events is detected by (16) of (1A1), the output (17) of (1A3) goes to logic high as shown in fig 7 for a generic case of mth events. The input to (1A4) are (17), (3), (15) and (7) signals. The output signal of (1A4) is a step signal (12). When a periodic signal 3 pulse arrives, i.e., it goes to logic high for one clock cycle of 7 signal, the signal (16[mth] ) is stored to the corresponding bit 11 (mth) of 11 signal with rising edge of the clock 7 and 16(mth) is cleared to logic low. If both 2 (mth) and 3 pulses arrives simultaneously, the 16(mth) bits of 16 is set to logic high and not cleared to logic low. So, the method/design ensures that no event is lost even it comes during update operation. The output (12) of (1A4) is set to logic high with rising edge of the clock (7) signal when signals (17 ) and (3) are logic high. The signal (12) is cleared to logic low by signal (14).<br>
The block (1B) consists of four synchronous set/reset registers (1B1), (1B2), (1B3), and (1B4). The step signal (12) is synchronized to microprocessor clock signal (8) by (1B1) block as shown in fig. 4. When signal (12) is logic high, it sets signal update retime1(18) to logic high as shown in timing diagram Figure 7. The signal (18) is input to (1B2) which sets signal update retime 2 (19) of (1B2) to logic high at the next rising edge of the clock signal (8). The signal (19) is input to (1B3) which sets output signal (14) to logic high at the next rising edge of the clock signal (8). The signal (14) is input to (1B1), (1B2) and (1B4) which sets output signal (13) of (1B4) to logic high and clears the (18), (19) and (14) signals to logic low at the next rising edge of the clock<br>
signal (8). Later when update operation is over which is indicated by signal (15), the signal (13) will be reset to logic low with the rising edge of the clock.<br>
The (1C ) consists of 16X8 Count RAM (1C1), eight two input AND logic(1C2), Inverter logic gate (1C3), eight input incrementor block(1C4), four bit tri-state buffer T1(1C5), four bit tri-state buffer T1(1C6), eight bit tri-state bufferTO(1C7), Event Shift Register (1C8), Clear Update Enable Generation (1C9) Saturation Flag Generation (1C10), INIT/READ/Count Cycle Generation (1C11), Update RAM Generation(1C12) and Count Address Countered3) blocks as shown in figures 5 &amp; 6.<br>
(IC8) block is used to shift the events loaded to it and Least Significant Bit of the output is used as increment enable signal. When signal (14) pulse is generated by (1B )block, the signal (11) is loaded to (1C 8) block with rising edge of the clock (8) signal. When signal (13) is at logic high and count cycle signal (23) is at logic high, events are shifted out from Most Significant Bit to Least Significant Bit. The output is the Least Significant Bit of the shift register and is represented as inc. enb(20) signal. Also simultaneously, when signals (13), (23) are logic high, (IC13) generates the count address count address (24) for each event shifted out from (1C8).<br>
For each event, count values are stored in (1C1) RAM. Each location of (1C1) corresponds to a specific event. During count cycle, signal (23) selects the count address (24) from (IC5) and applies it to the RAM address bus signal (30) of (1C1). The (1C1) outputs the count value and places it on the count out (27) bus. The bus signal (27) is input to the increment block (1C4). If the increment enable signal (20) is logic high, the count value (27) is incremented by one. The incremented count value count incremented (29) is input to (IC2). The initialization signal (21) is logic low during count cycle and the signal (29) is passed to the data input of (1C1) as count input signal (26). To update the incremented count value, the write enable input pulse update ram(25) of<br>
(1C1) goes to logic high for one clock cycle of (8) and the count value is written to the same address location with rising edge of the clock signal(8).<br>
The signal (25) is generated by (1C12) block. During count cycle when signals (23), (13) &amp; (20) are at logic high and (27) is not at predefined saturation value, (25) is generated for one clock cycle of signal (8).<br>
The (1C11) block generates the initialization signal (21), read cycle(22), count cycle (23) signals as output. Input to (IC11) blocks are (6),(5),(4) &amp; (8) signals. Figure 8 shows a typical read cycle of a processor. The signals (4), (5), (6) and (8) are generated by the microprocessor. The processor address bus (4) is retimed and processor address retime (31) is generated. At the rising edge (S4) cycle, processor read enable signal (32) signal goes to logic high when signal (6) is logic low and (5) is at logic high. The signal (32) is retimed at the next rising edge of (S6) of the clock signal (8) and retimed read enbled signal (33) is generated. When (32) and (33) are at logic high, initialization pulse<br>
(21)	is generated. During processor read, count cycle signal (23) goes to logic<br>
low when signal (6) is low or signal (33) is at logic high. The read cycle signal<br>
(22)	goes to logic high when signal (32) is at logic high.<br>
As shown in figure 5, the signal (22) selects processor retimed address bus (31) from (1C6) and applies to the address but (30) of (1C1). The 1C1 outputs the count values and places it onto signal (27). The signal (22) selects the count value (27) from (1C7) and passes it to processor data bus (9). The processor reads the data bus at the falling edge of S6 clock cycle of (8). The initialization pulse (21) is input to (1C3) clears the output (26) of (1C2) to zero, which is the data input to (1C1). The write enable pulse (25) is generated and with rising edge of the clock (8), zero is written to the address location of (1C1). This initializes the count value once it is read by the microprocessor.<br>
During read cycle, signal (25) pulse for (1C1) is generated by (1C12) when signal (22) and (21) are logic high.<br>
During count update, the (1C10) block sets the saturation flag (10) to logic high when signal (26) is at its saturation value and (25) is logic high. During read cycle when signal (22) goes high, signal (10) is cleared to logic low.<br>
When all the events are shifted out from (1C8), the signal (24) reaches its maximum count value and signal (13),(23) are logic high, (1C9) generated update over(15) signal. This indicates that update operation for the current data frame is over.<br>
In the preferred embodiment of the subject application, for N=16 event pulses signal 2 [2(15),2(14),..2(1),2(0)J represent 16 different events occurring in the system. The bit 2(0) of signal 2 is the Least Significant Bit and bit 2(15) is the Most Significant Bit. For example, during a data frame, for example 2nd , 5th, 9th and 14th events have occurred at different instances. This sets the signal 16 to "0100001000100100" or 4224(Hex) value. When the periodic update signal (3) pulse arrives, the value of signal (16) is loaded to (1A2) with rising edge of the clock signal (7) as shown in timing diagram figure 9. At the same rising edge of the clock (7), signal (3) clears the signal (16), i.e. all the bits of signal (16) are initialized to zero and sets the signal (12) to logic high value. Then signal (12) is synchronized with clock (8) and signal (14) pulse is generated. At the next rising edge of the clock, signal (14) loads the events stored as signal (11) to a shift register (1C8) as signal (34) and sets the signal (13) to logic high as shown in timing diagram figure 10.<br>
The signals (13), (23) control the shifting of events in (1C8) from MSB to LSB and up counting of the count address signal (24) in (1C13). The signal (23) selects the count address signal (24) and applies it to the RAM address bus signal (30) of (1C1) RAM block. When count address (24) is "0010" or 2(HEX), the 2nd event is shifted out to LSB, which is logic high and acts as increment enable signal (20). The (1C1) outputs the count value of the address location "0010" and places it on signal bus (27). The signal (27) is<br>
fed as input to incrementing block (1C4) and count value is incremented by one as signal (29). The incremented count value (29) is passed from (1C2) to the data input of (1C1) as signal (26). The write enable input pulse signal (25) of (1C1) goes high and the incremented count value (26) is written to the address location "0010" of (1C1) with rising edge of the clock.<br>
When the count address signal (24) is "0101' or 5(HEX), the 5th event is shifted out to the LSB of (1C8) and the count value of the 5th address location of 1C1 RAM is incremented by one and stored as explained above. When the count address (24) is "1010" or 9(HEX), the microprocessor initiates a read cycle to read the count value of address location, say "0100" or 6(HEX) of (1C1). The count cycle signal (23) goes to logic low and read cycle signal (22) goes to logic high indicating the microprocessor read is in progress. The signal (22) selects the microprocessor address bus signal (31) from (1C6) and applies it to the RAM address bus signal (30) of (1C1). The (1C1) outputs the count value to signal (27). The signal (22) selects the count value signal (27) and places it to the processor data bus signal (9). The count value on signal (9) is read by the microprocessor. Then (1C11) generates initialization pulse (21), which makes the output (26) of (1C5) to zero. The write enable pulse (25) of (1C1) is generated by (1C12) and the zero value is written to the address location "0110" to 1C1 RAM. Once read cycle is over, the count cycle becomes active and signal (23) goes to logic high. The signal (23) selects the count address (24), which is "1001" or 9(HEX) and the count value at the 9th location is incremented. The write enable input pulse (25) of 1C1 goes to logic high and the incremented count value of the address location "1001" is written to the 1C1.<br>
When count address (24) is "1110" or E (HEX), the 14th event is shifted out to LSB of (1C8) and the count value of the address location "1110" of (1C1) is incremented and written back to 1C1 as explained earlier for the other events. When count address is "1111" or F (HEX), a signal (15) is generated by (1C9) indication the end of updated process as all the events are shifted out and<br>
updated. The signal pulse (15) clears the signal (13) to logic low with rising edge of the clock (8). In the described embodiment, N=16 and Event Counter Width of 8 bits was implemented in Field Programmable Gate Array device XC4003e and the total implementation used was 61 CLBs.<br>
The subject application is a statement of invention, where various improvements, modifications and alterations are possible without deviating from the scope of the invention, hence the subject application should not be construed to restrict the scope of the application.<br><br><br><br><br><br><br>
WE CLAIM:<br>
1	An improved microprocessor interfacing system for the detection ,<br>
synchronization and counting of events for performance monitoring  and<br>
diagnostics in digital communication comprises a means for event detection<br>
and storage, means for update signal synchronization , means for event<br>
update and processor read, wherein the system and processor clock detects,<br>
synchronize and count the system events enabling the microprocessor read<br>
interface to count event values over count update to complete read operation<br>
in a single cycle without using any wait states.<br>
2	An improved microprocessor interfacing system as claimed in claim 1,<br>
wherein the said means for event detection and storage are the event<br>
detection and storage block comprising   an event detection block, an event<br>
store block, a logic gate and an update step signal generation block.<br>
3	An improved microprocessor interfacing system as claimed in claim 1,<br>
wherein the said means for update signal synchronization consists of plurality<br>
of synchronous set or reset registers.<br>
4	An improved microprocessor interfacing system as claimed in claim 3,<br>
wherein synchronous set or reset registers are at least four in number.<br>
5	An improved microprocessor interfacing system as claimed in claim 1,<br>
wherein the said means for event update and processor read consists of RAM<br>
count, input and logic block, an inverter logic gate, a plurality of tri-state<br>
buffer, event shift register, clear update enable generation block, saturation<br>
flag generation block, update RAM generation and count address block.<br>
6	An improved microprocessor interfacing system as claimed in claim 5,<br>
wherein the said tristate buffer are four bit tri state buffer.<br><br>
7	An improved microprocessor interfacing system as claimed in claim 5,<br>
wherein the said tristate buffer are eight bit tri state buffer.<br>
8	A method for detecting , synchronizing and counting of events for<br>
performance monitoring and diagnostics in digital communication as claimed<br>
in claim 1, comprises detecting the system events, storing such events in a<br>
register, synchronizing the said events and adapting to count update to<br>
update the count values,   reading  and  initializing  the  count values  by<br>
microprocessor through an interfacing circuit, wherein priority is given to micro<br>
processor to read count values over count update to complete read operation<br>
in a single cycle without using any wait states.<br>
9	A method for detecting , synchronizing and counting of events for<br>
performance monitoring and diagnostics as claimed in claim 9, wherein the<br>
said   count values are incremented or updated periodically by an update<br>
signal.<br>
10	A method for detecting , synchronizing and counting of events for<br>
performance monitoring and diagnostics in digital communication as claimed<br>
in   claim   9,   wherein   the   said   count  values   once   read   by  the   said<br>
microprocessor are initialized to zero.<br>
11	A method for detecting , synchronizing and counting of events for<br>
performance    monitoring    and    diagnostics    in    digital    communication<br>
substantially as herein before described with reference to the accompanying<br>
drawings.<br>
12	An improved microprocessor interfacing system for the detection ,<br>
synchronization and counting of events for performance monitoring and<br>
diagnostics in digital communication substantially as herein before described with reference to the accompanying drawings.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIyLWRlbC0yMDAxLWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">722-del-2001-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIyLWRlbC0yMDAxLWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">722-del-2001-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIyLWRlbC0yMDAxLWNvbXBsZXRlIHNwZWNpZmljYXRpb24gKGdyYW50ZWQpLnBkZg==" target="_blank" style="word-wrap:break-word;">722-del-2001-complete specification (granted).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIyLWRlbC0yMDAxLWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">722-del-2001-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIyLWRlbC0yMDAxLWNvcnJlc3BvbmRlbmNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">722-del-2001-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIyLWRlbC0yMDAxLWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">722-del-2001-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIyLWRlbC0yMDAxLWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">722-del-2001-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIyLWRlbC0yMDAxLWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">722-del-2001-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIyLWRlbC0yMDAxLWZvcm0tMTMucGRm" target="_blank" style="word-wrap:break-word;">722-del-2001-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIyLWRlbC0yMDAxLWZvcm0tMTkucGRm" target="_blank" style="word-wrap:break-word;">722-del-2001-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIyLWRlbC0yMDAxLWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">722-del-2001-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIyLWRlbC0yMDAxLWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">722-del-2001-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIyLWRlbC0yMDAxLWdwYS5wZGY=" target="_blank" style="word-wrap:break-word;">722-del-2001-gpa.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="226250-a-turbine-diaphragm-for-accommodating-a-rotor.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="226252-a-system-for-performing-non-targeted-analysis-on-data-collected-on-a-plurality-of-detected-components.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>226251</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>722/DEL/2001</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>04/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>23-Jan-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>15-Dec-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>28-Jun-2001</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>CENTRE FOR DEVELOPMENT OF TELEMATICS</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>9th FLOOR, AKBAR BHAVAN, CHANAKYAPURI, NEW DELHI-110 021, INDIA.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>TANAY KRISHNA</td>
											<td>CENTER FOR DEVELOPMENT OF TELEMATICS, TELECOM TECHNOLOGY CENTRE OF GOVERNMENT OF INDIA9TH FLOOR, AKBAR BHAVAN, CHANAKYAPURI, NEW DELHI 110 021, INDIA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>VISHWAJEET KAMAL</td>
											<td>CENTER FOR DEVELOPMENT OF TELEMATICS, TELECOM TECHNOLOGY CENTRE OF GOVERNMENT OF INDIA9TH FLOOR, AKBAR BHAVAN, CHANAKYAPURI, NEW DELHI 110 021, INDIA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04L 12/28</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td></td>
									<td></td>
								    <td>NA</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/226251-a-microprocessor-interfacing-device-for-detection-synchronization-and-counting-of-events by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:19:48 GMT -->
</html>
