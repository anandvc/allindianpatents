<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/206698-interleaving-apparatus-and-method-for-use-in-serial-concatenated-convoluttional-code-encoder-in-a-mobile-communication-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:55:04 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 206698:INTERLEAVING APPARATUS AND METHOD FOR USE IN SERIAL CONCATENATED CONVOLUTTIONAL CODE ENCODER IN A MOBILE COMMUNICATION SYSTEM</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">INTERLEAVING APPARATUS AND METHOD FOR USE IN SERIAL CONCATENATED CONVOLUTTIONAL CODE ENCODER IN A MOBILE COMMUNICATION SYSTEM</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>An interleaver for a serial concatenated convofutional code (SCCC) encoder is disclosed. The interleaver has a memory with m rows and n columns and the memory stores serial input symbols. The interleaver randomly selects one of the m rows, then randomly selects one of the positions in the selected row, then outputs the symbol stored in the selected position in the selected row so as to generate interleaved symbols. The SCCC encoder includes a component encoder for encoding the interleaved symbols from the interleaver. The component encoder has an effective free distance of the encoded codes. When the number of the serial input is k, the m rows and n columns in the memory are chosen such that m x n &gt; k,and m is larger than the effective free distance.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>INTERLEAVING APPARATUS AND METHOD FOR USE IN SERIAL CONCATENATED CONVOLUTIONAL CODE ENCODER IN A MOBILE<br>
COMMUNICATION SYSTEM<br>
BACKGROUND OF THE INVENTION<br>
1.	Field of the Invention<br>
The present invention relates generally to an encoding/decoding apparatus in a mobile communication system, and in particular, to an interleaving apparatus and method for an encoder using a serial concatenated convolutional code (SCCC).<br>
2.	Description of the Related Art<br>
In general, a W-CDMA (Wideband Code Division Multiple Access) or CDMA-2000 communication system requires data transmission at a low bit error rate (BER) ranging from 10-4 to 10-6, and requires a high data reliability in the situation where a signal-to-noise ratio (SNR) is relatively low in data transmission of a satellite system. To satisfy such requirements, most mobile communication systems encode and decode digital information to be transmitted over a wired or wireless link, using a parallel concatenated convolutional code (PCCC) or a turbo code for forward error correction. The use of PCCCs has improved performance as compared with existing convolutional code, and in particular, has superior performance when the SNR is low. Therefore, the PCCC has been adopted as the FEC technique for data communication in the IMT-2000 system and is the subject of active research.<br>
Performance of the PCCC is determined according to SISO (Soft-In-Soft-Out) iterative decoding at a receiver, and an encoder using the PCCC (hereinafter, referred to as a PCCC encoder) has a characteristic which is dependent on two parallel-connected component encoders and a turbo interleaver connected between them. The component encoders commonly use a recursive systematic code (RSC). The PCCC has a longer free distance dfree as compared with existing convolutional code.<br>
On the other hand, an error correction code, which is obtained by directly connecting two or more error correction codes, has been typically used in systems swhich requires a very low BER. For example, the provisional UMTS (Universal Mobile Telecommunication System) standard specifies that a serial concatenated<br><br>
-2-<br>
convolutional code (SCCC) should be used for a BER of below 10"7.<br>
FIG. 1 shows a structure of an encoding device that uses a SCCC (hereinafter, referred to as an SCCC encoder). In particular, FIG. 1 shows a 4-state SCCC encoder in which the component encoders have 4 states.<br>
Referring to FIG. 1, the SCCC encoder includes two component encoders 10 and 40, and an interleaver 30 which connects them in series. Performance of the SCCC encoder is determined depending on performance of the component encoders 10 and 40 and the characteristics of the internal interleaver 30. If the component encoders are set as in the PCCC encoder, the total dfree of the SCCC encoder will depend on the characteristics of the internal interleaver 30. As a result, the characteristics of the internal interleaver 30 will determine the whole performance of the SCCC encoder. That is, if the component encoders 10 and 40 are given, the interleaver 30 becomes the unique factor which determines the whole performance of the system.<br>
In FIG. 1, an outer encoder 10 encodes input information data U° and a multiplexer 50 converts the output of the outer encoder 10 in such a manner that two input bit streams are converted to one serial bit stream. Thereafter, a puncturer 20 receiving the output of the multiplexer 50, generates an outer code C° of rate 2/3. The generated outer code C° is provided to an inner encoder 40 as U1 through the SCCC interleaver 30. The inner encoder 40 of rate 1/2 encodes U1 to generate Cj, and a multiplexer 60 converts Cj in such a manner that two input bit streams are converted to one serial bit stream, and transmits its output to a channel.<br>
Conventionally, only the block interleaver or the PN (Pseudo Noise) interleaver was used as the interleaver of the SCCC encoder, on the assumption that the performance of the SCCC encoder has little dependence on the performance of the interleaver. That is, it was assumed that the performance would be guaranteed, if the distance and randomization of the preceding code are guaranteed for the following encoder. However, in order to optimize performance of the SCCC encoder comprised of two cascaded encoders, both the random property and the distance property should have been considered. But, such properties were conventionally overlooked. In other words, the fact was overlooked that, if the coded symbol distance was maintained while transmitting random code symbols, then consecutively generated errors could be fully corrected at the outer decoder.<br><br>
-3-<br>
Therefore, in order to optimize performance of an SCCC encoder, it is necessary to design an SCCC interleaves which satisfies both the distance property and the random property.<br>
SUMMARY OF THE INVENTION<br>
It is, therefore, an object of the present invention to provide an SCCC interleaving apparatus and method for optimizing performance of an SCCC encoder.<br>
It is another object of the present invention to provide an SCCC interleaving apparatus and method which satisfies both a distance property and a random property in a component encoder.<br>
It is further another object of the present invention to provide an SCCC interleaving apparatus and method which guarantees a low complexity while satisfying both the distance property and the random property in a component encoder.<br>
To achieve the above and other objects, there is provided an interleaver for a serial concatenated convolutional code (SCCC) encoder. The SCCC encoder includes an interleaver having a memory with m row groups and n column groups, for storing serial input symbols in the groups, randomly selecting the m row groups and randomly selecting one of the symbols stored in said each selected row group so as to generate interleaved symbols; and an encoder for encoding the interleaved symbols from the interleaver, the encoder having an effective free distance of the encoded codes. When the number of the serial input symbols is k, the memory with m row groups and n column groups includes (mxn &gt; k) groups, and m is larger than the effective free distance.<br>
BRIEF DESCRIPTION OF THE ACCOMPANYING DRAWINGS<br>
The above and other objects, features and advantages of the present invention will become more apparent from the following detailed description when taken in conjunction with the accompanying drawings in which:<br>
FIG. 1 is a diagram illustrating an SCCC encoder to which the present invention is applicable;<br><br>
-4-<br>
FIG. 2 is a diagram illustrating an SCCC interleaver according to an embodiment of the present invention;<br>
FIG. 3 is a diagram for explaining that the SCCC interleaver can be implemented by a 2-D SCCC interleaver;<br>
FIG. 4 is a flow chart illustrating operation of the 2-D SCCC interleaver according to an embodiment of the present invention;<br>
FIGS. 5A and 5B are illustrative diagrams for comparing the performance of various SCCC interleavers according to embodiments of the present invention with performance of the conventional SCCC interleaver;<br>
FIG. 6 is a diagram illustrating an SCCC decoder according to an embodiment of the present invention;<br>
FIG. 7 is a diagram illustrating a 0-augmented random address generator according to an embodiment of the present invention;<br>
FIG. 8 is a diagram illustrating an SCCC interleaver according to an embodiment of the present invention;<br>
FIGS. 9A and 9B are diagrams illustrating an SCCC interleaver according to various embodiments of the present invention; and<br>
FIG. 10 is a diagram illustrating a trellis structure of the component encoder shown in FIG. 1.<br>
DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT<br>
A preferred embodiment of the present invention will be described herein below with reference to the accompanying drawings. In the following description, well-known functions or constructions are not described in detail since they would obscure the invention in unnecessary detail.<br>
FIG. 2 shows a structure of an SCCC interleaver according to an embodiment of the present invention. This interleaver is used as an internal interleaver of the SCCC encoder. That is, the above SCCC interleaver implements the interleaver 30, shown in FIG. 1, connected between the component encoders 10 and 40.<br>
Referring to FIG. 2, a parameter setup unit 100 sets up rows and columns of a 2-dimensional array and other SCCC interleaver parameters from a given interleaver size. For example, when a PN shift register (PNSR) is used, the parameter setup unit 100 sets up an initial seed and a generator polynomial. Alternatively, when a linear recursive equation is used, the parameter setup unit<br><br>
-5-<br>
100 sets up an initial value and a prime number. The detailed setup parameters will be shown with reference to six embodiments which will be described later. An address generator 110 generates an interleaving rule or a base random address P(r,K) at each row. A row selector 120 multiplexes the respective rows (or groups). An address combiner 130 combines an output of the address generator 110 with an output of the row selector 120 to generate an address of data to be actually interleaved. An address puncturer 140 punctures an invalid address exceeding a preset interleaver size. A controller 150 controls the above elements. An address output from the address puncturer 140 is used as an address for interleaving the coded data stream output from the first component encoder 10 of FIG. 1, i.e., is used as an address for reading the stored coded data streams.<br>
Now, if the interleaver size N is determined, the parameter setup unit 100 determines rows, columns, a row selecting rule and a parameter for address generation. Next, the row selector 120 selects a row r at every clock, and the address generator 110 generates a random address P(r,K) in the selected row. The address combiner 130 combines r with P(r,K) to generate an address for actual interleaving operation. If the generated address is an invalid address, the address puncturer 140 deletes or punctures the invalid address. This process is repeated until N addresses are all generated.<br>
A description will now be made of the SCCC interleaver according to an embodiment of the present invention. First, it will be shown that the novel SCCC interleaver can be implemented by a 2-D (two-dimensional) SCCC interleaver. Next, it will be explained that the 2-D SCCC interleaver can be implemented in at least six embodiments. Thereafter, it will be shown that the novel 2-D SCCC interleaver has improved BER/FER (Bit Error Rate/Frame Error Rate) performance as compared with the conventional block interleaver or 1-D (1-dimensional) interleaver.<br>
2-D SCCC Interleaver<br>
When an input data size is given, a 2-D SCCC interleaver according to an embodiment of the present invention performs mapping as shown in FIG. 3. That is, when the size of the input data is set to N, the RowxCol 2-D array of FIG. 3 is mapped from left to right and from top to bottom. One row is selected at every clock cycle according to the row selecting rule, and addresses are generated one by one in the selected row according to a given interleaving rule. After each row is<br><br>
-6-<br>
selected once, the row selecting rule is used again to select the rows, the given interleaving rule to generate all the addresses. At this point, RowxCol &gt; N, and the number of rows is set to be larger than the effective free distance dfree of the internal encoder of the SCCC encoder.<br>
Referring to FIG. 3, in each row, the addresses are generated according to a corresponding interleaving rule, and the random addresses are generated according to P(r,k) which uses the PNSR or the linear recursive equation in the embodiment. P(r,k) is a generic Address Mapping function (at kth in r row). Here, a Kth address read from an rth row becomes P(r,k). The row selecting operation is based on a row multiplexing rule or a group multiplexing rule. According to such rules, each row is selected only once at the Row clock. Generating the random addresses for each row and selecting the rows according to the multiplexing rule is to prevent two or more invalid addresses from being consecutively punctured when RowxCol &gt; N.<br>
As stated above, the 2-D SCCC interleaver according to an embodiment of the present invention maps 1-D data of size N to a 2-D array of size RowxCol, selects one row at each clock cycle according to the row selecting rule, and generates the addresses one by one in the selected row according to the given interleaving rule.<br>
A general description will now be made of operation performed by the 2-D SCCC interleaver according to an embodiment of the present invention.<br>
In first step, the parameters corresponding to the interleaver size N, including the parameters for rows, columns, the interleaving rule P(r,k) and the types of P(r,k), are set up. This process is performed by the parameter setup unit 100 of FIG. 2.<br>
In the second step, a row is selected at every clock and the addresses are generated in the selected row using the P(r,k). This process is can be divided into row multiplexing, address generation and address combination. The row multiplexing operation is performed by the row selector 120 of FIG. 2, the address generation operation is performed by the address generator 110 and the address combination operation is performed by the address combiner 130.<br>
In the third step, it is examined whether the generated address is valid address. If it is invalid address, the address is not output. Otherwise, the address is output as a read address. This process can be called "address puncturing", and is<br><br>
- 7 -<br>
performed by the address puncturer 140 of FIG. 2. After the read address is output, the second and third steps are performed at the next clock. For reference, "address puncturing" can be classified into explicit address puncturing in which puncturing is performed after generating the address, and implicit address puncturing in which an invalid address is previously detected and deleted. With regard to a difference between the two methods, the former method uses one clock, and the latter method deletes the invalid address without using the clock. Conceptually, explicit address puncturing is identical to implicit address puncturing, but they can differ in implementation.<br>
The first, second and third steps are all controlled by the controller 150 of FIG. 2 in accordance with the procedure shown in FIG. 4.<br>
FIG. 4 is a flow chart illustrating operation performed by the 2-D SCCC interleaver according to the present invention.<br>
In FIG. 4, step 410 corresponds to the first step; steps 420, 430 and 440 correspond to the second step; and steps 450 and 460 correspond to the third step. In step 470, it is determined whether N addresses are all output. If the N addresses are not output all, k is increased by one to generate another address, in step 480.<br>
Referring to FIG. 4, the parameter setup unit 100 sets up the parameters corresponding to the given interleaver size N, i.e., the number of rows and columns, and the interleaving rule P(r,k), in step 410. The parameters can be differently set up according to the type of the interleaving rule P(r,k). The row selector 120 selects a row every clock, in step 420. The address generator 110 generates random addresses in the selected row according to the set interleaving rule P(r,k) in step 430. The address combiner 130 combines the output of the address generator 110 with the output of the row selector 120 to generate an output address, in step 440. Here, the address combiner 130 can combine the output of the row selector 120 as the high bits with the output of the address generator 110 as the low bits to generate the output address. The address puncturer 140 determines in step 450 whether the generated address is a valid address. If the generated address is a valid address, i.e., if the generated output address is smaller than the interleaver size N, the address puncturer 140 outputs the generated output address, as it is, in step 460. Thereafter, it is determined in step 470 whether N addresses are all output, by comparing the interleaver size N with the value K. If N addresses are not output all, the value K is increased by one to generate another address in step 480. Thereafter,<br><br>
-8-<br>
the procedure returns to step 420.  Steps 470 and 480 are performed by the controller 140.<br>
Otherwise, if the generated output address is an invalid address, i.e., if the generated output address is not smaller than the interleaver size N, the address puncturer 140 does not output the generated output address. That is, when the generated output address is not a valid address, steps 460 to 480 are skipped and the procedure returns to step 420.<br>
2-D SCCC Interleaver's Property<br>
The interleaver according to the preferred embodiment of the present invention is implemented by the 2-D SCCC interleaver. A description will be now made as to how the 2-D SCCC interleaver performs error correction on the data including error components generated due to noise. That is, a description will be made of the fact that the 2-D SCCC interleaver according to the preferred embodiment of the present invention can perform error correction more efficiently. Herein, for convenience, the description will be made with reference to a 4x8 interleaver having 4 rows and 8 columns. Therefore, it is assumed that puncturing the invalid address is not required. In addition, it is assumed that a correctly transmitted symbol is a zero (0) vector. Therefore, '0' indicates the normally transmitted symbol, and '1' indicates generation of a symbol error.<br>
FIG. 6 shows the structure of an SCCC decoder according to an embodiment of the present invention. The decoder is comprised of a SISO inner decoder 610, a SISO outer decoder 640, an SCCC interleaver 630 and an SCCC deinterleaver 620. Here, decoding is iteratively performed in the order of inner decoding and outer decoding.<br>
Referring to FIG. 6, A,(Ci,I) and  (C,O) at the input and output ports of the SISO inner decoder 610 indicate a unconstrained LLR (Log Likelihood Ratio) when the second parameter is I, and indicate a code-constrained LLR when the second parameter is O. In addition, the first parameter U indicates an information symbol of the encoder and the first parameter C indicates a code symbol. Further, a superscribed 'o3 indicates the outer encoder and a superscribed 'i' indicates the inner encoder.<br>
The SISO inner decoder 610 decodes a soft input received from a soft<br><br>
-9-<br>
demodulator (not shown) and extrinsic information  (Ui,I) obtained in the decoding process of the SISO outer decoder 640 to generate a new LLR for decoding of the following SISO outer decoder 640, and provides the generated new LLR to the deinterleaver 620. Here,  (Ui,I) is initially set to zero (0).  (C°,I), which is output by the deinterleaver 620, is decoded by the SISO outer decoder 640 to output  (Uo,I) and  (C°,O) which are improved LLRs.  (Uo,I) is used as an output value DECISION for deciding the information data, and  (C°,O) is provided to the SCCC interleaver 630 for continuous iterative decoding and rearranged in the original sequence.<br>
Table 1 below shows the decoding results of the SCCC inner decoder 610 of FIG. 6, wherein a place with ' 1' indicates an error correction-failed place. A preferable interleaving rule should be determined such that the data inputs should be dispersed over the dfree by interleaving the consecutively generated errors shown in Table 1 so that the following outer decoder 640 can easily correct the generated errors. This is refferring to burst errors from transmission after inner decoding.<br>
[Table 1]<br><br>
In Table 1, left to right is the direction for writing the data in an interleaving memory (now shown, but included in the interleaver 630 of FIG. 6), and top to bottom is the direction for reading the data stored in the interleaving memory. Referring to Table 1, it is noted that the data stream has consecutively generated errors of'11111', '111', and '11*. To correct the errors included in the data, the 2-D SCCC interleaver according to an embodiment of the present invention applies the interleaving rule to each row as shown in Table 2 below.<br>
Referring to Table 2, an interleaving rule of {0,5,7,6,8,4,2,1,3,9} is applied to the first row, an interleaving rule of {1,9,3,6,5,2,7,4,0,8} to the second row, an interleaving rule of {7,6,0,5,2,9,4,1,8,3} to third row, and an interleaving rule of {4,8,1,5,7,0,6,3,9,2} to the fourth row. The numeral in each column or position within a row of Table 2 indicates the sequence of the data to be read from that row. For example, the first read data in the first row is data position '0' in the first<br><br>
- 10-<br>
column, and second read data in that row is data position ' 1' in the eighth column. One data position is read from one row at one clock cycle, and one data position is read from the next at the next clock cycle. Since each row is selected once every clock cycle, data is sequentially read in an actually given row every 4 clocks.<br>
[Table 2]<br><br>
In addition, the 2-D SCCC interleaver according to an embodiment of the present invention applies a row (or group) multiplexing (or selecting) rule. It is assumed that the row selecting rule is a bit reversal row multiplexing rule={0,2,l,3}. Here, the "bit reversal row multiplexing rule" refers to reversing a binary bit value of each row and selecting the rows in the order of the resulting bit reversed value. That is, the binary value of the 4 rows has the order of {00,01,10,11} = {0,1,2,3} and the resulting order after reversing the binary values is {00,01,10,ll}={0,2,1,3}. As a result, the rows are selected in the order of {0,2,1,3}.<br>
By selecting the rows according to the above bit reversal multiplexing rule and applying the unique interleaving rules to the selected rows, the error pattern can be changed as shown in Table 3 below.<br>
[Table 3]<br><br>
In Table 3, where the above-stated interleaving rule is applied, the first 4 bits (1st to 4th columns), 0, 1, 0, 0, of the first row are obtained by selecting the rows according to the row multiplexing rule (i.e., {0,2,1,3}) and the positions within each row according to the interleaving rule for that row<br>
(e.g. {0,5,7,6,8,4,2,1,3,9} for the first row-row 0, as shown in Table 2). It should be remembered that the values "0" and "1" in Table 1 represent data<br><br>
-11 -<br>
without errors and data with errors, respectively.<br>
Following the example of Table 3, the first row, first column or position entry in Table 3 ("0") would be from the first row (row 0, according to the row multiplexing rule) and the first position (according to the location of "0" in Table 2-the interleaving rule) of Table 1. The first row, second position or column entry in Table 3 is from the third row (row 2, according to the row multiplexing rule) and the third position (according to the location of "0" in the third row of Table 2) of Table 1. The first row, third position or column entry in Table 3 is from the second row (row 1, according to the row multiplexing rule) and the ninth position (according to the location of "0" in the second row of Table 2) of Table 1. The first row, fourth position or column entry of Table 3 is from the fourth row (row 3, according to the row multiplexing rule) and the sixth position (according to the location of "0" in the fourth row of Table 2) of Table 1. The result is the first four values of Table 3:0, 1, 0, 0.<br>
After these first four values are obtained, the row multiplexing rule {0,2,1,3} starts over again. However, in this iteration, the position of the data is determined by the location of "1" in Table 2. The next entry (first row, fifth column or position) in Table 3 ("1") is from the first row (row 0, according to the row multiplexing rule) and the eighth position (according to the location of "1" in the first row of Table 2) of Table 1. The first row, sixth position or column entry in Table 3 is from the third row (row 2, according to the row multiplexing rule) and the eighth position (according to the location of "1" in the third row of Table 2) of Table 1. The first row, seventh position or column entry in Table 3 is from the second row (row 1, according to the row multiplexing rule) and the first position (according to the location of "1" in the second row of Table 2) of Table 1. The first row, eighth position or column entry of Table 3 is from the fourth row (row 3, according to the row multiplexing rule) and the third position (according to the location of "1" in the fourth row of Table 2) of Table 1. The result is the 4 bits of 5th to 8th columns of the first row in Table 3: 1, 0, 0, 0.<br>
After these four values are obtained, the row multiplexing rule {0,2,1,3} again repeats; however, now the position of the data is determined by the location of "2" in Table 2. The ninth entry (first row, ninth column or position) in Table 3 ("1") is from the first row (row 0, according to the row multiplexing rule) and the seventh position (according to the location of "2" in the first row of Table 2) of Table 1.  The first row, tenth position or column entry in Table 3 is from the third<br><br>
- 12-<br>
row (row 2, according to the row multiplexing rule) and the fifth position (according to the location of "2" in the third row of Table 2) of Table 1. The second row, first position or column entry in Table 3 is from the second row (row 1, according to the row multiplexing rule) and the sixth position (according to the location of "2" in the second row of Table 2) of Table 1. The second row, second position or column entry of Table 3 is from the fourth row (row 3, according to the row multiplexing rule) and the tenth position (according to the location of "2" in the fourth row of Table 2) of Table 1. The result is the 4 bits of the 9th to 10lh columns of the first row and the 1st to 2nd columns of the second row in Table 3:1, 0, 0, 0.<br>
The next four values are obtained in the same manner, with the position of the data being determined by the location of "3" in Table 2. The 2nd row, 3rd position entry in Table 3 ("1") is from the first row (row 0) and the ninth position (according to the location of "3" in the first row of Table 2) of Table 1. The 2nd row, 4th position entry in Table 3 is from the third row (row 2) and the tenth position (according to the location of "3" in the third row of Table 2) of Table 1. The 2nd row, 5th position entry in Table 3 is from the second row (row 1) and the third position (according to the location of "3" in the second row of Table 2) of Table 1. The 2nd row, 6th position entry in Table 3 is from the fourth row (row 3) and the eighth position (according to the location of "3" in the fourth row of Table 2) of Table 1. The result is the 4 bits of the 3rd to 6th columns of the second row in Table 3: 1,0,0,0.<br>
Thus, the pattern repeats. The next values are determined by the location of "4" in the four rows of Table 2. The 2nd row, 7th position entry in Table 3 ("1") is from the 1st row (row 0) and the sixth position of Table 1. The 2nd row, 8th position entry in Table 3 is from the 3rd row (row 2) and the seventh position of Table 1. The 2nd row, 9th position entry in Table 3 is from the 2nd row (row 1) and the eighth position of Table 1. The 2nd row, 10th position entry in Table 3 is from the 4th row (row 3) and the eighth position of Table 1. The resulting 4 bits of 7th to 10th columns of the second row in Table 3 are 1, 0, 0, 0. The next values are determined by the location of "5" in the four rows of Table 2. The 3rd row, 1st position entry in Table 3 ("0") is from the 1st row (row 0) and the 2nd position of Table 1. The 3rd row, 2nd position entry in Table 3 is from the 3rd row (row 2) and the 4th position of Table 1. The 3rd row, 3rd position entry in Table 3 is from the 2nd row (row 1) and the 5th position of Table 1. The 3rd row, 4th position entry in Table 3 is from the 4th row (row 3) and the 4th position of Table 1. The resulting 4 bits of<br><br>
- 13-the 1st to 4th columns of the 3rd row in Table 3 are: 0, 0, 0, 1.<br>
The next values are determined by the location of "6" in the four rows of Table 2. The 3rd row, 5th position entry in Table 3 ("0") is from the 1st row (row 0) and the 4th position of Table 1. The 3rd row, 6th position entry in Table 3 is from the 3rd row (row 2) and the 2nd position of Table 1. The 3rd row, 7th position entry in Table 3 is from the 2nd row (row 1) and the 4th position of Table 1. The 3rd row, 8th position entry in Table 3 is from the 4lh row (row 3) and the 7th position of Table 1. The resulting 4 bits of the 5th to 8th columns of the third row in Table 3 is 0, 1, 0, 0. The next values are determined by the location of "7" in the four rows of Table 2. The 3rd row, 9th position entry in Table 3 ("0") is from the 1st row (row 0) and the 3rd position of Table 1. The 3rd row, 10th position entry in Table 3 is from the 3rd row (row 2) and the 1st position of Table 1. The 4th row, 1st position entry in Table 3 is from the 2nd row (row 1) and the 7th position of Table 1. The 4th row, 2nd position entry in Table 3 is from the 4th row (row 3) and the 5th position of Table 1. The resulting 4 bits of 9lh and 10th columns of the third row and 1st and 2nd columns of the fourth row in Table 3 are: 0, 1,0, 1.<br>
The next values are determined by the location of "8" in the four rows of Table 2. The 4th row, 3rd position entry in Table 3 ("0") is from the 1st row (row 0) and the 5th position of Table 1. The 4th row, 4th position entry in Table 3 is from the 3rd row (row 2) and the 9th position of Table 1. The 4"1 row, 5th position entry in Table 3 is from the 2nd row (row 1) and the 10th position of Table 1. The 4th row, 6th position entry in Table 3 is from the 4th row (row 3) and the 2nd position of Table 1. The resulting 4 bits of the 3rd to 6th columns of the fourth row in Table 3 are: 0, 0, 0, 0. The next values are determined by the location of "9" in the four rows of Table 2. The 4th row, 7th position entry in Table 3 ("1") is from the 1st row (row 0) and the 10th position of Table 1. The 4th row, 8th position entry in Table 3 is from the 3rd row (row 2) and the 6th position of Table 1. The 4th row, 9th position entry in Table 3 is from the 2nd row (row 1) and the 2nd position of Table 1. The 4th row, 10th position entry in Table 3 is from the 4th row (row 3) and the 9th position of Table 1. The resulting 4 bits of the 7th to 10th columns of the fourth row in Table 3 is '1000'.<br>
When the error pattern shown in Table 3 is compared with the error pattern before interleaving, shown in Table 1, the consecutively generated errors are well dispersed by the 2-D SCCC interleaver according to an embodiment of the present invention. This is in order to have the distance between the adjacent bits after interleaving be more than 4 by maintaining the number of the rows at 4. The<br><br>
- 14-<br>
dispersed errors will cause an increase in the probability that the error will be corrected at the outer decoder.<br>
In conclusion, the interleaver according to an embodiment of the present invention uses the 2-D SCCC interleaver to obtain the distance property, and generates the random addresses in each row to maintain the random property in each row.<br>
Row Multiplexing<br>
As mentioned above, the 2-D SCCC interleaver according to an embodiment of the present invention selects the rows according to the row multiplexing rule or group multiplexing rule to maintain the distance between the adjacent bits after interleaving. That is, the 2-D SCCC interleaver performs row multiplexing using the rule for maintaining a constant distance rather than sequentially selecting the rows. This row multiplexing rule can be applied to the case where the number of the rows can be expressed in terms of powers of 2 as well as the case where the number of rows cannot be expressed in terms of powers of2.<br>
1. A Case Where The Number of Rows is Power of 2<br>
When the number of the rows is 28 (which is the power of 2), the binary values of all the rows are bit reversed and then the rows are selected in the order of the bit reversed values, as shown in Table 4 below. That is, when the binary values {000,001,010,011,100,101,110,111} of the 0th to 7th rows are bit reversed, the result is {000,100,010,110,001,101,011,111}={O,4,2,6,1,5,3,7}. Therefore, the rows are selected in the order of {0,4,2,6,1,5,3,7} as shown in Table 4.<br>
[Table 4]<br><br><br>
- 15-<br><br>
2. A Case Where The Number of Rows is not Power of 2<br>
Two methods may be used in this case. The first method, when the number of the rows is not expressed in terms of powers of 2, is to use a table look up method, For example, when the number of the rows is 7, a look-up table can be implemented such that the rows should be selected in the order of {0,4,1,5,2,6,3}.<br>
The second method, when the number of the rows is not expressed in terms of powers of 2, is to use bit reversal multiplexing. In this method, the bit reversal multiplexing is performed using the minimum value out of the numbers which are both a power of 2 and are larger than or equal to the number of the When that list is generated, the non-existent rows are deleted. For example, when the number of the rows is 7, the minimum value out of the numbers, which are both a power of 2 and are larger than or equal to the number of the rows, is 8. Then bit reversal is performed, as if the number of the rows is 8, generating the row selecting order of {0,4,2,6,1,5,3,7}. Now the non-existent row of 7 is deleted from this, leaving a row selecting order of {0,4,2,6,1,5,3}, and this order is used.<br>
Selecting The Number of Rows<br>
The number of the rows selected in designing the 2-D SCCC interleaver can greatly affect the whole performance of the interleaver. In general, for the interleaver size N, as the number of the rows approximates to sqrt(N), the distance property tends to increase but the random property in each row tends to decrease. For example, when the number of the rows is set to an excessively large value, using the PN shift register for random address generation will cause a decrease in the order of the primitive polynomial. As an alternative example, if the number of the rows is set to 1 so that the random property is obtained at the expense of the distance property, it becomes equivalent to the performance of the 1-D random address generation. That is, since selecting the rows causes a trade-off between the distance property and the random property, the rows should be selected such that the properties should be properly balanced, in order to increase the whole performance of the SCCC encoder.<br>
In  addition, when the inner decoder cannot correct the errors  at the<br><br>
-16-<br>
receiver, performance of the SCCC depends on how efficiently the outer (or inner) decoder can correct the remaining errors. As described above, if there exists an error pattern in which the errors are consecutively generated, dispersing the error pattern over a proper distance will increase the probability of error correction at the outer decoder. Therefore, if the distance between two adjacent error bits becomes over the free distance dfree of the component decoder after interleaving/deinterleaving, the succeeding error bits can be mostly corrected.<br>
Therefore, as shown in FIG. 1, in a 4-state SCCC encoder, since dfree of the terminating component encoder is about 5, if 8 (=23) or 16 (=24), which are powers of 2, is selected as the number of the rows, it is possible to maintain an optimal balance between the distance property and the random property. However, if the number of the rows is increased to 32, the distance property will increase whereas the random property will decrease.<br>
FIG. 10 shows a trellis structure of the component encoders 10 and 40 of FIG. 1. In the trellis structure, the numeral outside of each parenthesis indicates an information bit and the numeral inside of the parenthesis indicates a codeword. Since the component encoder is a systematic encoder, the information bit is always identical to the 1st code. To determine the optimal number of the rows, reference will be made to the characteristics of the encoder with reference to FIGS. 1 and 10.<br>
In FIG. 1, since the outer encoder 10 commonly uses the RSC, an input for having the minimum outer code weight is an input sequence ...000|101|0000... which starts from the zero state STATE_0 and returns to the zero state. An outer code of this input is a code ...000| 1101110000... with weight 5 and this becomes an input sequence to the inner encoder 10 in the following stage. That is, the actual dfree of the inner encoder 10 is not 5 where the input with the weight 2 is input, but is a value determined when the input pattern is such that ...000|1101101|000.., where ...000|11011|000... returns to the zero state, is input to the inner encoder 10. Here, the last '01' is an error generated to ensure that ...000|11011|000... returns to the zero state. This error is generated by noise in transsission channel. A code corresponding to such an input is ...000|11|10|01|10|11|01|10|000..., and the weight of this code is 9. Therefore, the effective dfree (or effective minimum distance) between the codes in the inner encoder becomes 9. This means that the number of the rows in the interleaver should be larger than 9. That is, it is noted that when Row &gt; 9 and the bit reversal row multiplexing rule is used, the optimal number of the rows is 16, which is larger than 9 and is a power of 2.<br><br><br>
- 17-<br>
Table 5 below shows the parameters which can be determined when the SCCC interleaver size has a value between 512 and 8192 and the PN shift register<br>
is used to generate the random addresses.<br>
[Table 5]<br>
Random Address Generation and O-Address Augmentation<br>
A method using a PN shift register (PNSR) or a method using a linear recursive equation can be typically used for a method of generating the random address in each row, i.e., determining the random interleaving rule P(r,k).<br>
When the PNSR is used, for a given column value, a primitive polynomial corresponding to the column value is selected and an initial seed value is set for the PNSR. An address generated at this time uses a state of the PNSR. Otherwise, when the linear recursive equation is used, for the given column value, an initial value is set and then an address is generated by an iterative formula. A detailed description of the two embodiments will be given later. In the two embodiments, since P(r,k) does not commonly generate an '0' address, an '0' address is augmented to a given random sequence to use a 0-augmented random sequence. That is, a 0th address is necessarily selected at a predetermined time, e.g., at the first clock cycle of each row. By doing so, it is possible to access every address in each row.<br>
FIG. 7 shows a 0-augmented random address generator according to an embodiment of the present invention.<br>
Referring to FIG. 7, a zero (0) address selector (or multiplexer) 720 selects a '0' address and an output of a random address generator 710 according to a value (0/1) of a select signal. Therefore, the random address output from the multiplexer 720 includes the '0' address. In FIG. 7, the '0' address should be selected only once for each row.<br><br>
-18-<br>
1. Random Address Generation Using PNSR<br>
One or two PNSRs can be used, or the PNSR can be used as many as the number of the rows. That is, the random addresses can be generated for each row using one or two PNSRs. Alternatively, the random addresses can be generated for each row using the PNSRs provided as many as the number of the rows.<br>
Embodiment 1: one PNSR is used for interleaving all the rows<br>
In Embodiment 1, all the addresses are generated using one PNSR. An address is obtained with a state of the PNSR. In this case, after one period of the PNSR is completed, although an address generating pattern becomes identical, the absolute address is changed since the row to be selected has changed.<br>
For example, when the interleaver size is N=1024, the rows, the columns, the PNSR's size MPNSR and the row multiplexing rule can be determined as follows.<br>
Rows- 16 [0,1,2,...,15]<br>
Columns = 64<br>
MPNSR = 6 (order of the primitive polynomial)<br>
Row multiplexing rule = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15}<br>
Embodiment 2: two different PNSRs are used<br>
In Embodiment 2, a first PNSR, PNSRe, is used for the even rows (0,2,4,6,8,10,12,14,...) and is a second PNSR, PNSRo, is used for the odd rows (1,3,5,7,9,11,13,15,...). This is to improve the random property by using two PN sequences having different properties.<br>
For example, when the interleaver size is N-1024, the rows, the columns, the PNSR's sizes MPNSRe and MPNSRo, and the row multiplexing rule can be determined as follows.<br>
Rows- 16 [0,1,2,...,15]<br>
Columns = 64<br>
MPNSRe - 6 (order of the primitive polynomial of the even rows)<br>
MPNSRo - 6 (order of the primitive polynomial of the odd rows)<br><br>
-19-<br>
Row multiplexing rule = {0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15} Embodiment 3: different PNSRs are used for each row<br>
Embodiment 3 corresponds to normalized Embodiment 2, and, in this embodiment, a different PNSR is used for each row in order to improve the random property. Since every row has an independent PNSR, Embodiment 3 uses ((row number) - 1) more PNSRs as compared with Embodiment 1. Therefore, Embodiment 3 has the increased complexity as compared with Embodiment 1.<br>
2. Random Address Generation Using Linear Recursive Equation Embodiment 4<br>
In this embodiment, only one linear recursive equation is used as in Embodiment 1. A linear recursive equation such as c(j)=[c(j-l)*p]%Row can be used. At this point, Row and p are prime numbers. Here, c(j) indicates an address generated at every clock in each row, and a value of c(0) is set up in the parameter initialization process.<br>
Embodiment 5<br>
In this embodiment, two different linear recursive equations are used as in Embodiment 2. That is, one of the following two equations can be selectively used according to the even rows and the odd rows. For example, ce(j) = [c(j-l)*p]%Row can be used for the even rows, and co(j) = [c(j-l)*q]%Row can be used for the odd rows. At this point, Row, p and q are the prime numbers. As in Embodiment 4, the values of ce(0) and co(0) are set up in the parameter initialization process.<br>
Embodiment 6<br>
In this embodiment, a different linear recursive equation is used for each row in a similar manner as Embodiment 3.<br>
FIG. 8 shows a normalized scheme of the above-discussed embodiments according to the present invention.<br>
Referring to FIG.  8, the scheme is  comprised  of R random  address<br><br>
-20-<br>
generators 800-803, a row multiplexing address generator 810, a control block 830, a selector 820 for selecting one of the random address generators according to an output signal of the control bock 830, and an address combination block 840 for combining an address output from the selected random address generator with the row multiplexing address to generate an actual address of the data.<br>
In operation, the row multiplexing address generator 810 generates one row address 'r' at each clock cycle, and the control block 830 controls the selector 820 to select one of the R random address generators 801-803 using a row select control function f(r) for the row address r. The address combination block 840 combines the random address selected by the selector 820 with the row address value 'r' to output an address of the data. At this point, the address combination block 840 combines an m-bit row address as the high bits with an n-bit random address as the low bits, to generate an (m+n)-bit output address.<br>
In Embodiments 1 and 4, f(r) = constant, meaning that only one random address generator is used. An interleaver applicable to these embodiments is shown in FIG. 9A.<br>
Referring to FIG. 9A, a row multiplexing address generator 912 generates an m-bit row address 'r' at every clock. A random address generator 910 generates an n-bit random address according to a rule which is equally set for every row. The address combination block 840 combines the m-bit row address generated by the row multiplexing address generator 912 as the high bits with the n-bit random address generated by the random address generator 910 as the low bits, so as to generate an (m+n)-bit output address.<br>
In Embodiments 2 and 5, f(r) = r%2 and an interleaver applicable to these embodiments is shown in FIG. 9B. Here, 'f(r) = r%2' indicates an modulo 2 operation, i.e., for calculating the remainder obtained after dividing r by 2.<br>
Referring to FIG. 9B, a row multiplexing address generator 924 generates an m-bit row address 'r' at each clock cycle. An even-row random address generator 920 generates an n-bit random address according to a rule which is equally set for every even row. An odd-row random address generator 922 generates an n-bit random address according to a rule which is equally set for every odd row. A control block 928 performs f(r)=r%2 operation in response to generation of the row address value V by the row multiplexing address generator<br><br>
-21-<br>
924, and controls a multiplexer (or selector) 926 according to the operation results. The multiplexer 926, under the control of the control block 928, selectively outputs the random addresses generated by the even-row random address generator 920 and the odd-row random address generator 922. That is, the multiplexer 926 outputs the random address generated by the even-row random address generator 926 for the even rows, and outputs the random address generated by the odd-row random address generator 922 for the odd rows. The address combination block 840 combines the m-bit row address generated by the row multiplexing address generator 924 as the high bits with the n-bit random address selected by the multiplexer 926 as the low bits, to generate an (m+n) output address.<br>
In Embodiments 3 and 6, f(r) = r and an interleaver applicable to these embodiments is shown in FIG. 9C.<br>
Referring to FIG. 9C, a row multiplexing address generator 940 generates an m-bit row address V at each clock cycle. A plurality of random address generators 930-933 each generate an n-bit random address according to a rule which is uniquely set for each row. For example, the random address generator 930 generates an n-bit random address according to a rule set for a 0th row, the random address generator 931 generates an n-bit random address according to a rule set for a 1st row, the random address generator 932 generates an n-bit random address according to a rule set for a 2nd row, and the random address generator 933 generates an n-bit random address according to a rule set for an (R-l)th row. A multiplexer 950 selects, when R rows are sequentially selected, a random address generator corresponding to the selected row, so that an n-bit random address generated by the corresponding random address generator should be provided to the address combination block 840. The address combination block 840 combines the m-bit row address generated by the row multiplexing address generator 940 as the high bits with the n-bit random address selected by the multiplexer 950 as the low bits, to generate an (m+n) output address.<br>
Therefore, it is possible to implement various types of the interleaver by properly determining the row selecting control function f(r).<br>
In the above described embodiments, although the address generation methods are different for each row, the basic concepts are equal. That is, the distance property is increased by row multiplexing of the 2-D SCCC interleaver, and the addresses are randomly generated in each row to maintain the random<br><br>
-22-<br>
property. Tables 7A to 9B below show the addresses generated according to the above embodiments, by way of example. In describing address generation, it will be assumed that row multiplexing is performed in the order of {0,2,1,3}.<br>
Embodiment 1 and Embodiment 4<br>
It will be assumed that RowxCol = 4x8 and P(r,k) address = {3,7,6,1,4,2,5}. First, the data in the first row is read as shown in Table 7A . Table 7A and 7B is shown, if bit reversal for each row is effected. Therefore, original row is processed by 0-&gt;2-&gt;l-&gt;3 as shown in the first row of Tables. That is, '0' address is accessed in each row. Next, the addresses are accessed as shown in Table 7B. In Table 7B, the outside numeral of each parenthesis indicates a relative address in each row, and the inside numeral of the parenthesis indicates the access order. Therefore, Tables 7A and 7B below can be regarded as a time index.<br>
[Table 7A]<br><br>
As described above, in Embodiment 1 and Embodiment 4, the same random address generating rule is applied to every row. Referring to Table 7B, the address generating rule {3,7,6,1,4,2,5} is sequentially applied to every row. For the address access order of 0-&gt;1-&gt;2-&gt;3, the first address '0' is selected in each row. That is, '0' in the first row is selected for the first address, '0' in the second row is selected for the second address, '0' in the third row is selected for the third address, and '0' in the fourth row is selected for the fourth address.<br>
For the address access order of 4 to 31, the above address generating rule {3,7,6,1,4,2,5} is applied. Therefore, '3' in the first row is selected for the fourth address, '7' in the second row is selected for the fifth address, '6' in the third row<br><br>
-23-<br>
is selected for the sixth address, and '1' in the fourth row is selected for the seventh address. Further, '4' in the first row is selected for the eighth address, '2' in the second row is selected for the ninth address, and '5' in the third row is selected for the tenth address. Similarly, the remaining 11th to 31st addresses are determined by sequentially selecting the rows and sequentially applying the address generating rule {3,7,6,1,4,2,5} to the selected rows.<br>
Embodiment 2 and Embodiment 5<br>
It will be assumed that RowxCol = 4x8, Pe(r,k) address = {3,7,6,1,4,2,5} and P0(r,k) address - {6,7,3,1,5,2,4}. First, the data in the first row is read as shown in Table 8A . That is, '0' address is accessed in each row. In Tables 8A and 8B, the first and second rows indicate the even rows, and the third and fourth rows indicate the odd rows. In the upper two rows, the addresses are accessed according to Pe(r,K), and in the lower two rows, the addresses are accessed according to Po(r,K). Next, the addresses are accessed as shown in Table 8B. In Tables 8A and 8B, the outside numeral of each parenthesis indicates a relative address in each row, and the inside numeral of the parenthesis indicates the address access order. Therefore, Tables 8A and 8B below can be regarded as a time index.<br><br>
As described above, in Embodiment 2 and Embodiment 5, the even-row random address generating rule is applied to the even rows and the odd-row random address generating rule is applied to the odd rows. Referring to Table 8B, since the rows are selected according to the bit reversal row selecting rule, the even-row random address generating rule {3,7,6,1,4,2,5} is applied to the first row ('0'  row)  and the second row ('1'  row),  and the odd-row random address<br><br>
-24-<br>
generating rule {6,7,3,1,5,2,4} is applied to the third row ('2' row) and the fourth row ('3' row). For the address access order of 0-&gt;1-&gt;2-&gt;3, the first address '0' is selected in each row. That is, '0' in the first row is selected for the first address, '0' in the second row is selected for the second address, '0' in the third row is selected for the third address, and '0' in the fourth row is selected for the fourth address.<br>
For the address access order of 4 to 31, the address generating rule {3,7,6,1,4,2,5} is applied to the even rows and the address generating rule {6,7,3,1,5,2,4} is applied to the odd rows. Therefore, '3' in the first row is selected for the fourth address, '7' in the second row is selected for the fifth address, '6' in the third row is selected for the sixth address, and '7' in the fourth row is selected for the seventh address. Further, '6' in the first row is selected for the eighth address, '1' in the second row is selected for the ninth address, '3' in the third row is selected for the tenth address, and '1' in the fourth row is selected for the 11th address. Similarly, the remaining 12th to 31st addresses are determined by sequentially selecting the rows and applying the address generating rule {3,7,6,1,4,2,5} or {6,7,3,1,5,2,4} to the selected rows.<br>
Embodiment 3 and Embodiment 6<br>
It will be assumed that RowxCol = 4x8, P(0,k) address = {3,7,6,1,4,2,5}, P(l,k) address = {6,7,3,1,5,2,4}, P(2,k) address = {1,7,3,6,4,5,2}, and P(3,k) address = {7,3,6,1,2,5,4}. First, the data in the first row is read as shown in Table 9A . That is, '0' address is accessed in each row. Next, the addresses are accessed as shown in Table 9B. P(r,K) exists separately in each row. In Tables 9A and 9B, the outside numeral of each parenthesis indicates a relative address in each row, and the inside numeral of the parenthesis indicates the address access order. Therefore, Tables 9A and 9B below can be regarded as a time index.<br>
[Table 9A]<br><br><br>
-25-<br><br>
As described above, in Embodiment 3 and Embodiment 6, a unique random address generating rule is applied to each row. Referring to Table 9B, for the address access order of 0-&gt;l-&gt;2-&gt;3, the first address '0' is selected in each row. That is, '0' in the first row is selected for the first address, '0' in the second row is selected for the second address, '0' in the third row is selected for the third address, and '0' in the fourth row is selected for the fourth address.<br>
For the address access order of 4 to 31, the unique address generating rules are applied to the respective rows. The random address generating rule {3,7,6,1,4,2,5} is applied to the first row, the random address generating rule {6,7,3,1,5,2,4} is applied to the second row, the random address generating rule {1,7,3,6,4,5,2} is applied to the third row, and the random address generating rule {7,3,6,1,2,5,4} is applied to the fourth row. Therefore, '3' in the first row is selected for the fourth address, '6' in the second row is selected for the fifth address, '1' in the third row is selected for the sixth address, and '7' in the fourth row is selected for the seventh address. Further, '7' in the first row is selected for the eighth address, '7' in the second row is selected for the ninth address, '7' in the third row is selected for the tenth address, and 43' in the fourth row is selected for the 11th address. Similarly, the remaining 12th to 31st addresses are determined by sequentially selecting the rows and applying the unique address generating rules to the selected rows.<br>
Performance Comparison on 2-D SCCC Interleaver<br>
A performance comparison between the novel SCCC interleaver and the conventional SCCC interleaver is shown in FIGS. 5A and 5B. The following simulation parameters are set to make a performance comparison among 5 types of the SCCC interleavers.<br>
-	Encoder : 4-state SCCC interleaver<br>
-	Information Size : 640<br>
-	Code Rate : R = 1/3 (outer code rate = 2/3, inner code rate = 1/2)<br>
-	Interleaver Size : (640 + 2) * 3/2 - 963, where '2' is the number of tail<br>
bits for zero-terminating the outer encoder, and '3/2' is a reciprocal of the<br>
outer code rate.<br><br>
-26-<br>
-	Channel: AWGN (Additive White Gaussian Noise)<br>
-	Decoder : Log MAP (Maximum A Posteriori) SISO (Soft-Input-Soft-<br>
Output) decoding algorithm<br>
-	Interleaver<br><br>
¦	Conventional : Block Interleaver<br>
¦	Conventional : 1 -D PN Interleaver<br>
¦	Embodiment 1 : 2-D PN Interleaver with 1 PNSR<br>
¦	Embodiment 2 : 2-D PN Interleaver with 2 PNSRs<br>
¦	Embodiment 3 : 2-D PN Interleaver with 16 PNSRs<br>
FIGS. 5A and 5B show BER/FER (Bit Error Rate/Frame Error Rate) performance according to the SNR (Signal-to-Noise Ratio). More specifically, FIGS. 5A and 5B show a performance comparison among the conventional block interleaver and 1-D PN interleaver and the novel 2-D SCCC interleavers according to respective embodiments of the present invention. It can be noted from FIGS. 5A and 5B that the novel 2-D SCCC interleavers according to embodiments of the present invention have highly improved BER/FER performance as compared with the block interleaver and the 1-D PN interleaver.<br>
Referring to FIG. 5A, from the viewpoint of BER, Embodiments 1 to 3 have similar performance. In particular, for the required BER performance of 10"5, the three embodiments show almost the same performance. The three embodiments all show much better BER performance as compared with the 1-D PN interleaver and the block interleaver. Referring to FIG. 5B, even from the viewpoint of the FER, the three embodiments show almost the same performance, and performances of the 1-D PN interleaver and the block interleaver are degraded about 10 and 100 times, respectively, at 1.5dB.<br>
As described above, when the SCCC is used for the error correction code, an embodiment of the present invention can design the SCCC internal interleaver having the optimal performance and low complexity. In addition, the novel interleaver has highly improved BER/FER performance as compared with the existing block interleaver and 1-D PN interleaver.<br>
While the invention has been shown and described with reference to a certain preferred embodiment thereof, it will be understood by those skilled in the art that various changes in form and details may be made therein without departing from the spirit and scope of the invention as defined by the appended claims.<br><br>
27<br>
WE CLAIM:<br>
1.	An encoding apparatus for a mobile communication system, comprising :<br>
-	a first encoder (10) for encoding input Information to output serial coded two coded<br>
symbols of symbols, said serial coded symbols having an effective free distance;<br>
-	an SCCC interleaver (Fig.2) having a memory with m rows and n columns,   said<br>
memory for storing said serial coded symbols, said Interleaver for randomly selecting<br>
one of the m rows, and for randomly selecting one of the symbols stored in said<br>
selected one of the m rows so as to generate interleaved symbols; and<br>
-	a second encoder (40) for encoding the interleaved symbols from the interleaver;<br>
wherein a number of the serial input symbols is k, the m rows and the n columns in<br>
the memory are such that m x n &gt; k, and m is larger than the effective free distance.<br>
2.	An interleaver in a serial concatenated convolutionai code (SCCC) encoder, said<br>
SCCC encoder having a first encoder for encoding input information to output a<br>
coded symbol stream, said interteaver for interleaving said coded output stream,<br>
and a second encoder for encoding the interleaved symbol stream, said interleaver<br>
comprising:<br>
a row selector for selecting rows, the number of rows being set according to a size<br>
of the Interleaver;<br>
an address generator for generating a random address of a column, the number of<br>
columns being set according to the interleaver size; and<br>
an address combiner for combining an output of the row selector with an output of<br>
the address generator to generate a resulting coded data stream as an Interleaving<br>
address.<br>
3.	The interleaver as claimed in claim 2, wherein the address generator is a PN<br>
(Pseudo Noise) shift register for generating a PN sequence for randomizing the<br>
columns of each row.<br>
4.	The interleaver as claimed in claim 2, wherein the address generator comprises;<br>
a first PN  (pseudo Noise) shift register  for  generating  a   PN  sequence for<br>
randomizing the columns of odd rows; and<br>
a second PN shift register for generating PN sequence for randomizing<br><br>
-28-the columns of even rows.<br>
5.	The interleaver as claimed in claim 2, wherein the address generator<br>
comprises:<br>
a plurality of PN (Pseudo Noise) shift registers for generating unique PN sequences with different properties to randomize the columns of each row.<br>
6.	The interleaver as claimed in claim 3, wherein the number of the columns<br>
is equal to 2n, where n is an integer.<br>
7.	The interleaver as claimed in claim 6, wherein one address is augmented to<br>
set the number of columns to 2n, where n is an integer.<br>
8.	The interleaver as claimed in claim 2, wherein the address generator uses<br>
one linear recursive equation to randomize the columns of every row.<br>
9.	The interleaver as claimed in claim 2, wherein the address generator uses a<br>
first linear recursive equation to randomize the columns of odd rows, and a second<br>
linear recursive equation to randomize the columns of even rows.<br>
10.	The interleaver as claimed in claim 2, wherein the address generator uses.<br>
11.	The interleaver as claimed in claim 8, wherein the number of the columns<br>
is set to 2n, where n is an integer.<br>
12.	The interleaver as claimed in claim 11, wherein one address is augmented<br>
to set the number of the columns to 2n, where n is an integer.<br>
13.	The interleaver as claimed in claim 2, wherein the number of the rows is<br>
set to 2n, where n is an integer.<br>
14.	The interleaver as claimed in claim 13, wherein the number of rows is 8,<br>
16, or 32.<br>
15.	The interleaver as claimed in claim 2, wherein the number of the rows is<br>
set to an integer, said integer being larger than on the effective free distance,<br>
wherein two coded symbols of the coded symbol stream of the first encoder have<br>
the effective free distance.<br><br>
-29-<br>
16.	The interleaver as claimed in claim 2, wherein the number of the rows is<br>
set to a number corresponding to 2n, where n is an integer, said number 2n being<br>
selected from integers larger than an effective free distance, wherein two coded<br>
symbols of the coded symbol stream of the first encoder have the effective free<br>
distance.<br>
17.	The interleaver as claimed in claim 2, wherein bit values representing the<br>
rows are bit reversed, and rows are selected according to order of the bit reversed<br>
values.<br>
18.	An   interleaving  method  for  an  interleaver  in   a   serial   concatenated<br>
convolutional code (SCCC) encoder, said SCCC encoder including a first encoder<br>
for encoding input information to output a coded symbol stream, said interleaver<br>
for interleaving the symbols stream, and a second encoder for encoding the<br>
interleaved symbol stream, the interleaving method comprising the steps of:<br>
selecting a row, the number of rows being set according to a size of the interleaver;<br>
generating an random address for a column, the number of columns being set according to the interleaver size; and<br>
combining the selected row with the generated random address to generate the resulting coded data stream as an interleaving address.<br>
19.	The interleaving method as claimed in claim 18, wherein the addresses of<br>
columns of every row are randomized by one PN sequence.<br>
20.	The interleaving method as claimed in claim 18, wherein addresses of<br>
columns of odd rows are randomized using a first PN sequence and addresses of<br>
columns of even rows are randomized using a second PN sequence.<br>
21.	The interleaving method as claimed in claim  18, wherein addresses of<br>
columns of each row are randomized using a unique PN sequence for each row.<br>
22.	The interleaving method as claimed in claim 19, wherein the number of<br>
the columns is set to 2n, where n is an integer.<br>
23.	The interleaving method as claimed in claim 22, wherein one address is<br>
augmented to set the number of the columns to 2n, where n is an integer.<br><br>
30-<br>
24.	The interleaving method as claimed in claim 18, wherein addresses of<br>
columns of every row are randomized using one linear recursive equation.<br>
25.	The interleaving method as claimed in claim 24, wherein the number of<br>
the columns is set to 2n, where n is an integer.<br>
26.	The interleaving method as claimed in claim 25, wherein one address is<br>
augmented to set the number of the columns to 2n, where n is an integer,<br>
27. The interleaving method as claimed in claim 18, wherein two different linear recursive equations are used: one to randomize addresses of columns of odd rows, and the other to randomize addresses of columns of even rows.<br>
28.	The interleaving method as claimed in claim 18, wherein a plurality of<br>
linear recursive equations are used to randomize the columns of every row.<br>
29.	The interleaving method as claimed in claim 18, wherein the number of<br>
the rows is set to 2n, where n is an integer.<br>
30.	The interleaving method as claimed in claim 29, wherein the number of<br>
the rows is 8, 16, or 32.<br>
31.	The interleaving method as claimed in claim 183 wherein the number of<br>
the rows is set to an integer, said integer being larger than an effective free distance,<br>
wherein two coded symbols of the coded symbol stream of the first encoder have<br>
the effective free distance.<br>
32.	The interleaving method as claimed in claim 18, wherein the number of<br>
the rows is set to a number corresponding to 2n, where n is an integer, said number<br>
2n being selected out of integers larger than an effective free distance, wherein two<br>
coded symbols of the coded symbol stream of the first encoder have the effective<br>
free distance.<br>
33.	The interleaving method as claimed in claim 18, wherein bit values<br>
representing the rows are bit reversed and the rows are selected according to an<br>
order of the bit reversed values.<br><br>
-31 -<br>
34.	An serial concatenated convolutional code (SCCC) encoder comprising:<br>
a first encoder for encoding input information of a predetermined size, and for outputting a first symbol stream two coded symbols of the first symbol stream having the effective free distance;<br>
an interleaver for writing the first symbol stream as input information of size N to specific rows and columns, and for reading from said specific rows and columns to output an interleaved symbol stream, said reading comprising selecting one row each clock cycle according to a row selecting rule, generating a column address in the selected row according to a given interleaving rule, and repeating said selecting and generating to thereby generate all the addresses; and<br>
a second encoder for encoding the interleaved symbol stream.<br>
35.	The SCCC encoder as claimed in claim 34, wherein the number of the<br>
rows is larger than the effective free distance.<br>
36.	The SCCC encoder as claimed in claim 35, wherein the number of the<br>
rows is to 2n, where n is an integer.<br>
An interleaver for a serial concatenated convofutional code (SCCC) encoder is disclosed. The interleaver has a memory with m rows and n columns and the memory stores serial input symbols. The interleaver randomly selects one of the m rows, then randomly selects one of the positions in the selected row, then outputs the symbol stored in the selected position in the selected row so as to generate interleaved symbols. The SCCC encoder includes a component encoder for encoding the interleaved symbols from the interleaver. The component encoder has an effective free distance of the encoded codes. When the number of the serial input is k, the m rows and n columns in the memory are chosen such that m x n &gt; k,and m is larger than the effective free distance.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
		<br>
		<div class="pull-left">
			<a href="206697-a-membrane-system.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="206699-a-method-for-controlling-data-flow-in-an-electronic-electricity-meter-and-an-electronic-electricity-meter-therefor.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>206698</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2001/00084/KOL</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>19/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>11-May-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>10-May-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>19-Jan-2001</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SAMSUNG ELECTRONICS CO. LTD</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>416 MAETAN-DONG, PALDAL-GU SUWON SHI, KYUNGKI-DO 442 370 KOREA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>KIM BEONG JO, SHINAN APT.</td>
											<td># 303-804, 201 MUJIGAEMAEUL KUMI DONG, PUNTANG-GU, SONGAM SHI, KYONGGI-DO 463 500 KOREA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>KIM MIN-GOO</td>
											<td>973-3, YOUNGTONG-DONG, PALDAL-GU, SUWON-SHI KYONGGI-DO 442 470, KOREA</td>
										</tr>
										<tr>
											<td>3</td>
											<td>LEE YOUNG-HWAN</td>
											<td>237-7 CHONGJA-DONG, PUNTANG-GU, SONGNAM-SHI, KYONGGI-DO 463 010, KOREA</td>
										</tr>
										<tr>
											<td>4</td>
											<td>KIM SE-HYOUNG</td>
											<td>MISUNG APT. #2-902, SONGPA 2-DONG, SONGPA-GU, SEOUL 138 172 KOREA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 11/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/KR00/00509</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-05-20</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>1999/19095</td>
									<td>1999-05-20</td>
								    <td>Republic of Korea</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/206698-interleaving-apparatus-and-method-for-use-in-serial-concatenated-convoluttional-code-encoder-in-a-mobile-communication-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:55:05 GMT -->
</html>
