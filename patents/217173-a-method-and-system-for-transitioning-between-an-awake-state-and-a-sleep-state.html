<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/217173-a-method-and-system-for-transitioning-between-an-awake-state-and-a-sleep-state by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 11:27:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 217173:&quot;A METHOD AND SYSTEM FOR TRANSITIONING BETWEEN AN AWAKE STATE AND A SLEEP STATE&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;A METHOD AND SYSTEM FOR TRANSITIONING BETWEEN AN AWAKE STATE AND A SLEEP STATE&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A system has a processor with multiple states, including an awake state and a sleep state, a memory subsystem including a memory controller and memory devices, and a second memory. The system uses software in the second memory to initialize the memory controller upon a transition from a sleep state to an awake state. The system detects a wake event trigger, and in response to the wake event trigger, executes software stored in the second memory to initialize the memory controller, and then executes software out of the first memory after the initialization.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>The present invention relates to a method and system for transitioning between an awake state and a sleep state.<br>
To implement low power "sleep" states in processor . systems, INTEL(TM) and others have proposed the Advanced Configuration and Power Interface Specification ("ACPI") ACPI defines an interface between the operating system and hardware that allows operating systems and hardware to interact, while permitting the design of operating systems and hardware to evolve independently.  The description of the SI and S2 sleep states found in the ACPI Specification,<br>
Revision I.Ob, released February 2, 1999 is reproduced in<br>
-* an Appendix to this specification.<br>
RAM subsystems can also have low power states.  In some RAM subsystems, a memory controller communicates with<br>
'the memory chips us.ing a particular protocol.  The memory<br><br>
controller is-an intelligent device that is initialized<br>
before it begins the normal operation of reading data from and writing data to the memory chips.  In the RDRAM(TM) RAM subsystem, developed by RAMBUS(TM), Inc. of Mountainview California, the memory controller includes a RAMBUS ASIC Cell ("RAC") that controls the electrical interface to the memory chips, performs multiplexing and demultiplexing functions, and converts data between a high speed proprietary serialized interface to the memory chips and the lower speed parallel interface used by the processor. The .RDRAM subsystem can be powered down to conserve power.<br>
The RDRAM subsystem must be reinitialized after being powered down.<br>
Summary of the Invention<br>
A system has a processor with multiple states, including an awake state and a sleep state, a memory subsystem including a memory controller and memory devices, and a second memory.  The system uses software in the second memory to initialize the memory controller upon a transition from a sleep state to an awake state.  The system detects a wake event trigger, and in response to the wake event trigger, executes software stored in the second memory to initialize the memory controller, and then executes software out of the first memory after the initialization.<br>
In another aspect of the invention, the memory subsystem is RAM based and stores some or all of the operating system software.  The software that initializes the memory controller is stored in the BIOS storage device. Prior to transitioning from an awake state to a sleep state, the operating system controls the preparation for<br>
the transition.	f\c^oM P^^y' ^^<br>
Brief Description of the,Drawings<br>
FIG. 1 is a block diagram of a processor system incorporating the invention.<br>
FIG. 2 is a flow chart depicting a set of state transitions performed by the system of Figure 1.<br>
FIG. 3 is a flow chart depicting a transition to and from the SI state performed by the system of Figure 1.<br>
FIG. 4 is a flow chart depicting a transition to and from the S2 state performed by the system of Figure 1.<br>
FIG. 5 is a block diagram illustrating another processor system.<br>
FIG. 6 illustrates another processor system.<br>
Detailed Description<br>
As shown in Figure 1, a processor 10 is connected to a memory controller hub 20.  The processor may be a Pentium II® class processor, other general purpose processor, or dedicated controller.  The processor may be part of a work station, desktop personal computer, portable computer, or telecommunications, video, or graphics device.  Memory controller hub 20 is connected to, and controls, main memory 30.  Memory controller hub 20 also handles graphics traffic and traffic to and from the I/O controller hub. Main memory 30 can be, for example, a RAMBUS memory system including multiple memory modules, each holding RDRAM memory chips.  The individual modules can be of a comparable size to standard dual inline memory modules.<br>
The memory controller hub 20 interacts with main memory 30 using a packetized protocol.  The memory controller acts as an interpreter between the RAM bus and processor 10 so that the processor does not need to concern itself with the details of the RAM structure or operation. Other high speed RAM technologies using a memory controller to access main memory may be used as well.<br>
Memory controller hub 20 and main memory 30 are clocked by memory clock 40.  For example, main memory may be differentially clocked at 400 MHZ using dual phase clocking to provide an effective clock rate of 800 MHZ. The processor is clocked by processor clock 50.  Also coupled to processor 10 via I/O controller hub 55 is<br>
nonvolatile memory 60.  The nonvolatile memory 60 may be ROM, EPROM, EEPROM, battery-backed RAM, and the like.  The nonvolatile memory 60 stores the BIOS (basic input/output software) and may include SMM (system management mode software).  The SMM may also reside in the main memory.<br>
The nonvolatile memory 60 stores the initialization software 70 used to initialize memory controller hub 20. Initialization software 70 may be part of the BIOS or part of the SMM software, if present.  In some applications, the initialization software may be independent of the BIOS, for example, in systems that do not have BIOS software external to processor 10.  Memory controller hub 20 includes internal registers 90 that control the address space mapping ("PAM registers").  These registers control whether the address generator looks to nonvolatile memory 60 for instructions and data or looks to main memory 30. Alternately, the PAM registers may reside in I/O controller hub 55 or in a separate well in the processor such that power is not lost when processor 10 is powered down. Connected to processor 10 is display or graphics controller 95.<br>
Processor 10 may include cache 110 to speed up memory access time.  The cache may be internal to the processor chip or package and may also be external.  I/O controller 55 contains a wake trigger state machine 100 to process wake event triggers received from outside the processor. State machine 100 can also reside in memory controller hub 20 or processor 10.  This state machine enables the processor to respond to wake events at a time before any software begins to execute.<br>
Once the system is running, the system is in an awake state, memory controller hub 20 is initialized, portions of operating system 80 are loaded into main memory 30, and the system is in normal operation.<br>
Referring to figure 2, the operating system may determine that power should be conserved and that the system should enter a sleep state.  This determination may be triggered based on an innumerable host of factors, such as a system idle time out, a request from a user, a request from a hardware device, such as a low battery or high temperature indication, or a request from an applications program.<br>
Before entering a sleep state, in step 200 the operating system prepares for the transition.  This preparation may include housekeeping tasks, cache flushing, context saving, and the like.  The operating system may also determine which devices are to be placed in a "sleep" state.  In circumstances where a system is designed to maximize power savings, the entire system may be placed in a sleep state.  In more simple designs, only the processor and the memory subsystem may be placed in a sleep state, while peripherals are left either fully powered or turned off.  The operating system also selects the desired sleep state and sets the appropriate bit or bits in a sleep state register.  For example, the ACPI specification includes the SI and S2 sleep states that provide for a low latency return to the awake state.<br>
In step 210, the processor transitions to the sleep state.  One way to accomplish this transition is to set the appropriate bits in a sleep enable register.  Either a<br>
software or hardware process then detects that this bit is set and asserts a sleep signal to the appropriate components.  Processor clock 50 is powered down.  Powering down may be accomplished by disconnecting power from the device itself, or may be accomplished by electrically disconnecting the incoming signal from the internal distribution lines internal to each chip.  For example, processor clock 50 may be left running, but the processor may electrically disconnect the incoming clock signal so the processor's internal components are not being clocked. Likewise, individual devices may be powered down with circuitry internal to the devices that prevent the flow of power to some or all of the components inside the device. In an RDRAM system, memory controller hub 20, main memory 30, and memory clock 40 are powered down.  When the main memory is power down, its contents are not lost, but the main memory devices transition to a power down state that consumes very little power.  An internal self refresh mechanism within main memory 20 keeps the memory contents when main memory is powered down.  Also, memory clock 40 transitions to a low power state.  In the low power state, physical power may or may not be removed.<br>
In step 220, a wake event trigger is detected.  This trigger signals that processor 10 should resume normal operation.  In some applications, this may be a return to full speed, full power mode.  In other applications, the system may awaken to a more drowsy state where processor 10 may not be running at full speed.  The wake event trigger may be generated by a source outside the system itself, such as a user pressing a "power on" or "resume" key, an<br>
incoming call signal from a modem or other telephony receiver, or it may be generated by a timer tied to a particular time of day or some other event such as scheduled system maintenance.<br>
In response to the detected wake event trigger, the system initializes the memory controller in step 230.  In an RDRAM system this includes initializing the RAC and the RDRAM core.  Other functions performed during initialization may be recalibration of the RAM bus drivers, synchronization of the RAM bus clock, and a general reset of the memory controller.  This initialization is not performed exclusively by the hardware, but rather involves executing initialization software 70 from nonvolatile memory 60.<br>
After memory controller hub 20 is initialized, control is passed in step 240 from the initialization software 70 to operating system 80 stored in main memory 30.  Operating system 80 now processes the wake event trigger.  This processing can include restoring the processor context, performing a quick system diagnostic, or other routine typically executed following a wake event.<br>
Figure 3 shows an embodiment implementing the SI sleep state with RDRAM.  In normal operation, setting the sleep enable bit will cause the processor to transition to the SI sleep state.  In this embodiment, however, the system management mode software is used to mediate between the sleep state and the RDRAM.  A portion of the system management mode software is stored in nonvolatile memory 60 that also stores the BIOS (the BIOS storage device).  The system management mode software, however, is inaccessible<br>
to the operating system. The operating system has no means by which it can directly jump to routines within the system management mode software.<br>
To allow for control to efficiently and cleanly shift from the operating system to the system management mode software, the processor is configured to respond to a sleep trigger with a system management interrupt (SMI).  To accomplish this, the operating system writes a bit to a register in step 300.  This register tells the hardware to generate an SMI in response to a sleep enable signal, rather than responding with a transition to a sleep state. In response to the SMI, the processor directs control to the system management mode software.  In step 310, the SMI Handler, which services the SMI, flushes the cache.  This cache flush avoids unified write backs in the L2 cache on instruction fetches.  If this step is performed, there will be no further memory writes until the processor transition from the sleep state.  Next, as shown in step 320, the SMI Handler sets the PAM registers to point to the BIOS storage device.  The PAM holds the address space mapping for the system.  Once the PAM registers are pointing to the BIOS storage device, instructions and data will be fetched from that device and not from the RDRAM.  In step 330, the SMI Handler executes a jump/branch instruction that points to an entry in the BIOS storage device.<br>
In step 340, the SMI Handler clears the bit that causes the processor to generate an SMI in response to a sleep enable.  The processor is now reconfigured to enter a sleep state in response to a sleep enable signal.  In step 350, the sleep enable bit is set for a second time.  This<br>
time, however, it is the SMI Handler that sets the bit, not the operating system.  The SMI Handler also identifies the desired sleep mode.  In this embodiment the desired sleep mode is the SI state.  The processor detects that the sleep enable bit is set and, in step 360, the system transitions to the SI sleep state.  The processor clock and RDRAM clock are powered down.  In this embodiment, the processor and RDRAM subsystem each have their own respective clocks.  In other embodiments the processor and memory subsystem can use the same clock as their respective clocks.  Once the RDRAM subsystem is powered down, it requires reinitialization.<br>
In step 370, a wake event trigger is received by the hardware signaling that the system should return to the awake state from the sleep state.  The clocks are returned to their power on state.  The processor resumes instruction fetching.  In step 380, the first instruction to be fetched is the instruction from the SMI Handler following the transition to the SI state.  In step 385, the SMI Handler then executes the instructions to initialize the RDRAM.  In step 390, the SMI Handler then sets the PAM registers to point to an entry in the RDRAM.  The SMI Handler then executes the return instruction and control transfers to the operating system.  In step 395, the operating system executes the next instruction following the instruction in which it set the sleep enable bit.  The system has returned successfully from the sleep state and normal operation continues.<br>
Figure 4 shows an embodiment using the S2 state.  The operating system desires to enter the sleep state in step<br>
410 and stores the resume address used by the BIOS in the RDRAM.  The operating system flushes the cache in Step 420, identifies the sleep state by writing the S2 state into the sleep type register, and enables the sleep state by writing the appropriate information into the sleep enable register. The processor and RDRAM clocks are powered down in step 430.  In the S2 state, the power to processor 10 is actually removed so that processor 10 is not consuming either active or leakage power.<br>
The system is in the S2 state in step 440.  A wake event trigger is detected in step 450.  Power is restored to the clocks.  A processor reset (CPURST#) is also asserted resetting the processor.  The system comes out of reset in step 460 and starts executing software at location FFFFFFFOh.  The PAM registers are configured to point to the BIOS storage device and not to shadow this space in the RDRAM.  Alternatively, a hardware state machine can respond to the wake event by changing the PAM registers to point to the BIOS storage device.  In step 470, the BIOS initializes the RDRAM.  In step 480, the BIOS redirects the PAM registers to execute software from the RDRAM.  BIOS passes control to the operating system via the resume address stored in RDRAM in step 410.  In step 490, the operating system processes the wake event interrupt.  In step 495, recovery from the sleep state is complete and normal operation in the awake state resumes.<br>
Figure 5 shows a processor and memory subsystem within the context of a larger system, such as might be found in a desktop system, portable computer, portable communications device, set top box, or video and graphics controller.<br>
Processor 510 and memory controller 520 are incorporated within the same chip.  The processor interacts with the memory 530, preferably RDRAM, via memory controller 520 through memory bus 535.  Memory controller 520 wakes and is initialized by the execution of software from BIOS storage device 540.  It may be desirable in some applications to incorporate the BIOS storage device into the same chip as processor 510 and memory controller 520.<br>
Power to the system is supplied by power source 545. In a portable system, power source 545 may be a battery. In desk top or set top devices, the power source may be a DC source drawing AC line power.  The power is distributed by power control circuitry 550.  Power control circuitry is responsive to the processor to decrease or cut off power to various parts of the system.  Power control circuitry 550 can also inform processor 510 of a low power condition.  As shown the power control circuitry interfaces with the processor in a manner independent of main bus 560.  In other embodiments, the power control circuitry may be treated as any other peripheral connected to the main bus. In a desk top system, the main bus may be a PCI bus. Connected to the main bus are display 580, high density storage 590, and peripherals 590.  In some systems that are graphics intensive, display or graphics controller 580 may have its own dedicated or high speed path to the processor. Display or graphics controller 580 may be connected to processor 10 or memory controller hub 20 through a separate bus or may be integrated with the memory controller in the processor core.  High density storage 590 will typically be<br>
a hard drive.  Peripherals 590 will vary with the particular application.<br>
Referring to Figure 6, three different configurations for a core chipset are shown.  Configuration I has the processor 610 (CPU), graphics controller 620 (GFX), and memory controller 630 (also called a memory controller hub or MCH) integrated into a single chip 640.  The I/O controller hub  650 (ICH) and video controller hub 655 (VCH) are shown as distinct chips.  The VCH may also be incorporated into chip 640.  ICH 650 controls the operation of the main bus, for example, the main bus 560 shown in figure 5.  ICH 650 has an output (NRST) that resets chip 640.  ICH 650 has a separate output (PCIRSTtf) that resets the main bus, for example, a PCI bus.  In configuration 2, processor 610, GFX 620, and MCH 630 are each in separate chips.  In configuration 3, processor 610 is in its own chip.  GFX 620 and MCH 630 are in a single chip.  In configurations 2 and 3, CPU 610 has its own reset input under control of ICH 650.<br>
In configuration 1 chip 640 and all its components are powered down in the sleep state, for example, an S2 state. In configuration 2, CPU 610 and MCH 630 are powered down. GFX 620 is left powered to maintain a display. Alternatively, GFX 620 may be powered down to conserve even more power.  In configuration 3, CPU 610, GFX 620, and MCH 630 are powered down.  Powering down the components in addition to stopping the clocks substantially reduces leakage currents.  Additionally, the interface between ICH 650 and the other components is isolated.  This interface is not a PCI interface, but a messaging protocol based<br><br>
interface.  In each configuration, the ICH is left powered. The ICH has hardware necessary to recover from the sleep state.  Reducing or eliminating leakage power in the S2 state from CPU 610, GFX 620, and MCH 630 will extend battery life in a substantial way in 0.18 micron process technologies and beyond.<br>
The disclosed embodiments are exemplary only.  Other embodiments are within the scope of the following claims.<br>
Appendix<br>
The SI and S2 sleep states of the ACPI Specification, Revision I.Ob, released February 2, 1999:<br>
9.1.1  SI Sleeping State<br>
The SI state is defined as a low wakeup latency sleeping state.  In this state no system context is lost (CPU or chip set), and the hardware is responsible for maintaining all system context, which includes the context of the CPU, caches, memory, and all chipset I/O.  Examples of SI sleeping state implementation alternatives follow.<br>
9.1.1.1	SI Sleeping State Implementation (Example 1)<br>
This example references an IA processor that supports the<br>
stop grant state through the assertion of the STPCLK#<br>
signal.  When SLP__TYPx is programmed to the SI value (the<br>
OEM chooses a value, which is then placed in the \_S1<br>
object) and the SLP_ENx bit is subsequently set, the<br>
hardware can implement an SI state by asserting the STPCLK#<br>
signal to the processor, causing it to enter the stop grant<br>
state.  In this case, the system clocks (PCI and CPU) are<br>
still running.  Any enabled wakeup event should cause the<br>
hardware to de-assert the STPCLK# signal to the processor.<br>
9.1.1.2	SI Sleeping State Implementation (Example 2)<br>
When SLP_TYPx is programmed to the Si value and the SLP_ENx bit is subsequently set, the hardware will implement an SI state by doing the following:<br>
1.	Place the processor into the stop grant state.<br>
2.	Stop the processor's input clock, placing the processor<br>
into the stop clock state.<br>
3.	Places system memory into a self-refresh or suspend-<br>
refresh state.  Refresh is maintained by the memory itself<br>
or through some other reference clock that is not stopped<br>
during the sleeping state.<br>
4.  Stop all system clocks (asserts the standby signal to<br>
the system PLL chip).  Normally the RTC will continue<br>
running.<br>
In this case, all clocks in the system have been stopped<br>
(except for the RTC's clock).  Hardware must reverse the<br>
process (restarting system clocks) upon any enabled wakeup<br>
event.<br>
9.1.2  32 Sleeping State<br>
The S2 state is defined as a low wakeup latency sleep<br>
state.  This state is similar to the SI sleeping state,<br>
except that the CPU and system cache context is lost (the<br>
OS is responsible for maintaining the caches and CPU<br>
context).  Additionally, control starts from the<br>
processor's reset vector after the wakeup event.  Before<br>
setting the SLP_EN bit, the ACPI driver will flush the<br>
system caches.  If the platform supports the WBINVD<br>
instruction (as indicated by the WBINVD and WBINVD_FLUSH<br>
flags in the FACP table) , the OS will execute the WBINVD<br>
instruction.  If the platform does not support the WBINVD<br>
instruction to flush the caches, then the ACPI driver will<br>
attempt to manually flush the caches using the FLUSH_SIZE<br>
and FLUSH_STRIDE fields in the FACP table.  The hardware is<br>
responsible for maintaining chipset and memory context.  An<br>
example of a S2 sleeping state implementation follows.<br>
9.1.2.1  S2 Sleeping State Implementation Example<br>
When SLP-TYPx is programmed to the S2 value (found in the<br>
\_S2 object) and then the SLP_EN bit is set, the hardware<br>
will implement an S2 state by doing the following:<br>
Stop system clocks (the only running clock is the RTC) .<br>
Place system memory into a self or suspend refresh state.<br>
Power off the CPU and cache subsystem.<br>
In this case, the CPU is reset upon detection of the wakeup event; however, core logic and memory maintain their context.  Execution control starts from the CPU's boot vector.  The BIOS is required to:<br>
Program the initial boot configuration of the CPU (such as the CPU's MSR and MTRR registers).<br>
Initialize the cache controller to its initial boot size and configuration.<br>
Enable the memory controller to accept memory accesses.<br>
Call the waking vector.<br><br><br><br><br><br><br>
We Claim:<br>
1.	A method for transitioning between an awake state and a sleep state<br>
in a system comprising a processor  10, a first memory 30, a first<br>
memory   controller   20,   and   a   second   memory   60,   the   method<br>
comprising:<br>
detecting a trigger to transition from the sleep state to the awake<br>
state;<br>
initializing the first memory controller in response to the detecting, the<br>
initializing comprising executing software in the second memory; and<br>
executing software in the first memory after the initializing,<br>
2.	The method as claimed in claim 1, comprising:<br>
preparing, under control of software stored in the first memory, for a transition from the awake state to the sleep state; and transitioning to the sleep state.<br>
3.	The method as claimed in claim 2 wherein the software stored in the<br>
first memory comprises operating system software.<br>
4.	The method as claimed in claim 2 wherein the first memory comprises<br>
RDRAM,<br>
5.	The method as claimed in claim 4 wherein the first memory controller<br>
resides in the same chip as the processor.<br>
6.	The method as claimed in claim 5 wherein the software in the second<br>
memory comprises BIOS software.<br>
7.	The method as claimed in claim 5 wherein the software in the second<br>
memory comprises software inaccessible by the operating system.<br><br>
8.	The method as claimed in claim 5 wherein the software in the second<br>
memory comprises system management mode software.<br>
9.	The method as claimed in claim 1 wherein the processor and memory<br>
controller  have   inputs  for  receiving   respective   clock   signals,   the<br>
method further comprising preventing the receiving of the respective<br>
clock signals prior to the detecting.<br>
10.	The method as claimed in claim 2 wherein the preparing comprises:<br>
configuring the processor to execute the software stored in the second<br>
memory in  response   to  a  sleep  trigger  signal  from  the  operating<br>
system;<br>
receiving a first sleep trigger signal from the operating system;<br>
executing the software stored in the second memory in response to the<br>
receiving;<br>
reconfiguring the processor to transition to the sleep state in response<br>
to a sleep trigger signal; and<br>
receiving a second sleep trigger signal.<br>
11.	The method as claimed in claim 10 wherein the software stored in the<br>
second memory comprises system management mode software, the<br>
method    further    comprising    generating    a    system    management<br>
interrupt in response to the receiving of the first sleep trigger.<br>
12.	The method as claimed in claim 10 wherein the initializing executes<br>
the software stored in the second memory at the instruction following<br>
the last instruction executed before transitioning to the sleep state.<br>
13.	The   method   as   claimed   in   claim   2   wherein   the   transitioning<br>
transitions the processor into an SI state.<br>
14.	The   method   as   claimed   in   claim   2   wherein   the   transitioning<br>
transitions the processor into an S2 state.<br><br>
15.	The method as claimed in claim 2 wherein the preparing comprises<br>
flushing a cache.<br>
16.	The method as claimed in claim 2 further comprising resetting the<br>
processor prior to the initializing.<br>
17.	The method as claimed in claim 1 wherein the processor and memory<br>
controller have inputs for receiving respective clock signals, and the<br>
first    memory    stores    operating    system    software,    the    method<br>
comprising:<br>
preparing,  under control  of the  operating  system  software,  for  a<br>
transition from the awake state to the  sleep state,  the preparing<br>
including  configuring the  address   space  mapping  to  point to  the<br>
second memory following the detecting;<br>
preventing the receiving of the respective clock signals by electrically<br>
disconnecting them or by powering down a clock that is a source of<br>
the clock signals;<br>
transitioning to the sleep state by setting a sleep indicator;<br>
detecting a trigger to transition from the sleep state to the awake state<br>
provided by an external source or an internal event;<br>
initializing the first memory controller in response to the detecting, the<br>
initializing comprising executing BIOS software in the second memory;<br>
executing operating system software after the initializing to process<br>
the awake state trigger.<br>
18.	The method as claimed in claim 17 comprising:<br>
storing a BIOS resume address in the first memory; and<br>
transferring control from the BIOS to the operating system following<br>
the initializing using the resume address stored in the first memory.<br>
19.	The method as claimed in claim  18 comprising powering down the<br>
first memory controller prior to the detecting.<br><br>
20.	A system(comprising:<br>
a processor (10) having an awake state and a sleep state;<br>
a first memory (30);<br>
a first memory controller (20);<br>
a second memory (60); and<br>
software stored in the second memory that executes to initialize the<br>
first memory controller responsive  to  a trigger  signal  signaling a<br>
transition from the sleep state to the awake state.<br>
21.	The system as claimed in claim 20 wherein:<br>
the first memory stores operating system software;<br>
the second memory is nonvolatile memory;<br>
the second memory stores BIOS software; and<br>
the operating system software is configured to control a transition<br>
from the awake state to the sleep state.<br>
•4*<br>
22.	The system as claimed in claim 21 wherein:<br>
the  operating  system  stores  a BIOS  resume  address  in  the  first<br>
memory prior to a  transition from the awake state to the sleep state;<br>
and<br>
the BIOS software returns control to the operating system using the<br>
stored BIOS resume address after the memory controller is initialized.<br>
23.	The   system   as   claimed   in   claim   21   wherein   the   first   memory<br>
comprises RDRAM.<br>
24.	The   system  as  claimed  in  claim  21   wherein  the   second  memory<br>
comprises RAM.<br>
25.	The system as claimed in claim 21 comprising system management<br>
mode    software,    the    system   management   mode    software   being<br>
inaccessible   by   the   operating   system,   and   wherein   the   system<br>
management mode software initializes the first memory.<br><br>
26.	The  system as  claimed  in  claim  20 wherein  the  processor,  first<br>
memory, and first memory controller have clock inputs, the system<br>
comprising clock disable circuitry preventing the internal clocking of<br>
the processor, first memory, and first memory controller.<br>
27.	The system as claimed in claim 20 wherein the processor and first<br>
memory controller reside within a common chip.<br>
28.	The system as claimed in claim 20 further comprising cache residing<br>
in the same chip as the processor and first memory controller and<br>
wherein the operating system is configured to flush the cache prior to<br>
the transition from the awake state to the sleep state.<br>
29.	The system as claimed in claim 20 in which the system is portable<br>
and comprises:<br>
a power storage medium;<br>
a display; and<br>
a processor clock;<br>
wherein the processor and first memory controller are not clocked in<br>
the sleep state;<br>
30.	The system as claimed in claim 29 comprising circuitry to disable the<br>
flow of power internal to the processor, first memory controller, and<br>
first memory.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1jb3JyZXNwb25kZW5jZS1vdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1jb3JyZXNwb25kZW5jZS1wby5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1mb3JtLTEucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1mb3JtLTE5LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1mb3JtLTIucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1mb3JtLTMucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1mb3JtLTQucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-form-4.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1mb3JtLTUucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1ncGEucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1wY3QtMTAxLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-pct-101.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1wY3QtMzA0LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-pct-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1wY3QtNDAxLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-pct-401.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1wY3QtNDA5LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-pct-409.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItNDY4LWRlbC1wY3QtNDE2LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-468-del-pct-416.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="217172-apparatus-and-method-of-forming-materials.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="217174-method-of-synthesis-of-a-substituted-or-unsubstituted-carbinol-compound.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>217173</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2002/00468/DEL</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>15/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>11-Apr-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>26-Mar-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>03-May-2002</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTEL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2200 MISSION COLLEGE BOULEVARD,SANTA CLARA,CALIFORNIA 95052,U.S.A.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>SATCHIT JAIN</td>
											<td>558 CRIMSONBERRY WAY,SAN JOSE,CALIFORNIA 95129,U.S.A.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>SUNG-SOO CHO</td>
											<td>1521 JASPER DRIVE,SUNNYVALE,CALIFORNIA 94087,USA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 1/32</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US00/41489</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-10-23</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/434,973</td>
									<td>1999-11-05</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/217173-a-method-and-system-for-transitioning-between-an-awake-state-and-a-sleep-state by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 11:27:43 GMT -->
</html>
