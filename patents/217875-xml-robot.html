<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/217875-xml-robot by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:13:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 217875:&quot;XML-ROBOT&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;XML-ROBOT&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>the invention relates to a metkod, system and apparatus for tke direct execustion of XML-documents by means of decoration of a XML-document, a document type definition (DTD), or their representation as structure tree, respeetively, with textual or graphical flow charts. The structure of the XML-document&#x27;s data is reused for and integrated with the code processing the same.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>XML-ROBOT<br>
Field and Background of the Invention<br>
The invention relates to a method, a system and apparatus forthe direct execution of XML documents according to claims 1 and 7-9.<br>
XML-basics<br>
XML has been defined as a subset of the SGMLformat In short, XML allows to define the format of documents structured by means of so-called tags. While XML defines both a physical and a logical structure of documents., in context of the present .invention the focus is set on the logical structure, however, reusing the provided means for physical structure. Abstracting from the physical structure, XML is used for giving both the docu-menttype definition (DTD) and XML-documents. A specific DTD 7"is used to classify XML-documents in those which are valid with respect to land those which are not. For short one says documents of DTD T, for those valid with respect to T. The logical aspects of a DTD define elements and attributes. Each document of such a type (given by means of a DTD), must contain only instances of the defined elements, and theattributes and composition of the elements must match the DTD. As an example a DTD T defining an element A, with a composition of subordinated elements X, Y, and Z and attributes b and c of element A might be noted in XML as follows:<br>
(Formula Removed)<br>
where #'PCDAIA is definingthe kind of data admissible for attributes b and c.Adocument of the above shown DTD T may now contain instances of element A. An instance of the element A consists of the start-tag <a...> and an end-tag . Within the start-tag, the values of the attributes are given, and between the start and the end tag, instances of the composing elements must be given. A document of type T may thus contain instances of A looking as follows:<br>
(Formula Removed)<br>
where the exact shape of X, Y, and Z instances is given by corresponding element definitions in the DTD T.<br>
The power of XMLsteamspartlyfromthefactthatthe definition of element composition is allowed to be recursive. For illustration some composition possibilities are introduced and used to complete the above example. The already used sequence (X, Y, Z) indicates that a X element is followed by a Y element, which in turn is followed.by a Z element, as shown in the above example. Another important composition operator is the choice (X |<br>
Y j Z) indicating a choice between an X, Y, or Z element. Other operators would be the + and * operators, indicating repetitions of a component However, they are not used in the examples.<br>
Assumingthat Y and Z have no composition (<lelementy>, <ielentz>) the DTD A is completed with definition ofX, where the choice composition and recursion to element A is used: . Thus X is either a Y or an A. Possible documents of type A are now:<br>
(Formula Removed)<br>
and arbitrary further repetitions of <yx>. For simplicity no spdifiatomposilon opera-tors like + and * were used for repetitions above. As a shortcut <y></y> can be replaced by <y></y>.<br>
XML is the outcome of a long standardization process and is widely used and accepted. Existing applications according to the prior art may be categorized in two different basic types: data exchange and document publishing. For data exchange applications XML can be used to define data formats for exchanging complex data between two programs. Furthermore XML is used as an exchange format for data residiwgln relational database systems. Examples for such formats are XML-data (Microsoft), MCF (Netscape), and RDF<br>
(W3C). For document publishing applications XML is the ideal data language for markup of all kind of documents. The main idea is to give the logical content of the document as an XML-document, and to give the layout information genericallyforthe DTDs. Examples for such generic layout languages are CSS or XSL. The output of the generated layout may be HTTP, SPDL, or Postscript, respectively.<br>
XML processing<br>
Currently existing software and applications are using XMLforthe representation of data and documents, which are then processed by general purpose programming languages. Existing proposals forthe processing of XML-documents can beseparated in event-driven and tree-manipulatingtechniques, independently whethertheapplieationliesin the data-exchange or document-publishing domain. In an event-driven approach, the document is processed in strict sequence. Each element in the data stream is considered an event trigger, which may precipitate some special action on the part of the application. The SAX application programmer interface (API) can be used to implement an event-driven approach in an existing programming language. The tree approach provides access to the entire document in form of a structure tree. Basically the elements of a XML-document are the nodes of the tree, and the components of each element are the siblings of the node. The commonly used API to access such a tree is DOM. The disadvantage of using APIs is, that all complexity of general purpose programming, particularly system and platform dependencies, reliability and security causing extensive and complex software, comes into play. Several XML tools try to hide this complexity by generating special code for data<br>
exchangeordocumentpublishingapplications. Although they mayhelpto easily generate a program pattern in a traditional programming language, they do not abstract com-pletelyfrom using explicit programmtag to navigate th rough the document that has to be processed.<br>
XML versus traditional programming<br>
An important issue relates to the concept of traditional structured as well as object oriented programing methods. Both methods use unstructured data sources, in the sense that the structure of such data is not given by means of production rules, like the element definitions in XML or BNF rules defining the structure of programs. Such data sources are, in the case of traditional programming, used in connection with a structured, however independent, program.On the other hand, object oriented programming methods combines the structured segmented code with data objects, but still the object space (data) is not structured in the above-mentioned sense. It would, of couurse be passible to use structured data models in connection with these methods but in either case the program structure is independent of the data structure and therefore needs complex treatment as described above. Infact.thecurrentsituation in pracessingXML-documents implies two independent structures, one of the XML-document and one of the program processing it This approach suffers particularly two fundamental disadvantages: (a) If a programmer intends to reliably process the complete structure of any instance of a DTD, such code mayfail duetothe variety of corresponding XML-documents and the complexity of such tasks and (b)the program processingthe XML-document is typically designed<br>
o process all documents of a certain DTD.thusthe complexity of the program is increased by the inherent generic nature of the code.<br>
Objects of the invention<br>
It is an object of the invention to create a method, system and apparatus to improve the processing of XML-documents in such manners that data and software are incorporated in an integrated structure and thus reducing or avoiding the complexity and/or need of fundamental programming knowledge in data processing and to reuse the existing structure of the XML-document.<br>
Another object of the invention is to provide a new and general method, system and apparatus to generate such integrated data and software structures for XML-documents. Yet another object of the invention isto provide a novel method,system and apparatusto directly execute standard document structures, i.e., XML-documents.<br>
Summary of the invention<br>
These objects are solved by the invention as specified in the claims 1 and 7-9.<br>
The inventive idea is based on a new method/system that uses executable software and data in a coordinated and integrated structure. The current invention may be considered as an application, but does not fall in either of the categories mentioned above, i.e. data<br>
exchange applications or document publishing applications. In contrast to such existing applications, this invention provides a method and apparatus to directly execute (or otherwise process) an XML-document.<br>
The present invention reuses the existing structure of the XML-document while avoiding a new structure and concept for the program that should process said document. Accordingly the inventive approach defines one program for each document (in contrast to one for each DTD) and thus the process complexity is clearly reduced.<br>
Such ability of direct execution of XML-documents is achieved by means of decorating a given XML-document and/or its documenttype definitions (DTD) with executable instructions that define the local behavior and process for each tag or at each node, respectively.<br>
This is achieved by incorporating the program instructions into textual form and/or graphical charts specifying sequential or concurrent control and data flow. Specifically, this is done in such mannerthatthe instantiation of instructions of a XML-robot is applied to a specific XML-document, resulting in an executable XML-document containing the complete execution behavior of said XML-document.<br>
A preferred embodiment of the invention uses a unique and general DTD specifying the module structure to be used for modules of the XML-robot A specific XML-document may be processed by applying procedures and specifications given in such XML-robot to the XML-document Thus, the modules are incorporated into the structure of said XML-<br>
document in such manner that the execution of the XML-document is performed directly. The execution relies on a few functions (primitives) that define how to access and how to alter a given XML-document Furthermore a specific and unique flow chart completely defines said execution process of the XML-document. These basic inventive definitions are<br>
complete, In the sense, thatthe given examples of XML-robots leadto the direct execution according to the invention.<br>
Another preferred embodiment of the invention provides the full information for each kind of elements of a given XML-document by means of a graphicalflow chart (GFC). This GFC defines the control flow through the elements and components, respectively, and which actions are executed during that control flow. Data flow is provided by actions executed when certain states of the GFC are reached. Examples of GFC are flow charts, Finite State Machines, State Charts, UMLState Machines, all kind of Petri Nets, UML action diagrams and other kinds of computational models. By presentingthe XML-document as a structure tree, this embodiment can be defined and explained in a pure graphical way, allowing for an advanced visual integrated developmentenvironmentforXML-robots. On the other hand for sequential GFC models (flow charts, Finite State Machines) executing actions on states, this graphical embodiment can be directly mapped into an embodiment using a textual form. In addition the embodiment using a textual representation could be generalized to a model allowing for concurrence (i.e. allowing parallel execution of multiple actions) and actions on arrows (i.e. actions on transitions of finite state machines), such that all variations this embodiment could be mapped into the embodiment using graphical flow charts.<br>
Both embodiments are characterized by a modular structure, where each module defines the execution behavior for a II elements of a specific tag, e.g. <a...>, while adding execution behavior for components of such elements, and furthermore adding execution behavior for all instances of elements with other tags, e.g. <b...>. All information in a module, whether textual or graphical is relative to an instance of the described kind of elements (<a...>), called the self element. In both embodiments, primitives are provided to call external functions, navigate through the structure of the document/tree, ranging over all instances of a certain kind of elements (<a...>), and defining additional attributes of the document/tree, whose definition is given in a pure functional style. If there exists a DTD forthe XML-document to be executed, this DTD provides explicitly the information which element kinds exist, and which components are present for those kinds. Thus such a DTD provides structure and guidance, for writing an XML-robot specification. Although both embodiments work without an explicit DTD, a DTD is used for the definitions and specification of the first embodiment described below. Furthermore, it has to be noted that a simple DTD can be derived from an XML-document without DTD.<br>
In the preferred embodiments intermediate results are stored by dynamically creatin'gand redefining attributes of the elements in the document/nodes of the structure-tree. Other, event based and pure functional/declarative models are possible as well. However, the dynamic process information is preferably given by the existing document/tree structure. Itisimportanttounderstandthat in contrastto existing processing models,the document or the structure tree of the XML-document is used directly as the basis for a GFC (or a corresponding textual form) being the definition of the execution behavior of the XML-<br>
document. Thus, such an XML-robot is a basic new way of applying XML-technique and processing XML-documents.<br>
Since the invention is not restricted to specific platforms or concrete implementations of the process, e.g. of existing API's such as SAX and DOM, the specification given here has to be abstracted from such concrete forms. Nevertheless, the primitives used are defined such that one could implement them. Furthermore the invention is not restricted to specific programming languages implementing the flow chart or other structural implementations, such as whether intermediate forms/results are generated, or whether the XML-document is executed by means of compiler and interpreter, respectively, or their combination.<br>
In accordance with the present invention there is disclosed, a computer system with at least two apparatuses, particularly Internet appliances, comprising a server providing services to at least one client by executing at least parts of a XML-document according to XML-robot specification sent from the client to the server or a server providing services to at least one client by sending a XML-robot specification and a XML-document to the client, such that said service is provided by execution of at least part of the sent document on the client according to the sent XML-robot specification.<br>
Brief description of embodiments with reference to the following drawings<br>
Fig.1 shows an Example for a DTD named ,,query"<br>
Fig.2 shows an XML-document valid with respect to the example DTD according to<br>
figure 1 Fig.3 shows the tree structure of the XML-document in Fig.2 as implied by the DTD<br>
,.query" as given in figure 1 Fig.4 shows a graphical specification and its corresponding instantiation of the DTD<br>
according to figure 1 Fig.5 shows a specification module, encapsulating the information on the left side of<br>
figure 4 for the element definition "query"<br>
Fig. 6	showsthe specification modulesforthe element's"setpoints" and "action".<br>
Fig. 7	shows how the local GFC's of each element definition are instanciated for<br>
each instance of such an element in the structure tree.<br>
Fig. 8	shows how the instances of the local GFC's are connected to a global,<br>
hierarchical GFC<br>
Fig. 9	shows the unique DTD defining the module structures<br>
Fig. 10-15	shows the flow charts defining the execution of a given XML-document<br>
using modules valid with respect to the DTD XML-robotdtd<br>
Fig. 16-18	show the textual representation of modules of the example according to<br>
figure Iff.<br>
Fig.-19a-19d    show examples on how to implement a specific XML-Robot specification<br>
Fig. 20	shows an overview over an embodiment for a web-beased XML-robot De-<br>
scription of the preferred embodiment<br>
Preferred embodiments of the invention are hereinafter described with reference to the drawings.<br>
The invention realizes the direct execution of an XML-document The following embodiments describe a graphical and a textual realization of the method, system andapparatus. Even though the subsequent examples relate to XML-documents ofa given and known DTD, it has to be understood that the invention, taking into consideraton certain disadvantages such as undefined results, allows the execution of XML-document without pre-known DTDs. In any case the DTD (if pre-known) or the XML-document are incorporated<br>
directlywiththeXML-robotspecificatIon(„decoration"of theDTDorXML-document).The Invention is, as described above, basically independentfrom the concrete implementation (platform,program languages,structuralforms such as storingand processing). However, where applicable, preferred embodiments using a specific implementation are described below.<br>
With reference to figures 1 to 8 a first graphical embodiment of the invention is described.<br>
Figure 1 shows a sample DTD with an element query having three components, two of type action and an optional component of type query. The attribute list of the element query consists of the single attribute question, being a required character data attribute. The element action is composed by either of the elements setpoints or query. The element setpoints has no components and the single attribute points.<br>
Figure 2 represents a valid document with respect to the sample DTD of figure 1 while referring to the DTD „query.dtd" as given in figure I This instance is used as a sample documentfor the further description below.<br>
Figure 3 shows a corresponding possible mapping of the document in figure 2 to an attributed structure tree (AST). Such an AST is an alternative graphical representation of the structure of an XML document. The nodes numbered 1 and 3 are instances of the element query. They have the two required action siblings accessible as S1-act!on and S2-action, and the optional query sibling is not present. If a query sibling would be present,<br>
itwould be accessible as S-query. Nodes 2,4, and 5 are instances of the element setpoints that do not have siblings. Attributes and their values are visualized within the boxes.<br>
Figure 4 shows the relation of.the execution specification for a DTD and how instances of the DTD are executed. The specification consists of the pure DTD definition and of, preferably graphical flow charts (GFC) and actions triggered if certain states of the charts are reached. The box on the left side represents an execution specification for a DTD that is structured in the pure DTD components, the definitions (visual description) of graphical flowcharts (GFC) and transition rules. The latter are fired while the control flows through the charts. As an alternative the same specifications can be given for the element instances of a XML-document without DTD.<br>
The box on the right side illustrates how this structure implies the direct execution of an XML-document The DTD, if existing, is used to validate the XML-document An attributed structure tree (AST) is constructed. The GFCs are used to decorate the AST and thus resulting in a global flow chart corresponding to the parsed XML-document The document is executed by executing the GFC, e.g. triggeringthe actions associated with certain states of the GFC and processing the control flow according to the conditions within the GFCs.<br>
A complete execution specification is structured into specification modules. Each specification module corresponds to an element declaration describing the execution behavior of that element, together with additional execution behaviorforthe components of that<br>
element, and for the instances of other element kinds.<br>
Figure 5 gives an example how a specification module for the query element according to figure 1 looks like. The uppermost part of the specification module contains relevant element and attribute definitions. The middle part gives a GFC fragment specifying the execution behavior for instances of element query. The GFC fragment is given using the preferred method of a graphical representation. Finally thetransition rule is shown in the bottom part of figure 5.<br>
With reference to figure 4 and figure 5 the preferred method of using a graphical representation of the sample DTD of figure 1 is now described in more detail. The example shown represents a GFC with a sequential control, comparable to Finite State Machines, State Charts, classical flow charts, or UML state machines. The procedure works in a similar way for distributed GFCs like variants of Petri Nets, or UML activity charts. In this embodimenttheexecutionbehaviorof a XML-documentis given by meansof a sequential graphicalflow chart whose states are associated with actions. In alternative embodiments arrows of the GFC may be associated with actions. In the present example embodiment at any state of the GFC, the corresponding actions are fired followed by a state transition to the next state. As in other state based formalisms (such as Harel's Statecharts), in the present GFC the control arrows can be labeled with boolean predicates which determine the flow of control whereby labels may be omitted. A control arrow without a label has a default behavior, e.g., if no other arrow originating from its source has a label evaluating to true, then the unlabeled arrow gets active.<br><br>
As shown on the left side of figure 4 a behavior specification of a DTD consists of three parts: the DTD definition itself, a visual notation for specifyingthe GFCs, and the specification of the actions. In addition there may be a specification for calculation of additional attributes before the execution, preferably given byfunctional dependencies, and security conditions, depending on the attributes defined by the DTD and by the specification of additional derived attributes. The DTD is used to generate a parser, and then a parsed XML-document is mapped in a canonical way into an AST. The second part of a specification describes the control flow in terms of state transitions in a GFC A visual description is associated with each element declaration of the DTD, defining a local GFC and also specifying how this GFC can be plugged into a global GFC via an inductive decoration of the AST. Toward this end, each node of the AST is decorated with a copy of the GFC fragment given by its graphical representation. The references to descendants of a node define an inductive construction of the global GFC as described below In connection with its execution (cf. figure 7 and 8). Finally, the last part consists of transition rules, specifying the actions fired during execution of the document Any state of the GFC may be associated with a transition rule, which is fired when this state is reached. The transitions in the GFC are conditional, the conditions being built up from attributes of the nodes of the AST.<br>
The GFC in figure 5 contains a round node representing a state called „ask". If that state is reached the corresponding action in the lowest part of the module is triggered. Then the control either flows to the box labeled Si-action orto the box labeled S2-action, depending on the conditions labeling the flow arrows. The boxes represent the GFCs corresponding to the siblings referenced by their labels. The I and T arrows represent entry and exit point<br>
of the control flow.<br>
In the first embodiment, as described later, I and T are treated like normal states called "initial" and "terminal".The arrows from-I and toT have to begivemexplicit-ly as transitions from "initial" and to "terminal". Further arrows into boxes have to be given explicitly as arrows to the "initial" state of the box, and arrows departing from boxes have to be given as arrows departing from the "terminal" state of the box. This correspondence may be easily understood below in connection with figures 1 to 8 which show the GFC in textual form.<br>
Figure 6 shows the specification modules action and setpoints of the example DTD of figure 1. While action is just the choice between setpoint and query, and thus it inherits the GFC definitions of these element definitions, the setpointelement module introduces a trivial GFG consisting of one state, whosecorresponding action is increasing the value of a PointCounter by the number given by means of the attribute points.<br>
As noted the visual notation in each specification module contains the information about the local GFC to be associated with each node of the AST corresponding to the specification module, and the information required to embed this GFC into the global GFC which corresponds to the input document.<br>
Figure 7 shows how the graphical fragments from each of the graphical representations are associated with the nodes of the AST corresponding to the example document and<br>
thereby illustrates how a global GFC may be obtained from an AST by matchingthe GFCs according to figure 5 and figure 6 with the corresponding nodes of the AST. One sees two instances of the GFC fragment given by the module query (cf. figure 5), and three instances of the trivial GFC fragment given by the module setpoints (cf. figure 6). Again, this figure shows the decoration of each node in the AST, that is reached by a graphical representation. Such graphical decoration mayachievethecontrolflowin a preferred way. However, it has to be understood that the invention may use solutions where textual program instructions or other means would replace the control flow and triggering of actions that are here achieved with the graphical flow charts.<br>
Figure 8 shows the hierarchical GFC resulting from an inductive nesting of these fragments. The GFC fragments in figure 7 contain boxes with references to siblings. The nesting is done by resolving these references<br>
A more detailed understanding of the visual notation used herein for the control-flow should be given by the following specification. The semantics of the graphical notation used in the specification modules can be described as follows:<br>
There are two kinds of nodes: ovals and boxes. The ovals represent the ordinary states of the GFC. They are also labeled with an action name, the action (specified using transition rules) being fired when the state is reached. The boxes correspond to superstates, which are GFCs themselves. In addition the boxes correspond to the nodes of the AST. This direct one-to-one correspondence of superstates in the GFC and nodes in the AST is the detailed<br>
embodiment of the identification of the structure of the AST and the structure of the execution behavior. Of course the described use of boxes, the reference of them to components, and the one-to-one correspondence of the structures is independent of the specific form of GFC, flow conditions, and actions.<br>
The boxes are the GFC corresponding to the components on the right-hand side of the element definition. The definition of these GFC is given in the specification module corresponding to the respective elements. The arrows correspond to edges in the hierarchical state transition graph of the generated GFC. The source and the target of an arrow can be either a box or an oval. In addition to this, there are two arrows, one with its source marked as I (for Initial) and target as a box or an oval, and the other with its target marked as T (forTerminal) and its source as a box or an oval.The arrow marked with I indicates the entry into the local GFC and that marked with T indicates the exit from it A transition to a superstate of the GFC results in an entry to the first state of the GFC (marked by the I arrow) which constitutes this superstate. The boxes in the visual description in each specification module are references to the corresponding GFC. Resolving these references for the decorated example document described in figure 7 leads to the GFC shown in figure 8. This generated hierarchical GFC gives the execution behavior of the XML-document and a direct execution of the hierarchical GFC is possible, thus allowing to directly execute XML-documents. The ability to directly execute the XML-documents does not depend on the specific kind of GFC shown in the preferred embodiment and any form of GFC that may be executed directly is suitable.<br>
In the example form of GFC, like in statecharts, a hierarchical state is entered at the initial state, which is indicated by an I arrow. If the fin a I state (marked with an outgoing T arrow) is reached, there is a transition to a state which is one level above in the hierarchy.<br>
Thus the execution of the hierarchical GFC in figure 8 works as follows. The control enters the rootof the structure tree, i.e. node!. The initial state of the corresponding GFC is the ask-state within node 1. The question attribute of this node is "Is Paris the Capital of France?" After triggering the ask-action, the answer attribute should be seteither to "yes" or "no". If answer equals "yes", control follows the upper control arrow exiting the ask-state, and enters superstate 2. The initial and terminal state of superstate 2 is the set action. After executing the set action and leaving superstate 2, the (optional, and actually non existing) S-query sibling is visited, not triggering any action, and superstate 1 is left. If the answer to the question in the ask-state of superstate 1 was "no" the superstate 3 is entered, and the initial state ask of superstate 3 is visited. This time the question "Are you sure?" is asked. If the answer is an insisting yes, the PointCounter is increased by 0 otherwise byl (superstates 4 and 5).<br>
In a preferred embodiment of the invention said states are handled by means of data cubes. The transition rules for the actions redefine the content of such data cubes pointwise. This may be better understood by assuming a simplified mode! of an imperative programming system. The state of the system is given by a multidimensional database. The data base consists of n-dimensional cubes. The content of a n-dimensional cube f can be read by the following term f(t,::::; tn) where t1 ::: tn are terms built over the<br>
cubes of the database. A normal variable corresponds to a O-dimensional cube, whereas arrays and records can be modeled with 1-dimensional cubes.<br>
The possible values that are stored in cubes may range over the usual data types like integers, reals, booleans, or anything else needed in a specific application,for instance the nodes of a structure tree, or dynamically generated objects. Attributes of the nodes of the structure tree are modeled by one-dimensional cubes and the value of an attribute a of a node n can be retrieved by the term a(n). For convenience the dot notation which is used in attribute grammars and object-oriented programming, e.g., n.a instead of a(n), is used as well.<br>
For instance a basic update rule is of the form f[t,::::; tn) :=v where f(t,;:::; tn) and v are terms built over the cubes in the system. The semantics of such a rule is to update the cubef atthe position of given coordinates to v. The rules can be composed either sequentially, or in a parallel fashion, so that the corresponding updates are all executed at once. Apartfromthe basic transition rule shown above, there may exist other transition rules, such as conditional rules where the firing depends on the evaluated boolean condition-term, do-for-all rules which allow the firing of the same rule for all the elements of a certain kind, choose rules which allowtochoose one elementof a certain kind and lastly extend rules which are used for introducing new elements, too. Transition rules are recursively built up from these rules.<br>
The process of executing the transition rules is now described more in detail, still with<br>
reference to figure 8. It is possibletotracethe execution of the sample program usingthe action rules given in the graphical representations in figures 5 and 6. The initial state is a simple state labeled with action ask, the entry into this state being marked by the I arrow In the graphical fragment attached to the root node of the AST. The ask action is specified in thequery-module was described above (cf.figure 3) and results in prlntingthe question, available in the attribute question: „ls Paris the Capital of France?". Then a user input is obtained (e.g. get(stdin)) and the attribute answer is set to the provided input After this action rule is executed, the conditions on the outgoing arrows from this state are evaluated. Two arrows leave from the ask-state, one labeled with the condition answer="yes" and the other with the condition answer="no" Depending on the value of the answer the corresponding arrow is followed, leading to the superstate node 2, or the superstate node 3. Assuming the answer was "no" one would follow the lower arrow, entering in the superstate 3. Since this is a superstate, it leads to a sequence, of transitions through the states of the flow chart which constitutes this superstate. In this case the initial state inside this superstate is again a simple state shown with the oval, which is again labeled with the action ask. This time the question attribute is printed to „Are you sure?". Depending on the answer of the user, either node 4 or node 5 is followed next. These nodes are superstates, containing one single state labeled by action set. This action adds as much points to the O-dimensional cube as specified with the points attribute. Consequently, a user answering "yes" to the initial question gets 10 points, a user answerlng"no", and then "yes" gets 0 points, and a user answering "no" to the first question and "no" to the second gets 1 point Due to the structure of the generated GFC, a user answering "yes" to the first question will never be asked the second question.<br>
More abstractly, a XML-document is thus executed by generating its GFC as described and then starting with the initial state (or states in case of concurrent execution) of its root element The initial state is found by entering the superstate, correspondingto the root of the document, and following the I arrow, if the I arrow leads to a normal state, this state is entered, otherwise the I arrows are followed recursively. If the initial state Is entered, its action is triggered. Then the conditions on the outgoing control arrows are evaluated and an arrow (or several arrows in the concurrent case) with satisfied condition is chosen. If the arrow leads to a normal state, this state is executed, and the procedure is repeated. If the arrow leads to a superstate, the I -arrows are followed recursively to determine the next state to execute and the procedure is repeated. If the arrow is a T arrow, the superstate is exited, and one of the outgoing arrows of the superstate with satisfying condition is chosen. This arrow is followed again as described above.<br>
Thus, the composition of the action for an XML-element definition is either represented by graphical and/or textual, sequential or concurrent control- and/or data-flow charts. Special textual and/or graphical means are provided to refer to the components of the XML-element definition, allowingfor synchronous and/or asynchronous execution of the actions of the components, such thatthe structure of the document, given by the components in each element definition, is reused directly in the structure of the execution, given by the triggering of actions of components. Furthermore special graphical and/ortextual means for defining the sequential or concurrent execution order of action composition may be provided together with conditions guarding certain execution paths of the specified order. These special graphical and/or textual means may be contained within the<br>
definition of conditions and actions or referencing the nodefor which the action combination is defined, for referencing its components, and for referencing its attributes, given by the XML-attribute definitions.<br>
With reference to figures 9 to 18 a second textual embodiment of the invention is now described.<br>
Figure 9 shows the unique general DTD for the XML-robot modules representing execution behavior of XML-documents according to the invention. Hereinafter, with reference to figure 9 ff, an embodiment using a textual realization of the invention is described more in detail. In orderto describe figures 9 ff. the required syntax and primitive functions shall be initially defined and explained below. Thefollowing definitions arefocused on the textual (text-based) realization.<br>
A XML-document to be executed is named "docxml" and the XML-robot is defined by documents given the file names "moduleX.xml", if the element name is X. Further it is assumed that all those files may be freely changed by the flowcharts shown in Figures 10 ff explaining the execution of doc.xml. The state of the execution consists of the mentioned documents, and the values of eleven global variables, here named cur, mod, state, derived, subcur, submod, curstate, action, trans, src, and trg. The execution alters said given documents by creating and redefining attributes, and by pastingthe state elements of the modules into the document "doc.xml". Further the values of the global variables are redefined (updated) during the execution. For instance if variable cur has value v7, in the<br>
current state of the execution, the execution of the update cur.~ v2 results in a new state where variable cur hast the value v2. In the present definitions, the values of the global variables are references inside the XML-documents or the constant undef.<br>
The XML-document to be processed uses the standardized structure described before, containing elements with start and end tags of the form <a ...> ... </a>. References to elements are pointers inside the documents. The references could be implemented (a) usingtext positions (urging to update them if furthertext is pasted inside the document), (b) existing reference mechanisms in the XML link definition, (c) pointers to objects in an object model of XML-structure-trees, such as DOM, or the trees described in the embodiment using GFC<br>
For better understanding of the execution process the focus may be set to said element's attributes. As an example, the attribute aa of an element A havingfor instance a value "13" is given as follows: <a aa="13"> ... </a>. To read the value of the attribute, a function evalAttr(_,_) is provided,takingtwo arguments, a reference to an elementand an attribute name, and returning the value of the attribute. Assuming docxml contains said element A and r is a reference to that element, the term evalAttr(r, "aa") evaluates to "13". The syntax „r.evalAttr("aa")", being equivalent to evalAttr(r, "aa"), and analogue syntaxes for other actions are used in the figures 10 ff and the description for convenience, too.<br>
The execution of the XML-document as described in thefollowing paragraphs requires the attributes to be dynamically updated and/or created. Thus, a procedure setAttr(__,_,_) is<br>
provided, taking three arguments: the first is a reference to an element, the second to an attribute name, and the third the new (initial) value of the attribute to be updated (created). E.g. the action r.setAttr("aa", "15") transforms the document doc.xml such that said element A, referenced by r, becomes the form <a aa="15">... </a>. An action r.setAttr("bb", "7") would transform the document doc.xml such thatthe element referenced by rhasthe form <a aa="13" bb="7">... </a>. If both actions are triggered in either order, the resulting form of the element referenced by r becomes <a aa="15" bb="7"> ... </a>. In this embodiment, the referenced elements are parts of a physical document, for instance doc.xml, and the transformation of said element results in a destructive, non-reversible change of the XML-document.<br>
Furthermore, in addition to standard values v existing in XML, such as strings and numbers, attributes may be setto values that are references to (other) elements in documents, as for instance the reference r in the above examples. As mentioned such references may be implemented in various ways, as long as the execution of action rl.setAttr(a,v) causes the term rlevalAttr(a) to evaluate to v, until another action r1.setAttr(a, v') is triggered to the same element rl, and the same attribute a, but with a different value v'.<br>
An action „Pastelnside" is used to paste text into an XML-document. The action has two arguments, the first is a reference to an element and the second is the text to be pasted. The text Is pasted right after the start tag of the referenced element. Given again a reference r, the action r.pastlnsideftextsample") transforms the referenced element A inside doc.xml into the following form: <a aa="13"> textsample... </a><br>
An action „Copy" is used to create a string from a reference. Given again the above example of a reference r pointing to an element A in doc.xml, the terra r.copy.evaluates to the string "<a aa="13"> ...</a>", which is syntactically identical to the referenced element, but physically different. If an elements copied, the attributes of the element remain the same, butthe reference to the copied elementremains pointing only to the document where the copy is taken from.<br>
Said actions Pastelnside and Copy are used to copy parts from oneinto another document Given two documents<br>
(Formula Removed)<br>
and references rl, pointing to the element B of docl.XML and r2 pointing to the inner<br>
element C of doc2.XML, the action rlpastelnside(r2.copy) results in a transformed<br><br>
(Formula Removed)<br>
whereas doc2.XML remains unchanged. Attributes of the eleraervtC, referenoedrfoy r2, are<br>
copied, but references into doc2.XML are not changed.<br>
Given a physical document, e.g. the file doc.xrni (or one of the moduleXYZ.xml files),the term getRef("doc.xml") evaluates to a reference to the root of the "document, e.g. the outermost start/end tag couple. Furthermore, the term r.getLabeI evaluates to the name of the element referenced by r. In the examples above with doc1XML and doc2.XML, rlgetLabel evaluates to "B" and r2.getlabel evaluates to "C".<br>
Navigation through XML-documents is done using the functios get First (,),getNext(_), andparent(J.Thefirstargumentof allthreefunctions is a reference to anelement inside an XML-document. Given a reference r, r.getFirst("A") evaluates to a reference to the first element A directly inside the start and end-tags of r. Nested instances are not considered. In the examples with docl.XML and doc2.XML, the reference r1 can be obtained by means of the term getRef("doc1.XML") and the reference r2 can be obtained fey means of theterm getRef("doc2.XML").<br>
If there is no element with the requested name, getFirst evaluates'to the constant undef. Further getRef does not refer to nested elements. Referring to the above examples, getRef{docl.XML).getFirst("A") does not evaluate to a reference tothe inner A-element, but to undef. In order to get a reference to the inner A-element, one had to use getRef(doc1.XML).getfirst("B").getFirst("A").<br>
As a consequence of the definition of getFirst, either r.getFirst{T').getLabel = "I" or r.getFirst('T') = undef, for any reference r, and label "I".<br>
The function getNext(_,_) returns a reference to the next element with thesame label, if existing, otherwise undef is returned. Given a reference r to the following XML-fragment:<br>
(Formula Removed)<br>
The reference r.getFirst("B") references the B-element with x ="1", the reference r.getFirst("B").getNext references the B-element with x-"2", the reference r.getFirst("B").getNextgetNext references the B-Element with x="4". In order to reference the B-element with x="3", one needs to write r.getFirst("B").getNext.getFirst("B").<br>
Thefunction„parent"mapsa referencetoanelementtoareferencetotheleastenclosing<br>
element. In the examples with docl.XML and doc2.XML,r1.parent = getRef("dod.XML") and r2.parentparent = getRef("doc2.XML").<br>
The function „<copylist as a first argument reference and second an element name. r.copylist assembles string by concatenating all elements directly nested in r. thus given the example getnext paragraph above results x="1"><:b x="2" xb the dtd for modules is defined. elements of this are explained stepwise below. typically given in separate module-files. course dtds had to be completed with a unique root element. however complete language list all might contained one dtd. topmost module-element these></:b>
The components of a module are a list of derived attributes, an optional expression, a list of states and a list of modules (sub-modules). The name-attribute indicates the element to which the module is applicable. The definitions are based on the assumption that an element "X" is present in the document to be executed, that a XML-document called<br>
"moduleX.xml" whose root element is a "module"-element exists, and that said root element has a "name" attribute with the value "X".<br>
delement module (derived*, expression?, state*, module*)<br><lattlist module name cdata></lattlist>
number CDATAT&gt;<br>
The list of derived attributes contains attribute definitions that are given by functional dependencies from other attribute definitions. The optional expression gives a security condition, that has to be fulfilled by each instance of such an element The states are the (non-nested) states of each instance of such an element Finally, the list of modules refers to the components of the element, for each of which the sub-modules may contain states and further sub-modules. For the sub-modules, the number attribute denotes which instance it refers to. If it referes to the first instance, number has the value "1", and so on. if it refers to all instances, number can have the value "all".<br><lelement derived expression><lattlist derived name cdata> delement argument EMPTY&gt; <lattlist argument name cdata><br>
A derived attribute definition has two components: the arguments, available in the definition, and the actual definition, given as expression. The name-attribute gives the name of the derived attribute. A derivec attribute is evaluated by setting the values of the<br>
arguments, and evaluating the defining expression.<br>
The components of a state are a list of actions, to he triggered if the state is reached, and a list of transitions departing from the state. The name of the state is used to reference it as the target of some transition.<br><lelement state transition><br>
Thetwo components of a transition are an expression, guardingthetransition, and a path, denoting the target of a transition. All expressions, paths, actions, and definitions of derived functions depend on their origin, i.e. the root of the module, respectively its instances in the XML-document to be executed.<br><br>
A path consists of an optional component, and an attribute state. The state denotes the name of the state, the path points to. Typical states are "initial"foe the initial state, and "terminal"forthefina!state(s). The component refers to nested components, the attribute number denotes again the chosen instance. If the value of number is "all" the path corresponds to a family of paths to all instances.<br><elementpath><br>
number CDATA T&gt;<br>
Expressions are used in various places and are defined as follows:<br>
getnext | parent | root | apply | external | constant&gt;<br>
Paths used as expressions evaluate to the corresponding element and not to the state referenced by the path. Self evaluates to the element which is the instance of the module containing the definition wherein self is used. Src evaluates to the element containing the state which has been executed last, if used in actions, and to-the element containing the source of a transition, is used inside a transition. Trg evaluates to the element containing thetarget of a transition. Evalattr, getfirst, getnext and parent evaluate to the corresponding primitive functions described above. Root evaluates to the root of the document which is executed. Apply is usedfor built in binaryand unary operators, like arithmetic operators (+, -, *,...), boolean operators (and, or, not,...), and string operators (append, concatenate, ...). External is used to call externa I functions, written in arbitrary programming languages. Finally constant is used to denote constant like numbers, i.e. booleans, and strings.<br>
In the flow charts, an abstract function evaluate(J is used to evaluate expression elements..<br>
Actions are triggered if a state is reached and are of the structure: delernent action (setAttr | ifthen | forali | external)&gt;<br>
The setAttr action corresponds to the setAttr primitive described above. Ifthen is used to execute certain actions only under certain conditions, and the forali is used to execute an actionforall instances of a certain element in a document. The external construct is again used to call external functions.<br>
In the flow charts, an abstract procedure execute{J is used to execute action elements.<br>
Since the definitions should be valid independentlyfrom the concrete choice of expression and action grammar, the DTD according to figure 9 is complete'd with the remaining rules starting at line 19 with the element delement src EMPTYx<br>
With reference to figures 10 to 16 the execution of a given XML-document doc.xml shall be explained more in detail. Figures 10 to 16 show six fixed flow charts F1, F2, F2, F3, F4 and F7 that specify the execution process. In contrast to the GFC's described In the context of the first embodiment, these flow charts do not depend upon the document to be executed and the robot-modules but arefixed for any document and any robot-module. Each flow chart refers to a logical block of the execution of a given XML-document doc.xml to be executed.The modules are provided as separate files moduleX.xmlfor each element-name X.The states of each flow chart Fy are referenced as [Fx.Sy] where x represents the number<br>
of the flow chart and y represents the state number within the corresponding flow chart.<br>
According to the invention the XML-document (or in other embodiments a DTD) is first traversed and all states and transitions from the modules are copied into the XML-document Subsequently the XML-document is executed standalone. During the copying process, the "origin" attribute of each state is set to the element currently traversed, e.g. the element from which the copy action has been triggered. The values of the origin attribute are thus references to elements of doc.xml.<br>
The initial state of the execution, shown in figure 10, is [F1.S1]. The value of the global variablecu is set to a reference to the root of the document "docxml". Then the control is passed to state [F1.S2], setting the value of the global variable mod to be a reference to the "module" element describing the execution behavior of the root, e.g. the module having the name correspondingto the label of cur. Then control is passed to the state [F2.S1] of theflow chart F2. The purpose ofF2 is to copy all "state"- and "derived"-elements from the module mod into the element cur, setting the attribute "origin" of all states and derived to cur. From F2.'s last state [F2.S99] control is passed to F3's first state [F3.S1]. The purpose of F3 is to copy the "state"-and "derive"-elements of the sub-modules of module mod into the corresponding components of element cur, still setting the attribute "origin" of all "state"- and "derived"-elements to cur. From F3' s last state [F3.S99] control is passed to [F1.S3], updating curto cur.traverse.Then the decision [F1.D1] branches upon the condition cur = undef. If the condition evaluates to true, the traversal terminated, and control is passed to [F5], otherwise control is passed back to [F1.S2].<br>
Module F5 may contain supplemental procedures to process modules nested in nested modules and to check security conditions. These procedures that are only used in special embodiments, may be implemented using standard process structures. From [F5] control is passed to [F6]. Again, module F6 is only used for special embodiments and contains states, transitions and derived attributes being reordered according to different policies, for instance preferences on the conditions in transitions and the like to be implemented. From [F6] control is passed to the first state of F7, to [F7.S1].<br>
As noted the purpose of F2 (figure 11) is to copy the "state"- and "derived"-elements of module mod into element cur, and to setthe "origin"-attributes of those elements to cur. Rather than first copying the elements and then setting the attributes, the attributes are setto the right value in module mod, and afterthisthe "state"- and "derived"-elements are copied from module mod into element cur. A global variable state is used to range over "state"-elements in mod, and a global variable derived is used to range over "derived"-elements. The first state [F2.S1] sets variable state to the first "state"-element in mod. Then control is passed to [F2.D1] and from there control is passed to [F2.S3] if state = undef, and to[F2.54] otherwise. In [F2.S3], which is reached if state is not undef, the attribute "origin" of state is setto cur. From there control is passed to [F2.S3], setting state to state.getNext. From there control goes again to the decision [F2.D1]. In [F2.54], which is reached after all "state"-elements have been copied, the global variable derived is set to the first "derived"-element In the same way asforthe "state-elements, the decision [F2.D2], branching upon derived=undef, and the state [F2..S6], triggering derived:- derived.getNext are used to iterate over all "derived"-elements, and in [F2.S5] the "origin"-attribute is setto cur.<br>
If the iteration terminates, control is passed to [F2.S7], pasting the complete list of deriveds into cur. Then in [F2.S99], the list of "state"-elements is copied from mod and pasted into cur.<br>
In F3 (figure 12), all sub-modules of mod are visited, usingthe iteration variable submod. If the iteration terminates, e.g. if the decision [F3.D1] evaluates submod to undef, then control is passed to the last state of F3, [F3.599]. Otherwise, control is passed to [F3.52], where the variable subcur is set to the first component whose label matches the label of the sub-module submod. lfthe"number"-attributeof thesubmodule submod is 'Tor "all", subcur is correctly set to the first instance and control is passed from decision [F3.D2] to the first state of F4, [F4.S1]. Otherwise, in [F3.S3] subcur is set to the next instance, and control is passed to the decision [F3.D3] which checks whether subauris undef. If not, there is the assumption that the second instance or all of them have to be checked, and control is again passed to the state [F4.S1]. The purpose of F4 is exactly the same as that of F2, but instead of mod and cur, one uses submod and subcur, except for the attribute "origin" which is set to cur.<br>
From the final state [F4.S99] control is passed to the decision [F3.D4]. If the branch condition evaluatesthe"number"-attribute of submo of to "all", control is passed to[F3.S3], traversing all instances with the right label. If that traversal stops, by triggering decision [F3.D3]to true, or by finding in decision [F3.D4], that number was not "all", the visiting of all sub-modules is continued in state [F3.S4]. There submod is set to the next instance of "module"-elements. From [F3.S4] control is passed again to the decision [F3.DT], which as<br>
noted, either continues the visiting of sub-modules or sends control to the last state of F3, i.e. [F3.S99].<br>
As mentioned above, F4 (figure 13) works exactly like F2. The variables state and derived are used to iterate over the "state"-elements and "derived"-elements of module submod, settingtheir"origin"-attributetoelementcur.Then all "state"- and "derived"-elements are copied and pasted into the element subcur.<br>
At state [F4.S99] all "state"-elements and "derived"-elements are copied into the corresponding elements of the document doc.xml and the "origin"-attribute is set, such that' the modules are not needed anymore. Since only an attribute of state has to be set and all "transition"-, "action"-, and "derived"-elements are and remain untouched, an alternative would be to copyonlytheoutermostpartof the"state"-elementsand"derived"-elements, and to use references to the modules for the rest.<br>
The first state [F7.S1] of flow chart F7, shown in figure 14, denotes the beginning of the actual execution phase. In F7, the actions of all states matching the current-state curstate are triggered.<br>
[F7.S1] sets cur back to the root of the document doc.xml. Then control goes to [F7.S2], where the global variable curstate is set to "initial". The purpose of curstate is to indicate the current state, inside the current element cur. In [F7.53], [F7.D1] and [F7.59] the variable state is iterated over all "state"-elements of the current element cur. [F7.S3] initialized the<br>
iteration, [F7.D1] is the termination criteria, sending control to [F8.S1] if it terminates and [F7.S9] is the actual iteratorthat sets state to the next instance of "state"-elements. Inside the iteration, the decision [F7.D2] checks whether the "name"-attribute of state matches the current state curstate. If so, [F7.S4] is visited next, setting variable cur to the value of attribute "origin" of state. The purpose of this update is to evaluate the actions in the right environment In [F7.S5], [F7.D3], and [F7.S7] the variable action is iterated over all actions inside state, and all of them are executed in [F7.S6j.When that iteration terminates, control is passed to [F7.S8] where the value of cur is reset to its original value. From there the iteration over states is entered again, leading after termination to [F8.S1]<br>
Finally in F8, shown in figure 15, the transitions are triggered, updating the current element cur, and the current state curstate. The evaluation of the transition conditions depend on the origin of their definition, the source-element src of the transition, and the target-element trg of the transition. In the "expression"-element denoting the condition, those three elements can be accessed as <self></self>, <src></src>, and <trg></trg>, respectively. In flow chart F8, two nested iterations take place over the "state"-elements and over their "transition"-elements. The first state [F8.S1] sets src to the current element cur. Then [F8.S2], [F8.D1], and [F8.59] iterate the variable state over all states in the current element cur. If the iteration terminates, control is passed back to [F7.S3], executing again the same actions. Otherwise, [F8.D2] checks whether the "name"-attribute of state matches the current state curstate. If so, [F8.S4] is entered, and cur is set to the value of attribute "origin". Then, [F8.55], [F8.D3], [F8.S8] are used to iterate variable trans over all transitions inside state. Inside the iteration, [F8.S6] sets trg to the result of evaluating the path. Then<br>
 [F8.D4] checks whether the expression of trans evaluates to true. It has to be noted, that for this evaluation the correct settings of cur, src, and trg are needed. If the result of the evaluation is true, cur is set to trg, and curstate is set to the "state"-attribute of the path-component of trans. Then control is passed to [F7.S3] in order to execute the actions of the new current element and state.<br>
In Figure 16,17, and 18 modules of the query language example accordingto figure 1 ff are shown. These modules are valid with respect to the DTD given in figure 11. The execution of the sample XML-document can be performed using the process described in figure 12 ff.Said modules may be automatically generated from a graphical input according to the graphical flow charts described above. On the other hand, their graphical representation could be generated from the textual form given here.<br>
With reference to figures 19a-19d the implementation of a XML-robot specification that gives the execution behavior of XML-documents as explained above is described more in detail. Given a XML-robot specification m0, written in a XML-robot specification language M, such as the visual/textual query language described above, and an XML-document d valid with respect to m0's document type definition DTDO, the execution specification gives all information on what an abstract process m0Exec(d) shall do in order to execute d. In order to implementthe abstract process m0Exec(d) a program is needed that can be executed on existing computers, e.g. a program written in a programming language such as C or Java. There are four basic ways to implement said program.<br>
In the figures 19a-19d processes are visualized as boxes, documents are visualized in the usual way, i.e. a box with a curved upper side, and an executable document, e.g. a program, is visualized as a combination of a document and a process, e.g. the execution of the program. Each process mayhave an input, in form of documents, an output, in form of documents, and it may start another process. Concrete processes, which can be executed on a real machine are shown as boxes with continuous lines, and abstract processes, such as the process m0Exec(d) are shown as boxes with dotted lines. The described possibilities of implementing XML-robots are different combinations of compiler and interpreter techniques. Either one of the techniques can be used for the meta formalism A/I and the formalism DTDO. Thus, there are typically four combinations, a compiler followed by an interpreter (figure 19a), a compiler followed by a compiler (figure 19b), an interpreter followed by an interpreter (figure 19c) and an interpreter followed by a compiler (figure 19d)<br>
Figure 19a shows an implementation by generating an interpreter IntDTDO from the XML specification m0. The Interpreter IntDTDO takes as input a XML-document d and checks whether it is valid with respect to DTDO. Subsequently it starts a process executing such a document d, in such manner that the process is equivalent to the above introduced abstract process m0Exec(d). The implementation is given by an executable document /G, whose execution takes as input a XML-robot execution specification m0 and generates as output an executable document IntDTDO, i.e. said Interpreter.<br>
Figure 19b visualizes a next possibility by providing a compiler generator given by an<br>
executable document CG that generates a compiler CompDTDO from the XML specification m0. The compiler CompDTDO transforms a document d, received as input, into an executable document d' whose execution must be equivalent to the abstract process m0Exec(d).<br>
Figure 19c shows an interpreter IntMtoInt of the specification language M starting an interpretation process of m0. The interpreter /nt/vlto/nttakes as input a XML-robot specification m0 and starts a process IntDTDO that takes as input a XML-document d. The process IntDTDO now starts a subsequent process executing the document d which process must be equivalent to the abstract process m0Exec(d).<br>
As a last possibility figure 19d shows an interpreter IntMtoComp of the specification language M. The interpreter IntMtoComp takes a XML-robot specification m0 as input, but starts in contrastto the pre-described interpreter IntMtoInt a compiler process CompDTDO, thattakes as input a XML-document d, and generates as output an executable document d' whose execution must again be equivalent to the execution of the abstract process m0Exec(d).<br>
It may be easily recognized that each of the above possibilities has specific advantages and drawbacks. As known, the advantage of using interpreter technology is the immediate availability of the execution,the advantages of the more complex compilertechnologyare both a better performance and the availability of the generated executable documents, which can be reused separately, independentfrom the XML-robot specification m0.<br>
in Figure 20 a preferred embodiment of a web-based XML-robot is shown. A server 21, typically a powerful web-server, is connected to a data base 22 and one or more libraries 23 of functionalities. By network connections, particularly over internet, one or more clients 25.1,25.2, typically using a browser running on a remote system, may access said server 21. The capabilities of these clients 25.1, 25.2 are more or less limited and may typically run limited abstract machines like the Java Virtual Machine.<br>
The Server 21 provides the service to execute XML-documents according to a XML-robot specification as described above. The actions in the XML-robot specification are actionsto be executed on the server 21, e.g. access to the server's database 22 or calls to the server's libraries 23 of functionality. In addition there are actions and possibly additional equipment 27 available for publishing results via e-mail, web pages, WAP, SMS and the like,, managing access rights and managing the architecture of the underlying databases and software systems. The XML-robot specification may be executed on the server 21 only, but it may serve as documentation of the service provided to the client.<br>
The situation is comparable to an Application Service Provider (ASP) model, where applications are run on a server, and all kind of clients can access them. The present invention shares the advantage of ASP that all computation is done on the server, and thus, the clients can be very small devices like Internet appliances. Furthermore the invention has the advance, that a finite XML-robot specification can execute infinite many different XML-documents matching the corresponding DTD.<br>
The applications of the Execution Service Provider approach rangefrom input/control of existing applications to the specification or even programming of new applications. The input/control applications use the XML-documents to control an application. The XML-robot specification would simply translate the documents into interactive input/control sequences for the application to be controlled. In the case of specification/programming of new applications the XML-docu merits correspond to syntax trees of programs and the XML-robot specification gives the execution behavior. Given for example a XML-robot specification with a DTD representing syntax trees for the programming language C and the XML-robot giving their execution behavior would allow to send arbitrary C programs to the server and to have them executed there.<br>
In contrast to the pre-described embodiment with an Execution Service Provider another preferred embodiment may provide LangLets (small XML-robot specification) and Mobile Languages, respectively. Here the Server 21 provides services to the clients 25.1,25.2 byfirst sending a XML-robot specification and then XML-documents that should be executed according to the specification. This embodiment requires clients 25.1,25.2 that are able to generate an interpreter/compiler from the XML-robot specification to execute the XML-documents. The actions of the XML-robot specification are accordingly executed on the clients 25.1,25.2. This approach may in a wider sense be compared to sending Java code to a clientwhich subsequently is executingthis code. However,theexecution behavior given by a XML-robot specification is a lot easier and far less expressive than full Java. A language like Java may nevertheless be used to program the actions of the XML-robot specification. The execution behavior of all XML-documents (infinite many) executed<br>
according to such an XML-robot specification is then restricted to the finite number of fixed (but parameterized) Java-actions in the XML-robot specification.<br>
It is an important advantage of the present invention that security properties of a finite XML-robot specification may be investigated. These properties may then be guaranteed or checked, respectively, for an infinite number of different XML-documents that are intended to be executed on the clients 25.1, 25.2. If, for instance, a certain critical security action is notcontained in the actions of the XML-robot specification, it may be guaranteed (based on the definitions directly) that this action is not executed for any XML-document executed according to that XML-robot specification. Or if another critical security action is only triggered by a state which is guarded by a certain condition, it can be guaranteed that this action is only triggered if this condition is fulfilled:<br>
Again it may be helpful to think of mobile code, where source code is sent over the net. However, in contrast to that, here a XML-robot specification is first sent, giving the execution behavior of the mobile language/DTD and then the programs/XML-documents are transferred. Thus, a mobile language is provided over a given network. The advantage of mobile languages over mobile code is, that repetitive computations are embedded in a generic way in the XML-robot specification, and the XML-documents describingthe actual instances of the computations are less complex.<br>
Such use of the inventive XML-robot allows the definition of a new language and to execute code written in said language, after having generated a corresponding compiler<br>
and/or interpreter. It is furthermore possible to build editors, debuggers and analysistools. The described data and code synergies allow directly to define the execution or other processing of a valid XML-document, without writing a separate program that explicitly parses and analyses the structure tree of such document<br>
The invention provides an apparatus 25.1,25.2, particularly Internet appliances, that may be used within an network environment particularly the Internet, that comprises means for receivingfrom and sending data to a remote computer. The apparatus provides means for storing and accessing data (XML-document) being sent from said remote computer. The apparatus preferably comprises means that can examine such data received from said remote computer and, if applicable, validate if such data is a valid and/or accepted XML-robotspecification. The apparatusfurthermore comprises means that may integrate the XML-robot specifications with a XML-document The XML-document is then executed by the apparatus, preferably by a processing unit, that may execute the Instructions of the XML-documents. It is easily understood by somebody skilled in the present technical field, that the means comprised by this apparatus may be integrated in such manner that e.g. the processing unitfor execution of the XML-document may provide functionality forthe sending/receiving operation of this apparatus. Furthermore the apparatus typically comprises a user interface, that may provide, if desired, means to animate execution and analysis of XML-documents or XML-robot specifications. However, it may serve as a service station within a network, only.<br>
The invention furthermore provides an apparatus that comprises means for graphical<br>
display of XML-robot specifications, e.g. as described with reference to figures 3 ff„ in an advanced visual integrated development environment. According to the specification above, this graphical representations are used to generate XML-documents representing said XML-robot specifications.<br>
The invention furthermore allows to provide distributed execution of XML-documents. Multiple XML-robots are then used to distribute a computation of XML-Documents due to the fact that the structure of the documents is at the same time the structure of the application that processes them. Accordingly, parts of a XML-Document can easily be executed on different instances of the XML-robot that may be located at different sites. Similarly, special applications may require part of the document to be executed on the server and part of the document on the client side.<br><br><br><br><br><br><br>
WE CLAIM:<br>
1. A computer system with at least two apparatuses (25.1, 25.2), particularly Internet appliances, comprising a server (21) providing services to at least one client by executing at least parts of a XML-document according to XML-robot specification sent from the client to the server or a server providing services to at least one client by sending a XML-robot specification and a XML-document to the client, such that said service is provided by execution of at least part of the sent document on the client according to the sent XML-robot specification.<br></elementpath></lelement></lattlist></lattlist></lelement></copylist></a...></a...></b...></a...></yx></ielentz></lelementy></a...></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLWNvbXBsZXRlIHNwZWNpZmljYXRpb24gKGdyYW5kZWQpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-complete specification (granded).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLWNvcnJlc3BvbmRlbmNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLWZvcm0tMTkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLWdwYS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLXBjdC0yMTAucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-pct-210.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLXBjdC00MDkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-pct-409.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDMtMDAwMDYtZGVsLXBldGl0aW9uLTEzOC5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2003-00006-del-petition-138.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="217874-an-electric-device-for-use-with-a-battery-powered-electric-vehicle.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="217876-an-embedded-processor-complex-for-controlling-the-programmability-of-a-network-processor.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>217875</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2003/00006/DEL</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>37/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>12-Sep-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>29-Mar-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>01-Jan-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>KUTTER, PHILLIP</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>SCHLOSSERGASSE 1, CH-8001, ZURICH, SWITZERLAND.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>KUTTER, PHILIPP</td>
											<td>SCHLOSSERGASSE 1, CH-8001, ZURICH, SWITZERLAND.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 17/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/IB00/01087</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-08-02</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>PCT/IB00/01087</td>
									<td>2000-08-02</td>
								    <td>PCT</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/217875-xml-robot by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:13:43 GMT -->
</html>
