<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/216077-a-method-of-querying-a-database by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:15:14 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 216077:A METHOD OF QUERYING A DATABASE.</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD OF QUERYING A DATABASE.</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>TITLE: A METHOD OF QUERYING DATABASE. A method of querying a database with a processor, wherein the database comprises an index, associated with one or more physical storage devices and data associated with one or more physical storage devices,wherein the index is queried by the processor using a search key comprising at least one symbol, the symbol being represented by a plurality of bits, inorder to locate data matching a search criterion, and wherein the index is a hierarchical structure of nodes that is navigated by the processor during a search until a conclusion set is reached,cgaracterused in that the index is searched by the processor by comparing a decision group of the search key at each node with a decision value of the node, in that each decision group comprising at least one bit and at least some of the decision groups comprise a plurality of bits, in that the structure is organized such that key symbols are not stored at a node in the structure, and in that each node has less than three exit paths therefrom.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>The present invention relates to a method of organising a database comprising indexing,<br>
placing information into, and querying a database. In particular the invention allows<br>
efficient search of scalar data within a data storage.<br>
Scalar data types include, for example, logical data, text strings, numeric data, and<br>
date-time data.<br>
Although data processors are fast, it is inefficient and time consuming to search through<br>
all the data held in a storage system to find a particular item having a specified property<br>
or a range of properties. Also, it is almost inevitable that the data will be stored in mass<br>
storage media, and this gives rise to delays due to disk access compared to CPU speed<br>
and access to semiconductor memory. It is more efficient to create an index such that<br>
items can be retrieved using a search key.<br>
Index mechanisms require the creation and maintenance of an internal index structure.<br>
The navigation and maintenance of this structure incurs a processing overhead in its<br>
own right. The overhead can vary as a function of the indexing mechanism used. It can<br>
also vary as the size of the database changes or as, for example, the data in the<br>
database changes from time to time.<br>
A simple example is in a database storing chronological information, such as dates of<br>
birth. The designer may, for example, structure the data such that those people born<br>
before 2000 AD have data relating to them segregated from those born after 2000 AD.<br>
This strategy may work for a while but, it can be seen that the number of people born<br>
before 2000 AD is a constrained set, whereas the number born after this date in<br>
unbounded. Thus, as time passes this indexing key may become redundant as the<br>
proportion of entries relating to people born after 2000 AD increases.<br>
The effectiveness of the indexing method can be judged against a number of attributes,<br>
such as:<br><br>
1) The size of the index. Larger indexes require more time to navigate. They may<br>
also require an increased number of data swaps or read operations involving transfer<br>
from mass storage media, such as hard disk drives, and faster memory, such as<br>
semiconductor memory.<br>
2) The structural constraints of the index. A highly constrained structure may offer<br>
initial advantages, but sutlers increased computational overhead if it is required to<br>
rebuild the index as the database grows to accommodate more data.<br>
3) The key data restrictions imposed by the index. Thus, the maximum size of the keys<br>
or the data types of the keys or ranges represented by the keys may begin to effect<br>
the performance of the index as it grows or as the database becomes populated with<br>
data.<br>
4) The key retrieval restrictions imposed by the index. Some indexes only allow exact<br>
key matching, whereas others allow range matching.<br>
5) Growth limitations on the index. The index may be constrained by a maximum size.<br>
6) Concurrency limitations. The index may either allow or inhibit simultaneous<br>
insertion and retrieval of key data.<br>
Known prior art systems typically use tree graphs with nodes containing one or more items<br>
of key data. In order to interrogate the database the trees are navigated by comparing key<br>
values at each node visited with a required search key. It is inherent in such a design that<br>
each node includes the entirety of a key associated with the creation of the node and hence<br>
the "size" of the node in data storage terms can be quite large.<br>
The efficiency of such indexes can be dependent upon the key size and the order in which<br>
data is added to the index.<br>
Furthermore, some methods require the trees to be "balanced" at all times if they are to<br>
operate properly. These methods can incur significant maintenance overheads for key<br>
insertion and deletion making them unsuitable for high throughput systems.<br><br>
Navigation<br>
According to a first aspect of the present invention, there is provided a method of<br>
organising a database having an index and data, wherein the index is queried using a search<br>
key comprising at least one symbol, the at least one symbol represented by a plurality of<br>
bits, in order to locate data matching the search criteria, characterised in mat the index is a<br>
hierarchical structure of decision nodes, the structure of nodes being navigated during a<br>
search until a conclusion is reached, and the structure is organised such that key symbols<br>
are not stored at a node in the structure, and each node has less than three exit paths.<br>
It is thus possible to provide an efficient index structure that enables efficient search and<br>
update of the database. The index structure is much smaller than prior art indexes because<br>
the nodes do not store the whole of the key associated with the node. Indeed a node need<br>
not store any key associated with it Furthermore the nodes do not store the decision rules<br>
relating to interrogation of a node. This is because the rules are global in mat they are<br>
shared by all nodes rather than being node specific.<br>
Each decision node makes a binary decision. That is, each node only has a maximum of<br>
two exit paths.<br>
Preferably the decision applied at each node is a simple query. By that it is meant that the<br>
query compares the key or part of the key with the decision criterion at a node, and that in<br>
binary terms the test is typically (though not necessarily exclusively) is the key, or part<br>
thereof being tested, greater than or less than the decision criterion. This removes the need<br>
to store features of the search key within the structure of the index itself.<br>
Each exit from a node may point to a further decision node, a conclusion set or to a null<br>
result.<br>
If an exit from a node points to another node, then the search continues. However, if the<br>
exit from a node points to a conclusion set then the navigation of the index is generally<br>
concluded.<br>
It is possible that no results will match the search terms, in which case the search ends at a<br>
null result.<br><br>
Every "record" in the database belongs to a conclusion set The conclusion set itself points<br>
to the data that satisfies the specific search criteria, or in some circumstances may store the<br>
data itself.<br>
The hierarchical structure of decision nodes may be regarded as a decision graph. The<br>
decision graph may be of any arbitrary size and internal structure. However, the decision<br>
graph is generally a small entity in terms of its size in a memory of a processor.<br>
Preferably the decision graph is, in use, held within electronic memory of a data processor.<br>
By holding a relatively small decision graph in RAM, the data processor can quickly find<br>
the result of the query. In particular since the analysis of the decision graph does not<br>
require access to magnetic or other physical storage media, access times associated with<br>
such media are eliminated thereby enhancing performance.<br>
Preferably each conclusion set can only be reached by one single route through the decision<br>
graph. This ensures mat all the keys in a conclusion set conform to a shared unique set of<br>
decisions.<br>
Database indexes can, and indeed must, evolve with time and this can lead to degradation<br>
in performance as the database grows. It is therefore necessary to allow for insertion and<br>
deletion of data within conclusion sets, and also for the creation of new conclusion sets.<br>
Preferably each conclusion set has a maximum size. The maximum size is a user or<br>
designer controlled parameter. However, the size may advantageously be related to the<br>
size of data or addressing blocks used by a storage device, such as a magnetic store which<br>
may comprise one or more hard disks. However any random access data storage may be<br>
used, such as optical storage devices.<br>
As a conclusion set approaches or reaches a predetermined size, a new decision node is<br>
inserted into the decision tree and the data which was in the conclusion set is re-indexed<br>
into new conclusion sets reached via the exit paths of the new decision node. The new<br>
decision node is inserted in the exit path of a node that had pointed to the conclusion set<br>
that outgrew its maximum size.<br>
Thus the conclusion sets are constructed to be well behaved.<br><br>
The decision graph does not contain any search key data itself. All key data is implied or<br>
deduced from the structure of the decision graph. This keeps the decision graph compact.<br>
Also, this means mat the size of the decision graph is independent of the key size.<br>
A further advantage of the present invention is that changes to the structure of the decision<br>
graph can be made, and that these changes are local. That is only one or a few decision<br>
nodes are affected by the change. This means that structural reorganisation is not a<br>
significant computational overhead.<br>
Preferably the decision nodes are related to portions, and more preferably relatively small<br>
portions, of the key. This has the consequence that the decision graph is largely<br>
independent of the structure of the key. This also has the advantage mat the decision graph<br>
places few, if any, restrictions on the structure of the key. Furthermore, the portion of the<br>
key to which a node is related does not have to follow a structured order as the decision<br>
graph is navigated. Thus, the portion of the key in question does not have to progress<br>
along the key in a monotonic fashion as the graph is navigated.<br>
Advantageously the decision graph is structured such that the semantic order of key<br>
sequences is preserved. Thus, for example, the decision graph may be structured such that<br>
a first node or set of nodes test a first bit or a first group of bits in a search key and that, as<br>
the decision graph is navigated towards a conclusion set, the bits of the key that are tested<br>
at subsequent nodes become increasingly less significant. Thus the decision graph can be<br>
navigated to locate keys either by exact matching or by range matching. The range may be<br>
partially or fully bounded during the search.<br>
The structure of decision graph, and in particular the fact that changes to the structure are<br>
local, in that they only affect a node or two, rather than being global means that the<br>
computational task of maintaining the decision graph is generally low. The localised<br>
nature of the reorganisation facilitates insertion, deletion and retrieval of data using the<br>
index. In fact, two or more of these events may occur concurrently.<br>
Preferably there is no functional limitation to the size of the decision graph. The structure<br>
of the index gives rise to a well behaved increase in search time as the decision graph<br>
grows to accommodate increased amounts of data.<br><br>
According to a second aspect of the present invention, there is provided a database having<br>
an index, and arranged to hold data and to allow the data to be located by interrogating the<br>
index using a search key, the key comprising at least one symbol, the or each symbol being<br>
represented by a plurality of bits, wherein the index is a hierarchical structure of decision<br>
nodes, the structure of nodes being navigated during a search until a conclusion is reached,<br>
the search criterion of each node being encoded by the position of the node within the<br>
index, and each node having upto two exit paths.<br>
The localised structural changes in the index facilitates concurrent insert, delete and<br>
retrieval events within the index.<br>
Preferably each item of data within the database can belong to only one conclusion set<br>
Decision Graph Splitting<br>
In spite of the strong preference that the decision graph should reside wholly within<br>
semiconductor memory this may not always be possible. This may be because the index<br>
becomes too large, or it may be because the host data processor implements a "virtual<br>
machine" environment for the database such that the host can multitask, and the operating<br>
system does not allocate sufficient memory resource to the database.<br>
Under such circumstances the decision graph can be held within blocks of memory on the<br>
mass storage device of the computer system. The disk controller manages the disk in terms<br>
of discrete blocks of data. Thus, for example, if the minimum block size used by the disk<br>
controller is 64K bytes, then a 40K index and a 60K index both occupy the same storage<br>
space on the disk, namely one block, and similarly a 65K index and a 130K index also<br>
occupy the same storage space, namely two blocks.<br>
In order to accommodate and work with these system constraints the modification of the<br>
index needs to be controlled since the size of the index will increase as the key population<br>
within the index increases. Thus to grow the index more blocks of memory are required.<br>
In a first scheme for growing the index when it is required to insert a new decision node<br>
and the block is full, a new block is created and the new node is placed in the new block.<br>
The decision graph is amended such that the node that points to the new node also causes<br><br>
the new block to be fetched from the magnetic store if that block is not already resident in<br>
semiconductor memory. Navigation then continues from the new node.<br>
This method is simple but inefficient as it is likely to lead to the creation of many, possibly<br>
hundreds, of nearly empty memory block from each parent full block. This may not be<br>
considered to be a problem in terms of space taken as disk drives can hold phenomenal<br>
amounts of data, but it may compromise index performance as more disk I/O operations are<br>
required to navigate the index.<br>
A preferred approach is to create a new block and then to split the parent block (i.e. the full<br>
block) substantially equally between the two blocks. This approach does require that the<br>
original block be interrogated to find the node mat best divides the block into two. This<br>
might be done from an ab-initio analysis of the nodes in the block or by approaches which<br>
are more statistical in nature. Thus, for example, a recursive algorithm might be used<br>
which repeatedly picks a test node for the split, calculates the division of the index<br>
resulting from the choice of node and on the basis of the result modifies the choice of test<br>
node until an approximately even distribution is achieved.<br>
This second approach has the benefit that each index block contains a substantial<br>
population of nodes. This leads to a significantly more efficient use of memory.<br>
Pattern matching.<br>
As noted hereinbefore, prior art systems store the entirety of a search key associated with<br>
any given mode.<br>
The first and second aspects of the present invention dislosed a tree structure where the<br>
nodes do not store the search key but the key data is inherent in the structure of the tree.<br>
According to a third aspect of the present invention, there is provided a method of<br>
interrogating a database having an index and data, and wherein the index is queried using a<br>
search key in order to locate data matching the search criteria, characterised in that the<br>
index is a hierarchical structure of decision nodes, the structure being navigated until a<br>
conclusion set is reached, and wherein a node may contain a sub-sequence of a key, against<br>
which a candidate key can be compared in order to determine an action to be taken, and in<br><br>
which the portion of the key stored at a node in an N+lth layer of the index is unrelated to<br>
the portion stored in the preceding node in the Nth layer.<br>
As used herein, the portion of the key at an (N+l)th node is unrelated to that at the Nth<br>
node in the sense that the key portion is not calculated by selecting successive parts of the<br>
key in a nominally varying manner.<br>
It is thus possible to provide a database wherein the decision nodes can be maintained<br>
relatively "small" since each node only stores a sub-sequence of a key rather than an entire<br>
key. This structure facilitates data base navigation, insertion and retrieval by pattern<br>
matching.<br>
According to a fourth aspect of the present invention, there is provided a database having<br>
an index and data, and wherein the index is queried using a search key in order to locate<br>
data matching the search criteria, characterised in that the index is a hierarchical structure<br>
of decision nodes, the structure being navigated until a conclusion set is reached, and<br>
wherein a node may contain a sub-sequence of a key, against which a candidate key can be<br>
compared in order to determine an action to be taken.<br>
Enhanced Pattern Matching<br>
Within the process of pattern matting, it is evident that the computational load in pattern<br>
matching is a function of the length of the pattern that is to be matched, and in particular<br>
that testing the match for a short character or symbol string is less computationally<br>
expensive than matching a long string.<br>
Furthermore the database/index efficiency also depends on how well the key population is<br>
divided at each node and how likely a sequence will appear within a query.<br>
This is best illustrated by considering two rather extreme examples. Supposing the index is<br>
organised by name of clients and other entities that a business may wish to correspond<br>
with.<br>
A pattern matching sequence that appears often will not sufficiently reduce the population<br>
of keys scanned during an index query. Thus, for example, if the sequence used in the<br><br>
pattern matching is "E", then given that this is likely to occur in most keys, it provides little<br>
help in dividing the key population.<br>
As a further extreme example, a sequence which occurs infrequently will also not reduce<br>
the population of keys that have to be scanned in most queries. Thus, for example, "ZZ" is<br>
unlikely to appear in a query and so is not a good candidate for a pattern matching query.<br>
As noted hereinabove, the more characters involved in a sequence, the less likely it is that<br>
the sequence will appear in a key. Thus a single character is likely to appear in a key with<br>
many characters whereas a specific sequence of four characters is much less likely to<br>
appear.<br>
In an ideal case, the query string would divide the population of keys reached from a node<br>
substantially evenly.<br>
A problem with the ASCII character set is that it is often difficult to find a suitable<br>
sequence using the full 255 characters in the set as there are many characters but the<br>
likelihood of some characters appearing is much greater than that of many other ones of the<br>
characters.<br>
However, combinations of dual characters can be rare.<br>
According to a fifth aspect of the present invention there is provided a method of storing a<br>
key or part thereof in an index of a database, wherein the elements of the key are mapped<br>
from a first set constituting a list of at least some of the values that the elements can take to<br>
a second set smaller than the first set<br>
Thus the number of different characters that can occur in the key is reduced. The mapping<br>
is not unique but if the mapping is appropriately selected the likelihood of any single<br>
character of the second set occurring can be reasonably high and combinations of two or<br>
more characters can be used for sequences.<br>
Preferably the mapping is applied to the key prior to navigation of the decision graph for<br>
insert, delete or query operations.<br><br>
Advantageously either the original key value or the converted key value (which is smaller<br>
in terms of the space required to store it) can be stored in the conclusion set<br>
According to a sixth aspect of the present invention, there is provided a database in which<br>
the keys are mapped to a reduced range of values prior to index navigation.<br>
Key Compression.<br>
As noted hereinabove, some prior art databases store the full decision/search key at each<br>
decision node. This can create a relatively large index structure given that the keys can<br>
themselves be large. It has also been noted that in a database constituting an embodiment<br>
of the present invention, the search keys do not need to be stored at each decision node,<br>
although it may be desirable to store a portion of the search key at a decision node. The<br>
option to store portions of the search key still results in a relatively compact database<br>
decision tree which can be navigated rapidly. However, the inventor has realised that the<br>
key does not need to be stored in the index in its native form. Thus the key may be<br>
encoded into a form which takes up reduced space.<br>
According to a seventh aspect of the present invention, there is provided a method of<br>
encoding keys within a database, wherein key data is stored in at least one conclusion set in<br>
an encoded form so as to reduce the storage space requirements of the keys.<br>
It is thus possible to provide a more compact conclusion set. The data base supports exact<br>
matching.<br>
It is important that the mapping function is well behaved, that is, that when the mapping<br>
function is applied to a particular key, it always returns the same result.<br>
However, it is not necessary that the mapping is unique. Indeed where the mapping<br>
algorithm gives a high degree of compression it becomes highly unlikely that the mapping<br>
will be unique.<br>
Advantageously at least two dissimilar mapping algorithms are used. The use of dissimilar<br>
mapping may be restricted to use in the conclusion sets.<br><br>
Known and published mapping algorithms, such as, for example CRC32 and Adler 32 may<br>
be used to implement the mapping functions.<br>
Preferably the mapping function is arranged to return a value from a range of positive<br>
integers (including zero) whose size is at least as large as the population of distinct keys<br>
held within the index. Thus each key has the potential to be mapped by the algorithm to<br>
another value and no keys are too long.<br>
For example the mapping can be calculated from a scalar of length N bytes using the<br>
following function:<br><br>
Where KN is the nth byte value (0..255) of key K<br>
R is the smallest power of 2 greater than the size of the population of distinct keys<br>
held in the index.<br>
Suggested values of R are<br>
216 for indexes containing less than 65000 keys.<br>
232 for indexes containing less than 4 X 109 keys.<br>
264 for indexes containing less than 1.8 X 1019 keys.<br>
Advantageously the key information stored at a conclusion set may be the conventional key<br>
as stored in prior art system, or preferably is a further encoded version of the key where the<br>
mapping function applied is different to the function used to encode keys in the decision<br>
graph.<br>
Qualifier<br>
An index query can lead to many key hits. Each result returned from the query may result<br>
in a retrieval of the associated data from a mass data storage device. Since this is typically<br><br>
a hard disk, then a disk I/O operation may be required for each result returned from the<br>
query.<br>
Not all of the data fetched may be required.<br>
Consider for example the case of a multinational organisation which wishes to query its<br>
personnel database in order to determine the number of employees based in London and<br>
within a specific salary range. An index based only on location or on salary might return<br>
many employees for a given query. It is only the resulted of the ANDed enquiry that<br>
reduces the query size.<br>
It is known to modify database indexes for mis type of query by storing more than one key<br>
in the index. Thus the key can be regarded as a compound or composite key. The chances<br>
of a candidate (i.e. an entry in the database) matching two keys is much reduced compared<br>
with the chances of a candidate matching one key, then the number of hits returned by the<br>
query is reduced and fewer disk I/O operations are required.<br>
It is known to make these composite keys by concatenating keys together. Put simply the<br>
second search criteria is added to the first at the time of index creation. However, the<br>
individual keys may be quite lengthy and producing an index of concatenated keys can<br>
result in the index becoming very large indeed.<br>
The applicant has realised that key data need not be stored in its original form but can in<br>
fact be encoded or represented by a word or bit sequence of significantly reduced length.<br>
The first key in the index, and every subsequent key in a concatenated key can be<br>
represented in such a modified form.<br>
According to an eighth aspect of the present invention, there is provided a method of<br>
organising a database, wherein the index key is a composite key containing at least one key,<br>
and in which one or more keys are represented in a compressed form.<br>
Preferably a plurality of keys are provided in compressed form.<br><br>
Preferably the keys are compressed by mapping them from an uncompressed form to a<br>
compressed form. The mapping need not be unique but must be well behaved. Suitable<br>
mapping can be performed by the use of hashing algorithms.<br>
There is, by the very feet that different keys can be represented by the same reduced<br>
representation, a risk that a query will return both results mat do match the query and some<br>
results that do not match, the query. However, assuming that a good randomising Hash<br>
encoding is used, the probability of a mis-match on one key is 1/255, but for N qualifiers<br>
the probability of a mis-match is (1/255)N.<br>
Thus, the error rate is generally small.<br>
Advantageously all hits returned are inspected so as to validate the data and remove any<br>
wrongly returned results.<br>
When performing insertion, deletion or retrieval, the new key must be compressed using<br>
the same key translation process as was used to build the index.<br>
Preferably each additional element after the first element of a concatenated key can be<br>
represented as a "qualifier". Each qualifier is preferably only 1 byte long.<br>
Thus, comparing the present invention with the prior art, a prior art concatenated key<br>
comprising eight key elements, each of eight bytes, occupies 64 bytes. In the present<br>
invention the principal key may be represented in an uncompressed format, thereby<br>
occupying 8 bytes, whilst the seven additional keys may be respectively represented a one<br>
byte qualifier. Thus the total key length is now only 15 bytes.<br>
The qualifier keys are optional, and none, any or all of the keys may be provided during an<br>
index query because they do not affect the navigation of the index structure. The testing of<br>
bits against the qualifier keys is performed when scanning the conclusion sets.<br>
It will therefore be appreciated that this aspect of the invention can be used with<br>
conventional database structures, such as a B-tree, or with the structures disclosed<br>
elsewhere in this application.<br><br>
Additionally qualifiers can be used in conjunction with an index where the information<br>
relating to a node is inferred from the position of a node rather than explicitly defined by or<br>
contained within the node itself (such as an index constituting an embodiment of the first<br>
aspect of the present invention).<br>
According to a ninth aspect of the present invention, there is provided a database wherein<br>
the index contains at least one key, and in which one or more keys are represented in a<br>
compressed form.<br>
Bounded Key<br>
As noted hereinbefore, the efficiency of data base indexes can be highly dependent upon<br>
the key characteristics used therewith, leading to potentially inefficient indexing systems<br>
where the key value is continually increasing or decreasing. An example of such an<br>
unbounded key is the date/time key that constantly increases with current time. As these<br>
keys are added to the index, they cause new areas of the index to be created, and as the old<br>
keys are deleted from the index they may cause fragmentation where obsolete areas of the<br>
index cannot be reused for new key values. It would be highly advantageous if the index<br>
structure could be organised in such a way that the use of an unbounded key did not cause<br>
the index to become unbalanced.<br>
According to a tenth aspect of the present invention, there is provided a method of<br>
navigating a database with a range of keys between a first key and a second key<br>
representing limits of the range, and wherein the keys mapped to a reduced range, and if the<br>
order of the keys is not preserved during the mapping a search is made of the mapped space<br>
greater than the larger of the keys and less than the smaller of the keys.<br>
Advantageously the key is operated on by a hashing or modulo function such that the keys<br>
are substantially equally distributed throughout the database. Thus, for example, an<br>
unbounded date/time (K) (which may, for example, be the number of milliseconds since 1st<br>
January 1970) is converted to (K modulo N) where N is the chosen modulo for the index.<br>
Thus the converter key value will always fall into the range 0 to (N-l).<br><br>
Preferably the modulo value applied to the keys is greater than or equal to the maximum<br>
number of distinct key values which would be held within the index. However it must be<br>
pointed out that this condition is not mandatory.<br>
Advantageously the conclusion sets (nodes at the end of the tree index) contain the key in<br>
the unmapped form. This reduces the possibility of error since the search key can men<br>
compared with key data in the conclusion set, both in their native form, such that mapping<br>
errors can be avoided.<br>
This invention can be applied to conventional B-tree or other indexes.<br>
According to a eleventh aspect of the present invention, there is a database including a<br>
method of coding unbounded keys for use within a data base, characterised in mat each key<br>
is processed by an operator which maps the key to a bounded range.<br>
Transient Keys<br>
There is sometimes a need to handle data whose validity or usefulness is limited to a<br>
certain time range, or other range of values. In prior art data bases, such "transient" data is<br>
handled much like normal data, and as a consequence it is usually necessary to explicitly<br>
delete obsolete transient key data or to remove sections of the index where such obsolete<br>
key data resides. Such operations can be very processor intensive and can incur a<br>
significance performance overhead within the database or can impose design constraints.<br>
According to an twelfth aspect of the present invention, there is provided a method<br>
managing keys within a data base, characterised in that the keys include a data field<br>
indicating a duration for which the key and its associated data should be maintained within<br>
the data base.<br>
Thus, some or all of the conclusion sets may be modified to include data indicating the<br>
duration for which a key and its associated properties can be considered valid.<br>
Preferably, expired keys are not actively removed from the conclusion sets, but they<br>
become available for overwriting by new data once they have expired. Thus, there is no<br>
need to explicitly delete transient keys and hence no performance overhead is involved in a<br><br>
deletion process. Rather, once the marker indicates that the data is no longer valid, the<br>
space that it occupies is made available for re-use.<br>
Although it would be possible to provide an explicit date and time marker for the data at<br>
which the information would no longer be detected within the conclusion set, this form of<br>
encoding could take up an unacceptably large amount of space. In a preferred embodiment<br>
of the present invention, me key is associated with an age unit, which gives a measure of its<br>
current age, and an age limit which indicates the age at which the data and key are no<br>
longer valid and become available for overwriting.<br>
Preferably the age unit is a variable, whose length represents the number of seconds in a<br>
single age unit The age limit represents the number of age units after which a key may be<br>
removed from the index.<br>
Advantageously each conclusion set contains an age base which is a date/time stamp of the<br>
most recently inserted/updated entry in that set. When the conclusion set is accessed, the<br>
age of each entry is calculated, and advantageously the results of the calculations are stored<br>
in an entry age field. A comparison may be made between the entry age and the age limit<br>
to determine when the entry can be overwritten.<br>
Determining the Duplicity of Scalar Data<br>
As noted hereinbefore, prior art (B-tree) decision graphs are navigated down to leaf blocks<br>
that hold the key value and pointer information. Navigating the decision index may require<br>
one or more disk input/output operations to find a chosen key. If the index is used to<br>
record the existence of unique key combinations, where duplicate combinations are<br>
frequent, then the disk structure of the index may be inappropriate for a high performance<br>
system.<br>
According to a thirteenth aspect of the present invention, there is provided a method of<br>
organising a data base such that it has a decision index and a key index, wherein the keys in<br>
the key index are stored in a compressed manner, and wherein a check may be made of the<br>
key index to see if the key exists prior to interrogating the decision index using the key.<br><br>
It is thus possible to provide an efficient memory base method for determining the<br>
existence of a key with an index, such that the need to search the index itself directly for<br>
the key can be avoided.<br>
Thus the invention effectively compliments a standard index structure by holding encoded<br>
key values in semiconductor memory. The existence of a key is checked to memory prior<br>
to searching the index. If a matching entry is found in memory, the key is rejected as a<br>
duplicate, otherwise an attempt is made to insert the entry into the index.<br>
In order to provide an efficient and compact structure, the key index uses a one way<br>
mapping function, such as a hash function. The features of the hash function or other<br>
mapping function, are such that;<br>
• Whenever the mapping function is invoked on the same key value more<br>
than once, the mapping function must consistently return the same value<br>
provided that no information within the key has been modified;<br>
• If two keys are deemed equal, then calling the mapping function on each of<br>
the two keys must produce the same result;<br>
It is not required that two unequal keys are mapped to dissimilar values,<br>
however, providing distinct results for unequal keys will improve the<br>
efficiency of the index.<br>
Published hash code algorithms, such as CRC 32 and Adler 32 may be used as they provide<br>
suitable functionality.<br>
In an implementation of the key index, the memory may be arranged as a homogeneous<br>
array of four byte elements. This array is known as the identity array. Preferably the<br>
number of elements in the identity array is 1.1 times or more the number of unique key<br>
elements held within the index structure. However, it follows that it is merely sufficient for<br>
the identity array to be at least as large as the index. Two hash functions, A and B, are used<br>
in conjunction with the array. The functions are selected such that;<br><br>
For any two unequal keys, K and L, where A(K) = A(L) it is unlikely that<br>
B(K) = B(L).<br>
For any two unequal keys K and L where B(K) = B(L), it is unlikely that<br>
A(K) = A(L).<br>
The hash function A is used to calculate the offset element (0.N) in the identity array for<br>
the key K using the following equation:<br>
Element number = ABS(A(K))modulo N<br>
Where ABS(..) returns the unsigned magnitude of a number and N is the number of<br>
elements in the identity array.<br>
This function is known as the element function E(K).<br>
Each element in the identity array stores B(K) where the element offset is given by E(K).<br>
A key (K) is deemed duplicate if the element at offset E(K) contains E(K). If the element<br>
contains any other value, the index structure must be searched to determine its duplicity.<br>
For an attempt to insert a key K into the index the following sequence of events occurs.<br>
Firstly E(K) is calculated. Then B(K) is calculated. If the element at E(K) in the identity<br>
array contains B(K), then the insert is rejected as a duplicate K. However, if the element at<br>
E(K) in the identity array does not contain B(K) then the element is overwritten with B(K)<br>
and a search is made of the index to determine if the key is a duplicate.<br>
The use of an identity array considerably reduces the storage area required to hold the list<br>
of the keys. If a data base had one million entries, and each key was 32 bytes long, then it<br>
would require over 32Mb of memory to cache the index in memory. However the<br>
equivalent identity array would only occupy 4.4Mb of memory.<br>
Organising Indexes bv Hierarchy<br>
As noted herein, prior art indexes typically use tree graphs with nodes containing one or<br>
more items of four key data. The tree graphs (decision graphs) are navigated down to leaf<br>
blocks (conclusion sets) that hold the key value and pointer information to the stored data<br><br>
structure. Navigating the index may require one or more disk input/output operations to<br>
find a chosen key. Disk access operations generally represent the highest performance<br>
overhead of the index since, in general, disk access is slow compared to memory access<br>
and data bottlenecks can occur. To mitigate this overhead, indexes are often partitioned<br>
with each partition assigned to a different physical disk, thereby allowing disk I-O"s to be<br>
overlapped during index operations to increase the overall throughput of the index. This<br>
method of subdividing the index presents a flat one dimensional view of index division.<br>
According to a fourteenth aspect of the present invention, there is provided a data base<br>
index divided in a hierarchical structure such that an index may delegate some of its<br>
workload to one or more other indexes.<br>
Preferably a delegate index may itself delegate some of its work load to one or more other<br>
indexes.<br>
An index participating in such a hierarchy of indexes is responsible for a range of sub keys.<br>
Where such an index is handling a sub-range of keys on behalf of another index, it is<br>
known as a delegate index, and its key sub-range is known as a key manifest<br>
Preferably the key manifest of an index is defined by limiting a contiguous subset of bytes<br>
within the key to a contiguous range of possible values. Any attempt to insert, delete or<br>
update or search for a key that does not conform to an index key manifest is rejected by an<br>
index, otherwise the key operation is handled by the index or one of its delegate indexes.<br>
The hierarchy may be arranged such that each index may have a zero, one or more delegate<br>
indexes, but each index may only be a delegate to one other index.<br>
Where an index has one or more delegate indexes, an operation to insert, update or delete a<br>
key is submitted to the delegate index with the appropriate key manifest. If none of the<br>
delegate indexes have an appropriate key manifest, then the operation must be handled by<br>
the index itself.<br>
Where an index has one or more delegate indexes, an operation to search for a key range is<br>
submitted to all of the delegate indexes with appropriate key manifests and the search is<br>
made by the index itself. The query results from the search delegate indexes are combined<br><br>
with the result from the index"s own search. All of the queries can be performed<br>
simultaneously. It is thus possible to modify an index structure such that work can be<br>
subdivided across various sub-indexes therein. Each sub-index may point to an associated<br>
physical storage device thereby allowing multiple concurrent disk accesses to occur. This<br>
reduces the disk bottleneck and allows fester operation of the data bases as whole.<br>
The present invention will further be described, by way of example, with reference to the<br>
accompanying drawings, in which:<br>
Figure 1 is a schematic overview of the present invention;<br>
Figure 2 is a schematic representation of the logical structure of a decision graph;<br>
Figure 3 schematically illustrates the structure of a decision node;<br>
Figure 4 schematically illustrates the structure of a conclusion set;<br>
Figure 5 schematically illustrates the structure of an entry in a conclusion set<br>
Figure 6 schematically illustrates an exact search procedure.<br>
Figure 7 schematically illustrates a range search procedure.<br>
Figure 8 schematically illustrates the procedure for inserting a key;<br>
Figure 9 schematically illustrates the procedure for deleting a key;<br>
Figure 10 schematically illustrates the procedure for an exact key query;<br>
Figure 11 schematically illustrates the procedure for a range of query; and<br>
Figure 12 schematically illustrates the procedure for traversing a node with a decision<br>
group G, decision value V, to minimum and maximum key ranges, and returning a result.<br>
Figure 13 shows the structure of a portion of a decision graph.<br>
Figure 14 shows the logical structure of a modification decision node.<br><br>
Figure 15 shows the procedure for inserting a key.<br>
Figure 16 shows the procedure for deleting a key.<br>
Figure 17 shows the procedure for an exact query match.<br>
Figure 18 shows the procedure for traversing the tree with a pattern list and returning the<br>
result<br>
Figure 19 shows the procedure for a search of a pattern list (L).<br>
Figure 20 is an example of how a pattern match process helps in sorting data.<br>
Figure 21 is a schematic illustration of a decision graph having a bounded index;<br>
Figure 22 shows the structure of a modified conclusion set;<br>
Figure 23 schematically illustrates a first way of splitting a decision graph;<br>
Figure 24 schematically illustrates a second way of splitting a decision graph; and<br>
Figure 25 schematically illustrates the configuration of a composite key having qualifiers<br>
therein.<br>
Figure 1 schematically illustrates a database incorporating an index constituting an<br>
embodiment of the present invention and a data store. The index 2 comprises a decision<br>
graph 4 and a plurality of conclusions sets, 6, 8, 10, 12 and 14. Each conclusion set is<br>
reached by one, and only one, path through the decision graph. However each conclusion<br>
set then points to relevant entries within a data store 16.<br>
Figure 2 schematically illustrates the structure of a decision graph, generally indicated 20.<br>
The decision graph commences at an origin 22. All navigation through the decision graph<br>
must start at the origin. The origin may have zero (for example when the database is new),<br>
one or two decision pointers pointing to further nodes within the decision graph or to<br>
conclusion sets. Each other decision node may contain 0, 1 or 2 decision pointers, with<br>
each decision pointer pointing to either another decision node or to a conclusion set. The<br><br>
decision pointers at a decision node will be referred herein to as "the low pointer" and "the<br>
high pointer".<br>
A decision pointer at any decision node in the decision graph can only point to either one<br>
other decision node in the same decision graph or to a single conclusion set Any decision<br>
graph node must be pointed to exactly by one other decision node within the same decision<br>
graph or by the origin. Similarly, any conclusion set must be pointed to exactly by only<br>
one decision node within the decision graph. Thus any conclusion set can only be reached<br>
by following a single and unique path through the decision graph from the origin. This<br>
unique path in known as a navigation path.<br>
Figure 3 schematically illustrates the logical structure of a decision node, generally<br>
indicated 40, in greater detail. The decision node includes a low pointer type, a low<br>
pointer, a high pointer type and a high pointer. The low pointer type 41 indicates the<br>
purpose of the low pointer 42. The low pointer type 41 can indicate whether low pointer<br>
42 points to a decision node or to a conclusion set The low pointer 42 gives the address of<br>
the decision node or of the conclusion set that it points to. A zero value can be inserted to<br>
indicate that no pointer exists. Similarly, a high pointer type 44 indicates whether the high<br>
pointer 45 points to a decision node or a conclusion set The high pointier indicates the<br>
address of the decision node or the conclusion set that it points to. Again, a zero value can<br>
be used to indicate that no pointer exists. This enables the "tree" like structure of the<br>
decision graph to be represented and stored with a data processor and its memory.<br>
Figure 4 schematically illustrates the structure of a conclusion set A conclusion set<br>
comprises a plurality of key and property entries, 60, 62, 64, 66 and 68 each linked together<br>
by a directed link giving the address of the next entry in the conclusion set. Figure 5<br>
schematically illustrates the logical structure of each entry within the conclusion set. The<br>
entry consists of three fields, namely a link field 80, a key field 82 and a property field 84.<br>
The link field points to the next conclusion set entry. The zero value can indicate that there<br>
are no more entries. The key field 82 holds the exact value of a key whereas the properties<br>
field 84 holds the properties associated with that key for example the address of the data<br>
corresponding to the key field 82. Having defined the components of the index, there<br>
follows a discussion of how to use and navigate the index.<br><br>
In order to navigate along the index, each decision node visited along a navigation path<br>
refers to one or a group of bits within the key. This group of bits is known as a "decision<br>
group" the number of bits in the decision group can be set to include any number of bits<br>
between a single bit and all the bits of the key.<br>
The range of possible values taken by the decision group is known as the "decision range"<br>
and is bounded by a decision range minimum value and a decision range maximum value.<br>
The decision range minimum value may be any value less than all bits set in the decision<br>
group, and similarly the decision range maximum value may be any value greater than the<br>
decision range minimum For convenience, minimum and maximum values may be<br>
represented in an unsigned magnitude notation system.<br>
Each decision node has an associated decision value. The decision value determines<br>
whether a low pointer or high pointer is followed when navigating through the decision<br>
node. The high pointer is used when the value of the examined decision bit group in the<br>
key is greater than the decision value, otherwise the low pointer is used.<br>
Comparison of the decision value is advantageously performed using unsigned magnitude<br>
notation. The decision value can be set to any value chosen by the system manager,<br>
designer or operator, but advantageously is selected from one of the following:<br>
1. The mathematical median of all possible values of the decision group.<br>
2. The mathematical median of all the expected values of decision groups.<br>
3. The mathematical average of all the expected values of the decision group.<br>
4. An arbitrary value specified at the time of creation of the index.<br>
5. The median of the current decision value (ie the most recently used decision value)<br>
and the decision value preceding it.<br>
The selection of a decision group at a visited decision node can, advantageously but not<br>
necessarily, be based on one or more of the following:<br>
i. The decision group may be the same for all the decision nodes.<br><br>
ii. The decision group may be changed on every visit to a decision node.<br>
ill. The decision group may be changed when the decision value from the previous<br>
decision node reaches or approaches the decision range maximum or decision range<br>
minimum of the current decision group.<br>
iv. The decision group may be changed when the decision value between successive<br>
nodes would change by less than one unit or by less than some other predetermined<br>
threshold.<br>
The size of me decision group at a decision node may be determined on the basis of one or<br>
more parameters. The size of a decision group may, for example, be fixed for all decision<br>
nodes. However, the size may be increased from the previous decision group when a new<br>
decision group is selected or, alternatively, the size may be decreased from the previous<br>
decision group when a new decision group is selected.<br>
The position of a decision group, relative to the key, at a decision node can be based on one<br>
or more of the following. The position of the decision group may be fixed for all decision<br>
nodes. Additionally and/or alternatively, the position of the decision group may be a fixed<br>
offset from the previous decision group when a new decision group is selected.<br>
Advantageously further constraints may be imposed if the index is to support key retrieval<br>
by range matching. In particular the most significant bit must be included within a<br>
hierarchically significant node, such as the origin. Then the significance of the decision<br>
group within the overall key should then be changed in a monotonic manner of decreasing<br>
significance.<br>
It is advantageous to consider some examples of how the index may be navigated. Figure 6<br>
shows how a four byte key can be navigated in an exact match search. In this example the<br>
keys are stored in ASCII coding and the numbers shown against each key show its value in<br>
hexadecimal notation. In this example, each decision group has a fixed size of four bits.<br>
The decision group is moved sequentially down to the next four less significant bits at each<br>
new node visited, in this example, the most significant bit is designated zero, the next<br><br>
most significant bit is one, the next most significant two, and so on. Furthermore, for<br>
simplicity, the decision value applied at every node is four. Thus, if the decision group has<br>
the value zero, one, two, three or four the graph is traversed to the left. However, if the<br>
decision group has a value of the range of five to fifteen the graph is traversed to the right<br>
As shown in Figure 6, a number of names are presented to the database. These names or<br>
key values, are Fred, John, Bill, Zoe, Eric and Pete. The hexadecimal equivalent of each<br>
key is located adjacent the name. The navigation process that will be described is suitable<br>
for insertion, deletion or matching.<br>
Initially the keys are presented to a first decision node 100 at which bits zero to three are<br>
tested Since each hexadecimal word occupies one byte, it is apparent that bits zero to<br>
three correspond to the first character in the keys. Thus, as Fred, John, Bill and Eric all<br>
start with a "4" mere keys are propagated leftwardly along the branch 102 to a second level<br>
node 104. However bom Zoe and Pete have an initial four bits falling outside of the range<br>
zero to three, and consequently their keys are propagated along a high pointer path 106 to<br>
node 108.<br>
The nodes 104 and 108 occupy me second level of the decision graph and consequently<br>
their decisions are based on the next four bits in the key. This corresponds to looking at the<br>
next character in the hexadecimal representation. Thus the node 104 Bill is passed along a<br>
low level pointer 110 to a subsequent node (not shown) as bits 4 to 7 in the key encode the<br>
value 2, whereas Fred, John and Eric are passed along a high level pointer 112 to a further<br>
node (not shown) because bits four to seven in their key encode the values 6, A and 5<br>
respectively in hexadecimal notation. Similarly, at node 108, the key Pete is passed along a<br>
low level pointer 114 as bits 4 to 7 therein encode the value zero, whereas Zoe is passed<br>
along a high level pointer 116 as bits 4 to 7 encode the value "A". This process can be<br>
repeated until sufficient of the key has been searched to reach a conclusion set.<br>
Figure 7 schematically illustrates how a four bite key can be navigated in a range match<br>
search. As with Figure 6, keys are stored in ASCII coding and the ASCII values against<br>
each key to show its value in hexadecimal notation.<br><br>
In this example, the decision group has a fixed size of eight bits. The decision group is<br>
moved down to the next eight less significant bits only when the decision range is<br>
exhausted; that is, when the decision value reaches either boundary of the decision range.<br>
In this example, the most significant bit is designated bit zero, the next most bit one, and so<br>
one as was the case with the example shown in Figure 6. The decision range at every node<br>
is 30 to 50 hexadecimal in order to cover all digits and uppercase letters represented in the<br>
ASCII format The decision value at every node used for a new decision group is 48<br>
hexadecimal, and is men changed to be the average of the previous decision values of the<br>
same decision group at each subsequent node for that same group. Where only one<br>
previous decision value is known, then the minimum or maximum bound of the decision<br>
value range is used depending on whether we have just navigated the left or the right<br>
respectively.<br>
Using the same keys as in the previous example, the keys are presented to a first node 118<br>
which examines the first eight bits, zero to seven, and compares them against the decision<br>
value 48 (hexadecimal). With the keys as shown, Fred, Bill and Eric pass along a low<br>
pointer to node 122, whereas John, Zoe and Pete along a high pointer 124 to node 126.<br>
At node 122, it becomes necessary to change the decision value. The decision value used<br>
for this new decision group is changed to the median value of the previous decision groups<br>
reached along the same path. Whereas only one previous decision value is known, as in<br>
this case, the minimum or maximum bound of the decision value range is used. Given that<br>
four node 122 was navigated against the low pointer 120, then the lower bound of the<br>
decision range is used.<br>
Thus, in order to calculate the new decision value it is required to find the median of the<br>
numbers in the range 30 hexadecimal to 48 hexadecimal explicitly, this group of numbers<br>
is 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 3A, 3B, 3C, 3D, 3E, 3F, 40, 41, 42, 43, 44,45, 46,<br>
47 and 48. From this, it can be seen that the median value is 3C. Setting this as the<br>
decision value, Fred, Bill and Eric all proceed along the high pointer 127. To the next node<br>
(not shown) whose decision value will be the median value of the range extending from 3C<br>
hexadecimal to 48 hexadecimal.<br><br>
Similarly, node 126 reached along the high point 124 from node 118 has a new decision<br>
value calculated, which in this instance will be 4C (hexadecimal). Applying the key at this<br>
node, John will pass to the left (low pointer) because it contains the value 4A which is less<br>
than the decision value of 4C, whereas Zoe and Pete pass to the right hand (high pointer)<br>
because they contain the value 5A and SO, respectively, which is greater than the decision<br>
value 4C.<br>
A further example of searching can be seen in the context of character searching, thus a<br>
search is performed using the following criteria:<br>
• An exact match index on an ASCII character key with each character<br>
occupying 8 bits and being in the range "A" to "Z" only.<br>
• A fixed decision group of S bits.<br>
• A decision graph origin of the most significant 8 bits (the 1" character)<br>
• The decision group advances by 8 bits (one character) for each decision node.<br>
The ASCII codes for "A" and "Z" are 65 and 90 respectively. Therefore a sensible decision<br>
value for mis group is the median value (i.e. 78).<br>
In this example, the decision group advances by one character (8 bits) every time that a<br>
new decision node is reached. A comparison is made of the value of the bits in the<br>
decision group within the key to the fixed decision value (78) to determine which pointer to<br>
follow.<br>
A more sophisticated approach involves changing the decision value at each move to a new<br>
decision node. Thus, the decision range for a decision group is limited by the decision<br>
range minimum and decision range maximum, which are 65 to 90 respectively. When<br>
moving to the next decision node, an operator may choose to select the new decision value<br>
by using the median of the current and previous decision value. When this is a new<br>
decision group and no previous decision value is available, then we may use the decision<br>
range value minimum or maximum (depending on whether a low or high pointer was<br>
followed, respectively). The selection of a new decision group may be made when the<br><br>
decision value changes by less than 1 or some other predefined threshold. An example of<br>
how a decision value changes is given below.<br>
Decision group in the key has a value of 82. The starting decision value for a new group is<br>
78. The decision range is 65 to 90. The decision group has been set such that a new group<br>
is selected when the decision value changes by less than 1.<br><br>
It should be noted that indexes which are not required to support key retrieval by range<br>
matching are not so heavily constrained as those that do. In particular indexes thai are not<br>
required to support range matching can have any decision group at its origin, and can<br>
change the decision group position arbitrarily and can also change decision groups<br>
arbitrarily when the decision value gets close (as may be defined by the system designer or<br>
as may be selected by a user or some management function) to the decision range limits,<br>
that is the maximum and minimum values of the decision range, or decision value changes<br>
by less than a preselected amount.<br>
When traversing a navigation path for the purpose of inserting, deleting or retrieving a<br>
candidate key, the decision group of the candidate key is compared at each decision node<br>
visited with the decision value of the decision node and the low pointer or high pointer is<br>
followed to the next decision node or conclusion set. Once a conclusion set has been<br>
reached the journey along the navigation path is complete. The journey along the<br>
navigation path is also complete when a decision group value indicates the use of a<br>
decision pointer that does not exist.<br><br>
A conclusion set consists of a series of keys and associated properties. The number of keys<br>
contained within a conclusion set is limited by an upper bound which can be determined by<br>
one or more of a combination of:<br>
1. A fixed limit;<br>
2. A limit specified at the time the index is created;<br>
3. A limit that can be specified throughout the lifetime of the index; and<br>
4. A limit that varies as a function of index growth.<br>
Figure 8 illustrates the procedure for inserting a key (K) with properties (Q). The<br>
procedure commences at step ISO where the index is entered at its origin with a default or<br>
initial decision group, DG, as set by the designer. An algorithm is implemented in order to<br>
calculate a start decision value D Vo. Control is men passed to step 152 which tests whether<br>
the decision group in the key is greater than the decision value, if the test is satisfied,<br>
control is passed to step 154 where the high pointer HP is examined and a new decision<br>
value DVi is created.<br>
From step 154 control is passed to step 156 where a check is performed to see that the<br>
pointer (whether this be a high pointer or a low pointer) exists. Similarly, if step 152<br>
indicates that the decision group in the key is not greater than the decision value, then<br>
control is passed to step 158 where the low pointer is examined and a new decision value<br>
DVi is calculated. Control passes from step 158 to step 156. From step 156, control is<br>
passed to step 160 provided that the pointer exists. Step 160 tests to see if the pointer<br>
points to a further decision node. If the pointer does point to a decision node, then control<br>
is passed to step 162 which advances the test to the next decision node. From step 162<br>
control is passed to step 164 which performs a test to see whether the decision group<br>
should be changed. If the answer to this test is yes, then control is passed to step 166<br>
which calculates the value of the new decision group in accordance with the criteria as set<br>
out hereinabove. Control is then passed from either step 164 or 166 back to step 152.<br>
If step 156 determines that a pointer does not exist, control is passed to step 170 to cause<br>
the creation of a new conclusion set and then to step 172 which updates the pointer to point<br><br>
to the new conclusion set. Control is then passed to step 174 which adds the key and its<br>
properties to the conclusion set<br>
Furthermore, if step 160 does not point to a decision node, then it must point to a<br>
conclusion set and control is passed to step 176 which causes a jump to be made to the<br>
relevant conclusion set and from men to step 174 such mat the key and its properties are<br>
added to the conclusion set<br>
A test is made at step 175 to see whether the conclusion set has exceeded its size limit If<br>
the conclusion set has not grown too large, control is passed to step 178 which represents<br>
an exit from the key insertion procedure, however if the conclusion set has reached its size<br>
limit then control is passed to step 180 which creates a new decision node with no pointers.<br>
From step 180 control passes to step 182 which updates the pointer of the previous<br>
decision node to point to the new decision node rather than the old conclusion set Control<br>
is then passed to step 184 which examines the old conclusion set CS(S) to see if it is<br>
empty. If it is not empty control is passed to step 186 which goes to the first key and<br>
property entry in the conclusion set CS(S) and re-navigates the index in order to find the<br>
new conclusion set into which this entry should be placed. Once the entry has been<br>
reallocated to a conclusion set, it is removed from its current conclusion set CS(S) at step<br>
188. Control is then returned to step 184 and the process is repeated until such time as the<br>
conclusion set CS(S) is empty. Control is men passed to step 190 which represents an exit<br>
point from the key insertion procedure.<br>
Thus, in general, the procedure for inserting a key and its associated properties into the<br>
index requires the navigation along the decision path for the key to be inserted. If the<br>
navigation path terminates without arriving at a conclusion set, then a new conclusion set<br>
has to be created and a decision pointer updated such that it points at the new conclusion<br>
set The new decision pointer must be placed in the decision graph at the point that<br>
traversal of the decision graph terminated. However, if the navigation path terminates at a<br>
conclusion set, then the key and its properties are inserted into this conclusion set. Each<br>
modification of a conclusion set varies the size of that set. Thus, if a new key is inserted<br>
into a conclusion set and this causes or would cause the set to exceed its upper bound, then<br>
a new decision node has to be created. A new decision group and/or decision value has to<br><br>
be associated with the new decision node and the decision pointer which previously<br>
pointed to the full conclusion set has to be amended to point to the new decision node.<br>
Then every item from the old (now full) conclusion set has to be reinserted into the new<br>
conclusion set or sets following the navigation path along the index.<br>
The data in the database will evolve over time and this evolution will include the deletion<br>
of keys and data, either because the data is no longer relevant to the data base or because it<br>
needs to be removed for archiving purposes in order that the "live" version of the database<br>
does not become cluttered with irrelevant or obsolete data. Figure 9 schematically<br>
illustrates the procedure for deleting a key. Some of the steps are identical to those which<br>
were described with respect to Figure 8, and consequently these steps have been given the<br>
same reference numerals. Thus steps 150 to 166 are identical to those already described,<br>
with the exception that if the test made at step 156 indicates that the pointer does not exist,<br>
then control is passed to step 200 which represents an exit from the deletion procedure.<br>
Step 160 passes control to step 176 if the test at step 160 determines that the pointer does<br>
not point to a decision node (as was the case with the procedure for inserting a key). From<br>
step 176 control is passed to step 202 where a test is performed to see if the conclusion set<br>
CS(S) is empty. If the conclusion set is empty, control is passed to step 204 which<br>
represents an exit from the procedure otherwise control is passed to step 206 which<br>
implements a scan through the entries in the conclusion set. The scan commences with the<br>
first key (L) in the conclusion set and control is then passed to step 208 where a test is<br>
made to see if the key (L) is equal to the deletion key. If it is, control is passed to step 210<br>
where the key (L) and its properties are deleted from the conclusion set. From step 210<br>
control is passed to step 214 where a test is made to see if the key (L) is the last key in the<br>
conclusion set Control is also passed to step 214 from step 208 if the key (L) is not the<br>
same as the deletion last key. Control is then passed to step 216 where the next key is<br>
selected and control is then passed to 208. Otherwise, control is passed from step 214 to<br>
step 218 which represents an exit from this procedure.<br>
Thus, in general terms, to delete a key and its associated properties from the index requires<br>
the navigation along the navigation path for the key to be deleted. If the navigation path<br>
terminates without arriving at a conclusion set, then it is deemed that the key does not exist<br><br>
in the index. However, if the navigation path terminates at a conclusion set, then a scan<br>
must be commenced through a conclusion set for all keys which are exactly equal to the<br>
key to be deleted. These keys and their associated properties are then removed from the<br>
conclusion set.<br>
Figure 10 shows the procedure for an exact query of a key, and for returning the result<br>
The procedure shares a great many similarities with the procedure for deleting a key and<br>
steps ISO to 206 are as described with reference to Figure 9. However, an additional step<br>
1S1 is inserted between the steps ISO and 1S2 in which a result set (R) is reset to the empty<br>
condition. Following navigation of the index to the conclusion set at step 202, control is<br>
passed to step 206 which initiates a sequential scan through the conclusion set From step<br>
206, control is parsed to step 230 where a test is made to see if the key (L) currently being<br>
examined is equal to the search key. If yes, control is passed to step 232, otherwise control<br>
is passed to step 234. At step 232 the key and its properties are added to the search query<br>
result list (R), control is then passed to step 234. Step 234 tests to see if the key currently<br>
being examined is the last in the conclusion set If no, the next key is examined and<br>
control is passed to step 230. If the key is the last key, control is passed from 234 to step<br>
236 which represents an exit from mis routine.<br>
Figure 11 schematically illustrates the procedure for performing a range query with a<br>
minimum key value (I) a maximum key value (A) and for returning the result (R). The<br>
procedure commences at step 300 where the results set (R) is reset to a null or empty<br>
condition. Control men passes to step 302 where the decision group and decision values<br>
are calculated and from then on control is passed to step 304 where the index is traversed in<br>
order to find those results which match the range query. The procedure for traversing the<br>
index is shown in greater detail in Figure 12. The procedure commences at step 350 where<br>
the procedure is entered at its starting node. Control then passes to step 352 where a test is<br>
made to see if the minimum key is less than or equal to the decision value (or omitted) and<br>
if the maximum key is greater than its associated decision value (or omitted). If the result<br>
of the test is such that both conditions are satisfied control passes to step 370 otherwise<br>
control passes to step 354. Step 370 checks to see whether a low pointer has been set, if it<br>
has control passes to step 372 where a check is made to see if the low pointer points to a<br>
conclusion set. If yes, control is passed to step 400. If no, control is passed to step 374<br><br>
where the decision group and decision values are recalculated and used to traverse the<br>
index from the node reached via the pointer. The procedure has the capability to call itself,<br>
and as such is recursive. Control then passes to step 376 where a check is made to see if a<br>
high pointer exists, if no, control is passed to step 378 which represents an exit, and if yes,<br>
control is passed to step 390 where a test is made to see if the high pointer points to a<br>
conclusion set, if yes, control is passed to step 400, whereas if the high pointer does not<br>
point to a conclusion set control is passed to step 392 where a new decision group and<br>
decision value are calculated and farmer traversal of the index is performed taking the new<br>
node as a start node.<br>
Returning to near the beginning of the procedure, in those instances where step 352 has<br>
passed control to step 354, step 354 performs a test to see if both the minimum key value<br>
and the maximum key value are less than or equal to the decision value. If they are, control<br>
is passed to step 356 otherwise control is passed to step 358. Step 356 performs a test to<br>
see if a low pointer exists, if it does not, control is passed to 357 which represents an exit<br>
from the procedure otherwise control is passed to step 360. Step 360 tests to see if the low<br>
pointer points to a conclusion set, if yes, control is passed to step 400 otherwise control is<br>
passed to step 402 which recalculates the decision group and decision value and invokes<br>
the traversal procedure in a recursive manner. Returning to step 358, a test is performed to<br>
see if the high pointer does exist, if yes, control is passed to step 362 otherwise control is<br>
passed to step 364 which represents an exit from the procedure. Step 362 performs a test to<br>
see if the high pointer points to a conclusion set, if yes, control is passed to step 400,<br>
otherwise control is passed to step 364 which calculates a new decision group and decision<br>
value and causes further traversal of the index to be performed starting from these new<br>
values.<br>
Step 400 performs a test to see if the conclusion set (S) is empty, if yes, control is passed to<br>
step 404 which represents an exit from the procedure. If the conclusion set is not empty,<br>
then a sequential scan of those entries in the conclusion set is initiated, starting at step 406<br>
where the first key in the conclusion set is selected. Control is then passed to step 408<br>
where a test is performed to see if the key (L) is within the range defined by the minimum<br>
and maximum key values. If the result of the test is "yes" then the key and its properties<br>
are added to the conclusion set (S) at step 410 whereas if the test at step 408 is negative<br><br>
control is passed to step 412 in which a test is made to see if the key currently under<br>
consideration is the last key in the conclusion set, if it is, control is passed to step 414<br>
which represents an exit from the procedure. Step 410 also passes control to step 412. If<br>
the test at step 412 determines that the key under consideration is not the last key, then the<br>
next key in title conclusion set is selected at step 416 and control is returned to step 408.<br>
Thus, in general terms, retrieving keys and their range properties by a range match using an<br>
optional minimal search key value and an optional maximum search key value requires<br>
recursive traversal of the decision graph from the origin, with the continued comparing of<br>
the decision group bits in the minimum and maximum search keys with the decision value<br>
at each decision node. If the unsigned magnitude of the minimum search key bits in the<br>
decision group is less than or equal to the decision value and the unsigned magnitude of the<br>
maximum search key bits in the decision group is greater than the decision value then,<br>
firstly, action is taken to traverse the decision graph reached from the low pointer using the<br>
minimal search key and omitting the maximum search key; and secondly actions are taken<br>
to traverse the decision graph reached from the high pointer using the maximum search key<br>
and omitting the minimum search key.<br>
If the unsigned magnitude of the minimum search key and the maximum search key bits in<br>
the decision group are both less man or equal to the decision value, men a traverse of the<br>
decision graph reached from the low pointer using both the minimum search key and the<br>
maximum search key is performed. If the unsigned magnitude of the minimum search key<br>
and the maximum search key bits in the decision group are both greater than the decision<br>
value, then a traverse of the decision graph reached from the high pointer using both the<br>
minimum search key and maximum search key is performed.<br>
It is apparent that multiple and repeated traversals of the decision graph are required. If all<br>
of the navigation paths resulting from the traversals terminate without arriving at a<br>
conclusion set, then it is deemed that no matching keys exist in the index. For those<br>
navigation paths which terminate at a conclusion set, then a scan through all of the keys in<br>
the conclusion sets is performed and all keys which match the required properties within<br>
the search range are returned as search results.<br><br>
As part of the implementation of the database within a data processor and storage system, it<br>
is advantageous, although not mandatory, that the size of the conclusion set should be an<br>
integer multiple of the storage device block transfer size, this provides optimal usage of the<br>
physical memory. It is also advantageous, though not mandatory, that the decision graph<br>
be divided into blocks that are of a size which is an integer multiple of the storage device<br>
block transfer size. This has the advantage that, when a decision block becomes full, a new<br>
block can be created and new decision pointers can point into the new block as appropriate.<br>
In order to achieve rapid operation of the database, it is advantageous that the decision<br>
graph be wholly or partially held, hi use, within the semiconductor memory of the data<br>
processing system, thereby avoiding the time overheads associated with disk access. As a<br>
further enhancement, it is also preferable that the conclusion sets be stored within the<br>
semiconductor memory, or that at least, once a conclusion set has been identified, it is<br>
swapped into semiconductor memory such that the sequential scanning of the conclusion<br>
set can be performed quickly.<br>
The optimal configuration for range matching of all key types is to use a decision bit group<br>
of one bit with a fixed decision value of zero. The decision group at the origin is the most<br>
significant bit and the decision group advances by one bit (towards the least significant bit)<br>
for every decision node visited. For numeric or date/time exact key matching, the optimal<br>
bit configuration seems to be to use a decision bit group of one bit with a fixed decision<br>
value of zero. The decision group at the origin is the least significant bit and the decision<br>
group advances by one bit (towards the most significant bit) for each decision node visited.<br>
For the searching of ASCII based keys, the optimal bit configuration for exact matching is<br>
to use a decision group of eight bits. The optimal decision values will depend upon the<br>
range of expected characters.<br>
Pattern Matching<br>
The database structure described with reference to the proceeding Figures relates to a<br>
structure where the decision nodes do not contain any key data whatsoever. However, it is<br>
possible to modify the database structure such that one or more nodes contains a partial key<br>
sequence. This facilitates the indexing and retrieving of scalar data by pattern matching.<br>
The tree structure is still small compared to prior art data bases since each decision node<br><br>
need only contain a relatively modest amount of data rather than the entire key as is the<br>
case with prior art systems.<br>
The data base structure requires only minor modification from that already described<br>
herein. Figure 13 shows the structure of the decision graph which, in many ways, maintains<br>
the same layout as was shown in Figure 2. However, the origin and each decision node<br>
now contains a bit sequence. The bit sequence represents part of the sub-key against which<br>
a candidate key is compared. The logical structure of each decision node is shown in<br>
Figure 14. The structure is very reminiscent to that described with respect to Figure 3. The<br>
node, generally designated 440, has a storage region 450 for a decision bit sequence. The<br>
decision bit sequence can be of any length. However, the important to note mat, in general,<br>
the decision bit sequence will be significantly shorter than the length of the key presented<br>
to the decision tret. The node includes an exclusion pointer type 452 and an inclusion<br>
pointer type 456 which indicate whether their associated exclusion pointers or inclusion<br>
pointers point to a further decision node or to a conclusion set. Thus these pointers<br>
perform the same function as the low pointer type and high pointer type 41 and 44,<br>
respectively, described with reference to Figure 3. The exclusion pointer 454 and an<br>
inclusion pointer 458 point to the address of the next node or conclusion set following the<br>
present node. Thus, the pointers 454 and 458 are analogous to the low pointer and high<br>
pointer 42 and 45, respectively, described hereinbefore. However, the change of<br>
terminology merely clarifies the feet that one pointer is followed if the candidate key<br>
contains the decision bit sequence, whereas the other pointer is followed if the candidate<br>
key does not contain the decision bit sequence.<br>
Figure 15 shows the procedure for inserting a key into the tree structure. This procedure is<br>
very similar to that described with respect to Figure 8, and like reference numerals have<br>
been used for like parts for brevity. However, step 152 is modified to become step 152" as<br>
the test is changed to see whether the decision bit sequence at a decision node is contained<br>
within the key, if yes, control is passed to step 154" where the inclusion pointer is<br>
followed. Control then passes to step 156. If step 152 finds that the decision bit sequence<br>
is not in the candidate key, then control passes to step 158" where the exclusion pointer is<br>
followed. A further modification to the procedure is that step 162 can point directly to the<br><br>
input of step 152", thereby omitting steps 164 and 166. However, otherwise the key<br>
insertion procedure is as hereinbefore described.<br>
The procedure for deleting the key, as shown in Figure 16, is also very similar to that<br>
described hereinbefore and once again, like reference numerals are used for like parts. As<br>
was the case with the procedure for inserting the key, steps 152, 154 and 158 are modified<br>
to become steps 152% 154" and 158" as described with reference to Figure 13, such that<br>
steps 152 tests to see whether the candidate key includes me decision bit sequence, and if<br>
yes, the inclusion pointer is followed, and if not, the exclusion pointer is followed.<br>
Additionally, step 162 now points directly to the input of step 152", thereby omitting step<br>
164 and 166.<br>
The index can, of course, be navigated for exact query matching of the key. Figure 17<br>
illustrates the navigation procedure for returning an exact query of the key. The procedure<br>
is very similar to that described with reference to Figure 10 and, as before, like reference<br>
numerals will be used for like steps in order to avoid repetition, and except for the fact that<br>
steps 152, 154 and 158 are modified such mat step 152" now compares the candidate key<br>
with the decision bit sequence, and if the decision bit sequence is within the candidate key,<br>
control is passed to step 154" where the inclusion pointer is followed, otherwise control is<br>
passed to 158" where the exclusion point was followed. Additionally, step 162 now points<br>
directly to the input of step 152".<br>
Figure 18 shows the procedure for traversing from a node with a pattern list (L) and<br>
returning a result (R). The procedure starts at step 500 where a start node is entered.<br>
Control is then passed to step 502 where a test is made to see if the decision bit sequence is<br>
contained within the pattern list (L). If the result of this test is negative, then control is<br>
passed to step 504 where a test is made to see if an exclusion pointer exists from the<br>
decision node. If an exclusion pointer does exist, then control is passed to step 506 where<br>
a test is made to see if the pointer points to another decision node, if it does control is<br>
passed to step 508 otherwise control is passed to step 510. Step 508 causes the next<br>
decision node to be selected and the traversal procedure is called in a recursive manner at<br>
step 512. From step 512 control passes to step 514. Additionally, if the test at step 502<br>
concludes that the decision bit sequence is contained within the pattern list, then control<br><br>
passes to step 514, similarly control also passes to step 514 if step 504 indicates that the<br>
exclusion pointer does not exist.<br>
Returning to step 510, this causes a jump to be made to the conclusion set pointed to by the<br>
pointer examined at step 506, and then a search is made through the conclusion set at step<br>
516. The search procedure will be described hereinafter with reference to Figure 19. From<br>
step 516, control is passed to step 514. Step 514 performs tests to see if the inclusion<br>
pointer exists, and if it does control is passed to step 518, otherwise control is passed to<br>
step 520 which represents an exit from the procedure. Step 518 tests to see if the pointer<br>
points to a further decision node, if it does control is passed to step 522 which calls the<br>
procedure again in a recursive manner, otherwise control is passed to step 524 which<br>
causes a jump to the conclusion set pointed to by the pointer. From step 524 a search is<br>
performed of the conclusion set at step 526 which is the same as step 516. Step 526 and<br>
522 both point to an exit step, step 528 representing an end to the procedure.<br>
Figure 19 schematically illustrates the search procedure of steps 516 and 526. The<br>
procedure is entered at step 530, from where control passes to step 532. Step 532 performs<br>
a test to see if the conclusion set is empty, if it is the procedure is exited at step 534<br>
otherwise control is passed to step 536. Step 536 selects the first key in the conclusion set<br>
and then passes control to step 538 which tests to see whether the key contains every<br>
pattern in the pattern list If it does, control is passed to step 540 otherwise control is<br>
passed to step 542. Step 540 adds the key and its properties from the conclusion set to the<br>
results list. It then passes control to step 542. Step 542 performs a check to see if the<br>
current key is the last key in the conclusion set, if it is, the procedure is exited at step 544<br>
otherwise control is passed to step 546. Step 546 selects the next key in the conclusion set<br>
and return control to step 538.<br>
Figure 20 schematically illustrates how a range search can be performed using a database<br>
constituting an embodiment of the present invention. Suppose that node 560 has the bit<br>
pattern RE stored therein and node 562 has the bit pattern OH. When the node is queried<br>
with the words red, Fred, Bill and John, the words red and Fred are directed along the<br>
include path towards a further node 564 whereas the words Bill and John are directed along<br><br>
the exclude path to node 562. Node 562 directs the word Bill along the exclude path, and<br>
the word John along the include path as it contains a bit pattern "OH".<br>
If the database is now queried using a wild card search, for example, using the search string<br>
"*red*", where * represents a muli-character wild card, then node 560 can determine that<br>
the exclude path towards 562 does not need to be searched, and hence the search can be<br>
limited to the path including the node 564. However, if the index is queried using the<br>
search term "*lap*" then node 560 is unable to determine whether the bit pattern RE is in<br>
the search string (as it may be contained within the wild card portion) and consequently the<br>
index has to search along both the include and exclude paths.<br>
It is worth noting that the position of the bit pattern in the key does not have to move<br>
sequentially along the key as one navigates from node to node in the database.<br>
Key compression<br>
In conventional data base systems the entirety of the key is stored at each decision node.<br>
Whereas, in the invention described hereinabove a portion of the key was stored at each<br>
decision node, although the length of that portion is not constrained. The applicant has<br>
realised that further space savings can be obtained by storing not the entirety of the key or a<br>
sub-portion of the key in its native form, but an expression of mat key derived from a result<br>
of a mapping process. Hash code algorithms, such as CRC32 and Adler 32 are well known<br>
and provide a function for mapping encoding key values. These algorithms operate on a<br>
long bit sequence to derive a much shorter bit sequence. The mapping algorithm is such<br>
that it is deterministic, in that if the input bit sequence is always the same the derived bit<br>
sequence is always the same. However, the mapping cannot be unique due to the high<br>
degree of compression obtained and consequently several input sequences will map onto a<br>
much shorter output sequence. Nevertheless, by accepting this consequence, the designs of<br>
the index can be considerably reduced. Thus, when navigating the tree graph for a<br>
candidate key K, the conventional traversal method is followed except that the value A(K)<br>
is used instead of K, where A is the map function used for the tree graph.<br>
Because two or more keys may map the same function, the conclusion set may contain<br>
information which would not have been reached had the mapping function not been used.<br><br>
It is therefore necessary to examine those entries in the conclusion set in order to exclude<br>
those which do not correspond to the unmapped key. This can be done by holding the<br>
unmapped key in the conclusion set and comparing those keys with the original unmapped<br>
search key in order to exclude those terms that do not match it However, a space saving<br>
may also be achieved by encoding the keys in the conclusion set with a second coding<br>
algorithm B, where B is different to A. The likelihood of an incorrect search key mapping<br>
to two identical map values under both mapping algorithms is very small indeed and<br>
consequently it is highly unlikely that a false map would be obtained. Indeed, the<br>
probability of a false match is approximately one in R2, where R is the range size of the<br>
lunction map. Both mapped key A and B are stored in the conclusion set as mis facilitates<br>
re-mapping of the conclusion set should it reach its maximum size.<br>
To insert a key into the index, the key is encoded using the first hash function. The index<br>
is then navigated using the encoded key via the navigation methods described hereinabove<br>
or conventional methods, until a conclusion set is reached. The key can then be inserted<br>
into the conclusion set in either an un-encoded form, or encoded using a second hash<br>
function.<br>
Deletions are similar, with the key being deleted from the conclusion set in either its native<br>
form, or using the encoded value form as a result of operating on the key using the second<br>
hash function.<br>
It is thus possible to provide an efficient method of encoding database keys in a form where<br>
their size is much reduced, and where the use of double encoding using dissimilar functions<br>
reduces the risk of false matches to an acceptably small occurrence.<br>
Bounded Key<br>
Figure 21 schematically illustrates an index constituting an embodiment of the present<br>
invention. Conceptionally, the index looks like that of a conventional B tree index.<br>
However, rather than entire native keys being included within each node of the decision<br>
tree, a encoded version of the key is used, where the key is mapped using a modulo<br>
arithmetic function. It also follows, that where only part of the key is unbounded, then only<br>
part of the key needs to be mapped in accordance with the present invention. Thus, when a<br><br>
key is presented to the index for searching, deletion or insertion, a standard modulo<br>
function is applied to the key prior to its use. To apply the modulo to a character string key<br>
type, requires the string to be treated as a very large unsigned magnitude integer of multiple<br>
bytes with the first character being the most significant byte in the integer value, and then<br>
applying the modulo.<br>
Thus, to insert a key into the index, the key is encoded using the modulo chosen for the<br>
index. The index structure is then navigated, as described hereinbefore, to a conclusion set<br>
(leaf block) using the encoded key value via standard index methods, or methods presented<br>
herein. The key is then inserted into the conclusion set in either its native form or in its<br>
encoded form. Deletion and searching are performed in similar ways. Thus, in a search<br>
once a conclusion set has been reached, the key is compared with all the key values in the<br>
conclusion set, either in their native or encoded forms.<br>
Figure 22 schematically illustrates the possibilities that may occur when an operator wishes<br>
to run a range match, rather man an exact match as described hereinabove. The minimum<br>
and maximum search keys for the range are represented as L (lower) and U (upper)<br>
respectively. These keys exist in an unbounded or unmapped search space 580 as shown in<br>
Figure 22. The keys are then mapped through the modulo process 582 in order to convert<br>
them into the bounded range of the index. It cannot be guaranteed mat the order of the<br>
keys will be preserved after the mapping process. This gives rise to two possibilities.<br>
Firstly, as shown in the mapped set schematically designated 584, the mapped lower key<br>
has a value less than the mapped upper key. If this is the case, then the index is navigated<br>
to a conclusion set using standard index navigation methods. However, as also<br>
contemplated and schematically illustrated in map set 586, the mapped lower key ML may<br>
have a value greater than the mapped upper key MU. In this instance, the search must be<br>
made of all conclusion sets having encoded values that are greater than or equal to the<br>
encoded minimal key ML. This search is performed using standard index navigation<br>
methods. Additionally, a search must be made for all conclusion sets having encoded<br>
values less than or equal to the encoded maximum key MU. Once again, this is performed<br>
using standard navigation methods.<br><br>
It should be noted that this technique can only work when the difference between the keys<br>
is less than the domain of the modulo encoding scheme. Thus, as a trivial example, if the<br>
keys were mapped using a modulo ten, then the difference between the lower and upper<br>
keys in the search range must be less than ten.<br>
Transient Keys<br>
Figure 23 schematically illustrates the data structure of a conclusion set/leaf block 600<br>
constituting an embodiment of the present invention. The conclusion set contains an age<br>
base 602 which represents the date and time of the most recent update to the conclusion set<br>
600. It also contains a plurality of key entries 604, 606 and 608. Considering only key<br>
entry 608 for brevity, this is further divided into three parts, namely an entry age 608A,<br>
entry key information 608B and entry property information 608C.<br>
When a transient entry is made, it has entry age data 608A associated with it This data<br>
refers to an age unit and an age limit which may be set for the index as a whole, but<br>
optionally could be set for individual conclusion sets. The age unit specifies the number of<br>
seconds in a single age unit Thus, for example, a value of 60 implies one minute, whereas<br>
86400 implies one day. The age limit represents the number of age units after which the<br>
key may be lost from the index. This is typically in the range of 1 to 254, thereby enabling<br>
it to fit within an 8 bit word. Thus, if a key is set to expire after 31 days, the age unit is set<br>
to 86400 seconds and the age limit is set to 31. For keys to expire after one day, the age<br>
unit and age limit may be set to 3600 seconds and 24, respectively.<br>
Each entry contains an entry age, expressed in one byte for efficiency, and this can be set<br>
between the value zero and 255, in this example, although other value ranges may be<br>
chosen as appropriate. Zero indicates that an entry is new, or less than one age unit older<br>
than the age base. 255 indicates that the entry is obsolete.<br>
For each update or insertion in the conclusion set, the following sequence is followed.<br>
Firstly the current date and time is noted, and then the number of elapsed age units between<br>
the age base and the current data and time is calculated. Then, every entry in the<br>
conclusion set has its entry age incremented by the number of elapsed age units. Any entry<br>
with an entry age calculated to be greater than or equal to 255 has its entry age set to 255.<br><br>
Any such entry then becomes available for re-use. Then the age base is set to the date and<br>
time noted at the beginning of the procedure. Any key to be inserted is placed into an<br>
available slot in the conclusion set and is set to an entry age of zero. An available slot may<br>
either be a slot which has not yet been allocated, or a slot which has become obsolete<br>
(because its entry age has reached 255). Furthermore, any entry which is updated has its<br>
entry age reset to zero.<br>
In the above embodiment, the entry age was stored as a single byte. This gives a range of<br>
254 time periods in which a type of data may become obsolete. It is possible to use more<br>
than one byte giving a wider range of age limits, but with an increased storage overhead.<br>
Alternatively, less man one byte may be used as the entry age, thereby reducing storage<br>
overhead, but als6 reducing the range of age limits mat can be individually defined.<br>
It is thus possible to provide an improved database.<br>
Decision Graph Splitting<br>
As discussed hereinbefore, it is preferable that the entirety of the decision graph (index) is<br>
held within semiconductor memory as this allows fast access. However, the capabilities of<br>
the hardware platform running the database or the size of the database may be such mat it<br>
is not possible to hold the entirety of the index within semiconductor memory or the time.<br>
This may, for example, be because the machine is expected to multi-task and perform other<br>
functions.<br>
It is well known that mass storage devices, such as hard disk drives, are divided into blocks<br>
of a predetermined size a file of any size less than the block size still occupies one block.<br>
Thus, physical memory is used in multiples of the block size. When reading and writing<br>
the decision graph to such a memory, it is preferable that the decision graph is structured in<br>
such a way that the entirety of it, or as much as possible, is written to a single block. Thus,<br>
a decision graph is likely to reside within a block of memory. However, as the index<br>
becomes increasingly populated, the decision graph grows as the key population grows.<br>
There therefore becomes a time when it becomes impossible to accommodate the decision<br>
graph within a single block. Thus methods of accommodating the decision graph across<br>
multiple blocks are required.<br><br>
With reference to Figure 24, suppose that memory block 700 represents the physical size of<br>
a block on the hard disk of a computer system, and that the block is subdivided to contain<br>
individual portions 702, 704, 706 and 708, amongst others, each of which relates to the<br>
data in respect of an associated node within the decision graph. Furthermore, suppose that<br>
the index has now reached such a size mat the block 700 is completely full.<br>
Now suppose that as a result of a database insert operation, it is required to insert a further<br>
node into the decision graph. The node insertion may occur at any point . As noted<br>
hereinbefore, each decision node (Figure 3) comprises a decision value, and a low pointer<br>
and a high pointer which indicates the next node in the graph. As a result, local<br>
amendments to the graph can be made such that a new node can be inserted after any<br>
existing node. Thus, supposing that as a result of an insert, it is required to insert a new<br>
node following the node whose data is represented by data item 706. Firstly, as the new<br>
node is inserted one of the output pointers of node 706 is modified to point to the new<br>
node. As part of the insert process the output pointers of the new node are also set up<br>
correctly such that the decision graph does not become broken. However, given that it is<br>
no longer possible to store the data relating to the new node, 710, in the memory block 700,<br>
the details relating to new node 710 must be stored in a further block 712. Further nodes<br>
relating to that new node may also be created and information stored in the memory block<br>
712.<br>
If at a later time, it is required to insert a new node relating to an earlier existing node, 708,<br>
then again the memory block 700 becomes full and consequently the details of a further<br>
new node 714 must be stored outside of the memory block 700. This process allows the<br>
decision graph to grow, but can result in the spawning of a large number of nearly empty<br>
memory blocks from each full (parent) block.<br>
Figure 25 illustrates an alternative method for growing the index. Again, assume that<br>
memory block 700 is full and that it is now required to insert: a new node. As before, a new<br>
memory graph block is created. But now the parent decision graph is split into equal parts.<br>
One part is placed in the old block 700 whilst the other part is placed in the new block<br>
712.<br><br>
With reference to Figure 25, assume initially that the index 720 is stored within memory<br>
block 700 and that block 700 is now full. Supposing that an index insert results in the<br>
creation of new node 722, and at this process causes the index to exceed the size of the<br>
memory block 700. However, in this method of controlling index growth, the structure of<br>
the indexes analysed so as to split it substantially equally between the index blocks. Thus,<br>
taking the portion of the index shown in Figure 25, it can be seen mat starting at node 724;<br>
ten nodes, encircled by chain-dot line 726 can be reached by the path extending to the left<br>
of the node 724, whereas twelve nodes encircled by chain-dot line 728 can be found in the<br>
path extending to the right of node 724. An algorithm recursively scans the index<br>
structure, by selecting a test node and then calculating the nodes depending therefrom in<br>
order to find a suitable candidate node for splitting the index. In the example shown in<br>
Figure 25, node 724 and the nodes encircled by line 726 would be placed in the old<br>
memory block 700, whereas the nodes encircled by chain-dot line 728 would be placed in<br>
the new memory block 712. This process ensures that each memory block is optimally and<br>
equitably utilised and stops the proliferation of substantially empty memory blocks.<br>
Frequently, it is desired that the search term in the index should be performed using two or<br>
more search criteria. These criteria are combined, generally recording to the principles of<br>
boolean algebra.<br>
It is possible for the query to be divided down into individual parts with each part being<br>
performed before the next is down and then the results combined at the end. This,<br>
however, can be very computationally intensive and require many read write operations to<br>
a block data store, such as a hard disk. Thus, for example, a query which returned 100 hits<br>
might then require another 100 slow disk I/O operations in order to fetch the data pointer to<br>
by the index query.<br>
Not all of the data fetched by the query may be required. Thus, if a query was made of a<br>
database to find all cars registered in 1997 that were Mercedes, the query for cars registered<br>
in 1997 would return many thousands of results. However, only a small number of these<br>
have been a Mercedes. Furthermore, for many queries it may not be possible in order to<br>
change the order of the query in such a way as to reduce the number of unwanted results.<br><br>
This problem can be overcome by using concatenated keys. However, hitherto such<br>
concatenated keys have maintained the entirety of both the primary search key and the<br>
subsidiary search keys in the combined concatenated key and consequently the combined<br>
key becomes particularly long.<br>
The applicant has realised that improved search performance can be made by associating<br>
qualifiers, and in particular appending qualifiers, to the primary search key. The qualifier<br>
does not directly the represent the second or subsequent search term, but rather is a<br>
shortened form of that subsequent term. In the present invention, the qualifier is generated<br>
by performing a hashing function on the or each subsequent search term. The same<br>
hashing function is used to query a database as is used to insert or delete data from it<br>
Thus, during creation of the database, the index is created -with a principal key (as before)<br>
and with zero or more qualifier keys.<br>
In use, the index is navigated by using the principal key and data is stored in the conclusion<br>
sets in the usual way. However, each qualifier key is hash encoded down to a single byte,<br>
that is a number in the range zero to 255, and is stored alongside the key entry in the<br>
conclusion set.<br>
During a query, the principal key is supplied with zero or more qualifier keys. The index is<br>
then navigated using the principal key, as before. Finally, once the correct conclusion set<br>
or sets are reached, these are then scanned by matching the principal key value and the<br>
qualifier key hash codes with the entries in the conclusion set Only those entries that<br>
match all of the principal key and all of the qualifier hash codes are returned.<br>
It will be noted that multiple qualifier keys can map to the same single byte hash code.<br>
There is therefore a small but finite probability that unwanted data will be returned.<br>
However, assuming that a good randomising hash encoding is used, the probability of a<br>
wrong match is one in 255 (or less than 0.5%) it can be seen that the present invention<br>
guarantees to return all the correct results, but with a small percentage of incorrect results<br>
as well. Thus all the key hits returned must then be inspected in a data store to remove any<br>
of the unwanted entries. However the reduction in size of the index and the simplification<br>
of the query process more than compensates for the additional analysis of the returned hits.<br>
This advantage increases as more qualifiers are used given that the probability for an<br><br>
incorrect hit decreases with an increasing number of qualifiers. The probability of a bad<br>
result is, under ideal circumstances, (1/255)N. Thus, with two qualifiers (N=2) the<br>
probability of a bad result is 1 in 65025 or less than 0.002%. With three qualifiers, the<br>
chance of returning an incorrect item of data reduces to approximately 14 million to 1.<br>
It would be seen that, the size of the search key, and data storage requirements within the<br>
conclusion sets, is much reduced. Thus, if it had been intended to search on 8 terms, each<br>
of which could be up to 8 bytes long, this would conventionally require storage of 64 bytes<br>
of data for each search key. In the present invention, this requirement is reduced to a mere<br>
15 bytes of data.<br>
When querying the database, each qualifier key is optional and none, any or all of the keys<br>
may be supplied because they do not affect navigation of the index structure. The qualifier<br>
keys only affect the number of bits which are returned when scanning the conclusion sets.<br>
Thus, the more qualifiers that are supplied the more precise the query result.<br>
It should be noted mat mis qualifier technique can be applied to any index structures, for<br>
example well known structures such as the B-tree. Figure 26 schematically illustrates the<br>
format of search key in accordance with this aspect of the present invention in which a first<br>
portion of the key contains the primary key data, and then the remainder of the key<br>
comprises the qualifiers Q1, Q2 and so on to Q7, each of which is a 1 byte long word<br>
produced by a hashing function on the original additional keys.<br>
Pattern Matching<br>
It is often desirable to do a pattern matching query within a database. Thus, rather than<br>
searching on the entirety of a search key, a search is performed using a sub-portion of the<br>
key.<br>
The efficiency of such searching depends on how well the key population is divided in each<br>
node in the decision graph.<br>
A problem with the ASCII character set is that it comprises 255 characters, but that the<br>
likelihood of some characters appearing is very high and yet combinations of dual<br>
characters is particularly rare.<br><br>
The applicant has realised that pattern matching can be much improved if the ASCII<br>
character set (or indeed an equivalent set) is mapped to a smaller set.<br>
The applicant has defined a number of mappings which reduce the set to 16 characters so<br>
that a single character fits within four bits (0-15) whilst a two character sequence can fit<br>
within a single byte.<br>
These modified character sets can then be used in a single index to divide down the key<br>
population.<br>
The mapping of the character set is applied to the key just prior to navigation of the<br>
decision graph for an insert, delete or query operation. Either the original key value or the<br>
converted key value (being of smaller size) can be stored with conclusion set depending on<br>
whether accurate or probabilistic query results are required. Examples of two character<br>
sets are given below:<br>
Phonetic Set<br><br>
Similarity Set<br><br><br>
In each of these schemes, characters are converted to uppercase such that the query is<br>
non-case specific. Furthermore, non-printing characters such as line feed and a character<br>
return are removed from the mappings.<br>
By utilising this reduced set the performance of pattern matching can be much unproved.<br>
The keys are mapped prior to insert, query or delete operations, and then the index is<br>
navigated using the mapped key.<br><br>
WE CLAIM:<br>
1. A method of querying a database with a processor, wherein the<br>
database comprises an index (2) associated with one or more physical<br>
storage devices and data (16) associated with one or more physical<br>
storage devices, wherein the index (2) is queried by the processor<br>
using a search key comprising at least one symbol, the symbol being<br>
represented by a plurality of bits, in order to locate data matching a<br>
search criterion, and wherein the index is a hierarchical structure of<br>
nodes (100, 104, 108) that is navigated by the processor during a<br>
search until a conclusion set (6-14) is reached, characterised in that<br>
the Index (2) is searched by the processor by comparing a decision<br>
group of the search key at each node with a decision value of the<br>
node, in that each decision group comprising at least one bit and at<br>
least some of the decision groups comprise a plurality of bits, in that<br>
the structure is organized such that key symbols are not stored at a<br>
node in the structure, and in that each node has less than three exit<br>
paths therefrom.<br><br>
2. A method as claimed in claim 1, wherein the nodes (100, 104, 108) do<br>
not store the entirety of the key associated with the node.<br>
3. A method as claimed in claim 1 or 2, in which the nodes (100, 104,<br>
108) do not store the decision rules relating to interrogation of the<br>
node.<br>
4. A method as claimed in any one of the preceding claims, in which the<br>
decision at each node (100, 104, 108) is a simple query,<br>
5. A method as claimed in claim 4, in which, at a node (10, 104, 108),<br>
the key or part of the key being used for a query is compared with the<br>
decision criterion at the node, and the test applied is whether the key<br>
or part thereof is greater or less than the decision criterion.<br>
6. A method as claimed in any one of the preceding claims, in which<br>
every record in the database belongs to a conclusion set (6-14).<br>
7. A method as claimed in any one of the preceding claims in which, the<br>
hierarchical structure of decision nodes (100, 104, 108) forms a<br>
decision graph held within the electronic memory of a data processor.<br>
8. A method as claimed in claim 6, in which each conclusion set (6-14)<br>
has a maximum size.<br><br>
9. A method as claimed in claim 8, in which the size of a conclusion set<br>
(6-14) is the same as or is a multiple of the size of a data or address<br>
block used in a data storage device.<br>
10. A method as claimed in claim 8, in which as a conclusion set (6-14)<br>
approaches a predetermined size, a new decision node (100, 104, 108)<br>
is inserted into the hierarchical structure of nodes and the data which<br>
was in the conclusion set is re-indexed into new conclusion sets<br>
reached via the exit paths of the new decision node.<br>
11. A method as claimed in claim 10, in which the new decision node (100,<br>
104, 108) is inserted in the exit path from a node that pointed to the<br>
conclusion set that reached the predetermined size.<br>
12. A method as claimed in any one of the preceding claims, in which<br>
structural re-organisation of the database only affects one or two<br>
decision nodes (100, 104, 108) at a time.<br>
13. A method as claimed in any one of the preceding claims, in which the<br>
decision nodes (100, 104, 108) are related to portions of the search<br>
key.<br>
14. A method at claimed in claim 13, in which the decision graph (4) is<br>
largely independent of the structure of the key.<br><br>
15. A method as claimed in any one of the preceding claims, in which the<br>
hierarchical structure of nodes (100, 104, 108) is structured such that<br>
a semantic order of key sequences is preserved.<br>
16. A method as claimed in claim 6, in which each entry in the the<br>
conclusion set (6-14) comprises a link field (80) pointing to the next<br>
item in the conclusion set, a key field (82) holding the exact value of a<br>
key associated with the entry in the conclusion set and a properties<br>
field (84) which holds one of the data corresponding to the key or a<br>
pointer pointing to the data corresponding to the key.<br>
17. A method as claimed in any one of the preceding claims, in which,<br>
when adding data, the index (2) is navigated until a conclusion set (6-<br>
14) is reached, or the need to create a conclusion set is identified, and<br>
the data is then added to the conclusion set.<br>
18. A method as claimed in any one of the preceding claims, in which keys<br>
stored within conclusion sets (6-14) include a data field indicating the<br>
duration for which the key and its data should be maintained within<br>
the database.<br>
19. A method as claimed in claim 18, in which keys and data which have<br>
expired are made available for overwriting with new data.<br><br>
20. A method as claimed in claims 18 or 19, in which expired keys and<br>
data are not actively deleted from the database.<br>
21. A method as claimed in claim 18, 19 or 20, in which when a conclusion<br>
set (6-14) Is accessed the age of each entry having a duration is<br>
calculated and the results of the calculation may be stored or used to<br>
determine which entries can be overwritten.<br>
22. A method as claimed in any one of the preceding claims, in which the<br>
database comprises a key index and a decision index, wherein the keys<br>
in the key index are stored in a compressed manner, and wherein a<br>
check is made of the key index to see if the key exists prior to<br>
interrogating the decision index using the key.<br>
23. A method as claimed in claim 22, in which the decision index is not<br>
searched if the key does not exist in the key index.<br>
24. A method as claimed in claim 22, or 23, in which, during an operation<br>
to insert a key, a check of the key index is made and the key is<br>
rejected as duplicate if a matching entry is found.<br>
25. A method as claimed in any one of claims 22 to 24, in which the keys<br>
in the key index are stored in a compressed, encoded or mapped form.<br>
26. A method as claimed in claim 25, in which the keys are mapped using<br>
a hash function.<br><br>
27. A method as claimed in any one of claims 22 to 26, in which the key<br>
index comprises an array of elements, the number of elements in the<br>
array being at least as large as the number of unique key elements<br>
within the index.<br>
28. A method as claimed in claim 27, in which two dissimilar functions are<br>
used, where one hash function is used as part of a process to calculate<br>
a destination element E(K) within the key index and the other hash<br>
function is used to encode the key and the result B(K) is stored at the<br>
destination element.<br>
29. A method as claimed in claim 28, in which during a query of the key<br>
index, the destination element is calculated for a target key, and the<br>
encoded value using the second hash function is calculated for the<br>
target key, and the key is deemed to be duplicate if the encoded value<br>
matches a pre-existing value in destination element.<br>
30. A method as claimed in any one of the preceding claims, in which the<br>
index comprises a hierarchical structure of indexes such that an index<br>
can delegate some of its workload to at least one other index.<br>
31. A method as claimed in claim 30, in which an index which has had<br>
work delegated to it can delegate work to other indexes.<br><br>
32. A method as claimed in claim 30 or 31, in which a key manifest of an<br>
index is defined by a range and any request to operate on a key<br>
outside of the range is rejected by the index.<br>
33. A method as claimed in claim 32, in which if the key is within the index<br>
range of database, the database can perform an operation on the key<br>
itself or delegate the task if the key is within the manifest range of any<br>
of the delegate indexes.<br>
34. A method as claimed in any one of claims 30 to 33, in which each<br>
index is associated with a physical storage device, thereby allowing<br>
multiple concurrent disk accesses to occur.<br>
A method of querying a database with a processor, wherein the database<br>
comprises an index (2) associated with one or more physical storage devices<br>
and data (16) associated with one or more physical storage devices, wherein<br>
the index (2) is queried by the processor using a search key comprising at<br>
least one symbol, the symbol being represented by a plurality of bits, in order<br>
to locate data matching a search criterion, and wherein the index is a<br>
hierarchical structure of nodes (100, 104, 108) that is navigated by the<br>
processor during a search until a conclusion set (6-14) is reached,<br>
characterised in that the index (2) is searched by the processor by comparing<br>
a decision group of the search key at each node with a decision value of the<br>
node, in that each decision group comprising at least one bit and at least<br>
some of the decision groups comprise a plurality of bits, in that the structure<br>
is organized such that key symbols are not stored at a node in the structure,<br>
and in that each node has less than three exit paths therefrom.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LUtPTE5QLTIwMDMtKDA5LTA5LTIwMTEpLUFTU0lHTk1FTlQucGRm" target="_blank" style="word-wrap:break-word;">649-KOLNP-2003-(09-09-2011)-ASSIGNMENT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LUtPTE5QLTIwMDMtKDA5LTA5LTIwMTEpLUNFUlRJRklFRCBDT1BJRVMoT1RIRVIgQ09VTlRSSUVTKS5wZGY=" target="_blank" style="word-wrap:break-word;">649-KOLNP-2003-(09-09-2011)-CERTIFIED COPIES(OTHER COUNTRIES).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LUtPTE5QLTIwMDMtKDA5LTA5LTIwMTEpLUNPUlJFU1BPTkRFTkNFLnBkZg==" target="_blank" style="word-wrap:break-word;">649-KOLNP-2003-(09-09-2011)-CORRESPONDENCE.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LUtPTE5QLTIwMDMtKDA5LTA5LTIwMTEpLUZPUk0gMTMucGRm" target="_blank" style="word-wrap:break-word;">649-KOLNP-2003-(09-09-2011)-FORM 13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LUtPTE5QLTIwMDMtKDA5LTA5LTIwMTEpLUZPUk0gMTYucGRm" target="_blank" style="word-wrap:break-word;">649-KOLNP-2003-(09-09-2011)-FORM 16.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LUtPTE5QLTIwMDMtKDA5LTA5LTIwMTEpLVBBLnBkZg==" target="_blank" style="word-wrap:break-word;">649-KOLNP-2003-(09-09-2011)-PA.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LUtPTE5QLTIwMDMtKDI2LTEyLTIwMTEpLUNPUlJFU1BPTkRFTkNFLnBkZg==" target="_blank" style="word-wrap:break-word;">649-KOLNP-2003-(26-12-2011)-CORRESPONDENCE.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LUtPTE5QLTIwMDMtQ09SUkVTUE9OREVOQ0UucGRm" target="_blank" style="word-wrap:break-word;">649-KOLNP-2003-CORRESPONDENCE.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1jb3JyZXNwb25kZW5jZS5wZGY=" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1leGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1mb3JtIDEucGRm" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1mb3JtIDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-form 13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1mb3JtIDIucGRm" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-form 2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1mb3JtIDI2LnBkZg==" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1mb3JtIDMucGRm" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1mb3JtIDUucGRm" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1sZXR0ZXIgcGF0ZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-letter patent.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1yZXBseSB0byBleGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC1zcGVjaWZpY2F0aW9uLnBkZg==" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-specification.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjQ5LWtvbG5wLTIwMDMtZ3JhbnRlZC10cmFuc2xhdGVkIGNvcHkgb2YgcHJpb3JpdHkgZG9jdW1lbnQucGRm" target="_blank" style="word-wrap:break-word;">649-kolnp-2003-granted-translated copy of priority document.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="216076-macrolide-compounds.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="216078-steroid-hormone-products-and-methods-for-preparing-them.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>216077</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>649/KOLNP/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>10/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>07-Mar-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>06-Mar-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>22-May-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>COPPEREYE LIMITED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>BOX HOUSE, BOX WILTSHIRE, SN13 8AA, GREAT BRITAIN.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>PAULY DUNCAN GUNTHER</td>
											<td>COPPEREYE LIMITED, BOX HOUSE, BOX, WILTSHIRE SN13, 8AA, GREAT BRITAIN.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 17/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/GB01/05242</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2001-11-28</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>0029238.3</td>
									<td>2000-11-30</td>
								    <td>U.K.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/216077-a-method-of-querying-a-database by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:15:15 GMT -->
</html>
