<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/224744-storage-access-keys by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:00:11 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 224744:STORAGE ACCESS KEYS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">STORAGE ACCESS KEYS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>This invention relates to a method for regulating access by a first process to a first data location on a storage device, comprising: receiving from the first process a request to access the first data location on a storage device, the request comprising a first information adapted to identify the first data location and a second information adapted to identify the first process; comparing a corresponding portion of the second information with a relevant portion of a third information which is adapted to identify an access right of the first process; and granting access to the first data location and modifying the third information if the corresponding portion of the second information matches the relevant portion of the third information.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>SPECIFICATION<br>
STORAGE ACCESS KEYS<br>
Field of the Invention<br>
The invention relates to computer systems, and more particularly to methods for<br>
communication with and regulating access to a storage system.<br>
Background<br>
In certain approaches to implementing a file system, operating system, distributed file<br>
system or database (hereinafter collectively referred to for convenience as a "file system"),<br>
metadata may be employed to represent the state of the name-space for data objects,<br>
including files, logical volumes, and other such objects (hereinafter collectively referred to<br>
for convenience as "files"), stored in a storage system associated with the file system. A<br>
storage system is a collection of storage devices, with a controller. This metadata can include<br>
mapping information that maps the various parts of a data object to the physical locations of<br>
those parts, as stored in the storage devices that comprise the storage system. Many file<br>
systems contain multiple distributed nodes, with each node being a discrete sub-system that<br>
interacts with the storage system.<br>
Each file is associated with metadata that identifies which storage device and<br>
locations on the storage device contain the various parts of the file, and where the parts of the<br>
file are located on the device. This metadata is typically stored on the storage system. File<br>
system nodes will from time to time access the data pointed to by the metadata. In order to<br>
access the data more efficiently, the nodes will cache local copies of the metadata. A<br>
problem arises, however, when the storage data is moved from one location within the<br>
storage system to another. All cached copies of the metadata must be updated with the new<br>
location of the data, to allow proper access to the data. One approach to informing the file<br>
system nodes of the changes to the metadata involves messages sent among all the nodes<br>
having copies of the metadata. The messages either update the file system nodes with the<br>
new location of the data in the storage system, or merely inform the node that data pointed to<br>
by the cached metadata is no longer valid. In the latter case, the node is responsible for<br>
updating the cached metadata from primary metadata associated with the data.<br>
Unfortunately, using messages for updating/informing the cached copies of the<br>
metadata location is relatively expensive and prevents the file system from achieving<br>
optimum performance. The volume of messages being transmitted in a file system with a<br>
large number of nodes quickly becomes large enough to significantly impact overall<br>
performance. Every node containing a cached copy of the metadata pointing to relocated or<br>
deleted data, or in some systems every node in the cluster, is updated. Therefore many<br>
unnecessary messages are sent out to nodes that wind up discarding the updated metadata<br>
before they ever use it. Furthermore, messages can be missed if a new node starts up during<br>
the moving process, after the message was sent out but before the primary metadata was<br>
updated to reflect the new location.<br>
Another common concern in distributed file systems is called the "split-brain<br>
syndrome". Split-brain syndrome is a condition resulting from an error condition that causes<br>
communications between one or more nodes in a cluster of nodes sharing storage devices, to<br>
be lost. Any operational node in the cluster has no easy way of determining if a node with<br>
which it cannot communicate has crashed or is still operating. When this condition occurs,<br>
there isn't a secure way for the nodes to serialize file system metadata updates, because<br>
global messaging capability is lost. Thus, there is the danger that two processes will attempt<br>
to update the metadata associated with a particular allocation unit simultaneously, causing<br>
data corruption. Various hardware extensions to storage devices have been proposed that<br>
permit inhibiting access to a device by a node. However, these mechanisms restrict all access<br>
to the device, from all processes operating on the failing node, not just the processes related<br>
to the failed application in the cluster.<br>
Summary of the Invention<br>
The present invention is directed to methods of communicating with and regulating<br>
access to data stored on a storage system.<br>
In an aspect of an embodiment of the invention, metadata update notifications are<br>
combined with process-level I/O processing requests.<br>
In another aspect of an embodiment of the invention, data access restrictions are<br>
combined with process-level I/O processing requests.<br>
In another aspect of an embodiment of the invention, information about a process<br>
making an I/O request is transmitted to the data storage system.<br>
In another aspect of an embodiment of the invention, data access restrictions are<br>
isolated to individual processes.<br>
In another aspect of an embodiment of the invention, metadata update notifications<br>
are isolated to individual processes.<br>
Brief Description of the Drawings<br>
FIG. 1 is a representation of the primary metadata for an exemplary file system file.<br>
FIG. 2 is a representation of a file stored on a storage device, showing now, storage access<br>
keys are used to manage access to the file, according to an embodiment of the invention.<br>
FIG. 3 is a flowchart of a method for relocating data using storage access keys, according to<br>
an embodiment of the invention.<br>
FIG. 4 is a flowchart of a method for using storage access keys in accordance with an<br>
embodiment of the invention.<br>
FIG. 5 is a representation of a file stored on a storage device, showing how the metadata<br>
appears prior to a snapshot copy of a file being made, in accordance with an embodiment of<br>
the invention.<br>
FIG. 6 is a representation of a file stored on a storage device, showing how the metadata<br>
appears after a snapshot copy of a file has been made, in accordance with an embodiment of<br>
the invention.<br>
FIG. 7 is a representation of a file stored on a storage device, showing how the metadata<br>
appears after a snapshot copy of a file has been made, and after the copy-on-write fault has<br>
triggered an extent relocation, in accordance with an embodiment of the invention.<br>
FIG. 8 is a high-level representation of a file system and an associated storage system, in<br>
accordance with an embodiment of the invention.<br>
FIG. 9 is a representation of two processes using fence keys in accordance with an<br>
embodiment of the invention.<br>
FIG. 10 is a flowchart of a method for using fence keys in accordance with an embodiment of<br>
the invention.<br>
FIG. 11 is a representation of the use offence keys to block a process from accessing the<br>
storage device, in accordance with an embodiment of the invention.<br>
FIG. 12 is a representation of a computer system in accordance with an embodiment of the<br>
invention.<br>
FIG. 13 is a representation of a processing unit in accordance with an embodiment of the<br>
invention.<br>
Detailed Description of the Preferred Embodiments<br>
In an embodiment, a distributed file system contains a storage system that is<br>
organized into multiple files. Each file includes one or more chunks of allocated storage that<br>
may be distributed amongst a plurality of physical storage devices. Associated with the file<br>
system is metadata containing information about the location of the parts of the files, which is<br>
stored in "extent maps." An extent map is a listing of allocated storage space, e.g. extents, for<br>
the file and the location in the storage system where the extents can be found.<br>
For example, turning to FIG. 1, shown is a simple file system 50 including the<br>
primary metadata for the file system, including a file directory, extent maps, and allocation<br>
units. The file system 50 includes a file directory 60 that contains a list of files. Each file in<br>
the file directory 60 has a pointer to an extent map associated with that file. Each file is a<br>
collection of data that is represented as a discrete unit, though the members of the collection<br>
may be located in different locations in a storage system 130. A file identifier 90 is used to<br>
identify a file, which is associated with a particular set of allocated storage. The file is<br>
associated with an extent map 105 by an extent map pointer 102. The extent map 105 is a list<br>
of extents of the file, with pointers to the physical storage blocks, referred to herein as<br>
"allocation units," where the extents can be found on the storage devices. A process wishing<br>
to access an extent of the file reads the extent map 105 to find out the allocation unit<br>
containing the desired extent of the file and then accesses the data at that location. Allocation<br>
units are the blocks of space on the storage device 140,145 containing the data that makes up<br>
the extents of the file. Allocation units associated with the file may reside on different<br>
storage devices, or they may reside on the same storage device. For simplicity, only a single<br>
allocation unit is shown for each storage device 140, 145 in FIG. 1. However, the storage<br>
devices in accordance with an embodiment of the invention contain a plurality of serially<br>
numbered allocation units.<br>
Storage Access Keys<br>
Turning to FIG. 2, storage access keys are associated with the various units of storage<br>
in the storage device 140, e.g. extents. In an embodiment, each storage access key is<br>
associated with an allocation unit. In another embodiment, each storage access key is<br>
associated with a range of allocation units. In another embodiment, multiple storage access<br>
keys are associated with the same allocation unit. Any given allocation unit can have one or<br>
more storage access keys associated with it. The file system is responsible for initializing the<br>
storage access keys that the application will be using and determining the particular mapping<br>
between storage access keys and allocation units. The particular portion of the storage device<br>
associated with each storage access key is a design choice for those skilled in the art and is<br>
not critical to the invention.<br>
The storage access keys in an embodiment are stored as an array. The storage access<br>
keys are enumerated by their position within the array, beginning with zero (0). Thus, Key 0<br>
would be in the first position in the array, Key 1 in the second, and so on. In a preferred<br>
embodiment, the storage access keys are stored on the storage device 140. In another<br>
embodiment, the storage access-keys are stored in the memory of a controller (not shown) for<br>
the storage system ] 30, of FIG. 1. In an embodiment, the storage access keys are persistent,<br>
even if the particular storage device they are associated with is deactivated. In another<br>
embodiment, the storage access keys are reconstructed from the data stored on the storage<br>
device when the storage device is re-activated. In this embodiment, the initial values of the<br>
storage keys have a default value when the storage device is activated<br>
Each storage access key includes a number of fields. Among these fields is a file<br>
number (FILE NBR) field. The file number field contains information that identifies the file<br>
associated with the data in the allocation unit linked to the storage access key. Also included<br>
is an extent (EXT) field that identifies the particular extent in the file that is associated with<br>
the data in the allocation unit linked to the storage access key. Other fields included in the<br>
storage access key include a valid flag (V), to indicate whether the data in the extent is valid;<br>
a read flag (R), that indicates whether other processes are allowed to read the data from the<br>
extent associated with the storage access key; a write flag (W), that indicates whether other<br>
processes are allowed to write data to the extent associated with the storage access key; and a<br>
snapshot mask field (SNAPSHOT MASK), that indicates whether or not there are snapshot<br>
copies of the extent stored in the extent associated with the storage access key.<br>
In an embodiment, if only the high-order bit of the snapshot mask field is set, then the<br>
extent is private, not shared. If another bit is set, then the extent is a snapshot copy. If more<br>
than one bit of the snapshot mask is set, then the extent is shared and must be copied prior to<br>
writing. The storage access key is not limited to the fields enumerated above, and can also<br>
contain other fields.<br>
In the example of FIG. 2, there is a one-to-one relationship between file extents and<br>
storage access keys. There is also a one-to-one relationship between allocation units and<br>
storage access keys. An extent map 200 contains the extents that make up the file bearing the<br>
file number 0X200. A first storage access key 152 is associated with a first allocation unit<br>
(not shown).- A second storage access key 157 is associated with a second allocation unit 142.<br>
A third storage access key 160 is associated with a third allocation unit (not shown). The<br>
particular associations made are design choices for the application developer, and are not<br>
critical to the invention.<br>
The first storage access key 152 has a file number field that contains the value<br>
"0X200" and an extent field containing the value "0X0", which indicates that the first<br>
allocation unit (not shown) associated with the file contains extent #1 of file 0X200, as<br>
identified by the file identifier 107 and first extent entry 108. The second storage access key<br>
157 has a file number field that contains the value "0X200" and an extent field containing the<br>
value "0X1", which indicates that the second allocation unit 142 associated with the file<br>
contains extent #2 of file 0X200, as identified by the file identifier 107 and second extent<br>
entry 109. The third storage access key 160 has a file number field that contains the value<br>
"0X200" and an extent field containing the value "0X2", which indicates that the third<br>
allocation unit (not shown) associated with the file contains extent #3 of file 0X200, as<br>
identified by the file identifier 107 and third extent entry 110. The fourth storage access key<br>
163 has an undefined value at this stage.<br>
During the operation of the file system, cached copies 171,173 of the extent map 200<br>
for the file are created by processes on the nodes 170,172. Various conditions can<br>
precipitate making a copy of the extent map 200 in a node's memory. For example, where<br>
the extent map 200 is stored on the storage device 140, a node creates a cached copy of the<br>
extent map 200 when a process on the node accesses the file. In another example where a<br>
first node contains the extent map 200, a second node remote from the first node accesses the<br>
file and causes a cached copy of the extent map 200 to be created in the remote node's<br>
memory. In another example, a copy of the extent map 200 is made on all nodes when the<br>
file is first created.<br>
At some point in the operation of the storage system, the file system may move data<br>
contained in the various allocation units from one location to another within the storage<br>
system. This movement may be between locations within the same storage device, or it may<br>
be across storage devices. For the sake of simplicity, the exemplary embodiment discussed<br>
herein assumes a movement between locations-within the same storage device. The data<br>
movement is done dynamically, while the data is still available to be accessed by processes<br>
running on the nodes accessing the file system. Various events can trigger the decision by the<br>
file system to move data.<br>
If a new storage device is added to the storage system, data may be moved to fill that<br>
storage device. If an existing storage device is scheduled to be removed from the storage<br>
system, data may be moved off of the storage device to be removed. If a particular storage<br>
device is over-utilized, data may be moved off of the over-utilized storage device. If a<br>
particular storage device is under-utilized, data may be moved onto the under-utilized storage<br>
device. If changes are made to a logical copy of a file, then a new physical copy of the file or<br>
the portion of the file containing the divergent content may be made. The reasons that<br>
precipitate a data movement are design choices for those skilled in the art and arenot critical<br>
to the invention.<br>
In the exemplar)' embodiment of FIG. 2, the second node 172 moves the data<br>
contained in the second allocation unit 142 to a fourth allocation unit 215. This movement<br>
follows the method of FIG. 3. The second node 172 reads the contents of the second<br>
allocation unit 142 into its local memory 174 and simultaneously updates the write flag<br>
contained in the second storage access key 157 to zero (0), at step 300. This inhibits other<br>
nodes from updating the second allocation unit 142 while its contents are undergoing<br>
relocation. Updating the write flag in the storage access key is performed as part of the same<br>
operation that reads the contents of the second allocation unit 142, and does not require an<br>
additional I/O operation..<br>
The second node 172 then writes the data to be moved from its local memory 174 to<br>
the fourth allocation unit 215 and simultaneously updates a fourth storage access key 163<br>
with values indicating the new contents of the fourth allocation unit 215, at step 310. Again,<br>
the storage access key update is performed as part of the I/O operation, and does not require<br>
an additional I/O operation.<br>
Finally, the second node 172 updates the extent map 200 on the storage device 140, as<br>
well as the cached extent map copy 173 stored on the second node 172, with the new location<br>
of the data, and invalidates the second storage access key 157 by writing a zero (0) to the<br>
valid flag of the second storage access key 157, at step 320. In an embodiment, a hint as to<br>
the new location of the data is left behind in the second storage access key I57, by changing<br>
the extent field of the second storage access key 157 to a value that indicates the new location<br>
of the data at step 320. No other extent maps are modified by, nor nodes notified of, the data<br>
movement when it occurs.<br>
Once the data contained in the second allocation unit 142 has been moved, a process<br>
running on the first node 170 may thereafter attempt to use the cached extent map copy 171<br>
of the extent map 200 stored on the first node 170 to access the second extent entry 109. The<br>
process may-attempt to access the second extent entry 109 by sending an I/O request to the<br>
storage device 140. An example of an I/O request is set forth in Table 1 below:<br>
Table 1<br>
In this embodiment, the I/O request contains two portions, an I/O portion (I) that has<br>
information relating to the particular I/O operation to be performed, and an access key<br>
portion (2) that has information relating to the data validation operation to be performed. The<br>
I/O portion contains: 1) information identifying the I/O request type, 2) information that<br>
identifies the particular storage device within the storage system that the I/O request will<br>
access, 3) the offset into the storage device, expressed as an allocation unit number, and 4)<br>
the range of data to be operated on.<br>
The access key portion of the I/O request contains: 1) a Key Number that identifies<br>
the storage access key the I/O request will be compared with, 2) an Expected Key Value that<br>
the I/O request will use to compare with the storage access key, 3) a Key Mask to apply to the<br>
storage access key before comparison with the key value, 4) a Key-AND field containing a<br>
value to be logically AND'ed with the storage access key after a successful match has been<br>
made, and 5) a Key-OR field containing a value to be logically OR'ed with the storage access<br>
key after a successful match has been made. The Expected Key Value contains information<br>
that identifies the file and extent that the I/O request expects to find in the allocation unit the<br>
I/O request is seeking to access. The Expected Key Value can also contain additional<br>
information, such as a flag indicating whetherthe I/O operation is a read or a write operation,<br>
a value indicating which process is making the I/O request, a snapshot mask, or other such<br>
information.<br>
The Key Mask is used to disregard portions of the storage access key that are not<br>
relevant to the comparison being made. The Key Mask is logically AND'ed with the storage<br>
access key before the storage access key is compared with the Expected Key Value from the<br>
first I/O request. If the Expected Key Value matches the storage access key, the Key-AND<br>
field is used to clear portions of the storage access key, by logically AND-ing those portions<br>
with zero values. If the Expected Key Value matches the storage access key, the Key-OR<br>
field is used to set portions of the storage access key by logically OR-ing the storage access<br>
key with the Key-OR field. For example, new file and extent values could be stored into a<br>
storage access key by first logically AND-ing the portion of the storage access key that<br>
contains the file and extent values with a zero value, and then logically OR-ing the cleared<br>
portion of the storage access key with values that identify the new file and extent of the data<br>
that is stored in the allocation unit accessed by the first I/O request.<br>
FIG. 4 is a flowchart, which is illustratively explained with reference to FIG. 2. A<br>
process on the first node 170 seeks to access the data pointed to by the second extent entry<br>
109 of the file, stored in the storage device 140. The process uses the cached extent map<br>
copy 171 of the extent map 200 to generate the I/O request shown in Table 1, at step 402.<br>
The I/O request is sent to the storage device 140, where it is determined that the I/O request is<br>
seeking access to the second allocation unit 142, at step 404. Methods of routing I/O requests<br>
are well known to thoseskilled in the art, and are not critical to the invention. Upon<br>
receiving the I/O request, the Expected Key Value is then compared with the second storage<br>
access key 157, to determine whether or not the second allocation unit 142 contains the data<br>
that the I/O request expects the second allocation unit 142 to contain.<br>
The irrelevant portions of the second storage access key 157 are first discarded by<br>
being masked by AND-ing the second storage access key 157 with the value in die Key Mask<br>
field of the I/O request, at step 406. In this example, since the I/O request is a "read" request,<br>
it is not relevant whether there are snapshot copies sharing the extent, so the snapshot mask is<br>
itself masked out. The precise information to be masked out is, however, a design choice for<br>
those skilled in the art and is not critical to the invention.<br>
The relevant portions of the second storage access key 157 are now compared with<br>
the value contained in the Expected Key Value field of the I/O request, at step 408. In a<br>
preferred embodiment, the comparison is done by doing a Boolean comparison of each of the<br>
bits of the masked second storage access key 157 with the corresponding bit in the Expected<br>
Key Value field of the I/O request. Since, after the data movement discussed above, the valid<br>
flag of the second storage access key 157 contains a value of zero (0) and the valid flag of the<br>
Expected Key Value field of the I/O request contains a value of one (I), there is no match and<br>
the comparison fails. Note that had the second storage access key 157 been re-used by<br>
another process, the valid flag of the second storage access key 157 would be set to one, and<br>
would therefore match the Expected Key Value information. However, the file number field<br>
and/or the extent field will not match the Expected Key Value information, and the<br>
comparison will still fail.<br>
Once the comparison fails, a storage access key fault is generated, and the I/O request<br>
is denied access to the second allocation unit 142, at step 410. A message is sent back from<br>
the storage device 140 to the first node 170, notifying the process in the first node 170<br>
making the I/O request that the cached extent map copy 171 contains obsolete information.<br>
The process then requests a new extent map, at step 412. Once the process has been notified,<br>
the next action to be taken depends on the particular implementation decisions made by the<br>
programmer of the application that initiated the I/O request.<br>
Exemplary actions that a file system programmer could implement, at step 414,<br>
include having the first node 170 read the extent map 200 on the storage device 140 or the<br>
second cached extent map copy 173 on the second node 172, for an updated copy of the<br>
obsolete information. In an embodiment, the entire cached extent map copy 171 is refreshed.<br>
In another embodiment, only the second extent entry 109 is refreshed. In another<br>
embodiment, the notification message that is sent back from the storage device 140 to the<br>
first node 170 contains the new location for the requested data.<br>
I/O requests can be used to change the values of the storage access keys. Turning<br>
again to FIG. 4 as illustratively explained with reference to FIG. 2, an I/O request is used to<br>
change the second storage access key 157. After the data movement operation discussed<br>
above, the second allocation unit 142 contains no valid data and is available for use, as<br>
signified by the value "0" in the valid (V) field. A process generates an I/O request that seeks<br>
to write data into the second allocation unit 142, at step 402. The exemplary I/O request of<br>
Table 2, below, includes a Key Number of "1", an Expected Key Value of all zeros, a Key<br>
Mask with a "1" in the valid flag and zeros everywhere else, a Key-AND of all zeros, and a<br>
Key-OR containing the file and extent information for the new data to be written to the<br>
second allocation unit 142.<br>
Table 2<br>
The irrelevant portion of the second storage access key 157 is discarded by the Key<br>
Mask value of the I/O request, at step 406. In this example, everything but the valid flag is<br>
discarded. The relevant portion of the second storage access key 157 is compared with the<br>
Expected Key Value of the I/O request, at step 408. The relevant portion of the second<br>
storage access key 157 is "0", as is the Expected Key Value field of the I/O request, therefore<br>
a successful match is made. The Key-AND field of the I/O request is applied to the second<br>
storage access key 157, clearing it, at step 418. The Key-OR field of the I/O request is then<br>
applied to the second storage access key 157, at step 420. The I/O request then writes new<br>
data to the second allocation unit 142, at step 422.<br>
The Key-OR field contains information that identifies the file and extent of the newly<br>
written data. The Key-OR field can also contain other information. In this example, since<br>
this is a write operation, the Key-OR field contains information used to indicate that the data<br>
from file 0x300 and extent 0x4 has been written to the second allocation unit 142.<br>
In accordance with another embodiment of the invention, a copy-on-write function is<br>
enabled using storage access keys. Copy-on-write functionality is an example of one of the<br>
ways an application programmer or a file system programmer could use the storage access<br>
key concept to solve a particular programming problem. Copy-on-write functionality is used<br>
to efficiently manage separate logical files that start out as snapshot copies of a single<br>
original file. When making a copy of a file, it is inefficient and wastes storage space to<br>
physically copy the data itself into a second location in the data storage system. It is more<br>
efficient to simply create another extent map for the new logical file, and have the new extent<br>
map point to the same locations as the old extent map.<br>
In FIG. 5, a first file 500 is labeled with a file number of 0X100. The first file 500,<br>
with no snapshot copies, has three extent entries in a first extent map 510. A first extent entry<br>
512 points to a first allocation unit 522. A second extent entry 514 points to a second<br>
allocation unit 524. A third extent entry 516 points to a third allocation unit 526. The<br>
allocation units 522,524,526 are contained on the storage device 140. Each allocation unit<br>
has a storage access key 532,534,536 associated with it. The first storage access key 532 is<br>
associated with the first allocation unit 522. The second storage access key 534 is associated<br>
with the second allocation unit 524. The third storage access key 536 is associated with the<br>
third allocation unit 526. The Valid (V), Read (R), and Write (W) flags are set to one (1) for<br>
each storage access key, to indicate that the allocation units are valid, readable, and writeable.<br>
The storage access keys each have the File Number (FILE NBR) and the Extent (EXT) set to<br>
the corresponding values derived from the extent map, indicating which extent of the file is<br>
stored in the allocation unit associated with each storage access key. The storage access keys<br>
also each have a Snapshot Mask (SS MASK), containing a one (1) in the high-order bit of the<br>
mask (0X8000), indicating that these allocation units correspond to a primary file. Unused<br>
storage access keys have their Valid flag cleared, indicating that they contain no valid data.<br>
A process performing a write I/O operation to the second allocation unit 524 would<br>
use the I/O request of Table 3, below.<br>
Table 3<br>
The Key Number in the I/O request is set to two (2), corresponding to the second<br>
storage access key 524. This key indicates that the second allocation unit contains the second<br>
extent entry 514 in the extent map 510 of the file. All Key Mask bits are set to one (1),<br>
except for the snapshot bit corresponding to the copy of the file to which the I/O operation is<br>
being directed. In this example, a write I/O operation is being directed to the primary file<br>
(non-snapshot copy), which is represented by the highest order bit (0X8000) in the Snapshot<br>
Mask. Consequently, the storage device will compare ali fields in the Expected Key Value<br>
field, except for the high-order Snapshot Mask bit. In this example, the comparison is<br>
successful and the I/O request is allowed.<br>
After a snapshot copy of the first file 500 of FIG. 5 has been made, there are two files<br>
in the file system that both point to the same locations on the storage device 140, as shown in<br>
FIG. 6. A second file 600 is created in the file directory. The second file 600 points to a<br>
second extent map 610. The second extent map 610 contains three extent entries. These<br>
extent entries point to the same allocation units as do the extent entries of the first extent map<br>
510. A fourth extent entry 612 points to the first allocation unit 522. A fifth extent entry 614<br>
points to the second allocation unit 524. A sixth extent entry 616 points to the third<br>
allocation unit 526. The snapshot copy 600 is assigned a new file number (0X101), but the<br>
file number field in the storage access keys remains the primary file number (0X100). When<br>
a process initiates an I/O request to the snapshot copy 600, it will use the file number of the<br>
original file 500. The bit in the Snapshot Mask fields of the storage access keys 532, 534,<br>
536 corresponding to the snapshot copy has been set to one (1). Since in this example this is<br>
the first snapshot that has been created, the next-to-highest-order bit has been set to one (1).<br>
Once the snapshot copy is created, a write I/O operation to either the primary file 500<br>
or the snapshot copy 600 causes a "Copy-on-Write" storage key fault. For example, a<br>
process performing a write I/O operation to the second extent of the snapshot copy 600,<br>
stored in the second allocation unit 524, would use the I/O request of Table 4, below.<br>
Table 4<br>
Since the snapshot copy 600 is a copy of the primary file 500, it uses the file name<br>
(0X100) associated with the primary file 500, rather than the snapshot copy's own file name<br>
(0X101). The Snapshot Mask in the second storage access key 534 is 0XC0OO, and after<br>
applying the Snapshot Mask in the I/O request of 0XBFFF, the masked value is 0X8000.<br>
This masked value does not match the snapshot mask value of zero (0), in the expected key<br>
value for the storage access key, therefore there is no match and the storage device traps the<br>
write I/O with a storage key fault.<br>
The storage key fault inhibits the write operation and leads to the file system invoking<br>
its copy on write algorithm. In an embodiment, the copy on write algorithm creates a copy of<br>
the targeted allocation unit, using a method similar to that described above for moving data<br>
from one allocation unit to another. The details of the copy-on-write algorithm are design<br>
choices for the application or file system programmer, and are not critical to the invention.<br>
After the file system updates the file system metadata, the file system attempts the write<br>
operation again, on the newly made copy of the data, and it executes successfully.<br>
The file system metadata after the second attempt of the write operation is shown in<br>
FIG. 7. In FIG. 7, a fourth allocation unit 724 has been allocated and the data from the<br>
second allocation unit 524 has been copied into the fourth allocation unit 724. A fourth<br>
storage access key 734 has been assigned to the fourth allocation unit 724. The fourth<br>
storage access key 734 has been assigned the file number and extent number of the fifth<br>
extent entry 614. The Snapshot Mask of the fourth storage access key 734 has its next-to-<br>
highest-order snapshot mask bit set to one (1) and therefore the snapshot mask reads as<br>
0X4000. This indicates that the fourth allocation unit 724 corresponds to the first snapshot<br>
copy 600 of the primary file 500. Since the second allocation unit 524 is no longer shared,<br>
the first snapshot mask bit of the second storage access key 534 is cleared. The snapshot<br>
mask field of the second storage access key 534 now reads 0X8000.<br>
Fence Kevs<br>
Fence keys are a mechanism in which metadata updates within a process family can<br>
continue in a secure fashion, even in the face of a split-brain condition, as discussed above.<br>
Turning now to FIG. 8, in an embodiment, a file system 800 includes nodes 810,820, 830,<br>
840. In an embodiment, each node 810, 820, 830, 840 is a separate CPU and associated<br>
circuitry, which is associated with the storage system 130. In another embodiment, the nodes<br>
810, 820, 830, 840 each contain multiple CPUs. A first node 810 contains processes 812,<br>
814,816 that are running on the first node 810, A second node 820 contains processes 822,<br>
824 that are running on the second node 820. Each process 812, 814, 816, 822,824, during its<br>
normal operations, transmits I/O requests to the storage system 130, as shown by the arrows.<br>
In an embodiment, each I/O request sent to the storage system contains information<br>
identifying the process that is making the I/O request. In another embodiment, the I/O<br>
request contains information identifying the application that is making the I/O request, where<br>
an application includes multiple processes. Within the node of the file system, the precise<br>
nature of the entity making the I/O requesting entity is a design choice for those skilled in the<br>
art and is not critical to the invention.<br>
When the I/O request is sent to the storage system, the process making the request is<br>
checked against a collection of processes that are allowed to access the data on the storage<br>
system. If the requesting process is in the collection of allowed processes, the requesting<br>
process is allowed access to the data. If the requesting process is not in the collection of<br>
processes allowed to access the data, the requesting process is denied access to the data.<br>
Turning to FIG. 9, in an embodiment, inside the storage device 140 is a collection of<br>
fence keys 910. The fence keys are numbered from 0 to N-1, N being the number of fence<br>
keys in the collection. Each fence key corresponds to a process on a node. The contents of<br>
the fence values are negotiated at start-up time through messages exchanged through the<br>
communications interconnect 920 used by the family of processes sharing the storage device<br>
140. Access to the storage device by a process is authorized by comparing the fence key<br>
entry associated with the process with the value specified in the I/O request that is seeking<br>
access.<br>
In an embodiment the fence keys are stored on the storage device 140. In another<br>
embodiment the fence keys are stored in the memory of a controller (not shown) for the<br>
storage system containing the storage device 140. In an embodiment, the fence keys are<br>
persistent, even if the particular storage device they are associated with is deactivated. In<br>
another embodiment, the fence keys are reconstructed from the data stored on the storage<br>
device 140 when the storage device 140 is re-activated.<br>
In the exemplary embodiment of FIG. 9, the storage device 140 is being shared by a<br>
first process 955 running on a first node 950, and a second process 965 running on a second<br>
node 960. The nodes 950, 960 also contain other processes, which are omitted for the sake of<br>
clarity. A first fence key 930 is initialized on the storage device 140 and associated with the<br>
first process 955 running on the first node 950. A second fence key 940 is initialized on the<br>
storage device 140 and associated with the second process 965 running on the second node<br>
960.<br>
In an embodiment, each process has a fence key associated with it. Alternatively, a<br>
collection of processes can be associated with a fence key. The fence keys are assigned when<br>
the processes 955,965 are initialized. Alternatively, the fence keys can be assigned when the<br>
processes 955, 965 first attempt to access the storage device 140. The first process 955 and<br>
the second process 965 are located on different nodes. Alternatively, the first process 955<br>
can be located on the same node as the second process 965. Each storage device preferably<br>
contains a separate fence key for each process.<br>
When the first process 955 is initialized, the first fence key 930 is assigned a fence<br>
value. When the second process 965 is initialized, the second fence key 940 is assigned a<br>
fence value. The fence values are preferably unique, non-recurring values that serve to<br>
identify the specific process. For example, the fence key values can be based upon the<br>
interval of time that has passed from a pre-defined reference time up to the time the process<br>
associated with the fence key is created.<br>
If communications between a process on an operating node and a process on another<br>
node is lost, and a process on the operating node needs to update file system metadata, then<br>
the operating process will change the fence key value of the fence key associated with the<br>
process to which communications has been lost. This locks out the other process from further<br>
access to the storage device. After the other process recovers and has reestablished<br>
communications, it interrogates the operating node as to the new fence key value and begins<br>
normal operation again.<br>
As a practical example of the operation of the fence keys of an embodiment, assume<br>
the first process 955 seeks to access the storage device 140. Turning to the flowchart of FIG.<br>
10, with reference to FIG. 9, the first process 955 generates an I/O request, requesting access<br>
to the storage device 140, at step 1002. In an embodiment, the I/O request is as shown in<br>
Table 5 below:<br>
Table 5<br>
In another embodiment, the I/O request contains both storage access key information<br>
and fence key information, as shown in Table 6:<br>
Table 6<br>
The I/O request of Table 6 contains three portions: an I/O portion (1). as described<br>
above, optionally a storage access key portion (2) as described above, and a fence key portion<br>
(3). The fence key portion contains a Fence Key Number, which identifies the fence key that<br>
the I/O request will be compared with, and an Expected Fence Value that the I/O request will<br>
use to compare with the fence key.<br>
At step 1004. the I/O request is sent to the first storage device 140. The storage<br>
device 140. locates the Fence Key Number (0) within the I/O request, and determines that the<br>
first fence key 930 is the proper fence key to compare with the I/O request. The storage<br>
device ]40 compares the fence value (0X200) contained in the first fence key 930 with the<br>
Expected Fence Value (0X200) contained in the I/O request, at step 10061 In an embodiment,<br>
the comparison is done by a Boolean compare of each of the bits of the Expected Fence<br>
Value with the corresponding bits of the fence value contained in the first fence key 930.<br>
Precise methods of comparing two values are design choices for those skilled in the art, and<br>
are not critical to the invention.<br>
Since in this example embodiment, the Expected Fence Value and the fence value<br>
contained in the first fence key 930 are the same, the comparison succeeds. At step 1012<br>
there is no key change request. Where the I/O request contains both a fence key portion and<br>
a storage access key portion, the storage device 140 then processes the storage access key<br>
portion of the I/O request, using the methods discussed above, at step 1018. Alternatively,<br>
the storage device 140 processes the storage access key portion of the I/O request first, then<br>
processes the fence key portion, and if both keys match, the I/O request is completed. The<br>
ordering of the processing of the portions is a design choice for those skilled in the art and is<br>
not critical to the invention.<br>
From time to time, it is desired that the second process 965 be denied access to the<br>
storage device 140. There are various reasons why the second process 965 needs to be denied<br>
access to the storage device 140. The second process 965 may be malfunctioning, or the<br>
second process 965 may appear to an observer, such as the first process 955 or the storage<br>
device 140, to be malfunctioning because, for example, the second process 965 has stopped<br>
communicating with the observer. The various reasons for denying the second process 965<br>
access to the storage device 140 are design choices for those skilled in the art and are not<br>
critical to the invention.<br>
A practical example of how fence keys block a process from accessing the storage<br>
device 140 is shown using the flowchart of FIG. 10 with reference to the system of FIG. 11.<br>
In FIG. 11, the communications interconnect 920 has been broken. The first process 955<br>
detects this, and at step 1002 the first process 955 sends an access-blocking request to the<br>
storage device 140, asking the storage device 140 to block the second process 965 from<br>
accessing the storage device 140. Methods of detecting communications failures in a file<br>
system are well known to those skilled in the art, and are not critical to the invention. In an<br>
embodiment, the first process 955 seeks to block the second process 965 from accessing all of<br>
the storage devices in a storage system. In another embodiment, the first process 955 seeks to<br>
block the second process 965 from accessing some or only one of the storage devices in the<br>
storage system.<br>
An example of an access-blocking request is shown in Table 7 below:<br>
Table 7<br>
The access-blocking request contains three sections. The first section (1) identifies the<br>
type of request being made, and contains information to identify the storage device being<br>
accessed, a target fence key number of one (1), which is the number of the fence key the<br>
access blocking request seeks to change, and a new fence key value of 0X202, which is the<br>
value that the blocking request seeks to change the targeted fence key to. The second section<br>
(2) is optional and contains storage access key information. In this example, storage access<br>
keys are not involved, so the Key Mask is set to all zeros, ensuring against a storage access<br>
key fault The third section (3) contains the Fence Key Number and Expected Fence Value<br>
of the process making the access-blocking request, as discussed above. This information is<br>
included because a process wishing to change the access rights of another process must first<br>
itself be granted access to the storage system.<br>
In the exemplary embodiment, the access-blocking request is sent to the storage<br>
device ] 40 by the first process 955, at step 1004. The storage device 140 uses the method<br>
described above to verify that the first process 955 is itself allowed to access the storage<br>
device 140, at step 100$. In this exemplary embodiment, the first process 955 passes the<br>
access test, and the access-blocking request is accepted. In another embodiment, the first<br>
process 955 fails the access test because the first process 955 has itself been blocked by<br>
another entity, such as the second process 965 or the storage device 140, and the access<br>
blocking request is rejected, at step 1008.<br>
Once the access-blocking request has passed the access test and been accepted by the<br>
storage device ] 40, at step 1012 it is noted that this request seeks to change a fence key. The<br>
target fence key number is read from the access-blocking request at step 1014. In this<br>
example, the target fence key number is one (1), which references the second fence key 940,<br>
associated with the second process 965. The New Fence Value of 0X202 is then read from<br>
the access-blocking request, and the New Fence Value is written to the second fence key 940,<br>
at step 1016. The New pence Value is a pre-defined blocking value. In an embodiment, the<br>
access-blocking request is then applied in a similar manner to all of the storage devices in the<br>
storage system. In another embodiment, the access-blocking request contains additional<br>
information indicating which storage devices in the storage system the access-blocking<br>
request will be applied to.<br>
The above set fence key operation is an example of one operation that can be<br>
implemented using the fence keys and storage access keys of an embodiment of the<br>
invention. Other operations can also be implemented using fence keys and storage access<br>
keys in accordance with an embodiment of the invention. Exemplary operations include, an<br>
operation that retrieves a fence key, an operation that sets a storage access key, and/or an<br>
operation that retrieves a storage access key.<br>
In another embodiment, once the access-blocking request has changed the fence key<br>
value stored in the second fence key 940, the second process 965 may attempt to access the<br>
storage device 140. The second process 965 generates an I/O request as described above,<br>
using the Fence Key Number of " 1" and the Expected Fence Value of "0x201". The second<br>
fence key 940 is compared with the I/O request. The Expected Fence Value is compared<br>
with the newly changed fence key value of the second fence key 940, at step 1006. Since in<br>
this example, the expected fence value is 0X201, and the fence value of the second fence key<br>
940 is 0X202, the two values are different, the comparison fails, a fence key fault is triggered<br>
and the second process is denied access to the storage device 140, at step 1008. At step 1009,<br>
the new fence value is returned to the process making the I/O request.<br>
The fence key fault indicates that the second process 965 should initiate recovery<br>
proceedings. In an embodiment, these recovery proceedings would include the second<br>
process 1) invalidating all cached copies of its extent maps, 2) re-negotiating its key value<br>
with the other nodes in the file system, 3) and restoring communications with the first node<br>
950. The pre-defined blocking value stored in the second fence key 940 could also be used as<br>
a pointer indicating which node it was that did the fencing. The details of these proceedings<br>
are design choices for the applications programmer or the file system programmer, and are<br>
not critical to the invention.<br>
SYSTEM ARCHITECTURE OVERVIEW<br>
Referring to Fig. 12, in an embodiment, a computer system 1220 includes a host<br>
computer 1222 connected to a plurality of individual user stations 1224. In an embodiment,<br>
the user stations 1224 each comprise suitable data terminals, for example, but not limited to,<br>
e.g., personal computers, portable laptop computers, or personal data assistants ("PDAs"),<br>
which can store and independently run one or more applications, i.e., programs. For purposes<br>
of illustration, some of the user stations 1224 are connected to the host computer 1222 via a<br>
local area network ("LAN") 1225. Other user stations 1224 are remotely connected to the<br>
host computer 1222 via a public telephone switched network ("PSTN") 1228 and/or a<br>
wireless network 1230.<br>
In an embodiment, the host computer 1222 operates in conjunction with a data storage<br>
system 1231, wherein the data storage system 1231 contains a database 1232 that is readily<br>
accessible by the host computer 1222.<br>
In alternative embodiments, the database 1232 may be resident on the host computer,<br>
stored, e.g., in the host computer's ROM, PROM, EPROM, or any other memory chip, and/or<br>
its hard disk. In yet alternative embodiments, the database 1232 may be read by the host<br>
computer 1222 from one or more floppy disks; flexible disks, magnetic tapes, any other<br>
magnetic medium, CD-ROMs, any other optical medium, punchcards, papertape, or any other<br>
physical medium with patterns of holes, or any other medium from which a computer can<br>
read.<br>
In an alternative embodiment, the host computer 1222 can access two or more<br>
databases 1232, stored in a variety of mediums, as previously discussed.<br>
Referring to Fig. 13, in an embodiment, each user station 1224 and the host computer<br>
1222, each referred to generally as a processing unit, embodies a general architecture 1302.<br>
A processing unit includes a bus 13(13 or other communication mechanism for<br>
communicating instructions, messages and data, collectively, information, and one or more<br>
processors 1304 coupled with the bus 1303 for processing information. A processing unit<br>
also includes a main memory 1308, such as a random access memory (RAM) or other<br>
dynamic storage device, coupled to the bus 1303 for storing dynamic data and instructions to<br>
be executed by the processors) 1304.. The main memory 1308 also may be used for storing<br>
temporary data, i.e., variables, or other intermediate information during execution of<br>
instructions by the processors) 1304.<br>
A processing unit may further include a read only memory (ROM) 1309 or other<br>
static storage device coupled to the bus 1303 for storing static data and instructions for the<br>
processors) 1304. A storage device 1310, such as a magnetic disk or optical disk, may also<br>
be provided and coupled to the bus 1303 for storing data and instructions for the processors)<br>
1304.<br>
A processing unit may be coupled via the bus 1303 to a display device 1311, such as,<br>
but not limited to, a cathode ray tube (CRT), for displaying information to a user. An input<br>
device 1312, including alphanumeric and other keys, is coupled to the bus 1303 for<br>
communicating information and command selections to the processors) 1304. Another type<br>
of user input device may include a cursor control 1313, such as, but not limited to, a mouse, a<br>
trackball, a fingcrpad, or cursor direction keys, for communicating direction information and<br>
command selections to the processors) 1304 and for controlling cursor movement on the<br>
display 1311.<br>
According to one embodiment of the invention, the individual processing units<br>
perform specific operations by their respective processors) J 304 executing one or more<br>
sequences of one or more instructions contained in the main memory 1308 Such instructions<br>
may be read into the main memory 1308 from another computer-usable medium, such as the<br>
ROM 1309 or the storage device 1M0. Execution of the sequences of instructions contained<br>
in the main memory 1308 causes the processors) 1304 to perform the processes described<br>
herein. In alternative embodiments, hard-wired circuitry may be used in place of or in<br>
combination with software instructions to implement the invention. Thus, embodiments of<br>
the invention are not limited to any specific combination of hardware circuitry and/or<br>
software.<br>
The term "computer-usable medium," as used herein, refers to any medium that<br>
provides information or is usable by the processors) 1304. Such a medium may take many<br>
forms, including, but not limited to, non-volatile, volatile and transmission media. Non-<br>
volatile media, i.e., media that can retain information in the absence of power, includes the<br>
ROM 1309. Volatile media, i.e., media that can not retain information in the absence of<br>
power, includes the main memory 1308. Transmission media includes coaxial cables, copper<br>
wire and fiber optics, including the wires that comprise the bus 1303. Transmission media<br>
can also take the form of carrier waves; i.e., electromagnetic waves that can be modulated, as<br>
in frequency, amplitude or phase, to transmit information signals. Additionally, transmission<br>
media can take the form of acoustic or light waves, such as those generated during radio<br>
wave and infrared data communications.<br>
Common forms of computer-usable media include, for example: a floppy disk,<br>
flexible disk, hard disk, magnetic tape, any other magnetic medium, CD-ROM, any other<br>
optical medium, punchcards, papertape, any other physical medium with patterns of holes,<br>
RAM, ROM, PROM (i.e., programmable read only memory), EPROM (i.e., erasable<br>
programmable read only memory), including FLASH-EPROM, any other memory chip or<br>
cartridge, carrier waves, or any other medium from which a processor 1304 can retrieve<br>
information.<br>
Various forms of computer-usable media may be involved in providing one or more<br>
sequences of one or more instructions to the processor(s) 1304 for execution. For example,<br>
the instructions may initially be provided on a magnetic disk of a remote computer (not<br>
shown). The remote computer may load the instructions into its dynamic memory and then<br>
transit them over a telephone line, using a modem. A modem local to the processing unit<br>
may receive the instructions on a telephone line and use an infrared transmitter to convert the<br>
instruction signals transmitted over the telephone line to corresponding infrared signals. An<br>
infrared detector (not shown) coupled to the bus 1303 may receive the infrared signals and<br>
place the instructions therein on the bus 1303. The bus 1303 may carry the instructions to the<br>
main memory 1308, from which the processors) 1304 thereafter retrieves and executes the<br>
instructions. The instructions received by the main memory 1308 may optionally be stored<br>
on the storage device 1310, either before or after their execution by the processor(s) 1304.<br>
Each processing unit may also include a communication interface 1314 coupled to the<br>
bus 1303. The communication interface 1314 provides two-way communication between the<br>
respective user stations 1224 and the host computer 1222. The communication interface<br>
1314 of a respective processing unit transmits and receives electrical, electromagnetic or<br>
optical signals that include data streams representing various types of information, including<br>
instructions, messages and data.<br>
A communication link 1315 links a respective user station 1224 and a host computer<br>
1222. The communication link 1315 may be a LAN ] 225, in which case the communication<br>
interface 1314 may be a LAN card. Alternatively, the communication link 1315 may be a<br>
PSTN 1228, in which case the communication interface 1314 may be an integrated services<br>
digital network (ISDN) card or a modem. Also, as a further alternative, the communication<br>
link 1315 may be a wireless network 1230.<br>
A processing unit may transmit and receive messages, data, and instructions,<br>
including program, i.e., application, code, through its respective communication link 1315<br>
and communication interface 1314. Received program code may be executed by the<br>
respective processor(s) 1304 as it is received, and/or stored in the storage device 1310, or<br>
other associated non-volatile media, for later execution. In this manner, a processing unit<br>
may receive messages, data and/or program code in the form of a carrier wave.<br>
In the foregoing specification, the invention has been described with reference to<br>
specific embodiments thereof. It will, however, be evident that various modifications and<br>
changes may be made thereto without departing from the broader spirit and scope of the<br>
invention. For example, the reader is to understand that the specific ordering and<br>
combination of process actions shown in the process flow diagrams described herein is<br>
merely illustrative, and the invention can be performed using different or additional process<br>
actions, or a different combination or ordering of process actions. The specification and<br>
drawings are, accordingly, to be regarded in an illustrative rather than restrictive sense, and<br>
the invention is not to be restricted or limited except in accordance with the following claims<br>
and their legal equivalents.<br>
WE CLAIM<br>
1. A method for regulating access by a first process to a first data location on<br>
a storage device, comprising: receiving from the first process a request to<br>
access the first data location on a storage device, the request comprising<br>
a first information adapted to identify the first data location and a second<br>
information adapted to identify the first process; comparing a<br>
corresponding portion of the second information with a relevant portion of<br>
a third information which is adapted to identify an access right of the first<br>
process; and granting access to the first data location and modifying the<br>
third information if the corresponding portion of the second information<br>
matches the relevant portion of the third information.<br>
2. The method as claimed in claim 1, wherein the step of granting access<br>
comprises changing data associated with a second data location by the<br>
first process to deny the second process of accessing the second data<br>
location.<br>
3. The method as claimed in claim 1, wherein the third information is<br>
persistent.<br>
4. The method as claimed in claim 1, wherein the storage device is a first<br>
storage device and the third information is stored in a second storage<br>
device.<br>
5. The method as claimed in claim 1, wherein the second storage device is a<br>
memory.<br>
6. The method as claimed in claim 1, wherein the first process comprises<br>
multiple processes.<br>
7. The method as claimed in claim 1, wherein the request comprises an<br>
additional information adapted to identify the access right of the first<br>
process, and processing the additional information to determine the<br>
access right.<br>
8. The method as claimed in claim 7, wherein the access to the first data<br>
location is granted, the method comprises granting access to the first data<br>
location when both the processing of said additional information, and<br>
comparing a corresponding portion of the second information with a<br>
relevant portion of the third information succeed.<br>
9. The method as claimed in claim 7, comprising denying access to the first<br>
data location when either the processing of said additional information, or<br>
the comparison of a corresponding portion of the second information with<br>
a relevant portion of the third information fails.<br>
10. The method as claimed in claim 1, wherein said request to access the first<br>
data location is a data output request.<br>
11. The method as claimed in claim 1, wherein said request to access the first<br>
data location is a data input request.<br>
12. The method as claimed in claim 1, wherein said request to access the first<br>
data location is a access-blocking request.<br>
13. The method as claimed in claim 2, wherein the step of changing data in<br>
the second data location comprises changing a second storage key to a<br>
pre-defined value.<br>
14. The method as claimed in claim 2, wherein the request comprises an<br>
additional information adapted to identify the access right of a second<br>
process to multiple storage devices.<br>
15. The method as claimed in claim 1, wherein the step of modifying the third<br>
information is performed by applying a logical or operator to the third<br>
information and a fourth information.<br>
16. The method as claimed in claim 1, wherein the step of modifying the third<br>
information is performed by applying a logical and operator to the third<br>
information and a fourth information.<br>
17. The method as claimed in claim 15, wherein the fourth information is a<br>
key mask.<br>
18. The method as claimed in claim 1 comprises denying access to the first<br>
data location if the corresponding portion of the second information does<br>
not match the relevant portion of the third information.<br>
19. The method as claimed in claim 18, wherein the step of denying access<br>
comprising sending a message to the first process or generating a fault.<br>
20. The method as claimed in claim 18, wherein the step of denying access is<br>
initiated by the first process.<br>
21. The method as claimed in claim 18, wherein the step of denying access is<br>
initiated by the storage device.<br>
22. A system for regulating access by a first process to a first data location on<br>
a storage device, comprising: means for receiving from the first process a<br>
request to access the first data location on a storage device, the request<br>
comprising a first information adapted to identify the first data location<br>
and a second information adapted to identify the first process; means for<br>
comparing a corresponding portion of the second information with a<br>
relevant portion of a third information which is adapted to identify an<br>
access right of the first process; and means for granting access to the first<br>
data location and modifying the third information if the relevant portion cf<br>
the second information matches the corresponding portion of the third<br>
information.<br>
23. The system as claimed in claim 22, wherein the first process comprises<br>
multiple processes.<br>
24. The system as claimed in claim 22, wherein the request comprises<br>
additional information adapted to identify the first process.<br>
25. The system as claimed in claim 24, wherein the means for comparing a<br>
corresponding portion of the second information with a relevant portion of<br>
the third information comprises:<br>
means for comparing an additional information to the third information;<br>
means for generating a comparison success if both a corresponding<br>
portion of the additional information matches a first relevant portion of<br>
the third information, and, a corresponding portion of the second<br>
information matches a second relevant portion of the third information;<br>
and<br>
means for generating a comparison failure if either the corresponding<br>
portion of the additional information does not match the first relevant<br>
portion of the third information or if a corresponding portion of the second<br>
information does not match the second relevant portion of the third<br>
information.<br>
26. The system as claimed in claim 22, wherein the means for granting access<br>
comprising means for changing one or more additional storage keys each<br>
of which is associated with an additional data location by the first process<br>
to deny the second process of accessing the additional data locations.<br>
27. The system as claimed in claim 26, wherein the means for changing the<br>
data in the second data location comprises means for changing the<br>
additional storage keys to pre-defined values.<br>
28. The system as claimed in claim 22, wherein the request to access the first<br>
data location is a data output request.<br>
29. The system as claimed in claim 22, wherein the request to access the first<br>
data location is a data input request.<br>
30. The system as claimed in claim 22, wherein the request to access the first<br>
data location is an access-blocking request.<br>
31. The system as claimed in claim 22, wherein the means for modifying the<br>
third information comprises means for applying a logical OR operator to<br>
the third information and a fourth information.<br>
32. The system as claimed in claim 22, wherein the means for modifying the<br>
third information comprises means for applying a logical AND operator to<br>
the third information and a fourth information.<br>
33. The system as claimed in claim 22, comprises means for denying access<br>
to the first data location if the corresponding portion of the second<br>
information does not match the relevant portion of the third information.<br>
This invention relates to a method for regulating access by a first process to a<br>
first data location on a storage device, comprising: receiving from the first<br>
process a request to access the first data location on a storage device, the<br>
request comprising a first information adapted to identify the first data location<br>
and a second information adapted to identify the first process; comparing a<br>
corresponding portion of the second information with a relevant portion of a third<br>
information which is adapted to identify an access right of the first process; and<br>
granting access to the first data location and modifying the third information if<br>
the corresponding portion of the second information matches the relevant<br>
portion of the third information.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtYXNzaWdubWVudC5wZGY=" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtY29ycmVzcG9uZGVuY2UucGRm" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtZXhhbWluYXRpb24gcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtZm9ybSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtZm9ybSAxOC5wZGY=" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtZm9ybSAyLnBkZg==" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-form 2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtZm9ybSAyNi5wZGY=" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtZm9ybSAzLnBkZg==" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtZm9ybSA1LnBkZg==" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtcmVwbHkgdG8gZXhhbWluYXRpb24gcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUzMy1rb2xucC0yMDAzLWdyYW50ZWQtc3BlY2lmaWNhdGlvbi5wZGY=" target="_blank" style="word-wrap:break-word;">1533-kolnp-2003-granted-specification.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="224743-tufted-laminate-web.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="224745-a-method-for-preparation-of-regenerative-type-synthetic-cold-rolling-oil-formulation.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>224744</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1533/KOLNP/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>43/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>24-Oct-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>22-Oct-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>24-Nov-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>ORACLE INTERNATIONAL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>500 ORACLE PARKWAY, MS 50P7, REDWOOD SHORES, CA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>BRIDGE, WILLIAM</td>
											<td>2969 SEAVIEW PARKWAY, ALAMEDA, CA 94502</td>
										</tr>
										<tr>
											<td>2</td>
											<td>LONG, RICHARD</td>
											<td>1040 CONTINENTALS WAY, NO.14 BELMONT, CA 94002</td>
										</tr>
										<tr>
											<td>3</td>
											<td>RITTO, PATRICK</td>
											<td>295 GLORIA CIRCLE, MENLO PARK, CA 94025</td>
										</tr>
										<tr>
											<td>4</td>
											<td>SEPEZ, THOMAS</td>
											<td>3877, RANCHO PALOMARES, CASTRO VALLEY, CA 94552</td>
										</tr>
										<tr>
											<td>5</td>
											<td>PRUSCINO, ANGELO</td>
											<td>436 DISTEL DR, LOS ALTOS, CA 94022</td>
										</tr>
										<tr>
											<td>6</td>
											<td>WILLIAMS, JAMES</td>
											<td>1266 FREMONT TERRACE, SUNNYVALE, CA 94087</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 12/14</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US02/16535</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-05-22</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/873,130</td>
									<td>2001-05-31</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/224744-storage-access-keys by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:00:12 GMT -->
</html>
