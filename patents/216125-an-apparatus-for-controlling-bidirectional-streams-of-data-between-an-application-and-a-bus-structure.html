<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/216125-an-apparatus-for-controlling-bidirectional-streams-of-data-between-an-application-and-a-bus-structure by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:18:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 216125:&quot;AN APPARATUS FOR CONTROLLING BIDIRECTIONAL STREAMS OF DATA BETWEEN AN APPLICATION AND A BUS STRUCTURE&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;AN APPARATUS FOR CONTROLLING BIDIRECTIONAL STREAMS OF DATA BETWEEN AN APPLICATION AND A BUS STRUCTURE&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>An isochronous data pipe provides a bi-directional path for data between an application and a bus structure. The isochronous data pipe includes the ability to send, receive and perform manipulations on any isochronous stream of data, including data on any number of isochronous channels. The isochronous data pipe is a programmable sequencer that operates on the stream of isochronous data as it passes through the isochronous data pipe. The isochronous data pipe is programmed by an application to perform specific operations on the stream of data before the data is either transmitted across the bus structure or sent to the application, thereby pre-processing and manipulating the data before it is delivered to its destination. The operations are performed on both the packet header and the data field of the data packet. The isochronous data pipe can be stopped and started on the occurrence of specific events. In an alternate embodiment of the present invention, the isochronous data pipe is programmed to send and receive both isochronous and asynchronous data, including generating requests and appropriate packet headers.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FIELD OF THE INVENTION:	             <br>
	.      <br>
The present invention relates to an appartus for controlling bedirectional streams of data between an<br>
application and a bus structure. More particularly, the present invention relates to the field of<br>
managing and manipulating a high-speed stream of isochronous data to complete a data transfer operation between an application and node coupled to a bus structure.<br>
BACKGROUND OF THE INVENTION:<br>
The IEEE 1394 standard, "P1394 Standard For A High Performance Serial Bus," Draft 8.01vl, June 16, 1995, is an international standard for implementing an inexpensive highÂ¬speed serial bus architecture which supports both asynchronous and isochronous format data transfers. Isochronous data transfers are real-time transfers which take place such that the time intervals between significant instances have the same duration at both the transmitting and receiving applications. Each packet of data transferred isochronously is transferred in its own time period. An example of an ideal application for the transfer of data isochronously would be from a video recorder to a television set The video recorder records images and sounds and saves the data in discrete chunks or packets. The video recorder then transfers each packet, representing the image and sound recorded over a limited time period, during that time period, for display by the television set The IEEE 1394 standard bus architecture provides multiple channels for isochronous data transfer between applications. A six bit channel number is broadcast with the data to ensure reception by the appropriate application. This allows multiple applications to simultaneously transmit isochronous data across the bus structure. Asynchronous transfers are traditional data transfer operations which take place as soon as possible and transfer an amount of data from a source to a destination.<br><br>
The IEEE 1394 standard provides a high-speed serial bus for interconnecting digital devices thereby providing a universal I/O connection. The IEEE 1394 standard defines a digital interface for the applications thereby eliminating the need for an application to convert digital data to analog data before it is transmitted across the bus. Correspondingly, a receiving application will receive digital data from the bus, not analog data, and will therefore not be required to convert analog data to digital data. The cable required by the IEEE 1394 standard is very thin in size compared to other bulkier cables used to connect such devices. Devices can be added and removed from an IEEE 1394 bus while the bus is active. If a device is so added or removed the bus will then automatically reconfigure itself for transmitting data between the then existing nodes. A node is considered a logical entity with a unique address on the bus structure. Each node provides an identification ROM, a standardized set of control registers and its own address space.<br>
The IEEE 1394 standard defines a protocol as illustrated in Figure 1. This protocol includes a serial bus management block 10 coupled to a transaction layer 12, a link layer 14 and a physical layer 16.  The physical layer 16 provides the electrical and mechanical connection between a device or application and the IEEE 1394 cable. The physical layer 16 also provides arbitration to ensure that all devices coupled to the IEEE 1394 bus have access to the bus as well as actual data transmission and reception.  The link layer 14 provides data packet delivery service for both asynchronous and isochronous data packet transport. This supports both asynchronous data transport, using an acknowledgement protocol, and isochronous data transport, providing real-tune guaranteed bandwidth protocol for just-in-time data delivery. The transaction layer 12 supports the commands necessary to complete asynchronous data transfers, including read, write and lock.  The serial bus management block 10 contains an isochronous resource manager for managing isochronous data transfers. The serial bus management block 10 also provides overall configuration control of the serial bus in the form of optimizing arbitration timing, guarantee of adequate electrical power for all devices on the bus, assignment of the cycle master, assignment of isochronous channel and bandwidth resources and basic notification of errors.<br><br>
To initialize an isochronous transfer, several asynchronous data transfers may be required to configure the applications and to determine the specific channel which will be used for transmission of data. Once the channel has been determined, buffers are used at the transmitting application to store the data before it is seni and at the receiving application to store the data before it is processed. In a general purpose host or peripheral implementation, the format of the transmitted data is not in form which can be used by the application. In most cases, a general purpose processor must preprocess the stream of data before sending it to the application. Often, the preprocessing task consumes considerable computational power which can make it impossible to effectively handle the real time stream of data.<br>
What is needed is an isochronous data pipe that provides the ability to the application to manage and manipulate a high-speed stream of data being sent from or received by the application over a bus structure. What is further needed is an isochronous data pipe which allows the application to transmit and receive data in its native format, thereby improving the ability of the application to effectively handle a continuous stream of data over time.<br>
Accordingly, there is a apparatus for controlling bidirectional streams of data between an application (12, 14) and a bus structure (58) comprising: (a) a receiving circuit (44) for receiving a stream of data from a source selected from the application (12, 14) and the bus structure (58) and forming a received stream of data; (b) a control store memory (24) coupled to the receiving circuit (44) and to the application (12, 14), wherein the applicationX12, 14) stores a series of at least one operation codes within the control store memory (24) for performing manipulations on the received stream of data required by the application; and (c) a converting circuit (20) coupled to the control store memory (24) and to the receiving circuit for obtaining the series of operation codes and converting the received stream of data into an output stream of data by executing the series of operation codes.<br><br>
SUMMARY OF THE INVENTION:<br>
An isochronous data pipe provides a bi-directional path for data between an application and a bus structure. The isochronous data pipe includes the ability to send, receive and perform manipulations on any isochronous stream of data, including data on any number of isochronous channels. The isochronous data pipe is a programmable sequencer that operates on the stream of isochronous data as it passes through the isochronous data pipe. The isochronous data pipe is programmed by an application to perform specific operations on the stream of data before the data is either transmitted across the bus structure or sent to the application, thereby pre-processing and manipulating the data before it is delivered to its destination.  The operations are performed on both the packet header and the data field of the data packet.  The isochronous data pipe can be stopped and started on the occurrence of specific events.  In an alternate embodiment of the present invention, the isochronous data<br><br>
pipe is programmed to send and receive both isochronous and asynchronous data, including generating requests and appropriate packet headers.<br>
BRIEF DESCRIPTION OF THE DRAWINGS:<br>
Figure 1 illustrates a protocol defined by the IEEE 1394 standard.<br>
Figure 2 illustrates a block diagram schematic of a link circuit including an isochronous data pipe according to the present invention and an asynchronous data pipe.<br>
Figure 3 illustrates a register file within the isochronous data pipe.<br>
Figure 4 illustrates a register file within the isochronous data pipe sequencer.<br>
Figure 5 illustrates an example of an isochronous data stream showing the isochronous recording format.<br>
DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT:<br>
An isochronous data pipe transmits and receives data for an application across a bus structure. Preferably, the bus structure is an IEEE 1394 standard bus structure. The isochronous data pipe is programmable and will execute a series of instructions on a stream of data in order to perform manipulations on the data required by the application. In a link circuit, an isochronous data pipe is included for transmitting and receiving isochronous data and an asynchronous data pipe is included for transmitting and receiving asynchronous data. The data from the isochronous data pipe and the asynchronous data pipe is multiplexed onto the bus structure. The data received from the bus structure is demultiplexed to the isochronous data pipe and the asynchronous data pipe. Alternatively, the isochronous data pipe is programmed to transmit and receive both isochronous and asynchronous data.<br>
A link circuit including an isochronous data pipe (IDP), according to the present invention, and an asynchronous data pipe is illustrated in Figure 2.  The link circuit 10 provides a link between applications 12 and 14 and a bus structure 58.  The applications 12 and 14 are both coupled to a system bus 16. The system bus 16 is coupled to both the isochronous data pipe 20 and the asynchronous data pipe 26.  The applications 12 and 14 are<br>
. also both coupled to an applications interface circuit 18.  The applications interface circuit 18 is coupled to a set of control registers 38, to the isochronous data pipe 20, to the asynchronous data pipe 26 and to a link core 44.  Both the isochronous data pipe and the asynchronous data pipe 26 include a register set 24 and 28, respectively.  The outbound FIFO 30 corresponds to the isochronous data pipe 20 and is coupled between the isochronous data pipe 20 and a multiplexer 40. The outbound FIFO 32 corresponds to the asynchronous data pipe 26 and is coupled between the asynchronous data pipe 26 and the multiplexer 40. The control registers 38 are also coupled to both the isochronous data pipe 20 and the asynchronous data pipe 26. An inbound FIFO 34 is coupled to a demultiplexer 42.  The demultiplexer 42 is coupled to both the isochronous data pipe 20 and the asynchronous data pipe 26.<br>
The link core 44 includes a transmitter 46, a receiver 48, a cycle timer 50, a cycle monitor 52, a CRC error checking circuit 54 and a physical interface circuit 56 for physically interfacing to the bus structure 58. The transmitter 46 is coupled to the multiplexer 40, to the cycle tuner 50, to the CRC error checking circuit 54 and to the physical interface circuit 56. The receiver 48 is coupled to the inbound FIFO 34, to the cycle monitor 52, to the CRC error checking circuit 54 and to the physical interface circuit 56.  The cycle timer 50 is coupled to the cycle monitor 52. The physical interface circuit 56 is coupled to the bus structure 58.<br>
The link circuit 10, illustrated in Figure 2, includes a single FIFO 34 for all incoming data, both isochronous and asynchronous, a FIFO 30, dedicated to the isochronous data pipe 20 for outbound data and a FIFO 32, dedicated to the asynchronous data pipe 26 for outbound data. The outbound data from the FIFOs 30 and 32 are multiplexed, by the multiplexer 40, through the link core 44 and onto the bus structure 58. The inbound data from the FIFO 34 is directed to either the isochronous data pipe 20 or the asynchronous data pipe 26, by the demultiplexer 42, as will be discussed below.<br>
Preferably, the inbound FIFO 34 is thirty-three bits wide, the outbound FIFO 30 is thirty-four bits wide and the outbound FIFO 32 is thirty-three bits wide.   In each of the FIFOs 30, 32 and 34, bits 0 through 31 are designated to carry data and bit 32 is designated to carry<br><br>
a packet boundary marker. For outbound packets, the isochronous data pipe 20 and the asynchronous data pipe 26 set the bit 32 to a logical high voltage level on the first quadlet of each packet. For inbound packets, the link core 44 sets the bit 32 to a logical high voltage level on the first quadlet of each packet.<br>
In the outbound FIFO 30, corresponding to the isochronous data pipe 20, bit 33 is designated to indicate an isochronous cycle boundary. The isochronous data pipe 20 sets the bit 33 to a logical high voltage level on the first quadlet of the first isochronous packet in each isochronous cycle.  When the link core 44 receives a quadlet of data with the bit 33 set to a logical high voltage level, it delays until the next cycle start, then transmits all isochronous packets in the outbound FIFO 30 until another quadlet with the bit 33 set to a logical high voltage level is detected.<br>
To transmit application data, from one of the applications 12 and 14, onto the bus structure 58, the isochronous .data pipe 20 and the asynchronous data pipe 26 both generate appropriate header information and append the appropriate application data to form a packet in the form required by the bus structure 58. These packets are then stored in the appropriate FIFO 30 and 32 for transmission onto the bus structure 58.<br>
The asynchronous data pipe 26 is preferably implemented as described hi co-pending<br>
U.S. Patent Application Serial Number	, filed on the same date as the present<br>
application and entitled "Asynchronous Data Pipe For Automatically Managing Asynchronous Data Transfers Between An Application And A Bus Structure," which is hereby incorporated by reference. The asynchronous data pipe 26 automatically generates transactions necessary to complete asynchronous data transfer operations for an application over a bus structure. The asynchronous data pipe 26 includes a register file 28 which is programmed by the application. The register file 28 allows the application to program requirements and characteristics for the data transfer operation.  The register file 28 includes bus speed, transaction label, transaction code, destination node identifier, destination offset address, length of each data packet, packet counter, packet counter bump field, control field and a status field.<br><br>
After the register file 28 is programmed and initiated by the application, the asynchronous data pipe 26 automatically generates the read or write transactions necessary to complete the data transfer operation over the appropriate range of addresses, using the information in the register file as a template for generating the transactions and headers. The asynchronous data pipe 26 automatically increments the value in the destination offset address field for each transaction according to the length of each data packet, unless an incrementing feature has been disabled, signalling that the transactions are to take place at a single address. The packet counter value represents the number of transactions remaining to be generated. The packet counter value is decremented after each packet of data is transferred. The packet counter bump field allows the application to increment the packet counter value by writing to the packet counter bump field.<br>
Multiple asynchronous data pipes can be included within a link circuit 10 for managing multiple asynchronous data transfer operations. In such a system, each asynchronous data pipe has its own unique transaction label value or range of values. The multiplexer 40 multiplexes the transactions and data packets from the asynchronous data pipes and the isochronous data pipe onto the bus structure 58. The demultiplexer 42 receives signals and data packets from the bus structure 58 and routes them to the appropriate asynchronous data pipe or isochronous data pipe, using the transaction code and the transaction label values.<br>
In the link circuit 10 there is only one isochronous data pipe 20.  This isochronous data pipe 20 can handle multiple isochronous channels and at the data interface, the isochronous data pipe 20 can interact with more than one application. Therefore, the isochronous data pipe 20 can support more than one stream of isochronous data, where each stream of data is made up of one or more isochronous channels.  In an alternative embodiment, as will be described below, the isochronous data pipe 20 can also send and receive asynchronous data, thereby performing the functions of an asynchronous data pipe.<br>
The link core 44 accepts packets of data from the outbound FIFOs 30 and 32, creates packets which comply with the format required by the bus structure 58 and then transfers the<br><br>
packets through the physical interface 56 onto the bus structure 58. The link core 44 transmits one isochronous cycle's worth of data from the outbound isochronous FIFO 30 on each isochronous cycle.  When not transmitting isochronous data, the link core 44 transmits asynchronous packets from the outbound asynchronous FIFO 32.<br>
The link core 44 transmits all received packets to the inbound FIFO 34. Unless the link core 44 is operating in a snoop mode, the link core 44 only receives asynchronous packets addressed to the appropriate node ID and isochronous packets with the proper channel numbers. In the snoop mode, the link core 44 receives all packets regardless of their destination node ID or isochronous channel number.<br>
The isochronous data pipe 20 provides a bi-directional data path for application data which is to be transmitted over the bus structure 58. A stream of isochronous data is made up of data on one or more isochronous channels. The isochronous data pipe 20 can operate on any arbitrary stream of isochronous data, containing data on any number of isochronous channels. The isochronous data pipe 20 is a programmable sequencer that operates on a stream of isochronous data from the bus 16 to the outbound isochronous FIFO 30 or from the receive FIFO 34 to the bus 16.<br>
For each quadlet of data transferred, the isochronous data pipe 20 executes a predetermined number of instructions to manipulate the data as necessary. These instructions can operate on the isochronous data block packet.  When sending data to be output on the bus structure 58, the stream of data output by the isochronous data pipe 20, is dependent on both the stream of data input to the isochronous data pipe 20 and the manipulations performed on the data by the isochronous data pipe 20. Correspondingly, when receiving data from the bus structure 58, the stream of data output by the isochronous data pipe 20 on the bus 16, is dependent on the stream of data input to the isochronous data pipe 20 and the manipulations performed on the data by the isochronous data pipe 20.<br>
The isochronous data pipe 20 supports several scheduling features for the starting and stopping of isochronous data transfers, depending on the current mode of operation of the isochronous data pipe.   With proper programming, the isochronous data pipe supports the<br><br>
isochronous recording data formats, as defined in the SCSI-3 Serial Bus Protocol standard. This protocol defines how to label an isochronous stream of data when it is recorded so that it can be recreated precisely when played back. The isochronous data pipe is a programmable data handling engine in the isochronous data path.  With proper programming, this engine implements the isochronous recording formats, plus includes the ability to filter the data by deleting quadlets, or performing specific operations on each quadlet transferred to or from the bus structure 58.<br>
The FIFO interface for both the isochronous data pipe 20 and the asynchronous data pipe 26 is coupled directly to a FIFO 30 and 32, respectively. The FIFO 30 is dedicated to the data path controlled by the isochronous data pipe 20. The FIFO 32 is dedicated to the data path controlled by the asynchronous data pipe 26. The link interface for the isochronous data pipe 20 and the asynchronous data pipe 26 are both coupled through the multiplexer 40 and the demultiplexer 42 to the link core 44. The data presented from the isochronous data pipe 20 and the asynchronous data pipe 26 to the link core 44 is in a format required by the link core function.  Both the isochronous data pipe 20 and the asynchronous data pipe 26 expect the data coming from the link core 44 to be in the format defined by the link core specification.  If additional logical blocks are included within a system, each logical block is coupled to the link core 44 through the multiplexer 40 and the demultiplexer 42. For example, multiple asynchronous data pipes could be included within a system. In a system with multiple asynchronous data pipes, each of the asynchronous data pipes are coupled to the multiplexer 40 through the FIFO 32. In such a system, an additional multiplexer is included between the asynchronous data pipes and the FIFO 32 for multiplexing packets of data into the FIFO 32.<br>
When directing data from the isochronous data pipe 20, the multiplexer 40 recognizes that when data is available from the isochronous data pipe, the multiplexer 40 transmits one packet of data per isochronous cycle per channel.  The data sent from the link core 44 to the isochronous data pipe 20 and the asynchronous data pipe 26 is routed through the FIFO 34 and the demultiplexer 42.  The demultiplexer 42 does not change any information when it<br><br>
routes packets from the link core 44 to the appropriate one of the isochronous data pipe 20 or the asynchronous data pipe 26. All information produced by the link core is sent to the destination logical block. The isochronous data pipe 20 and the asynchronous data pipe 26 will perform all necessary manipulation of the data from the link core 44 before this data is transferred to one of the applications 12 and 14, which may include stripping header information required by the protocol for the bus structure 58. For outbound data, the isochronous data pipe 20 and the asynchronous data pipe 26 both prepare data from the application so that it is in the proper form, as required by the link core 44. Both the isochronous data pipe 20 and the asynchronous data pipe 26 will generate the appropriate header information and embed that in the data from the application before sending the data to the link core 44 through the muliplexer 40.<br>
For both the isochronous data pipe 20 and the asynchronous data pipe 26, the link interface produces and consumes data in a format which is compatible with the requirements of the link core 44 function.  During a data send operation, the isochronous data pipe 20 will generate the required bus structure specific header information and embed it in the data from the application, as required by the link core 44.  During a data receive operation, for data moving from the link core 44 to either the isochronous data pipe 20 or the asynchronous data pipe 26, the isochronous data pipe 20 and the asynchronous data pipe 26 both accept that data in the format provided by the link core 44. In other words, no manipulation of the data is required to translate data from the link core 44 to the isochronous data pipe 20 or the asynchronous data pipe 26.<br>
When only one logical block is included within a system, that logical block can be connected directly to the link core 44.  When there are multiple logical blocks within a system, the system includes an appropriate multiplexer 40 and demultiplexer 42 between the logical blocks and the link core 44.  The multiplexer 40 is responsible for taking the data at the link interfaces of the multiple logical blocks and multiplexing that data through the link core 44 and onto the bus structure 58 on a packet by packet basis.  This information is application specific and is routed to the bus structure in a priority set by the transferring<br><br>
operation. Each isochronous data packet is sent by the multiplexer 40 during its appropriate time period. The demultiplexer 42 uses the value in the transaction code and the channel number fields of each packet received from the bus structure 58 to route the packet to the appropriate logical block 20 or 26.  If there is no more than one isochronous data pipe 20 and one asynchronous data pipe 26, then the transaction code is all that is required to route the packet appropriately.  The demultiplexer 42 will first read the transaction code to determine that the packet is asynchronous data and should be routed to an asynchronous data pipe. If there is more than one asynchronous data pipe within the system, the demultiplexer 42 then uses the value in the transaction label of the asynchronous response packet header to route the packet to the proper asynchronous data pipe.<br>
The isochronous data pipe of the present invention is a bidirectional data path between a corresponding FIFO and the link core 44.  With proper programming, the isochronous data pipe supports the isochronous data recording format, as documented in the SCSI-3 Serial Bus Protocol (SBP) standard and allows programmable manipulation of the data in the isochronous stream.<br>
When transferring data through the corresponding FIFO 30 to the link core 44 or when receiving data from the demultiplexer 42, the isochronous data pipe 20 operates on each quadlet of data independently.  The isochronous data pipe 20 performs a programmable number of instructions on each quadlet in order to manipulate the data, as necessary. The possible instructions which can be performed by the isochronous data pipe 20 are included within an instruction set, which will be discussed in detail below. The isochronous data pipe 20 also includes an independent, dedicated register file 24 which will also be discussed in detail below.<br>
If a bus reset occurs while the isochronous data pipe 20 is transferring data, the isochronous data pipe 20 operation resumes exactly where it left off when the next cycle start packet appears on the bus structure 58.  Note that although the processing of isochronous data resumes immediately, the embedded application reallocates any channel numbers, bandwidth<br><br>
and any connections in use prior to the bus reset, as defined in the IEEE 1394 standard and the IEC standard for consumer devices.<br>
The isochronous data pipe 20 is controlled by an independent, dedicated register file, as illustrated in Figure 3. This register file is programmed by the originating application and used to generate headers, instructions and transactions necessary to complete an isochronous data transfer operation across the bus structure 58. The register file 80 includes 120 bytes of data, numbered hexadecimally 0 through 77. In Figure 3, the register file 80 is illustrated in a table format with 30 horizontal rows, each including four bytes of data.  An offset column 82 is included in Figure 3, to show the offset of the beginning byte in each row from the address of the beginning of the register file 80. A read/write column 84 is also included to show whether the fields in each row can be either read from and written to or read from only.<br>
The cycle time field cycle_time is a twenty bit field within bytes 0-2 of the register file 80. The cycle time field can be read from and written to.  When the control event field, which will be discussed below, contains the cycle number value, the cycle time field holds the cycle time on which the isochronous data pipe 20 will start or stop transferring isochronous data.<br>
The control field is a thirty-two bit field within bytes 4-7 of the register file 80. The control field can be read from and written to. The control field includes an event field, an output enable field, a stop on error field, a transmit enable field and a go field. The event field is a four bit field in bits 28-31 of the control register.  The value in the event field defines the bus event for the isochronous data pipe 20 to use as a trigger.  When this bus event occurs, the isochronous data pipe transfers the value stored in the pending channel mask register pending_ch_mask to the current channel mask register ch_mask.  The event field is encoded for the possible bus events as illustrated in Table I below.<br><br>
TABLE I<br><br>
(Table Removed)<br>
Therefore, when the event field holds a value equal to 0, the isochronous data pipe will then start or stop immediately.  When the event field holds a value equal to 1, the isochronous data pipe will then start or stop, as specified by the value hi the cycle time field, as discussed above.<br>
The output enable field is a four bit field in bits 4-7 of the control field. When any of the bits in the output enable field are set to a logical high voltage level, then the corresponding DMA channel will assure that the prefill FIFO is kept full and the isochronous data pipe 20 will dispatch to the control store output instruction whenever there is an empty quadlet in the outbound FIFO 30.<br>
The stop on error field is a one bit field in bit 3 of the control field.  When the stop on error bit is set to a logical high voltage level, the isochronous data pipe 20 will stop the current operation on the first error encountered by setting the value in the channel mask register to a logical low voltage level. Possible errors when sending data include a FIFO underrun or a missing cycle start packet. Possible errors when receiving data include a FIFO overrun, a missing cycle start packet, a data CRC error, an error in packet format or a channel missing error.<br><br>
The transmit enable field is a one bit field in bit 1 of the control field.  When the transmit enable bit is set to a logical high voltage level, the isochronous data pipe 20 will begin executing the output control store program.  When the go bit is at a logical low voltage level or the output control store program executes a return instruction, the transmit enable bit will be cleared.<br>
The go field is a one bit field in bit 0 of the control field. The application sets the go bit to a logical high voltage level to enable the isochronous data pipe to watch for an event. When the specified event condition is satisfied, the isochronous data pipe 20 transfers the contents of the pending channel mask register to the current channel mask register.<br>
The status field is a thirty-two bit field within bytes 8-B of the register file 80. The status field can be read from and written to. The status field contains status information which reports the current state of the isochronous data pipe 20. The bits 0-7 of the status field correspond to the bits 0-7 of the control field and include an output field, a stop on error field, a transmit enable field and an active field.  The value of these fields in the status register indicate the current operational state of the isochronous data pipe 20.  The bits 8-27 of the status field are reserved.  Within the status field, the active field is a one bit field in bit 0 of the status field, which indicates whether or not the isochronous data pipe is active. Preferably, if the active bit is equal to a logical high voltage level, the isochronous data pipe is currently active and transferring data. If the active bit is equal to a logical low voltage level, the isochronous data pipe is not currently active. The error field is a four bit field hi bits 28-31 of the status field.  When the isochronous data pipe 20 halts operation due to an error, the error field contains a value indicating the error condition. The error field is only valid when the active bit is equal to a logical low voltage level. The possible values for the error field and the error to which they correspond are listed in Table II below.<br>
TABLE II<br><br>
(Table Removed)<br>
The pending channel mask high field pending_ch_mask_hi is a four byte field within bytes 20-23 of the register file 80. The pending channel mask low field pending_ch_mask_lo is a four byte field within bytes 24-27 of the register file 80. Together, the two pending channel mask fields pending_ch_mask_hi and pending_ch_mask_lo form an eight byte field containing the mask of isochronous channel numbers for the isochronous data pipe 20 to receive. The isochronous data pipe 20 transfers the contents of this field to the channel mask register when the programmed trigger event occurs. The bit assignment of the pending channel mask field is the same as the bit assignment of the channels available register defined hi chapter eight of the IEEE 1394 standard.<br>
The current channel mask high field ch_mask_hi is a four byte field within bytes 28-2B of the register file 80. The current channel mask low field ch_mask_lo is a four byte field within bytes 2C-2F of the register file 80.  Together, the two current channel mask fields ch_mask_hi and ch_mask_lo form an eight byte field containing the channel mask currently hi operation, with each bit within the current channel mask fields representing an isochronous channel.  The channel mask field is only loaded from the pending channel mask field when a<br>
trigger event occurs.  The isochronous data pipe 20 ignores received isochronous channel numbers for which the corresponding bit in the current channel mask field is set to a logical high voltage level.<br>
The control store output field CS_output is a one byte field within byte 34 of the register file 80. The control store output field CS_output contains the control store address within the control store memory, to which the isochronous data pipe 20 dispatches whenever there is an empty quadlet in the outbound FIFO 30 and the isochronous data pipe 20 is not currently receiving an isochronous packet of data. The control store memory contains instructions used by the isochronous data pipe in performing its operations on a stream of data.<br>
The control store cycle start address field CS_addr_CS is a one byte field within byte 37 of the register file 80. The control store address field CS_addr_CS contains the control store address to which the isochronous data pipe branches when the cycle start packet is received. The first quadlet available to the control store program is the first quadlet of the cycle start packet. The control store address fields CS_addr_0 through CS_addr_63 are each one byte fields within bytes 38 through 77 of the register file 80. These fields contain the control store address store where the isochronous data pipe is to branch upon receiving data on the isochronous channel matching the byte number of the control store address field. For example, the control store address field CS_addr_10 contains the address in the control store where the isochronous data pipe is to branch upon receiving data on the isochronous channel number 10.  The isochronous data pipe ignores all isochronous channels for which the corresponding value in the control store address field is equal to FFh. It should be noted that the behavior of the control store address field is the same when transmitting as when receiving isochronous data.<br>
There are sixty-four potential isochronous channels 0-63.  The control store address fields CS_addr_0 through CS_addr_63 each correspond to an isochronous channel and contain the address in the control store memory where the instructions for that isochronous channel begin.  Accordingly, when the isochronous data pipe 20 receives data on a particular<br>
isochronous channel, the isochronous data pipe 20 branches to the address contained in the corresponding control store address field to obtain the instructions for manipulating the data for that channel.  Isochronous channels for which the corresponding value in the control store address field is equal to FFh are ignored.<br>
A stream of isochronous data is made up of one or more isochronous channels. The isochronous data pipe 20 receives isochronous channels for which the corresponding bit in the current channel mask field is set to a logical high voltage level.  The isochronous data pipe 20 transmits isochronous data according to the control store program beginning at the control store address pointed to by the value in the control store output CS_output register.  For example, if the isochronous channels 3, 4 and 5 exist on the bus structure 58 and the application wants the isochronous data pipe 20 to combine channels 3 and 5 into a single stream without performing any manipulation on the data contained in these isochronous channels, then the application programs a value of "lOh," for example, into the control store address fields CS_addr_3 and CS_addr_5. At the control store address "lOh," the application then loads an instruction sequence as shown in Table III.<br>
TABLE III<br>
 (Table Removed)<br>
The application then programs a value of "28h" into the pending channel mask, then writes a value of "1" into the control field. This value in the control field indicates an event of immediate with no DMA channels programmed for output. The result is that the isochronous data pipe 20 immediately shifts the value of the pending channel mask field into the current channel mask field. Because the bits 3 and 5 are now set to a logical high voltage level in the current channel mask field, the isochronous data pipe 20 will begin processing the isochronous channels 3 and 5 according to the control store program beginning at address "lOh." Note that in this example both the control store fields CS_addr_3 and CS_addr_5 contain a value of "lOh," so that the data for both of the isochronous channels 3 and 5 is processed according to the same control store instruction sequence, beginning at the address "lOh."<br>
The control store program illustrated in Table III is a program which moves the data from the receive FIFO 34 onto the DMA channel 0 on the bus 16. The isochronous data pipe 20 ignores any data received on isochronous channel 4 because the bit 4 in the current channel mask field is not set to a logical high voltage level.<br>
In the last line of the control store program illustrated in Table III, a return instruction is included.  In all cases, the return instruction causes the isochronous data pipe 20 to perform the same tasks; namely, the isochronous data pipe decrements the value of the stack pointer and dispatches to the instruction within the stack which the stack pointer is currently pointing to. If the stack pointer is equal to zero when a return instruction is executed, the isochronous data pipe 20 halts operation until the next enabled isochronous channel is received or a cycle start packet is received.  If the isochronous data pipe 20 is executing an output control store program, a return instruction will cause the isochronous data pipe to resume operation at the instruction where the output program was interrupted by the received isochronous packet.<br>
The isochronous data pipe is actually a programmable sequencer which can be programmed to perform operations on the received stream of isochronous data.  The isochronous data pipe sequencer contains a register file as illustrated in Figure 4.  Within the register file 90, the immediate value register IMM is a thirty-four bit register with a register<br><br>
code of "0" which can only be a source register. The immediate value register IMM specifies that the thirty-four bit immediate field of the instruction contains the source data for the given operation.<br>
The bus input register BUS_IN is a thirty-two bit register with a register code of "1" which can only be a source register. Accessing the bus input register BUS_IN as a source of an operation clocks one quadlet of data from the receive FIFO 34 through the isochronous data pipe 20.  Subsequent accesses to the bus input register BUS_IN access subsequent quadlets of data in the input data stream.<br>
The bus output register BUS_OUT is a thirty-four bit register with a register code of "2" which can only be a destination register. Accessing the bus output register BUS_OUT as a destination of an operation clocks one quadlet of data through the isochronous data pipe 20 to the outbound isochronous FIFO 30.  Subsequent accesses to the bus output register BUS_OUT clock subsequent quadlets of data in the output data stream.<br>
The data registers DO-D7 are each thirty-four bit registers with a register code of "4", "5", "6", "7", "8", "9", "A" and "B", respectively, which can be either a source or destination register. The data registers DO-D7 can be used as the source or destination register for any operation.<br>
The data interface registers DATA_0-DATA_3 are each thirty-two bit registers with a register code of "10", "11", "12" and "13", respectively, which can be either a source or<br>
*<br>
destination register. Each of the data interface registers DATA_0-DATA_3 access a different DMA channel. Use of these registers is to be consistent with the programming of the output enable field DMA_out_en.<br>
The isochronous data pipe 20 implements a stack made up of a linear list of eight one byte registers.  The stack registers are only accessed during a branch to subroutine instruction and a return instruction.  In the preferred embodiment of the present invention, the stack registers SO-S7, each have a respective register address 0-7.  Alternatively, the actual number of stack registers will vary depending on the specific implementation.  When the control store<br><br>
program is loaded, the stack pointer is automatically initialized to a value of zero, thereby pointing to the corresponding stack register SO.<br>
When the isochronous data pipe 20 branches to a subroutine, the isochronous data pipe 20 decrements the stack pointer, stores the address of the next control store instruction into the current stack register, increments the value of the stack pointer, then branches to the control store instruction contained in the low order byte of the source field. When the isochronous data pipe 20 executes a return instruction, it decrements the stack pointer, then the isochronous data pipe 20 branches to the control store instruction contained in the current stack register. If the stack pointer is decremented when it contains a value equal to zero, the value of the stack pointer will remain at zero and the isochronous data pipe 20 will halt operation until it receives an isochronous data packet or cycle start packet. When the isochronous data pipe is executing an output control store program and a cycle start packet or enabled isochronous channel is received, the isochronous data pipe 20 will interrupt execution of the output control store program, save the address of the current instruction in the stack, decrement the stack pointer and then dispatch to the proper location to handle the received packet.<br>
Each isochronous control store instruction includes an OpCode field, a source field, a destination field, an immediate value field, an immediate field and a reserved field.  The OpCode field is a six bit field which describes an operation to perform, as will be discussed below hi reference to Figure 5. The source field src is a four bit field which specifies a register or immediate value which contains the source value for the specified operation. The destination field dest is a four bit field which specifies a destination register for the specified operation. The immediate value field imm_val is a one bit field which when set to a logical high voltage level, specifies that one of the operands is contained in the immediate field. The immediate field imm is a thirty-four bit field which specifies an immediate value to use for an operation if the immediate value field imm_val is set to a logical high voltage level.  In the preferred embodiment of the present invention, the reserved field includes thirteen bits which are reserved for use in alternate embodiments of the isochronous data pipe 20.<br><br>
The operation codes which are implemented by the isochronous data pipe sequencer during manipulation of a data stream and can be included in the OpCode field are listed in Table IV below.  The isochronous data pipe 20 will store the results for any of these operations into any register which is capable of being a destination, as illustrated hi Figure 4, including the data registers DO-D7, the outbound isochronous FIFO 30 and any DMA channel which is configured as a destination.<br>
TABLE IV<br><br>
(Table Removed)<br>
For most of the operations listed in Table IV, there are included two mnemonic instructions. The mnemonic instruction which includes an "I" specifies the operation is to be conducted using the immediate value. The mnemonic instruction which does not include an "I" specifies the operation is to be conducted between the values in the source and destination registers.<br>
When a MOVE operation is performed, the value in the register specified in the source field src is moved to the register specified in the destination field dest. If the register specified in the source field src is a thirty-four bit register and the register specified in the destination field dest is a thirty-two bit register, the high order two bits will be lost. If the register specified in the source field src is a thirty-two bit register and the register specified in the destination field dest is a thirty-four bit register, then the high order two bits will both be set to a logical low voltage level.<br>
When a MOVE Multiple operation is performed, a number of quadlets of data specified by a count value are moved from the register specified in the source field src to the register specified in the destination field dest. The count value is stored in the register designated in the immediate field of the instruction. Preferably, for the MOVE Multiple operation, the register specified in the source field src is one of the data interface registers DATA_0 - DATA_3, which access a DMA channel, or the bus input register BUS_IN. Preferably, for this operation, the register specified in the destination field dest is one of the data interface registers DATA_0 - DATA_3, which access a DMA channel, or the bus output register BUS_OUT.<br>
During an AND operation, a logical AND operation is performed on the values in the source field src and the destination field dest and the result is stored in the register specified in the destination field dest. The ANDI form of this instruction uses the value in the immediate field instead of the value in the destination field as one of the operands and stores the result in the register specified in the destination field dest.  If the register specified in the source field src is a thirty-four bit register and the register specified in the destination field dest is a thirty-two bit register, the high order two bits will be lost.  If the register specified in the source field src is a thirty-two bit register and the register specified in the destination field<br>
dest is a thirty-four bit register, then the high order two bits will both be set to a logical low voltage level. If both the register specified in the source field src and the register specified in the destination field dest are thirty-four bit registers, then the AND operation is performed on all thirty-four bits.<br>
During an OR operation, a logical OR operation is performed on the values in the registers specified by the source field src and the destination field dest and the result is stored in the register specified in the destination field dest. The ORI form of this instruction uses the value hi the immediate field instead of the value in the destination field as one of the operands and stores the result hi the register specified hi the destination field dest. If the register specified in the source field src is a thirty-four bit register and the register specified hi the destination field dest is a thirty-two bit register, the high order two bits will be lost. If the register specified in the source field src is a thirty-two bit register and the register specified in the destination field dest is a thirty-four bit register, then the high order two bits will both be set to a logical low voltage level.  If both the register specified hi the source field src and the register specified in the destination field dest are thirty-four bit registers, then the OR operation is performed on all thirty-four bits.<br>
When a SHIFT operation is performed, the value in the destination register dest is shifted by the number of bits specified by the value in the source register src and the result is stored in the register specified in the destination field dest. A positive shift value shifts the value in the destination register to the right towards the least significant bit and zeros are used to fill in the shifted bits on the left beginning with the most significant bit. A negative shift value shifts the value in the destination register to the left towards the most significant bit and zeros are used to fill in the shifted bits on the right beginning with the least significant bit. The SHIFTI form of this instruction shifts the value in the source register by the number of bits specified in the immediate field and stores the result in the register specified in the destination field.  If the register specified in the source field src is a thirty-four bit register and the register specified in the destination field dest is a thirty-two bit register, the high order two bits will be lost.  If the register specified in the source field src is a thirty-two bit register<br>
and the register specified in the destination field dest is a thirty-four bit register, then the high order two bits will both be set to a logical low voltage level.  If both the register specified in the source field src and the register specified in the destination field dest are thirty-four bit registers, then the shift operation is performed on only the low order thirty-two bits.<br>
When a CMP operation is performed, the value in the source register src is subtracted from the value in the destination register dest. If the result of the CMP operation is a positive value, the Z bit is set to a logical high voltage level. If the result of the CMP operation is a negative or zero value, the Z bit is set to a logical low voltage level. The results of the CMP operation are not stored anywhere. The CMPI form of this instruction subtracts the immediate value from the value in the source register src, and sets the Z bit as specified above, according to the result. This instruction also does not store the result of the operation.<br>
When an ADD operation is performed, the value in the source register src is added to the value in the destination register dest and the result is stored in the destination register dest. The ADDI form of this instruction adds the value in the source register src to the immediate value and stores the result in the destination register dest.  If the register specified in the source field src is a thirty-four bit register and the register specified in the destination field dest is a thirty-two bit register, the high order two bits will be lost. If the register specified in the source field src is a thirty-two bit register and the register specified in the destination field dest is a thirty-four bit register, then the high order two bits will both be set to a logical low voltage level.  If both the register specified in the source field src and the register specified in the destination field dest are thirty-four bit registers, then the ADD operation is performed on only the low order thirty-two bits.<br>
When a SUB operation is performed, the value in the destination register dest is subtracted from the value in the source register src and the result is stored in the destination register dest.  The SUBI form of this instruction subtracts the immediate value from the value in the source register and the result is stored in the destination register dest.  If the register specified in the source field src is a thirty-four bit register and the register specified in the destination field dest is a thirty-two bit register, the high order two bits will be lost.  If the<br><br>
register specified in the source field src is a thirty-two bit register and the register specified in the destination field dest is a thirty-four bit register, then the high order two bits will both be set to a logical low voltage level. If both the register specified in the source field src and the register specified in the destination field dest are thirty-four bit registers, then the SUB operation is performed on only the low order thirty-two bits.<br>
When a MULT operation is performed, the value hi the source register src is multiplied by the value in the destination register dest and the result is stored hi the destination register dest. The MULTI form of this instruction multiplies the immediate value by the value in the source register src and the result is stored in the destination register dest. If the register specified in the source field src is a thirty-four bit register and the register specified in the destination field dest is a thirty-two bit register, the high order two bits will be lost. If the register specified in the source field src is a thirty-two bit register and the register specified in the destination field dest is a thirty-four bit register, then the high order two bits will both be set to a logical low voltage level.  If both the register specified in the source field src and the register specified in the destination field dest are thirty-four bit registers, then the MULT operation is performed on only the low order thirty-two bits.<br>
When a BRANCH operation is performed, the isochronous data pipe 20 branches to the control store address contained in the low order byte of the source field src.  The source field src can specify a register or an immediate value.<br>
When a BRANCH ON ZERO operation is performed, the isochronous data pipe 20 branches to the control store address contained in the low order byte of the source field src if the result of the last arithmetic or move control store instruction was equal to zero. The source field src can specify a register or an immediate value.<br>
When a BRANCH ON NOT ZERO operation is performed, the isochronous data pipe 20 branches to the control store address contained in the low order byte of the source field src if the result of the last arithmetic or move control store instruction was not equal to zero. The source field can specify a register or an immediate value.<br><br>
When a BSR operation is performed, the address of the next control store instruction is pushed onto the stack and the isochronous data pipe 20 branches to the control store address contained in the low order byte of the source field src. The source field src can specify a register or an immediate value.<br>
When a BSR ON ZERO operation is performed, if the result of the last arithmetic or move control store instruction was equal to zero, the address of the next control store instruction is pushed onto the stack and the isochronous data pipe 20 branches to the control store address contained in the low order byte of the source field src.  The source field src can specify a register or an immediate value.<br>
When a BSR ON NOT ZERO operation is performed, if the result of the last arithmetic or move control store instruction was not equal to zero, the address of the next control store instruction is pushed onto the stack and the isochronous data pipe 20 branches to the control store address contained in the low order byte of the source field src.  The source field src can specify a register or an immediate value.<br>
When a RETURN operation is performed, the last control store address is popped off of the stack and the isochronous data pipe 20 branches to that address.<br>
The isochronous recording format defined in the Serial Bus Protocol defines a standard format for recording a stream of isochronous data as transmitted over the bus structure 58. The isochronous data pipe 20 of the present invention can be programmed to transform a received stream of isochronous data into the isochronous recording format, according to the Serial Bus Protocol.  Correspondingly, the isochronous data pipe can also be programmed to create a stream of isochronous data from a stream of data in the isochronous recording format. A stream of data in the isochronous recording format is illustrated in Figure 5.  It should be noted that the data stream illustrated in Figure 5 begins on an isochronous cycle boundary.<br>
In Figure 5, the data stream 94 includes data packets which are included for each isochronous cycle in both channels A and B.  An offset column 92 is included in Figure 5, to show the offset of the beginning of each horizontal row.  The header horizontal rows each include four bytes.  The data section will include as many bytes as necessary to transfer the<br><br>
data packet.  The header for each packet includes a seconds field, a cycle number field, and a cycle field.  Each subheader for each channel within each packet includes a data_length field, a tag field tg, a channel field, a data field and a synchronizing field sy.  The subheader is then followed by the data section within the packet.<br>
EXAMPLE: Converting Isochronous Data To The Isochronous Recording Format<br>
The control store program included in Table V below illustrates an example of how the isochronous data pipe 20 of the present invention can be programmed by an application to capture an isochronous stream of data consisting of channels 3 and 5, map channel 3 to channel 7 and channel 5 to channel 9 and then send the resulting stream of data to DMA channel 0 hi the isochronous recording format.<br>
TABLE V<br>
(Table Removed)<br>
EXAMPLE: Converting From Isochronous Recording Format<br>
The control store program included in Table VI below illustrates an example of how the isochronous data pipe 20 of the present invention can be programmed by an application to take a stream of data at DMA channel 3 which is in the isochronous recording format and create a stream of isochronous data for transmission over the bus structure 58. The source stream of data contains isochronous channels 7 and 9. This control store program maps channel 7 to channel 1 and channel 9 to channel 2. Note that the program illustrated in Table VI requires that the first quadlet of data presented at DMA channel is a cycle start quadlet.<br>
TABLE VI<br>
(Table Removed)<br>
Formats for carrying digital consumer audio and video data over an IEEE 1394 format bus via an isochronous channel contain absolute time stamps which are inserted by the sender and used at the receiver to recreate the timing information necessary to decode the stream of data.  Similarly, non-consumer audio and video storage devices, such as a hard disk drive, will also modify this embedded time stamp information such that when the data is played back at a later time, a consumer device receiving the data will function properly.<br>
The isochronous data pipe 20 is first initialized by an application before it can transfer isochronous data.  Once initialized, the application uses the control register to change the operational state of the isochronous data pipe 20. The current operational state is completely defined by the value in the current channel mask register and the information contained in the low order byte of the status register.<br>
In order to change the state of the isochronous data pipe 20, the application programs a new channel mask value into the pending channel mask register and a new operational state into the control register.  In the same register access to the control register, the application<br>
also sets the go bit and programs an event into the event field.  When the programmed event occurs, the isochronous data pipe 20 transfers the value in the pending channel mask register to the current channel mask register. The isochronous data pipe 20 also transfers the information in the low order byte of the control register into the low order byte of the status register.<br>
In order to stop the operation of the isochronous data pipe 20, the application programs a value of one into the pending channel mask register and a logical low voltage level into the transmit enable bit in the control register. As with any state change, the application also sets the go bit and programs an event into the event field of the control register.  When the event occurs the value in the current channel mask register becomes zero and the transmit enable bit in the status register is pulled to a logical low voltage level, thereby stopping the operation of the isochronous data pipe 20.  When the operation of the isochronous data pipe 20 is stopped, the active bit in the status register is also pulled to a logical low voltage level.<br>
In order to activate the isochronous data pipe 20, the application first loads a control store program and programs the proper control store offsets into the control store address register file.  The pending channel mask register is then programmed with a bit mask of the channels which the isochronous data pipe 20 is to receive. If the isochronous data pipe 20 is not receiving data, the value in the pending channel mask register is programmed to zero. The go bit in the control register is set to a logical high voltage level to indicate a state change.  The transmit enable bit in the control register is set to a logical high voltage level if the isochronous data pipe 20 is transmitting isochronous data.  The stop on error bit in the control register is set to a logical high voltage level if the isochronous data pipe 20 is to stop operation on any error.  If the isochronous data pipe 20 is transmitting isochronous data, the output enable bits in the control register which correspond to the DMA channels involved in transmitting isochronous data are set to a logical high voltage level.  The event field in the control register is programmed to an event on which the isochronous data pipe 20 is to change state.<br>
The asynchronous data pipe 26, as stated above, automatically generates transactions necessary to complete asynchronous data transfer operations for an application over the bus structure 58. In an alternate embodiment of the isochronous data pipe 20 of the present invention, the isochronous data pipe 20 can be programmed to transfer and receive both isochronous and asynchronous data.  Accordingly, in this embodiment, the asynchronous data pipe 26 and the corresponding FIFO 32 are not necessary. Furthermore, because the isochronous data pipe 20 is the only logical block within the link circuit, the multiplexer 40 and demultiplexer 42 are also not necessary.<br>
As described above, the isochronous data pipe 20 of the preferred embodiment is programmed to execute a control store program and perform a series of operations on a stream of isochronous data.  In this alternate embodiment, the isochronous data pipe 20 also can be programmed to send and receive asynchronous data.  In this embodiment, the isochronous data pipe 20 appears as a virtual asynchronous data pipe and is programmed to generate the transactions necessary to complete asynchronous data transfer operations, as well as generate the appropriate headers when sending data and strip headers from received data, as<br>
described in U.S. Patent Application Serial Number	, filed on the same date as the<br>
present application and entitled "Asynchronous Data Pipe For Automatically Managing Asynchronous Data Transfers Between An Application And A Bus Structure."<br>
In this alternate embodiment, the isochronous data pipe 20 will send or receive both isochronous and asynchronous data.  The isochronous data pipe 20 is programmed by an application to execute an appropriate program for manipulating either an isochronous or asynchronous stream of data, as necessary.  When receiving or transmitting asynchronous data the isochronous data pipe 20 is programmed to automatically generate the read or write transactions necessary to complete the data transfer operation over the appropriate range of addresses.  The isochronous data pipe will appropriately automatically increment the value in the destination offset address field for each transaction according to the length of each data packet, unless an incrementing feature has been disabled, signalling that the transactions are to take place at a single address.<br>
The present invention has been described in terms of specific embodiments incorporating details to facilitate the understanding of the principles of construction and operation of the invention.  Such reference herein to specific embodiments and details thereof is not intended to limit the scope of the claims appended hereto. It will be apparent to those skilled in the art that modifications may be made in the embodiment chosen for illustration without departing from the spirit and scope of the invention.<br><br>
We Claim:<br>
1.       An apparatus for controlling bidirectional streams of data between an application (12, 14) and a bus structure (58) comprising:<br>
a.	a receiving circuit (44) for receiving a stream of data from a source<br>
selected from the application (12, 14) and the bus structure (58) and forming a<br>
received stream of data;<br>
b.	a control store memory (24) coupled to the receiving circuit (44)<br>
and to the application (12, 14), wherein the application (12, 14) stores a series<br>
of at least  one  operation  codes within  the  control  store  memory  (24)  for<br>
performing manipulations on  the received  stream of data required by the<br>
application; and<br>
c.	a converting circuit (20) coupled to the contol store memory (24)<br>
and to the receiving circuit for obtaining the series of operation codes and<br>
converting the  received  stream of data into  an  output stream of data by<br>
executing the series of operation codes.<br>
2.	The apparatus as claimed in claim 1, wherein the apparatus provides the<br>
output stream of data to the bus structure (58) if the received stream of data is<br>
received from the application (12, 14), and the apparatus provides the output<br>
stream of data to the application if the received stream of data is received from<br>
the bus structure (58).<br>
3.	The apparatus as claimed in claim 2, wherein the received stream of data<br>
is an isochronous stream of data.<br>
4.	The apparatus as claimed in claim 3, wherein the series of operation<br>
codes are stored at a memory address within the control store memory (24)<br>
corresponding to a channel number on which the received stream of data is<br>
transmitted.<br><br>
5.	The apparatus  as claimed  in  claim 4,  wherein the  receiving circuit<br>
determines if the received stream of data is an isochronous stream of data or<br>
an asynchronous stream of data.<br>
6.	The apparatus as claimed in claim 5, wherein the bus structure (58) is<br>
configured for coupling to a physical bus interface for placing data on the bus<br>
structure (58) and obtaining data from the bus structure (58).<br>
7.	The apparatus as claimed in claim 6, wherein an asynchronous data pipe<br>
(26) automatically controls asynchronous data transfer operations to and from<br>
the application (12, 14) over the bus structure (58) including:<br>
a.	an asynchronous receiving circuit configured for coupling to the<br>
application (12, 14) for receiving instructions regarding an asynchronous data<br>
transfer operation; and<br>
b.	a  controller  coupled  to  the  asynchronous  receiving  circuit for<br>
automatically generating transactions necessary to complete the asynchronous<br>
data transfer operation between the application (12, 14) and a node coupled to<br>
the bus structure (58).<br>
8.	The apparatus as claimed in claim 7, wherein the multiplexing circuit<br>
(40)   is   coupled   to   an   isochronous   data   processing   apparatus   (20),   the<br>
asynchronous   data   pipe   (26)   and   the   physical   bus   interface   (56)   for<br>
transmitting data packets from the isochronous data processing apparatus (20)<br>
and the asynchronous data pipe (26) to the bus structure (58).<br>
9.	The apparatus as claimed in claim 8, wherein a demultiplexing circuit<br>
(42)   is   coupled   to   the   isochronous   data  processing  apparatus   (20),   the<br>
asynchronous data pipe (26) and the physical bus interface (56) for routing<br>
data packets obtained from the bus structure (58) to an appropriate one of the<br>
isochronous data processing apparatus (20) and the asynchronous data pipe<br>
(26).<br><br>
10.	The apparatus as claimed in claim 9, wherein the isochronous data<br>
processing apparatus (20) executes series of operation codes regarding both<br>
isochronous and asynchronous received streams of data.<br>
11.	The apparatus as claimed in claim 5 and 10, wherein the control store<br>
memory   stores   the   series   of   operation   codes   at   a   memory   address<br>
corresponding to a channel number on which the received stream of data is<br>
transmitted if the received stream of data is an isochronous stream of data and<br>
at a memory address corresponding to asynchronous data if the received<br>
stream of data is an asynchronous stream of data.<br>
12.	The apparatus as claimed in claim   6, wherein the bus structure (58) is<br>
an IEEE 1394 standard bus structure.<br>
13.	An apparatus for controlling bidirectional streams of data substantially<br>
as herein described with reference to and as illustrated in the accompanying<br>
drawings.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">408-del-1997-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">408-del-1997-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">408-del-1997-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LWNvcnJlc3BvbmRlbmNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">408-del-1997-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">408-del-1997-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">408-del-1997-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LWZvcm0tMTMucGRm" target="_blank" style="word-wrap:break-word;">408-del-1997-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LWZvcm0tMTkucGRm" target="_blank" style="word-wrap:break-word;">408-del-1997-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">408-del-1997-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">408-del-1997-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LWZvcm0tNC5wZGY=" target="_blank" style="word-wrap:break-word;">408-del-1997-form-4.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LWZvcm0tNi5wZGY=" target="_blank" style="word-wrap:break-word;">408-del-1997-form-6.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LWdwYS5wZGY=" target="_blank" style="word-wrap:break-word;">408-del-1997-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LXBldGl0aW9uLTEzNy5wZGY=" target="_blank" style="word-wrap:break-word;">408-del-1997-petition-137.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDA4LWRlbC0xOTk3LXBldGl0aW9uLTEzOC5wZGY=" target="_blank" style="word-wrap:break-word;">408-del-1997-petition-138.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="216124-optical-recording-medium-method-for-recording-reproducing-the-optical-recording-medium-and-apparatus-for-recording-reproducing-the-optical-recording-medium.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="216126-an-expandable-bifurcated-stent-and-method-for-production-thereof.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>216125</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>408/DEL/1997</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>12/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>21-Mar-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>10-Mar-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>20-Feb-1997</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SONY ELECTRONICS, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>1 SONY DRIVE, PARK RIDGE, NEW JERSEY 07656-8003, UNITED STATES OF AMERICA.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>SCOTT D. SMYERS</td>
											<td>16345 LOS GATOS BLVD., #6, LOS GATOS, CA 95032, U.S.A.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>BRUCE FAIRMAN</td>
											<td>275 MARTINEZ ROAD, WOODSIDE, CA 94062, USA</td>
										</tr>
										<tr>
											<td>3</td>
											<td>HISATO SHIMA</td>
											<td>5-9-12 KITASHINAGAWA, SHINAGAWA-KU, TOKYO 141, JAPAN</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 1/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>08/612,322</td>
									<td>1996-03-07</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/216125-an-apparatus-for-controlling-bidirectional-streams-of-data-between-an-application-and-a-bus-structure by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:18:26 GMT -->
</html>
