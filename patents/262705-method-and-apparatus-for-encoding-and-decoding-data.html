<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/262705-method-and-apparatus-for-encoding-and-decoding-data by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:50:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 262705:METHOD AND APPARATUS FOR ENCODING AND DECODING DATA</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD AND APPARATUS FOR ENCODING AND DECODING DATA</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method and apparatus for turbo coding and decoding is provided herein. During operation, a concatenated transport block (CTB) of length X is received and a forward error correction (FEC) block size KI is determined from a group of available non-contiguous FEC block sizes between Kmin and Kmax , and wherein Kmin &lt;=KI&lt; Kmax and wherein KI is additionally based on X. The concatenated transport block of length X is segmented into C segments each of size substantially equal KI. An FEC codeword for each of the C segments is determined using FEC block size KI; and the C FEC codewords are transmitted over the channel.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>METHOD AND APPARATUS FOR ENCODING AND DECODING DATA<br>
Field of the Invention<br>
The present invention relates generally to encoding and decoding data and in<br>
particular, to a method and apparatus for turbo coding and decoding data.<br>
Background of the Invention<br>
Digital data transmissions over wired and wireless links sometimes may be<br>
corrupted, for instance, by noise in the link or channel, by interference from other<br>
transmissions, or by other environmental factors. To combat the errors introduced by<br>
the channel, many communication systems employ error-correction techniques to aid<br>
in communication.<br>
One technique utilized for error correction is turbo coding of an information<br>
block to be transmitted. Utilizing such a technique, an encoder within the transmitter<br>
of a communication system will encode an input block u of length K bits into a<br>
codeword block x of N bits. The codeword block x is then transmitted over the<br>
channel, possibly after further processing such as channel interleaving as defined in<br>
the IEEE 802.16e specifications. At the receiver, the turbo decoder takes the received<br>
signal vector y of length N as input, and generates an estimate ŭ of vector u.<br>
Typically the turbo encoder is composed of two constituent convolutional<br>
encoders. The first constituent encoder takes the input block u as input in its original<br>
order, and the second constituent encoder takes the input block u in its interleaved<br>
order after passing u through a turbo interleaver π. The turbo encoder output x is<br>
composed of the systematic bits (equal to the input block u), the parity bits from the<br>
first constituent encoder, and the parity bits from the second constituent encoder.<br>
Correspondingly the turbo decoder within the receiver of the communication<br>
system is composed of two constituent convolutional decoders, one for each<br>
constituent code. The constituent decoders are separated by the interleaver Π and the<br>
corresponding deinterleaver π-1. Messages in the format of log-likelihood ratios<br>
(LLRs) arc passed between the constituent decoders iteratively. The decision u is<br>
made after several iterations.<br>
The turbo interleaver n is the key component in the turbo code design. It is<br>
responsible for scrambling the input block u in a pseudo-random fashion, thus<br><br>
providing the codewords x with good weight distribution, hence good error-correcting<br>
capabilities, in addition to decoding performance, the turbo interleaver π has<br>
significant impact on the implementation of the turbo decoder within the receiver.<br>
Usually, turbo codes performance improves with increasing interleaver length.<br>
However, there is a diminishing return in increasing the interleaver size. In practice,<br>
the maximum Forward Error Correction (FEC) block size (i.e., interleaver size) of a<br>
turbo code is limited to a certain value due to complexity and delay reasons. Hence, if<br>
the size of the input block (concatenated transport block or CTB) is larger than the<br>
maximum FEC block size supported by the turbo code, the CTB is segmented (e.g.,<br>
using code block segmentation rule) into several small segments, each of which is<br>
processed separately by the turbo encoder at the transmitter and correspondingly by<br>
the turbo decoder at the receiver.<br>
In some systems, the turbo code may be designed to support only a small<br>
number of FEC block sizes for various reasons (e.g., high speed decoding, reduced<br>
storage, etc). Therefore, a need exists for a method and apparatus for turbo coding and<br>
decoding that appropriately matches the CTB to available FEC block sizes.<br>
Brief Description of the Drawings<br>
FIG. 1 is a block diagram of a transmitter.<br>
FIG. 2 is a block diagram of a receiver.<br>
FIG. 3 is a block diagram of the turbo encoder of FIG. 1.<br>
FIG. 4 is a block diagram of transport block former on the transmitter side.<br>
FTG. 5 is a block diagram of a transport block assembler on the receiver side.<br>
FIG. 6 is a flow chart showing operation of the transmitter of FIG. 1.<br>
FIG. 7 is a flow chart showing operation of the receiver of FIG. 2.<br>
Detailed Description of the Drawings<br>
In order to address the above-mentioned need, a method and apparatus for<br>
turbo coding and decoding is provided herein. During operation, a concatenated<br>
transport block (CTB) of length X is received and a forward error correction (FEC)<br>
block size KI is determined from a group of available non-contiguous FEC block sizes<br>
between Kmin and Kmax, and wherein Kmin 
based on X. The concatenated transport block of length X is segmented into C<br><br>
segments each of size substantially equal to KI. An FEC codeword for each of the C<br>
segments is determined using FEC block size KI and the C FEC codewords are<br>
transmitted over the channel.<br>
In an alternate embodiment, a concatenated transport block (CTB) of length X<br>
is received and two FEC block sizes KI-1 and KI are determined from a group of non-<br>
contiguous FEC block sizes, wherein the available non-contiguous FEC block sizes<br>
are between Kmin and Kmax, and wherein Kmin 
wherein K1-1 and KI are additionally based on X. The concatenated transport block of<br>
length X is segmented into C segments each of size substantially equal to <br>
An FEC codeword for each of the C segments is determined using FEC block sizes AT/<br>
or and the C FFC codewords are transmitted over the channel.<br>
The benefit of the above methods is that they reduce the padding of filler bits<br>
required to encode the CTB, while using the fewest number of segments allowed by<br>
the available non-contiguous FEC block sizes. In particular, the second method uses<br>
two different (but adjacent) FEC block sizes to minimize the number of filler bits<br>
while using the fewest number of segments as allowed by the available non-<br>
contiguous FEC block sizes. Moreover, the FEC block sizes for the segment sizes and<br>
the number of segments for the two embodiments may be determined using simple<br>
logic circuitry.<br>
Prior to describing encoding and decoding data, the following definitions are<br>
provided to set the necessary background:<br>
■	For ease of notation, a concatenated transport block refers to the result of<br>
concatenating one or more transport blocks, after adding overhead such as<br>
CRC bits to each transport block.<br>
■	X denotes the concatenated transport block size (e.g., length of the<br>
concatenated transport block in bits).<br>
■	Y denotes the total number of filler bits added to a concatenated transport<br>
block.<br>
■	C denotes the number of segments a concatenated transport block gets<br>
segmented into.<br>
■	CBSSt denotes the size of the ith segment of a concatenated transport block (i =<br>
1,.... C), where C is the segment size. CBSS stands for code block segment<br>
size.<br>
■  denote FEC block sizes (e.g., sizes for which turbo code internal<br>
interleaver arc defined) that may be used to FEC encode the segments of a<br>
concatenated transport block.<br><br>
■  denotes a set of available non-contiguous FEC block sizes (sizes for<br>
which a turbo code internal interleaver is defined).<br>
■  denotes the number of filler bits added to a segment.<br>
■	R denotes the mother code rate of the turbo coder (e.g., R = 1/3 for the 3GPP<br>
Turbo Code).<br>
■	R-1 is the inverse of mother code rate of turbo coder (e.g., R-1 = 3 for the 3GPP<br>
Turbo Code).<br>
■	Ntb is the number of tail bits in the FEC codeword at the output of FEC<br>
encoder. In particular,<br>
o Ntb = 12 for 3GPP turbo code with tail bits.<br>
o Ntb, = 0 for a 3GPP turbo code with tail-biting.<br>
■	π denotes the turbo code internal interleaver.<br>
■	The flooring operation |_x_| denotes the largest integer smaller than or equal to x<br>
and the ceiling operation |x| denotes the smallest integer larger than or equal<br>
to x.<br>
Turning now to the drawings, wherein like numerals designate like<br>
components, FIG. 1 is a block diagram of transmitter 100. As shown, transmitter 100<br>
comprises code block segmentation circuitry 102, filler circuitry 103, turbo encoder<br>
104, filler discard circuitry 105, transmitter 108, logic circuitry 106, and table/storage<br>
107. Transmitter 100 additionally comprises of receiving circuitry (not shown in FIG.<br>
1) that receives a concatenated transport block of length X. Logic circuitry 106<br>
determines an available FEC block size K1 from a group of non-contiguous FEC block<br>
sizes 107, wherein the available non-contiguous FEC block sizes are between Kmin and<br>
Kmax, and wherein . and wherein K1 is additionally based on X. Code<br>
block segmentation circuitry 102 segments the concatenated transport block of length<br>
X into C segments of sizes substantially equal to K1, and encoding circuitry 104<br>
determines an FEC codeword for each of the C segments using FEC block size AT/.<br>
Finally transmission circuitry 108 transmits the C FEC codewords over a channel.<br>
In another embodiment, the transmitter 100 comprises receiving circuitry (not<br>
shown in the FIG. 1) that receives a concatenated transport block of length X, logic<br>
circuitry 106 that determines two available FEC block sizes K1-1 and K1 from a group<br>
of non-contiguous FEC block sizes 107, wherein the available non-contiguous FEC<br>
block sizes are between , and wherein <br>
  and wherein and are additionally based on X. Transmitter 100 comprises<br>
code block segmentation circuitry 102 that segments the concatenated transport block<br>
of length X into C segments of sizes substantially equal to  and encoding<br><br>
circuitry 104 that determines an FEC codeword for each of the C segments using FEC<br>
block size K1 or K1-1 Finally transmission circuitry 108 is provided that transmits the<br>
C FEC codewords over a channel.<br>
Encoding circuitry 104 is preceded by filler circuitry 103 that inserts filler bits<br>
into the segments to form an FEC input block. FEC encoder 104 encodes the FEC<br>
input block, and filler discard circuitry 105 discards bits related to the filler bits.<br>
During operation of transmitter 100, data in the form of a concatenated<br>
transport block is received by circuitry 102. Circuitry 102 prepares the concatenated<br>
transport block before Forward Error Correction (FEC) encoding.<br>
In general, the range of the CTB sizes (i.e., X) may be different from the range<br>
of the FEC block sizes supported by the underlying FEC scheme in the physical layer<br>
for a communication system. Therefore, it is necessary to define a rule that divides a<br>
CTB into segments that can be efficiently handled by the FEC. In particular, CTB<br>
sizes (i.e., X) are often much larger than the maximum FEC block size that FEC<br>
encoder 104 can handle. Therefore, the CTB needs to be segmented by circuitry 102<br>
into a number of smaller-sized segments and each segment needs to be encoded by<br>
FEC encoder 104 into a separate FEC codeword.<br>
Circuitry 102 uses a code block segmentation rule that is designed to achieve<br>
good performance (i.e., the aggregate performance of the segments for a given CTB)<br>
with the underlying FEC. It involves the following aspects for any given CTB size:<br>
■	Choosing the number of segments C;<br>
■	Choosing the sizes of each segment;<br>
■	Inserting the filler bits before FEC encoding and the removing of filler bits<br>
after FEC encoding, if the segment size cannot be handled directly by the<br>
FEC.<br>
The proposed segmentation rules arc particularly useful for Evolved-UMTS<br>
Terrestrial Radio Access (EUTRA) system where a turbo coder may be defined for<br>
only a limited set of FEC block sizes (interleaver sizes). Unlike the Release 6 3GPP<br>
Turbo coder that defines 5075 interleavers of contiguous sizes, one for each<br>
interleaver size K1 between 40 bits and 5114 bits, an EUTRA turbo coder may define<br>
a limited number of FEC block sizes K.table (e.g., 40-50 interleavers with non-<br>
contiguous sizes ranging from 128 bits to 6144 bits) to cover a large number of<br>
segment sizes (e.g., 6144-128+1 = 6017 sizes). When the segment size is equal to an<br>
available FEC block size, then the segment can be taken as an FEC input block<br>
directly (thus no need of filler bit insertion). However, when the segment size is not<br>
equal to any available FEC block sizes, filler bit padding may be applied, and the next<br><br>
larger available FEC block size (i.e., interleaver size) chosen from Ktable 107 may be<br>
used.<br>
Number of segments :<br>
The segmentation rules take the following properties of turbo coding into<br>
account.<br>
(a)	Turbo code performance improves as the FEC block size increases.<br>
(b)	Turbo code performance improvement via increasing FEC block sizes has<br>
diminishing returns beyond a few thousand bits.<br>
(c)	A CTB is received correctly only if all the segments arc received correctly.<br>
Properties' (a) and (c) indicate that the overall performance is likely to be<br>
dominated by the segment having the worst performance. Thus, it is preferable to<br>
have segments that arc approximately of equal sizes so that they are FEC encoded<br>
with approximately equal FEC block sizes (and hence accorded approximately equal<br>
error protection from FEC perspective).<br>
Property (b) suggests that it is not necessary to include interleavers for very<br>
large sizes in the table (Ktable). However, the FEC block sizes defined in Ktable may<br>
depend on other factors. For example, i) for reduced storage/complexity, a small<br>
number of interleavers in Ktable may be desirable, and ii) the maximum interleaver size<br>
defined in Ktable may be chosen to limit the number of segments per CTB, thus<br>
limiting the segmentation penalty of a CTB. The segmentation penalty is the<br>
performance loss due to dividing a CTB into several segments instead of encoding the<br>
entire CTB into one FEC codeword.<br>
Property (c) suggests that the minimum number of segments should be used to<br>
reduce segmentation penalty.<br>
Considering all the above, the number of segments is where<br>
Kmax is the maximum FEC block size defined in Ktable. Assuming that CBSSi denote<br>
the segment size of the th segment (z = 1,...Q of the concatenated transport block, the<br>
sum of all segments is equal to the concatenated transport block size X, i.e., the<br>
segment sizes are constrained by the following equation.<br><br>
The next section describes the determination of the FEC block size used for<br>
FEC encoding, one for each of the C segment size.<br><br>
FEC block size determination<br>
Given that a CTB of length X is the input to the code block segmentation<br>
function, the rule for determining the FEC block size (interleaver size) for turbo coder<br>
as described in Release 6 of the 3GPP standard is as follows<br><br>
where K max=5114 is the maximum interleaver size for Rel 6 Turbo code, C is the<br>
number of segments (or code blocks), KI is the interleaver size, and Y is the total<br>
number of filler bits inserted for the CTB of size X when C FEC input blocks of size<br>
KI is used. In essence, a CTB of size X is segmented into C segments of<br>
approximately equal size, and each segment is encoded using a turbo code with a KI-<br>
bit interleaver. IT Y&gt; 0, Y known bits are padded to the beginning of the first segment<br>
before encoding. Since the FEC block sizes (i.e., interleavers) are defined for all sizes<br>
between Kmin = 40 and Kmax = 5114 in Release 6 3GPP turbo code, the number of<br>
filler bits is bounded by C, the number of segments used for code block segmentation.<br>
However, in other systems such as the one being considered for EUTRA, the<br>
FEC block sizes (interleaver sizes) may be defined only for non-contiguous sizes (a<br>
coarser set of interleaver sizes) Ktable. In such cases, segment sizes that are not equal<br>
to any available FEC block sizes (i.e., not defined in Ktable) need to be handled using<br>
filler bits before FEC encoding (and puncturing after encoding to arrive at a desired<br>
code rate).<br>
Assuming that a turbo coder supports only a limited number of FEC block<br>
sizes distributed between K,„i„ and Kmax, both inclusive, two simple methods of code<br>
block segmentation of a concatenated transport block of length X using Ktable are<br>
described next. These methods use as few segments as possible while they also reduce<br>
the number of filler bits that are required for encoding,<br>
Allow one FEC block size only<br>
One method is to modify (1) and let all segments be encoded with a single<br>
interleaver size KI, where<br><br><br><br>
as follows (for easy understanding, all involved computations are repeated below). In<br>
this case, logic circuitry 106 performs the following operations to find the number of<br>
segments,<br><br>
and C1-1 and CI are the number of segments that arc encoded using FEC block sizes KI.<br>
i and KI, respectively, where KI is the smallest size from available FEC block sizes<br>
that is greater than or equal to |X/C|, and D1 denotes the difference between the<br>
adjacent interleaver sizes KI-1 and KI.<br>
Note that in (4) Y does not indicate the number of filler bits required if<br>
allowing two adjacent sizes; but indicates the number of filler bits required had only<br>
one size of KI is used for all C segments.<br>
Thus, the code block segmentation forms C segments, of which CI-I segments<br>
arc FEC-encoded with a FEC block size KI-I. Note that when Y
and this method degenerates to using one FEC block size of KI.(i.e., KI-I size is<br>
allowed but not actually used.) On the other hand, when Y&gt;= DI, this method requires<br>
fewer filler bits than padding all C segments to the larger FEC block size KI. This<br>
method is optimal in that the number of filler bits Y" added per CTB is guaranteed to<br>
be least while using the fewest segments as possible. Y" is determined as follows<br><br>
It can be proven that Y" is bounded by DI, regardless of C,<br><br>
[n this case, the segment sizes obtained after code block segmentation have the<br>
following constraints, assuming (without loss of generality that the first C1 segments<br>
are encoded with KI and rest with KI-).<br><br><br>
Returning to FIG. 1, as discussed above, a proper FEC block size needs to be<br>
chosen from table 107 of non-contiguous FEC block sizes. Logic circuitry 106<br>
performs the task of choosing the appropriate FEC block size/sizes as discussed<br>
above. An example of table 107 is given in Table 1. For example, in first case, logic<br>
circuitry 106 chooses FEC block size from the available non-contiguous FEC block<br>
sizes between  and wherein and wherein KI is<br>
additionally based on X. Particularly, if a single FEC block size KI is to be used, logic<br>
circuitry 106 chooses the smallest K, (from Ktable) that is not smaller than , i.e.,<br>
  , where and  If, however, two FEC block sizes<br>
are to be used, and are determined with equation (4) giving the number of<br>
segments that are encoded using FEC block sizes <br><br>
The underlying FEC coder 104 supports only a limited set of FEC block sizes<br>
(or input sizes). Without loss of generality, it is assumed that FEC coder 104 is a turbo<br>
coder, and the set of FEC block sizes supported by the turbo coder is the set of<br>
interleaver sizes for which the turbo code internal interleaver is defined. However,<br>
one of ordinary skill in the art will recognize that other FEC schemes may be used in<br>
104, including low-density parity check (LDPC) codes, convolutional codes, block<br>
turbo codes, Reed-Solomon codes, etc.<br>
Once the number of segments C and the FEC block size for each segment is<br>
determined, this information is passed to code block segmentation circuitry 102 where<br>
the CTB (X bits) is segmented into C segments which are encoded with FEC block<br>
size K[, if only one FEC block size is allowed. Alternatively, if two adjacent FEC<br>
block sizes are allowed, the code block segmentation circuitry 102 may output O<br><br>
segments which arc to be encoded with FEC block sizesegments which<br>
arc to be encoded FEC block size  <br>
Filler Bit Insertion<br>
The number of filler bits (padded for each segment) may be determined based<br>
on the segment size and the FEC block size being used for FEC encoding of the<br>
segment. There are at least two ways to distribute the overall filler bits into the C<br>
segments.<br>
•	Concentrated-filler. Put the filler bits into as few segments as possible<br>
without making the segment sizes too small. In one example, all filler bits may appear<br>
in the beginning of the first segment. The advantage is that only one segment<br>
(containing all the filler bits) needs to be handled separately. Moreover, the filler bits<br>
can be padded to the segment that is encoded with the larger FEC block size KI rather<br>
than smaller FEC block size when two FEC block sizes are used for a CTB. This<br>
method is particularly attractive when allowing two adjacent FEC block sizes for<br>
encoding.<br>
•	Disrributcd-filler. Distribute the filler bits evenly (as much as possible)<br>
into a plural of segments. The filler bits can be distributed to as many as all C<br>
segments.<br>
For efficient implementation of the transmitter and the receiver, concentrated-<br>
filler is preferred. A preferred embodiment is to append Y" (if allowing two adjacent<br>
FEC block sizes; Y if allowing one FEC block size only) consecutive filler bits to the<br>
front of the one of the segments (e.g., the first or the last) using FEC block size KI<br>
before sending it to the encoder. In terms of performance, it is equivalent to<br>
appending the Y" consecutive filler bits to the end of a segment having FEC block size<br>
KI.<br>
Returning to FIG. 1, for each segment (produced by circuitry 102), an FEC<br>
codeword is determined using the steps of inserting filler bits into the segment to form<br>
an FEC input block; FEC encoding the FEC input block; and discarding bits related to<br>
the filler bits.<br>
Each segment produced by circuitry 102 is passed to filler circuitry 103 where<br>
filler bit insertion takes place. If no filler bits are required, then filler circuitry is<br>
transparent, i.e., no filler bits are added (Kfilter=0). The segments (along with filler<br>
bits) are then passed to turbo encoder 104 where turbo encoding of the C segments<br>
leads to C FEC codewords. The filler bits are then discarded by circuitry 105 and the<br><br>
resulting C codewords are appropriately transmitted by transmission circuitry 108. If<br>
no filler bits are added by circuitry 103, then filler discard circuitry 105 is transparent,<br>
i.e., no filler bits are removed Note that it is possible that circuitry 105 may<br>
not discard any bits corresponding to the filler bits.<br>
FIG. 2 is a block diagram of a receiver. During operation the received signal<br>
vector goes through the code block de-segmentation circuitry 202 which organizes<br>
portions of received signal vector according to the segment they are associated with.<br>
The segment size, number of segments, FEC block size used to turbo-decode each<br>
segment, number of filler bits may be determined using logic circuitry 213 and<br>
available FEC block size table 215 in a fashion similar to that at the encoder. The<br>
filler handling circuitry 204 uses the knowledge of the location of filler bits to benefit<br>
turbo decoder 206, for e.g., by setting the LLRs corresponding to filler bits to a high<br>
magnitude. After turbo decoding, circuitry 208 discards the filler bits to obtain<br>
estimate of a segment. The code block assembler 211 assembles the estimated<br>
transport by suitably collecting and arranging the estimates of the segments obtained<br>
from circuitry 208.<br>
Removal of parity bits of constituent coder<br>
This section provides a specific way of determining the FEC codeword. The<br>
method takes advantage of the knowledge of filler bits insertion at the transmitter is<br>
described. In particular, the method determines which bits (both systematic and parity<br>
bits) can be discarded from the turbo encoder output with no or negligible significant<br>
performance degradation. In general, the filler bits arc known, and hence the<br>
systematic bits of these bits (equal to the known bits) can be discarded prior to<br>
transmission. However, it is not clear if any parity bits can be discarded.<br>
FIG. 3 is a block diagram of turbo encoder 104 of FIG. 1. During operation,<br>
input block of length KI bits enters both interleaver 301 and constituent encoder 302.<br>
Interleaver 301 interleaves the input block and passes the input block in interleaved<br>
order to constituent encoder 303. Constituent encoder 303 then encodes the<br>
interleaved input block. In a similar manner, constituent encoder 302 encodes the<br>
original input block. The codeword block x is composed of systematic block (equal to<br>
the FEC input block), output of constituent encoder 302, and output of constituent<br>
encoder 303. The codeword block x is then sent to circuitry 105.<br>
In a conventional turbo encoder such as e.g., tailed turbo codes, the initial state<br>
of the constituent encoders (shift register contents) is assumed to be all-zero. In such<br>
case, when filler bits (usually 0's) are inserted at the beginning of the turbo code<br><br>
input block, the systematic bits and the parity bits of the constituent encoder 302<br>
corresponding to the Kfiller bit positions are all zeros. Therefore, these bits may be<br>
discarded at the transmitter and the receiver can utilize this knowledge while<br>
performing turbo decoding. However, in the constituent encoder 303, the Kfiller bits are<br>
scrambled due to the turbo code interleaver and hence the parity bits of constituent<br>
encoder 303 corresponding to the filler bits are not known and thus cannot be<br>
discarded simply.<br>
When the turbo coder has tail-biting constituent encoders, the initial state of<br>
the constituent encoders may not be always zero. For tail-biting codes, the initial state<br>
and the final state for a constituent encoder are equal and they depend on the input<br>
block. Therefore, when Kfiller consecutive filler bits (i.e., zeros) arc inserted at the<br>
beginning of the turbo code input block, the parity bits of constituent encoder 302<br>
corresponding to the Kfiller bit positions are not always zeros. However, it can be<br>
proven that most of these Kfiller parity bits of the constituent encoder 302 carry no<br>
information.<br>
In general, groups of consecutive filler bits are inserted into a segment to form<br>
an FEC input block wherein the group length is a multiple of 2m-l (=7 for the<br>
constituent convolutional codes within the 3GPP turbo coder). Then, the FEC input<br>
block is FEC encoded and parity bits related to the filler bits are discarded. The FEC<br>
encoder can be a tail-biting convolutional code used alone, or a tail-biting<br>
convolutional code used as a constituent code of a turbo coder.<br>
In particular, when used for turbo codes with tail-biting constituent codes,<br>
groups of systematic bits corresponding to the filler bits may be discarded; and the<br>
parity bits corresponding to the groups of filler bits at the output of a constituent<br>
encoder may be discarded, wherein the constituent encoder takes the FEC input block<br>
without interleaving for tail-biting turbo coders. This can be shown as follows.<br>
Let the state of the shift register of constituent encoder 302 at step i be S(i), let<br>
m be the number of elements in the shift register, and let g be any integer greater than<br>
0. When (2m-l)xg zeros are input to the constituent encoder from step i+1 to step<br>
i+(2m-l)xg, the following is a property of recursive convolutional encoder (such as<br>
the one used in Rel. 6 3GPP turbo code),<br><br>
Note that S(i) may not be a constant. In addition, the states S(J) in between may not be<br>
a constant or equal to state <br>
Therefore, the state of the constituent encoder remains unchanged between<br>
step Therefore, the transmitter can take advantage of (7) by<br>
discarding the constituent encoder output during those steps, as these filler bits do not<br><br>
change the shift register state and thus providing no information for the decoder. The<br>
decoder within the receiver can also take advantage of (7) similarly based on the<br>
knowledge of filler bit positions and values. Next, the above method is described with<br>
an example where Kfiller filler bits (zeros) are inserted in consecutive positions in the<br>
input of a tail-biting turbo code.<br>
Since Kfiller consecutive filler bits (zeros) are inserted in the turbo code input<br>
block,  and therefore  parity bits of constituent<br>
encoder 302 may be discarded, where p is the number parity bits at the output of the<br>
constituent encoder 302 that are generated for each bit in the FEC input block.<br>
Therefore, only the parity bits corresponding to the groups of filler bits at the output<br>
of constituent encoder 302 are discarded, wherein constituent encoder 302 takes the<br>
FEC input block without interleaving for tail-biting turbo coders.<br>
For a tail-biting 3GPP turbo coder, p=\ in constituent encoder 1, m=3. Thus<br>
 parity bits can be discarded from constituent encoder 302 for Kfiller<br>
consecutive filler bits. Since m=3, at most only 6 parity bits corresponding to the Kfiller<br>
filler bits of constituent encoder 302 may need to be kept at the output of constituent<br>
encoder 302.<br>
In constituent encoder 303, the Kfiller filler bits may get dispersed due to the<br>
turbo code interleaver. Therefore, it may not be possible to discard the parity bits from<br>
the constituent encoder 303 without affecting performance.<br>
The following section describes some example scenarios in which the code<br>
block segmentation rule may be used, e.g., hybrid-Automatic Repeat reQuest<br>
(HARQ), Multiple Tnput Multi Output (MIMO), etc.<br>
Transport Block (TB) Former<br>
The code block segmentation rule described above is applied to a concatenated<br>
transport block (CTB) on a hybrid ARQ (HARQ) channel. Before code block<br>
segmentation, the information bits than needs to be sent to a single user from the base<br>
station within a transmission time interval (TTI) may need to be divided into at least<br>
one transport block, thus going through at least one HARQ channel. For example FIG.<br>
4 shows an example wherein the information bits are transmitted using two HARQ<br>
channels (corresponding to HARQ1, and HARQ2), and two transport blocks TBI and<br>
TB2. During operation, information bits of length A are received by TB formation<br>
circuitry 402 to be transmitted on one or more spatial streams. Circuitry 402<br>
designates X' bits as a transport block TBI, where processor 404<br>
attaches CRC bits to the X' bits to form the concatenated transport block of length X;<br><br>
the concatenated transport block of length X is mapped to a first HARQ channel. The<br>
concatenated transport block is sent to the code block segmentation circuitry 102.<br>
Circuitry 402 designates W'=A- A' bits from the information bits as a second<br>
transport block TB2; HARQ2 processor 406 attaches CRC bits to Y bits form a second<br>
concatenated transport block; the concatenated transport block is mapped to a second<br>
HARQ channel. The concatenated transport block is sent to the code block<br>
segmentation circuitry 102.<br>
Note that circuitry 404 and 406 may perform additional functions such as<br>
other functionalities related to HARQ, adding control information, etc.<br>
Though the concepts in FIG 4 arc illustrated using two HARQ channels, they<br>
can be easily extended to a plurality of HARQ channels. If more than one HARQ<br>
channel is supported to a user within a Transmission Time Interval (TTI), the code<br>
block segmentation rule may be applied to each TB.<br>
Multiple HARQ channels may occur due to having too many FEC codewords<br>
(or segments) per TIT per user, such as from large bandwidth (e.g., 20MHz), higher<br>
order modulation (e.g., 64QAM), multistream MIMO, etc. Multiple HARQ channels<br>
may also be used for TBs that have different QoS, such as VoIP and best-effort data.<br>
A MIMO codeword comprises the bits that are sent to a single user within a<br>
TTI on one MIMO stream. Thus a MIMO codeword may comprise one or more FEC<br>
codewords. Sometimes a MIMO codeword is used to refer to the bits on a MIMO<br>
stream.<br>
Rules may be defined for the creation of a TB. In one embodiment, a TB shall<br>
comprise no more than x (e.g., x=8) FEC codewords (value of x determined by the<br>
cNodeB scheduler in EUTRA). In another embodiment, if more than x FEC<br>
codewords are needed for a TB, then two TBs are created as follows. The packet is<br>
divided approximately evenly between two TBs, each TB having nearly the same<br>
number of FEC codewords of approximately the same size. In yet another<br>
embodiment, for FEC codewords that are to be sent to two MIMO streams, each<br>
belongs to a separate TB. In yet another embodiment, for FEC codewords that are to<br>
be sent to three MIMO streams while using 2 simultaneous HARQ channels, the first<br>
(on average, best quality stream) belongs to one TB and the second and third stream<br>
belong to a second TB. In yet another embodiment, four MIMO codewords to be sent<br>
using two HARQ channels, several combinations are possible. For example, (a)<br>
TB1=1,2 TB2=3,4 (b) TB1=1,3 TB2=2,4 (c) TB1=1,2 TB2=2,3 (d) TB1=1,<br>
TB2=2,3,4. Here TBi refers to TB of i-th HARQ channel; numbers 1 through 4<br>
indicates the MIMO codeword (or stream) number.<br><br>
FIG. 5 is a block diagram of receiver processing when information bits arc<br>
received over at least one HARQ channel. The received bits from the code block<br>
assembler 211 are input to the appropriate channel processors 504 and 506. The<br>
output of the channel processors are the estimated transports blocks TBI and TB2<br>
which are input to the TB assembler circuitry 502 which combines the TBs and<br>
outputs estimated information bits.<br>
FIG. 6 is a flow chart showing operation of the transmitter of FIG. 1. The logic<br>
flow begins at step 601 where segmentation circuitry receives a concatenated<br>
transport block of length X. At step 603 logic circuitry accesses table 107 and chooses<br>
an appropriate FEC block size. As discussed above, in a first embodiment of the<br>
present invention the FEC block size KI is determined from a group of non-contiguous<br>
FEC block sizes located in table 107, where the available non-contiguous FEC block<br>
sizes in table 107 are between Kmin and Kmax, and wherein Kmin 
discussed above, KI is based on X. X is determined by logic circuitry 106 from the<br>
concatenated transport block. Once X is determined,	and<br>
C = |X/Kmax| are determined. In a second embodiment of the present invention FEC<br>
block sizes KI and KI-I are determined, where KI=|X/C|+δ<br>
Continuing, at step 605 the number of segments C and the FEC lock sizes are<br>
passed to segmentation circuitry 102 and at step 607 segmentation circuitry segments<br>
the concatenated transport block of length X into C segments of size substantially<br>
equal to KI (or alternatively KI and KI-I. Filler bits are added (if necessary) at step 609<br>
via circuitry 103 and at step 611 each of the C segments are encoded (i.e., an FEC<br>
codeword is determined for each of the C segments). Finally, at step 613 the FEC<br>
codewords are transmitted via transmission circuitry 108.<br>
As discussed above, the step of determining an FEC codeword comprises the<br>
steps of inserting filler bits into the segment to form an FEC input block, FEC<br>
encoding the FEC input block, and discarding bits related to the filler bits. This step<br>
may entail inserting groups of consecutive filler bits into a segment to form an FEC<br>
input block where the group length is a multiple of 7, FEC encoding the FEC input<br>
block, and discarding bits related to the filler bits. Discarding filler bits comprises the<br>
steps of discarding groups of systematic bits corresponding to the filler bits and<br>
discarding the parity bits corresponding to the groups of filler bits at the output of<br>
constituent encoder 1, where constituent encoder takes the FEC input block without<br>
interleaving for tail-biting turbo coders.<br>
FIG. 7 is a flow chart showing operation of the receiver of FIG. 2. The logic<br>
flow begins at step 701 where the segment size, number of segments, FEC block size<br>
used to turbo-decode each segment, and the number of filler bits are determined using<br><br>
logic circuitry 213 and table 215. As discussed above, in a first embodiment of the<br>
present invention the FEC block size KI is determined from a group of non-contiguous<br>
FEC block sizes located in table 215, where the available non-contiguous FEC block<br>
sizes in table 215 arc between Kmin and Kmax, and wherein As<br>
discussed above, KI is based on X. X is determined by logic circuitry 213 from the<br>
received signal vector. Logic circuitry 213 then determines  and<br>
  . In a second embodiment of the present invention FEC block sizes Ki<br>
and KI-1 are determined, where <br>
At step 703 a received signal vector goes through code block de-segmentation<br>
circuitry 202 which organizes portions of received signal vector according to the C<br>
segment they are associated with. At step 705 filler handling circuitry 204 uses the<br>
knowledge of the location of filler bits to benefit turbo decoder 206, for e.g., by<br>
setting the LLRs corresponding to filler bits to a high magnitude. Each of the C<br>
segments is decoded at step 707. After turbo decoding, circuitry 208 discards the filler<br>
bits to obtain estimate of a segment (step 709). Code block assembler 211 assembles<br>
the estimated transport by suitably collecting and arranging the estimates of the<br>
segments obtained from circuitry 208 (step 711).<br>
While the invention has been particularly shown and described with reference to<br>
a particular embodiment, it will be understood by those skilled in the art that various<br>
changes in form and details may be made therein without departing from the spirit and<br>
scope of the invention. It is intended that such changes come within the scope of the<br>
following claims.<br><br>
Claims<br>
1.	A method of operating a transmitter, the method comprising the steps of:<br>
receiving a concatenated transport block of length X;<br>
determining an available FEC block size KI from a group of non-contiguous<br>
FEC block sizes, wherein the available non-contiguous FEC block sizes are between<br>
Kmin and Kmax, and wherein Kmin 
X,<br>
segmenting the concatenated transport block of length X into C segments of<br>
sizes substantially equal to KI;<br>
determining an FEC codeword for each of the C segments using FEC block<br>
size KI; and<br>
transmitting the C FEC codewords over the channel.<br>
2.	The method of claim 1 wherein <br>
3.	The method of claim 1 wherein the step of determining an FEC codeword further<br>
comprises the steps of:<br>
inserting filler bits into the segment to form an FEC input block;<br>
FEC encoding the FEC input block; and<br>
discarding bits related to the filler bits.<br>
4.	The method of claim 1 further comprising the steps of:<br>
receiving information bits of length A to be transmitted on one or more spatial<br>
streams;<br>
designating X' bits as a transport block, where X'
attaching CRC bits to the X' bits to form the concatenated transport block of<br>
length X; and<br>
wherein the concatenated transport block of length X is mapped to a first<br>
HARQ channel.5.	The method of claim 4 further comprising the steps of:<br>
designating  bits from the information bits as a second transport<br>
block;<br>
attaching CRC bits to form a second concatenated transport block; and<br>
wherein the concatenated transport block is mapped to a second HARQ<br>
channel.<br><br>
6.	The method of claim 1 wherein the step of determining an FEC codeword further<br>
comprises the steps of<br>
inserting groups of consecutive filler bits into a segment to form an FEC input<br>
block wherein the group length is a multiple of 7;<br>
FEC encoding the FEC input block; and<br>
discarding bits related to the filler bits.<br>
7.	The method of claim 6 wherein the method of discarding bits further comprises the<br>
steps of<br>
discarding groups of systematic bits corresponding to the filler bits; and<br>
discarding the parity bits corresponding to the groups of filler bits at the output<br>
of constituent encoder 1, wherein constituent encoder takes the FEC input block<br>
without interleaving for tail-biting turbo coders.<br>
8.	An apparatus comprising:<br>
receiving circuitry receiving a concatenated transport block of length X;<br>
logic circuitry determining an available FEC block size KI from a group of<br>
non-contiguous FEC block sizes, wherein the available non-contiguous FEC block<br>
sizes are between Kmin and Kmax, and wherein Kmin 
additionally based on X;<br>
code block segmentation circuitry segmenting the concatenated transport<br>
block of length X into C segments of sizes substantially equal to KI;<br>
encoding circuitry determining an FEC codeword for each of the C segments<br>
using FEC block size KI, and<br>
transmission circuitry transmitting the C FEC codewords over a channel.<br>
9.	The apparatus of claim 8 wherein <br>
10.	The apparatus of claim 8 further comprising:<br>
filler circuitry inserting filler bits into at least one segment to form an FEC<br>
input block.<br><br>
A method and apparatus for turbo coding and decoding is provided herein. During operation, a concatenated transport <br>
block (CTB) of length X is received and a forward error correction (FEC) block size KI is determined from a group of available<br>
non-contiguous FEC block sizes between Kmin and Kmax , and wherein Kmin 
The concatenated transport block of length X is segmented into C segments each of size substantially equal KI. An FEC codeword<br>
for each of the C segments is determined using FEC block size KI; and the C FEC codewords are transmitted over the channel.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1LT0xOUC0yMDA5LSgxNy0wNC0yMDE0KS1DT1JSRVNQT05ERU5DRS5wZGY=" target="_blank" style="word-wrap:break-word;">1037-KOLNP-2009-(17-04-2014)-CORRESPONDENCE.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1LT0xOUC0yMDA5LSgxNy0wNC0yMDE0KS1PVEhFUlMucGRm" target="_blank" style="word-wrap:break-word;">1037-KOLNP-2009-(17-04-2014)-OTHERS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1LT0xOUC0yMDA5LSgyMy0wNC0yMDEyKS1BU1NJR05NRU5ULnBkZg==" target="_blank" style="word-wrap:break-word;">1037-KOLNP-2009-(23-04-2012)-ASSIGNMENT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1LT0xOUC0yMDA5LSgyMy0wNC0yMDEyKS1DT1JSRVNQT05ERU5DRS5wZGY=" target="_blank" style="word-wrap:break-word;">1037-KOLNP-2009-(23-04-2012)-CORRESPONDENCE.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1LT0xOUC0yMDA5LSgyMy0wNC0yMDEyKS1GT1JNLTEucGRm" target="_blank" style="word-wrap:break-word;">1037-KOLNP-2009-(23-04-2012)-FORM-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1LT0xOUC0yMDA5LSgyMy0wNC0yMDEyKS1GT1JNLTIucGRm" target="_blank" style="word-wrap:break-word;">1037-KOLNP-2009-(23-04-2012)-FORM-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1LT0xOUC0yMDA5LSgyMy0wNC0yMDEyKS1GT1JNLTMucGRm" target="_blank" style="word-wrap:break-word;">1037-KOLNP-2009-(23-04-2012)-FORM-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1LT0xOUC0yMDA5LSgyMy0wNC0yMDEyKS1GT1JNLTUucGRm" target="_blank" style="word-wrap:break-word;">1037-KOLNP-2009-(23-04-2012)-FORM-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1LT0xOUC0yMDA5LSgyMy0wNC0yMDEyKS1GT1JNLTYucGRm" target="_blank" style="word-wrap:break-word;">1037-KOLNP-2009-(23-04-2012)-FORM-6.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1LT0xOUC0yMDA5LSgyMy0wNC0yMDEyKS1QQS1DRVJUSUZJRUQgQ09QSUVTLnBkZg==" target="_blank" style="word-wrap:break-word;">1037-KOLNP-2009-(23-04-2012)-PA-CERTIFIED COPIES.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LWNvcnJlc3BvbmRlbmNlLnBkZg==" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LWZvcm0gMTgucGRm" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LWdwYS5wZGY=" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1LT0xOUC0yMDA5LUdSQU5URUQtU1BFQ0lGSUNBVElPTi1DT01QTEVURS5wZGY=" target="_blank" style="word-wrap:break-word;">1037-KOLNP-2009-GRANTED-SPECIFICATION-COMPLETE.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LWludGVybmF0aW9uYWwgcHVibGljYXRpb24ucGRm" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-international publication.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LWludGVybmF0aW9uYWwgc2VhcmNoIHJlcG9ydC5wZGY=" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-international search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LXBjdCBwcmlvcml0eSBkb2N1bWVudCBub3RpZmljYXRpb24ucGRm" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-pct priority document notification.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LXBjdCByZXF1ZXN0IGZvcm0ucGRm" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-pct request form.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTAzNy1rb2xucC0yMDA5LXNwZWNpZmljYXRpb24ucGRm" target="_blank" style="word-wrap:break-word;">1037-kolnp-2009-specification.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QtMTAzNy1rb2xucC0yMDA5LmpwZw==" target="_blank" style="word-wrap:break-word;">abstract-1037-kolnp-2009.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="262704-oral-care-composition-comprising-a-phenolic-compound-and-antioxidant-vitamins-and-vitamin-derivatives.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="262706-voice-synchronization-during-call-handoff.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>262705</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1037/KOLNP/2009</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>37/2014</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>12-Sep-2014</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>08-Sep-2014</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>18-Mar-2009</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>MOTOROLA, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>1303 EAST ALGONQUIN ROAD, SCHAUMBURG, ILLINOIS 60196</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>BLANKENSHIP, T. KEITH</td>
											<td>21910 PINE LAKE CIRCLE, KILDEER, ILLINOIS 60047</td>
										</tr>
										<tr>
											<td>2</td>
											<td>BLANKENSHIP, YUFEI W.</td>
											<td>21910 PINE LAKE CIRCLE, KILDEER, ILLINOIS 60047</td>
										</tr>
										<tr>
											<td>3</td>
											<td>CLASSON, BRIAN K.</td>
											<td>756 BLOOMFIELD COURT, PALATINE, ILLINOIS 60067</td>
										</tr>
										<tr>
											<td>4</td>
											<td>NIMBALKER, AJIT</td>
											<td>2609 BRIAR TRAIL ROAD, SCHAUMBURG, ILLINOIS 60173</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H03M 13/29</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2007/078676</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2007-09-17</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/539,404</td>
									<td>2006-10-06</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/828,213</td>
									<td>2006-10-04</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/262705-method-and-apparatus-for-encoding-and-decoding-data by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:50:40 GMT -->
</html>
