<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/256099-methods-and-apparatuses-to-identify-devices by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:55:33 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 256099:METHODS AND APPARATUSES TO IDENTIFY DEVICES</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHODS AND APPARATUSES TO IDENTIFY DEVICES</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Embodiments of the present invention include systems with Readers and Tags in which a Reader queries the Tags with a parameter that includes a level of probability of reply according to which the Tags individually and randomly decide whether or not to reply. In one embodiment, the Tags can switch between two states : A and B. The query command also specifies a state (A or B) so that only the Tags in the specified state can reply. After successfully sending the Tag identification data from a Tag to the Reader, the Tag switches to the other state from the specified state. In one embodiment, the operations about the two states are symmetric. In one embodiment, the Tags can remember the parameters used in a query so that a short form of query command can be used to repeat the query with the same query parameters.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
METHODS AND APPARATUSES TO IDENTIFY DEVICES<br>
[0001]       This application is related to, claims the benefit of and incorporates by reference, Provisional U.S. Patent Application Serial no. 60/518,229, filed November 7, 2003. This application also claims the benefit of, and incorporates by reference, three prior U.S. Patent Applications: (1) U.S. Patent Application Serial No. 10/160,458, filed May 30, 2002; (2) U.S. Patent Application Serial No. 10/267,924, filed October 8, 2002; and (3) U.S. Patent Application Serial No. 10/915,725, filed August 9, 2004.<br>
TECHNICAL FIELD<br>
[0002]       The invention relates to the field of devices having an identifier, such as Tags,<br>
and further relates to methods and apparatuses for identifying such Tags.<br>
BACKGROUND<br>
[0003]       Multiple wireless Tags can be interrogated by sending a code from an interrogating transmitter (e.g., a Reader) and having information transmitted by the Tag in response. This is commonly accomplished by having the Tag listen for an interrogation message and for it to respond with a unique serial number and/or other information. The Tags typically have limited power available for transmitting data wirelessly to the Reader. It is desirable to extend the range of wireless Tags so that it is not necessary to bring each Tag close to a Reader for reading. However, when the range of the reading system is extended , many Tags will be within the range of the interrogating system so that their replies may corrupt each other. [0004]       Current implementations of radio frequency (RF) Tags require considerable logic to handle interface protocols and anti-collision problems that occur when multiple Tags within the range of a Reader all attempt to reply to an interrogating message. For example, current integrated circuits that are used in RF Tags require nearly 3,000 logic<br><br>
gates to handle an interface protocol and to handle anti-collision protocols. This considerable size required by an integrated circuit increases the cost of the RF Tag and thus makes it less likely for such a Tag to be more commonly used. Prior art attempts to avoid collisions when reading multiple RF Tags are described in U.S. Patents 5,266,925, 5,883,582 and 6,072,801. However, these prior art approaches provide inefficient solutions for avoiding collisions when reading multiple RF Tags.<br><br>
SUMMARY OF EMBODIMENTS OF THE INVENTION<br>
[0005]       Methods and apparatuses to identify Tags are described here. Some of the embodiments of the present invention are summarized in this section. [0006]      Embodiments of the present invention include systems with Readers and Tags in which a Reader queries the Tags with a parameter that specifies a level of probability of reply according to which the Tags individually and randomly decide whether or not to reply. In one example, the Tags can switch between two states: A and B. The query command also specifies a state (A or B) so that only the Tags in the specified state can reply. After successfully sending the Tag identification data from a Tag to the Reader, the Tag switches to the other state from the specified state. In one embodiment, the operations about the two states are symmetric. In another embodiment, the Tags can remember the parameters used in a query so that a short form of query command can be used to repeat the query with the same query parameters.<br>
[0007]       In one aspect of the present invention, a method for querying a plurality of Tags includes broadcasting a first query command with a first value of a probability parameter, where the first value of the probability parameter indicates a first probability of reply according to which each of the plurality of Tags randomly determines whether or not to reply, and detecting a reply in response to the first query command. In one embodiment, in response to a determination that there is no reply to one or more query commands to query according to the first value of the probability parameter, a Reader further broadcasts a second query command with a second value of the probability parameter where the second value of the probability parameter indicates a second probability of reply which is greater than the first probability of reply. In another embodiment, in response to a determination that there is no legible reply to one or more query commands to query according to the first value of the probability parameter, due to collision of multiple replies, a Reader further broadcasts a second query command with a second value of the probability parameter where the second value of the probability parameter indicates a second probability of reply which is less than the first probability of<br><br>
reply. In one embodiment, the first value is an integer Q, the first probability of reply for one of the plurality of Tags is substantially equal to pQ and p is less than 1 (e.g., p can be substantially equal to 0.5). In one embodiment, the first probability of reply for a first one of the plurality of Tags is different from the first probability of reply for a second one of the plurality of Tags. In one embodiment, the first query command further includes a state flag indicating a first state so that Tags in a second state do not reply to the first query command and Tags in the first state reply to the first query command randomly according to the first value of the probability parameter. In one embodiment, a Reader 1) broadcasts a second query command with a second value of the probability parameter and a state flag indicating the second state so that Tags in the first state do not reply to the second query command and Tags in the second state reply to the second query command randomly according to the second value of the probability parameter, and 2) detects a reply in response to the second query command. In one embodiment, the first and second query commands are symmetric with respect to the first and second states. In one embodiment, in response to a legible reply to the first query command, which reply includes first handshaking data, a Reader further sends a second command including the first handshaking data and receives Tag identification data as a reply to the second command. When the identification Tag data is not received successfully, the Reader further sends a command to indicate an error in receiving the Tag data. In one embodiment, a Reader further broadcasts a second query command without specifying a value of the probability parameter to query according to the first value of the probability parameter. The first query command includes second values of a plurality of parameters including the probability parameter, and the second query command does not specify values of the plurality of parameters to query according to the second values of the plurality of parameters. In one example, the second query command is substantially shorter than the first query command.<br>
[0008] In another aspect of the preset invention, a method for a Tag to respond to a query from a Reader includes receiving from the Reader a first query command with a first value of a probability parameter, and randomly deciding whether or not to reply to<br><br>
the first query command so that a probability of reply is according to the first value of the probability parameter. In one example, in response to a random decision to reply, a Tag further sends a reply with first handshaking data, which can be a random number generated in response to the first query command. In one embodiment, the first value is an integer Q, the first probability of reply for one of the plurality of Tags is substantially equal to pQ, and p is less than 1 (e.g., p can be substantially equal to 0.5). In one embodiment, the first query command further includes a state flag indicating a first state, the Tag does not reply to the first query command if the Tag is in a second state; and the Tag replies to the first query command randomly according to the first value of the probability parameter if the Tag is in the first state. In one embodiment, a Tag 1) receives a second query command with a second value of the probability parameter and a state flag indicating the second state, and 2) randomly decides whether or not to reply to the second query command so that a probability of reply is according to the second value of the probability parameter, if the Tag is in the second state. The Tag does not reply to the second query command if the Tag is in the first state. In one embodiment, the Tag processes the first and second query command with symmetry with respect to the first and second states. In one embodiment, a Tag further sends a first reply with first handshaking data in response to a random decision to reply, and in response to receiving from the Reader a second command including the first handshake data, the Tag sends a second reply with Tag identification data. In one embodiment, in response to receiving a query command after sending the second reply, the Tag switches from the first state to the second state and, after receiving a command indicating an error in receiving the Tag identification data at the Reader, the Tag remains in the first state if a query command is received after the command indicating the error. In one embodiment, a Tag further receives a second query command that does not specify a value of the probability parameter and the Tag randomly decides whether or not to reply to the second query command so that a probability of reply is according to the first value of the probability parameter. In one embodiment, the first query command includes values of a plurality of parameters including the probability parameter; the second query command does not<br><br>
specify values of the plurality of parameters, and the Tag processes the second query<br>
command according to the second values of the plurality of parameters. In one<br>
embodiment, the second query command is substantially shorter than the first query<br>
command.<br>
[0009]       The present invention includes methods and apparatuses that perform these<br>
methods, including data processing systems that perform these methods, and computer<br>
readable media which when executed on data processing systems cause the systems to<br>
perform these methods.<br>
[0010]      Other features of the present invention will be apparent from the<br>
accompanying drawings and from the detailed description that follows.<br><br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0011]       The present invention is illustrated by way of example and not limitation in<br>
the figures of the accompanying drawings in which like references indicate similar<br>
elements.<br>
[0012]       Figure 1 shows an example of an identification system, which includes a<br>
Reader, and a plurality of RF Tags.<br>
[0013]       Figure 2 shows an example of one embodiment of an RF Tag that may be<br>
used with embodiments of the present invention.<br>
[0014]       Figure 3 shows an example of an RF Tag according to one embodiment of the<br>
present invention.<br>
[0015]      Figure 4 illustrates a flowchart representation of a communication method<br>
according to one embodiment of the present invention.<br>
[0016]       Figure 5 illustrates a flowchart representation of a method for a Tag to<br>
communicate with a Reader according to one embodiment of the present invention.<br>
[0017]       Figure 6 shows an example of a decision making circuit for a Tag to<br>
randomly decide whether or not to reply to a query according to one embodiment of the<br>
present invention.<br>
[0018]       Figure 7 shows a flowchart representation of a method for a Tag to generate<br>
random numbers for communication with a Reader according to one embodiment of the<br>
present invention.<br>
[0019]       Figure 8 illustrates a flowchart representation of a method for a Reader to<br>
read Tag data from a number of Tags according to one embodiment of the present<br>
invention.<br>
[0020]       Figure 9 illustrates a Tag state diagram according to one embodiment of the<br>
present invention.<br>
[0021]       Figures 10 - 13 illustrate signal modulations for broadcasting from a Reader<br>
to Tags according to embodiments of the present invention.<br>
[0022]       Figures 14 - 17 illustrate signal modulations for a Tag to reply to a Reader<br><br>
according to embodiments of the present invention.<br><br>
DETAILED DESCRIPTION<br>
[0023]       The following description and drawings are illustrative of the invention and are not to be construed as limiting the invention. Numerous specific details are described to provide a thorough understanding of the present invention. However, in certain instances, well-known or conventional details are not described in order to avoid obscuring the description of the present invention. The term "coupled" as used herein, may mean directly coupled or indirectly coupled through one or more intervening components. References to one or an embodiment in the present disclosure are not necessarily references to the same embodiment, and such references mean at least one. [0024]       Figure 1 illustrates an example of an identification system 100 which includes a Reader 101 and a plurality of Tags 131, 133, 135,... and 139. The system is typically a Reader-talks-first RF ID system using either passive or semi-passive active backscatter transponders as Tags. The incorporation of a battery and/or memory into a Tag is an expanded feature to facilitate longer read range; however, the use of the battery does require certain trade-offs, such as higher costs, limited longevity, larger form factor, greater weight and end-of-life disposal requirements. Thus, the Tag.s 131-139 may have memory and/or a battery or may have neither of these elements. It will be appreciated that different types of Tags may be mixed in a system where a Reader is interrogating Tags with batteries and Tags without batteries. There are at least 4 classes of Tags which may be used with the present invention: (1) no power source on the Tag except for power which is obtained from the Tag's antenna, but the Tag does include a read-only memory which has the Tag's identification code, (2) a Tag without internal power, but when powered from the Reader, can write data to non-volatile memory in the Tag; this type of Tag also includes memory for storing the identification code, (3) a Tag with a small battery to provide power to the circuitry in the Tag. Such a Tag may also include non-volatile memory as well as memory for storing the Tag's identification code, and (4) a Tag which can communicate with other Tags or other devices. [0025]       Figure 1 shows an embodiment of a Reader. The Reader 101 typically<br><br>
includes a receiver 119 and a transmitter 123, each of which is coupled to an I/O (input/output) controller 117. The receiver 119 may have its own antenna 121, and the transmitter 123 may have its own antenna 125. It will be appreciated by those in the art that the transmitter 123 and the receiver 119 may share the same antenna provided that there is a receive/transmit switch which controls the signal present on the antenna and which isolates the receiver and transmitter from each other. The receiver 119 and the transmitter 123 may be similar to conventional receiver and transmitter units found in current Readers. The receiver and transmitter typically operate, in North America, in a frequency range of about 900 megahertz. Each is coupled to the I/O controller 117 that controls the receipt of data from the receiver and the transmission of data, such as commands, from the transmitter 123. The I/O controller is coupled to a bus 115 that is in turn coupled to a microprocessor 113 and a memory 111. There are various different possible implementations that may be used in the Reader 101 for the processing system represented by elements 117,115,113 and 111. In one implementation, the microprocessor 113 is a programmable microcontroller, such as an 8051 microcontroller or other well-known microcontrollers or microprocessors (e.g. a PowerPC microprocessor) and the memory 111 includes dynamic random access memory and a memory controller that controls the operation of the memory. M memory 111 may also include a non-volatile read only memory for storing data and software programs. The memory 111 typically contains a program that controls the operation of the microprocessor 113 and also contains data used during the processing of Tags as in the interrogation of Tags. In one embodiment further described below, the memory 111 would typically include a computer program which causes the microprocessor 113 to send search commands through the I/O controller to the transmitter and to receive responses from the Tags through the receiver 119 and through the I/O controller 117. The Reader 101 may also include a network interface, such as an Ethernet interface, which allows the Reader to communicate to other processing systems through a network. The network interface would typically be coupled to the bus 115 so that it can receive data, such as the list of Tags identified in an interrogation from either the microprocessor<br><br>
113 or from the memory 111.<br>
[0026]      Figure 2 shows an example of one implementation of a Tag that may be used with the present invention. The Tag 200 includes an antenna 201 that is coupled to a receive/transmit switch 203. This switch is coupled to the receiver and demodulator 205 and to the transmitter and modulator 209. A correlator and controller unit 207 is coupled to the receiver and demodulator 205 and to the transmitter 209. The particular example shown in Figure 2 of a Tag may be used in various embodiments in which a memory for maintaining data between commands is maintained in the Tag and in which a bit by bit correlation occurs in the Tag. The receiver and demodulator 205 receives signals through the antenna 201 and the switch 203, demodulates the signals, and provides these signals to the correlator and controller unit 207. Commands received by the receiver 205 are passed to the controller of the unit 207 in order to control the operation of the Tag. Data received by the receiver 205 is also passed to the control unit 207, and this data may include parameters for a query command and handshake data from a handshake command in the embodiments described below. The transmitter 209, under control of the control unit 207, transmits responses or other data through the switch 203 and the antenna 201 to the Reader. It will be appreciated by those in the art that the transmitter may be merely a switch or other device that modulates reflections from an antenna, such as antenna 201.<br>
[0027]      In one embodiment of the present invention, to achieve Tag cost low enough to enable ubiquitous use of Tags in the supply chain, the Tags are designed with properties, such as a small Integrated Circuit (IC) area to permit low cost, small memory, non-precision timing requirements, atomic transactions to minimize Tag state storage requirements and others. Such Tags can be produced at low cost. However, other Tag designs can also be used. Further, it is understood that the method of avoid collisions in communications according to embodiments of the present invention can also be used in other similar situations.<br>
[0028]      Figure 3 shows an example of an RF Tag according to one embodiment of the present invention. In one embodiment, a VLC (Very Low Cost) Tag 300 includes an<br><br>
antenna 301 and an integrated circuit 303, connected together. The Tag IC 303 implements the command protocol and contains the ePC (Electronic Product Code). The antenna 301 receives the Reader interrogation signals and reflects the interrogation signal back to the Reader in response to a modulation signal created by the IC 303. The Tag IC 303 implements the VLC Tag by combining an RF interface and power supply 311, data detector and timing circuit 313, command and control 315, data modulator 317 and memory 319. In one embodiment, command and control 315 includes static logic which implements the communication protocol according to embodiments of the present invention.<br>
[0029]      The RF Interface and Power Supply 311 converts the RF energy into the DC power required for the Tag IC 303 to operate, and provides modulation information to the Data Detector and Timing circuit 313. The RF interface also provides a means of coupling the Tag modulation signals to the antenna for transmission to the Reader. The Data Detector and Timing circuit 313 de-modulates the Reader signals and generates timing and data signals used by the command and control 315. The command and control 315 coordinates all of the functions of the Tag IC 303. The command and control 315 may include state logic to interpret data from the Reader, perform the required internal operations and determines if the Tag will respond to the Reader. The command and control 315 implements the state diagram and communications protocol according to embodiments of the present invention. The memory 319 contains the ePC code of the item Tagged by a VLC Tag. The data modulator 317 translates the binary Tag data into a signal that is then applied to the RF Interface 311 and then transmitted to the Reader (e.g., Reader 101).<br>
[0030]       The design and implementation of the Tags can be characterized in layers. For example, a physical and environmental layer characterizes the mechanical, environmental, reliability and manufacturing aspects of a Tag a radio frequency (RF) transport layer characterizes RF coupling between Reader and Tag and a communication layer characterizes communications/data protocols between Readers and Tags. Various different implementations of Tags at different layers can be used with embodiments of<br><br>
the present invention. It is understood that the implementations of the Tags are not limited to the examples shown in this description. Different Tags or communication devices can use methods of the embodiments of the present invention for communication according to the needs of the target application.<br>
[0031]       In one embodiment of the invention, a Tag may be fabricated through a fluidic self-assembly process. For example, an integrated circuit may be fabricated with a plurality of other integrated circuits in a semiconductor wafer. The integrated circuit will include, if possible, all the necessary logic of a particular RF Tag, excluding the antenna 301. Thus, all the logic shown in the Tag 300 would be included on a single integrated circuit and fabricated with similar integrated circuits on a single semiconductor wafer. Each circuit would be programmed with a unique identification code and then the wafer would be processed to remove each integrated circuit from the wafer to create blocks that are suspended in a fluid. The fluid is then dispersed over a substrate, such as a flexible substrate, to create separate RF Tags. Receptor regions in the substrate would receive at least one integrated circuit, which then can be connected with an antenna on the substrate to form an RF Tag. An example of fluidic self-assembly is described in U.S. Patent No.<br>
5,545,291.<br>
[0032]       Figure 4 illustrates a flowchart representation of a communication method<br>
according to one embodiment of the present invention. A Reader broadcasts a query command with a specified value of Q parameter to Tags in state A (401). In response to the query command, each of the Tags in state A individually and randomly decides whether or not to reply to the query command such that a probability of replying is in accordance with the value of the Q parameter (403). Tags in state B do not reply to the query command which is for tags in state A. The Reader then detects any reply to the query command (405). It is determined whether there are too few replies (407). For example, when the Reader obtains no reply for a number of query commands with the specified value of Q parameter, the Reader may determine that the specified level of probability to reply is too low and there are too few replies. When there are too few replies, the Reader adjusts the value of Q parameter to increase the probability to reply<br><br>
(411). Similarly, it is determined whether there are too many replies (409). When there are too many replies, the replies from different Tags corrupt each other. Thus, the Reader adjusts the value of Q parameter to decrease the probability to reply when there are too many replies. If no legible reply is received (417), the Reader broadcasts a query command without specifying parameters so that the previously transmitted parameters are used for the current query (415). Since the same parameters for the query are not transmitted again, it is faster to issue the query command to repeat the previous query than to issue the query command with all the parameters. In response to the new query command, each of the Tags in state A then individually and randomly decides whether or not to reply to the query command such that a probability of replying is in accordance with the value of the Q parameter (403).<br>
[0033]      When the value of Q parameter is adjusted to a suitable value, the probability of obtaining one legible reply from a large number of Tags will be high. Thus, the Reader can simply repeat the previous query without adjusting query parameters until there are too few (or too many) replies.<br>
[0034]      When one legible reply is received (417), the Reader communicates with the Tag which provides the reply (419). In one embodiment of the present invention, the reply from the Tag includes data that identifies the Tag so that the Reader can address the Tag that provides the legible reply. In one embodiment, a Tag generates a random number for the purpose of handshaking with the Reader. During the communication with the Tag, the Reader obtains Tag Identification data from the Tag. If the communication with the Tag is successful (421), the Tag switches from state A into state B (423); otherwise, the Tag remains in state A (425). Once the Tag is in state B, the Tag does not respond to the query for Tags in state A. Thus, the Reader can communicate with the Tags in state A one at a time until all Tags are in state B.<br>
[0035]       In one embodiment of the present invention, the operations with respect to state A and state B are symmetric. For example, the Reader can broadcast a query command with a specified value of Q parameter to Tags in state B. In response to the query command for Tags in state B, each of the Tags in state B individually and<br><br>
randomly decides whether or not to reply to the query command such that a probability of replying is in accordance with the value of the Q parameter. Tags in state A do not respond to the query for Tags in state B. If the communication with the Tag in state B is successful, the Tag switches from state B into state A; otherwise, the Tag remains in state B. Thus, the Reader can sort the Tags from state A into state B one at a time, or sort the Tags from state B into state A one at a time.<br>
[0036]       Alternatively, the operations with respect to state A and state B may be non-symmetric. For example, the Reader can sort the Tags from state A into state B one at a time but not from state B into state A one at a time. In such an implementation, the Reader can first place the Tags into state A before starting to read Tag data from Tags one at a time.<br>
[0037]       Figure 5 illustrates a flowchart representation of a method for a Tag to communicate with a Reader according to one embodiment of the present invention. In operation 501, the Tag receives commands from a Reader. After receiving a query command with a query parameter Q for Tags in state A (e.g., QueryA) (503), the Tag determines if it is in state A (507). If the Tag is not in state A, the Tag does not reply to the query for Tags in state A.<br>
[0038]       Similarly, after receiving a query command with a query parameter Q for Tags in state B (e.g., QueryB) (505), the Tag determines if it is in state B (507). If the Tag is not in state B, the Tag does not reply to the query for Tags in state B. [0039]       If the query matches the state of the Tag (e.g., the Tag in state A receives a query for Tags in state A or the Tag in state B receives a query for Tags in state B), the Tag randomly determines whether or not to reply to the query command such that a probability of replying is in accordance with the query parameter (e.g., having a probability of 0.5Q to reply). If the Tag decides to reply (513), the Tag replies to the query command with handshake data (e.g., a random number). [0040]       When the Tag receives a query command without parameters (e.g., QueryRep) (517), it is determined whether the Tag obtained query parameters from a previous query command (519). If the Tag has the query parameters from a previous<br><br>
query command (e.g., a previous QueryA or QueryB command), the Tag responds to the query using the same parameters that were used for the previous query command (521). For example, if the previous query command is for Tags in state A, the current query command without parameters is also for Tags in state A. Thus, operation 507 is performed to check if the query is intended for the Tag. Similarly, if the previous query command is for Tags in state B, the current query command without parameters is also for Tags in state B so that operation 509 is performed. The Q parameter used in processing the previous query command is also used for the processing of the current query command without parameters. In one embodiment of the present invention, when a suitable value of Q parameter is reached, the Reader issues many query commands without parameters to repeat the query of the same parameters. Since the query command without parameters is quick to transmit (and quick to process), the time to process a large number of Tags can be shortened using such a query command without parameters.<br>
[0041]       When the Tag receives a command to handshake with handshake data from the Reader (e.g., Ack) (523), the Tag checks if the received handshake data matches the handshake data sent from the Tag (525). If the handshake data do not match (527) (e.g., the handshake command is not in response to a reply sent from the Tag or the handshake data received from the Reader is different from the handshake data sent from the Tag), the Tag does not reply. Otherwise, the Tag sends Tag data (e.g., ePC) to the Reader (529) and enters into "waiting to change state" (531). In one embodiment, the Tag assumes that the Reader receives the Tag data unless the Reader transmits a command to indicate that the Tag data is not received. For example, when the Tag receives a command to prevent state change (e.g., NAk) (533), the Tag exits "waiting to change state" (537). When the Tag receives a command other than to handshake or to prevent state change (e.g., receiving QueryA, QueryB or QueryRep) (539), the Tag changes Tag state (e.g., from State A to State B, or from State B to State A) (543) if the Tag is waiting to change state (541). In another embodiment, the Tag always assumes that the Reader receives the Tag data. The Tag changes its state from A to B, or from B to A, if a query<br><br>
command is received while it is waiting to change state after sending the Tag data. It is understood that operations 541 and 543 are performed before operation 507 or 509 is performed. Thus, after replying to a query for tags in state A and sending the Tag data, the tag in state A switches into state B and does not reply to a further query for tags in state A. To prevent the Tag from changing state, the Reader can broadcast a command to prevent state change (e.g., NAk) before another query command. [0042]       Figure 6 shows an example of a decision making circuit for a Tag to randomly decide whether or not to reply to a query according to one embodiment of the present invention. A random bit generator (601) generates one bit of random information at a time. A number of random bits are stored in memory 603. For example, when a new bit of random information is generated, it is shifted into the memory so that the first bit in the memory contains the new bit of random information and the oldest bit of random information is discarded. When the Tag received the Q parameter from the Reader (e.g., in a QueryA command or a QueryB command), the value of the Q parameter is stored in memory 607. A logic circuit (605) determines if the first Q bits (e.g., the most recent Q bits) in memory 603 are all zeros. If the first Q bits in memory 603 are all zeros, the Tag decides to reply to the query. Otherwise, the Tag does not reply. When Q is zero, the Tag always decides to reply if the Tag is in the specified state.<br>
[0043]       In one embodiment, the random bit generator (601) has a probability of (1/2) to generate zeros. Thus, for a given Q value, the probability to reply is (1/2)Q. The random bit generator (601) may generate random bits at a rate of one bit per command, faster than one bit per command, or slightly slower than one bit per command. It is understood that different Tags may generate the random bits at different rates. Further, the random bit generator (601) may not generate zeros with a probability of (1/2). For example, important Tags may be biased to have a probability greater than 1/2 to generate zeros. Thus, these Tags are more likely to satisfy requirement that the first Q bits are all zeros. As a result, these Tags have a greater probability to reply earlier than other Tags. [0044]       From the above example, it is understood that the Tag can randomly decide to reply with a probability of replying controlled by the Q parameter. Different<br><br>
implementations can be used to achieve such controlled random decision-making. For example, it may be requested that the oldest Q bits in the memory are all ones. Since adjusting the value of the Q parameter can adjust the probability of replying, a Reader can adaptively adjust the Q value to increase the probability of getting a single legible reply from a large number of Tags that are in the range of the Reader. [0045]       Figure 7 shows a flowchart representation of a method for a Tag to generate random numbers for communication with a Reader according to one embodiment of the present invention. Operation 701 generates a random bit (e.g., using a random bit generator 601). It is then determined whether the Tag has finished handshaking with a Reader (703). If the Tag is in the process of handshaking with the Reader, the random bit is not used to update the information in the memory (e.g. 603). Thus, the random number in the memory remains the same during the process of handshaking. In the process of handshaking, the Tag sends the content of the memory of random bits (e.g., 16-bit memory) to the Reader as the handshake data and receives a handshake command (e.g., Ack) with handshake data back from the Reader. If the handshake data received from the Reader matches the handshake data sent from and maintained at the Tag, handshaking is successful and the Tag can send the Tag data to the Reader in response. If the Reader does not send the handshake command again (or the handshake data does not match), the Tag finishes handshaking with the Reader (e.g., by sending another query command). When the Tag is not handshaking with the Reader, the Tag does not need to freeze the content of the memory of random bits. Thus, the Tag shifts the random bit into the memory of random bits (705) to update the content. Based on this description, a person skilled in the art can envision various alternative implementations. For example, the random bit may be generated only in response to a query command. [0046]       In one embodiment of the present invention, the entire content of the memory of random bits (e.g., 603) that is used for making the random decision is used as the handshake data. Alternatively, only a portion of it may be used as the handshake data. For example, when the Tag replies if the first Q bits are all zeros, the Tag may use only the last (16 - Q) bits of the random bit memory as handshake data. Alternatively, the Tag<br><br>
may use other random numbers as the handshake data.<br>
[0047]      Figure 8 illustrates a flowchart representation of a method for a Reader to read Tag data from a number of Tags according to one embodiment of the present invention. After broadcasting a query command with a Q parameter for Tags in state A (801), a Reader detects any reply from the Tags with handshake data (803). When there is no reply (805), it is determined whether the Q parameter is already equal to zero. If the Q parameter is equal zero and no reply is received in response to the query command, it can be determined that there is no Tag in state A within range, since any Tag in state A receiving the query command will reply when the Q parameter is equal to zero. If the Q parameter is not already zero, the Reader can reduce the Q parameter to increase the probability of receiving a reply. For example, the Reader can maintain a parameter Qf as a floating-point number so that Q is determined from Int(Qf) (where Int(x) indicates the integer portion of a real number x). The Reader can update Qf as Min(Qf/l .4, 0.9) (where Min(x/a, b) indicates the minimum value between x/a and b), and update Q as Int(Q) (811, 815), when there is no reply. When there are multiple replies from different Tags that corrupt each other, the Reader cannot obtain legible handshake data from the replies (817). To,avoid collision, the Reader can increase the Q parameter to decrease the probability of receiving multiple replies. For example, the Reader can update Qf as Qf xl.4 and update Q as Int(Q) (813, 815) when multiple replies collide to corrupt each other.<br>
[0048]      Note that when the Reader can obtain legible handshake data from one reply, the Reader does not have to increase the Q parameter even if there is collision. For example, when a weak reply collides with a strong reply, the Reader can still obtain the handshake data from the strong reply. In this case, the Reader can simply ignore the weak reply and start to handshake with the Tag that sends the strong reply. Thus, hidden collisions improve performance, since weak Tags are protected by the ACK handshake and the stronger Tag is still counted if the Reader can extract its handshake. [0049]       After legible handshake data is received as reply to the query command (817),<br><br>
the Reader handshakes with the Tag that sends the handshake data (e.g., by broadcasting a command, such as Ack, with the handshake data). Then, the Reader tries to receive Tag data (e.g., Tag identification data, such as ePC) from the Tag (821). For example, if the Tag determines that the handshake data in the Ack command matches the handshake data sent from the Tag, the Tag transmits the Tag identification data as a reply to the Ack command. If the Tag receives legible Tag data (823), the Tag can broadcast a command to repeat the previous query command without re-broadcasting the parameters for the query (829). In response to the query command, the Tag that just sent the Tag data switches from state A to state B so that it does not respond to the query for Tags in state A. The Tags in state A use the previous query parameters for the current query. However, if the Tag data is not legible (823), the Reader may try again to handshake with the Tag (819) or broadcast a command to indicate that the Tag data is not received (827). [0050]      In one embodiment of the present invention, the Tag switches state in response to any query commands after transmitting the Tag data. Thus, after receiving the legible Tag data, the Reader can choose to broadcast a command to repeat the previous query or to broadcast a query command with new query parameters. Alternatively, the Tag can be implemented such that it switches state, after transmitting the Tag data, only in response to the command that repeats the previous query command (e.g., QueryRep). Thus, the Reader can use one QueryRep command to cause: 1) the Tag that has just sent the Tag data to switch state to leave the set of Tags to be interrogated; and 2) other Tags to be queried and to make random decisions about whether or not to reply to the query.<br>
[0051]      In one implementation of the present invention, system communication follows a two-stage command-reply pattern where the Reader initiates the transaction (Reader Talks First, RTF). In the first phase, the Reader provides power to one or more passive Tags with continuous wave (CW) RF energy. Tags power up, ready to process commands after receiving one command that is used for synchronization of their clocks. The Reader transmits information to the field by amplitude modulation using the Reader-to-Tag encoding scheme described below. On completion of the transmission, the Reader<br><br>
ceases modulation and maintains RF to power the Tags during the reply phase. Tags communicate with the Reader via backscatter modulation during this period using the four (4)-phase bit encoding scheme described below.<br>
[0052]      In one implementation, basic commands are designed to limit the amount of state information the Tags have to store between transactions. The power available to a passive Tag is a complicated function of transmitted power, Tag/Reader antenna orientations, local environment and external sources of interference. Tags on the margin of the RF field are powered unreliably and therefore cannot be counted on to maintain a memory of previous transactions with the Reader. In particular, moving Tags or objects may cause the Tag to have power only for brief intervals, primarily due to multi-path interference. In one implementation, it is designed to allow the efficient counting of Tags under these conditions by minimizing the total transaction time and by allowing rapid recovery from missed commands. Tags which have threshold power and receive three commands (e.g., a prior command to spin up on, a query, and an ACK with its reply) in as little as three milliseconds can be inventoried.<br>
[0053]      In one implementation, there is only one bit of state for each session, between command groups, and the impact of that state is further lessened by symmetrizing the command set about those two states, as described below.<br>
[0054]       In one implementation, each Tag has four sessions available, each with a single bit of independent state memory. The backscatter mode and data rate are the same for all of the sessions, and the random reply register is the same for all sessions. The state of being selected is also the same for all sessions. This session structure allows up to four Readers or processes to communicate with the Tag population in a multitasking environment, but they can do so with a complete command group. A command group starts with a QueryA/B (QueryRep does not start a command group), and continues through an ACK, and ends with either the command after the ACK (which completes the transaction from the Tag's point of view), or at the end of the use of the SELECTED state by a process. [0055]      One example of the use of two sessions is a portal Reader which is counting<br><br>
all Tags coining through a portal, but wants to preferentially count pallets. It could then run two simultaneous processes on the Tag population. Session 0, for example, could be used by one process to sweep the entire population of Tags between state A and state B to ensure counting all Tags that it touches once, regardless of their former state. Session 1 could selectively mask all pallet Tags to state A for that session and all other Tags to state B, and count them preferentially in an interleaved process, without interfering with the ongoing inventory in the first process.<br>
[0056]       A similar example would be a set of store inventory Readers set to synchronize their inventory type. For example, all inventory Readers would use Session 0 at the Tags to inventory from the A state to the B state for a ten second interval, and then inventory from the B state back to the A state. This ensures that all Tags are counted by one inventory Reader once per cycle. Simultaneously, a handheld Reader could use session 1 to look for a specific ePC by masking a sufficient portion of that ePC to state A while masking all other Tags to state B. It then uses Session 1 QueryA commands to seek that Tag or Tag type. This avoids interference with the store inventory Readers as long as command groups do not collide (interleave) and as long as RF interference is avoided.<br>
[0057]       Figure 9 illustrates a Tag state diagram according to one embodiment of the present invention. The Tag state diagram shows the states that a Tag may take within command groups. A command group is a set of sequential commands which start with a QueryA/B command and end with the Tag leaving the selected or acknowledge state. Between Tag groups, the state in each session is A or B. The DEAD state is a permanent state. For Session 0, states A and B are persistent states, even in the absence of power. After a long period of time, at least one second but possibly hours, state B reverts to state A. In state A, all Tags respond to QueryA commands but not QueryB commands. In state B, QueryB commands are responded to, but not QueryA commands. If the state memory has expired for a particular session, the Tag enters into state A upon power up for that session. [0058]       Sessions other than the 0 Session may not have a persistent A-B flag, and may<br><br>
remember their state only while power is available. If their state is lost, the state for that<br>
session reverts to state A.<br>
[0059]       Upon power up, the Tag resets all of its internal state except for the state flags<br>
for each of the 4 sessions. The Tag synchronizes its clock to the rising edges of the sync<br>
bits provided by the first command, but is not allowed to act upon the first command after<br>
power up. It maintains its clock with sufficient accuracy to decode the next command. If<br>
clock frequency needs to be corrected by more than 20% during any command spinup,<br>
the Tag does not respond to that command but waits until the next QueryA or QueryB<br>
command. This is designed to prevent inappropriate and possibly interfering responses.<br>
[0060]       For each session, while a Tag is in state A, it responds to QueryA commands<br>
but not QueryB commands. A Tag enters into state A upon the appropriate SetState<br>
command, and upon successful completion of an inventory handshake starting with a<br>
QueryB.<br>
[0061]       For each session, while a Tag is in state B, it responds to QueryB commands<br>
but not QueryA commands. A Tag enters into state B upon the appropriate SetState<br>
commands, and upon successful completion of an inventory handshake started from a<br>
QueryA. A Tag may remain in state B for session zero (0) even with loss of power of up<br>
to 1 second.<br>
[0062]       For each independent session, if the state memory for state B is lost, the Tag<br>
powers up in state A.<br>
[0063]       The Dead State is a permanent change in the state of the Tag state entered on<br>
receipt of a valid Kill Command and Kill Code sequence. The Dead state is implemented<br>
by a permanent change in the physical Tag, such as programming E2 or blowing a fuse.<br>
[0064]       Some embodiments of the present invention relates to RFID protocol for<br>
achieving a fast, robust, compatible and extensible protocol for various classes of RFID<br>
Tags, while allowing very inexpensive implementations for both Tags and Readers. In<br>
one embodiment, the RF transport layer focuses on UHF operations; for example, the<br>
protocol can be applicable from 400 MHz to 2.45 GHz.<br>
[0065]       There are at least four classes of Tags for different applications and cost<br><br>
requirements. Tags of different classes that meet the requirements of all of the design layers are able to work together. Tags may also include a standardized wired I/O interface to sensors, clocks, displays and other devices.<br>
[0066]      Class I Tags are simple passive, read-only backscatter Tags, designed for lowest cost production. Class I Tags have a one-time programmable memory, write once identity memory, 64 or 96-bit ePC Code, and optional recycling code. [0067]       Class II Tags are passive backscatter Tags with higher functionality and cost than Class I. In addition to the Class I features, Class II Tags: can write and read data into and out of Tags, have read-write memory, may have battery power for non-communication purposes, and optionally have sensors and data loggers. [0068]      Class HI Tags are semi-passive backscatter Tags. In addition to class II features, class HI Tags have a built-in battery or other energy source to support increased read range.<br>
[0069]       Class IV Tags are modem-like semi-passive or active (transmitter) Tags that can wirelessly communicate with each other and/or other devices. Class IV Tags may also emulate the class I-III Tags in communication with Readers. [0070]       RFID systems according to one implementation of the present invention have features including: identification of single Tags in the field of a Reader, anti-collision functionality to manage reading of multiple Tags in the field of a Reader, error management in the system from sources of RF interference and marginal Tags, operations in compliance with local RF regulatory requirements, and coexistence with systems operating in compliance with local RF regulatory requirements. [0071]      Some detailed examples are provided below. However, according to this description, different detailed designs and implementations can be envisioned by those skilled in the art. Overall system architecture is typically a function of the marketplace. [0072]      In the following description, references to bits in the memory of RFID Tags are made. When referring to bits in Tag memory, the words "up" or "higher" generally refer to the Most Significant Bit (MSB) direction and the words "down" or "lower" to the Least Significant Bit (LSB) direction. For example, the binary representation of the<br><br>
decimal number seven (7) is 0111. Shifting each bit "up" or "higher" by one yields the decimal number fourteen (14), represented in binary as, 1110.<br>
[0073]       In one embodiment of the present invention, the command format is designed to support very low cost (VLC) Tags. The Reader performs extra work, allowing the Tags to be as simple and inexpensive as possible. This falls largely into two areas, dealing with timing uncertainty and dealing with limited long term memory in the Tags. However, other types of Tags (e.g., Class HI and higher Tags, such as battery powered devices with large memories) may also support these command formats (e.g., for compatibility reasons).<br>
[0074]      VLC, single-chip Tags typically have limited oscillator stability, since quartz crystals are cost and size prohibitive. In one embodiment, the Tags use the bit timing of commands to synchronize their internal clock, and need to be powered up and see one full command packet before they can start decoding further commands. Replies from these Tags are structured such that the Reader can interpret the information transmitted by the Tags at whatever clock rate the Tag is able to provide. This scheme is similar in concept to auto-synchronization schemes used in magnetic card or barcode Readers. [0075]      In one implementation, three classes of commands are provided, including basic commands, programming commands and data link commands. Basic commands provide object identification, sorting, inventory, etc. Programming commands support Tag data initialization and programming by the Tag manufacturers prior to Tagged items entering the supply chain. Data link commands provide a data link layer for class II and higher Tags.<br>
[0076]      One embodiment of the present invention uses Huffman encoded commands, for example, 18 bits for Query A/B (with 4 bit Q), 6 bits for QueryRep (last query repeat), 23 bits for ACK (including 16 bits of data), 13 bits for NAK (used Rarely, e.g., on data errors) and 13 bits or more for parameters of other commands. Thus, a QueryRep command is substantially shorter than a QueryA or a QueryB command. [0077]      Detailed examples of command structure in one implementation are described below. In the following examples of command structures, the command fields are<br><br>
generally listed in the order in which they are transmitted.<br>
[0078]      In one implementation, there are three types of inventory commands, query, ACK and NAK. A Query command starts a transaction, to which one or more Tags respond with a random 16-bit number. If the Reader successfully extracts a 16-bit number, it is sent back to the Tag for handshaking through an ACK command. A Tag only responds if the 16-bit number sent by the ACK command matches the number that the Tag sent. A Tag which has its 16-bit random number confirmed then replies with a prefix, its CRC (Cyclic Redundancy Check) and its ePC (Electronic Product Code). The Tag then transitions its internal state for that session from A to B (or from B to A) unless it gets a NAK. If it receives a NAK, it stays in the former state. [0079]       In one implementation, the Reader transmits spinup bits first. Within each field, the LSB (Least Significant Bit) is transmitted first. Every command is preceded by four Manchester zero bits to enable clock spinup. The clock spinup bits are followed by a Manchester high violation, command bits and parameters which vary from command to command. If the Tag clock setting mechanism is required to adjust the clock by more than 20%, or if the Tag does not see the spinup bits or Manchester high violation, the Tag ignores the command except for the purpose of improving its clock sync. If any command does not match the data pattern of a valid command, the Tag does not change its internal state, and does not modulate its backscatter. At the start of every command, the Tag refreshes the state memory for each of its four sessions. If the Tag is starting up from a power on reset, it enters the "Awaiting first query" state. [0080]      When the Tag is reset through "Power On," the Tag always enters into the state of "Awaiting first query."<br>
[0081]       When the clock is not synchronized, or the clock changed by more than 20%, or spinups or the Manchester violation have not been seen, or bad command bits or bad CRC data is received, a bad command is received at the Tag. When the starting state condition is in "Awaiting first query," "Ready," or "Selected," the Tag remains in the same state condition in response to a bad command. When the starting state condition is "Waiting for ACK" or "Acknowledged," a bad command causes the Tag to enter into the<br><br>
state of "Ready."<br>
[0082]       A QueryA command has parameters which include a session number, backscatter mode and the relative Tag to Reader data rate. It has a data payload which is a number Q. When a Tag receives the QueryA command, if it is in state A for that session, it responds with a probability of (1/2)Q, The Tag responds to each query with an independent (1/2)Q probability. In one embodiment, the reply from the Tag contains 16 random bits which the Tag also remembers until the next command. [0083]       For example, a QueryA command may include spinup bits (4-bit, "0000"), Manchester high violation (1-bit), Command bits (1-bit, "0"), Session number [S] (2-bit), A/B flag (1-bit, "0" for QueryA and "1" for QueryB), Backscatter mode [M] (2-bit), Backscatter relative rate [R] (2-bit) and Q parameter [Q] (4-bit). Bit masking can be used for large populations as described below.<br>
[0084]       In response to a QueryA command, a Tag: 1) sets the session number to [S]; 2) sets the state flag for query to "A"; 3) sets the Q parameter to [Q]; 4) sets the Backscatter mode to [M]; and, 5) sets the Backscatter Rate to [R]. The Tag computes a random number and makes random decision according to [Q]. In addition, if the Tag is in the starting state of "Selected" or "Acknowledged", the Tag switches to state B if it is in state A and to state A if it is in state B. Then, if the Tag is in state A, and the random decision is positive, the Tag replies with the random number and enters into the state of "Waiting for ACK"; otherwise, the Tag enters into the state of "Ready." [0085]      A QueryB command is symmetric to a QueryA command with respect to state A and B. A successful completion of a handshake cycle after a QueryB command places the Tag into state B for that session. The Tag reply to a QueryB command is in the same format as to a QueryA command.<br>
[0086]      For example, a QueryB command may include spinup bits (4-bit, "0000"), Manchester high violation (1-bit), Command bits (1-bit, "0"), Session number [S] (2-bit), A/B flag (1-bit, "0" for QueryA and "1" for QueryB), Backscatter mode [M] (2-bit), Backscatter relative rate [R] (2-bit) and Q parameter [Q] (4-bit). Bit masking can be used for large population as described below.<br><br>
[0087]       In response to a QueryB command, a Tag: 1) sets session number to [S]; 2) sets state flag for query to "B"; 3) sets the Q parameter to [Q]; 4) sets the Backscatter mode to [M]; and, 5) sets the Backscatter Rate to [R]. The Tag computes a random number and makes a random decision according to [Q], In addition, if the Tag is in the starting state of "Selected" or "Acknowledged", the Tag switches to state B if it is in state A and to state A if it is in state B. Then, if the Tag is in state B and the random decision is positive, the Tag replies with the random number and enters into the state of "Waiting for ACK"; otherwise, the Tag enters into the state of "Ready."<br>
[0088]       A QueryRep command repeats the last query with the same parameters. If the Tag has not seen a QueryA/B since power on reset, it does not respond to a QueryRep. This command is typically the most common command except in the complete atomic mode. The Tag reply to a QueryRep is in the same format as that for a QueryA or QueryB command.<br>
[0089]       For example, a QueryRep command may include spinup bits (4-bit, "0000"), Manchester high violation (1-bit), and, Command bits (1-bit, "0"). [0090]       In response to a QueryRep command, a Tag in the state of "Awaiting first query" does not reply and remains in the state of "Awaiting first query." A Tag in the state of "Acknowledged" or "Selected" does not reply, switches to state B if it is in state A and to state A if it is in state B, and enters into the state of "Ready". A Tag in the state of "Ready" or "Selected": 1) computes a random number and makes random decision according to [Q]; 2) checks if the state of the Tag matches the state flag of the query (e.g., state flag for query is "A" while the Tag is in state A or state flag for query is "B" while the Tag is in state B); and, 3) if the state of the Tag matches the state flag for query and the random decision is positive, replies with the random number and enters into the state of "Waiting for ACK". If the state of the Tag does not match the state flag for query or the random decision is negative, the Tag does not reply and enters into the state of "Ready."<br>
[0091]       In one embodiment, a reply from a Tag in response to a query command (e.g., QueryA, QueryB or QueryRep) contains 16-bit handshake data in the currently set<br><br>
backscatter mode, and at the currently set backscatter rate. (Both are set by a QueryA or QueryB command). They send a one, followed by a crowbar off for one bit period, 16 bits of random data, followed by another crowbar off period, and a trailing 1. [0092]      For example, a reply from a Tag in response to a query command may include TAGSPINUP (1-bit, "1"), High violation (Crowbar off for backscatter modulation bit period), Tag handshake (16-bit, Random data), High violation (Crowbar off for backscatter modulation bit period) and TAGTRAILER (1-bit, "1"). [0093]      An ACK command is sent by the Reader when it successfully extracts the handshake from a Tag reply. The ACK follows immediately after a Query command, without intervening commands except other ACKs. It also follows within time Tcoast (defined below), together considered as an atomic "command" of the protocol. If the ACK command received by the Tag does not contain the handshake that it replied to the immediately preceding Query, it does not reply.<br>
[0094]      For example, an ACK command may include spinup bits (4-bit, "0000"), Manchester high violation (1-bit), command bits (2-bit, "10") and Handshake data (16-bit, the data that was sent to the Reader in the immediately preceding query). [0095]      In response to an ACK command, a Tag in the starting state of "Awaiting first query" does not reply and remains in the state of "Awaiting first query." A Tag in the starting state of "Ready" or "Selected" does not reply and enters into the state of "Ready." A Tag in the starting state of "Waiting for ACK" or "Acknowledged" checks if the handshake data in the ACK command matches the random number sent to the Reader in the immediately preceding query. If there is a match, the Tag scrolls back ePC and CRC as a reply and enters into the state of "Acknowledged"; otherwise, the Tag enters into the state of "Ready."<br>
[0096]       A reply in response to an ACK command contains ePC and CRC. Tags matching their 16-bit handshake to that sent by the Reader reply in the currently set backscatter mode, and at the currently set backscatter rate. (Both are set by a QueryA or QueryB command). They respond by sending four (4) one (1) bits followed by a high violation for one Reader to Tag bit time, and all the identification data in the Tag starting<br><br>
at bit 0. Data sent by the Reader to the Tag may be of variable length. The data is followed by a crowbar off (high) violation, and four trailing ones (l)s. [0097]      For example, a reply from a Tag in response to an ACK command may include TAGSPINUP (4-bit, "111 1"), High violation (Crowbar off for backscatter modulation bit period), Tag data (variable size, ePC, CRC, recycling data, etc) High violation and TAGTRAELER (4-bit, "1111").<br>
[0098]       If a Reader does not receive a response to an ACK, the Reader transmits a NAK. If it receives a garbled response to an ACK, it may transmit a NAK or try an ACK again. The NAK (or any command other than a Query, a repeat ACK, or select) is used to signal a Tag that it has not been recorded, and should stay in its former (A or B) state. [0099]       In a query-ACK inventory, NAK is used only upon data error. The NAK command also ends the SELECTED state. There is no reply to a NAK.For example, a NAK command may include spinup bits (4-bit, "0000"), Manchester high violation (1-bit), and command bits (8-bit, "11000000").<br>
[00100]     In response to a NAC command, a Tag in the starting state of "Awaiting first query" does not reply and remains in the state of "Awaiting first query." A Tag in the starting state of "Ready", "Selected", "Waiting for ACK", or "Acknowledged" does not reply and enters into the state of "Ready".<br>
[00101]     A SetState command is used to restrict searches and for direct addressing and masking, including various set operations (e.g., union). Set operations are performed by using SetState commands. Masking would start by picking an unused session, and then setting all of the Tags to the desired state in that session by issuing a string of SetState commands. Tags whose state is changed respond with the ScrollID preamble, enabling applications which maintain an inventory by simply individually changing the state of each Tag previously known to be in the field, and using the presence or absence of a reply to update their inventory before executing a random inventory for new Tags. [00102]     For example, a SetState command may include spinup bits (4-bit, "0000") Manchester high violation (1-bit), command bits (8-bit, "11000001"), Session number [S] (2-bit), State flag (1-bit), Tag manipulation flags (2-bit, "00" for setting the state if the<br><br>
mask is matched and setting opposite state if not matched, "10" for setting the state if the mask is matched and doing nothing if not matched, "11" for setting the state if the mask is not matched and doing nothing if matched), Pointer (8-bit), Length (8-bit, Length of mask bits), Mask bits (variable size), and CRC8 (8-bit, calculated from the first command bit through the last mask bit).<br>
[00103]     In response to a SetState command, a Tag in the starting state of "Awaiting first query" remains in the state of "Awaiting first query." A Tag in the starting state of "Ready", "Selected", "Waiting for ACK", or "Acknowledged" enters into the state of "Ready". In response to the SetState ACK command, a Tag sets the session number to [S] and the AB state of the session to "A" or "B" depending on the mask. When the mask matches, the Tag sends a positive reply; otherwise, the Tag does not reply. If the state flag is "A" and the state manipulation flags are "00," the AB state of the session is set to "A" if the mask matches and to "B" if the mask does not match. If the state flag is "A" and the state manipulation flags are "01"), there is no action. If the state flag is "A" and the state manipulation flags are "10", the AB state of the session is set to "A" if the mask matches and there is no action if the mask does not match. If the state flag is "A" and the state manipulation flags are "11", the AB state of the session is set to "A" if the mask does not match and there is no action if the mask does not match. If the state flag is "B" and the state manipulation flags are "00," the AB state of the session is set to "B" if the mask matches and to "A" if the mask does not match. If the state flag is "B" and the state manipulation flags are "01"), there is no action. If the state flag is "B" and state manipulation flags are "10", the AB state of the session is set to "B" if the mask matches and there is no action if the mask does not match. If the state flag is "B" and the state manipulation flags are "11", the AB state of the session is set to "B" if the mask does not match and there is no action if the mask does not match.<br>
[00104]     Tags matching their data to the mask sent by the Reader reply in the currently set backscatter mode, and at the currently set backscatter rate (both are set by a QueryA or QueryB command). They send a one, followed by a crowbar off for one bit period, 16 bits of data, followed by another crowbar off period, and a trailing 1.<br><br>
[00105]     For example, a reply to a SetState command may include TAGSPINUP (1-bit, "1"), High violation (Crowbar off for backscatter modulation bit period), Tag confirm (16-bit, "0101010101010101"), High violation (Crowbar off for backscatter modulation bit period), and TAGTRAILER (1-bit, "1").<br>
[00106]     A SELECT command is an addressing command. The SELECTED state is held in volatile memory and is cleared at power on reset, and also cleared by the use of any Query command. Programming and class II or higher commands are divided into addressing (SELECT) and data exchange parts to allow the Tag communications hardware and registers used for addressing to be reused for reading and writing. The Tag is in the "Selected" state to execute KILL, ProgramID, VerifylD, LockID, and Read and Write. (Select is only used to Kill, Program and LockID in class I Tags). [00107]     For example, a SELECT command may include spinup bits (4-bit, "0000"), Manchester high violation (1-bit), command bits (8-bit, "11000010"), Session number (2-bit) and CRC8 (Calculated from the first command bit through the session number). [00108]     Tag addressing proceeds as follows:<br>
1)	Pick an open session.<br>
2)	Issue a mask for that session, specific enough to probably get only the desired<br>
Tag.<br>
3)	Search for the Tag using Query-ACK until you find the desired Tag<br>
(recognizing it by its complete ePC and CRC).<br>
4)	Issue the SELECT command.<br>
[00109]     In response to a SELECT command, a Tag in the starting state of "Awaiting first query" does not reply and remains in the state of "Awaiting first query." A Tag in the starting state of "Ready," "Selected," or "Waiting for ACK" does not reply and enters into the state of "Ready." A Tag in the starting state of "Acknowledged" provides a positive reply if the power is high enough for writing and a negative reply if the power is not high enough for writing, and enters into the state of "Selected." [00110]     Tags selected by the SELECT command reply in the currently set backscatter mode, and at the currently set backscatter rate (both are set by a QueryA or QueryB<br><br>
command). They send a one, followed by a crowbar off for one bit period, 16 bits of data, followed by another crowbar off period, and a trailing 1.<br>
[00111]     For example, a reply to a SELECT command may include TAGSPHNPUP (1-bit, "1"), High violation (Crowbar off for backscatter modulation bit period), Tag confirm (16-bit, "0000 0000 0000 0000 if power is not high enough to write, "0101 0101 0101 0101 if power is high enough to write), High violation (Crowbar off for backscatter modulation bit period) and TAGTRAILER (1-bit, "1").<br>
[00112]     A KILL command is addressed by the SELECTED address mode. Tags matching the kill code sent by the Reader in a [VALUE] field are deactivated and no longer respond to Reader queries. Any bits beyond the length of the kill code supported by the Tag are ignored except for the CRC calculation, and if all the bits in the Tag match the kill code, the kill command executes the appropriate kill. The KILL command may require higher field strengths from the Reader, and may therefore be a short-range operation. In one embodiment, the Reader transmits "l"s for 100 milliseconds, then 100 milliseconds of "0"s, followed by 15 "l"s and then another 100 milliseconds of "0"s after the kill code for the Tag to complete the command.<br>
[00113]     For example, a KILL command may include spinup bits (4-bit "0000"), Manchester high violation (1-bit), command bits (8-bit, "11000011"), Kill type (2-bit, "00" for complete kill (erase all data and permanently deactivate), "01" for preserve recycle (erase all but recycling field), "10" for cloak (set to unresponsive, but not erased)), Pointer (8-bit), Length (8-bit, Length of mask bits), Kill code (variable side), and CRC8 (8-bit, calculated over the bits from the first command bit through the full kill code, including any ignored bits of the kill code).<br>
[00114]     A Tag is first in the selected state for the kill command to be executed. Tags ignore kill code data beyond the length that it can handle. If the kill code matches the bits it does have, it executes kill. Longer kill code Tags are more secure and shorter kill code Tags may be less expensive to manufacture, but all Tags are compatible. [00115]     In response to a KILL command, a Tag in the starting state of "Selected" sets kill bits to DEAD without a reply and enters the "DEAD" state if the kill code is matched<br><br>
and the kill is successful. A Tag in the starting state of "Selected" sends a negative response and remains in the state of "Selected" if the kill code is matched but the kill is not successful. A Tag in the starting state of "Awaiting first query" does not reply and remains in the state of "Awaiting first query." A Tag in the starting state of "Ready," "Waiting for ACK "or" Acknowledged" does not reply and enters into the state of "Ready."<br>
[00116]     Only Tags which unsuccessfully attempt to execute a KILL command reply in the currently set backscatter mode, and at the currently set backscatter rate (both are set by a QueryA or QueryB command). They send a one, followed by a crowbar off for one bit period, 16 bits of data, followed by another crowbar off period, and a trailing 1. [00117]     For example, a reply to a KILL command may include TAGSPINUP (1-bit, "1"), High violation (Crowbar off for backscatter modulation bit period), Tag confirm (16-bit, "0000 0000 0000 0000 for Kill command failed), High violation (Crowbar off for backscatter modulation bit period), and TAGTRAILER (1-bit, "1"). [00118]     A Tag is SELECTED to respond to a ScrollMFG command. For example, a ScrollMFG command may include spinup bits (4-bit "0000"), Manchester high violation (1-bit), command bits (8-bit, "11000100") and CRC8 (8-bit, calculated over all the command bits).<br>
[00119]     In response to a ScrollMFG command, a Tag in the starting state of "Selected" sends a reply and remains in the state of "Selected." A Tag in the starting state of "Awaiting first query" does not reply and remains in the state of "Awaiting first query." A Tag in the starting state of "Ready," "Waiting for ACK "or" Acknowledged" does not reply and enters into the state of "Ready."<br>
[00120]     Selected Tags reply to the ScrollMFG command by sending back the preamble, and the following data, which is never allowed to be programmable. [00121]     For example, a reply to a ScrollMFG command includes Preamble (4-bit, "0000"), High Manchester violation, MANUFACTURER (16-bit, assigned by "authorizing agency"), MASK SET/ PRODUCT CODE (16-bit, manufacturer defined), DIE NUMBER (16-bit, manufacturer defined), CAPABILITY CODE (16-bit, assigned<br><br>
by "authorizing agency"), MEMORY SIZE (16, capability code dependent meaning), and<br>
CRC (16-bit, calculated over all the bits from the manufacturer to the last field<br>
transmitted). The ScrollMFG reply can optionally end at any field after the<br>
MANUFACTURER field.<br>
[00122]     Programming Commands use the same command structure and field<br>
definitions as the Basic Commands, but are typically issued only by a Tag programming<br>
device, or Programmer. A Tag Programmer may be similar to a Reader, with the<br>
exception that it can execute Programming Commands in addition to Basic Commands,<br>
in accordance with methods approved by Tag (and IC) manufacturers.<br>
[00123]     Programming Commands enable programming of the contents of the Tag<br>
memory, and verification of the contents of the Tag memory prior to locking the contents.<br>
[00124]     Manufacturers may define additional optional commands which are<br>
specifically used for manufacturing test only. For example, these commands may be<br>
required to have command codes in the range D7h to Dfh.<br>
[00125]     All Programming Commands are disabled once the Tag manufacturer has<br>
locked the Tag data contents. The specific timings for programming a Tag are memory<br>
technology dependent.<br>
[00126]     Tag programming is accomplished 16 bits at a time. Programming is typically<br>
allowed if the Tag has not been previously locked. If a Tag is not known to be cleared or<br>
of a type not needing an erase cycle before programming, EraselD is used before<br>
ProgramlD.<br>
[00127]     The data is sent to the Tag using the ProgramlD Command, where a [PTR]<br>
field is the memory row address to be programmed and a [VAL] field contains the 16 bits<br>
of data to be programmed into the selected memory row address.<br>
[00128]     Upon receipt of a valid ProgramlD Command, the Tag executes the<br>
appropriate internal timing sequences required to program memory.<br>
[00129]     For example, a ProgramlD Command may include spinup bits (4-bit "0000"),<br>
Manchester high violation (1-bit), command bits (8-bit, "11000101"), pointer (8-bit),<br>
Data Area (2-bit, "00" for CRC &amp; ePC, "01" for user data (none for class I), "10" for kill<br><br>
code), Length (8-bit, Length of data), ID to program (variable size), and CRC8 (8-bit,<br>
calculated over all fields from the first command bit to the end of the ID).<br>
[00130]     In response to a ProgramlD command, a Tag in the starting state of "Selected"<br>
writes data if it is not locked and remains in the state of "Selected." A Tag in the starting<br>
state of "Selected" sends a positive reply if successful and a negative reply if<br>
unsuccessful. A Tag in the starting state of "Awaiting first query" does not reply and<br>
remains in the state of "Awaiting first query." A Tag in the starting state of "Ready,"<br>
"Waiting for ACK "or" Acknowledged" does not reply and enters into the state of<br>
"Ready."<br>
[00131]     Tags executing the ProgramlD command reply in the currently set backscatter<br>
mode, and at the currently set backscatter rate. (Both are set by a QueryA or QueryB<br>
command). They send a one, followed by a crowbar off for one bit period, 16 bits of<br>
data, followed by another crowbar off period, and a trailing 1.<br>
[00132]     For example, a reply to a ProgramlD command may include TAGS PINUP (1-<br>
bit, "1"), High violation (Crowbar off for backscatter modulation bit period), Tag confirm<br>
(16-bit, "0000 0000 0000 0000 for failed to write, "0101 0101 0101 0101 for successful<br>
write), High violation (Crowbar off for backscatter modulation bit period), and<br>
TAGTRAILER (1-bit, "1").<br>
[00133]     Tag Erasing may be accomplished 16 bits at a time. Erasing the ED is only<br>
allowed if the Tag has not been previously locked. Upon receipt of a valid EraselD<br>
Command, the Tag executes the appropriate internal timing sequences required to<br>
program memory.<br>
[00134]     For example, an EraselD Command may include spinup bits (4-bit "0000"),<br>
Manchester high violation (1-bit), command bits (8-bit, "11000111"), and CRC8 (8-bit,<br>
calculated over all fields from the first command bit to the end of the ID).<br>
[00135]     In response to an EraselD command, a Tag in the starting state of "Selected"<br>
tries to erase ePC and CRC if it is not locked and remains in the state of "Selected." A<br>
Tag in the starting state of "Selected" sends a positive reply if successful and a negative<br>
reply if unsuccessful. A Tag in the starting state of "Awaiting first query" does not reply<br><br>
and remains in the state of "Awaiting first query." A Tag in the starting state of "Ready,"<br>
"Waiting for ACK "or" Acknowledged" does not reply and enters into the state of<br>
"Ready."<br>
[00136]     Tags executing the EraselD command reply in the currently set backscatter<br>
mode, and at the currently set backscatter rate. (Both are set by a QueryA or QueryB<br>
command). They send a one, followed by a crowbar off for one bit period, 16 bits of<br>
data, followed by another crowbar off period, and a trailing 1.<br>
[00137]     For example, a reply to an EraselD command may include TAGSPINUP (1-<br>
bit, "1"), High violation (Crowbar off for backscatter modulation bit period), Tag confirm<br>
(16-bit, "0000 0000 0000 0000 for failed to erase, "0101 0101 0101 0101 for successful<br>
erase), High violation (Crowbar off for backscatter modulation bit period), and<br>
TAGTRAILER (1-bit, "1").<br>
[00138]     A VerifylD command scrolls out the entire contents of memory, including<br>
protected fields. The Tag does not respond to VerifylD after it is locked. The Tag is<br>
SELECTED before VerifylD can be executed.<br>
[00139]     For example, a VerifylD command may include spinup bits (4-bit "0000"),<br>
Manchester high violation (1-bit), command bits (8-bit, "11001000") and CRC8 (8-bit,<br>
calculated over all the command bits).<br>
[00140]     In response to an EraselD command, a Tag in the starting state of "Selected"<br>
replies and remains in the state of "Selected", if it is not locked. A Tag in the starting<br>
state of "Selected" does not reply and enters into the state of "Ready," if it is not locked.<br>
A Tag in the starting state of "Awaiting first query" does not reply and remains in the<br>
state of "Awaiting first query." A Tag in the starting state of "Ready," "Waiting for ACK<br>
"or" Acknowledged" does not reply and enters into the state of "Ready."<br>
[00141]     Tags matching their 16-bit handshake to that sent by the Reader reply in the<br>
currently set backscatter mode, and at the currently set backscatter rate. (Both are set by<br>
a QueryA or QueryB command). They respond by sending four (4) one (1) bits followed<br>
by a high violation for one Reader to Tag bit time, and all the identification data in the<br>
Tag starting at bit 0. Data sent by the Reader to the Tag may be of variable length. The<br><br>
data is followed by a crowbar off (high) violation, and four trailing ones (l)s.<br>
[00142]     For example, a reply to a VerifylD command may include TAGSPINUP (4-<br>
bit, "1111"), High violation (Crowbar off for backscatter modulation bit period), Tag data<br>
(variable size, all Tag data contents, including protected fields), High violation (Crowbar<br>
off for backscatter modulation bit period) and TAGTRAUJBR (4-bit, "1111").<br>
[00143]     A LockID command is used to lock the identification (CRC and ePC) portions<br>
of a Tag's memory before it leaves a controlled supply channel. The Tag is SELECTED<br>
before LockID can be executed.<br>
[00144]     For example, a LockID command may include spinup bits (4-bit "0000"),<br>
Manchester high violation (1-bit), command bits (8-bit, "11001001") and CRC8 (8-bit,<br>
calculated over all the command bits).<br>
[00145]     In response to a LockID command, a Tag in the starting state of "Selected"<br>
tries to lock ePC and CRC, if it is not locked. A Tag in the starting state of "Selected"<br>
remains in the state of "Selected" and provides a positive response if successful and a<br>
negative response if unsuccessful. A Tag in the starting state of "Awaiting first query"<br>
does not reply and remains in the state of "Awaiting first query." A Tag in the starting<br>
state of "Ready," "Waiting for ACK "or" Acknowledged" does not reply and enters into<br>
the state of "Ready."<br>
[00146]     Tags selected by the select command execute the LockID command and then<br>
reply in the currently set backscatter mode, and at the currently set backscatter rate (both<br>
are set by a Query A or QueryB command). They send a one, followed by a crowbar off<br>
for one bit period, 16 bits from the table below, followed by another crowbar off period,<br>
and a trailing 1.<br>
[00147]     For example, a reply to a LockID command includes TAGSPINUP (1-bit,<br>
"1"), High violation (Crowbar off for backscatter modulation bit period), Tag confirm<br>
(16-bit, "0000 0000 0000 0000 for fail to LockID, "0101 0101 0101 0101 for Command<br>
successful), High violation (Crowbar off for backscatter modulation bit period), and<br>
TAGTRAILER (1-bit, "1").<br>
[00148]     Class II and higher Tags use the same singulation method and identification<br><br>
method as the class I Tags. In addition, they may have additional read/write memory,<br>
security features, sensors, etc. Class II Tags may also have a battery to realize sensor<br>
logging, for example.<br>
[00149]     Class III and above Tags are defined to have battery-assisted communications.<br>
Class HI and above Tags respond to class I commands in a low power passive mode, or at<br>
longer ranges they use a key transmission to go to the battery assist communications<br>
mode. The wakeup key for class three and above Tags is described below. This allows<br>
them to avoid using their battery assist except for long-range exchanges which are<br>
specifically directed at them, reducing the use of battery power.<br>
[00150]     Communications with class II and above Tags are standardized into a handle<br>
based I/O data link. Handles are issued by an "authorizing agency" for a specific<br>
purpose, and together with the SCROLLMFG information, can be used to deduce and<br>
exercise the capabilities of a Tag. A few example capability codes and corresponding<br>
handles include:<br>
00XX XXXX XXXX XXXX for handles and capabilities by look up table;<br>
01XX XXXX XXXX XXXX for handles and capabilities by subfields;<br>
01XX XXXX XXXX 0000 for no memory;<br>
01XX XXXX XXXX 0001 for bit wide memory, 0-7FFFFF memory address in bits,<br>
Read LEN bits starting at given address, Write LEN bits at given address; 01XX XXXX XXXX 0010 for Byte wide memory, 0-7FEFFF Memory addresses in<br>
bytes, Read LEN Bits starting at given address, Write LEN bits at given address;<br>
01XX XXXX XXXI XXXX for Scratchpad type Memory, such as 1) 1-7FFFFF<br>
Memory addresses, Read LEN Bits starting at given address, Write address and<br>
LEN data bits to scratch pad, or 2) FFFFFF, Verify scratchpad data and address,<br>
or 3) FFFFFE, Write scratch pad to memory; 01XX XXXX 000X XXXX for no security; 01XX XXXX 001X XXXX for Key exchange security, such as 1) FFFFFD, Write<br>
security token, LEN bits long, or 2) FFFFFC, Read security token; 01XX XX00 XXXX XXXX for No temperatures;<br><br>
01XX XX01 XXXX XXXX for Temperature interval recorder, such as 1) FFFFFFB Interval, Set interval in seconds, Read current interval, or 2) FFFFFFA, Set number of temperatures to read at a time, or 3) FFFE 0000 0000 - FFFE FFFF FFFF, Read temps, Handle- FFFE00OOO0O 0 intervals into past.<br>
[00151]     A READ command is the basic command for fetching data from the class II or higher Tag. It is addressed only by the SELECTED addressing mode, and uses a 24 bit PTR field which is a read address or handle, and a LEN field which is the number of bits to read, or is used as a second parameter whose meanings are to be determined by the handle.<br>
[00152]     For example, a READ command may include spinup bits (4-bit "0000"), Manchester high violation (1-bit), command bits (8-bit, "11010000"), Read handle (24-bit, Meaning defined by capability code), Data Area (2-bit, "00" for CRC &amp; ePC, "01" for user data (none for class I), "10" for kill code), Length (8-bit, length of data to read), and CRC8 (8-bit, calculated over all fields from the first command bit to the end of length).<br>
[00153]     The data returned by the Tag is determined by the capacity code and the handle used. It may contain a CRC.<br>
[00154]     For example, a reply to a read command includes TAGSPINUP (1-bit, "1"), High violation (Crowbar off for backscatter modulation bit period), Data (variable size data), High violation (Crowbar off for backscatter modulation bit period) and TAGTRAILER (1-bit, "1").<br>
[00155]     A WRITE command is the basic command for writing data to the class II or higher Tag. It is addressed only by the SELECTED addressing mode, and uses a 24-bit PTR field which is a read address or handle, a 16-bit LEN, and a variable length data field whose length is determined by the [LEN] parameter. [00156]     For example, a WRITE command includes spinup bits (4-bit "0000"), Manchester high violation (1-bit), command bits (8-bit, "11010001"), Write handle (24-bit, meaning defined by capability codes), Length (8-bit, length of data (granularity<br><br>
defined by handle &amp; capability codes)), Data to write (variable size) and CRC8 (8-bit). [00157]     Tags selected by the select command execute the WRITE command, and reply in the currently set backscatter mode, and at the currently set backscatter rate. (Both are set by a QueryA or QueryB command). They send a one, followed by a crowbar off for one bit period, 16 bits from the table below, followed by another crowbar off period, and a trailing 1.<br>
[00158]     For example, a reply to a WRITE command may include TAGSPINUP (1-bit, "1"), High violation (Crowbar off for backscatter modulation bit period), Tag confirm (16-bit, "0000 0000 0000 0000 for write failed, "0101 0101 0101 0101 for write successful), High violation (Crowbar off for backscatter modulation bit period), TAGTRAILER (1-bit, "1").<br>
[00159]     One embodiment of the present invention includes the use of the two-state symmetry of the protocol, which has advantages over an alternative ready-quiet protocol as is known in the art. The symmetric protocol effectively has less state dependence by symmetrizing quiet-ready states into two symmetrical halves, the State A and State B of the protocol.<br>
[00160]     The symmetry substantially increases the performance over ready-quiet protocols in cases where Tags have been inventoried and put into a quiet state, and it is desired to inventory them again, either from a different Reader station, or as part of a continuous inventory to monitor Tags being removed over time. [00161]     In the case of a ready-quiet protocol, the Tags, once placed in the quiet state, are touched by a talk command before they can participate in an inventory. Several talk commands can be issued before an inventory, but there is no guarantee that a Tag will receive the talk command if multi-path interference is high, the transmission frequency is wrong, or if the Tag is out of range of the Reader at that point in time. By eliminating the need to see a talk command, a Tag can be counted during a single "lucky" time or position, extending the effective reliable range of the protocol.<br>
[00162]     Using a timeout for a persistent quiet state is an alternative approach, but the manufacture of a Tag which has a tightly controlled persistence time is difficult. Also,<br><br>
for example, a 10 second timeout might be too short a time to inventory a large number of Tags, while a 30 second timeout might be long enough to interfere with multiple Readers tracking an item on a trajectory or catching a shoplifter in the act of destroying a Tag or putting the item into a shielded bag and walking away with an item. [00163]     One recommended implementation of the Tag is to supply a persistent node, which maintains its state for at least twenty seconds in the absence of power. Assuming that the persistent node decays to the zero (0) state, [0] encodes state A, and [1] encodes state B. State B expires with time into the state A. There is no upper bound on the time that state B persists, but it is not permitted to be in states where it is randomly powering up into state A or state B. The suggested implementation is to refresh the persistent node at some time during every command, weather or not the Tag is addressed by the command.<br>
[00164]     Readers would start by doing an inventory as described above, using QueryA or QueryRep commands, and ACKs. After no further Tags are responding, the Reader would continue to do high-level (e.g., addressing many tags using bit masking as described above) Query commands to explore any uncounted Tags. Note that a Tag in state A would be counted even if it were only powered for a brief time, just long enough to see a command to synchronize its clock, a QueryA, an ACK, and one subsequent command. At this point all Tags which had been inventoried would be in state B. After a predetermined amount of time, a new inventory would be done, in the same way, but using QueryB. There is no need to do any separate talk or wake commands, as all Tags that are powered at that moment would have been placed into state B already. After this inventory, all inventoried Tags are in the state A, and the Reader can continue to do high level QueryA commands for a while. Then an A inventory could start again, with no need to issue talk commands, so there is no possibility that a talk command is missed. [00165]     Any Tag that is continuously in the field is counted in every inventory, both the A and B flavors. Any Tag that enters the field is counted, in the worst case, in the second inventory after it enters the field, the same worst case time as if a ready-quiet protocol was used, even if a talk command at the beginning of each inventory was<br><br>
guaranteed to be received in the quiet-talk type protocol.<br>
[00166]    A persistent quiet capability in an RFID system provides consistency in counting Tags near the edge of a Reader's range when Tags are moving through the Reader's field. For Tags at the edge of the range, as the frequencies are changed and/or multi-path interference changes as the Tag or other objects are moved in the Reader field, the power available to the Tag fluctuates and may only be sufficient to power the Tag for brief periods of time. Persistent sleep allows the majority of Tags to be counted quickly, and then for Q=0 Queries to be repeated, seeking out Tags which are only intermittently powered. The symmetrical commands extend this comprehensive counting capability to Tags that have just been inventoried and put into the quiet state and would therefore potentially be missed if they did not receive a wakeup command. It is also useful as part of a continuous inventory process.<br>
[00167]     This approach prevents the Tags from ever entering a state where they are hard to count, as they would be in the quiet state of a ready-quiet protocol. It may seem that the quiet state is not hard to get out of, because a talk command can be used. However, if a Tag is unknown to the Reader, only a high level talk command potentially wakes it up, and a high level talk command would wake up all the other Tags as well. It may seem that if a Tag is in a quiet state, it has been recently inventoried anyway, but if a different Reader station did that inventory, or if a continuous inventory is desired, then the Tag needs to be inventoried again. If a Tag is in the quiet state in a ready-quiet protocol, it is touched twice, at two widely separated times and possibly two frequencies. It needs to be active once when the whole field of Tags is awakened, and then again later when that particular Tag is to be inventoried. Needing two events to happen greatly impacts the probability of counting Tags which are on the margin of the RF range and are only intermittently powered, and that is avoided by using the symmetric protocol. Additionally, time is saved by not requiring additional talk commands to be issued. [00168]     In one embodiment of the present invention, the RF Transport Layer is designed for UHF operation, although other alternative operations can also be used. The Tag-to-Reader and Reader-to-Tag link is defined as half-duplex. Readers initiate<br><br>
communication with Tags by sending a command sequence. The Reader then provides a reply period for the Tag by transmitting an un-modulated carrier while listening for a reply from the Tag. The Tags are not expected to be able to detect Reader modulation while they are replying. The RF transport layer may use the following bands: 902- 928 MHz and 2400.0-2483.5 MHz in North American, 869.4-869.65 MHz and 865.6-867.6 MHz in European, and UHF bands near 2450 MHz. These UHF bands have features including: high speed (up to 160 Kbps in North America) Reader-to-Tag system data rate; 320 kbps or faster Tag-to-Reader system data rate; consistent operation with high hit rates at ranges of 2 meters or more under typical conditions; relatively small Tag and Reader antennas; and North American bands are wide enough to permit significant frequency hopping.<br>
[00169] Readers may be in one of three available states: OFF (emitting no RF energy), CW (emitting RF energy at some power level without amplitude modulation), and Active (emitting RF energy with amplitude modulation).<br>
[00170]     Figure 10 illustrates an embodiment of Reader-to-Tag Modulation. In the Active state, the Reader-to-Tag link makes use of split phase Manchester encoding with a minimum modulation depth of 30%. A data one (1) may be encoded by a high RF period followed by a low RF period. A data zero (0) may be encoded by a low RF period followed by a high RF period. Modulation shape, depth and rate of modulation are variable within the limits described below. Tags may adjust their timing over a range of modulation rates to lock to Reader transmissions automatically. The falling edges are held to a low amount of jitter from their nominal times as defined by the Manchester coding. The fall times can vary from their nominal value to accommodate a RF duty cycle.<br>
[00171] The modulation parameters in general are illustrated in Figure 11. It will be understood that specific values of pulse modulation parameters can be a function of the local regulatory environment. For example, pulse modulation parameters may include:<br>
To: Elemental Clock Cycle period. Time for a single bit sent from Reader to Tag.<br>
Tr: Rise time of modulation envelope, 10% to 90% of Modulation amplitude<br><br>
variation. T Fall time of modulation envelope, 90% to 10% of Modulation amplitude<br>
variation T fwhrs:Pulse width of modulation envelope measured at 50% of Modulation<br>
amplitude variation.<br>
Mod: Amplitude variation of modulated carrier. Ripple: Peak to Peak variation in modulation overshoot and undershoot at edges<br>
of intended modulation.<br>
Dmoc Peak-to-Peak variation in modulation depth from intended value. :T0T0 Master Clock Interval Tolerance, Basic accuracy of Reader signaling. TCW: Minimum CW time immediately before a command. Tcoast: Maximum Time duration between EOF and the next command, to ensure<br>
that the Tag clock is sufficiently accurate to decode the next command. [00172]     In one implementation, for Reader modulation sequences, the Reader clock may be stable to within 1% over the length of a transaction. All other "Elemental Clock Cycle timings are proportional to the modulation clock frequency To. In one<br>
implementation, modulation parameters have the following values, in which all<br>
times and frequencies scale with To, except as noted.<br>
To: Master Clock Interval (6 us to 24 us)<br>
TOTOL: Master Clock Interval Tolerance ( 0.1% Maximum)<br>
DR: Data Rate (I/To)<br>
Trlsejitter: Maximum jitter from nominal in falling edges (0.0l*To)<br>
DutyCycle: RF high period duty cycle (=50% or &gt;50%)<br>
MOD: Modulation Depth (30% minimum)<br>
Tf: Max fall Time (1/4 To)<br>
Tr: Max Rise Time (1/4 To)<br>
Ripple: Ripple (10 % pp)<br>
TCW: Minimum CW time preceding any command, may overlap with response<br><br>
CW interval (4 x To) Tcoast :Time duration between EOF and the next command (5 ms max., does not<br>
scale with To)<br>
[00173]     Figure 12 illustrates an example of Reader to Tag modulation encoding. In one implementation, all transactions begin with a minimum CW period preceding each command to allow the Tag to locate the beginning of the command. All commands start with four spinup bits to synchronize the Tag clocks. During the Data Modulation of a command, Tags maintain their clock phase by reference to the falling edges of the Reader to Tag data modulation, which are held to low time jitter. The bit period time, To, determines the Reader-to-Tag data rate. After the last pulse, the Tag is ready to receive the next command after the minimum CW time, and be able to decode a command received within a Tcoast interval.<br>
[00174]     In order for the Tag to successfully decode the next command, the Reader starts the next transaction within the Tcoast interval. This restriction does not apply when the carrier has been turned off for sufficient time for the Tag to loose DC power, as the Tag re-synchronizes at the next power up. If the Tag clock frequency is adjusted by more than 20% in a spin up, the Tag does not respond to that command. [00175]     Figure 13 illustrates data modulation timing for data "0," "1" and a Manchester high violation. Data Modulation Timing, Tdatao, for Reader-to-Tag clocking when data = "0," is encoded by an RF low period followed by a high period. Data Modulation Timing, Tdaml, for Reader-to-Tag clocking when data = "1", is encoded by an RF high period followed by an RF low period. Data Modulation Timing, Tdatal, for Reader-to-Tag clocking for the Manchester high violation, is encoded by two consecutive RF high periods.<br>
[00176]     The Reader may optionally shorten the time between commands below that required for a response. The Reader may listen for a Tag reply during the reply period, and if a reply has NOT been started by a Tag prior to expiration of a time (TTagscrollDel+2*To), may shorten the duration for that reply interval.<br><br>
[00177]     Tags reply to Readers by means of modulating their backscatter between two states. These two states may modulate the backscatter in phase or amplitude, or both. [00178]     One of these states is assumed, but not required, to impair the energy gathering ability of the Tag, and is referred to in this description as the "crowbar on" state. It is assumed that the backscatter state of the Tag is "crowbar off until the start of backscatter modulation. As many Tags need to return to the "crowbar off' state at the end of backscatter modulation, all Tags are required to return their backscatter state to the state that they were in prior to starting a backscatter reply. This transition occurs after the end of the last backscatter transition transmitted (to the crowbar on state), at a time equal to that of the smallest feature size in the backscatter modulation mode. [00179]     The Tag-to-Reader modulation is selected by a [MODULATION] field of a Reader to Tag command, and is either FM0 in the case of [MODULATION]=0, or F2F, in the case of [MODULATION]=1, or an as yet undefined high frequency mode for [MODULATION]=3. All Tags may be required to implement all three forms of encoding. Readers may implement one or more decoders. The primitive for F2F encoding is the same, with the same timing, as FM0, but two FM0 primitives are used to encode each bit of F2F. A F2F encoder can be implemented using a FM0 encoder preceded by a bit inverter and encoding twice for each bit in succession. [00180]     In FM0, Tags reply to Reader commands with backscatter modulation. There is a change of backscatter state between each bit period, and a 0 bit has an additional change of backscatter state at the center of the bit time. The nominal data rate for Tag to Reader is four times the Reader to Tag Rate, but may vary up to 10% over an 80-bit response window due to oscillator drift in the Tag. It is anticipated that FM0 is used in cases where the backscatter noise environment can be controlled (i.e. shielding around fluorescent lamps, etc.).<br>
[00181]     In F2F, Tags reply to Reader commands with backscatter modulation that follows a four (4)-interval bit cell encoding scheme. Two (2) transitions are observed for a zero (0) and four (4) transitions are observed for a one (1) during a Bit Cell. The nominal data rate for Tag to Reader is twice the Reader to Tag Rate, but may vary up to<br><br>
10% over an 80-bit response window due to oscillator drift in the Tag. [00182]     Some examples of the Tag to Reader modulation parameters are listed below. To: Reader to Tag Master Clock Interval;<br>
Tragbitcell: Tag to Reader bit cell interval (To/4 for FMO, To/2 for F2F); Tag Data Rate: Tag to Reader Nominal Data Rate (4/T0 for FMO, 2/T0 for F2F);<br>
TTgscrollDe: Reply delay from end of command to start of Tag ScrollID Reply (2 x To); TRaglet : Reply delay from end of command to start of Tag ID Reply (2 x To);<br>
: Tag to Reader reply duration for 8+16+96 bit ScrollID reply (TTagbitcell x 120 bits);<br>
Tragbitcell: Tag to Reader bit cell interval variation at last bit of 120 bit ScrollID reply (10 % max);<br>
T cost: Time duration between EOF and the next command (5 ms max.).<br>
[00183]     The delay from the end of data to the start of a reply to a ScrollID or VerifyED Command, TtagscrollDel, is illustrated in Figure 14. The duration of a ScrollID Reply,<br>
TTagreplyNoma:  is also illustrated in Figure 14. The variation in the bit cell duration, avTTagbiteeelk, is illustrated in Figure 15. [00184]     Tag-to-Reader bit cell encoding is illustrated in Figure 16. In FMO encoding, the state of the Tag backscatter is changed at the edge of each bit, and an additional change of state occurs in the middle of bit intervals which correspond to a "0" data bit. The crowbar starts in the off state, and makes its first transition to the on state at the beginning of the first data bit. A final bit interval transition is inserted at the end if it is needed to leave the modulation in the, high state (not in the crowbar state), at the later edge of potentially one extra bit time.<br>
[00185]     In F2F encoding, the Tag backscatter is modulated by a selection of one of two symbols per bit cell. Under this encoding scheme there are always transitions in the middle of a bit and unlike Manchester encoding, the sense of zeros and ones are<br><br>
maintained when the code is inverted. Figure 17 illustrates this inversion. [00186]     It will be apparent from this description that aspects of the present invention may be embodied, at least in part, in software. That is, the techniques may be carried out in a computer system or other data processing system in response to its processor, such as microprocessor 113 or controller 207, executing sequences of instructions contained in a memory, such as memory 111 or memory 319. In various embodiments, hardwired circuitry may be used in combination with software instructions to implement the present invention. Thus, the techniques are not limited to any specific combination of hardware circuitry and software not to any particular source for the instructions executed by the data processing system. In addition, throughout this description, various functions and operations are described as being performed by or caused by software code to simplify description. However, those skilled in the art will recognize what is meant by such expressions is that the functions result from execution of the code by a processor, such as the microprocessor 113 or the controller 207.<br>
[00187]     A machine-readable medium can be used to store software and data which when executed by a data processing system causes the system to perform various methods of the present invention. This executable software and data may be stored in various places including, for example, memory 111 or memory 319. Portions of this software and/or data may be stored in any one of these storage devices. [00188]     Thus, a machine-readable medium includes any mechanism that provides (i.e., stores and/or transmits) information in a form accessible by a machine (e.g., a computer, network device, personal digital assistant, manufacturing tool, any device with a set of one or more processors, etc.). For example, a machine-readable medium includes recordable/non-recordable media (e.g., read only memory (ROM), random access memory (RAM), magnetic disk storage media, optical storage media and flash memory devices, etc.), as well as electrical, optical, acoustical or other forms of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.). [00189]     Some of the abbreviations used in this description are listed below. [00190]     AM: Amplitude Modulation;<br><br>
[00191]     CRC: Cyclic Redundancy Check;<br>
[00192]     CW: Continuous Wave;<br>
[00193]     kbps: kilobits per second;<br>
[00194]     LSB: Least Significant Bit;<br>
[00195]     ms: milliseconds (10-3 seconds);<br>
[00196]     MHz: megahertz (106 Hertz);<br>
[00197]     MSB: Most Significant Bit;<br>
[00198]     RAM: Random Access Memory;<br>
[00199]     RF: Radio Frequency;<br>
[00200]     RFID: Radio Frequency Identification;<br>
[00201]     RTF: Reader Talks First;<br>
[00202]     us: microseconds (10-6 seconds);<br>
[00203]     VLC: Very Low Cost; and<br>
[00204]     In the foregoing specification, the invention has been described with reference<br>
to specific exemplary embodiments thereof. It will be evident that various modifications<br>
may be made thereto without departing from the broader spirit and scope of the invention<br>
as set forth in the following claims. The specification and drawings are, accordingly, to<br>
be regarded in an illustrative sense rather than a restrictive sense.<br><br><br>
 CLAIMS<br>
What is claimed is:<br>
1.	A method to query a plurality of Tags, the method comprising:<br>
broadcasting one or more first query commands including a first value of a<br>
probability parameter, the first value of the probability parameter indicating a first probability of reply, wherein each of the plurality of Tags randomly determines whether or not to reply; and detecting a reply in response to the first query command.<br>
2.	The method of claim 1, further comprising:<br>
broadcastmg, responsive to a determination that there is no reply to the one or<br>
more first query commands, a second query command including a second value of the probability parameter, the second value of the probability parameter indicating a second probability of reply which is greater than the first probability of reply.<br>
3.	The method of claim 1, further comprising:<br>
broadcasting, responsive to a determination that there is no legible reply to the one or more first query commands, a second query command including a second value of the probability parameter, the second value of the probability parameter indicating a second probability of reply which is less than the first probability of reply.<br>
4.	The method of claim 1, wherein the first value of the probability parameter is an<br>
integer Q, the first probability of reply for one of the plurality of Tags is<br>
substantially equal to pQ, and p is less than 1.<br><br>
5.	The method of claim 4, wherein p is substantially equal to 0.5.<br>
6.	The method of claim 1, wherein the first probability of reply for a first one of the<br>
7.	plurality of Tags is different from the first probability of reply for a second one of<br>
8.	the plurality of Tags.<br>
9.	The method of claim 1, wherein the first query command further includes a state<br>
10.	flag indicating a first state, wherein Tags in a second state do not reply to the first<br>
11.	query command and Tags in the first state reply to the first query command<br>
12.	randomly according to the first value of the probability parameter.<br>
13.	The method of claim 7, further comprising:<br>
broadcasting a second query command including a second value of the probability parameter and a state flag indicating the second state, wherein Tags in the first state do not reply to the second query command and Tags in the second state reply to the second query command randomly according to the second value of the probability parameter; and<br>
detecting a reply in response to the second query command.<br>
9.	The method of claim 8, wherein the first and second query commands are<br>
10.	symmetric with respect to the first and second states.<br>
11.	The method of claim 7, further comprising:<br>
sending, responsive to a legible reply to the first query command, wherein the<br>
legible reply includes first handshaking data, a second command including the first handshaking data; and<br>
receiving Tag identification data as a reply to the second command.<br><br>
11.	The method of claim 10, further comprising:<br>
sending a command to indicate an error in receiving the Tag identification data when the Tag identification data is not received successfully.<br>
12.	The method of claim 1, further comprising:<br>
broadcasting a second query command without including a value of the probability parameter.<br>
13.	The method of claim 12, wherein<br>
the first query command includes first values of a plurality of parameters<br>
including the first value of the probability parameter; and the second query command does not include values of the plurality of parameters.<br>
14.	The method of claim 13, wherein the second query command is substantially<br>
15.	shorter than the first query command.<br>
16.	A method for a Tag to respond to queries from a Reader, the method comprising:<br>
17.	receiving from the Reader a first query command including a first value of a<br>
probability parameter; and<br>
deciding randomly whether or not to reply to the first query command, wherein a probability of reply is determined by the first value of the probability parameter.<br>
16.	The method of claim 15, further comprising:<br>
sending, responsive to a random decision to reply, a reply with first handshaking data.<br><br>
17.	The method of claim 16, wherein the first handshaking data is a random number<br>
18.	generated in response to the first query command.<br>
19.	The method of claim 15, wherein the first value of the probability parameter is an<br>
20.	integer Q, the first probability of reply is substantially equal to pQ, and p is less<br>
21.	than 1.<br>
22.	The method of claim 18, wherein p is substantially equal to 0.5.<br>
23.	The method of claim 15, wherein the first query command further includes a state<br>
24.	flag indicating a first state, and wherein the Tag does not reply to the first query<br>
25.	command if the Tag is in a second state, and the Tag replies to the first query<br>
26.	command randomly according to the first value of the probability parameter if the<br>
27.	Tag is in the first state.<br>
28.	The method of claim 20, further comprising:<br>
receiving a second query command including a second value of the probability parameter and a state flag indicating the second state; and<br>
deciding randomly whether or not to reply to the second query command, wherein a probability of reply is determined by the second value of the probability parameter if the Tag is in the second state, and wherein the Tag does not reply to the second query command if the Tag is in the first state.<br>
22.	The method of claim 21, wherein the Tag processes the first and second query<br>
commands with symmetry with respect to the first and second states.<br><br>
23.	The method of claim 20, further comprising:<br>
sending, responsive to a random decision to reply, a first reply with first<br>
handshaking data; and sending, responsive to receiving from the Reader a second command including<br>
the first handshaking data, a second reply with Tag identification data.<br>
24.	The method of claim 23, further comprising:<br>
switching, responsive to receiving a query command after sending the second reply, from the first state to the second state, wherein after receiving a command indicating an error in receiving the Tag identification data at the Reader, the Tag remains in the first state if a query command is received after the command indicating the error.<br>
25.	The method of claim 15, further comprising:<br>
receiving a second query command which does not include a value of the<br>
probability parameter; and deciding randomly whether or not to reply to the second query command, wherein<br>
a probability of reply is determined by the first value of the probability<br>
parameter.<br>
26.	The method of claim 25, wherein<br>
the first query command includes first values of a plurality of parameters including the first value of the probability parameter;<br>
the second query command does not include values of the plurality of parameters; and<br>
the Tag processes the second query command according to the first values of the plurality of parameters.<br><br>
27.	The method of claim 26, wherein the second query command is substantially<br>
28.	shorter than the first query command.<br>
29.	A Reader to query a plurality of Tags, the Reader comprising:<br>
means for broadcasting one or more first query commands including a first value of a probability parameter, the first value of the probability parameter indicating a first probability of reply, wherein each of the plurality of Tags randomly determines whether or not to reply; and<br>
means for detecting a reply in response to the first query command.<br>
29.	The Reader of claim 28, further comprising:<br>
means for broadcasting, responsive to a determination that there is no reply to the one or more first query commands, a second query command including a second value of the probability parameter, the second value of the probability parameter indicating a second probability of reply which is greater than the first probability of reply.<br>
30.	The Reader of claim 28, further comprising:<br>
means for broadcasting, responsive to a determination that there is no legible<br>
reply to the one or more first query commands, a second query command with a second value of the probability parameter, the second value of the probability parameter indicating a second probability of reply which is less than the first probability of reply.<br>
31.	The Reader of claim 28, wherein the first value of the probability parameter is an<br>
integer Q, the first probability of reply for one of the plurality of Tags is<br>
substantially equal to pQ, and p is less than 1.<br><br>
32.	The Reader of claim 31, wherein p is substantially equal to 0.5.<br>
33.	The Reader of claim 28, wherein the first probability of reply for a first one of the<br>
34.	plurality of Tags is different from the first probability of reply for a second one of<br>
35.	the plurality of Tags.<br>
36.	The Reader of claim 28, wherein the first query command further includes a state<br>
37.	flag indicating a first state, wherein Tags in a second state do not reply to the first<br>
38.	query command and Tags in the first state reply to the first query command<br>
39.	randomly according to the first value of the probability parameter.<br>
40.	The Reader of claim 34, further comprising:<br>
means for broadcasting a second query command including a second value of the probability parameter and a state flag indicating the second state, wherein Tags in the first state do not reply to the second query command and Tags in the second state reply to the second query command randomly according to the second value of the probability parameter; and<br>
means for detecting a reply in response to the second query command.<br>
36.	The Reader of claim 35, wherein the first and second query commands are<br>
37.	symmetric with respect to the first and second states.<br>
38.	The Reader of claim 34, further comprising:<br>
means for sending, responsive to a legible reply to the first query command, wherein the legible reply includes first handshaking data, a second command including the first handshaking data; and<br>
means for receiving Tag identification data as a reply to the second command.<br><br>
38.	The Reader of claim 37, further comprising:<br>
means for sending a command to indicate an error in receiving the Tag<br>
identification data when the Tag identification data is not received successfully.<br>
39.	The Reader of claim 28, further comprising:<br>
means for broadcasting a second query command without including a value of the probability parameter.<br>
40.	The Reader of claim 39, wherein<br>
the first query command includes first values of a plurality of parameters<br>
including the first value of the probability parameter; and the second query command does not include values of the plurality of parameters.<br>
41.	The Reader of claim 40, wherein the second query command is substantially<br>
42.	shorter than the first query command.<br>
43.	A Tag responsive to queries from a Reader, the Tag comprising:<br>
means for receiving from the Reader a first query command including a first value<br>
of a probability parameter; and means for deciding randomly whether or not to reply to the first query command,<br>
wherein a probability of reply is determined by the first value of the<br>
probability parameter.<br>
43.	The Tag of claim 42, further comprising:<br>
means for sending, responsive to a random decision to reply, a reply with first handshaking data.<br><br>
44.	The Tag of claim 43, wherein the first handshaking data is a random number<br>
45.	generated in response to the first query command.<br>
46.	The Tag of claim 42, wherein the first value of the probability parameter is an<br>
47.	integer Q, the first probability of reply for one of the plurality of Tags is<br>
48.	substantially equal to pQ, and p is less than 1.<br>
49.	The Tag of claim 45, wherein p is substantially equal to 0.5.<br>
50.	The Tag of claim 42, wherein the first query command further includes a state<br>
51.	flag indicating a first state, and wherein the Tag do not reply to the first query<br>
52.	command if the Tag is in a second state, and the Tag replies to the first query<br>
53.	command randomly according to the first value of the probability parameter if the<br>
54.	Tag is in the first state.<br>
55.	The Tag of claim 47, further comprising:<br>
means for receiving a second query command including a second value of the probability parameter and a state flag indicating the second state; and<br>
means for deciding randomly whether or not to reply to the second query<br>
command, wherein a probability of reply is determined by the second value of the probability parameter if the Tag is in the second state, and wherein the Tag does not reply to the second query command if the Tag is in the first state.<br>
49.	The Tag of claim 48, wherein the Tag processes the first and second query<br>
commands with symmetry with respect to the first and second states.<br><br>
50.	The Tag of claim 47, further comprising:<br>
means for sending, responsive to a random decision to reply, a first reply with<br>
first handshaking data; and means for sending, responsive to receiving from the Reader a second command<br>
including the first handshake data, a second reply with Tag identification<br>
data.<br>
51.	The Tag of claim 50, further comprising:<br>
means for switching, responsive to receiving a query command after sending the second reply, from the first state to the second state, wherein after receiving a command indicating an error in receiving the Tag identification data at the Reader, the Tag remains in the first state if a query command is received after the command indicating the error.<br>
52.	The Tag of claim 42, further comprising:<br>
means for receiving a second query command which does not include a value of<br>
the probability parameter; and means for deciding randomly whether or not to reply to the second query<br>
command, wherein a probability of reply is determined by the first value<br>
of the probability parameter.<br>
53.	The Tag of claim 52, wherein<br>
the first query command includes first values of a plurality of parameters including the first value of the probability parameter;<br>
the second query command does not include values of the plurality of parameters; and<br><br>
the Tag processes the second query command according to the first values of the plurality of parameters.<br>
54.	The Tag of claim 53, wherein the second query command is substantially shorter<br>
55.	than the first query command.<br>
56.	A machine readable medium containing instructions which when executed on a<br>
57.	data processing system causes the system to perform a method to query a plurality<br>
58.	of Tags, the method comprising:<br>
broadcasting one or more first query commands including a first value of a probability parameter, the first value of the probability parameter indicating a first probability of reply, wherein each of the plurality of Tags randomly determines whether or not to reply; and<br>
detecting a reply in response to the first query command.<br>
56.	The medium of claim 55, wherein the method further comprises:<br>
broadcasting, responsive to a determination that there is no reply to the one or<br>
more first query commands, a second query command including a second value of the probability parameter, the second value of the probability parameter indicating a second probability of reply which is greater than the first probability of reply.<br>
57.	The medium of claim 55, wherein the method further comprises:<br>
broadcasting, responsive to a determination that there is no legible reply to the<br>
one or more first query commands, a second query command with a second value of the probability parameter, the second value of the probability parameter indicating a second probability of reply which is less than the first probability of reply.<br><br>
58.	The medium of claim 55, wherein the first value of the probability parameter is an<br>
59.	integer Q, the first probability of reply for one of the plurality of Tags is<br>
60.	substantially equal to pQ, and p is less than 1.<br>
61.	The medium of claim 58, wherein p is substantially equal to 0.5.<br>
62.	The medium of claim 55, wherein the first probability of reply for a first one of<br>
63.	the plurality of Tags is different from the first probability of reply for a second<br>
64.	one of the plurality of Tags.<br>
65.	The medium of claim 55, wherein the first query command further includes a state<br>
66.	flag indicating a first state, wherein Tags in a second state do not reply to the first<br>
67.	query command and Tags in the first state reply to the first query command<br>
68.	randomly according to the first value of the probability parameter.<br>
69.	The medium of claim 61, wherein the method further comprises;<br>
70.	broadcasting a second query command including a second value of the probability<br>
parameter and a state flag indicating the second state, wherein Tags in the first state do not reply to the second query command and Tags in the second state reply to the second query command randomly according to the second value of the probability parameter; and detecting a reply in response to the second query command.<br>
63.	The medium of claim 62, wherein the first and second query commands are<br>
symmetric with respect to the first and second states.<br><br>
64.	The medium of claim 61, wherein the method further comprises:<br>
sending, responsive to a legible reply to the first query command, wherein the<br>
legible reply includes first handshaking data, a second command including the first handshaking data; and<br>
receiving Tag identification data as a reply to the second command.<br>
65.	The medium of claim 64, wherein the method further comprises:<br>
sending a command to indicate an error in receiving the Tag identification data<br>
when the identification Tag identification data is not received successfully.<br>
66.	The medium of claim 55, wherein the method further comprises:<br>
broadcasting a second query command without including a value of the<br>
probability parameter.<br>
67.	The medium of claim 66, wherein<br>
the first query command includes first values of a plurality of parameters<br>
including the first value of the probability parameter; and the second query command does not include values of the plurality of parameters.<br>
68.	The medium of claim 67, wherein the second query command is substantially<br>
69.	shorter than the first query command.<br>
70.	A Tag responsive to queries from a Reader, the Tag comprising:<br>
71.	an antenna;<br>
an Integrated Circuit (IC) coupled to the antenna to:<br>
receive from the Reader a first query command with a first value of a probability parameter; and<br><br>
decide randomly whether or not to reply to the first query command,<br>
wherein a probability of reply is determined by the first value of the probability parameter.<br>
70.	The Tag of claim 69, the IC coupled to the antenna further to send, responsive to a<br>
71.	random decision to reply, a reply with first handshaking data.<br>
72.	The Tag of claim 70, wherein the first handshaking data is a random number<br>
73.	generated in response to the first query command.<br>
74.	The Tag of claim 69, wherein the first value of the probability parameter is an<br>
75.	integer Q, the first probability of reply for one of the plurality of Tags is<br>
76.	substantially equal to pQ, and p is less than 1.<br>
77.	The Tag of claim 72, wherein p is substantially equal to 0.5.<br>
78.	The Tag of claim 69, wherein the first query command further includes a state<br>
79.	flag indicating a first state, wherein the Tag does not reply to the first query<br>
80.	command if the Tag is in a second state, and the Tag replies to the first query<br>
81.	command randomly according to the first value of the probability parameter if the<br>
82.	Tag is in the first state.<br>
83.	The Tag of claim 74, the IC coupled to the antenna further to:<br>
receive a second query command including a second value of the probability parameter and a state flag indicating the second state; and<br>
decide randomly whether or not to reply to the second query command, wherein a probability of reply is according to the second value of the probability<br><br>
parameter if the Tag is in the second state, and wherein the Tag does not reply to the second query command if in the first state.<br>
76.	The Tag of claim 75, wherein the Tag processes the first and second query<br>
77.	commands with symmetry with respect to the first and second states.<br>
78.	The Tag of claim 74, the IC coupled to the antenna further to:<br>
send, responsive to a random decision to reply, a first reply with first handshaking<br>
data; and send, responsive to receiving from the Reader a second command including the<br>
first handshake data, a second reply with Tag identification data.<br>
78.	The Tag of claim 77, the IC coupled to the antenna further to switch, responsive<br>
79.	to receiving a query command after sending the second reply, from the first state<br>
80.	to the second state, wherein after receiving a command indicating an error in<br>
81.	receiving the Tag identification data at the Reader, the Tag remains in the first<br>
82.	state if a query command is received after the command indicating the error.<br>
83.	The Tag of claim 69, the IC coupled to the antenna further to:<br>
84.	receive a second query command which does not include a value of the<br>
probability parameter; and<br>
decide randomly whether or not to reply to the second query command, wherein a probability of reply is determined by the first value of the probability parameter.<br>
80.	The Tag of claim 79, wherein<br>
the first query command includes first values of a plurality of parameters including the first value of the probability parameter;<br><br>
the second query command does not include values of the plurality of parameters;<br>
and the Tag processes the second query command according to the first values of the<br>
plurality of parameters.<br>
81.	The Tag of claim 80, wherein the second query command is substantially shorter<br>
82.	than the first query command.<br>
83.	An apparatus to query a plurality of Tags, comprising:<br>
84.	an antenna; and<br>
a Reader, comprising:<br>
a receiver coupled to the antenna;<br>
a transmitter coupled to the antenna;<br>
a processor coupled to the receiver, the transmitter and a memory, the<br>
processor to control the transmitter and the receiver, the Reader to broadcast one or more first query commands including a first value<br>
of a probability parameter, the first value of the probability parameter<br>
indicating a first probability of reply, wherein each of the plurality of Tags<br>
randomly determines whether or not to reply, and the Reader further to detect a reply in response to the first query command.<br>
83.	The apparatus of claim 82, the Reader further to broadcast, responsive to a<br>
determination that there is no reply to the one or more first query commands, a<br>
second query command including a second value of the probability parameter, the<br>
second value of the probability parameter indicating a second probability of reply<br>
which is greater than the first probability of reply.<br><br>
84.	The apparatus of claim 82, the Reader further to broadcast, responsive to a<br>
85.	determination that there is no legible reply to the one or more first query<br>
86.	commands, a second query command including a second value of the probability<br>
87.	parameter, the second value of the probability parameter indicating a second<br>
88.	probability of reply which is less than the first probability of reply.<br>
89.	The apparatus of claim 82, wherein the first value of the probability parameter is<br>
90.	an integer Q, the first probability of reply for one of the plurality of Tags is<br>
91.	substantially equal to pQ, and p is less than 1.<br>
92.	The apparatus of claim 82, wherein p is substantially equal to 0.5.<br>
93.	The apparatus of claim 82, wherein the first probability of reply for a first one of<br>
94.	the plurality of Tags is different from the first probability of reply for a second<br>
95.	one of the plurality of Tags.<br>
96.	The apparatus of claim 82, wherein the first query command further includes a<br>
97.	state flag indicating a first state, wherein Tags in a second state do not reply to the<br>
98.	first query command and Tags in the first state reply to the first query command<br>
99.	randomly according to the first value of the probability parameter.<br>
100.	The apparatus of claim 88, the Reader further to broadcast a second query<br>
101.	command including a second value of the probability parameter and a state flag<br>
102.	indicating the second state, wherein Tags in the first state do not reply to the<br>
103.	second query command and Tags in the second state reply to the second query<br>
104.	command randomly according to the second value of the probability parameter,<br>
105.	the Reader further to detect a reply in response to the second query command.<br><br>
REPLACEMENT SHEET OF CLAIMS:<br>
90.	A machine readable medium containing instructions which when executed on a data<br>
processing system causes the system to perform a method to respond to queries from a<br>
Reader, the method comprising:<br>
receiving from the Reader a first query command including a first value of a<br>
probability parameter; and deciding randomly whether or not to reply to the first query command, wherein a<br>
probability of reply is determined by the first value of the probability<br>
parameter.<br>
91.	The method of claim 90, further comprising:<br>
sending, responsive to a random decision to reply, a reply with first handshaking data.<br>
92.	The method of claim 91, wherein the first handshaking data is a random number generated<br>
in response to the first query command.<br>
93.	The method of claim 90, wherein the first value of the probability parameter is an integer Q,<br>
94.	the first probability of reply is substantially equal to pQ, and p is less than 1.<br>
95.	The method of claim 18, wherein p is substantially equal to 0.5.<br><br>
95.	The Tag of claim 69, wherein the antenna is an only antenna for the Tag.<br>
96.	The Tag of claim 69, wherein the Tag is a passive backscatter Tag.<br>
97.	The apparatus of claim 82, wherein the antenna is an only antenna for the apparatus.<br>
98.	An apparatus comprising:<br>
first and second antennas; and<br>
a Reader, the Reader comprising:<br>
a receiver coupled to the first antenna;<br><br>
a transmitter coupled to the second antenna; and<br>
a processor coupled to the receiver, the transmitter and a memory, the processor to control the transmitter and the receiver,<br>
wherein the Reader is configured to broadcast one or more first query commands including a first value of a probability parameter, the first value of the probability parameter indicating a first probability of reply by each of a plurality of Tags, and the Reader further configured to detect a reply in response to the first query command.<br>
99.      An apparatus of claim 98 wherein the first value is an integer Q,<br>
and the first probability of reply by each of the plurality of Tags is (0.5)^Q.<br>
Dated this 29th day of May 2006<br><br>
CLAIMS<br>
What is claimed is:<br>
1.	A method to query a plurality of Tags, the method comprising:<br>
broadcasting one or more first query commands including a first value of a<br>
probability parameter, the first value of the probability parameter indicating a first probability of reply, wherein each of the plurality of Tags randomly determines whether or not to reply; and detecting a reply in response to the first query command.<br>
2.	The method of claim 1, further comprising:<br>
broadcastmg, responsive to a determination that there is no reply to the one or<br>
more first query commands, a second query command including a second value of the probability parameter, the second value of the probability parameter indicating a second probability of reply which is greater than the first probability of reply.<br>
3.	The method of claim 1, further comprising:<br>
broadcasting, responsive to a determination that there is no legible reply to the one or more first query commands, a second query command including a second value of the probability parameter, the second value of the probability parameter indicating a second probability of reply which is less than the first probability of reply.<br>
4.	The method of claim 1, wherein the first value of the probability parameter is an<br>
integer Q, the first probability of reply for one of the plurality of Tags is<br>
substantially equal to pQ, and p is less than 1.<br><br>
5.	The method of claim 4, wherein p is substantially equal to 0.5.<br>
6.	The method of claim 1, wherein the first probability of reply for a first one of the<br>
7.	plurality of Tags is different from the first probability of reply for a second one of<br>
8.	the plurality of Tags.<br>
9.	The method of claim 1, wherein the first query command further includes a state<br>
10.	flag indicating a first state, wherein Tags in a second state do not reply to the first<br>
11.	query command and Tags in the first state reply to the first query command<br>
12.	randomly according to the first value of the probability parameter.<br>
13.	The method of claim 7, further comprising:<br>
broadcasting a second query command including a second value of the probability parameter and a state flag indicating the second state, wherein Tags in the first state do not reply to the second query command and Tags in the second state reply to the second query command randomly according to the second value of the probability parameter; and<br>
detecting a reply in response to the second query command.<br>
9.	The method of claim 8, wherein the first and second query commands are<br>
10.	symmetric with respect to the first and second states.<br>
11.	The method of claim 7, further comprising:<br>
sending, responsive to a legible reply to the first query command, wherein the<br>
legible reply includes first handshaking data, a second command including the first handshaking data; and<br>
receiving Tag identification data as a reply to the second command.<br><br>
11.	The method of claim 10, further comprising:<br>
sending a command to indicate an error in receiving the Tag identification data when the Tag identification data is not received successfully.<br>
12.	The method of claim 1, further comprising:<br>
broadcasting a second query command without including a value of the probability parameter.<br>
13.	The method of claim 12, wherein<br>
the first query command includes first values of a plurality of parameters<br>
including the first value of the probability parameter; and the second query command does not include values of the plurality of parameters.<br>
14.	The method of claim 13, wherein the second query command is substantially<br>
15.	shorter than the first query command.<br>
16.	A method for a Tag to respond to queries from a Reader, the method comprising:<br>
17.	receiving from the Reader a first query command including a first value of a<br>
probability parameter; and<br>
deciding randomly whether or not to reply to the first query command, wherein a probability of reply is determined by the first value of the probability parameter.<br>
16.	The method of claim 15, further comprising:<br>
sending, responsive to a random decision to reply, a reply with first handshaking data.<br><br>
17.	The method of claim 16, wherein the first handshaking data is a random number<br>
18.	generated in response to the first query command.<br>
19.	The method of claim 15, wherein the first value of the probability parameter is an<br>
20.	integer Q, the first probability of reply is substantially equal to pQ, and p is less<br>
21.	than 1.<br>
22.	The method of claim 18, wherein p is substantially equal to 0.5.<br>
23.	The method of claim 15, wherein the first query command further includes a state<br>
24.	flag indicating a first state, and wherein the Tag does not reply to the first query<br>
25.	command if the Tag is in a second state, and the Tag replies to the first query<br>
26.	command randomly according to the first value of the probability parameter if the<br>
27.	Tag is in the first state.<br>
28.	The method of claim 20, further comprising:<br>
receiving a second query command including a second value of the probability parameter and a state flag indicating the second state; and<br>
deciding randomly whether or not to reply to the second query command, wherein a probability of reply is determined by the second value of the probability parameter if the Tag is in the second state, and wherein the Tag does not reply to the second query command if the Tag is in the first state.<br>
22.	The method of claim 21, wherein the Tag processes the first and second query<br>
commands with symmetry with respect to the first and second states.<br><br>
23.	The method of claim 20, further comprising:<br>
sending, responsive to a random decision to reply, a first reply with first<br>
handshaking data; and sending, responsive to receiving from the Reader a second command including<br>
the first handshaking data, a second reply with Tag identification data.<br>
24.	The method of claim 23, further comprising:<br>
switching, responsive to receiving a query command after sending the second reply, from the first state to the second state, wherein after receiving a command indicating an error in receiving the Tag identification data at the Reader, the Tag remains in the first state if a query command is received after the command indicating the error.<br>
25.	The method of claim 15, further comprising:<br>
receiving a second query command which does not include a value of the<br>
probability parameter; and deciding randomly whether or not to reply to the second query command, wherein<br>
a probability of reply is determined by the first value of the probability<br>
parameter.<br>
26.	The method of claim 25, wherein<br>
the first query command includes first values of a plurality of parameters including the first value of the probability parameter;<br>
the second query command does not include values of the plurality of parameters; and<br>
the Tag processes the second query command according to the first values of the plurality of parameters.<br><br>
27.	The method of claim 26, wherein the second query command is substantially<br>
28.	shorter than the first query command.<br>
29.	A Reader to query a plurality of Tags, the Reader comprising:<br>
means for broadcasting one or more first query commands including a first value of a probability parameter, the first value of the probability parameter indicating a first probability of reply, wherein each of the plurality of Tags randomly determines whether or not to reply; and<br>
means for detecting a reply in response to the first query command.<br>
29.	The Reader of claim 28, further comprising:<br>
means for broadcasting, responsive to a determination that there is no reply to the one or more first query commands, a second query command including a second value of the probability parameter, the second value of the probability parameter indicating a second probability of reply which is greater than the first probability of reply.<br>
30.	The Reader of claim 28, further comprising:<br>
means for broadcasting, responsive to a determination that there is no legible<br>
reply to the one or more first query commands, a second query command with a second value of the probability parameter, the second value of the probability parameter indicating a second probability of reply which is less than the first probability of reply.<br>
31.	The Reader of claim 28, wherein the first value of the probability parameter is an<br>
integer Q, the first probability of reply for one of the plurality of Tags is<br>
substantially equal to pQ, and p is less than 1.<br><br>
32.	The Reader of claim 31, wherein p is substantially equal to 0.5.<br>
33.	The Reader of claim 28, wherein the first probability of reply for a first one of the<br>
34.	plurality of Tags is different from the first probability of reply for a second one of<br>
35.	the plurality of Tags.<br>
36.	The Reader of claim 28, wherein the first query command further includes a state<br>
37.	flag indicating a first state, wherein Tags in a second state do not reply to the first<br>
38.	query command and Tags in the first state reply to the first query command<br>
39.	randomly according to the first value of the probability parameter.<br>
40.	The Reader of claim 34, further comprising:<br>
means for broadcasting a second query command including a second value of the probability parameter and a state flag indicating the second state, wherein Tags in the first state do not reply to the second query command and Tags in the second state reply to the second query command randomly according to the second value of the probability parameter; and<br>
means for detecting a reply in response to the second query command.<br>
36.	The Reader of claim 35, wherein the first and second query commands are<br>
37.	symmetric with respect to the first and second states.<br>
38.	The Reader of claim 34, further comprising:<br>
means for sending, responsive to a legible reply to the first query command, wherein the legible reply includes first handshaking data, a second command including the first handshaking data; and<br>
means for receiving Tag identification data as a reply to the second command.<br><br>
38.	The Reader of claim 37, further comprising:<br>
means for sending a command to indicate an error in receiving the Tag<br>
identification data when the Tag identification data is not received successfully.<br>
39.	The Reader of claim 28, further comprising:<br>
means for broadcasting a second query command without including a value of the probability parameter.<br>
40.	The Reader of claim 39, wherein<br>
the first query command includes first values of a plurality of parameters<br>
including the first value of the probability parameter; and the second query command does not include values of the plurality of parameters.<br>
41.	The Reader of claim 40, wherein the second query command is substantially<br>
42.	shorter than the first query command.<br>
43.	A Tag responsive to queries from a Reader, the Tag comprising:<br>
means for receiving from the Reader a first query command including a first value<br>
of a probability parameter; and means for deciding randomly whether or not to reply to the first query command,<br>
wherein a probability of reply is determined by the first value of the<br>
probability parameter.<br>
43.	The Tag of claim 42, further comprising:<br>
means for sending, responsive to a random decision to reply, a reply with first handshaking data.<br><br>
44.	The Tag of claim 43, wherein the first handshaking data is a random number<br>
45.	generated in response to the first query command.<br>
46.	The Tag of claim 42, wherein the first value of the probability parameter is an<br>
47.	integer Q, the first probability of reply for one of the plurality of Tags is<br>
48.	substantially equal to pQ, and p is less than 1.<br>
49.	The Tag of claim 45, wherein p is substantially equal to 0.5.<br>
50.	The Tag of claim 42, wherein the first query command further includes a state<br>
51.	flag indicating a first state, and wherein the Tag do not reply to the first query<br>
52.	command if the Tag is in a second state, and the Tag replies to the first query<br>
53.	command randomly according to the first value of the probability parameter if the<br>
54.	Tag is in the first state.<br>
55.	The Tag of claim 47, further comprising:<br>
means for receiving a second query command including a second value of the probability parameter and a state flag indicating the second state; and<br>
means for deciding randomly whether or not to reply to the second query<br>
command, wherein a probability of reply is determined by the second value of the probability parameter if the Tag is in the second state, and wherein the Tag does not reply to the second query command if the Tag is in the first state.<br>
49.	The Tag of claim 48, wherein the Tag processes the first and second query<br>
commands with symmetry with respect to the first and second states.<br><br>
50.	The Tag of claim 47, further comprising:<br>
means for sending, responsive to a random decision to reply, a first reply with<br>
first handshaking data; and means for sending, responsive to receiving from the Reader a second command<br>
including the first handshake data, a second reply with Tag identification<br>
data.<br>
51.	The Tag of claim 50, further comprising:<br>
means for switching, responsive to receiving a query command after sending the second reply, from the first state to the second state, wherein after receiving a command indicating an error in receiving the Tag identification data at the Reader, the Tag remains in the first state if a query command is received after the command indicating the error.<br>
52.	The Tag of claim 42, further comprising:<br>
means for receiving a second query command which does not include a value of<br>
the probability parameter; and means for deciding randomly whether or not to reply to the second query<br>
command, wherein a probability of reply is determined by the first value<br>
of the probability parameter.<br>
53.	The Tag of claim 52, wherein<br>
the first query command includes first values of a plurality of parameters including the first value of the probability parameter;<br>
the second query command does not include values of the plurality of parameters; and<br><br>
the Tag processes the second query command according to the first values of the plurality of parameters.<br>
54.	The Tag of claim 53, wherein the second query command is substantially shorter<br>
55.	than the first query command.<br>
56.	A machine readable medium containing instructions which when executed on a<br>
57.	data processing system causes the system to perform a method to query a plurality<br>
58.	of Tags, the method comprising:<br>
broadcasting one or more first query commands including a first value of a probability parameter, the first value of the probability parameter indicating a first probability of reply, wherein each of the plurality of Tags randomly determines whether or not to reply; and<br>
detecting a reply in response to the first query command.<br>
56.	The medium of claim 55, wherein the method further comprises:<br>
broadcasting, responsive to a determination that there is no reply to the one or<br>
more first query commands, a second query command including a second value of the probability parameter, the second value of the probability parameter indicating a second probability of reply which is greater than the first probability of reply.<br>
57.	The medium of claim 55, wherein the method further comprises:<br>
broadcasting, responsive to a determination that there is no legible reply to the<br>
one or more first query commands, a second query command with a second value of the probability parameter, the second value of the probability parameter indicating a second probability of reply which is less than the first probability of reply.<br><br>
58.	The medium of claim 55, wherein the first value of the probability parameter is an<br>
59.	integer Q, the first probability of reply for one of the plurality of Tags is<br>
60.	substantially equal to pQ, and p is less than 1.<br>
61.	The medium of claim 58, wherein p is substantially equal to 0.5.<br>
62.	The medium of claim 55, wherein the first probability of reply for a first one of<br>
63.	the plurality of Tags is different from the first probability of reply for a second<br>
64.	one of the plurality of Tags.<br>
65.	The medium of claim 55, wherein the first query command further includes a state<br>
66.	flag indicating a first state, wherein Tags in a second state do not reply to the first<br>
67.	query command and Tags in the first state reply to the first query command<br>
68.	randomly according to the first value of the probability parameter.<br>
69.	The medium of claim 61, wherein the method further comprises;<br>
70.	broadcasting a second query command including a second value of the probability<br>
parameter and a state flag indicating the second state, wherein Tags in the first state do not reply to the second query command and Tags in the second state reply to the second query command randomly according to the second value of the probability parameter; and detecting a reply in response to the second query command.<br>
63.	The medium of claim 62, wherein the first and second query commands are<br>
symmetric with respect to the first and second states.<br><br>
64.	The medium of claim 61, wherein the method further comprises:<br>
sending, responsive to a legible reply to the first query command, wherein the<br>
legible reply includes first handshaking data, a second command including the first handshaking data; and<br>
receiving Tag identification data as a reply to the second command.<br>
65.	The medium of claim 64, wherein the method further comprises:<br>
sending a command to indicate an error in receiving the Tag identification data<br>
when the identification Tag identification data is not received successfully.<br>
66.	The medium of claim 55, wherein the method further comprises:<br>
broadcasting a second query command without including a value of the<br>
probability parameter.<br>
67.	The medium of claim 66, wherein<br>
the first query command includes first values of a plurality of parameters<br>
including the first value of the probability parameter; and the second query command does not include values of the plurality of parameters.<br>
68.	The medium of claim 67, wherein the second query command is substantially<br>
69.	shorter than the first query command.<br>
70.	A Tag responsive to queries from a Reader, the Tag comprising:<br>
71.	an antenna;<br>
an Integrated Circuit (IC) coupled to the antenna to:<br>
receive from the Reader a first query command with a first value of a probability parameter; and<br><br>
decide randomly whether or not to reply to the first query command,<br>
wherein a probability of reply is determined by the first value of the probability parameter.<br>
70.	The Tag of claim 69, the IC coupled to the antenna further to send, responsive to a<br>
71.	random decision to reply, a reply with first handshaking data.<br>
72.	The Tag of claim 70, wherein the first handshaking data is a random number<br>
73.	generated in response to the first query command.<br>
74.	The Tag of claim 69, wherein the first value of the probability parameter is an<br>
75.	integer Q, the first probability of reply for one of the plurality of Tags is<br>
76.	substantially equal to pQ, and p is less than 1.<br>
77.	The Tag of claim 72, wherein p is substantially equal to 0.5.<br>
78.	The Tag of claim 69, wherein the first query command further includes a state<br>
79.	flag indicating a first state, wherein the Tag does not reply to the first query<br>
80.	command if the Tag is in a second state, and the Tag replies to the first query<br>
81.	command randomly according to the first value of the probability parameter if the<br>
82.	Tag is in the first state.<br>
83.	The Tag of claim 74, the IC coupled to the antenna further to:<br>
receive a second query command including a second value of the probability parameter and a state flag indicating the second state; and<br>
decide randomly whether or not to reply to the second query command, wherein a probability of reply is according to the second value of the probability<br><br>
parameter if the Tag is in the second state, and wherein the Tag does not reply to the second query command if in the first state.<br>
76.	The Tag of claim 75, wherein the Tag processes the first and second query<br>
77.	commands with symmetry with respect to the first and second states.<br>
78.	The Tag of claim 74, the IC coupled to the antenna further to:<br>
send, responsive to a random decision to reply, a first reply with first handshaking<br>
data; and send, responsive to receiving from the Reader a second command including the<br>
first handshake data, a second reply with Tag identification data.<br>
78.	The Tag of claim 77, the IC coupled to the antenna further to switch, responsive<br>
79.	to receiving a query command after sending the second reply, from the first state<br>
80.	to the second state, wherein after receiving a command indicating an error in<br>
81.	receiving the Tag identification data at the Reader, the Tag remains in the first<br>
82.	state if a query command is received after the command indicating the error.<br>
83.	The Tag of claim 69, the IC coupled to the antenna further to:<br>
84.	receive a second query command which does not include a value of the<br>
probability parameter; and<br>
decide randomly whether or not to reply to the second query command, wherein a probability of reply is determined by the first value of the probability parameter.<br>
80.	The Tag of claim 79, wherein<br>
the first query command includes first values of a plurality of parameters including the first value of the probability parameter;<br><br>
the second query command does not include values of the plurality of parameters;<br>
and the Tag processes the second query command according to the first values of the<br>
plurality of parameters.<br>
81.	The Tag of claim 80, wherein the second query command is substantially shorter<br>
82.	than the first query command.<br>
83.	An apparatus to query a plurality of Tags, comprising:<br>
84.	an antenna; and<br>
a Reader, comprising:<br>
a receiver coupled to the antenna;<br>
a transmitter coupled to the antenna;<br>
a processor coupled to the receiver, the transmitter and a memory, the<br>
processor to control the transmitter and the receiver, the Reader to broadcast one or more first query commands including a first value<br>
of a probability parameter, the first value of the probability parameter<br>
indicating a first probability of reply, wherein each of the plurality of Tags<br>
randomly determines whether or not to reply, and the Reader further to detect a reply in response to the first query command.<br>
83.	The apparatus of claim 82, the Reader further to broadcast, responsive to a<br>
determination that there is no reply to the one or more first query commands, a<br>
second query command including a second value of the probability parameter, the<br>
second value of the probability parameter indicating a second probability of reply<br>
which is greater than the first probability of reply.<br><br>
84.	The apparatus of claim 82, the Reader further to broadcast, responsive to a<br>
85.	determination that there is no legible reply to the one or more first query<br>
86.	commands, a second query command including a second value of the probability<br>
87.	parameter, the second value of the probability parameter indicating a second<br>
88.	probability of reply which is less than the first probability of reply.<br>
89.	The apparatus of claim 82, wherein the first value of the probability parameter is<br>
90.	an integer Q, the first probability of reply for one of the plurality of Tags is<br>
91.	substantially equal to pQ, and p is less than 1.<br>
92.	The apparatus of claim 82, wherein p is substantially equal to 0.5.<br>
93.	The apparatus of claim 82, wherein the first probability of reply for a first one of<br>
94.	the plurality of Tags is different from the first probability of reply for a second<br>
95.	one of the plurality of Tags.<br>
96.	The apparatus of claim 82, wherein the first query command further includes a<br>
97.	state flag indicating a first state, wherein Tags in a second state do not reply to the<br>
98.	first query command and Tags in the first state reply to the first query command<br>
99.	randomly according to the first value of the probability parameter.<br>
100.	The apparatus of claim 88, the Reader further to broadcast a second query<br>
101.	command including a second value of the probability parameter and a state flag<br>
102.	indicating the second state, wherein Tags in the first state do not reply to the<br>
103.	second query command and Tags in the second state reply to the second query<br>
104.	command randomly according to the second value of the probability parameter,<br>
105.	the Reader further to detect a reply in response to the second query command.<br><br>
REPLACEMENT SHEET OF CLAIMS:<br>
90.	A machine readable medium containing instructions which when executed on a data<br>
processing system causes the system to perform a method to respond to queries from a<br>
Reader, the method comprising:<br>
receiving from the Reader a first query command including a first value of a<br>
probability parameter; and deciding randomly whether or not to reply to the first query command, wherein a<br>
probability of reply is determined by the first value of the probability<br>
parameter.<br>
91.	The method of claim 90, further comprising:<br>
sending, responsive to a random decision to reply, a reply with first handshaking data.<br>
92.	The method of claim 91, wherein the first handshaking data is a random number generated<br>
in response to the first query command.<br>
93.	The method of claim 90, wherein the first value of the probability parameter is an integer Q,<br>
94.	the first probability of reply is substantially equal to pQ, and p is less than 1.<br>
95.	The method of claim 18, wherein p is substantially equal to 0.5.<br><br>
95.	The Tag of claim 69, wherein the antenna is an only antenna for the Tag.<br>
96.	The Tag of claim 69, wherein the Tag is a passive backscatter Tag.<br>
97.	The apparatus of claim 82, wherein the antenna is an only antenna for the apparatus.<br>
98.	An apparatus comprising:<br>
first and second antennas; and<br>
a Reader, the Reader comprising:<br>
a receiver coupled to the first antenna;<br><br>
a transmitter coupled to the second antenna; and<br>
a processor coupled to the receiver, the transmitter and a memory, the processor to control the transmitter and the receiver,<br>
wherein the Reader is configured to broadcast one or more first query commands including a first value of a probability parameter, the first value of the probability parameter indicating a first probability of reply by each of a plurality of Tags, and the Reader further configured to detect a reply in response to the first query command.<br>
99.      An apparatus of claim 98 wherein the first value is an integer Q,<br>
and the first probability of reply by each of the plurality of Tags is (0.5)Q.<br>
Dated this 29th day of May 2006<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICAgIEVYQU1JTkFUSU9OIFJFUE9SVCBSRVBMWSBSRUNFSVZFRCAgMjctMDktMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006    EXAMINATION REPORT REPLY RECEIVED  27-09-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICAgQU1FTkRFRCAgUEFHRVMgT0YgU1BFQ0lGSUNBVElPTiAgMTEtMDMtMjAxMy5wZGY=" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006   AMENDED  PAGES OF SPECIFICATION  11-03-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICAgQU1FTkRFRCBDTEFJTVMgIDExLTAzLTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006   AMENDED CLAIMS  11-03-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICAgQU1FTkRFRCBDTEFJTVMgIDI1LTA0LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006   AMENDED CLAIMS  25-04-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICAgQU1FTkRFRCBQQUdFUyBPRiBTUEVDSUZJQ0FUSU9OICAgMjUtMDQtMjAxMy5wZGY=" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006   AMENDED PAGES OF SPECIFICATION   25-04-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICAgQ09SUkVTUE9OREVOQ0UgT1RIRVJTICAyNS0wNC0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006   CORRESPONDENCE OTHERS  25-04-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICAgRVhBTUlOQVRJT04gUkVQT1JUIFJFUExZIFJFQ0VJVkVEIDExLTAzLTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006   EXAMINATION REPORT REPLY RECEIVED 11-03-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICAgRVhBTUlOQVRJT04gUkVQT1JUIFJFUExZIFJFQ0VJVkVELiAgMjctMDktMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006   EXAMINATION REPORT REPLY RECEIVED.  27-09-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICAgRk9STS0xICAgMjUtMDQtMjAxMy5wZGY=" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006   FORM-1   25-04-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICAgRk9STS0zICAyNS0wNC0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006   FORM-3  25-04-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICAgRk9STS0zICAyNy0wOS0yMDEyLnBkZg==" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006   FORM-3  27-09-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICAgRk9STS0zIDExLTAzLTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006   FORM-3 11-03-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICBBU1NJR05NRU5UICAxMS0wMy0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006  ASSIGNMENT  11-03-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICBDT1JSRVNQT05ERU5DRSBPVEhFUlMgIDEyLTA0LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006  CORRESPONDENCE OTHERS  12-04-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICBGT1JNLTE4LnBkZg==" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006  FORM-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1DSEVOUC0yMDA2ICBPVEhFUiBQQVRFTlQgRE9DVU1FTlQgICAyNS0wNC0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">1903-CHENP-2006  OTHER PATENT DOCUMENT   25-04-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1jaGVucC0yMDA2IGZvcm0tMSAgIDIyLTExLTIwMTAucGRm" target="_blank" style="word-wrap:break-word;">1903-chenp-2006 form-1   22-11-2010.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1jaGVucC0yMDA2IGZvcm0tMTMgICAyMi0xMS0yMDEwLnBkZg==" target="_blank" style="word-wrap:break-word;">1903-chenp-2006 form-13   22-11-2010.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1jaGVucC0yMDA2LWFzc2lnbmVtZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">1903-chenp-2006-assignement.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1jaGVucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1903-chenp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1jaGVucC0yMDA2LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">1903-chenp-2006-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1jaGVucC0yMDA2LWRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">1903-chenp-2006-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1jaGVucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1903-chenp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1jaGVucC0yMDA2LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">1903-chenp-2006-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1jaGVucC0yMDA2LWZvcm0gMjYucGRm" target="_blank" style="word-wrap:break-word;">1903-chenp-2006-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1jaGVucC0yMDA2LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">1903-chenp-2006-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1jaGVucC0yMDA2LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">1903-chenp-2006-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkwMy1jaGVucC0yMDA2LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">1903-chenp-2006-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="256098-a-method-for-processing-data-for-transmission-in-a-multiple-input-multiple-output-mimo-communication-system.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="256100-anthranilamide-derivatives-as-insecticides.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>256099</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1903/CHENP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>18/2013</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>03-May-2013</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>01-May-2013</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>30-May-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>ALIEN TECHNOLOGY CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>18220 Butterfield Blvd., Morgan Hill, CA 95037</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>SMITH, John, Stephen</td>
											<td>1438 Oxford Street, Berkeley, CA 94709</td>
										</tr>
										<tr>
											<td>2</td>
											<td>CARRENDER, Curtis, L.</td>
											<td>15950 Oakridge Road, Morgan Hill, CA 95037</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06K19/07</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2004/036991</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-11-05</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/915,725</td>
									<td>2004-08-09</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/518,229</td>
									<td>2003-11-07</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/256099-methods-and-apparatuses-to-identify-devices by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:55:34 GMT -->
</html>
