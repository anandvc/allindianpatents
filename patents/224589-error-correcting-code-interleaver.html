<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/224589-error-correcting-code-interleaver by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:44:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 224589:ERROR-CORRECTING CODE INTERLEAVER</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">ERROR-CORRECTING CODE INTERLEAVER</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Memory may be partitioned into ever-sliding FIFOs. Each of the FIFOs may be stacked end-to-end in memory with the oldest data at the base offset and the newest at the end (or viceversa). Each symbol, the pointer may be incremented (modulo the set size) by an appropriate amount (typically J more than for the previous symbol). After each set, the pointers may be incremented by J more than the previous increment and the process starts over, wrapping around the memory if the end of the memory is reached. After a preset number of symbols, the process may restart from an increment of J. Alternatively, the pointers may be decremented rather than incremented. Thus, the newest symbol cannibalizes the memory position vacated by the oldest symbol in the current FIFO, causing the FIFOs to &#x27;slide&#x27;, providing for a very efficient and reliable use of memory for error-correcting code interleaving.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
TITLE OF INVENTION ERROR-CORRECITNG CODE INTERLEAVER<br>
FIELD OF THE INVENTION [0001]      The present invention relates to communications systems. More particularly, the present invention relates to a solution for interleaving error-correcting code.<br>
BACKGROUND OF THE INVENTION [0002]      When digital data is transmitted over what could potentially be a noisy channel, it is important to have a means of recovery against at least a limited number of errors. These errors may be introduced into a data stream by noise or other environmental factors. The process of recovering data having errors is known as error-correction. Eirar-conection is generally accomplished by adding a number of redundant pieces of data to a string of data being communicated When a receiver attempts to reconstruct the original message sent, it may begin by examining a possibly corrupted version of the encoded message, and then makes a decision as to which data (if any) to correct.<br>
[0003]      The set of all possible encoded messages is known as an en or-correcting code. Broadly, there are two types of error-correcting codes: codes of block type and codes of convolutional type. Codes of block type split an information string into blocks of k pieces of data to produce a code word of length n, where n &gt; k. If the encoder is using a code of block type, the system takes k pieces of data of the information string and places all k pieces of data in<br><br>
a buffer. Then a function is applied to the entire k block to produce the code word. There are certain applications, however, where messages come in serially rather than in large blocks, in which case the use of a buffer may be undesirable. In these cases, a code of convolutional type may be utilized A convolutional coder generates redundant pieces of data based on modulo-2 convolutions. Since the convolutional coder utilizes past pieces of data as well as current pieces of data to generate a code word, it may be viewed as a finite state machine.<br>
[0004]      Block-type codes and convolutional codes may be used together to improve performance and efficiency. For example a block-type code may be used to encode information, producing a series of symbols representing the information. A convolutional code may then be used to encode the symbols. This provides an extra layer of protection, but also allows improved handling of burst and random errors. A typical design for such a system may include a Reed-Solomon block code, followed by convolutional coding. A Reed-Solomon code is a special type of block code known as a cyclic code. A cyclic code is one where the sum of any two code words in the code is also a code word, and where any cyclic shift of a code word in the code is<br><br>
[0005]      The handling of burst and random eiTors through the use of the convolutional code may be further improved by interleaving the R-S symbols in time. Th|s distributes any potential<br><br>
errors among multiple R-S code words, thus improving the change of recovery due to interference generated at a single time but perhaps lasting longer than simple RS decoding could handle. Thus, the resulting errors per RS code word due to a burst is likely to be within the correction capability of the RS code.<br>
[0006] A convolutional interleaver typically distributes symbols by increasing the delay for each symbol within a set. The increase in delay between any two symbols may be demoted by J and the number of symbols in a set may be denoted by /.<br>
[0007]      One way to describe the interleaving function is to show / number of rows of First-In-First-Out memories (FIFOs), with each FIFO being deeper than the previous by J elements. FIG. 1 is a diagram illustrating a typical interleaver and de-interieaver. The first position 100 need not have any FIFO, as no delay is needed. The next position 102 has a FIFO of length /. The next position 104 has a FIFO of length 2 * J, and so on, until the 7th position 106 has a FIFO of length I*J. A commutator advances to the next position each time a symbol is transmitted, wrapping around to the 1st position after the 7th position has been reached. Thus, when data is first received, it may be set to the first row. As a new RS symbol is written into the row, the oldest value for that row is read out and the row pointer advances by one. When the last row (7) is finished, the pointer resets to the first row and repeats the sequence. This causes the symbols to be interleaved. A similar process may occur in the de-interleaver to arrive at the original symbol sequence.<br><br>
[0008]      A straightfoward implementation of this design may involve several stationary First-In-First-Out memories (FIFOs) in memory. New data written into a FIFO would replace the oldest data. The drawback for this implementation is that it requires a significant amount of storage to maintain the read and write pointers for the FIFOs. Each FIFO requires its own read and write pointers, thus necessitating /read and write pointers.<br>
[0009]      Another possible solution to this problem would be to modify the implementation such that rather than pointers, a look-up table is used to compute the address required to read or write at a particular point in the sequence. This would reduce the total pointer storage as well as the address calculation logic. Unfortunately, the access pattern for a typical implementation does not repeat for almost I64 bits of counting. This would result, therefore, in a look-up table of extraordinary size, making this implementation infeasible.<br>
[0010]      What is needed is a solution that minimizes interleaver memory, while keeping the memory pointer calculation practical.<br><br>
BRIEF DESCRIPTION OF THE INVENTION [0011]      Memory may be partitioned into ever-sliding FIFOs. Each of the FIFOs may be stacked end-to-end in memory with the oldest data at the base offset and the newest at the end (or vice-versa). Each symbol, the pointer may be incremented (modulo the set size) by an appropriate amount (typically J more than for the previous symbol). After each set, the pointers may be incremented by J more than the previous increment and the process starts over, wrapping around the memory if the end of the memory is reached. After a preset number of symbols, the process may restart from an increment of /. Alternatively, the pointers may be decremented rather than incremented. Thus, the newest symbol cannibalizes the memory position vacated by the oldest symbol in the current FIFO, causing the FIFOs to "slide", providing for a very efficient and reliable use of memory for error-correcting code interleaving.<br><br>
BRIEF DESCRIPTION OP THE DRAWINGS [0012]      The accompanying drawings, which are incorporated into and constitute a part of this specification, illustrate one or more embodiments of the present invention and, together with the detailed description, serve to explain the principles and implementations of the invention.<br>
[0013]      In the drawings;<br>
FIG. 1 is a diagram illustrating a typical interleaver and de-interleaver.<br>
FIG. 2 is a diagram illustrating the progression of the xead and write pointers through sliding FIFOs in accordance with an embodiment of the present invention.<br>
FIG. 3 is a diagram illustrating the progression of the xead and write pointers through sliding FIFOs in accordance with another embodiment of the present invention.<br>
FIG. 4 is a flow diagram illustrating a method for interleaving symbols of an enor correcting code having / symbols in a set in accordance with an embodiment of the present invention.<br>
FIG. 5 is a flow diagram illustrating a method for interleaving symbols of an error-correcting code having 1 symbols in a set in accordance with another embodiment of the present invention.<br><br>
FIG. 6 is a flow diagram illustrating a method for interleaving symbols of an error-correcting code having / symbols in a set in accordance with a third embodiment of the present invention.<br>
FIG. 7 is a block diagram illustrating an apparatus for interleaving symbols of an error correcting code having / symbols in a set in accordance with an embodiment of the present invention.<br>
FIG. 8 is a block diagram illustrating an apparatus for interleaving symbols of an error-correcting code having 1 symbols in a set in accordance with another embodiment of the present invention.<br>
FIG. 9 is a block diagram illustrating an apparatus for interleaving symbols of an error-correcting code having / symbols in a set in accordance with a third embodiment of die present invention.<br><br>
DETAILED DESCRITPIION<br>
[00014]      Embodiments of the present invention are described herein in the context of a syslem and method for remote performance analysis and optimization of computer systems. Those of ordinary skill in the art will realize that the following detailed description of the present invention is illustrative only and is not intended to be in any way limiting. Other embodiments of the present invention will readily suggest themselves to such skilled persons having the benefit of this disclosure. Reference will now be made in detail to implementations of the present invention as illustrated in the accompanying drawings. Hie same reference indicators will be used throughout the drawings and the following detailed description to refer to the same or like parts.<br>
[0015]      In the interest of clarity, not all of the routine features of the implementations described herein are shown and described. It will, of course, be appreciated that in the development of any such actual implementation, numerous implementation-specific decisions must be made in order to achieve the developer's specific goals, such as compliance with application- and business-related constraints, and that these specific goals will vary from one implementation to another and from one developer to another. Moreover, it will be appreciated that such a development effort might be complex and time-consuming, but would nevertheless be a routine undertaking of engineering for those of ordinary skill in the art having the benefit of this disclosure.<br><br>
[0016] In accordance with the present invention, the components, process steps, and/or data structures may be implemented using various types of operating systems, computing platforms, computer programs, and/or general purpose machines.<br>
{0017]      The present invention provides a solution that partitions memory into ever-sliding FIFOs. The storage of each of the FIFOs is stacked end-to-end in memory with the oldest data at the base offset and the newest at the end. In one embodiment of the present invention, only a single read pointer and a single write pointer is needed. In another embodiment, a single write pointer may be used with a known equation to compute the read pointer. Each symbol, the pointer is incremented (modulo the set size) by an appropriate amount (typically / more than for the previous symbol). After each set, the pointers may be incremented by J more than the previous increment and the process starts over, wrapping around the memory if the end of the memory is reached. After a preset number of symbols is reached, the process restarts from an increment of J.<br>
[0018]      It should be noted that while the present document describes an implementation where pointers are incremented each symbol, one of ordinary skill in the art would recognize that the present invention could also be used for an embodiment where the, pointers are decremented each symbol.<br>
[0019]      There are several variations on the present invention that may be utilized to accomplish different goals. If the developer wishes to optimize the processing logic required for the interleaves then an implementation may be chosen wherein rather than having no delay (and<br><br>
no corresponding FIFO) for the first symbol, a delay is introduced by adding a FIFO. This simplifies the calculation of the read and write pointers, as will be seen below. However, this adds / entries, as each of the / FIFO's much be increased by a block, as well as adds a constant one-symbol delay to the overall system latency. Thus, if the developer wishes to optimize memory, he may choose an implementation where the first symbol has no delay. Additionally, the developer may choose between implementations storing both a read and write pointer, and ones that contain only a write pointer with the read pointer calculated using a known equation. Having only a write pointer reduces the amount of storage required, but the necessity of using an equation to compute the read pointer adds logic.<br>
[0020]      FIG. 2 is a diagram illustrating the progression of the read and write pointers through sliding FIFOs in accordance with an embodiment of the present invention. In this embodiment, both read and write pointers are maintained in order to reduce the amount of logic. Additionally, no delay is introduced for the first symbol, thus no FIFO is required for the first symbol. In this<br><br>
whereas the second requires a FDFO of length J, the third a FIFO of length 2/, etc. The extra location at the end is required in order to accomplish the sliding aspect as will be seen later, similar to the "magic 15" puzzle game where one location must be empty in order to slide the other 15 tiles around.<br>
[0021]      Each time a symbol is processed, it may be known as a cycle. At a certain point, the symbols will reach a point where the cycles "turn over", or start back at 0.<br><br>
[0022]      The progression of reads and writes may proceed according to the following process, where wr is the write pointer, rd is the read pointer, wr_new is a placeholder variable, and step indicates a step value:<br>
1)	initialize wr to any value (as the initial location is not relevant since the FIFO's will be sliding)<br>
2)	initialize rd to wr<br>
Then, for each step from 0 to 7-1, repeat 3,4,5,6, and 7 as follows<br>
3)	set wr=wr_new<br>
4)	set wr_new=(step-wr_new) modulo the size of the memory, unless step=0, in which case set wr_new=rd<br>
5)	set rd=wr_new<br>
6)	read out value at rd<br>
7)	write new value at wr<br>
[0023]      Once the step reaches 7-1, it simply turns back over to 0 and steps 3-7 may be repeated until such time as no new symbols are received. It should be noted that this process could easily be modified to be subtracting rather than adding the step each iteration, thus sliding the FIFOs in the other direction. The direction the FIFOs slide is not relevant, its the fact that they slide that is important<br>
[0024]      Thus, referring back to FIG. 2, an 7 of 5 may be assumed, with a / of 1 byte.<br>
Therefore, there will essentially be 4 FIFOs of increasing length starting at length 1, but in<br>
«<br>
actuality there simply be a memory of size 11 bytes and the FIFOs will slide around this<br><br>
memory. FI G. 2 indicates this FIFO, with memOTy locations 0 through 10. The read pointer may progress according to the Table 1:<br><br><br>
[0025]      The write pointer may progress according to Table 2;<br><br><br>
[0026]      Thus, the first symbol will be in cycle 0, which is a bypass, thus it won't be placed in the FIFO. The second symbol will be in cycle 1, a read-out will occur from location 1 (which is empty for now), and the symbol will be written to location 0. The third symbol will be in cycle 2, a read-out will occur from location 3 (empty) and the symbol will be written to location I. The fourth symbol will be in cycle 3, a read-out will occur from location 6 (empty) and the symbol will be written to location 3. The fifth symbol will be in cycle 4, a read-out will occur from location 10 (empty) and the symbol will be written to location 6. The sixth symbol restarts the cycle at 0, and thus is a bypass. The seventh symbol will be in cycle 1, a read-out will occur fiom location 0 (which has a value written in cycle 1) and the symbol will be written to location 10. Thus, the proper delay of 1 for the "first FIFO" has been accomplished This process continues indefinitely until there are no symbols left<br>
[0027]      FIG. 3 is a diagram illustrating the progression of the read and write pointers through sliding FIFOs in accordance with another embodiment of the present invention. In this embodiment, an extra delay (and therefore extra memory location) is introduced for each of the<br><br>
[0028] Thus, referring back to FIG. 3, memory locations 0 through 15 may be provided. The progression of reads and writes may proceed according to the following process, where wr is the write pointer, rd is the read pointer, and step indicates a step value:<br>
1) initialize wr to any value (as the initial location is not relevant since the FIFO's will be sliding)<br><br>
Then, for each step from 0 to 7-1, repeat 2,3,4,5,6, and 7 as follows<br>
2)	set rd=wr-l<br>
3)	read out value at rd<br>
4)	write new value at wr<br>
5)	set wr=wr+(step+l)*J<br>
[0029]      The read pointer may progress according to Table 3:<br><br>
Table 3<br><br>
[0030]      The write pointer may progress according to Table 4:<br><br>
[0031]      FIG. 4 is a flow diagram illustrating a method for interleaving symbols of an error correcting code having 7 symbols in a set in accordance with an embodiment of the present invention. This embodiment is similar to the embodiment shown in FIG. 2 and described in the corresponding text. At 400, a placeholder may be set to an initial location in a memory of size<br><br>
symbols begin to be received. For every 7 symbols received, the following loop will be executed In this loop, step may be counted from 0 to 7-1, at each iteration performing a series of actions. Thus, by counting through from step from 0 to 7-1, and repeating that counting for every / symbols, the process is said to be repetatively counting.<br><br>
[0032]      At 402, a write pointer may be set equal to the placeholder. At 404, if step is 0, the placeholder may be set equal to a read pointer. At 406, if step is not 0, the placeholder may be advanced stepV memory locations, wrapping around if the placeholder value would be past an end of the memory. Advancing the placeholder may involve either adding stepV to fee placeholder, or subtracting stepV from the placeholder, depending upon which direction the FIFOs will be slid. Hie wrapping may occur by taking this sum or difference and applying modulo the memory size to it. At 408, the read pointer may be set equal to the placeholder. At 410, a symbol may be read out from a location in the memory indicated by the read pointer. At 412, a next of the I symbols may be written to a location in the memory indicated by the write pointer, unless step is 0, in which case it is bypassed at 414. A symbol may be bypassed by transmitting it without delay.<br>
[0033]      FIG. 5 is a flow diagram illustrating a method for interleaving symbols of an error-correcting code having 1 symbols in a set in accordance with another embodiment of the present invention. This embodiment is similar to the embodiment shown in FIG. 3 and described in the corresponding text. In this embodiment, both read and write pointers are stored At 500, a write<br><br>
delay value (i.e., the size of each memory location). Then, symbols begin to be received. For every / symbols received, the following loop will be executed. In this loop, step may be counted from 0 to M, at each iteration performing a series of actions. Thus, by counting through from step from 0 to 7-1, and repeating that counting for every 1 symbols, the process is said to be repetatively counting.<br><br>
[0034]       At 502, a read pointer may be set equal to one memory location behind the write pointer, wrapping around if the read pointer would be past an end of the memory. One memory location behind may be equivalent to either one memory location less than or one memory location more than, depending on the direction the FIFOs would be slid The wrapping may occur by taking this sum or difference and applying modulo the memory size to it At 504, a symbol may be read out from a location in the memory indicated by the read pointer. At 506, a next of the / symbols may be written to a location in the memory indicated by the write pointer. At 508, the write pointer may be advanced (step+l)*J memory locations, wrapping around if the write pointer would be past an end of the memory. Advancing the write pointer may involve either adding (step+l)*J to the write pointer, or subtracting (step+l)*J from the write pointer, depending upon which direction the FIFOs will be slid Hie wrapping may occur by taking this sum or difference and applying modulo the memory size to it<br>
[0035]      FIG. 6 is a flow diagram illustrating a method for interleaving symbols of an error-correcting code having J symbols in a set in accordance with a third embodiment of the present invention. This embodiment is similar to the embodiment shown in FIG. 5 and described in the corresponding text, except in this embodiment, only the write pointer is stored. At 600, a write<br><br>
delay value (i.e., the size of each memory location). Then, symbols begin to be received Fbr every / symbols received, the following loop will be executed. In thisloop, step may be counted from 0 to M, at each iteration performing a series of actions. Thus, by counting through from step from 0 to JA, and repeating that counting for every 7 symbols, the process is said to be repetatively counting.<br><br>
[0036]      At 602, a symbol may be read out from a location in the memory equal to one memory location behind the write pointer, wrapping around if this location would be past an end of the memory. One memory location behind may be equivalent to either one memory location less than or one memory location more than, depending on the direction the FIFOs would be slid The wrapping may occur by taking this sum or difference and applying modulo the memory size to it At 604, a next of the J symbols may be written to a location in the memory indicated by the write pointer. At 606, the write pointer may be advanced (step+l)*J memory locations, wrapping around if the write pointer would be past an end of the memory. Advancing the write pointer may involve either adding (step+l)*J to the write pointer, or subtracting (sre/H-1)*J from the write pointer, depending upon which direction the FIFOs will be slid. The wrapping may occur by taking this sum or difference and applying modulo the memory size to it<br>
[0037]      FIG. 7 is a block diagram iUustrating an apparatus for interleaving symbols of an error correcting code having 1 symbols in a set in accordance with an embodiment of the present invention. A memory 700 may be provided which can store the FIFOs and any variables to be used in the calculations, A memory initializer 702 coupled to the memory 700 may set up an<br><br>
each memory location) for the FIFOs. A placeholder setter 704 coupled to the memory 700 may may set the placeholder to an initial location in the memory. Then, symbols begin to be received. For every / symbols received, a loop will be executed. In this loop, step may be counted from 0 to 7-1, at each iteration performing a series of actions. /Thus, by counting through from step from 0 to 7-1, and repeating that counting for every 7 symbols, the process is said to be repetatively counting. A step repetative counter 706 coupled to the placeholder setter 704 may<br><br>
perform this repetitive counting and control the loop. From this point forward, what is referred to as memory is actually the portion of memory set aside for the FIFOs.<br>
[0033]      A write pointer setter 708 coupled to the memory 700 and to the step repetative<br>
counter 706 may set a write pointer equal to the placeholder. If step is 0, the placeholder setter<br>
704 may set the placeholder equal to a read pointer. If step is not 0, the placeholder setter 704<br>
may advance the placeholder step*J memory locations, wrapping around if the placeholder value<br>
would be past an end of the memory. Advancing the placeholder may involve either adding<br>
step*J  to the placeholder, or subtracting step*J from the placeholder, depending upon which<br>
direction the FIFOs will be slid. The wrapping may occur by taking this sum or difference and<br>
applying modulo the memory size to it. A read pointer setter 710 coupled the memory 700 and<br>
i to the step repetative counter 706 may set the read pointer equal to the placeholder. A memory<br>
location reader 712 coupled to the memory 700 and to the step repetative counter 706 may then<br>
read out a symbol from a location in the memory indicated by the read pointer. A symbol writer<br>
714 coupled to the memory 700 and to the step repetative counter 706 may then write a next of<br>
the 1 symbols to a location in the memory indicated by the write pointer, unless step is 0, in<br>
which case it is bypassed. A symbol may be bypassed by transmitting it without delay.<br>
[00391      FIG- 8 is a block diagram illustrating an apparatus for interleaving symbols of an enor-correcting code having / symbols in a set in accordance with another embodiment of the present invention. A memory 800 may be provided which can store the FIFOs and any variables to be used in the calculations. A memory initializer 802 coupled to the memory 800 may set up<br><br><br>
memory location) for the FIFOs. A write pointer setter 804 coupled to the memory 800 may set a write pointer to an initial location in the memory. Then, symbols begin to be received For every 7 symbols received, a loop will be executed. In this loop, step may be counted from 0 to 7-1. at each iteration performing a series of actions. Thus, by counting through from step from 0 to 7-1, and repeating that counting for every 7 symbols, the process is said to be repetatively counting. A step repetative counter 806 coupled to the write pointer setter 804 may perform this repetative counting and control the loop. From this point forward, what is referred to as memory is actually the portion of memory set aside for the FIFOs.<br>
[0040]      A read pointer setter 808 coupled to the memory 800 and to the step repetative counter 806 may set a read pointer equal to one memory location behind the write pointer, wrapping around if the read pointer would be past an end of the memory. One memory location behind may be equivalent to either one memory location less than or one memory location more than, depending on the direction the FIFOs would be slid. The wrapping may occur by taking this sum or difference and applying modulo the memory size to it. A memory location reader 810 coupled to the memory 800 and to the step repetative counter 806 may read out a symbol from a location in the memory indicated by the read pointer. A symbol writer 812 coupled to the memory 800 and to the step repetative counter 806 may write a next of the 7 symbols to a location in the memory indicated by the write pointer. The write pointer setter 808 may then advance the write pointer (step+i)*J memory locations, wrapping around if the write pointer would be past an end of the memory. Advancing the write pointer may involve either adding (step+l)*J to the write pointer, or subtracting (siep+l)*J from the write pointer, depending upon<br><br>
which direction the FIFOs will be slid. The wrapping may occur by taking this sum or difference and applying modulo the memory size to it<br>
[0041]      FIG. 8 is a block diagram illustrating an apparatus for interleaving symbols of an error-correcting code having / symbols in a set in accordance with another embodiment of the present invention. A memory 800 may be provided which can store the FIFOs and any variables to be used in the calculations. A memory initializer 802 coupled to the memory 800 may set up<br><br>
memory location) for the FIFOs. A write pointer setter 804 coupled to the memory 800 may set a write pointer to an initial location in the memory. Then, symbols begin to be received. For every / symbols received, a loop will be executed. In this loop, step may be counted from 0 to /-1, at each iteration performing a series of actions. Thus, by counting through from step from 0 to /-I, and repeating that counting for every 1 symbols, the process is said to be repetatively counting. A step repetative counter 806 coupled to the write pointer setter 804 may perform this repetative counting and control the loop. From this point forward, what is referred to as memory is actually the portion of memory set aside for the FIFOs,<br>
[0042]      A read pointer setter 808 coupled to the memory 800 and to the step repetative counter 806 may set a read pointer equal to one memory location behind the write pointer, wrapping around if the read pointer would be past an end of the memory. One memory location behind may be equivalent to either one memory location less than or one memory location more than, depending on the direction the FIFOs would be slid. The wrapping may occur by taking this sum or difference and applying modulo the memory size to it A memory location reader<br><br>
810 coupied to the memory 800 and to the step repetative counter 806 may read out a symbol from a location in the memory indicated by the read pointer, A symbol writer 812 coupled to the memory 800 and to the step repetative counter 806 may write a next of the /symbols to a location in the memory indicated by the write pointer. The write pointer setter 808 may then advance the write pointer (step+l)*J memory locations, wrapping around if the write pointer would be past an end of the memory. Advancing the write pointer may involve either adding (step+l)*J to the write pointer, or subtracting (s$ep+l)*from the write pointer, depending upon which direction the FIFOs will be slid. The wrapping may occur by taking this sum or difference and applying modulo the memory size to it.<br>
[0043]      FIG. 9 is a block diagram illustrating an apparatus for interleaving symbols of an error-correcting code having / symbols in a set in accordance with a thin! embodiment of the present invention, A memory 900 may be provided which can store tHe FIFOs and any variables to be used in the calculations. A memory initializer 902 coupled to the memory 900 may set up<br><br>
memory location) for the FIFOs. A write pointer setter 904 coupled to the memory 900 may set a write pointer to an initial location in the memory- Then, symbols begin to be received. For every / symbols received, a loop will be executed. In this loop, step may be counted from 0 to /-1, at each iteration performing a series of actions. Thus, by counting through from step from 0 to 7-1, and repeating that counting for every 1 symbols, the process is said to be repetatively counting. A step repetative counter 906 coupled to the write pointer setter 804 may perform this repetative counting and control the loop. From this point forward, what is referred to as memory is actually the portion of memory set aside for the FIFOs-<br><br>
[0044]      A memory location reader 908 coupled to the memory 900 and to the step  repetative counter 906 may read out a symbol from a location in the memory equal to one memory location behind the write pointer, wrapping around if the read pointer would be past an end of the memory. One memory location behind may be equivalent to either one memory location less than or one memory location more than, depending on die direction the FIFOs would be slid. The wrapping may occur by taking this sum or difference and applying modulo the memory size to it. A symbol writer 910 coupled to the memory 900 and to the step repetative counter 906 may write a next of the / symbols to a location in the memory indicated by the write pointer. The write pointer setter 908 may then advance the write pointer (step+l)*J memory locations, wrapping around if the write pointer would be past an end of the memory. Advancing the write pointer may involve either adding (step+l)*J to the write pointer, or subtracting {step+X)*J from the write pointer, depending upon which direction the FIFOs will be slid- The wrapping may occur by taking this sum or difference and applying modulo the memory size to it<br>
[0045]      While embodiments and applications of this invention have been shown and described, it would be apparent to those skilled in the art having the benefit of this disclosure that many more modifications than mentioned above are possible without departing from the inventive concepts herein. The invention, therefore, is not to be restricted except in the spirit of the appended claims.<br><br><br>
WE CLAIM;<br>
1.	A process for treating anaerobically decomposed organic material which comprises generating electric current to enhance hydrogen producing microorganismal activity and to reduce methane-producing microorganismal activity, said current being generated at intervals determined with reference to levels of hydrogen and/or methane detected in gas produced from the organic material.<br>
2.	The process as claimed in claim 1 wherein carbon dioxide produced from the organic material is separated from hydrogen produced from the organic material by preferential absorption of said carbon dioxide in a pressurized fluid whereby said hydrogen escapes to collection means.<br>
3.	The process as claimed in claim 2 wherein said pressurized fluid comprises a column of water having a height of at least 300 metres, maintained at a temperature in therange4-16°C.<br>
4.	The process as claimed in claim 2 or 3 wherein resulting carbon dioxide-containing pressurized fluid is permitted to expand to allow release of carbon dioxide and to transfer energy to a motor.<br>
5.	The process as claimed in claim 4 wherein heat is added to said carbon dioxide-containing pressurized fluid before it is permitted to expand.<br>
6.	The process as claimed in claim 5 wherein the expanded fluid is subsequently cooled, pressurized and recycled for further absorption of carbon dioxide.<br><br>
7.	An apparatus (300, 400) for use in the separation of carbon dioxide from other gaseous material produced by decomposition of organic material, said apparatus comprising container means (302, 402) adapted to contain a pressurized fluid in which carbon dioxide is preferentially soluble relative to said other gaseous material, feed means (304, 404) adapted to introduce a mixture of said carbon dioxide and other gaseous material into a lower part of said container means, collection means (308, 408) adapted to collect undissolved other gaseous material from an intermediate part of said container means, and fluid withdrawal means (310, 410) adapted to withdraw carbon dioxide-containing fluid and optionally also carbon dioxide from an upper part of said container means.<br>
8.	The apparatus as claimed in claim 7 wherein said container means is in the form of a vertical column.<br>
9.	The apparatus as claimed in claim 8 wherein said column has a height of at least 300 metres.<br><br>
10.	The apparatus as claimed in claim 8 or 9 further comprising one or more helical fins (306, 406) positioned about the axis of said column, the top of said helical fin or fins communicating with said collection means.<br>
11.	The apparatus as claimed in any of claims 7 to 10 further comprising means for controlling the temperature of said container means.<br>
12.	The apparatus as claimed in any of claims 7 to 11 further comprising an expansion engine (430, 432, 434, 436, 438, 440) adapted to receive carbon dioxide- containing pressurized fluid from said fluid withdrawal means.<br><br>
13.	The apparatus as claimed in claim 12 further comprising carbon dioxide collecting<br>
means (458) adapted to collect carbon dioxide from said expansion engine.<br>
14.	The apparatus as claimed in claim 12 or 13 further comprising heating means<br>
(414, 416, 418, 420, 422, 424) for heating carbon dioxide-containing pressurized fluid<br>
passing from said fluid withdrawal means to said expansion engine, cooling means<br>
(456) and pressurizing means (454) for respectively cooling and pressurizing fluid<br>
collected from said expansion engine, and means for introducing such cooled and<br>
pressurized fluid to a lower part of said container means.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1IGFic3RyYWN0IGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">2534-chenp-2005 abstract duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1IGNsYWltcyBkdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">2534-chenp-2005 claims duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1IGRlc2NyaXB0aW9uIChjb21wbGV0ZSkgZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">2534-chenp-2005 description (complete) duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1IGRyYXdpbmdzIGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">2534-chenp-2005 drawings duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1LWFzc2lnbmVtZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">2534-chenp-2005-assignement.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">2534-chenp-2005-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">2534-chenp-2005-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1LWNvcnJlc3BvbmRuZWNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">2534-chenp-2005-correspondnece-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1LWRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">2534-chenp-2005-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">2534-chenp-2005-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">2534-chenp-2005-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">2534-chenp-2005-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1LWZvcm0xOC5wZGY=" target="_blank" style="word-wrap:break-word;">2534-chenp-2005-form18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjUzNC1jaGVucC0yMDA1LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">2534-chenp-2005-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="224588-a-method-of-altering-the-level-of-phytochemical-in-a-harvested-plant-cell-and-an-apparatus-for-performing-the-method.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="224590-resonance-frequency-adjusting-method-and-stirling-engine.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>224589</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2534/CHENP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>49/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>05-Dec-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>21-Oct-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>04-Oct-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>TERAYON COMMUNICATION SYSTEMS, INC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>4988 Great America Parkway, Santa Clara, CA 95054,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>FANFELLE, ROBERT, J</td>
											<td>1077 Chesterton Avenue, Redwood City, CA 94061,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>HUBRIS, ALEXANDER</td>
											<td>3287 Lac D&#x27;Azur Court, San Jose, CA 95148,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>HO3M13/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2004/007881</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-03-15</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/394,937</td>
									<td>2003-03-21</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/224589-error-correcting-code-interleaver by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:44:38 GMT -->
</html>
