<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/233901-a-cryptographic-and-or-error-correction-apparatus by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:57:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 233901:&quot;A CRYPTOGRAPHIC AND/OR ERROR CORRECTION APPARATUS&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;A CRYPTOGRAPHIC AND/OR ERROR CORRECTION APPARATUS&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method of processing binary data representing field elements of an odd-characteristic finite field GF(pk) is described. The method comprises storing binary data representing at least a portion of a field element of an odd-characteristic finite field GF(pk) in a register, p being an odd prime number, the field element comprising k coefficients in accordance with a polynomial-basis representation, the binary data comprising plural groups of data bits, wherein each group of data bits represents an associated one of the k coefficients. The method also comprises executing at least one operation on contents of the register such that the plural groups of data bits are processed in parallel. An apparatus comprising a memory and a processing unit coupled to the memory to carry out the method is also described. (FIG-1)</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> EFFICIENT ARITHMETIC IN FINITE FIELDS OF ODD CHARACTERISTIC ON BINARY HARDWARE CROSS REFERENCE TO RELATED APPLICATIONS The present application is related to U.S. Patent Application entitled "Cryptography using finite fields of odd characteristic on binary hardware," Serial No. 10/271,947 (Attorney Docket No. 040001-177), and to U.S. Patent Application entitled "Error correction using finite fields of odd characteristic on binary hardware," Serial No. 10/271,945 (Attorney Docket No. 040001-178), both filed even date herewith, the disclosures of which are incorporated herein by reference in their entirety. BACKGROUND Field Of The Invention The present invention relates to methods and apparatuses for efficiently carrying out computations hi finite fields of odd prime characteristic on binary hardware. The invention is particularly useful for carrying out such computations in cryptography and in error correction, but is not limited to such uses. Background Information Some Basic Aspects of Finite Fields A finite field (also called a Galois field) is a finite algebraic structure, possessing two Well-defined operations: an "addition" and a "multiplication". A finite field with N Elements exists if and only if N is the power of a prime number, i.e. N=pn for some Prime p=2, 3, 5, ... such as discussed in R. Lidl and H. Niederriter, Introduction to Finite Fields and Their Applications, Cambridge University Press, Cambridge, Revised ed., 1994. This field is unique up to an isomorphism and is normally denoted GF(pn). For a prime p, the ground field GF(p) is simply the integers under addition and multiplication modulo p. In general, if F is a field of q=pl elements (i.e. F=GF(pk)), the extension field of degree / can be defined, denoted as F[t]/(f(t)), where f(t) is a polynomial of degree I, irreducible over F. This extension field may also be referred to as GF(p*). This then gives (the unique) finite field of q' elements. In other words, this is the field of p^p" elements. The number p is called the characteristic of the field. The well-known fact that the two fields of the same size are isomorphic does not necessarily mean that the mapping between the fields is trivial. However, constructions of such mappings are not necessary for the present invention and, in any event, are within the purview of one of ordinary skill in the art and are discussed in textbooks, such as Introduction to Finite Fields and Their Applications referred to above. There are two predominant ways to represent a finite field. One representation is the normal basis representation well known to those of ordinary skill in the art and such as described in Introduction to Finite Fields and Their Applications referred to above. The main advantage with a normal basis is that it facilitates multiplying elements by themselves, i.e. squaring-type operations. The normal basis representation is not discussed further here. Some computational aspects associated with normal basis representations are discussed in U.S. Patent No. 4,587,627 (Computational method and apparatus for finite field arithmetic), U.S. Patent No. 4,567,600 (Method and apparatus for maintaining the privacy of digital messages conveyed by public transmission), and U.S. Patent No. 5,854,759 (Method and apparatus for efficient finite field basis conversion), the entire contents of each of which are incorporated herein by reference. Another representation is known as the polynomial basis representation. In this representation, field elements of G&amp;($) may be thought of as polynomials of degree at most k-1 whose coefficients are field elements of the ground field GF(p), i.e., integers in the set (0, ..., p-1). A typical element, y, in the field can therefore be expressed as for some integers by where 0  1. Thus, an element in the field can be written as where each Yi is an element of GF(2fc). Adding field elements a and p in this representation can be done by carrying out the operation Since as , p; are elements of GF(2k), their sum, cq + p; can be computed as the bitwise XOR between the a, and pj. Thus, if k is small enough to fit in a hardware register (typically k(oci, pj) hi these algorithms denotes a procedure carrying out the operation (add, multiply, etc.) on field elements cq and pj in the field GFCp*). First, an addition algorithm, denoted SUM(cc, P), that relates the addition of elements a and P of the extension field GF(pft) to computations to be carried out in the field GFCp*) is given below. i SUM(a,p): for i=0 to /-I do 8j=GFjp_k_ADD(ai5 pj) end return where GF__p_k_ADD will be described in detail below. In addition, a multiplication algorithm, denoted PRODUCT(a, P), that relates the multiplication of elements a and P of the extension field GFCp"") to computations to be carried out in the field GFfp1) is now described. Here it is assumed that necessary initializations of DLOG and ANTILOG tables have already been made. Forms of the DLOG and ANTILOG tables will be described below. In addition, exemplary DLOG and ANTILOG tables are given in FIGS. 10A and 11A for a simple illustration for GF(32) to be described later. PRODUCT(cc,p): fori=0to2/-2do 5—0 for j=max(0,i-/+l) to min(i, M) do 8i=GF_p_k_ADD(Si, GF_p_k_MUL(a,, end end return REDUCER I2*"2 + 8^ t2" + • • • + 8, t + 80 , f(t)) where GF_p_k__MUL and REDUCE(6, f) (the latter computing z(t) mod f(t)) will be described in detail below. It should be noted that the above multiplication algorithm is merely one example of possible multiplication algorithms. For large values of / (e.g., /&gt;100), faster performance may be obtained by using Karatsuba's method instead of the simple PRODUCT algorithm above. Karatsuba's method is known to those of ordinary skill in the art and is described, for example, in Seminumerical Algorithms referred to above. Finally, a reduction operation "mod f(t)" necessary for completing the multiplication algorithm, PRODUCT(a, (3), can be done with a well-known algorithm given below and denoted as REDUCE(8, f&gt;- This algorithm can also make use of the present inventive approach for efficient arithmetic hi the field GF^*) to be described. For computational efficiency, f(t) can be chosen to be "sparse", meaning that f(t) has only a few non-zero coefficients (e.g., 3 non-zero coefficients). In this case, f(t) has form f(t)=f, t* + fj tj + f0 for some j between / and 0. It should be noted, however, that it is not necessary hi general for f(t) to have such a sparse. For any value of /, an irreducible polynomial f(t) of degree / can be readily found by methods known to those of ordinary skill hi the art. A general approach for determining an irreducible polynomial f(t) may be found in Sendraanerical Algorithms referred to above, for example. With these comments in mind, the reduction algorithm, denoted REDUCE(8, f), is as follows. REDUCE(5, f) tmpl=GF_p_k_MUL(GF_p_k_INVERSE(fi), f0) tmp2=GF_p_k_MUL(GF_p_k_INVERSE(fz), fy for i=2/-2 dovmto 1 do 5w=GF_p_k_SUB(8w, GF_pJc_MUL(tmpl, 8;)) 6i.H=GF_p_k_SUB(Sw+j, GF_p_k_MUL(tmp2, 8,)) end return 8M t'"J + 5wt'-2 + - + 8,t + 50. The REDUCE algorithm above is just a normal polynomial division algorithm adapted for the special form of f(t) given above. It should be noted that tmpl and tmp2 can be pre-computed because they are fixed once the representation is given, that is, once f(t) is defined. The function GFjp_k_SUB refers to field subtraction hi the field GF(pk), and the function GF_p_k_INVERSE refers to multiplicative inverse computation, both of which are easily implemented given algorithms for GF_p_k_ADD and GF_p_k_MUL and both of which will be described below. An exemplary apparatus 100 for executing the above-noted algorithms and for implementing other aspects of the invention will now be described with reference to the block diagram of FIG. 1. The apparatus 100 comprises a memory 101 and a processing unit 105 coupled to the memory 101. The apparatus 100 can also comprise an input/output device 103. The processing unit 105 comprises a plurality of registers 107-121, which are controlled by logic circuits (not shown) within the processing unit 105. The processing unit 105 can communicate with the input/output device 103 and the memory 101 via electrical connections (e.g., electrical buses) represented by the arrows shown in FIG. 1. It is also possible for the processing unit 105 to communicate with external registers (not shown) located outside the processing unit 105. The processing unit 105 can be, for example, any conventional type of processing unit, such as a Pentium-class processor or other CPU typically found in personal computers, or it may be a special purpose processor, such as may be found in wireless phones or other handheld devices. It is common for conventional processors used hi personal computers to have eight general purpose registers, such as illustrated by the eight registers 107-121 in FIG. 1 (also denoted as registers a-h). The registers 107 can be, for example, 8-bit registers, 16-bit registers, 32-bit registers, 64-bit registers, etc. Present generation processors for conventional personal computers commonly have 32-bit registers. The memory 101 can be, for example, any suitable memory capable of storing computer programs, such as a magnetic disk, a CD ROM, a magneto-optical disk, a flash memory, or other types of memory. In addition to storing computer programs, the memory 101 can also be used to store intermediate or final computational results generated by the processing unit 105 and can also be used to store look-up tables to be utilized during computations. The input/output device 103 can be, for example, any suitable device for passing data to and/or from the processing unit 105, such as a hard-wired modem or network interface, a wireless modem, a second memory, an analog-to-digital/digital-to-analog (AD/DA) converter, or other similar types of devices. Separate input and output devices can be utilized in place of a combined input/output device if desired. In addition, the input/output device 103 can be configured to perform guard-bit insertion and guard-bit removal. Guard-bit insertion and guard-bit removal are described later in relation to FIGS. 8A and 8B, for example. In one aspect, the memory 101 can store one or more computer programs, and the processing unit 105 can access the memory 101 to execute steps of the computer program(s). These computer programs can include, for example, programs representing the algorithms noted above and programs implementing other aspects of the invention as described below. In addition, although a single processing system 100 having a single processing unit 105 is shown in FIG. 1, it should be understood that the processing system 100 can comprise multiple processing units 105. Moreover, it is possible to embody the present invention using multiple processing systems instead of a single processing system 100. The remainder of the detailed description will focus on describing the inventive approaches for storing binary data representing field elements of GFCp*) in hardware registers and for executing operations on such binary data in a manner to enhance the speed of arithmetic computations involving field elements of GF(pk). In this regard, descriptions of the algorithms GFjp_k_ADD and GFjjJeJMUL, which provide for adding and multiplying field elements of the field GF(pk), will be described. In addition, other apparatuses for implementing the approaches will also be described. According to one aspect of the invention, the apparatus 100 illustrated in FIG. 1 can be used to carry out computations involving field elements of an odd-characteristic finite field GF(pk) in a manner that enhances computational efficiency compared to conventional approaches for carrying out computations involving field elements of odd-characteristic finite fields. In particular, the processing unit 105 is configured (e.g., programmed) to store binary data representing at least a portion of a field element of an odd-characteristic finite field GFCp1*) hi a register, such as register 107 shown in FIG. 1, wherein p is an odd prime number and wherein the field element comprises k coefficients hi accordance with a polynomial basis representation. The processing unit 105 and the register can be viewed as means for storing binary data representing at least a portion of a field element of GF(pk). The binary data comprise plural groups of data bits, wherein each group of data bits represents an associated one of the k coefficients. Thus, binary data representing multiple coefficients of a field element of the odd-characteristic finite field GF(pk) are packed into a single hardware register according to an aspect of the present invention. In contrast, conventional approaches for carrying out computations involving field elements of odd-characteristic finite fields merely place binary data representing a single coefficient of an odd-characteristic finite field into a single hardware register. In addition, the processing unit 105 is also configured to execute at least one operation on the contents of the above-noted register 107 such that the plural groups of data bits are processed hi parallel. For example, one or more operations can include a shift operation, an addition operation, a binary subtraction operation, a logical AND operation, and a NOT operation (logical negation) to name a few. In this regard, the processing unit 105 can be viewed as means for executing at least one operation on the binary data such that the plural groups of data bits are processed in parallel. Thus, by storing binary data representing multiple coefficients of a field element of GF^ in a single hardware register and by processing the plural groups of data bits in parallel, the speed of computations according to the present invention can be greatly increased compared to conventional methods for computations involving field elements of odd-characteristic finite fields. For example, if all k coefficients of a field element of GFCp") are represented in a single hardware register, such as register 107 shown in FIG. 1, the speed of processing the binary data representing the field element can be increased by a factor of k for addition and k2 for multiplication over conventional methods. Multiple coefficients of a field element of GF(p*) can be stored in a single hardware register using two exemplary approaches according to the present invention. These approaches are referred to herein as the single-guard-bit representation and the multiple-guard-bit representation, respectively, each of which has different advantages as will be described below. In describing each of these representations, it is assumed that the hardware architecture is capable of performing basic arithmetic and logical operations on w-bit words, e.g., the hardware registers can be w-bit registers for some w &gt; k(m+ 1) where binary data representing an entire field element is to be stored in a single register. In conventional terms, this means that the hardware architecture can perform arithmetic and logical operations on binary encoded integers in the range (0 .. 2W-1). In principle, larger values of w are preferable because more information can thereby be processed per operation. Bit positions are numbered from right to left wherein the least significant bit is indexed by "0", the next bit by "1", the next bit by "2", and so on, up to most significant bit (the word size), which is indexed by "w-1". Examples of the single-guard-bit representation are shown hi FIGS. 2A and 2B for 32-bit hardware registers. FIG. 2A is a schematic illustration of a hardware register 200 with a data storage scheme for storing binary data representing a field element a,{=(a.9£ are stored in bit positions zero and one (from the right). Another group of data bits representing the coefficient a1i, ... , a^, a^ ) of GF(75). In the example of FIG. 2B, five groups of bit positions 211-r (unshaded bit positions) are allocated to store binary data representing the field coefficients a4fi, ..., au, cc^. In this example, p=7=2m-l. Therefore, m=3, and three bits (not including guard bits) are allocated to store the binary data representing each coefficient ciy. Binary data representing coefficient oc^ are stored in bit positions zero, one and two (from the right). Binary data representing coefficient au i are stored in bit positions four, five and six, and so on. In the example of FIG. 2B for GF(75), the ground field is GF(7), and the following mapping between integer values of each coefficient and corresponding binary data is applicable (the quantities hi parentheses are the binary data): 0~(0, 0, 0); 1~(0, 0, 1); 2~(0, 1, 0); 3-(0 ,1, 1); 4'(1, 0, 0); 5~(1, 0, 1); 6~(1, 1, 0); and T(l, 1, 1) where 7 also corresponds to 0 (because 7 mod 7=0). Thus, the present invention provides a dual representation wherein two different numbers in the field GF(p) (7 and 0 in this example, where p=7) represent a same value (zero). In addition, in the example of FIG. 2B, five bit positions 213-r are allocated to store guard bits (lightly shaded regions), which are initially assigned binary values of 0. In addition, bit positions three, seven, eight, eleven, etc. are allocated for guard bits. Also, in the Example of FIG. 2B, the twelve most significant bit positions 215 in the register 210 are unused (darkly shaded regions). An example of the multiple-guard-bit representation is shown in FIG. 2C. FIG. 2C is a schematic illustration of a hardware register 220 with a data storage scheme for storing a field element (^=(0^, ... , aM, a0ii) of GF(38). In the example of FIG. 2C, eight groups of bit positions 221-r (unshaded bit positions) are allocated to store binary data representing the field coefficients cc^, ... , ctu, o^, and adjacent groups of bit positions 221-r are separate by a group of two guard bit positions 213-r (lightly shaded bit positions). In this example, p=3=2m-l. Therefore, m=2, and two bits (not including guard bits) are allocated to store the binary data representing each coefficient ctj.j. Binary data representing coefficient a0ii are stored in bit positions zero and one (from the right). Binary data representing coefficient au are stored in bit positions four and five and six, and so on. Eight groups of bit positions 223-r are allocated to store two guard bits each (lightly shaded regions), which are initially assigned binary values of 0. In the example of FIG. 2C, bit positions two, three, six, seven, eight, ten, eleven, etc. are allocated for guard bits. There are no unused bit positions in this example. It is typically desirable to store binary data representing an entire field element of GF(p*) in a single hardware register 107. However, in cases where a field element is sufficiently large such that its binary representation exceeds the storage capacity of a single register, it is desirable to store binary data representing at least a portion of the field element in the register 107. The arithmetic and logical operations noted above can be carried out by coordinating the operations in multiple registers that together store binary data representing a single field element of GF(p*). For example, if two registers are used to store binary data representing a single field element of GFOp*), a right shift by m bits over all the binary data can be carried out by coordinating the two registers such that the least significant bit in left hand register is shifted to the most-significant-bit side of the right-hand register. (The terminology "right-hand" and "left-hand" are used merely to distinguish the registers in the sense that a left-most-bit position hi a register corresponds to the mo.st-significant-bit position. The terminology is not intended to suggest that one register is necessarily physically positioned to the left of another register). It should be noted, however, that where two registers are used to store binary data representing a field element, if unused bit spaces are present in the most-significant-bit positions of the right-hand register, a right-shift operation must be implemented to skip over the unused bit spaces. According to another exemplary aspect of the present invention, the system 100 illustrated in FIG. 1 can be configured to execute the steps shown hi the flow diagram illustrated hi FIG. 3. FIG. 3 illustrates an approach 300 comprising a plurality of steps that can be executed by the processing unit 105 shown in FIG. 1. As shown at step 301 shown in FIG. 3, the processing unit 105 stores first binary data representing a first field element of GF(pk) in a first register (e.g., register 109), p being an odd prime number, wherein the first binary data comprises k groups of first data bits, and wherein each group of first data bits corresponds to an associated one of the k coefficients of the first field element. Similarly, as shown at step 303, the processing unit 105 stores second binary data representing a second field element of GF^*) in a second register (e.g., register 111), wherein the second binary data comprises k groups of second data bits, and wherein each group of second data bits corresponds to an associated one of the k coefficients of the second field element. Further, as shown at step 305 the processing unit 105 then generates third binary data by executing at least one operation on contents of the first register and contents of the second register such that the k groups of first data bits are processed in parallel and such that the k groups of second data bits are processed in parallel. For example, the operation or operations referred to in step 305 can include an addition operation, a subtraction operation, a shift operation, a logical AND operation, and a NOT operation just to name a few. Combinations of such operations may be carried out, for example, to generate third binary data that represents a third field element equal to the sum of the first and second field elements or a third field element equal to the product of the first and second field elements as will be described in detail below. The k groups of first data bits can be structured in the first register 109 such that at least one first guard bit is positioned adjacent to the most significant bit of each group of first data bits, each group of first data bits being separated from an adjacent group of first data bits by a corresponding at least one first guard bit. The k groups of second data bits can be structured in the second register 111 such that at least one second guard bit is positioned adjacent to the most significant bit of each group of second data bits, each group of second data bits being separated from an adjacent group of second data bits by a corresponding at least one second guard bit. In addition, the third binary data can comprise k groups of third data bits stored and structured in a third register (e.g., register 113)' such that at least one third guard bit is positioned adjacent to the most significant bit of each group of third data bits, each group of third data bits being separated from an adjacent group of third data bits by a corresponding at least one third guard bit. In this regard, the third field element comprises k third coefficients in accordance with the polynomial-basis representation, and each group of third data bits represents an associated one of the k third coefficients. (In the discussion above, "first", "second" and "third" are used as labels.) The processing unit 105 and a first register (e.g., register 109) can be viewed as means for storing first binary data representing a first field element of GF(p*). The processing unit 105 and a second register (e.g., register 111) can be view as means for storing second binary data representing a second field element of GFfc"). The processing unit 105 and a third register (e.g., register 113) can be viewed as means for storing third binary data representing a third field element of GF^*). The processing unit 105 can be viewed as means for executing at least one operation on the first binary data and the second binary data such that the k groups of first data bits are processed in parallel and such that the k groups of second data bits are processed in parallel. At step 307, it is determined whether or not more data should be processed. If more data should be processed, the flow men proceeds back to step 301. If the additional processing involves processing binary data that have already been stored in a manner consistent with steps 301 and/or 303 as a result of another calculation, steps 301 and/or 303 can be skipped as appropriate. If it is determined at step 307 not to process more data, the algorithm ends. Exemplary approaches for executing step 305 shown in FIG. 3 will now be described. Step 305 can be implemented, for example, using an algorithm GFjp_k_ADD or an algorithm GFjp_k_MUL, which will be described below. GFjp_k_ADD and GF_p_k_MUL were referred to above hi the discussion of the algorithms SUM(a, p), PRODUCT(a, p), and REDUCE(5, f). As will be described below, certain aspects of algorithms for both GF_p_k_ADD and GF_p_k_MUL depend upon the functional form of the characteristic value p and upon whether the single-guard-bit representation or the multiple-guard-bit representation is used. In particular, certain aspects of these algorithms depend on whether p is written as p=2m-l, p=2m+l or p=2m±dfor some integer m and some small integer d. The integer d is to chosen such that d 1. In general, for p = 2m±d,it is desirable to choose d odd and as close to 1 as possible. Given a value of p, a good (m, d)-pair can be found by trying all m = 1, 2, ..., (21og2(p)), and for each such m, selecting d to satisfy p = 2m±d, uitil a small d is found. Addition Using Single-Guard-Bit Representation, p=2*-l A form of GF_p_k_ADD for the single-guard-bit representation where p=2m-l will now be described, and it will be shown how one full addition of two field elements in GF(p") (i.e., k additions pertaining to the k coefficients of each field element), including the associated modular reduction, can be performed with a small, fixed number of operations (and without modular reductions which require long divisions) on a hardware architecture having at least w=k(m+l) bit word size. For example, for a 32-bit architecture, full additions in GF(310) can be performed using only five instructions. In the single-guard-bit representation, first binary data representing a first field element ai=(ak.u, ..., aliis a0&gt;i) of OFfe*) is stored in a first single hardware register (e.g., register 107 shown in FIG. 1) by storing binary data representing cc0ji in bit positions 0 through m-1,- binary data representing au in bit positions m+1 through 2m, etc., such that a group of data bits representing one field coefficient is separated by one bit position from an adjacent group of data bits representing another field coefficient. Second binary data representing a second field element Pj is stored similarly in a second single hardware register (e.g., register 109). Bit positions v(m+l)-l where v=l, 2, ..., k are allocated to separate the binary data representing the coefficients ccoi,  &gt;) 619 and an output register 621 for holding a result "c". Right shift gates are known to those of ordinary skill in the art, and such gates shift the values therein to the right by a selected number of bits and enter a corresponding number of zeros into the most significant bit positions. The clock/logic unit 605 can also have an output terminal (not shown) for providing a signal to be input to another hardware apparatus to initiate computations in another hardware apparatus when computations in the apparatus 600 are complete. For example, another hardware apparatus can be another apparatus 600 or a multiplier apparatus 1200 such as illustrated hi FIG. 12 to be described later. The operation of the apparatus 600 illustrated in FIG. 6 will now be described. First binary data representing a first field element and second binary data representing a second field element of GF(pk) are input on lines labeled a and b to the first register 601 and the second register 603, respectively. It is assumed that the first and second binary data are already configured with zeros at guard-bit positions (e.g., by a processor that is not shown). Binary data representing the quantity m is also provided to the right-shift gate (») 619. Mask register 613 receives a first predetermined binary quantity Ml (a mask quantity) from a processor (not shown), where Ml is a quantity with values as described previously. Alternatively, mask register 613 can also comprise a circuit that generates the quantity Ml upon input, of binary data representing the quantity m. Making such a circuit is within the purview of one of ordinary skill in the art. Computation is initiated by a start signal on the input line labeled s. The first and second binary data, the binary data representing the quantity m, and the start signal can be provided from a processor (not shown) or from another hardware apparatus (not shown), such as a multiplier apparatus as illustrated in FIG. 12 to be described later, via a conventional routing circuit, for example. When the values of the first binary data and second binary data in the registers 601 and 603 are stable, a signal si locks those values into the registers 601 and 603, respectively. The adder 607 then adds the values provided at its two inputs from register 601 and 603. When the output of the adder 607 is stable, the output from adder 607 is locked into register 609 by a signal on the line labeled s2. The tune required for a given value to become stable in a given register can be conventionally determined by one of ordinary skill in the art in view of the circuitry design, and a locking signal (e.g., on line si or line s2) can be timed to occur after this time. At this point, the register 609 holds binary data representing corresponding to the quantity a+b shown hi step 401 of FIG. 4. The binary data hi register 609 are then directed from register 609 to the AND gate 611. The AND gate 611 performs a logical AND between the binary data from register 609 and the mask quantity Ml from mask register 613. The result of this logical AND operation is equivalent to the quantity cl illustrated at step 403 of FIG. 4. The output from the first AND gate 611 is then directed back to the input of the first register 601, and another signal on the line labeled si then locks the corresponding values into the first register 601 at the appropriate time. In this regard, it will be understood that a signal on the line si can be tuned appropriately such that it is unnecessary to provide a multiplexer or switch at the point labeled 623 to route data output from register 609. Of course, the apparatus 609 could be provided with a multiplexer or switch at the point 623 for routing data if desired. While the operations described in the immediately preceding paragraph are being carried out, the following operations are more or less simultaneously carried out. Output from the register 609 is directed to the second AND gate 617, and the first predetermined binary quantity Ml is directed to a logical NOT gate 615. The output from the logical NOT gate 615 is also directed to an input of the second AND gate 617. The data at these the inputs of the second AND gate 617 are then combined via a logical AND operation and are directed to a right-shift gate 619. The right-shift gate 619 executes a right-shift by m bits on the data input from the second AND gate 617 according to the input on the line labeled m. The output of the right-shift gate 619 is then directed to the input of the second register 603. The result of this group of operations, which is input to the second register 603, corresponds to the quantity c2 referred to in step 405 of FIG. 4. When the values of the binary data now stored in the first and second registers 601 and 603 are stable, the signal si locks these values into the first and second registers 601 and 603. At this point, the adder 607 adds the binary data from the first and second registers 601 and 603 and directs the output to output register 609. The binary data now stored in register 609 is then directed to the output register 621, and a signal on line s3 locks the binary data into the register 621 at the appropriate time. This binary data corresponds to third binary data denoted as c at step 407 of FIG. 4. Those of ordinary skill in the art will appreciate that many variations of the apparatus 600 are possible according to the present invention. For example, each internal w-bit register 601, 603, 609, 613, and 621 can be replaced with multiple parallel (i.e., coordinated) registers, at least one of which holds binary data representing at least two coefficients of a field element. Further, the first AND gate 611, the adder 607, the second AND gate 617, the NOT gate 615, and the right-shift gate 619 shown in FIG. 6 are accordingly replaced with multiple parallel (i.e., coordinated) copies of each. In the apparatus 600 as described with reference to FIG. 6, first and second binary data are input to first and second registers 601 and 603, respectively, with zeros already configured at appropriate guard-bit positions. The first and second binary data may be provided in this configuration by a processor (not shown), for example, that inserts zeros at guard-bit positions as appropriate. Thus, the processor (not shown) and the first register 601 can be viewed as means for storing first binary data, and the processor (not shown) and the second register 603 can be viewed as means for storing second binary data. Further, the register 621 and/or the register 609 can be viewed as means for storing third binary data. Moreover, the clock/logic device 605 and any or all of the remaining devices illustrated in FIG. 6 can be viewed as means for executing at least one operation on the first binary data and the second binary data. By utilizing the apparatus 600 along with a processor (not shown), the apparatus 600 has flexibility to be used with field elements for various choices of p and k for the finite field GF(pk), where p is of form p=2m-l. In particular, the quantity m is a variable, and the right-shift gate 619 responds accordingly to the input value of m. In addition, the mask register 613 holds an appropriate form of the first predetermined binary quantity Ml that depends upon the quantity m. The quantity Ml is "predetermined" in the sense that once the quantity m is chosen (which determines the quantity p), the form of the quantity Ml directly follows as described above. In another exemplary aspect of the invention, the apparatus 600 can be modified, such as shown by hardware apparatus 700 illustrated in the block diagram of FIG. 7, for a situation hi which a dedicated choice of the finite field GF^*) is made and remains unchanged. That is, the quantities m, p, and k, as well as the choice of whether the representation is a single-guard-bit representation or a multiple-guard-bit representation, are fixed, and the hardware apparatus 700 is dedicated to those choices. In this situation, the hardware apparatus 700 can receive initial binary data representing field elements wherein the initial binary data are not configured with zeros in guard-bit positions. Rather, the hardware apparatus 700 itself configures the initial binary data with zeros hi appropriate guard-bit positions to generate first and second binary data without the need for a processor to configure the first and second binary data with zeros in guard-bit positions. The hardware apparatus 700 illustrated in FIG. 7 will now be described. The hardware apparatus 700 illustrated in the functional block diagram of FIG. 7 shares various common features and operational aspects with the apparatus 600 illustrated hi FIG. 6, and like features are given like reference numerals in FIGS. 6 and 7. Discussion of aspects of the apparatus 700 that are common to the apparatus 600 will not be duplicated here. Rather, aspects in which the apparatus 700 differs from the apparatus 600 will be.discussed. The apparatus 700 possesses several features not found in the apparatus 600. In particular, the apparatus 700 possesses guard-bit-insertion circuits 701' and 703' (GB insertion) and a guard-bit-removal circuit 709' (GB removal). Exemplary implementations of these circuits will be described in FIGS. 8A and 8B. As shown in FIG. 7, the guard-bit-insertion circuits 701' and 703' are functionally arranged at the .input to the hardware apparatus 700, and the guard-bit-removal circuit 709' is functionally arranged between the register 709 and the output register 721. The guard-bit-insertion circuits 701' and 703' operate to receive initial binary data a' and b' (without guard bits) corresponding to first and second field elements of GF(p") and to insert appropriate guard bits into that data. In other words, the guard-bit-insertion circuits 701' and 703' transform the initial binary data a' and b' into first binary data and second binary data having guard bits, in particular, with zeros at guard-bit positions. The guard-bit-removal circuit 709' has the opposite function - namely, to receive third binary data c representing a computational result and having guard bits and to remove those guard bits, thereby forming final binary data c' representing the computational result, but without guard bits. The apparatus 700 also lacks certain features present in the apparatus 600 because they are not needed hi the apparatus 700. In particular, the apparatus 700 lacks an input line for the quantity m into the right-shift gate 719 and into the mask register 713. Such an input line is not necessary given that m is fixed. Rather, the right-shift gate 719 is initialized once with the value of m to execute the appropriate right shift. Similarly, the mask register 713 is initialized once with the appropriate form of Ml. Conventional electrical connections can be used for carrying out these initializations and are not shown in FIG. 7. The operation of the apparatus 700 illustrated in FIG. 7 is substantially similar to that described for the apparatus 600 illustrated in FIG. 6 except for the operational distinctions noted above. In the apparatus 700 as described above, the first register 701 and the guard-bit insertion circuit 701' can be viewed as means for storing first binary data. The second register 703 and the guard bit insertion circuit 703' can be viewed as means for storing second binary data. Further, the register 709 can be viewed as means for storing third binary data. Moreover, the clock/logic device 705 and any or all of the remaining devices illustrated in FIG. 7 can be viewed as means for executing at least one operation on the first binary data and the second binary data. The guard-bit-insertion circuits 701' and 703' and the guard-bit-removal circuit 709' referred to in FIG. 7 will now be described in greater detail with reference to FIGS. 8A and 8B. The exemplary circuits illustrated in FIGS. 8A and 8B reflect a 32-bit register arrangement configured for the field GF(78); however, the concepts reflected in FIGS. 8A and SB are generally applicable to registers of others sizes and to other finite fields GFCp*). FIG. 8A illustrates an exemplary guard-bit-insertion circuit 800 that can be used for guard-bit-insertion circuits (GB insertion) referred to by reference numerals 701' and 703', respectively, in FIG. 7. As shown in FIG. 8A, the circuit 800 comprises a first register 801 with a plurality of bit positions 803 (e.g., 32 bits). The circuit 800 also comprises a register 805 having plural groups 807 of bit positions intended to store binary data representing field coefficients of a field element of GFCp*) and a plurality of guard-bit positions 809 (lightly shaded regions). The circuit 800 also comprises a plurality of electrical connections 811 configured to route data from register 801 to register 805 in a manner that provides a guard-bit position 809 adjacent to the most significant bit position of the preceding group of 3-bit positions 807. The guard-bit positions 809 are electrically grounded to provide zeros for these bit values, but these electrical connections are not shown in the FIG. 8A. Such a circuit can be formed, for example, using conventional lithographic techniques. In this manner, each 3-bit group 807 of bit positions in register 805 can store binary data representing a coefficient of a field element of GF(78), and each group 807 of bit positions in register 805 is separated from an adjacent group 807 of bit positions by a single guard bit 809. Accordingly, the guard-bit-insertion circuit 800 allows initial binary data representing coefficients of a field element to be transferred in parallel from register 801 to register 805 in a manner that inserts guard bits between groups of data bits representing coefficients of the field element. Similarly, an exemplary guard-bit-removal circuit 820 is illustrated in FIG. 8B for a 32-bit GF(78) configuration. As illustrated in FIG. 8B the guard-bit-removal circuit 820 is the mirror image of the guard-bit-insertion circuit 800 shown in FIG. 8A. The guard-bit-removal circuit 820 comprises a register 825, a register 821 and a plurality of electrical connections 831. The register 825 comprises plural groups 827 of bit positions and a plurality of guard-bit positions 829, each guard-bit position being located adjacent to the most significant bit of a given group 827 of bit positions. As illustrated in FIG. SB, the electrical connections 831 are configured such that binary data representing field coefficients of a field element stored in register 825 are transferred to register 821 in a manner that eliminates guard bits between adjacent groups of data bits representing field coefficients. That concludes the discussion of FIGS. 8A and 8B. .Multiplication Using Single-Guard-Bit Representation According to another aspect of the invention, an exemplary form of GFjp_k_MUL for the single-guard-bit representation will now be described for computing the product of two (non-zero) field elements otj and fy in GF^1). The case where one field element is zero is trivial and does not need to be described. This discussion is applicable to p written in the functional forms p=2m-l, p=2m+l, p=2m-d and p=2m+d. As noted previously in the discussion pertaining to Equations 9-12, a multiplicative group is cyclic, and a field element g, therefore, can be found such that any other non-zero field element can be written as g* for some integer x 1 and d odd), each coefficient of a field element is represented using m+2, m+1 and m+2 bits of binary data (not including guard bits), respectively, instead of m bits as for p=2ID-l. Directly addressed DLOG tables for p of forms other than p=2m-l, therefore, are correspondingly larger than directly addressed DLOG tables for p of the form p=2™-l. An exemplary DLOG table 1000 illustrating concepts described above for the single-guard-bit representation is shown in FIG. 10A for the simple case of GF(32) where p=2m-l for m=2. The example in FIG. 10A was constructed for GF(32) using the generator g(t)=t and the irreducible polynomial p(t)=t2+t+2. Such a DLOG table can be implemented, for example, using an 8-bit, 16-bit, 32-bit, etc., architecture. As noted previously, choosing an appropriate generator and irreducible polynomial for a given finite field GF(pk) is within the purview of one of ordinary skill in the art. The exemplary DLOG table J.000 illustrated in FIG. 10A comprises memory addresses 1001 corresponding to the field elements a(t) in binary form and stored values 1003 corresponding to the associated integers x in binary form. In addition, the exemplary DLOG table 1000 comprises 2k(m+1)=2*=64 rows (entries) 1005. In the example of FIG. 10A, each memory address comprises a k(m+l)=2(2+l)=6-bit string, and the left-most bit of each memory address 1001 corresponds to the most significant guard bit of a corresponding field element. This most significant guard bit can be eliminated from the memory addresses 1001, if desired, allowing the DLOG table 1000 to be indexed by binary strings k(nH-l)-l bits in length. The memory addresses 1001 comprise groups of data bits corresponding to coefficients of field elements in the manner previously described. Each memory address 1001 further comprises a plurality of guard bits 1005 The stored values 1003 of the DLOG table 1000 are illustrated as being functionally adjacent to the memory addresses 1001 for purposes of illustration. Each stored value 1003 comprises binary data representing an integer x as defined above. Reference infonnation 1050 is presented in FIG. 10B in a manner that is aligned via rows with the information in the DLOG table 1000 shown in FIG. 10A. The reference information 1050 in FIG. 10B is not part of the DLOG table 1000 and is merely provided for convenience to reflect the association between the binary information shown in the DLOG table 1000 and the field elements a(t) in polynomial form and the actual integer values x. Various blank entries denoted by "--" are present in the "x" and "a(t)" columns of both FIG. 10B and FIG. 10A. These blank entries stem from two considerations. First, some blank entries reflect the fact that there is no integer x that satisfies gx=0 for the field element "0" (a(t)=0), as is known to those of ordinary skill in the art. Other blank entries correspond to memory addresses 1001 having a "one" in any corresponding guard-bit position. As noted above, these entries are not used in the exemplary DLOG table 1000. hi the above-described direct-addressing example, the DLOG table 1000 has reserved memory locations that are not used for look-up operations corresponding to the two types of blank entries described above. The majority of these blank entries are associated with memory addresses having a "one" in any guard-bit position. However, compact DLOG tables can be implemented without such blank entries. For example, instead of associating field elements with consecutive memory addresses, binary data representing field elements a(t) with only zeros at guard-bit positions can be stored hi a DLOG table. Corresponding values for x=DLOG(a(t)) can also be stored in the DLOG table. The stored a(t) entries and x entries can be associated with each other such that looking up a given a(t) entry returns the corresponding x entry. This approach does not have the simplicity of using consecutive binary data corresponding to a(t) entries as addresses, but it does have the advantage of requiring less memory space. In one aspect of the present invention, a multiple-guard-bit representation can be used to obtain compact tables without significantly complicating the look-ups, as will be described later. In general, such a compact DLOG table can be configured with 2km+l reserved memory locations (e.g., viewed as 2km rows with 2 entries per row), all of which can be used for look-up operations. Alternatively, such a compact DLOG table can be implemented using 2km reserved memory locations if the most significant guard bit is eliminated. In comparison, a directly addressed DLOG table comprises 2k&amp;n+1) reserved memory locations (or 2k(m~HH reserved memory locations if the most significant guard bit is eliminated). Thus, utilizing a compact DLOG table can be useful for computations involving relatively larger field elements (e.g., field elements represented by binary data of greater than 25 bits including guard bits). Exemplary aspects of ANTILOG tables according to the present invention will now be described. ANTILOG tables according to the present invention are similar to DLOG tables described above. In particular, ANTILOG tables also contain binary information representing the quantities x and a(t). However, ANTILOG tables are indexed (addressed) by binary data representing the quantity x=DLOG(a(t)). Thus, for a memory address corresponding to a given value of x, the looked-up quantity is a(t)=ANTILOG(x). Given that ANTILOG tables are indexed by x instead of a(t) (as for DLOG tables), ANTILOG tables are considerably smaller than corresponding DLOG tables. In particular, ANTILOG tables have pk-l reserved memory locations regardless of the functional form of p. The fact that there are pk-l reserved memory locations instead of pv reserved memory locations stems from the fact that there is no integer x corresponding to the field element a(t)=gx=0. An exemplary ANTILOG table 1100 is shown in FIG. 11A for the simple case of GF(32) for the single-guard-bit representation where p=2m-l and m=2. The example hi FIG. 11A was constructed for GF(32) using the generator g(t)=t and the irreducible polynomial p(t)=tz+t+2. Such an ANTILOG table can be implemented, for example, using an 8-bit, 16-bit, 32-bit, etc., architecture. The exemplary ANTILOG table 1100 illustrated in FIG. 11A comprises memory addresses 1101 corresponding to integers x in binary form and stored values 1103 corresponding to the associated field elements a(t) in binary form. The memory addresses 1101 of the exemplary ANTILOG table 1100 are illustrated hi FIG. 11A as being functionally adjacent to the stored values 1103 for purposes of illustration. Each stored value 1103 comprises groups of data bits representing coefficients of field elements La the manner previously described. Each stored value 1103 further comprises a plurality of guard bits 1105 whose entries are zeros. In a manner similar to that shown in FIG. 10B, reference information 1150 is presented in FIG. 1 IB in a manner that is aligned via rows with the information in the ANTELOG table 1100 shown in FIG. 11 A. The reference information 1150 in FIG. 11B is not part of the ANTELOG table 1100 and is merely provided for convenience to reflect the association between the binary information shown in the ANTELOG table 1100 and the field elements a(t) in polynomial form and the actual integer values x. As noted above, DLOG tables and ANTELOG tables according to the present invention can be stored using any suitable hardware architecture (e.g., 8-bit, 16-bit, 32-bit, etc.). In addition, as noted above, directly addressed DLOG tables can be implemented with consecutive binary data representing field elements used as memory addresses. Alternatively, compact DLOG tables can be implemented that do not use direct addressing as described above. Such compact DLOG tables use less memory space but do not allow indexing directly by binary data representing field elements, and a more time-consuming table look-up is needed for compact DLOG tables. However, in the multiple-guard-bit representation described below, a considerably more compact DLOG table can be provided (approximately a factor 2k smaller) that still allows direct addressing and in which only a very small decrease in efficiency is encountered with regard to table look-ups. Memory requirements for directly addressed look-up tables for the single-guard-bit representation for p=2m-l are as follows. For a directly addressed DLOG table, each row contains the binary form of an integer x of size k*loga(p) « km bits, and (not including the most significant guard bit) the table is indexed by (k-l)(m+l)+m=k(m+l)-l bit binary strings corresponding to the field elements. .Thus, the size of the DLOG table is roughly km2k(m+1)-1 bits. For the ANTELOG table, each entry contains at most a k(m+l)-bit string, and there are pk-l entries. Thus, the size is k(m+l)( pk-l) bits, which is roughly equal to k(m+l)2Ian bits. Accordingly, the DLOG table is roughly a factor 2k' larger than the ANTELOG table. It is possible to reduce table sizes even further (for both the single-guard-bit representation and the multiple-guard-bit representation) at the cost of carrying out a larger number of multiplications. For example, the aforementioned Karatsuba's method for multiplying polynomials of degree k works by replacing a single multiplication of two degree-k polynomials with three multiplications, each involving polynomials of degree k/2. Those of ordinary skill in the art will recognize that above-described exemplary multiplication according to the present invention can be similarly modified to use tables of smaller size in conjunction with more table look-ups. For instance, if S is a table size for carrying exemplary multiplication according to the present invention as described above, a modification can be made wherein tables of size S1/2 are used in conjunction with three times as many table look-ups. Notwithstanding the increased cost in table look-ups, this approach can be desirable for memory-constrained environments. In view of the discussion above with regard to GF_p_k_MUL and the corresponding DLOG and ANTILOG tables, it can be seen that the above-described exemplary approach for carrying out multiplication of field elements of GF(pk) according to the present invention differs significantly from conventional approaches. First, in comparison to approaches for binary finite fields with characteristic p=2, the present approach stores binary data representing field elements differently by utilizing guard bits. Accordingly, the DLOG and ANTILOG tables according to the present invention also possess guard bits, such as illustrated in FIGS. 10A and 11 A, whereas the look-up tables for conventional approaches involving binary finite fields do not possess (or require) guard bits. In addition, in comparison to conventional approaches for multiplication of field elements of an odd-characteristic finite field, the present method accomplishes the multiplication task with significantly fewer operations. In particular, with regard to the extension field GFCp*) referred to above in the discussion regarding SUM(a, P) and PRODUCT(cc, P), each element of the extension field is represented as a vector (polynomial) of length /, where each component (coefficient) is stored according to the single-guard-bit representation. Multiplying two elements in the extension field requires approximately 3/2 operations rather than (flc)2 operations as would be required using conventional approaches. Thus, even for relatively small values of k, a significant increase in computational speed is achieved. In another aspect of the invention relating to multiplications of field elements of an odd-characteristic finite field, a dedicated hardware apparatus can be provided for carrying out operations of GFj?_k_MUL illustrated in FIG. 9. FIG. 12 is a functional block diagram illustrating such an exemplary hardware apparatus. In particular, the exemplary apparatus 1200 illustrated in FIG. 12 provides another approach for generating third binary data, denoted as c in FIG. 4, that can represent the product of a first field element and a second field element of GFCp11). In FIG. 12, solid lines represent electrical connections for the flow of data, and dotted lines represent electrical connections for the flow of control signals. The apparatus 1200 is described here in the discussion pertaining to the single-guard-bit representation, but the apparatus 1200 is equally applicable to a multiple-guard-bit representation, which is described later. Moreover, the apparatus 1200 is independent of the form of the characteristic value p (i.e., p=2m±l oro=2m±d). The apparatus 1200 comprises a first register 1201 and a second register 1203 for holding first binary data (register contents "a") and second binary data (register contents "b"), respectively. The first binary data and the second binary data represent field elements of the finite field GF(pk). Here, it is assumed that the first and second binary data in the first and second registers 1201 and 1203 are already configured with zeros at appropriate guard-bit locations. However, guard-bit insertion and removal circuits, such as described with regard to FIGS. 7 and 8 could also be included if desired such that initial binary data without guard bits could be input to the apparatus 1200. The apparatus 1200 also comprises a combinatorial logic and clock device (clock/logic) 1205, a first multiplexer 1207 (MUX1), a DLOG look-up memory 1209, and an ANTILOG look-up memory 1211. The DLOG and ANTCLOG look-up memories can be implemented, for example, using a random access memory (RAM) or a flash memory. The apparatus 1200 also comprises a register 1213 for holding the binary quantity DLOG(a), a register 1215 for holding the binary quantity DLOG(b), an addition gate (+) 1217 (also referred to as an adder), and a register 1219 for holding the integer value pk-l in binary form, which can be received, for example, from a processor. Alternatively, a specialized circuit can be provided along with the register 1219 to generate the value pk-l upon input of values for p and k. Configuring such a specialized circuit is within the purview of one of ordinary skill in the art. The apparatus 1200 also comprises a modulo arithmetic circuit 1221 (MOD) for computing the remainder of an input quantity divided by pk-l, which is supplied by register 1219. The circuit 1221 can be conventional modular arithmetic hardware known to those of ordinary skill in the art and does not need to be described further. The apparatus 1200 further comprises a second multiplexer 1223 (MUX2) and an output register 1225 for holding third binary data "c" resulting from computations within the apparatus. The clock/logic unit 1205 can also have an output terminal (not shown) for providing a signal to be input to another hardware apparatus to initiate computations in another hardware apparatus when computations in the apparatus 1200 are complete. For example, another hardware apparatus can be another apparatus 1200 or an addition apparatus 600 such as illustrated in FIG. 6. The operation of the exemplary apparatus 1200 illustrated in FIG. 12 will now be described. First, the DLOG look-up memory 1209 and the ANTILOG look-up memory 1211 are initialized once with appropriate discrete logarithm and anti-logarithm data. This can be accomplished by providing an initial programming signal to the clock/logic unit 1205 via the line labeled s, and by simultaneously supplying discrete logarithm and anti-logarithm data to the DLOG look-up memory 1209 and the ANTILOG look-up memory 1211, respectively, via external data buses labeled eDl and eD2. At the same time, address data is supplied to the DLOG memory 1209 and to the ANTILOG memory 1211 by external address buses eAl and eA2, respectively, via MUX1 1207 and MUX2 1223, respectively. As noted above, the look-up memories 1209 and 1211 can be implemented with RAM or flash memory, for example. Alternatively, if the apparatus 1200 is to be dedicated for particular values of p and k, the look-up memories 1209 and 1211 can be implemented using ROM, and pre-computations of the discrete logarithm and antilogarithm data can be done once and loaded into the ROM at manufacture. With the look-up memories 1209 and 1211 initialized, first binary data representing a first field element and second binary data representing a second field element can be input on lines labeled a and b to the first register 1201 and the second register 1203, respectively. It is assumed that the first binary data and the second binary data are already configured with zeros at appropriate guard-bit positions. Alternatively, guard-bit insertion circuits can be utilized to insert appropriate guard bits before loading the first binary data and second binary data into the first and second registers 1201 and 1203, respectively, such as described with regard to FIGS. 7 and 8. Binary data representing the quantity pk-l are input on the line labeled "pk-l" to the register 1219. The first binary data, the second binary data, the discrete logarithm and antilogarithm data, and the binary data representing the quantities p and k can be provided, for example, from a processor (not shown) or from one or more hardware apparatuses (not shown). For example, an addition apparatus 600 as illustrated in FIGS. 6 or 7 can be used to provide at least some of this data (e.g., first binary data and second binary data) via a conventional routing circuit. Computation is initiated by a start signal on the line labeled s as shown in FIG. 12. The start signal can also be provided from a processor (not shown) or from one or more hardware apparatuses (not shown). When the values of the first binary data and second binary data in the registers 1201 and 1203 are stable, a signal si locks those values into the first and second registers 1201 and 1203, respectively. When values of the binary data representing the quantity pk-l in register 1219 are stable, a signal s5 locks those values in register 1219. A signal s2 is then input to MTJX1 1207 which then passes the contents, a, of the first register 1201 to the DLOG memory 1209 to access the DLOG memory 1209. When the output values from the DLOG memory are stable, the output values are locked into register 1213 by a signal s4. Register 1213 now holds the value of DLOG(a). Another signal s2 is then input to MUX2 1223 which then passes the contents, b, of the second register 1203 to the DLOG memory 1209 to access the DLOG memory 1209. When the output values from the DLOG memory are stable, the output values are locked into register 1215 by a signal s3. Register 1213 now holds the value of DLOG(b). The adder 1217 then computes the integer sum of the contents of registers 1213 and 1215 and sends the result to the modulo arithmetic circuit 1221 (MOD) to compute the remainder of the value input thereto when divided by the quantity pk-l, which is available from register 1219. The output from MUX2 is then input to the ANTILOG memory 1211 to access the ANTILOG memory 1211. When the output values from the ANTILOG memory 1211 are stable, the output values are locked into register 1225 by a signal s6. Register 1225 now holds the value ANTILOG{(DLOG(a)+DLOG(b)) mod (pk-l)} in the single-guard-bit representation, which is available for output as register contents, c. If desired, however, a guard-bit-removal circuit, such as illustrated in FIGS. 7 and 8, could be placed functionally between the ANTILOG memory 1211 and the register 1225 to remove guard bits from the result of the computations. This completes the description of the exemplary multiplication apparatus 1200 illustrated in FIG. 12. In the apparatus 1200 as described, the first register 1201 and a processor (not shown) can be viewed as means for storing first binary data. Alternatively, the first register 1201 and a guard-bit insertion circuit (not shown) can be viewed as means for storing first binary data. The second register 1203 and a processor (not shown) can be viewed as means for storing second binary data. Alternatively, the second register 1203 and a guard-bit insertion circuit (not shown) can be viewed as means for storing second binary data. Further, the register 1225 can be viewed as means for storing third binary data. Moreover, the clock/logic device 1205 and any or all of the remaining devices illustrated in FIG. 12 can be viewed as means for executing at least one operation on the first binary data and the second binary data. Addition using Multiple-Guard-Bit Representation, p=2m-l Exemplary aspects of the invention pertaining to addition of field elements where p=2m-l are now described for the multiple-guard-bit representation. Here it is assumed that invention is implemented using a hardware architecture operating on at least 2km bit quantities (i.e., registers are at least 2km bits in size). The invention according to the multiple-guard-bit representation may be implemented, for example, using the system 100 illustrated in FIG. 1, which has already been described. In addition, dedicated hardware apparatuses, such as illustrated in FIGS. 6, 7, 8 and 12 and which have already been described, may also be used to implement the invention according to the multiple-guard-bit representation. Descriptions of these apparatuses are not reproduced here. However, appropriate modifications to the apparatuses illustrated in FIGS. 6, 7, 8 and 12 for the multiple-guard-bit representation, where necessary, will be described below. The representation of field elements of GF(pk) in the multiple-guard-bit representation was described previously in the discussion pertaining to the example of FIG. 2C. As noted in that discussion, elements of a finite field are stored as binary strings, but instead of having only one guard-bit position between adjacent groups of data bits representing coefficients of a field element, a plurality of guard-bit positions (e.g., m guard-bit positions) are provided between adjacent groups of bit positions that are allocated to store binary data representing the field coefficients of a field element. For example, as illustrated in FIG. 2C for GF(38), eight groups of bit positions 221-r (unshaded bit positions) are allocated to store binary data representing field coefficients oc7&gt;i, ..., &gt;m) (19) where a and b represent contents of the first and second register, respectively, in which the first and second binary data are stored according to the multiple-guard-bit representation and where c represents the resulting contents of a third register holding third binary data also stored according to the multiple-guard-bit representation. The explanation of how the above-noted operations result in correctly providing third binary data representing a third field element of GF(pk) equal to the sum of the first and second field elements is the same as described above for the single guard-bit representation and is not repeated here. As noted above, hardware apparatuses illustrated in FIGS. 6, 7 and 8 can be used to implement the invention according to the multiple-guard-bit representation. No modifications to the apparatus 600 illustrated in FIG. 6 are necessary hi this regard. It is merely necessary to recognize that the first and second binary data are stored in the first and second registers 601 and 603 according to the multiple-guard-bit representation and that the first and second predetermined binary quantities Ml and M2 are configured as described above. For the multiple-guard-bit representation, a modification to the addition apparatus 700 illustrated in FIG. 7 is required in the sense that the guard-bit-insertion circuits 701' and 703' and the guard-bit removal circuit 709' must be configured to insert multiple guard bits, instead of a single guard bit, between adjacent groups of data bits representing coefficients of a field element. In this regard, the exemplary guard- bit-insertion circuit 800 illustrated in FIG. 8A can be configured such that the electrical connections 811 are displaced wherein more than one guard-bit position 809 without an electrical connection 811 is inserted between adjacent groups of bit positions 807 in the register 805. Similarly, the exemplary guard-bit-removal circuit 820 illustrated in FIG. 8B can be configured such that the electrical connections 831 are displaced to remove more than one guard-bit position between adjacent groups of bit positions 807 in the register 825. With such modifications for the multiple-guard-bit representation, the operation of the apparatus 700 illustrated in FIG. 7 is the same as previously described. Multiplication Using Multiple-Guard-Bit Representation Implementations of exemplary forms of GF_p_k_MUL for the field GF(pk) will now be described for the multiple-guard-bit representation. This discussion is applicable to p given by the functional forms p=2m±land p=2radd. The only differences that occur for different functional forms of p relate to the number of bits used to store binary data representing a given coefficient of a field element and how many bits are allocated in ANTILOG tables for each coefficient of a field element. These differences will be discussed in greater detail below. The immediate discussion will proceed for the case where p=2m-l for which m bits are used to store each coefficient of a field element, but the discussion is applicable to the other functional forms for p noted above. In a first exemplary implementation of GF_p_k_MUL for the multiple-guard-bit representation, a compression function is-used to more efficiently utilize memory space allocated for DLOG and ANTILOG tables. This approach uses directly addressed DLOG and ANTILOG tables in a manner somewhat similar to that described above for the single-guard-bit representation, but the forms of the directly addressed DLOG and ANTILOG tables are different. In particular, to save memory space allocated for the DLOG and ANTILOG tables, the DLOG and ANTILOG are configured without guard bits (making them about kmfi1011 bytes in combined size). For a directly addressed DLOG table, where binary data corresponding to field elements are used as memory addresses, eliminating guard bits from the DLOG table means that the total number of consecutive memory addresses are reduced. Thus, the number of reserved memory locations are also reduced. For the ANTILOG table, which is also directly addressed and which uses binary data representing integers x=DLOG(a(t)) as memory addresses, eliminating guard bits reduces the number of bits used to store binary data representing field elements a(t), thereby reducing memory requirements. To utilize such tables, binary data representing field elements of GF(pk) stored in the multiple guard representation are compressed before carrying out a DLOG table look-up. In addition, resulting binary data is then decompressed after carrying out an ANTILOG table look¬up. This is now described in greater detail. Here it is assumed that field elements are stored according to the multiple-guard-bit representation with m guard bits between adjacent groups of data bits that represent coefficients of a field element. However, the present approach is not limited to m guard bits between adjacent groups of data bits and modifications for multiple guard bits other than m guard bits between adjacent groups of data bits will be apparent from the discussion below. Let t=INT(k/2) where INT(k/2) is the integer value of k/2 rounded down to nearest integer. A compression can be executed on register contents, a, stored in the multiple-guard-bit representation using a compression function (COMP) given by COMP(a)={(a XOR (a » (2t-l)m)) &amp; M3} (20) where M3 is predetermined binary quantity representing the value 2km-l so that COMP(a) has km bits. (The XOR can be replaced by a bitwise OR-operation in equation 20 above.) The COMP function moves groups of data bits representing field coefficients (that is, relevant, information-carry ing data) from bit-position blocks 2jm, ..., (2j +l)m-l, where j &gt; t, to the reserved guard-bit-position blocks (2(j-t)+l)m, ..., (2(j-t)+2)m-l. This is shown, for example, in FIG. 13 which illustrates the above-noted mapping of bit positions from a register 1301 to bit positions of a register 1302 where uncompressed data in register 1301 is compressed into register 1302. Dotted oblique lines 1303 illustrate the mapping of bit-position blocks shifted relative to their original positions. Dotted vertical lines 1304 illustrate the mapping of bit position blocks which are not shifted relative to their original positions. As illustrated in FIG. 13 for the case of GF(38) where t=4 and m=2 (because p=2m-l), as an example for j=t=4, data in bit positions 16 (i.e., 2jm) and 17 (i.e., (2j + l)m-l) are mapped to bit positions 2 (i.e., (2(j-t)+l)m) and 3 (i.e., (2(j-t)+2)m4). Other data blocks are similarly mapped. Accordingly, no groups of data bits representing coefficients of a field element are lost in the above-noted operations. The directly addressed DLOG table is configured such that the memory addresses correspond to COMP values of associated field elements for fast look-up. The directly addressed ANTILOG table stores COMP values of binary data representing field elements. Moreover, all entries in the DLOG and ANTILOG tables will contain relevant (i.e., information-carrying) data. Hence, there is no empty or unused space in the DLOG and ANTILOG tables. A decompression of compressed binary data can be carried out using a decompression function (DECOMP) in an analogous manner. Let M4 be a predetermined binary quantity with ones in bit-positions 2jm, 2jm+l, 2jm+2,..., (2j + l)m-l, where j=0., 1, ..., k-1, and zeros elsewhere. Then DECOMP(z) = {(z XOR (z « (2t-l)m)) &amp; M4) (21) where, again, the XOR can be replaced by a bitwise OR-operation and m)} mod p. (25) Because u 1 will be described below in conjunction with determining suitable representation sets Sp corresponding to allowed values of coefficients of field elements of GF^*). As will be seen, the Sp sets depend on the functional form of p and on m and d, where p=2™±d. In analogy to the above, these sets will be denoted by Sp+ for the case p=2m+l, Sp+d for p=2m+d, and Sp4 for p=2m-d. As noted above, the coefficients of field elements of GF(p*) themselves are elements of GF(p). It should be noted that as long as a modular reduction of a quantity c subtracts a multiple of p from c, there is mathematically no problem with allowing more general sets Sp if they are closed under addition followed by the modular reduction. Addition and Multiplication in GF(pk) where p= In the following descriptions of GFjp_k_ADD and GF_p_k_MUL for the case where p=2m-f-l, it is assumed that m £ 2 such that p &gt; 5. This is because the case where p=3 is preferably addressed using the previously described approaches for addition and multiplication where p=2m-l (i.e., p=22-l). Let the set Sp+ be given by Sp+ = {0, 1, ..., 2p-2). (Thus, for p=2m+l the present invention allows the values 0, 1, ..., p-2, to have two representations, whereas in the case p=2m-l, only the value 0 had more than one representation.) Each coefficient of a field element of GF^11) is then an element of Sp+. Note that 2p-2=2m+1, so that m+2 bits (not including guard bits) are used to represent a coefficient of a field element of GF^"), which is one more bit than was needed to represent coefficients in the set Sp" ={0 , ..., p} utilized in the approaches forp=2m-l. For the case p=2m+l, binary data representing field elements of GF(pk) can be stored in hardware registers according to either the single-guard-bit representation or the muitiple-guard-bit representation, such as described previously, except that for p=2m+l, m+2 bits (not including guard bits) are allocated for each group of data bits representing a coefficient of a field element. For example, in the single-guard-bit representation, first binary data representing a first field element cc; of GFfe*), wherein the first binary data comprises k groups of first data bits, can be stored as follows. Here it is assumed that (m+3)k is at most the hardware word size (i.e., register size). Let cij be a first field element of GF^*) where oci=(ak.1 b ..., o^fi) and where each o^ belongs to the set Sp+. A group of first data bits representing a0&gt;i is stored in a first register in bit positions 0, 1, ,.., m+1. A first guard bit having a value of zero is stored in the first register in bit position m+2 (a guard-bit position). Another group of first data bits representing aM is stored hi the first register in bit positions m-f 3, ..., 2m+4, and so on. Accordingly, there is one first guard bit in every bit position v(m+3)-l where v=l, 2, ... - that is, every successive (m+3)-rd bit position. In other words, there is one first guard bit positioned adjacent to the most significant bit of each group of first data bits. Second binary data comprising k groups of second data bits representing a second field element of GF(p^) can similarly be stored in a second register with one second guard bit adjacent to the most significant bit of each group of second data bits. (Here, the use of "first" and "second" merely distinguish between attributes corresponding to the first field, element and the second field element, respectively.) By storing binary data representing first and second field elements of GF(pk) in first and second hardware registers. in this manner, no carry bit will propagate from one group of data bits representing a field coefficient into an adjacent group of data bits representing another field coefficient. The approach for storing binary data representing field elements according to the multiple-guard-bit representation is completely analogous, the only difference being that more than one guard-bit position is provided between adjacent groups of data bits representing field coefficients. An exemplary form of GF_jp_k_ADD where p=2m-fl will now be described with reference to the flow diagram of FIG. 14. The operations shown in FIG. 14 can be executed by a system such as system 100 shown in FIG. 1. Further, it is assumed that steps 301 and 303 shown in FIG. 3 have already been executed by the processor 105 such that first binary data representing a first field element of GF(p*) are stored in a first register (e.g., register 107 shown in FIG. 1) and such that second binary data representing a second field element are stored in a second register (e.g., register 109) in a manner such as described directly above. The first and second binary data can be stored according to either the single-guard-bit representation or the multiple-guard-bit representation - the approach is the same in either case. The steps illustrated hi FIG. 14 then represent an exemplary implementation of step 305 shown hi FIG. 3. As indicated at step 1401, the processing unit 105 adds the contents, a, of the first register 107, and the contents, b, of the second register 109 using addition (that is, addition with a carry into the next most significant bit if necessary). The result of the addition can be stored in another register 111 such as illustrated in FIG. 1. As indicated at step 1403, the processing unit 105 then executes a logical AND operation between the quantity (a+b) stored in register 111 and a first predetermined binary quantity Ml stored hi one of the registers (e.g., register 113). The quantity Ml has values of zero at bit positions corresponding to bit positions of first guard bits stored in the first register 107 and has binary values representing the quantity 2m-l at bit positions corresponding to bit positions of each group of first data bits stored in the first register. For example, where p-5 (i.e., m=2 where p=2m+l), the first predetermined binary quantity Ml comprises successive binary strings (0, 0, 1, 1) separated by bit values of zero (corresponding to guard-bit positions), because 2m-l=3, which is given by (0, 0, 1, 1) in binary. The above definition for the quantity Ml is applicable to the multiple-guard-bit representation as well as to the single-guard-bit representation for the case where p=2m+l. The result of the operations indicated at step 1403 can be referred to as first intermediate data cl and is stored in one of registers (e.g., register 115). As indicated at step 1405, the processing unit 105 executes a logical AND operation between the quantity (a+b) stored in register 111 and a second predetermined binary quantity M2 where M2 is given by M2=NOT(M1). The NOT operation is bitwise logical negation. The result of this operation is stored in one of registers (e.g., register 117). Also indicated at step 1405, the processing unit 105 then executes a right shift by m bits on the quantity ((a+b)&amp;M2). The result of this operation can be stored in the same register 117 or in a different register. At step 1407, the processing unit 105 subtracts the quantity {((a+b)&amp;M2)&gt; &gt;m} from a third predetermined binary quantity PI. The quantity PI has values of zero at bit positions corresponding to bit positions of the first guard bits stored in the first register and has binary values representing the quantity 2ra+l (=p) at bit positions corresponding to bit positions of each group of first data bits in the first register. For example, where p=5 (i.e., m=2) the third predetermined binary quantity PI comprises successive binary strings (0, 1, 0, 1) separated by bit values of zero (corresponding to guard-bit positions), because 2m+l=5 which is given by (0, 1, 0, 1) in binary. The result of the operations indicated at step 1409 can be referred to as second intermediate binary data c2 and is stored in one of the registers (e.g., register 119). At step 1409 the processor executes addition between the first intermediate binary data cl and the second intermediate binary data c2 to generate the third binary data, represented by c, which can be stored in one of the registers (e.g., register 121). According to this approach, the third binary data c represents the sum of the first field element and the second field element. The algorithms according to FIGS. 3 and 14 have been described in terms of a specified sequence of steps to facilitate the description. However, it is not necessary to carry the steps indicated in FIGS. 3 and 14 in the exact order illustrated. Those of ordinary skill in the art will recognize that the order of steps can be varied and that some of the steps can be carried out simultaneously. For example, steps 301 and 303 shown hi FIG. 3 can be carried out simultaneously, and steps 1403 and 1405 shown in FIG. 4 can be carried out simultaneously. Regardless of the sequence in which various operations are executed,' it is merely necessary to determine the quantity c (third binary data) in accordance with the relation where a is first binary data representing the first field element, b is second binary data representing the second field element, + represents addition, and Ml, M2 and PI are as defined above. In this regard, those of ordinary skill in the art will recognize that each group of data bits Cj of the resulting quantity c represents a value that is an element of the set Sp+, and each such Cj is given by Cj=(aj+bj) mod(p) (up to a single multiple of p), where the j subscript for the quantities a and b designate corresponding groups of data bits that represent an associated coefficient of the respective field element. Thus, it is evident that addition of field elements in GFfc*) where p=2TO+l can be carried out using six simple instructions (compared to five simple instructions for p=2m-l). Utilizing the second term (Pl-{(c '&amp;M2) &gt; &gt;m)}) as an additive quantity in equation 36 is, hi principle, the same as subtracting the quantity ((a+b) div 2*) modulo p, thus making equation 36 consistent with equation 33. However, implementing subtraction of a quantity q as an addition of the quantity p-q has advantages. In particular, if subtraction is implemented in a conventional way, i.e. by subtracting ((a+b) div 2m) rather than by adding (Pl-{(( a4-b)&amp;M2)»m)}), there is a possibility of encountering negative "borrows" even if no additive carries are encountered. In contrast, by utilizing the additive quantity (Pl- {((a+b)&amp;M2)&gt; &gt;m)}), such negative borrows can be avoided. To prove that the approach given in equation 36 will produce correct addition results, observe that if a^ and bj e Sp+, then any Cj of the quantity c in equation 36 will satisfy 0<cj.>2) is stored hi register 1517 (corresponding to step 1405 in FIG. 14). The contents of register 1517 (((a+b)&amp;M2)&gt; &gt;2) are subtracted from the contents of register 1515 (PI) and the result (c2=Pl-(((a+b)&amp;M2)&gt; &gt;2)) is stored in register 1519 (corresponding to step 1407 of FIG. 14). Finally, the contents of register 1509 (cl) are added to the contents of register 1519 (c2) using addition, and the resulting third binary data (c=cl+c2) is stored in register 1521. The resulting third binary data stored in register 1521 correspond to a field element given in vector notation as (5, 5, 7, 5, 7, 5), which is the expected result. If desired, this result can be reduced modulo 5 (which is mod(p) in this example) prior to an output operation, for example, providing the result (0, 0, 2, 0, 2, 0). This completes the discussion of Example 2. In another aspect of the invention relating to computations involving field elements of an odd-characteristic finite field where p=2m+l, a hardware apparatus can be provided for carrying out operations for the exemplary form of GF_jp_k_ADD illustrated in FIG. 14. FIG. 16 is a functional block diagram of such an exemplary hardware apparatus. In particular, the apparatus 1600 illustrated in FIG. 16 provides another approach for generating third binary data, denoted as c in FIGS. 14 and 16, that can represent the sum of a first field element and a second field element of GF(pk). The apparatus 1600 is applicable to both the single-guard-bit representation and the multiple-guard-bit representation. The hardware apparatus 1600 illustrated in the functional block diagram of FIG. 16 shares various common features and operational aspects with the apparatus 600 illustrated hi FIG. 6, and like features are given like reference numerals in FIGS. 6 and 16. Discussion of aspects of the apparatus 1600 that are common to the apparatus 600 will not be duplicated here. Rather, aspects in which the apparatus 1600 differs from the apparatus 600 will be discussed. The apparatus 1600 possesses several features not found in the apparatus 600. In particular, the apparatus 1600 possesses an additional register 1625 for holding the third predetermined binary quantity PI and a subtraction gate 1627 for subtracting the output from the right-shift gate 1619 from the contents (PI) of the register 1625. The output frdm the subtraction gate 1627 is fed back into the register 1603 as indicated. In contrast, as illustrated in FIG. 6, the apparatus 600 has no register analogous to register 1625 and no subtraction gate analogous to subtraction gate 1627. Rather, for the apparatus 600 illustrated in FIG. 6, the output from the right-shift gate 619 is fed directly into register 603 illustrated therein. By providing the register 1625 and die subtraction gate 1627 in the manner illustrated in FIG. 16B, the apparatus 1600 is enabled to manipulate data in a manner corresponding to step 1407 illustrated in FIG. 14. In other respects, the apparatus 1600 operates like the apparatus 600 illustrated in FIG. 6, and no additional discussion of the like aspects in FIG. 1600 is required. In the apparatus 1600 as described above, the first register 1601 and a processor (not shown) can be viewed as means for storing first binary data such as described with regard to FIG. 6. The second register 1603 and a processor (not shown) can be viewed as means for storing second binary data. Further, the register 1621 and/or the register 1609 can be viewed as means for storing third binary data. Moreover, the clock/logic device 1605 and any or all of the remaining devices illustrated in FIG. 16 can be viewed as means for executing at least one operation on the first binary data and the second binary data. In another exemplary aspect of the invention, the addition apparatus 1600 used for p=2m+l can be modified, such as shown for the hardware apparatus 1700 illustrated in the block diagram of FIG. 17, for a situation in which a dedicated choice of the finite field GFCp*) is made and remains unchanged. That is, the quantities m, p, and k, as well as the choice of whether the representation is a single-guard-bit representation or a multiple-guard-bit representation, are fixed, and the hardware apparatus 1700 is dedicated to those choices. In this situation, the hardware apparatus 1700 can receive initial' binary data representing field elements wherein the initial binary data are not configured with zeros in guard-bit positions. Rather, the hardware apparatus 1700 itself configures the initial binary data with zeros in appropriate guard-bit positions to generate first and second binary data without the need for a processor to configure the first and second binary data with zeros in guard-bit positions. The . hardware apparatus 1700 illustrated in FIG. 17 will now be described. The hardware apparatus 1700 illustrated in the functional block diagram of FIG. 17 shares various common features and operational aspects with the apparatus 1600 illustrated in FIG. 16, and like features are given like reference numerals in FIGS. 16 and 17. Discussion of aspects of the apparatus 1700 that are common to the apparatus 1600 will not be duplicated here. Rather, aspects in which the apparatus 1700 differs from the apparatus 1600 will be discussed. The apparatus 1700 possesses several features not found in the apparatus 1600. hi particular, the apparatus 1700 possesses guard-bit-insertion circuits 1701' and 1703' (GB insertion) and a guard-bit-removal circuit 1709' (GB removal). The guard-bit-insertion and guard-bit-removal circuits, 1701', 1703' and 1709' can be implemented, for example, using circuits similar to those shown in the examples of FIGS. 8A and 8B, which have already been described. As shown in FIG. 17, the guard-bit-insertion circuits 1701' and 1703' are functionally arranged at the input to the hardware apparatus 1700, and the guard-bit-removal circuit 1709' is functionally arranged between the register 1709 and the output register 1721. The guard-bit-insertion circuits 1701' and 1703' operate to receive initial binary data a' and b' (without guard bits) corresponding to first and second field elements of GFCp*) and to insert appropriate guard bits into that data. In other words, the guard-bit-insertion circuits 1701' and 1703' transform the initial binary data a' and b' into first binary data and second binary data having guard bits, in particular, with zeros at guard-bit positions. The guard-bit-removal circuit 1709' has the opposite function - namely, to receive third binary data c representing a computational result and having guard bits and to remove those guard bits, thereby forming final binary data c' representing the computational result, but without guard bits. The apparatus 1700 also lacks certain features present in the apparatus 1600 because they are not needed in the apparatus 1700. In particular, the apparatus 1700 lacks an input line for the quantity m into the right-shift gate 1719 and into the mask register 1713. Such an input line is not necessary given that m is fixed. Rather, the right-shift gate 1719 is initialized once with the value of m to execute the appropriate right shift. Similarly, the mask register 1713 and the register 1725 are initialized once with the appropriate forms of Ml and PI depending upon whether the single-guard-bit representation or multiple-guard-bit representation is being used. Conventional electrical connections can be used for carrying out these initializations and are not shown in FIG. 17. In respects other than the operational distinctions noted above, the operation of the apparatus 1700 illustrated in FIG. 17 is substantially similar to that described for the apparatus 1600 illustrated in FIG. 16, and no further discussion is necessary. In the apparatus 1700 as described above, the first register 1701 and the guard-bit insertion circuit 1701' can be viewed as means for storing first binary data. The second register 1703 and the guard bit insertion circuit 1703' can be viewed as means for storing second binary data. Further, the register 1709 can be viewed as means for storing third binary data. Moreover, the clock/logic device 1705 and any or all of the remaining devices illustrated in FIG. 7 can be viewed as means for executing at least one operation on the first binary data and the second binary data. Multiplication of field elements in GF(pk) where p=2m+l can be carried out using the exemplary forms of GFjp_k_MUL previously described with reference to FIGS. 9-12 for p=2m-l for both the single-guard-bit representation and multiple-guard-bit representation. It is merely necessary to recognize that m+2 bits (not including guard bits) are allocated to store each group of data bits representing a coefficient of a field element of GF(pfc) for p=2m+l as opposed to m bits for the case where p=2m-l. This difference, of course, must also be applied to the form of the DLOG and ANTILOG tables. Where the compression function (COMP) and decompression function (DECOMP) are utilized with the multiple-guard-bit representation, these functions must also take into consideration that m+2 bits, rather than m bits, are allocated to store each group of data bits representing a field coefficient. Addition and Multiplication in GF(pk) -wherep—TM In another aspect of the present invention, the above-described treatments of carrying out computations in GF(pk) for p=2m-l and p=2m+l can be extended to p of the form p=2ni±d. Here, it is assumed that is assumed that d&gt;l and d is odd. Moreover, the choices of m and d are such that the resulting p is an odd prime. Where a given prime can be written as both p=2m-d and p=2m+d for different choices of m and d, it is preferable to use the form that allows the smallest value of d. For example, p=ll can be written as both p=23+3 (m=3, d=3) and as p=24-5 (m=4, d=5). It is preferable to use the choice p=23+3 where m=3 and d=3. Approaches for carrying out addition and multiplication in GFfp11) - that is, approaches for implementing GF__p_k_ADD and GF_p_k_MUL - for p=2m ±d will now be described. For the case p=2m±d, binary data representing field elements of GFCp") can be stored in hardware registers according to either the single-guard-bit representation or the multiple-guard-bit representation, such as described previously, except that for p=2m-d, m+1 bits (not including guard bits) are allocated for each group of data bits representing a coefficient of a field element, and that for p=2m+d, m+2 bits (not including guard bits) are allocated for each group of data bits representing a coefficient of a field element. For example, in the single-guard-bit representation for p=2m-d, first binary data (register contents a) representing a first field element a; of GF(pk), . wherein the first binary data comprises k groups of first data bits, can be stored as follows. Here it is assumed that (m+2)k is at most the hardware word size (i.e., register size). Let ctj be a first field element of GF(p*) where o^cc^y, ..., o^j) and where each Oj4 belongs to the a Sp (which will be a certain set Sp"d or Sp+d, depending on the form of p, as discussed below). A group of first data bits representing o^ is stored in a first register in bit positions 0, 1, ... , m. A first guard bit having a value of zero is stored in the first register in bit position m+1 (a guard-bit position). Another group of first data bits representing a^ is stored in the first register in bit positions m+2, ..., 2m+2, and so on. Accordingly, there is one first guard bit in every bit position v(m+2)-l where v=l, 2, ... - that is, every successive (m+l)-th bit position. In other words, there is one first guard bit positioned adjacent to the most significant bit of each group of first data bits. Second binary data (register contents b) comprising k groups of second data bits representing a second field element of GF(p^) can similarly be stored in a second register with one second guard bit adjacent to the most significant bit of each group of second data bits. (The use of "first" and "second" is merely distinguish between attributes corresponding to the first field element and the second field element, respectively.) By storing binary data representing first and second field elements of GF(p^ in first and second hardware registers in this manner", no carry bit will propagate from one group of data bits representing a field coefficient into an adjacent group of data bits representing another field coefficient. The approach for storing binary data representing field elements according to the multiple-guard-bit representation is completely analogous, the only difference being that more than one guard-bit position is provided between adjacent groups of data bits representing field coefficients. Addition in GF(p*) (that is, implementing GFjp_k_ADD) for the case where p~2m-d will now be described with reference to FIGS. 18 and 19. The case where p=2m-d can be treated by extending the approach used for p=2m-l. It is assumed that d&gt; 1 and d is odd. It may be assumed, obviously, that 1 <d>m} instead of {((a+b)&amp;M2)&gt; &gt;m}. That is, the quantity c2 in step 1805 has a multiplicative factor of "d" that is not present in step 405 shown in FIG. 4. The multiplication * by d is multiplication that is conventionally carried out with known processors (e.g., normal integer multiplication or floating-point multiplication). Binary data representing the quantity d is stored in the right-most bit positions of register with zeros elsewhere. In other words, if d were viewed as a vector quantity • with coefficients corresponding to groups of data bits associated with field elements, the vector quantity would be (0, 0, 0, ..., d). Thus, implementing the approach 1800 illustrated in FIG. 18 provides third binary data, c, that represents the sum of first and second field elements of GFtp*). Of course, the sequence of carrying out the operations shown in FIG. 18 can vary from the sequence illustrated in FIG. 18, such as has been previously described. Different sequences can be used as long as the quantity c is determined in accordance with the relation. where a, b, c, Ml and M2 are as described above. Note equation 37 reduces to Equation 13 for the case d=1. It will now be shown that the set Sp"*1 is closed under the operations shown in equation 37 (addition followed by modular reduction) where a and b each comprise k groups of data bits 3j and bj5 respectively, where j=0, ..., k-1 and where each ^ and bj represents a group of data bits corresponding to an element of the set Sp"d={0, 1, ... , 2m+d-l} referred to above. Then, with regard to each individual coefficient of the first and second field elements of GFQ*), respectively, it can be seen Ihat aj+bj^2m+I+2d-2 (this equation is intended to reflect a comparison of the integer values represented by % and bj). Note that a function defined by h(x)=(x mod 2m)-t-d(x div 2m) (corresponding to equation 43 above) is a "sawtooth" function which monotonically increases locally on each interval of form {t2m, (t+l)2m-l}. Furthermore, for y0, each c, of the result c is indeed a correct representation of (aj+bj) mod p, up to a multiple of p. Of course, the modular reduction may now take more time, and one question is how many times the reduction represented by equation 39 above is carried out. Under the approach described above, it can be seen that the reduction is carried out at most twice. In particular, suppose that a Cj in equation 38 becomes at least c&gt;2m (otherwise there is nothing to show). Since a,- and bj represent coefficients that are elements of Sp, it is also true that cl. Then, because cj-2pK) is true if and only if at least one of the Cj satisfies Cj&gt;2m. Note that even if some other Cj 2m-1 can be treated by the previously described methods, simply by rewriting p as p=2m'±d' where m' and d' are appropriately chosen.) First, an exemplary approach 2000 for implementing GF_p_k_ADD where d <br>
l, as discussed above. An exemplary approach 2100 for implementing GF_p_k_ADD where p/6<d representation single-guard-bit used also applicable not however if div function equation representation. both description case above addition already gfjp_k_add previously size noted actually now approach range d available smaller multiple-guard-bit reference indeed reduction sp case. reasonable when found operation. under closed find difficult analogy h notice considering fact reduction. larger get clear done was what reductions performing repeatedly gf moreover in the interval p ... has fixed-points z for all that interval. of repeated therefore needs slight modification. this situation set will instead be given by independent note m bits are needed storage each coefficient including guard bit can then carried out accordance with a slightly modified modular algorithm as reflected fig. particular it seen steps and shown same respectively except step is written using c="a+b," notation utilized reassignment quantity occurs prescriptions determining quantities ml m2 pi exact forms course depend upon whether or accordingly no further discussion necessary. illustrated compared to regard decision determines any cj result represents an integer value greater than similar described answer yes repeated. other words hi executes operations equations where understood>2m+I is shorthand for determining whether a group of data bits Cj represents an integer value greater than 2m+I. The implementation of the loop represented by equation 42 is similar to that described with reference to equation 39 and FIG. 19. A difference is that in the previous case the test could be implemented by checking if (c &amp; M2) was zero or not. In the present case, the test can be carried out by checking whether (c &amp; M7) is zero or not, where M7 is a new binary quantity that is the same as M2, except that bit m, and in general, the least significant non-zero bit of any given segment of M2, is reset to zero. (For example, whereas the quantity M2 illustrated in the example of FIG. 15 is given by repeated occurrences of (1, 1,0, 0) as indicated by reference numeral 1511, the quantity M7 as described above would be given by repeated occurrences of (1, 0, 0, 0) for the test for the present case, with guard bits in appropriate positions.) It can be easily seen by those of ordinary skill hi the art that by using the above-noted choice of Sp and the test condition in equation 42, the reduction will eventually terminate, with all components of c being smaller than 2<d a multiplier circuit performing multiplication by the given quantity d is inserted between output connection of right-shift gate and input register i.e. at location indicated in fig. for same type can be complete analogy appartuses illustrated figs. modified with land locations those figures respectively to modify them general case p="2m+d,"> 1. Similar to the efficiency enhancements described above for p=2m-l, efficiency enhancements are also expected for approaches for p=2m+l, p=2m-d and p=2m+d. For example, for addition for k=3, the present methods described herein are expected to be about 8 times faster than the conventional approach (which does not involve parallelization as does the present invention). For k=8 and k=10, the present methods described herein are expected to be about 15 times faster than the conventional approach. Parallel Addition with Non-prime Moduli As should be clear to those of ordinary skill in the art, in none of the cases for describing k parallel additions modulo p=2m± d, d &gt; 1, did we actually make use of the fact that p was a prime number. While using prime p is important for multiplication in finite fields (otherwise, the group is not cyclic and no generator/log-tables can be found), addition operations are well defined and completely analogous even if p is not prime. Thus, in another aspect of the present invention, the exemplary approaches described above for GF_p_k_ADD can be used to perform k parallel additions modulo p for any p (prime or not) that is close to a power of 2, i.e. p=2m± d. In complete analogy, the above-described approaches can be used for different functional forms of p depending on the sign in front of d, and the magnitude of d. Other Aspects, Including Cryptography and Error Correction In another aspect of the present invention, the approaches described above can be used in an error correction apparatus and in a method of error correction. The purpose of an error correcting code is to enable a receiver to reconstruct an original message even if the message disturbed by errors in transit, i.e. to correct the errors in the received message. This is done by introducing redundancy to the message. As known to those of ordinary skill in the art, a number of check equations are utilized in error-correcting codes. Upon reception of a message, the receiver can determine if an error occurred by checking the received data in accordance with these equations, and if so, can also determine the error. Depending upon these equations, which define the error-correcting code, multiple errors can sometimes be corrected. In many cases the codes/equations are constructed using finite field arithmetic. The code will then consist of N-tuples (or "vectors") of the form g=(g0, g]s .--, gN -i) where each g; is an element in GF(q) for some q. Note that only a relatively small set of all such possible g can be valid code words; if all g were allowed, it would be impossible to tell whether an error occurred or not. Conventionally, each message is mapped into such an N-tuple and transmitted. If a limited number of the gs are corrupted, the receiver can still retrieve g to obtain the original message. Examples of such codes include Reed-Solomon codes, BCH codes, and Goppa codes known to those of ordinary skill in the art, such as described in The Theory of Error Correcting Codes by F. J. MacWilliams and N. J. A. Sloane, Elsevier Science B.V., Amsterdam, 1977. As noted above, these codes can utilize arithmetic operations over finite fields. However, conventional implementations of such codes either utilize binary finite fields or utilize odd-characteristic finite fields in the conventional inefficient manner in which a single coefficient of GF(pk) is operated upon in a hardware register. In contrast, the present invention provides an approach for carrying out error correction involving odd-characteristic finite fields in which data representing coefficients of a finite field are processed in a parallel and highly efficient manner by storing binary data representing multiple coefficients of an odd characteristic finite field in a single hardware register and by processing the binary data representing the multiple coefficients in parallel. A conventional approach for decoding a BCH code, such as discussed in The Theory of Error Correcting Codes referred to previously, can be described as follows. The field F=GF(q) is the field of q=pn elements, and we let w denote the multiplicative order of q modulo N (i.e., w is the smallest y such that qy=l mod N). Let an element a in GF(qN) be a primitive N-th root of unity, i.e., N is the smallest integer for which ccN=l in that field. Important special cases occur when N=qw-l, which corresponds to a primitive BCH code, and wheiTN=q-r, which corresponds to a Reed-Solomon code. The corresponding BCH code will consist of all N-dimensional vectors g=(g0, gi, ••-, en-i) with components in GF(q) that satisfy the matrix-vector equation HgT=0, where H is a (D-l)-by-N matrix given by where T denotes transpose and where D can assume any value between 1 and N-l. This description pertains to a narrow sense BCH code, which is not the most general form. In an aspect of the present invention, an exemplary error-correcting apparatus 2200 is provided, such as illustrated in the block diagram of FIG. 22. The apparatus 2200 comprises an input device 220.1 (which can also be an input/output device, for example) that receives a signal intended to represent an allowed code word of an error correcting code and a processing unit 2203 programmed for error correction. The apparatus 2200 can also comprise a memory that can be accessed by the processing unit 2203 (e.g., to retrieve a computer program that can cause the processing unit to execute steps of the approaches described herein) and that can store binary data provided by the processor (e.g., calculation results). The signal can be binary data or it can be an analog signal that is converted (e.g., mapped with a mapping device) to binary data in the input/output unit 2201. The phrase "binary data intended to represent an allowed code word" as used herein is intended to encompass both of these possibilities. The processing unit 2203 can be any suitable processing unit, including conventional or specialized processors, for carrying out the approaches described herein, and the input/output unit 22 can be any suitable interface or device for inputting/outputting data. For example, the processing unit 2203 can be the processing unit of a conventional computer, and the input/output device 2201 can be a conventional modem. As another example, the processing unit 2203 can be that of a hand-held device, such as a mobile telephone or personal digital assistant, and the input/output device 2201 can be a wireless receiver/transmitter. As another example, the processing unit 2203 can be that of a compact disk (CD) player or digital video disk (DVD) player, and the input/output device can be an optical signal receiver that receives a signal from a laser beam modulated by the CD or DVD and outputs a corresponding electrical signal. The processing unit is programmed to correct errors in the binary data where allowed code words are N-tuples of field elements of GF(p*). The finite field GF(pft) is an extension field of a base field GF(pk) where p is an odd prime number and where field elements of GF(pt) comprise k base coefficients. A portion of the binary data comprises k groups of data bits and represents a field element of GF(pk) wherein the field GF(pk) has k base coefficients in accordance with a polynomial basis representation, each group of data bits representing a corresponding one of the k base coefficients. The portion of the binary data is stored in a register, and the processing unit processing processes the portion of the binary data such mat the k groups of data bits are processed in parallel using, for example, arithmetic operations previously described above. This will be described in greater detail below. In particular, the error-correcting apparatus 2200 can be programmed for error correction according to the present invention using an exemplary approach 2300 illustrated in FIG. 23. .For example, the approach 2300 can be implemented for decoding a BCH code in which the inventive computational approaches described previously are applied to the matrix formulation for error correction described above with reference to equation 50. The approach 2300 can correct d/2 errors (and sometimes more errors) in received binary data g'=(g'03 g'l5 ... , g'N_i) intended to represent an allowed code word. First, as indicated at step 2301 in FIG. 23, the error-correcting apparatus receives binary data intended to represent an allowed code word of an error correcting code wherein the allowed code word is an N-tuple of field elements of GF(p*) where p is an odd prime number. In other words, each allowed code word comprises N field elements of GFCp*). The binary data can be received directly or can be converted from an analog signal as noted above. In addition, each field element of GF(p*) can be viewed as comprising / primary coefficients in accordance with a polynomial basis representation, wherein each primary coefficient is a field element of GF(pk) having k base coefficients. The binary data intended to represent an allowed code word can be viewed as comprising N collections of data bits, wherein each collection of data bits comprises / segments of data bits, each segment of data bits representing a corresponding one of the 7 primary coefficients. Further, each segment of data bits can be viewed as comprising k groups of data bits, wherein each group of data bits represents a corresponding one of the k base coefficients. As indicated at step 2303, the error-correcting apparatus 2200 then calculates a syndrome based upon the received binary data, wherein a given portion of the binary data (e.g., a given segment of data bits corresponding to one of the / primary coefficients) is stored in a register, and wherein k groups of data bits of the given portion of the binary data are processed in parallel. In particular, for the example of the matrix formulation described above with reference to equation 43 (pertaining to a BCH code), a syndrome can be calculated as follows. Transmitted binary data g=(g0l gi» •••» sn-i) (°r a transmitted signal corresponding to such binary data) is received as binary data g'=(g'0» g'j, •••, gVi)- Let the error locations in the binary data g' be those indices j for which g'j^ gj5 and let the error values be the (non-zero) values e, in GF(pft) satisfying g'^gj+Cj. Finally, for convenience define T|j=aj where aj is a to the power of j (computed hi the field). Then, in conjunction with the matrix equation 43 referred to above, the syndrome S can be calculated in accordance with the relation giving S=(Sl, 82, ... , Sd.i). It should be noted that the components g'j in g' are elements in GF(p*), and the syndrome entries S; are elements of GF(pNflc), where GF(pNfl£) is an extension field of GF(pflt). In calculating the syndrome S in accordance with equation 44, arithmetic operations must be carried out hi the field GF^*). As noted above, each of the / segments of data bits comprises k groups of data bits, each group of data bits represents a corresponding one of the k base coefficients. As reflected at step 2303, the syndrome is calculated such that k groups of data bits stored hi a register are processed in parallel using, for example, exemplary implementations of GF_p_k_ADD and GF_p_k_MUL, as well as any other needed operations, described previously. Next, as indicated at step 2305, it is determined whether the syndrome S is equal to zero, i.e., whether S=0=(0, 0, ..., 0). If S=0, then no error occurred, and the procedure skips to step 2309 where it is determined whether more data should be processed. If S*0, the procedure proceeds to step 2307 where the errors are detected. As indicated at step 2307, the error-correcting apparatus detects errors in an errbr-:ontaining portion of the binary data (e.g., an error-containing segment of data bits) based upon the syndrome, and corrects the errors in the error-containing portion of the binary data by processing k groups of data bits of the error-containing portion of the1 binary data hi parallel'. This process is repeated for all error-containing portions of the jinary data. For example, with regard to the matrix formulation of equation 44 pertaining to a BCH code, assuming r errors occurred, equation 45 below must be satisfied for each j, where for some e4 (the error values) in GFCp"1) and some ti^ belonging to the set {%, ..., ti „.,} (the error locations). Moreover, hi determining the error values in accordance with this example, the maximum number r must be determined, such that the system of equations (where l operation to provide The operations in equation 49 may be thought of as a land of exponentiation wherein z=g*. In the remainder of the description, we genetically use gx to denote the composition of the group operation with itself, x times acting on g. From the context it will always be clear if this operation is finite field multiplication, or, elliptic curve point addition. In the elliptic curve case, this thus gives rise to a special case of the discrete logarithm problem referred to previously. Current state of the art suggests that the elliptic curve version of the discrete logarithm can be harder to solve than in other settings, making it especially attractive for cryptography. According to an aspect of the present invention, there is provided a cryptographic apparatus comprising a key source and an odd-characteristic finite-field cryptographic unit coupled to the key source for use in a cryptographic system, such as the exemplary cryptographic system illustrated in FIG. 24A. The cryptographic apparatus is configured to implement cryptographic computations involving the field GF^11) (p being an odd prime) and can utilize the single-guard-bit representation or the multiple-guard-bit representation. An exemplary cryptographic system according to the present invention will now be described with reference to FIG. 24A. FIG. 24A is a functional block diagram illustrating a cryptographic system 2400 comprising a first cryptographic apparatus 2401, a second cryptographic apparatus 2403, a first transceiver 2405 for transmitting and receiving ciphertext over an insecure channel 2417, and a second transceiver 2407 for transmitting and receiving ciphertext over the insecure channel 2417. An eavesdropper 2419 is assumed to be able to observe the communications over the insecure channel 2417. The first cryptographic apparatus 2401 comprises a first key source 2409 and a first odd-characteristic finite-field cryptographic unit 2411 (also referred to herein as the first FFCU) for encrypting and decrypting messages. Either or both the first key source 2409 and the first FFCU 2411 can be implemented, for example, using one or more processing units of a conventional computer or of a hand-held device such as a mobile phone. In addition, the first cryptographic apparatus 2401 can also comprise a memory that can be accessed by the FFCU 2411 (e.g., to retrieve a computer program that can cause the FFCU 2411 to execute steps of cryptographic approaches described herein) and that can store binary data provided by the FFCU 2411 (e.g., calculation results). The second cryptographic apparatus 2403 comprises a second key source 2413 and a second odd-characteristic finite-field cryptographic unit 2415 (also referred to herein as the second FFCU 2415) for encrypting and decrypting messages. (Here, "first" and "second" are used merely to distinguish aspects of the first cryptographic apparatus 2401 and the second cryptographic apparatus 2403.) Either or both the second key source 2413 and the second FFCU 2415 can be implemented, for example, using one or more processing units of a conventional computer or of a hand-held device such as a mobile phone. In addition, the second cryptographic apparatus 2403 can also comprise a memory that can be accessed by the FFCU 2415 (e.g., to retrieve a computer program that can cause the FFCU 2415 to execute steps of cryptographic approaches described herein) and that can store binary data provided by the FFCU 2415 (e.g., calculation results). In addition, the first and second key sources 2409 and 2413 can include random number generators. As noted above, the first cryptographic apparatus 2401 comprises a first key source 2409 and a first odd-characteristic finite-field cryptographic unit (FFCU) 2411 coupled to the key source. In one aspect of the present Invention, the FFCU 2411 (or FFCU 2415) can be configured to execute steps of an exemplary cryptographic method 2450 illustrated in the flow diagram of FIG. 24B. The method 2450 comprises storing binary data representing at least a portion of a field element of an odd-characteristic finite field GFtp*) in a register (e.g., an internal register of a processing unit used to implement the FFCU 2411), p being an odd prime number (step 2451). The field element comprises k coefficients in accordance with a polynomial-basis representation, and the binary data comprises plural groups of data bits, wherein each group of data bits represents an associated one of the k coefficients. The method also comprises processing the binary data in accordance with a cryptographic algorithm such that the plural groups of data bits are processed in parallel (step 2453). Additional details relating to an exemplary operation of the cryptographic system 2400 illustrated hi FIG. 24A and relating to the exemplary cryptographic method 2450 illustrated in FIG. 24B will now be described. The description will address the case where a message is sent from the first cryptographic apparatus 2401 and is received by the second cryptographic apparatus 2403, but the description is equally applicable to the situation where the message originates at the second cryptographic apparatus 2403 and is received by the first cryptographic apparatus 2401. A first converser and a second converser each have secure keys. In one aspect, a secure key can be generated by key exchange according to the present invention. In this regard, the binary data referred to above can be key data, and the cryptographic algorithm referred to above can be a key exchange algorithm such as described below with reference to FIG. 25. A secure key can be thereby exchanged via the insecure channel 2417. Alternatively, in another exemplary aspect, each of the conversers can have a public key/private key pair, wherein the public keys of each converser are made available to the other converser over a public channel. In this regard the binary data referred to above can be message data, and the cryptographic algorithm referred to above can be a public-key encryption algorithm used to encrypt/decrypt the message data, such as described below with reference to Figure 26. As illustrated in FIG. 24A, a secure key generated by key exchange, or a public key, can be provided from the key source 2409 to the first FFCU 2411 of the first encryption apparatus 2401. Plaintext P is provided to the first FFCU 2411, and the plaintext is encrypted by the first FFCU 2411 using a suitable encryption algorithm, thereby generating ciphertext C. The encryption algorithm is agreed upon by the first and second conversers in advance, and the key from key source 2409 is appropriately configured for the encryption algorithm. If key exchange according to the present invention is used to generate a secure key, the encryption algorithm used for encrypting the plaintext can be any suitable encryption algorithm, such as DBS or RSA, for example. If public/private key pairs are used, the encryption algorithm used for encrypting the plaintext can be public-key encryption such as described below with reference to FIGS. 26, 27 and 28 or any suitable encryption algorithm that can be implemented in accordance with the method 2450 illustrated in FIG. 24B. The ciphertext C is then provided to the transceiver 2405 (e.g., a network interface, modem or wireless transmitter/receiver) which transmits the ciphertext C over the insecure channel 2417 to transceiver 2407. It is assumed that the transmission can be observed by an eavesdropper 2419. The ciphertext is then provided to the second FFCU 2415 of the second cryptographic apparatus 2403. The second FFCU 2415 decrypts the ciphertext according to a decryption algorithm that corresponds to the encryption algorithm agreed upon by the first.and second conversers. The decryption algorithm utilizes a key from the key source 2413 in conjunction with the decryption. The key can be, for example, a key generated using key exchange, or a private key corresponding to a public key used for encryption. Additional exemplary aspects according to the present invention relating to FIGS. 24A and 24B will now be discussed. In one aspect of the present invention, the binary data stored in the register can represent all k coefficients the field element. In addition, the plural groups of data bits can be stored in the register such that at least one guard bit is positioned adjacent to the most significant bit of each group of data bits, each group of data bits being separated from an adjacent group of data bits by a corresponding at least one guard bit. One guard bit (single-guard-bit representation) or multiple guard bits (multiple-guard-bit representation) can positioned adjacent to the most significant bit of each group of data bits. An initial value of zero can assigned to each at least one guard bit. In one aspect of the present invention, the cryptographic apparatus 2401 (and/or 2403) can implement key exchange, as one example of the cryptographic method 2450, using computations involving the odd-characteristic finite field GF(pk). Such key exchange can be carried out using the single-guard-bit representation or the multiple-guard-bit representation. An exemplary method 2500 of key exchange according to the present invention, e.g., implemented using the cryptographic system 2400, will now be described with reference to FIGS. 24A and 25. A first converser having a first cryptographic apparatus 2401 and a second converser having a second cryptographic apparatus 2403 want to communicate securely over the insecure channel 2417 such than an eavesdropper cannot decrypt their transmissions. Thus, the first and second conversers must first agree on a key to use for encryption, data authentication, etc. Such a key can be generated using Diffie-Hellman key exchange adapted for finite-field computations over GF(pk) according to the present invention. Conventional Diffie-Helhnan key exchange is described in U.S. Patent No. 4,200,770 (Cryptographic apparatus and method), the entire contents of which are incorporated herein by reference. Moreover, as noted above, conventional key exchange over elliptic curves is described in U.S. Patent No, 5,159,632 previously incorporated herein. The first and second conversers agree on a quantity g, wherein g is an element of a finite field F or a point on an elliptic curve over F, F being an odd-characteristic finite field GFCp11) or an extension field of GF(pk), p being an odd prime number. In practice, g will generate a group over which calculations are carried out, the group having an exponentiation operation. If g is chosen, for example, as a point on an elliptic curve over F, the group can be viewed as an elliptic curve group defined over the F. If g is chosen as an element of F, the group can be viewed as a conventional multiplicative group over the finite field F. In either case, the quantity g should be chosen such that a smallest integer x, where gx= 1, is sufficiently large to provide for sufficient security ("1" is the identity element in the group). For example, the binary representation of this integer x should be at least 160 bits in size in view of the computational power of present generation processors. This smallest integer x can be denoted by |G| (the size of the group). Sufficient security in this regard means that the exponentiation is secure hi the sense that the discrete logarithm problem is intractable (i.e., computationally infeasible). To generate a key, a number xA is generated (step 2501) by the key source 2409 of the first cryptographic unit 2401 associated with the first converser and is provided to the first FFCU 2411. The number xA can be, for example, an integer generated randomly or pseudorandomly, as these terms are conventionally understood in the art. The number xA is not intended to be shared with other conversers, and, in this regard, can be considered a secret number. It will be understood that an integer in this context is intended to include both an integer stored as an integer as well as an integer stored as a floating-point decimal. The first FFCU 2411 generates and sends yA, wherein yA=g*A (step 2503) to the second cryptographic unit 2403 associated with the second converser over the insecure channel 2417. As noted above, g is an element of a finite field F or a point on an elliptic curve over F, F being an odd-characteristic finite field GF(pk) or an extension field of GF(pk), p being an odd prime. The quantity g comprises plural first base coefficients, wherein the first base coefficients are elements of GF(p). For example, if g is chosen as an element of GF^*), then g would comprise k first base coefficients that are elements of GF(p). If g is chosen as an element of an extension field GFtp1*), then g would comprise l-k first base coefficients that are elements of GF(p). If g is chosen as a point on an elliptic curve over GF(pk), then g would comprise 2-k first base coefficients that are elements of GF(p), because g would then be represented by a pair of quantities, both of which are elements of GF(pk). Similarly, if g is chosen as a point on an elliptic curve over GFCp"5), then g would comprise 2-Me base coefficients that are elements of GF(p). The first FFCU 2411 carries out the computation of yA by storing multiple groups of first data bits representing at least some of the plural first base coefficients of g in a first register and by processing the multiple groups of first data bits in parallel to generate yA (step 2503). The multiple groups of first data bits can be stored in the first register such that at least one first guard bit is positioned adjacent to the most significant bit of each group of first data bits, each group of first data bits being separated from an adjacent group of first data bits by a corresponding at least one first guard bit. One first guard bit can be positioned adjacent to the most significant bit of each group of first data bits (i.e., the single-guard-bit representation), or multiple first guard bits can be positioned adjacent to the most significant bit of each group of first data bits (i.e., the multiple-guard-bit representation). An initial value of zero can be assigned to each first guard bit. The computation of yA can be carried out using the exponentiation function referred to in equation 32 such that the multiple groups of first data bits are processed in parallel in the manner previously described. Even though equation 32 was described with regard to p of the form p=2m-l, equation 32 is also applicable for p of the form p=2m+l and p=2m±d,as noted previously. Depending upon the register size of the hardware and the number of first base coefficients that g comprises, it may be possible to store multiple groups of first data bits representing all base coefficients of g in a single register. Similarly, a number xB (e.g., a randomly or pseudorandomly generated integer) is independently generated "by the second key source 2413 of the second cryptographic unit 2403 associated with the second converser and is provided to the second FFCU 2415. The number xB is not intended to be shared with other conversers, and, in this regard, can be considered a secret number. The second FFCU 2415 computes and sends yB=g*B to the first cryptographic unit 2401 over the insecure channel 2417. The second FFCU 2415 can carry out the computation of yB by storing multiple groups of data bits representing at least some of the plural first base coefficients of g in either the single-guard-bit representation or multiple-guard-bit representation in a register and by using the exponentiation function referred to in equation 32 such that the multiple groups of data bits are processed in parallel in the manner previously described. The first FFCU 2411 receives the quantity yB, wherein yB comprises plural second base coefficients, the second base coefficients being elements of GF(p) (step 2505). The FFCU 2411 stores multiple groups of second data bits representing at least some of the plural second base coefficients of yB hi a second register, and then calculates K=(yB)xA by processing the plural groups of second data bits in parallel (step 2507). The second FFCU 2415 computes the same value K in accordance with K=(yA)xB. These computations can also be carried out using exponentiation operation referred to hi equation 32 wherein multiple groups of data bits representing associated base coefficients (elements of GF(p)) of yB and yA are respectively processed in parallel. Under the above assumptions, only the first and second conversers can compute K, and the first and second conversers may use K (or a function thereof) as a key. By implementing the above-described adaptation of Diffie-Hellman key exchange over an elliptic curve or other group defined over GF(p*) using the single-guard-bit representation or multiple-guard-bit representation, the present invention offers increased computational efficiency compared to conventional approaches, which can either be manifested as increased speed compared to conventional approaches or increased security for the same computational effort. Having generated a secure key K hi accordance with the key exchange algorithm described above, the first and second conversers can utilize that key in conjunction with their first and second FFCUs 2411 and 2415, respectively, to encrypt and decrypt exchanged messages. The encryption/decryption algorithm in this regard can be, for example, conventional cryptographic methods such as RSA or DES known to those of ordinary skill in the art, or any other suitable encryption algorithm. The first cryptographic apparatus 2401 and the second cryptographic apparatus 2403 have 'each been described as comprising a finite-field cryptographic unit and a key source. It should be understood that the first finite-field cryptographic unit 2411 and the first key source 2409 of the first cryptographic apparatus 2401 can be implemented using a memory and a processing unit coupled to the memory. In other words, the first cryptographic apparatus 2410 can comprise a memory and a processing unit coupled to the memory, wherein the processing unit is configured to execute steps noted above for the first cryptographic unit. Similarly, the second cryptographic apparatus can also comprise a memory and a processing unit coupled to the memory, wherein the processing unit of the second cryptographic apparatus is configured to execute steps noted above for the second cryptographic unit. Of course, previously described exemplary aspects of the invention including but not limited to the utilization of single or multiple guard bits, storing a portion of a field element or the entire field element in a single register (or storing a portion of or an entire quantity representing a point on an elliptic curve over F in a single register), the options of various functional forms of p, etc. are applicable to the exemplary method 2500 illustrated hi FIG. 25. In another aspect of the present invention, there is provided a method of public-key cryptography as another example of the cryptographic method 2450. An exemplary method of public-key cryptography 2600 according to the present invention will now be described with reference to FIGS. 24A and 26. The exemplary method 2600 corresponds to an adaptation of ElGamal public-key encryption and decryption modified according to the present invention. It will be understood that each cryptographic apparatus 2401 and 2403 illustrated in FIG. 24A can be implemented using a memory and a processing unit coupled to the memory, wherein each respective processing unit executes steps associated with the corresponding cryptographic apparatus. In the exemplary method 2600, the second converser obtains a public key yA associated with a first converser, wherein yA=gxA and wherein xA is the first converser's private key (step 2601). For example, the second converser can receive a transmission comprising the first converser's public key and the quantity g, or the second converser can look-up the first converser's public key and the quantity g from a directory in which this information is published. The quantity g is an element of a finite field F or a point on an elliptic curve over F, wherein F is an odd-characteristic finite field GP^*) or an extension field of GFCp1"), p being an odd prime. The first and second conversers can agree in advance on a particular choice for F to be used and for whether an elliptic curve is to be used, or the first converser can publish this information in a directory along with the public key yA and the quantity g. The quantity yA comprises plural first base coefficients, and the quantity g comprises plural second base coefficients, the first and second base coefficients being elements of GF(p). The first converser can use the first cryptographic apparatus 2401 to generate the public key yA=gxA . The first converser's private key xA can be a randomly or pseudorandomly generated integer as these terms are conventionally understood in the art and is not intended to be shared with other conversers. In this regard, the FFCU 2411 associated with the first converser can store multiple groups of data bits representing coefficients of g in a register and can process the multiple groups of data bits in parallel using the exponentiation operation referred to in equation 32 in conjunction with the single-guard-bit representation or the multiple-guard-bit representation to generate yA. As noted above, the first converser's public key yA can be published hi a directory, but it is intended for the first converser to keep the quantity xA (the private key) secret. The second converser generates a number r (e.g., using a random-number generator or psuedo-random-number generator that can be incorporated, for example, into the key source 2413) and calculates a pair of quantities (u, v)=(gr, f "1(P)*(yA)r) using the FFCU 2415 (e.g. a processing unit), wherein P represents a plaintext message of a set of plaintext messages, f is a mapping Junction that maps at least a portion of a vector space over F to the set of plaintext messages, and * denotes a suitable binary operation on the vector space over F (step 2603). Additional details relating to the mapping function f, the vector space over F and the operation * will be described below and with reference to FIG. 27 (which addresses the case where g is an element of F) and FIG. 28 (which addresses the case where g is a point on an elliptic curve over F). The number r can be a randomly or pseudorandomly generated integer as these terms are conventionally understood in the art. The number r is not intended to be shared with other conversers, and, in this regard, can be considered a secret number. To calculate the quantity v, multiple groups of first data bits representing at least some of the plural first base coefficients of yA are stored in a first register and processed in parallel. The multiple groups of first data bits can be stored in the first register such that at least one first guard bit is positioned adjacent to the most significant bit of each group of first data bits, each group of first data bits being separated from an adjacent group of first data bits by a corresponding at least one first guard bit. In other words, either the single-guard-bit representation or the multiple-guard-bit representation can be used. An initial value of zero can be assigned to each first guard bit. Where, g is chosen to be an element of F, the exponentiation of yA can be carried according to equation 32 described previously. Where g is chosen to be a point on an elliptic curve over F, the exponentiations associated with (yA)r and g3^ denote r-fold (or xA-fold) elliptic-curve point addition. The first and second conversers agree in advance on the set of plaintext messages they will use in their communications. The function f is a mapping function that maps at least a portion of the vector space over F to the set of plaintext messages, and the first and second conversers agree on the mapping function f in advance. For example, the set of plaintext messages can comprise words, sentences and/or individual characters, and each plaintext message can be encoded as an integer. The quantity g will generate a group over which cryptographic calculations are carried out, and the nature of the group depends upon the choice of g. In addition, it will be appreciated by those of ordinary skill in the art that the choice of g (and thus the group) also impacts the dimension of the vector space over F. Moreover, the nature of the group affects how exponentiation is carried out in step 2603 and affects the choice of the binary operation *. For example, the group generated by g can be the finite field F, in which case the vector space is the one-dimensional vector space corresponding to F, and the operation * is multiplication in F. Alternatively, the group generated by g can be a subgroup of the finite field F, in which case the vector space is also the one-dimensional vector space corresponding to F, and * is again multiplication in F. As another alternative, the group generated by g can be an elliptic-curve group over F, and the operation * can be elliptic-curve point addition or component-wise multiplication in F x F as will be discussed in greater detail with reference to FIG. 28. In this latter case, the vector space over F can be chosen according to two options. In the first option, the vector space over F can be the two dimensional vector space corresponding to F x F where "x" denotes the cartesian product. In the second option, the vector space can be a three-dimensional vector space over F hi which projective coordinates known to those of ordinary skill in the art are used hi conjunction with the elliptic-curve group. To the extent that the group generated by g can be smaller than any of the above-noted vector spaces, it can be sufficient for f to map merely a portion , of the vector space over F to the set of plaintext messages. The quantity g should therefore be chosen such that the size of the group generated by g is equal to or larger than the set of plaintext messages. Moreover, it is assumed that the quantities g and yA, which are assumed to be publicly available, are chosen such that determining xA from yA and g would be computationally infeasible. Other considerations involving the relationship between security and the size of the group generated by g will be apparent to those of ordinary skill in the art in view of conventionally known attributes of ElGamal public-key cryptosystems, such as described, for example, in Handbook of Applied Cryptography referred to previously. For example, it is known to those of ordinary skill in the art how to choose the size of a group utilized in conventional ElGamal public-key cryptosy stems. Alternatively, it is also known to those of ordinary skill in the art how to approximate the size of the group based on a given choice of the generator. These aspects are also applicable to the above-described method 2600 according to the present invention. The mapping function f should be chosen such that each element of the group generated by g corresponds to a different plaintext message. In other words, the mapping function f can be uniquely invertible. Alternatively, if the group generated by g is larger than the set of plaintext messages, the mapping function f can be chosen such that more than one element of the group generated by p is associated with the same plaintext message. Where plaintext messages are encoded as integers, the mapping function f can be then chosen such that f is an almost injective mapping from the group generated by g to the set of integers {0, 1, 2, ..., Q-l}, where Q«|G| (|G| is the size of the group). For example, this can be essentially an identity mapping. Choosing a given mapping function f is within the purview of one of ordinary skill in the art in view of the above-described teachings. The second converser then sends the pair of quantities (u, v) to the first converser over the insecure channel 2417 (step 2605). The pair of quantities (u, v) corresponds to an encrypted version of the plaintext message. In addition, the calculation of the quantity u can be carried out by the second converser by storing multiple groups of second data bits representing at least some of the plural second base coefficients of g in a second register and by processing the multiple groups of second data bits in parallel. In this regard either the single-guard-bit representation or the multiple-guard-bit representation can be used. The calculation of gM (to calculate u) can be carried out using exponentiation according to equation 32 or using xA-fold elliptic-curve point addition depending upon the choice for g. The quantities g, u and v can be elements of the finite field F, wherein F can be chosen as GF(pk) or as an extension field of GF(p"). Alternatively, the quantities g, u and v can be points on an elliptic curve over F. The first converser can decrypt a received pair of quantities (u, v), thereby retrieving the plaintext message P, by computing P=f(u"*A * v) where u"** * v=v/uxA and wherein "/" denotes the inverse of the operation of * (step 2607). The quantity u** can be computed by the first FFCU 2411 according to the exponentiation function of equation 32 or according to xA-fold elliptic-curve point addition as appropriate. This computation can be carried out using the single-guard-bit representation or multiple-guard-bit representation, such as described above with regard to key exchange. Only the first converser who knows xA is assumed to be able to decrypt this message. By implementing the above-described adaptation of ElGamal public-key cryptography using the single-guard-bit representation or multiple-guard-bit representation, the present invention offers increased computational efficiency compared to conventional approaches, which can either be manifested as increased speed compared to conventional approaches or increased security for the same computational effort. Of course, previously described exemplary aspects of the invention including but not limited to the utilization of single or multiple guard bits, storing a portion of a field element or the entire field element in a single register (or storing a portion of or an entire quantity representing a point on an elliptic curve over F in a single register), the options of various functional forms of p, etc. are applicable to the exemplary method 2600 illustrated in FIG. 26. Exemplary implementations of the method 2600 will now be described with reference to FIG. 27 (which addresses the case where g is an element of F) and FIG. 28 (which addresses the case where g is a point on an elliptic curve over F). FIG. 27 is a flow diagram of an exemplary method of public-key cryptography 2700. In the exemplary method 2700, the second converser obtains a public key yA associated with a first converser, wherein yA=gxA and wherein xA is the first convener's private key (step 2701). For example, the second converser can receive a transmission comprising the first converser's public key and the quantity g, or the second converser can look-up the first converser's public key and the quantity g from a directory in which this information is published. The quantity g is an element of a finite field F wherein F is an odd-characteristic finite field GF(pk) or an extension field of GF(pk), p being an odd prime. The first and second conveners can agree on particular choices for F to be used in advance, or the first converser can publish this information in a directory along with the public key and the quantity g. The quantity yA comprises plural first base coefficients, and the quantity g comprises plural second base coefficients, the first and second base coefficients being elements of GF(p). The first converser can use the first cryptographic apparatus 2401 to generate the public key yA=gxA. The first converser's private key xA can be a randomly or pseudorandomly generated integer as these terms are conventionally understood hi the art and is not intended to be shared with other conversers. In this regard, the FFCU 2411 associated with the first converser can store multiple groups of data bits representing coefficients of g in a register and can process the multiple groups of data bits in parallel using the exponentiation operation referred to in equation 32 in conjunction with the single-guard-bit representation or the multiple-guard-bit representation to generate yA. As noted above, the first converser's public key yA can be published in a directory, but it is intended for the first converser to keep the quantity xA (the private key) secret. The second converser generates a number r (e.g., using a random-number generator or psuedo-random-number generator that can be incorporated, for example, into the key source 2413) and calculates a pair of quantities (u, v)=(gr, 'f~l(P)*(yAy) using the FFCU 2415 (e.g. a processing unit), wherein * denotes multiplication in F and wherein P represents a plaintext message of a set of plaintext messages (step 2703). The number r can be a randomly or pseudorandomly generated integer as these terms are conventionally understood in the art. The number r is not intended to be shared with other conversers, and, in this regard, can be considered a secret number. To calculate the quantity v, multiple groups of first data bits representing at least some of the plural first base coefficients of yA are stored in a first register and processed in parallel. The multiple groups of first data bits can be stored in the first register such that at least one first guard bit is positioned adjacent to the most significant bit of each group of first data bits, each group of first data bits being separated from an adjacent group of first data bits by a corresponding at least one first guard bit. In other words, either the single-guard-bit representation or the multiple-guard-bit representation can be used. An initial value of zero can be assigned to each at least one first guard bit. In addition, the exponentiation of yA can be carried according to equation 32 described previously. The first and second conversers agree in advance on the set of plaintext messages they will use in their communications. The function f is a mapping function that maps at least a portion of F to the set of plaintext messages, and the first and second conversers agree on the mapping function f in advance. For example, the set of plaintext messages can comprise words, sentences and/or individual characters, and each plaintext message can be encoded as an integer. The quantity g will generate a group over which cryptographic calculations are carried out. This group can be the multiplicative group of the finite field F, or a subgroup of that multiplicative group, depending upon the choice of g. To the extent that the group generated by g can be smaller than F, it can be sufficient for f to map merely a portion of F to the set of plaintext messages. The quantity g should therefore be chosen such that the size of the group generated by g is equal to or larger than the set of plaintext messages. Moreover, it is assumed that the quantities g and yA, which are assumed to be publicly available, are chosen such that determining xA from yA and g would be computationally infeasible. Other considerations involving the relationship between security and the size of the group generated by g will be apparent to those of ordinary skill in the art in view of conventionally known attributes of ElGamal public-key cryptosystems, such as described, for example, in Handbook of Applied Cryptography referred to previously. For example, it is known to those of ordinary skill in the art how to choose the size of a group utilized in conventional ElGamal public-key cryptosystems. Alternatively, it is also known to those of ordinary skill in the art how to approximate the size of the group based on a given choice of the generator. These aspects are also applicable to the above-described method 2600 according to the present invention. The mapping function f should be chosen such that each element of the group generated by g corresponds to a different plaintext message. In other words, the mapping function f can be uniquely invertible. Alternatively, if the group generated by g is larger than the set of plaintext messages, the mapping function f can be chosen such that more than one element of the group generated by p is associated with the same plaintext message-. Where plaintext messages are encoded as integers, the mapping function f can be then chosen such that f is an almost injective mapping from the group generated by g to the set of integers {0, 1, 2, ..., Q-l}, where Q«|G| (|G| is the size of the group). For example, this can be essentially an identity mapping. Choosing a given mapping function f is within the purview of one of ordinary skill hi the art in view of the above-described teachings. The second converse! then sends the pair of quantities (u, v) to the first converser over the insecure channel 2417 (step 2705). The pair of quantities'(u, v) corresponds to an encrypted version of the plaintext message. In addition, the calculation of the quantity u can be carried out by the second converser by storing multiple groups of second data bits representing at least some of the plural second base coefficients of g hi a second register and by processing the multiple groups of second data bits in parallel. In this regard either the single-guard-bit representation or the multiple-guard-bit representation can be used, and the exponentiation of g (to calculate u) can be carried out using equation 32 described previously. The quantities g, u and v can be elements of the finite field F, wherein F can be chosen as GF(pk) or as an extension field of GF(pk). The first converser can decrypt a received pair of quantities (u, v), thereby retrieving the plaintext message P, by computing P=f(u"xA * v) where u** * v=v/uxA and wherein "/" denotes division hi F (step 2707). Carrying out division hi F is within the purview of those of ordinary skill in the art and requires no further discussion. The quantity u** can be computed by the first FFCU 2411 by applying the exponentiation function of equation 32 using the single-guard-bit representation or multiple-guard-bit representation, such as described above with regard to key exchange. Only the first converser who knows xA is assumed to be able to decrypt this message. By implementing the above-described adaptation of ElGamal public-key cryptography over a group defined over GF(p^, or the field itself, using the single-guard-bit representation or multiple-guard-bit representation, the present invention offers increased computational efficiency compared to conventional approaches, which can either be manifested as increased speed compared to conventional approaches or increased security for the same computational effort. Of course, previously described exemplary aspects of the invention including but not limited to the utilization of single or multiple guard bits, storing a portion of a field element or the entire field element in a single register (or storing a portion of or an entire quantity representing a point on an elliptic curve over GFfp11) in a single register), the options of various functional forms of p, etc. are applicable to the exemplary method 2700 illustrated in FIG. 27. The above-described public-key cryptography method 2700 can also be modified according to the present invention for implementation using elliptic curves over F where F is as above. An exemplary method 2800 of public-key cryptography and will now be described with reference to FIG. 28. In fact, the treatment is completely analogous to that described with regard to FIG. 27, and the discussion here will be abbreviated, describing mainly the differences that need to be considered. We assume the first and second converser have agreed on an elliptic curve group, or, that a description of the group to be used is transmitted between the conversers. This can, for instance, be done as a preamble to actual messages. Step 2801 is completely analogous to step 2701 described previously, except that in the method 2800, g is a point on an elliptic curve over F. Thus, in the exemplary method 2800, the second converser obtains a public key yA associated with a first converser, wherein yA=gxA and wherein xA is the first converser's private key (step 2801). The quantity g is a point on an elliptic curve over the finite field F wherein F is an odd-characteristic finite field GFCp*) or an extension field of GF(pk), p being an odd prime. The quantity yA comprises plural first base coefficients, and the quantity g comprises plural second base coefficients, the first and second base coefficients being elements of GF(p). The second converser generates a number r (e.g., using a random-number generator or psuedo-random-number generator that can be incorporated, for example, into the key source 2413) and calculates a pair of quantities (u, v)=(gr, f J(P)*CyA)0 using the FFCU 2415 (e.g. a processing unit), wherein P represents a plaintext message of a set of plaintext messages, wherein * is elliptic-curve point addition or component-wise multiplication in FxF, and wherein r can be generated as described above (step 2803). The function f is a mapping function that maps at least a portion of FxF to the set of plaintext messages, wherein multiple groups of first data bits representing at least some of the plural first data base coefficients of yA are stored hi a first register and processed in parallel to calculate v. Additional aspects relating to the calculation of u and v will be described below. As noted at step 2805, the second converser then sends the pair of quantities (u, v) to the first converser, the pair of quantities corresponding to an encrypted version of the plaintext message. As noted at step 2807, the first converser can then can decrypt a received pair of quantities (u, v), thereby retrieving the plaintext message P, by computing P=f(u"xA * v) where u** * v=v/uxA and wherein "/" denotes the inverse of the operation * (step 2807). Additional details relating to the operation "/" will be described below. The quantity u** can be computed by the first FFCU 2411 by applying the exponentiation function in equation 32 using the single-guard-bit representation or multiple-guard-bit representation, such as described above with regard to key exchange. Only the first converser who knows xA is assumed to be able to decrypt this message. By implementing the above-described adaptation of ElGamal public-key cryptography over an elliptic curve over F using the single-guard-bit representation or multiple-guard-bit representation, the present invention offers increased computational efficiency compared to conventional approaches, which can either he manifested as increased speed compared to conventional approaches or increased security for the same computational effort. Additional aspects relating to calculation of the pair of quantities u and v by the first converser and relating to retrieving a plaintext message P from the pah- of quantities u and v by the first converser will now be described. From a notational point of view, such as already mentioned hi connection to equation 49, the exponentiations associated with (yA)r, gr, etc., now denote r-fold (or xA-fold) elliptic curve point addition. Computing the quantity u is thus completely analogous to the approach set forth with regard to FIG. 27, and u will now be an elliptic curve point. For v, two cases can be considered for the operation * and the mapping function f, as will now be described. In either of the two cases, the second converser needs to compute a value of the form f "1(P)*(yA)r, where (yA)r is now a point on the elliptic curve, i.e. an (x, y)-coordinate pah- in F x F, where x denotes cartesian product, i.e. pairs of elements from F. Thus, f' needs to produce a value that can be composed with this two-dimensional value. In the first case that f can be chosen so that f1 is guaranteed to be a point on the elliptic curve, * can simply be the usual elliptic curve point addition operation. For the first converser in this case, the "/" operation is point subtraction (the inverse of addition, which is well-known to those of ordinary skill in the art). For the first case, the f mapping can be done hi several ways, an example of which is as follows. We can assume that the plaintext message space consists of binary strings of length smaller than Ik Iog2 (p), where 1, k, p are the values defining the field F. Note that this can be assumed without loss of generality, since we can cut a message of longer size into smaller blocks, satisfying this length constraint, and can process each block individually. We can also interpret P in the natural way as a set of base coefficients of the field F. Note that P does not uniquely determine the element associated with this set of base coefficients, since some bits are left unspecified. (The actual position of the unspecified bits can be agreed upon in advance or communicated between the conversers.) We can assign a random value, R, to the unspecified bits, and obtain a value x = x(P, R) in F. This x value is evaluated as the right-hand side of equation 48. As is well-known to those of ordinary skill in the art, the probability that there exists a left-hand y-value satisfying the equality of equation 48 is one half, and if so, finding a matching y-value can be done with well-known methods. If no matching y-value exists, we repeat the process with a new random R, etc. The probability that the process would repeatedly fail for a large number of consecutive attempts is small. The above approach describes how fl can be computed by the second converser. The first converser computes f by simply discarding the y-coordinate of the elliptic curve point, and also by discarding the bit-positions corresponding to the randomly chosen R-bits. The above-described procedure merely serves as an example how to embed messages.as elliptic curve points, other approaches to defining f are possible. With regard to such approaches, it can be slightly complicated in general to assure that the mapping always produces points on the elliptic curve, satisfying equation 48. This concludes the discussion relating to the first exemplary case for choices of the mapping function f and the operation "*" associated with steps 2803 and 2807. In the second exemplary case for choices of the mapping function f and the operation "*", it is not required to carry out the calculations in steps 2803 and 2807 to produce points on an elliptic curve. Thus, approaches involving the second case described here may be more attractive. We now describe one exemplary approach for the second case. In the second case, one chooses f to be a mapping that maps at least a fraction of arbitrary values in F x F to the plaintext space. That is, we produce more or less arbitrary (x, y) coordinate pairs, not necessarily satisfying 48. This is done so that unique decryption is almost always guaranteed (thus, the field F in general needs to be at least as large as the square root of the size of the plaintext space). Finding such f is easy and well-known to those of ordinary skill in the art. For instance, interpreting P as a set of base coefficients, encoded as binary strings, f can be essentially the identity mapping. In the second case, the combination operation * is defined to simply be coordinate-wise multiplication in F, i.e. (a, b) * (x, y) = (ax, by). For the second converser (the receiver in this exemplary description), the operation "/" is correspondingly defined as coordinate-wise division in F (the inverse operation of "*"). The approach of using coordinate-wise multiplication and division rather elliptic curve operations is known in the literature as the Menezes-Vanstone method and can be applied to the present invention as described above. In both of the above-described approaches associated with the two cases for choices of the mapping function f, parallel processing multiple groups of data bits representing base coefficients takes place as described before. Observe that in all of the three above-described approaches according to the present invention relating to FIGS. 27 and 28 (modified ElGamal over F, modified ElGamal over an elliptic curve E over F with plaintext embedding in E, and modified ElGamal over an elliptic curve E over F without plaintext embedding in E), the function f can be viewed as mapping at least a portion of a one-dimensional vector space (that is, F) or two-dimensional vector space over F (e.g., F x F) to the set of plaintext messages. In another exemplary aspect, the method 2800 can be modified such that instead of mapping at least a portion of a two-dimensional vector space over F (that is, F x F) to the set of plaintext messages, the mapping function f can be chosen such that f maps at least a portion of a three-dimensional vector space over F to the set of plaintext messages. In this aspect, projective coordinates in a three dimensional vector space are used in conjunction with an elliptic curve approach. Other aspects of the approach remain the same as those set forth in FIG. 28 for the exemplary method 2800. Projective coordinates are known to those of ordinary skill in the art, and no further discussion of modifying the method 2800 according to this aspect is necessary. In another aspect of the present invention, encryption, decryption and/or authentication can be implemented using a secure key chosen by one of the conversers and exchanged over a secure channel, such as the secure channel 2421 illustrated in FIG. 24A. For example, either the first converser or the second converser can generate a secure key using the first key source 2409 or the second key source 2413. Such a secure key can then be exchanged over the secure channel 2421 (e.g., using a courier). Encryption and decryption can then be carried out using the FFCUs 2411 and 2415 illustrated in FIG. 24A. In this regard, the cryptographic algorithm referred to in FIG. 24B can be any suitable encryption algorithm that can be implemented hi accordance with method 2450, and encrypted information can be thereby transmitted over the insecure channel 2417. As another example, information can be encrypted using any conventional encryption algorithm, and the cryptographic algorithm referred to in FIG. 24B can be any suitable authentication algorithm that can be based upon the secure key exchanged over the secure channel 2421 and that can be implemented in accordance with method 2450. Implementing a suitable authentication algorithm in accordance with method 2450 is within the purview of one of ordinary skill in the art in view of the teachings provided herein. In another aspect of the present invention, a variant of ElGamal public-key cryptography can be implemented using the present inventive approaches over a finite field F, where F is the finite field GF(p*) or an extension field of GFfc*) (p being an odd prime) to provide digital signatures using the cryptographic system 2400 illustrated in FIG. 24A. For example, such a variant based upon the basic DSA (Digital Signature Algorithm) will now be described. Other variants exist as well. Once again, a group defined over F, a quantity g (e.g., an element of F or a point on an elliptic curve over F), and a mapping function f are agreed upon by first and second conversers, such as described above with regard to the exemplary implementation of ElGamal public-key cryptography over GF(pk) according to the present invention in FIG. 26. In addition, the first converser generates a private key xA and a public key yA as described above. To sign a message P (e.g., plaintext or ciphertext encoded as an integer), the first converser can proceed as follows. The first converser generates a number r (e.g., a randomly or pseudorandomly generated integer) using, for example, a random-number generator or a pseudorandom number generator that can be incorporated, for example, into the key source 2409, and computes a=gr using the first FFCU 2411 by applying the exponentiation function 32 in conjunction with either the single-guard-bit representation or multiple-guard-bit representation. The number r is riot intended to be shared with other conversers, and, in this regard, can be considered a secret number. The first converser then computes a solution to the equation where * is ordinary multiplication to find a quantity b that satisfies equation 50. Only the first converser, knowing xA, is assumed to be able to do this. The signature to the message P is then defined as the pair (a, b). The first converser can then sign the plaintext message P using the first FFCU 2411 by applying one of the cryptographic approaches described above, thereby generating the signature, (a, b), and sends P and the pair (a, b) to the second converser over the insecure channel 2417. To verify that the pair (a, b) represents a valid signature on P of the first converser, the second converser computes the following quantities u and v where b"1 is the multiplicative inverse of b and * represents multiplication (conventional multiplication). The second converser then computes g"(yA)v using the second FFCU 2415 by applying the exponentiation function 32 in conjunction with the inventive * approaches for storing plural groups of first data bits representing coefficients of yA in a first register, storing plural groups of second data bits representing coefficients of a representation of g in a second register, processing the plural groups of first data bits in parallel, and processing the plural groups of second data bits in parallel. The second converser accepts the signature as valid if, and only if, g"(yA)v=a. Accordingly, computational approaches involving me field GF(p*) according to the present invention can be applied to digital signatures, and the corresponding computations can be executed in a manner much faster than conventional approaches involving GFtp*) or in a manner that provides significantly greater security against forged signatures for the same computational effort. Using elliptic curves over F according to the present invention is also a possible setting for digital signatures. In the case of elliptic-curves, the differences that need to be considered in comparison to the above-described implementation of digital signatures are completely analogous to the differences in implementation of public-key cryptography where g is an element of a finite field F (FIG. 27) and where g is a point on an elliptic curve over F (FIG. 28). Accordingly, no further discussion of using elliptic curves in conjunction with digital signatures according to the present invention is necessary. In another aspect of the invention, a pseudorandom number generator can be provided that carries out computations in the field GF(p') (p being an odd prime number) using computational approaches previously described herein. A pseudorandom number generator deterministically expands short random seeds to longer strings that appear to be random. Many conventional constructions are known to those of ordinary skill in the art, and such constructions can be based on finite fields and elliptic curves, for example. The inventive computational approaches described herein can be applied to such constructions. For example, let F=GF(pn) be a finite field, defined as an extension field of GF(p*) for some t=n/w where w is an integer. Let g be an field element of F that generates a sufficiently large subgroup of F's multiplicative group. In addition, let f be a function as described above with regard to the application of the present inventive approaches to ElGamal public-key cryptography. Finally, let Tr be trace-mapping well known to those of ordinary skill in the art, which maps elements of F to elements of GF(p') in accordance with the following equation for any x in F. Finally, define the function I(x) as I(x)=gx. Upon input of a random seed s (as a binary encoded integer), the generator is now defined as follows. Let Xo=I(s), and let xi+,=I(f(Xj)) for i=0, 1, 2, .... ,T. In principle T can be taken to be very large, e.g. of magnitude comparable to square root of the field size, though a smaller T will give higher security. In addition, define the output of the pseudorandom number generator to be the concatenation of Tr(Xo), Trfo), Tr(X2&gt;, .... This approach provides an output consisting of pseudorandom elements of GF(pt). If a binary string is desired as output, a suitable conversion function is applied to the outputs. Under the assumption that the discrete logarithm problem in the group is intractable (i.e., computationally infeasible), the above-described pseudorandom number generator will be secure. As indicated above, the pseudorandom number generator utilizes various operations in GF(p*), including addition, multiplication and exponentiation, and the previously described inventive approaches based upon either the single-guard-bit representation or the multiple-guard-bit representation can be used to efficiently carry out the necessary computations. The embodiments described herein are merely illustrative and should not be considered restrictive in any way. The scope of the invention is given by the appended claims, rather than the preceding description, and all variations and equivalents which fall within the range of the claims are intended to be embraced therein. <br><br><br><br><br><br><br><br>
WE CLAIM: <br>
1; A cryptographic and/or error correction apparatus carrying out computations involving field elements of an odd characteristic finite field GF(pk), the apparatus comprising: a memory; and a processing unit coupled to the memory, comprising a general purpose w-bit ALU and two binary general purpose w-bit registers, wherein the processing unit stores binary data representing any two field elements of an odd-characteristic finite field GF(pk) in a first and a second w-bit binary register, p being an odd prime number, the field element comprising k coefficients in accordance with a polynomial-basis representation, the binary data comprising plural groups of data bits, wherein each group of data bits represents an associated one of the k coefficients, the storing being such that at least one guard bit is positioned adjacent to the most significant bit of each group of data bits, each group of data bits being separated from an adjacent group of data bits by a corresponding at least one guard bit, and executing a fixed number of w-bit ALU operations on contents of the registers thereby producing the result of a finite field operation. <br><br>
2. The cryptographic and/or error correction apparatus as claimed in claim 1, wherein the processing unit assigns an initial value of zero to each at least one guard bit. <br><br>
3. The cryptographic and/or error correction apparatus as claimed in claim 1, wherein multiple guard bits are positioned adjacent to the most significant bit of each group of data bits. <br><br>
4. The cryptographic and/or error correction apparatus as claimed in claim 1, wherein the finite field operation is a finite field addition. <br><br>
5. The cryptographic and/or error correction apparatus as claimed in claim 1, wherein the finite field operation is a finite field multiplication. <br><br>
6. The cryptographic and/or error correction apparatus as claimed in claim 4, wherein p = 2m- d, d is an odd integer greater than or equal to 3 and less than 2m-1, m is an integer greater than or equal to 3, each group of first data bits and each group of second data bits is m+1 bits in size m &gt; 1, said execution of a fixed number of w-bit operations comprises combining the contents of first register, and the contents of the second register, in accordance with equation number 37 such as herein described. <br><br>
7. The cryptographic and/or error correction apparatus as claimed in claim 4, wherein p=2m+d, d is an odd integer greater than or equal to 3, m is an integer greater than or equal to 3, and less than 2m- 1, each group of first data bits and each group of second data bits is m+2 bits in size, and p=2N ±1 for any integer N. said execution of a fixed number of w-bit operations comprises combining the contents of first register, and the contents of the second register, in accordance with equation number 40 such as herein described. <br><br>
8. The cryptographic and/or error correction apparatus as claimed in claim 4, wherein p=2m-l, m is an integer greater than or equal to 2, and each group of first data bits and each group of second data bits is m bits in size, said execution of a fixed number of w-bit operations comprises combining the contents of first register, and the contents of the second register, in accordance with equation number 13 such as herein described. <br><br>
9. The cryptographic and/or error correction apparatus as claimed in claim 4, wherein p=2m+l, m is an integer greater than or equal to 2, and each group of first data bits and each group of second data bits is m+2 bits in size, said execution of a fixed number of w-bit operations comprises combining the contents of first register, and the contents of the second register, in accordance with equation number 36 such as herein described. <br><br>
10. The cryptographic and/or error correction apparatus as claimed in claim 5, wherein said execution of a fixed number of w-bit operations comprises combining the contents of first register and the contents of the second register in accordance with equation number 18 such as herein described. <br><br>
11. The cryptographic and/or error correction apparatus as claimed in claim 1, wherein the binary data represents the field element in entirety and wherein said executing at least one operation comprises calculating a quantity given by equation number 32 such as herein described. <br><br><br></d></d></d></cj.></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtQWJzdHJhY3QtKDA1LTA5LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Abstract-(05-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtQWJzdHJhY3QtKDA5LTAzLTIwMDkpLnBkZg==" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Abstract-(09-03-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtQWJzdHJhY3QtKDA5LTA5LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Abstract-(09-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">761-delnp-2005-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtQ2xhaW1zLSgwNS0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Claims-(05-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtQ2xhaW1zLSgwOS0wMy0yMDA5KS5wZGY=" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Claims-(09-03-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtQ2xhaW1zLSgwOS0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Claims-(09-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">761-delnp-2005-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtY29tcGxldGUgc3BlY2lmaWNhdGlvbiAoZ3JhbnRlZCkucGRm" target="_blank" style="word-wrap:break-word;">761-delnp-2005-complete specification (granted).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtQ29ycmVzcG9uZGVuY2UtT3RoZXJzLSgwNS0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Correspondence-Others-(05-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtY29ycmVzcG9uZGVuY2Utb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">761-delnp-2005-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS0wNS0wOS0yMDA4LnBkZg==" target="_blank" style="word-wrap:break-word;">761-delnp-2005-description (complete)-05-09-2008.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">761-delnp-2005-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtRHJhd2luZ3MtKDA1LTA5LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Drawings-(05-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">761-delnp-2005-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtRm9ybS0xLSgwNS0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Form-1-(05-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtRm9ybS0xLSgwOS0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Form-1-(09-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtZm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">761-delnp-2005-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtZm9ybS0xMy5wZGY=" target="_blank" style="word-wrap:break-word;">761-delnp-2005-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtZm9ybS0xOC5wZGY=" target="_blank" style="word-wrap:break-word;">761-delnp-2005-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtRm9ybS0yLSgwNS0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Form-2-(05-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtRm9ybS0yLSgwOS0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Form-2-(09-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtZm9ybS0yLnBkZg==" target="_blank" style="word-wrap:break-word;">761-delnp-2005-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtRm9ybS0yNi0oMDUtMDktMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Form-26-(05-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtZm9ybS0yNi5wZGY=" target="_blank" style="word-wrap:break-word;">761-delnp-2005-form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtRm9ybS0zLSgwNS0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Form-3-(05-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtZm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">761-delnp-2005-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtRm9ybS01LSgwNS0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Form-5-(05-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">761-delnp-2005-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtZ3BhLnBkZg==" target="_blank" style="word-wrap:break-word;">761-delnp-2005-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtcGN0LTMwNC5wZGY=" target="_blank" style="word-wrap:break-word;">761-delnp-2005-pct-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtcGN0LTMwOC5wZGY=" target="_blank" style="word-wrap:break-word;">761-delnp-2005-pct-308.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtcGN0LTQwOS5wZGY=" target="_blank" style="word-wrap:break-word;">761-delnp-2005-pct-409.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtcGN0LTQxNi5wZGY=" target="_blank" style="word-wrap:break-word;">761-delnp-2005-pct-416.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLWRlbG5wLTIwMDUtcGN0LXNlYXJjaCByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">761-delnp-2005-pct-search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzYxLURFTE5QLTIwMDUtUGV0aXRpb24tMTM3LSgwNS0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">761-DELNP-2005-Petition-137-(05-09-2008).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="233900-an-automated-teller-machine.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="233902-a-rotor-for-an-electrical-motor.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>233901</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>761/DELNP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>20/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>15-May-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>17-Apr-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>25-Feb-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>TELEFONAKTIEBOLAGET LM ERICSSON (PUBL.)</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>S-126 25 STOCKHOLM, SWEDEN.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>ROLF BLOM</td>
											<td>SVARDVAGEN 2, S-175 68 JARFALLA, SWEDEN.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>MATS NASLUND</td>
											<td>GRIMSTAGATAN 161, S-162 58 VALLINGBY, SWEDEN.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 7/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/SE2003/001560</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2003-10-07</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/271,947</td>
									<td>2002-10-17</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/233901-a-cryptographic-and-or-error-correction-apparatus by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:57:43 GMT -->
</html>
