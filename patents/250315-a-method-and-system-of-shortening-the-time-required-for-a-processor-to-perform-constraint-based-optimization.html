<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/250315-a-method-and-system-of-shortening-the-time-required-for-a-processor-to-perform-constraint-based-optimization by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:30:23 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 250315:A METHOD AND SYSTEM OF SHORTENING THE TIME REQUIRED FOR A PROCESSOR TO PERFORM CONSTRAINT BASED OPTIMIZATION</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD AND SYSTEM OF SHORTENING THE TIME REQUIRED FOR A PROCESSOR TO PERFORM CONSTRAINT BASED OPTIMIZATION</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The purpose is to solve target problems in short calculation time certainly without describing algorithms that are data procedures on computers. As the solution method, because it is configured so that, when the initial values or variation values, which are used for constraint conditions with regard to target problems and the relevant constraint conditions, are set through Means for Variable Value Setting (2), then Means for Constraint Condition Extraction (3) extracts constraint conditions that are related to those variables, then means for Constraint Condition Calculation (4) searches for the solutions for each constraint condition one by one, and Means for Variable Value Resetting (5) repeats searching for the solutions for each constraint condition setting these searched solutions as new variables, so the course of solution searching becomes clear, and it becomes possible to surely reach the final solution and dramatically speed up computing, because each markedly simplified constraint condition has only to be solved.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>[Name of Document] Description<br>
[Title of the Invention] Constraint-based Solution Method, Constraint-based Solver and<br>
Constraint-based Solution System<br>
[Technical Field]<br>
This invention is relevant to the effective solution concerning the problems<br>
consisting of any constraint condition, and especially, the Constraint-based Solution<br>
Method, Constraint-based Solver, and Constraint-based Solution System, which becomes<br>
practicable only by setting the constraint conditions, of which the procedure for constraint<br>
propagation is considered, and the variable values.<br>
[Background Art]<br>
The procedural programming method, in which the user describes the procedures<br>
of data (algorithm) successively after the procedural declaration of data structures using<br>
programming languages such as, for example, C language and JAVA, is the mainstream of<br>
current common programming methods for various application programs. The procedures<br>
of data by means of this procedural programming are, in principle, correspondent with the<br>
procedures that computers actually execute, except that optimization is performed by the<br>
optimizing functions of compiling programs. Therefore, the procedural programming<br>
method is a solution method, which can flexibly respond to various problems through<br>
describing the details of computer (CPU) behaviors.<br>
As an alternative method for the above-mentioned procedural programming<br>
method, which describes CPU behaviors, there is the declarative programming method.<br>
This is the method to leave everything to the CPU as for actual data procedures after the<br>
constraint conditions which are corresponding to the target problems are defined by the<br>
user, and it has been conventionally used as a convenient problem solution method for<br>
certain problem areas, (e.g. Patent Document 1 or 2)<br>
The aforementioned declarative programming has characteristics that the user has only to<br>
wait for solution to be output just describing constraint conditions, whereas they cannot<br>
interfere with the order in which the CPU executes data processing. Among the<br>
programming methods, which are broadly divided into two aforementioned groups, the<br>
procedural programming method is mainly used in the current computing environment.<br>
If program development is performed in this procedural programming method, as<br>
soon as the user defines the data structure, algorithm, which should be described with the<br>
data structure, is usually determined in conjunction with that. Furthermore, such algorithm<br>
can be expressed in the same procedure and patterned for the similar target problems.<br>
Consequently, it has been a conventional problem that program development becomes<br>
inefficient in that same kind of programming works are overlapped in each application. To<br>
cope with this problem, recently, programming works have been promoted to be highly<br>
efficient through actively introducing the partialization of software by means of the<br>
creation of libraries of programming parts which are commonly used and software<br>
development based on object-orientation, thus focusing on the parts which existing<br>
programs don't have.<br>
[Patent Document 1] Kokai number (1993)3548<br>
[Patent Document 2] Kokai number (1997)81387<br>
[Disclosure of Invention]<br>
[Problems to Be Resolved by the Invention]<br>
However, realistically, the number of software parts which are developed into<br>
libraries is gigantic, and furthermore, it has been increasing every year. Considering the<br>
fact that each programmer made not a few selection mistakes when he or she extracted the<br>
most appropriate parts for the target problem from this gigantic parts group, and that there<br>
was the danger of having to redo the development work by choosing them again, there was<br>
a problem that there were many cases in which each programmer performed coding work<br>
from scratch without utilizing software parts.<br>
Besides, because object-oriented software development required a certain skill, not every<br>
programmer could do object-oriented programming work, and as a whole, there was a<br>
problem that improvement of work efficiency wasn't enhanced so much.<br>
As just described, the present condition is that the excluded aspect that individual skills are<br>
relied on and the inefficient aspect haven't been solved yet.<br>
On the other hand, as mentioned previously, at least the description of constraint<br>
conditions and the data used for the relevant constraint conditions are necessary in the<br>
declarative programming method, and the number of the constraint conditions and data<br>
becomes huge if it is applied to actual problems. An actual problem here is, for example, a<br>
combinatorial optimization problem that satisfies simultaneous equations of fk(Xi, X2,...,<br>
Xn)<bk ... m and that makes evaluation function fo xa xn minimum></bk>
value.<br>
That is, as shown in Fig. 17, the computer (the constraint solver in Fig. 17) searches in a<br>
lump for the data which simultaneously satisfy all constraint conditions if the constraint<br>
conditions expressed with m pieces of simultaneous equations and evaluation function fo<br>
are given to the computer.<br>
This combinatorial optimization problem exponentially increases the possibilities<br>
of combination in the solution space as the number of variable X and simultaneous<br>
equations increase, so procedures on the computer become complex and gigantic. In<br>
addition, especially when the function fk is nonlinear, there are some cases in which<br>
dispersed numerous solution spaces exist, and one device or another to search for the<br>
solution efficiently without searching in solution spaces that have no solution and falling<br>
into infinity loop is necessary. By the way, along with combinatorial optimization problems,<br>
there are also similar problems in combination sufficiency problems, integer programming,<br>
and so on.<br>
Moreover, when it becomes necessary to modify the parts of the condition<br>
equations of constraint conditions or the input data, there were problems of great<br>
inefficiency as well as the waste of resources, because the similar constraint condition<br>
problems that have already been calculated should be re-calculated from scratch.<br>
Consequently, in consideration of the aforementioned problems, this invention is<br>
intended to surely solve target problems in a short calculation time, without describing<br>
algorithms which are data processing procedures on the computer.<br>
[Means for Solving the Problem]<br>
The Constraint-based Solution Method in this invention includes -<br>
Constraint Condition Inputting Processes to input constraint conditions, of which<br>
processing procedures for constraint propagation regarding the target problem are<br>
considered by users;<br>
Variable Value Setting Processes to set the default and variation values used for the<br>
constraint conditions which are input by the above-mentioned Constraint Condition<br>
Inputting Processes;<br>
Constraint Condition Extraction Processes to extract the constraint conditions in relation to<br>
the values which are set by the above-mentioned Variable Value Setting Processes from the<br>
constraint conditions which are input by the above-mentioned Constraint Condition<br>
Inputting Processes;<br>
Constraint Condition Calculation Processes to calculate the solutions of the relevant<br>
constraint conditions, assigning the default or variation values to the above-mentioned<br>
variables, in conformity to the procedure orders of the constraint propagation which are<br>
considered by the above-mentioned users, concerning all of the constraint conditions that<br>
are extracted by the above-mentioned Constraint Condition Extraction Processes; and<br>
Variable Value Resetting Processes to set the solutions calculated by the above-mentioned<br>
Constraint Condition Calculation Processes as the new variation values for the<br>
above-mentioned Variable Value Setting Processes;<br>
and is characterized by the fact that above-mentioned Variable Value Resetting Processes<br>
repeat the execution of the above-mentioned Constraint Condition Extraction Processes and<br>
above-mentioned Constraint Condition Calculation Processes as long as new variation<br>
values which are reset exist.<br>
In the Constraint-based Solution Method of the present invention which includes -<br>
the Constraint Condition Inputting Processes to input constraint conditions,<br>
the Variable Value Setting Processes to set the variation values used for the constraint<br>
conditions which are input by the above-mentioned Constraint Inputting Processes;<br>
the Constraint Condition Extraction Processes to extract the constraint conditions in<br>
relation to the values which are set by the above-mentioned Variable Value Setting<br>
Processes from the constraint conditions which are input by the above-mentioned<br>
Constraint Condition Inputting Processes; and<br>
the constraint solution methods which include the Constraint Condition Calculation<br>
Processes which calculate the solutions of the constraint conditions extracted by the<br>
above-mentioned Constraint Condition Extraction Processes;<br>
above-mentioned constraints are characterized and comprised of at least either of the facts<br>
that the number of current array elements is included, numerous values are given to the<br>
above-mentioned variables, searching by the element values of structure arrays is included,<br>
and that letter strings are converted into numbers by means of the default rule.<br>
The Constraint-based Solver in this invention includes -<br>
Means for Constraint Condition Inputting to input the constraint conditions, of which the<br>
processing procedures for constraint propagation regarding the target problem are<br>
considered by users;<br>
Means for Variable Value Setting to set the default and variation values used for the<br>
constraint conditions which are input by the above-mentioned Means for Constraint<br>
Condition Inputting;<br>
Means for Constraint Condition Extraction to extract the constraint conditions in relation to<br>
the values which are set by the above-mentioned Means for Variable Value Setting from the<br>
constraint conditions which are input by the above-mentioned Means for Constraint<br>
Condition Inputting;<br>
Means for Constraint Condition Calculation to calculate the solutions of the relevant<br>
constraint conditions, assigning the default or variation values to the above-mentioned<br>
variables, in conformity to the procedure orders of the constraint propagation which are<br>
considered by the above-mentioned user, concerning all of the constraint conditions that are<br>
extracted by the above-mentioned Means for Constraint Condition Extraction; and<br>
Means for Variable Value Resetting to set the solutions calculated by the above-mentioned<br>
Means for Constraint Condition Calculation as the new variation values for the<br>
above-mentioned Means for Variable Value Setting;<br>
and is characterized by the fact that above-mentioned Means for Variable Value Resetting<br>
repeat the execution of the above-mentioned Means for Constraint Condition Extraction<br>
and above-mentioned Means for Constraint Condition Calculation as long as new variation<br>
values which are reset exist.<br>
In the Constraint-based Solver of this invention which include -<br>
Means for Constraint Condition Inputting to input constraint conditions,<br>
Means for Variable Value Setting to set the values of variables used for the constraint<br>
conditions which are input by the above-mentioned Means for Constraint Condition<br>
Inputting;<br>
Means for Constraint Condition Extraction to extract the constraint conditions in relation to<br>
the values which are set by the above-mentioned Means for Variable Value Setting from the<br>
constraint conditions which are input by the above-mentioned Means for Constraint<br>
Condition Inputting; and<br>
the constraint solution methods which include Means for Constraint Condition Calculation<br>
which calculate the solutions of the constraint conditions extracted by the above-mentioned<br>
Means for Constraint Condition Extraction;<br>
above-mentioned constraint conditions are characterized and comprised of at least either of<br>
the facts that the number of current array elements is included, numerous values are given<br>
to the above-mentioned variables, searching by the element values of structure arrays is<br>
included, and that letter strings are converted into numbers by means of the default rule.<br>
The Constraint-based Solution System of this invention is characterized in that<br>
numerous hardware are connected to each other to enable communication, and at least one<br>
of the above-mentioned hardware has either function of Constraint-based Solver that was<br>
described above.<br>
[Advantageous Effect of the Invention]<br>
According to this invention, it is comprised so that the procedures, in which<br>
solutions that satisfy each constraint condition are found after extracting constraint<br>
conditions which are related to the relevant values of variables and the solutions of each<br>
above-mentioned constraint condition are found through assigning the given solutions as<br>
the new values of variables (variation values), are repeated when constraint conditions of<br>
which the procedure for constraint propagation is considered and the values of variables<br>
(default values) which are used for constraint conditions are input, thus enabling to find<br>
solutions for each single constraint condition without having any AND relationship with<br>
other constraint conditions, and to find final solutions while performing rapid calculation<br>
procedures.<br>
[Best Mode for Carrying Out the Invention]<br>
Hereinafter, preferred embodiments of the present invention will be described in<br>
detail with referent to the drawings.<br>
Fig. 18 is a conceptual figure that shows the positioning between the conventional<br>
programming language environment and the Constraint-based Solver of the present<br>
invention, which searches for the solutions of constraint conditions. As shown in Fig. 18,<br>
the conventional programming language environment has a programming language<br>
processor, program codes, and data, and it has the mode that programming language<br>
processor controls program codes and data. The present invention has the configuration so<br>
that constraints (constraint conditions) and constraint solvers are provided along with the<br>
data of the conventional programming language environment and that they are connected to<br>
exchange information with each other.<br>
In addition, Fig. 19 also shows the conventional programming language environment, but it<br>
is the configuration figure in which the aforementioned conventional Constraint-based<br>
Solver is composed in the form of library.<br>
(The First Embodiment)<br>
At first, the basic configuration and the basic operation of the Constraint-based Solver in<br>
the first embodiment of the present invention will be explained.<br><basic configuration of the constraint-based solver><br>
Fig. 1 is the overall configuration figure indicating the basic constituent elements of the<br>
Constraint-based Solver 100.<br>
As shown in Fig.l, the Constraint-based Solver 100. contains Means for Constraint<br>
Condition Inputting 1, Means for Variable Value Setting 2, Means for Constraint Condition<br>
Extraction 3, Means for Constraint Condition Calculation 4, and Means for Variable Value<br>
Resetting 5.<br>
Means for Constraint Condition Inputting 1 is to input the constraint conditions<br>
that the user decided to use through imagining the procedures of constraint propagation by<br>
the computer (CPU).<br>
Means for Variable Value Setting 2 is to set up specific initial values that the user assigns<br>
for each variable that comprises the constraint constraints, which were input with Means<br>
for Constraint Condition Inputting 1. Moreover, as described in detail later, it also sets up<br>
the values other than initial values (hereinafter, referred to as variation values) to each<br>
variable.<br>
Besides, Means for Constraint Condition Inputting 1 and Means for Variable Value Setting<br>
2 are so to speak User Interfaces for data input and have no limit in particular, and contain<br>
various tools to make it easier to input and can be equipped with display (monitor) screens<br>
in which values which are input by the user can be confirmed. In addition, a configuration<br>
containing output-indicating means (not shown in the figure) that submit the values<br>
calculated by the Constraint-based Solver 100 to the user can be permitted. This<br>
output-indicating means also can be equipped with display (monitor) screens on which<br>
output values can be confirmed. Furthermore, it can be input-output means that can input<br>
and output data by making it one of the Means for Constraint Condition Inputting 1<br>
(including Means for Variable Value Setting 2) and output-indicating means.<br>
Means for Constraint Condition Extraction 3 extracts constraint conditions bearing<br>
each variable to which an initial value or variation value as a constituent element is set<br>
from the constraint conditions that are input. In this embodiment, Means for Constraint<br>
Condition Extraction 3 is configured so that relevant constraint conditions are extracted in a<br>
mass, but it is no problem to extract one at a time, so that the solution of a constraint<br>
condition with Means for Constraint Condition Calculation 4 to be hereinafter described<br>
and the extraction of the next constraint condition are repeated in order.<br>
Although Means for Constraint Condition Calculation 4 solves each constraint<br>
condition to which initial values or variation values are assigned, as the characteristics of<br>
the present invention, it is not solved in a lot as a so-called simultaneous solution that<br>
satisfies all constraint conditions, but each constraint condition is targeted to be solved one<br>
by one. Consequently, if a value of a certain variable is set or changed, the first solutions of<br>
constraint conditions are given in order, according to the predetermined order sequentially.<br>
The above-mentioned predetermined order here is the order that is indicated in the<br>
constraint conditions that the user (programmer) has input in consideration of the<br>
procedures for constraint propagation.<br>
Here are the concrete examples of constraint conditions.<br>
(A) Example 1 of Constraint Conditions<br>
The following accounting calculation problem can be cited as a typical example used as the<br>
explanation to readily understand the declarative programming method.<br>
When each price and quantity of four items is set as (1)¥100, 2 pieces, (2)¥200, 3 pieces,<br>
(3)¥300, 2 pieces, (4)¥50, 3 pieces, if the constraint conditions in the present invention are<br>
expressed with the array variables of prices, quantities, and subtotals, they are expressed as<br>
follows;<br>
price[l] = 100, price[2] = 200, price[3]= 300, price[4]= 50 ...(Formula 1)<br>
quantity[l] = 2, quantity[2] = 3, quantity[3] = 2, quantity[4] = 3 ...(Formula 2)<br>
subtotal[i] = price[i] * quantity[i] (i=l to 4).. .(Formula 3)<br>
total = £ subtotal [i] (i=l to 4).. .(Formula 4)<br>
(Formula 1) and (Formula 2) are especially the setting of variable data among constraint<br>
conditions.<br>
As evidenced by the above-mentioned descriptions of (Formula 1) to (Formula 4),<br>
10<br>
the descriptions of repetitive loops, which are necessary for the procedural programming<br>
method, such as 0 -» total ("-»" means assignment and hereinafter referred to as such),<br>
total + subtotalfl] -» total, total + subtotal[2] -&gt; total, total + subtotal[3] -&gt; total, and<br>
total + subtotal[4] -* total, are unnecessary for the declarative programming method.<br>
(B) Example 2 of Constraint Conditions<br>
string name, message, outputs, output; .. .(Formula 5)<br>
name="Tokkyo Taro" .. .(Formula 6)<br>
message="Hello. This sentence is a book of HTML documents." .. .(Formula 7)<br>
outputs="Name" &amp; name &amp; "Message" &amp; message; .. .(Formula 8)<br>
output = "" &amp; outputs &amp;  .. .(Formula 9)<br>
Above-mentioned (Formula 5) is the definition of variable data, (Formula 6) and (Formula<br>
7) are value assignments to the variables, and above-mentioned (Formula 8) and (Formula<br>
9) are specific execution formulas. Besides, the operator &amp; is a string concatenation<br>
operator.<br>
As shown in (Formula 6) and (Formula 7) above, HTML texts, which are output with<br>
"output" after arbitrarily rewriting "name" and "message," are generated.<br>
(C) Example 3 of Constraint Conditions<br>
The constraint conditions that describe the operation to continuously concatenate a string<br>
"str" to another string "add" are shown as follows.<br>
string str; ... (Formula 10)<br>
string add; ... (Formula 11)<br>
str = str &amp; add .. .(Formula 12)<br>
Above-mentioned (Formula 10) and (Formula 11) are the definitions of variable data, and<br>
above-mentioned (Formula 12) is a specific execution formula. The constraint propagation<br>
caused by the value change of the string "str" in this example is that the value of the string<br>
"add" is repeatedly added to the string "str" every time the value of the string "add" is<br>
changed.<br>
Here it must be noted that constraint conditions don't have to be such formulas<br>
expressed with equal signs or inequality signs that are shown in above-mentioned (A) to<br>
(C). Besides, as for the evaluation of the constraints, true or false is finally given as an<br>
answer, and as is the case with C language and others, for example, if only f(x) is described<br>
as a constraint condition, this f(x) is executed, and the result is judged and processed<br>
depending on whether it is true or false.<br>
Means for Variable Value Resetting 5 sets the first solutions that are given with<br>
Means for Constraint Condition Calculation 4 as new values, that is, variation values, so<br>
that the second and later solutions are given with Means for Constraint Condition<br>
Extraction 3 and Means for Constraint Condition Calculation 4. Besides, a series of<br>
procedures to search for the solutions of the constraint conditions terminate when the<br>
Constraint-based Solver 100 receives the end command separately after the final solution is<br>
attained without any further solution to be modified with Means for Constraint Condition<br>
Calculation 4.<br>
As mentioned above, one of the characteristics of the present invention is to<br>
repeatedly give the solutions of each constraint condition in order by assigning values to<br>
the variables of each constraint condition that is extracted. To enable this, it is based on the<br>
premise that the user sets up the constraint conditions in advance in consideration of the<br>
procedure of constraint propagation.<br>
By the way, if it lapses into the conditions of solution inability that the solution<br>
cannot be given or solution indetermination that the solution cannot be specified during the<br>
process of Means for Constraint Condition Calculation 4, they are output as program errors<br>
by seeing to it that appropriate exception handling, which is previously defined on the<br>
computer, is executed. However, that means the user has defined constraint conditions that<br>
cannot be solved. As for Constraint-based Solver 100, the user shoulders the burden that<br>
constraint conditions must be set up in consideration of the procedures of the computer so<br>
that they will be procedures which must be essentially soluble, which is much easier work<br>
compared to that of the conventional procedural programming method.<br>
Overall Operation of the Constraint-based Solver 100<br>
Then, the overall operation of the Constraint-based Solver 100 with the aforementioned<br>
configuration is explained.<br>
Fig. 2 is the flow chart showing the operation order of the Constraint-based Solver 100.<br>
At first, whether initial values are set to variables, which are used in constraint conditions,<br>
or not is judged in the step S20. As a result of the above-mentioned judgment, if initial<br>
values have not been set to each variable that comprises constraint conditions which are<br>
input by Means for Constraint Condition Inputting 1, Means for Variable Value Setting 2<br>
sets the initial values designated by the user in the step S21.<br>
Then, Means for Constraint Condition Extraction 3 judges if the values of each<br>
variable have been modified or not in the step S22. When initial values are set to variables<br>
as constraints, it is regarded as the first modification and proceeds to the next step S22.<br>
Once the initial values are set and the after-mentioned procedures of the steps are finished,<br>
the Constraint-based Solver 100 maintains the waiting condition until the new value<br>
modification of variables are executed in this step S22. In addition, although "completion"<br>
is not shown in this flow chart, when the indication command of operation completion is<br>
input externally, the Constraint-based Solver 100 is controlled so that it will execute the<br>
predefined operating process (not shown in the figure) and will terminate a series of<br>
operations.<br>
In the step S23, Means for Constraint Condition Extraction 3 generates the set S<br>
that has the variables modified in the step S22 as its elements. Here generating the set S<br>
means, for example, writing suffixes, with which the above-mentioned modified names of<br>
variables and the array elements of variables can be identified, in a certain memory area on<br>
the computer, and so forth.<br>
In addition, Means for Constraint Condition Extraction 3 judges whether there are any<br>
elements in the above-mentioned set S, that is, any variables of which the values have been<br>
modified with Means for Variable Value Setting 2 (the step S24). As a result of the<br>
above-mentioned judgment, when there are elements in the set S (when the set S is not an<br>
empty set), Means for Constraint Condition Extraction 3 picks up the element Sm one by<br>
one (the step S25).<br>
Then, the set Q of the constraints related to the element Sm, which is picked up as<br>
mentioned above, is generated in the step S26. That is, if there are any constraint conditions<br>
that are comprised including the element Sm, Means for Constraint Condition Extraction 3<br>
output them to the set Q. Then, while there are elements in the above-mentioned set Q in<br>
the step S27, the following steps S28 to S30 are executed repeatedly.<br>
In the step S28, Means for Constraint Condition Calculation 4 picks up a<br>
constraint condition Qm from the set Q. And Means for Constraint Condition Calculation 4<br>
solves the constraint condition Qm picked up in the step S28, and searches for variables<br>
and their values that should be modified so as to satisfy the constraint condition Qm (the<br>
step S29).<br>
Here is the detailed content of the process in the step S29.<br>
(1) Whether the constraint condition Qm is satisfied or not is checked, and if it is satisfied,<br>
the present step S29 is completed.<br>
(2) Variables and their values which should be modified to satisfy the constraint condition<br>
Qm are searched for.<br>
(3) Whether the values of variables that are searched for in the item (2) above are true or<br>
not is verified.<br>
Although the item (2) above is indispensable as the process in the step S29, the other items<br>
(1) and (3) are not necessarily so. The user may judge whether they are necessary or not in<br>
accordance with the target problems, and comprise so that they are explicitly or implicitly<br>
designated as constraint conditions.<br>
Furthermore, in the step S30, Means for Variable Value Resetting 5 resets the<br>
values of the variables that are searched for in the step S29, and in the following process<br>
the constraint conditions are solved based on the values that are reset.<br>
Therefore, when a certain variable is modified, if there are multiple constraint conditions<br>
that are related to the variable, the solutions of each constraint condition, which are picked<br>
up one by one, are given in order, and simultaneously, the variables are added to the end of<br>
the set S by the solutions that are acquired.<br>
One the other hand, as a result of the constraint condition Qm being picked up by<br>
the step S28, if it is judged that there is no element in the set Q at the step S27, a series of<br>
processes return to the step 24, and the next variable Sm is picked up from the set S,<br>
repeating the similar processes.<br>
As a result, when there is no more element in the set S, it is equivalent to be the situation<br>
that has entered a stable condition as for the process of the Constraint-based Solver 100,<br>
and as mentioned before, it gets into the waiting condition at the step S22 until a new value<br>
is set for any variable that is used for the constraint conditions.<br>
In this embodiment, as for the order in which the variables Sm are picked up when<br>
there are multiple variables Sm in the set S at the step S25, and the order in which the<br>
constraint condition Qm is picked up at the step S28, in consideration of the processing<br>
procedures for constraint propagation, the constraint condition setting method is that the<br>
user explicitly designates the order (order of priority) and let the computer execute it.<br>
Specifically, for example, the priority order is attained by predetermining that it is the order<br>
the constraint conditions are described. The concrete examples on this matter are shown<br>
below.<br>
The aforementioned accounting calculation problem is used again.<br>
The constraints are as follows:<br>
price[l] = 100,price[2] = 200,price[3]= 300,price[4]= 50 ...(Formula 1)<br>
quantity! 1] = 2, quantity[2] = 3, quantity[3] = 2, quantity[4] = 3 ...(Formula 2)<br>
subtotal[i] = pricefi] * quantity[i] (i=l to 4) ...(Formula 3)<br>
total = 2 subtotal[i] (i=l to 4) .. .(Formula 4)<br>
There is some meaning in the description order of (Formula 1) to (Formula 4) mentioned<br>
above. For example, the constraint condition (constraint) which is described first has the<br>
highest priority, and the following constraint conditions have less high priority in order. In<br>
this case, the value setting for each variable by (Formula 1) and (Formula 2) is<br>
preferentially executed, and (Formula 3) and (Formula 4) mean that the constraints are<br>
registered inside the computer afterward.<br>
The execution order of the constraints is determined on execution, but the order in which<br>
the elements are picked up from the set S and the set Q is uncertain. As explicit methods to<br>
determine that, there are methods of judging from the description order or setting the order<br>
of priority in the constraints.<br>
In addition, it is also acceptable to configure the aforementioned order of priority<br>
so that the computer (CPU) executes it automatically. In this case, the user needs to set the<br>
constraint conditions consisting of the content and the description order that will not cause<br>
any contradiction during the calculation processes, in whatever order the computer execute<br>
them, but this task can be executed easily if the user has normal knowledge and experience<br>
as a programmer.<br>
Then, the operation order shown on Fig. 2 is explained, using the example of the<br>
aforementioned accounting calculation, following the changes of the variable values in the<br>
specific constraint conditions.<br>
For example, suppose price[2] is changed from 200 to 250. Because it is not the setting of<br>
initial value but the change of data, it proceeds from the step S20 to the step S22. As a<br>
result of the step S23, the set S = { price[2] }. Because it can be judged that there are some<br>
elements in the set S at the step S24, price[2] is picked up at the step S25.<br>
Then, subtotal [2] = price[2] * quantity[2], the constraint condition which is related<br>
only to price[2], becomes the element of the set Q at the step S26. In short, the set Q =<br>
{ subtotal [2] = price[2] * quantity[2] } is generated.<br>
Then, because it can be judged that there are some elements in the set Q at the step S27, the<br>
constraint condition, subtotal[2] = price[2] * quantity[2], is picked up. The solution of the<br>
constraint condition, that is, subtotal[2] = 250 * 3 = 750 is calculated at the step S29. This<br>
modified value 750 is set for subtotal[2] at the step 30. subtotal[2] is added to the set S.<br>
Then, the set S = { subtotal[2] } is generated.<br>
\And it returns to the step S27, but because the set Q is an empty set after picking<br>
up the only element from the previous set Q, it proceeds to the step S24 afterwards.<br>
At the step S24, subtotal[2], which has just been added in the set S, is judged and this<br>
subtotal[2] is picked up at the step S25.<br>
Then, the set Q, which has the constraint condition which is related only to<br>
subtotal [2], total = 2 subtotal[i] (i=l to 4), as its element, is generated. That is,<br>
the set Q = { total = £ subtotal [i] (i=l to 4) } is generated. The relevant constraint<br>
conditions are picked up at the step S28, and the solution of the constraint conditions, that<br>
is, total = 200 + 750 + 150 = 1700 is calculated at the step S29, and the modified value<br>
1700 is set for the variable (total) at the step S30. Simultaneously, the variable (total) is<br>
stored in the set S. Subsequently, because the steps S27, S24, S25, and S26 have been<br>
executed, and no constraint that is related exits, there is no element to be added to the set Q.<br>
In this case, it is possible to simplify it to shorten the calculation time as follows. Namely,<br>
at the step S29, when the solution of the constraint conditions is searched, addition is not<br>
executed again, but only the changed values are utilized and difference is dissolved. And, at<br>
the step S30, because it is known that there is no constraint condition that is related to total,<br>
to shorten the calculation time, it is arranged so that no element is added to the set S.<br>
Again, it returns to the step S27, but because the set Q is an empty set after picking<br>
up the only element from the previous set Q, it proceeds to the step S22, and the<br>
Constraint-based Solver 100 maintains the waiting condition until there is next data<br>
modification from outside.<br>
By the way, as for the aforementioned process at the step S28 on the operation of the<br>
Constraint-based Solver 100, the process of picking up the constraint conditions Qm one by<br>
one to search for the solution has been explained, but they don't necessarily have to be<br>
picked up one by one. When it is possible to give the solutions of the constraints<br>
simultaneously, two or more constraint conditions are to be picked up from the set Q.<br>
Herewith, soluble target problems may become wide-ranged.<br>
Furthermore, the actual solution method of the constraint conditions Qm is not limited to<br>
the way of solving with simple formula transformation like accounting problems. The<br>
solution method with regard to existing formulas can entirely be used, and accordingly, it is<br>
permitted to introduce the solution method of n-th degree equations.<br>
In addition, as another specific example, the processes of addition and deletion of<br>
the number of data itself, which are used for constraint conditions, are explained.<br>
In the aforementioned example of accounting calculation, the variables of price and<br>
quantity are expressed in arrays respectively and the number of the data was fixed to four<br>
to set up the constraint conditions, but the constraint conditions, in which the number of<br>
data itself is set as a variable, are considered. By adding price[5] and quantity[5] to the<br>
present constraint conditions, the following modification is performed,<br>
pricefl] = 100, price[2] = 250, price[3]= 300, price[4]= 50, price[5]=310 ...(Formula 13)<br>
quantity! 1] = 2, quantity[2] = 3, quantity[3] = 2, quantity[4] = 3, quantity[5] = 3<br>
 (Formula 14)<br>
totalitems = 5 Formula 15)<br>
subtotalfi] =price[i] quantity[i] (i=l to 4) ...(Formula 16)<br>
total = E subtotal[i] (i=l to totalitems) ...(Formula 17)<br>
If the aforementioned process is executed completely similarly:<br>
subtotal[5] = price[5] * quantity[5] = 310 * 3 - 930<br>
total = £ subtotal[i] = 200 + 750 + 600 +150 + 930 = 2630<br>
Thus, it is possible to search for solution without leaving any constraint conditions that<br>
remain unsolved. This kind of modification is similar when variables or constraint<br>
conditions are deleted, and it is also possible to modify the number of variables expressed<br>
with variable length arrays.<br>
The screen examples of the user inputting these constraint conditions and values,<br>
making use of the actual input-output means (for example, Means for Constraint Condition<br>
Inputting 1) are shown on Fig. 24. By the way, the screen examples of Fig. 24 are<br>
equivalent to the screen examples of Means for Constraint Condition Inputting 1 and<br>
Means for Variable Value Setting 2, which have the output function, and they are the<br>
execution examples in which input-output interface for UNIX is mounted as a structure,<br>
which is equivalent to general programming language. Though input and output from (a) to<br>
(h) in Fig. 24 are sequential, they are displayed separately for convenience.<br>
As shown in Fig. 24 (a), the user inputs 'ripple' after the UNIX prompt, which is indicated<br>
with '$' (Fig. 24 (b)). As a result, the programs which the processes of the present<br>
invention are mounted are loaded, and the user is prompted to input data with the indication<br>
of '%' on the screen (the data input by the user are displayed after '%', and on the line<br>
directly after starting a new line, the data values and calculation output values that are<br>
received are displayed).<br>
Then, the user inputs the initial constraints (Fig. 24 (c) 241). Though as for the<br>
constraint 242, sum calculation is abstracted as the function totalarrayQ here, it can also be<br>
expressed with the constraint shown in Fig. 21. In addition, it is also possible to directly<br>
describe procedural loop structures (refer to fusion with the functional programming<br>
language). And when the difference dissolution of sum calculation is realized in the process<br>
at the step S29, the side of the Constraint-based Solver 100 judges and automatically<br>
processes it, and the user is not conscious of that.<br>
Then, the user sets the initial values (Fig. 24 (d) 243 and 244). Though the<br>
processes that are shown in the steps from S22 to S30 are executed, when they are clearly<br>
unnecessary in consideration of operation efficiency, it is possible to prevent them from<br>
being executed in the judgment of the Constraint-based Solver 100. At Fig. 24 (e) 245,<br>
remaining input values are read into from files by 'load'. At this point, subtotal and total<br>
have been calculated and already set, and through inputting 'total' at 246, the current total<br>
value is displayed and the execution result can be acquired. When Fig. 24 (f) 247 is input,<br>
the step S26 in Fig. 2 is executed. And there is no screen output during the calculation, but<br>
the processes indicated in the steps from S22 to S30 are executed, and the total value of<br>
execution result is displayed as a result of inputting of 248. Inputting of 249 and 250 is the<br>
additional setting of the number of data which are used for constraint conditions. And the<br>
total value is displayed in execution result as a result of inputting Fig. 24 (g) 251, the end<br>
command is issued as a result of inputting Fig. 24 (h) 252.<br>
In addition, it is also acceptable to put together and define some data definition<br>
and constraints as one class in classification concept, give them parameters to make them<br>
instances, and configure to make the set of the constraints and values. As a result,<br>
constraint conditions that are set can be divided into multiples, so it is convenient to<br>
execute only necessary minimum processes. The concept with regard to this classification<br>
is shown in Fig. 20. This class can be inherited. For example, when there are class A<br>
containing Variable 1, Variable 2 and Constraint 1 and Class B containing Variable 3, it is<br>
possible to inherit these Class A and Class B, and additionally generate the class which has<br>
inherited Constraint 2 in Fig. 20.<br>
By the way, as seen from the configuration and operation of the Constraint-based<br>
Solver 100 in this embodiment, for example, there is no setting of evaluation formula<br>
(evaluation condition) that no constraint condition violates constraint. In the conventional<br>
declarative programming method, there are many cases that it is judged whether any<br>
contradiction exists among constraint conditions based on the relevant evaluation formula<br>
when the solutions of constraint conditions is searched for. In the present invention, it is<br>
assumed that when the user sets the constraint conditions, he/she sets them without causing<br>
any contradictions. Therefore, the Constraint-based Solver 100 can search for the solution<br>
in the end without fail, and if the solution is not searched for, it means that the user has<br>
failed to set the constraint conditions correctly.<br>
Evaluation formulas with regard to the existence of constraint violation are unnecessary on<br>
execution, but needless to say, it is helpful to cope with problems such as debugs and<br>
discovery of mistakes to prepare them as an auxiliary function.<br>
According to the Constraint-based Solver 100 if this embodiment, when constraint<br>
conditions with regard to the target problems and the initial values or variation values are<br>
set for the variables to be used for the relevant constraints, it is configured so that the<br>
constraint conditions related to the variables are extracted, the solutions of each constraint<br>
conditions are solved one by one, and the solutions given are set as new variable values to<br>
repeat the solution searching, so it becomes possible to solve target problems with any data<br>
structure and the constraint conditions that connect between data from the data structure.<br>
That is, the constraint conditions which are set are configured so that without describing<br>
any algorithms to solve target problems like conventional procedural programming, after<br>
the commands which are equivalent to these algorithms are included in the data structure,<br>
they are described along with the procedures of constraint propagation, and the solutions of<br>
each constraint condition are searched for one by one without searching for the most<br>
appropriate solution that satisfies all constraint conditions, so the course of solution<br>
searching becomes clear, and it becomes possible to surely reach the final solution and<br>
dramatically speed up computing, because each markedly simplified constraint condition<br>
(for example, linear equations) has only to be solved.<br>
In addition, because the solution method of problems can be directly described in<br>
the constraint conditions, the user doesn't necessarily have to have special professional<br>
knowledge of conventional programming language, and he/she can solve target problems<br>
easily.<br>
(The Second Embodiment)<br>
In the aforementioned first embodiment, as for the Constraint-based Solver 100, it is<br>
configured so that Means for Constraint Condition Inputting 1, Means for Variable Value<br>
Setting 2, Means for Constraint Condition Extraction 3, Means for Constraint Condition<br>
Calculation 4, and Means for Variable Value Resetting 5 are included, but it is the<br>
characteristics of the Constraint-based Solver 200 in this embodiment, in addition to each<br>
configuration means 1 to 5, that Means for Constraint Condition Storage 6 and Means for<br>
Variable Value Storage 7 are equipped.<br>
By the way, as for the common configuration parts between the configuration of the<br>
Constraint-based Solver 200 in this embodiment and that of the Constraint-based Solver<br>
100 in the first embodiment, same signs are attached to such parts, and detailed explanation<br>
is to be omitted.<br>
The overall configuration of the Constraint-based Solver 200 in this embodiment<br>
is shown in Fig. 3.<br>
Means for Constraint Condition Storage 6 stores the constraint conditions that are input<br>
through Means for Constraint Condition Inputting 1 in the prescribed memory area. In<br>
addition, Means for Variable Value Storage 7 stores the variable values (initial values and<br>
variation values) that are set though Means for Variable Value Setting 2.<br>
Besides, Means for Constraint Condition Extraction 8 in this embodiment, in addition to<br>
the functions of Means for Constraint Condition Extraction 3 in the first embodiment, has<br>
the function to compare the newly set constraint conditions or variation values to the<br>
constraint conditions or values that are stored in the aforementioned memory area, and to<br>
extract constraint conditions only when they are not consistent with each other. By the way,<br>
needless to say, Means for Constraint Condition Extraction 8 is not always required to<br>
execute the aforementioned comparison, and it is acceptable to extract constraint conditions<br>
and variable values from Means for Constraint Condition Storage 6 and Means for Variable<br>
Value Storage 7.<br>
Fig. 4 (a) is a drawing to show the mode example of Means for Constraint<br>
Condition Storage 6 storing constraint conditions into memory areas of computers (for<br>
example, memories and magnetic disks). That is, assuming that there is a constraint<br>
condition referring to the variable X with 3 constraint formulas (Constraint 1, Constraint 2,<br>
and Constraint 3), the expression method of memory area when the value 246 is set for this<br>
variable X is shown. An example of the constraint conditions of the aforementioned<br>
accounting calculation problem being expressed in this form is shown in Fig. 6 and Fig. 5.<br>
For example, as shown in Fig. 4 (b), the formula (x = y + z) is stored after being<br>
divided. However, it is not limited to this expression method. As the storage mode of<br>
constraint conditions, it is not necessarily required to divide the memory area into values<br>
and constraints, and for example, it is acceptable not to divide the constraint conditions as a<br>
structure and have them as letter strings.<br>
In addition, it is not limited to the data structure shown in Fig. 5, and such memory area as<br>
is shown below is also accepted.<br>
- The values of variables are divided into types, and certain values are recorded only on the<br>
memory, but as for the other values, the values on the record area may be permanent<br>
through recording them into files and databases, or may have special meanings in terms of<br>
the time system and so on.<br>
- It is not necessary to indicate the variable names with pointers, and they may be directly<br>
held.<br>
- The values of variables are not necessarily kept directly.<br>
- Because it is not necessary to identify variables in compiling the programs and others, the<br>
variable names are not essential.<br>
- Constraints used for constraint conditions don't have to be a list.<br>
- It is acceptable not to have any constraint lists, and as shown in Fig. 7, it may be the<br>
configuration to search for constraints from variable names. However, it is not limited to<br>
the configuration of memories and pointers as shown in Fig. 7.<br>
In addition, all data types that innumerably exist because of the above-mentioned<br>
transformation are to be included.<br>
According to the Constraint-based Solver 200 in this embodiment, because it is<br>
configured so that the initial values or variation values of the variables that are used for the<br>
constraint conditions with regard to the target problems and relevant constraint conditions<br>
are temporarily or permanently kept, it is possible for Means for Constraint Condition<br>
Extraction 8 to execute the processes to search for the variables and their values that<br>
require modification to satisfy the constraint condition Qm through solving Qm, which is<br>
related to the modified variable Sm.<br>
As a result, even though there may be any modification of constraint conditions, there are<br>
some cases when it is not necessary to recalculate every multiple constraint condition from<br>
scratch, thus achieving efficiency of calculation time.<br>
(The Third Embodiment)<br>
As for the Constraint-based Solver 100 in the aforementioned first embodiment, it is<br>
configured so that Means for Constraint Condition Inputting 1, Means for Variable Value<br>
Setting 2, Means for Constraint Condition Extraction 3, Means for Constraint Condition<br>
Calculation 4, and Means for Variable Value Resetting 5 are included, and as for the<br>
Constraint-based Solver 200 in the aforementioned second embodiment, it is configured so<br>
that additionally Means for Constraint Condition Storage 6 and Means for Variable Value<br>
Storage 7 are equipped, but as for the Constraint-based Solver 300, as shown in Fig. 8, it is<br>
characterized in that it is equipped with Means for Function Definition Holding 9 and<br>
Means for Function Definition Execution 10.<br>
The configuration of either of the Constraint-based Solver 100 in the first embodiment or<br>
the Constraint-based Solver 200 in the Second embodiment can be turned into the one<br>
which is additionally equipped with Means for Function Definition Holding 9 and Means<br>
for Function Definition Execution 10, but to simplify the explanation, the configuration<br>
that they are added to the Constraint-based Solver 100 is explained.<br>
By the way, as for the common configuration parts between the configuration of the<br>
Constraint-based Solver 300 in this embodiment and that of the Constraint-based Solver<br>
100 in the first embodiment, same signs are attached to such parts, and detailed explanation<br>
is to be omitted.<br>
The role which of the Constraint-based Solver 300 in this embodiment has from<br>
the viewpoint of programming technique is that the third embodiment fuses the procedural<br>
programming method, while the first embodiment executes problem solution with the<br>
complete declarative programming method. This is to accomplish flexible problem solution<br>
for whatever target problems through trying to use the procedural programming method as<br>
for the partial problems that are difficult to solve with the declarative programming<br>
method.<br>
The overall configuration of the Constraint-based Solver 300 in this embodiment<br>
is shown in Fig. 8.<br>
Means for Function Definition Holding 9 holds the procedures and variable values that the<br>
user describes in the conventional procedural programming method through Means for<br>
Constraint Condition Inputting 1 and Means for Variable Value Setting 2. Means for<br>
Function Definition Holding 9 is connected to Means for Constraint Condition Extraction 3<br>
so that they can input-output data mutually.<br>
By the way, it is not necessarily required to be the configuration to permit procedural<br>
description other than constraint conditions as in Means for Constraint Condition Inputting<br>
1 in this embodiment. For example, it is acceptable to be the configuration that inputting<br>
means exclusively for procedural description is equipped additionally. It also applies to<br>
Means for Variable Value Setting 2, and it is acceptable to equip the means for variable<br>
value setting exclusively for the variables of procedures that are described in procedural<br>
way.<br>
Means for Function Definition Holding 10 actually makes the computer execute<br>
the procedures that are held with Means for Function Definition Holding 9. Also, Means<br>
for Function Definition Execution 10 is connected to Means for Constraint Condition<br>
Calculation 4 so that they can input-output data mutually.<br>
The processes of the Constraint-based Solver 300 in this embodiment are<br>
explained with specific examples. Now, assume the case when y = sin(x), y = a function<br>
with no inverse function (x) or something is included in the constraints that are described as<br>
constraint conditions.<br>
In this case, at the step S29 shown in Fig. 2, when the procedure for formula transformation<br>
of x = sin'^y) is tried to search for the value of the variable x, in relation to the value<br>
domain of the inverse function, there are some cases when the value of x is impossible to<br>
be searched for. Also, as for y = a function with no inverse function f(x), it is impossible to<br>
search for the value of x with the value of y. In such cases, user functions in conventional<br>
procedural programming are freely introduced and handle them.<br>
For example, in solving constraints, it is set to permit that solution methods can be<br>
chosen from multiple options. Assuming that the constraint condition is a = f(b), to search<br>
for the value of the variable b, it is set that { a = f(b), b = f_rev(a) } is prepared and the<br>
constraints can be solved if either of them can be applied.<br>
Also, if the values of the variables 1 and m are not determined in the constraint y = f(l, m),<br>
or if it is the case of inequality like y &gt; x, the relevant constraints cannot be solved easily.<br>
In case of the inequality y &gt; x, when the value of x turns out to be n, the only information<br>
that can be obtained is that y is bigger than n, and the final solution of the value of the<br>
variable y can also be said to be unknown. In these cases, other than processing them as the<br>
setting errors of the constraint conditions, it is acceptable to let the process continue<br>
through assigning the information of y &gt; n to the related constraints as it is. It also applies<br>
to z = x + y, which cannot be solved if only one equation is paid attention to, and it can also<br>
be solved through permitting that simultaneous equations are dealt with among multiple<br>
formulas and multiple values.<br>
That is because, as a result, there are some cases when the value of the variable y<br>
can be definable in relation to the conditions of the other constraints or can be narrowed<br>
down more, or y &gt; n can be realized as a solution as it is. As just described, it tries to solve<br>
them wherever possible when it is possible to solve them with the other constraints, dealing<br>
with inequality and such as they are, not defined values as variable values. That is, Means<br>
for Constraint Condition Extraction 3 in this case executes the solution method which has<br>
the relationship shown in Fig. 9. If the value of x in the constraints in Fig. 9 is modified, all<br>
the formulas (Solution Methods 1 to 3) that don't have the form of assigning it to x are<br>
executed, thus making the solution process of constraints flexible, and it becomes possible<br>
to let it have solution ability, in the same way as the conventional programming which uses<br>
procedural programming, or more than that.<br>
Also, without being limited to the cases when it is difficult to express them as<br>
constraints as for the problems of inverse functions and such, as for the formulas which can<br>
be normally expressed as constraints, if it is configured so that they are transformed into<br>
the form of the solution method as shown in Fig. 9, it is expected to improve the speed in<br>
executing the processes.<br>
As just described, as for the Constraint-based Solver 300, it is configured so that<br>
Means for Function Definition Holding 9 and Means for Function Definition Execution 10<br>
are included, the constraint conditions, functions that have been defined in the conventional<br>
programming, and such are fused, and it becomes possible for the user to shifting between<br>
the solution method as constraint conditions and that of conventional programming<br>
technique, depending on the quality or the characteristics of target problems. As a result, as<br>
for the Constraint-based Solvers 100 and 200 in the first and second embodiment, it<br>
becomes markedly easy to describe the constraint conditions that contain inverse operation<br>
processes that cannot be solved.<br>
(The Fourth Embodiment)<br>
In addition to each aforementioned configuration means of the Constraint-based Solvers<br>
100, 200 and 300 in the embodiments from the first to the third, the Constraint-based<br>
Solver 400 is characterized in that it can set variable values through using information from<br>
databases and system resources accordingly.<br>
The overall configuration of the Constraint-based Solver 400 in this embodiment is shown<br>
in Fig. 10.<br>
To simplify the explanation of this embodiment, here is the explanation of the<br>
Constraint-based Solver 400, which is configured of the Constraint-based Solver 200 in the<br>
second embodiment with addition. Needless to say, information from databases and system<br>
resources can be used for the Constraint-based Solvers in the other embodiments.<br>
By the way, as for the common configuration parts between the configuration of the<br>
Constraint-based Solver 400 in this embodiment and that of the Constraint-based Solver<br>
200 in the second embodiment, same signs are attached to such parts, and detailed<br>
explanation is to be omitted.<br>
As shown in Fig. 10, according to the configuration of the Constraint-based Solver<br>
400 in this embodiment, partial or all variables in constraint conditions can be linked with<br>
the values recorded in aforementioned databases 11 and system resources 12, and such<br>
variables in the system as are linked with other matters like time, thus enabling easy<br>
management of variables that consistency between the variables outside the<br>
Constraint-based Solver 400 and the variables of constraint conditions is achieved.<br>
Then, some examples that dealing with the variables with more complicated data<br>
structures as the content of constraint conditions is possible are shown. The following<br>
examples are feasible for all of the Constraint-based Solvers 100, 200, 300 and 400 in the<br>
first embodiment to the fourth embodiment.<br>
(Constraint Conditions that Define Multiple Values for Variables)<br>
Normally, constraint conditions to assign values to variables are, for example, described<br>
like x = 10, but it is defined to assign multiple values to the variable X. More specifically,<br>
for example,<br>
x-{10, 11,12};<br>
Description like this is permitted. In this case, as for computing of addition, subtraction,<br>
multiplication and division among variables, if addition is taken as an example, x + y<br>
executes + operation for each element of each variable x and y.<br>
(Constraint Conditions with Variables of Array Structures of which Operators Are<br>
Defined)<br>
Now, an one-dimensional array vec is considered. This one-dimensional array vec is set as<br>
vec = {50, 200, 300}, and access for the element of the No. i (0 
1) is expressed as vec[i]. Each element of the one-dimensional array vec is vec[0] = 50,<br>
vec[l] = 200, and vec[2] = 300.<br>
Here, the operators for the one-dimensional arrays vecl and vec2 are defined as follows.<br>
vecl + vec2 ... the array that all the elements of each one-dimensional array are added to<br>
vecl - vec2 ... the array that all the elements of each one-dimensional array are subtracted<br>
vecl  vec2 ... the array that all the elements of each one-dimensional array are multiplied<br>
vecl / vec2 ... the array that all the elements of each one-dimensional array are divided<br>
vecl = vec2 ... the comparison or assignment of arrays that all of the elements of each<br>
one-dimensional array are same<br>
vecl &amp; vec2 ... the array that all the elements of each one-dimensional array are linked<br>
By defining the operators for one-dimensional arrays like this, it becomes possible to deal<br>
with them in the same way as the constraints in the aforementioned embodiments from the<br>
first to the fourth.<br>
To access the constraint conditions of array structures, for example, such operators as<br>
shown in Fig. 21 can be prepared, though they are not for limitation. It is possible to use<br>
28<br>
any function for this operator.<br>
In addition, to realize flexible accesses to the elements of the aforementioned<br>
one-dimensional arrays, it is enabled to designate domains at vec[i]. Specifically, if vec [n. .<br>
m, 1. . k, i. . j] expresses an array that the elements ofNo. n to m, No. 1 to k, and No. i to j<br>
of the dimensional array are picked up and aligned,<br>
Such computing as vecl[0. . 3] = vec2[0. . 1] &amp; vec2[4. . 5] + vec3[0. . 3] becomes<br>
possible, and one-dimensional arrays can be dealt with as constraints (constraint<br>
conditions).<br>
For example, if letters are stored in each array element of the aforementioned<br>
one-dimensional array (here, it is shown as str), str becomes a letter string. As for the letter<br>
string str = "Hello World!", if the fact that any letter is assigned to each str[i], or if the letter<br>
string 1 = "Hello " and the letter string 2 = "World!", such constraints that are expressed as<br>
the letter sting str = the letter string 1 &amp; the letter string 2 can be dealt with. Moreover, it<br>
becomes possible to describe constraints more flexibly by enabling pattern matching and<br>
letter string replacing by means of regular expression only with letter strings.<br>
By applying this, for example, the HTML (hypertext markup language) outputs by<br>
means of Web, which vary in accordance with the modification of variable values, are<br>
described as follows,<br>
date = "2003/01/01";<br>
name = "Tokkyo Taro" ;<br>
content = "long-passage writing"<br>
HTML_data = "" &amp; date[0..3] &amp; "Year" &amp; date[5..6] &amp; "Month" &amp;<br>
date[8..9] &amp; "Day" &amp; "Name:" &amp; name &amp; "Content:" &amp; content &amp;<br>
"";<br>
(Constraint Conditions Equipped with Default Conversion Rules)<br>
Conversion rules are prepared with regard to any data conversion, and especially, it is<br>
possible to designate them by default.<br>
Particularly, in cases where numbers are converted into letter strings, there is a method to<br>
use conversion functions every time they are referred to, but preparing the defaults of data<br>
conversion rules enables efficient description.<br>
As an example, the following rules are prepared.<br>
- It is ensured that conversion rules are right aligned.<br>
- S stands for signs, and they are - only when numbers are negative, and they are null for<br>
the other cases.<br>
- Xn stands for a number with n-digits or less.<br>
- Yn stands for a number with fixed n-digits.<br>
- Zn stands for zero suppression with fixed n-digits.<br>
In this case, for example, in defining variables,<br>
float("SX9.Y3")vall;<br>
is defined, vail can be referred to as a letter string which has a total letter number of 14,<br>
fixed three digits on decimal fraction and right alignment.<br>
Also, if unsigned int("Z8") va!2;<br>
is defined, va!2 has no sign, and va!2 can be referred to as a letter string which has a total<br>
letter number of eight of eight digits with zero suppression.<br>
Of course, describing directly as va!2("Z10") and such in referring to values enables<br>
application of not only default rules but also other rules in applying them.<br>
This kind of definition of conversion rules by means of constraint conditions that have<br>
default conversion rules enables easy description of constraints in clerical application and<br>
such.<br>
Needless to say, it can also be applied to other data structures, and the aforementioned one<br>
is an example as the format of conversion rules, which means there are many kinds of<br>
them.<br>
(Constraint Conditions with Priority Orders)<br>
An example of description in cases where weight is added to constraint conditions is shown<br>
as follows.<br>
{Conditional expression&gt;} [:a priority order];<br>
or<br>
{<conditional expression>} [:<a priority order>]; -&gt; {<the process in case where the></the>
conditional expression is not realized&gt;} ;<br>
Here, it is ensured that, in cases where multiple constraint conditions correspond to each<br>
other, the constraints to be executed are selected in accordance with the values of the<br>
priority order. Also, it is ensured that, in cases where there are multiple values of the same<br>
priority order, all of them are executed. Defining such constraints with priority orders<br>
makes it become effective in cases where only the constraint with the highest priority order<br>
or the lowest is executed, or the execution order of the constraints is designated.<br>
(Constraint Conditions Based on Structures)<br>
It is possible to deal with multiple data types in a mass with structures (abstract data<br>
structures). If the aforementioned data of Web output is tried to express with this structure,<br>
the following expression can be made,<br>
struct structure_name {<br>
date date;<br>
name name;<br>
string content;<br>
bbs_data[] ;<br>
In the actual Web system, the data of the aforementioned structure turns out to exit in<br>
databases and files, and in the case of the aforementioned structure, access to "content"<br>
with regard to the array number 5, for example, becomes possible by<br>
"bbs_data[5].content".<br>
By the way, with regard to access to the data of this structure, defining the operators of<br>
letter string matching for the members (which mean date, name, content and HTML_data)<br>
enables to describe searching processes as constraint conditions.<br>
(Constraint Conditions for Built in Functions, Additional Operators and Rule<br>
Addition)<br>
Besides, to realize Fig. 12 (a) and Fig. 12 (b), in which a bit practical example problems are<br>
shown, using each aforementioned data structure, some rules are added. By the way, Fig. 12<br>
 (a) and Fig. 12 (b) are supposed to be shown in the same drawing, but they are shown as<br>
separate ones.<br>
For example, as built in functions, operators and rules, the following are prepared.<br>
- vsize(arg) ... a built in function to search for the size of the array given with an argument<br>
arg<br>
- inttostr(arg)... a built in function to convert integers into letter strings<br>
- strtrunc(argl, arg2)... Though the letter strings of arg 1 are copied, if they are longer than<br>
the letter string length which is designated with arg2, the letters for that are cut off.<br>
- array domain designating operator[*] ... This means the elements of all the arrays.<br>
- Some constraints parenthesized with {} are processed as a block in a mass.<br>
- [$i] ... Though this is similar to index[i] that has already appeared so far, in the constraint<br>
conditions massed only in a block, all have the same value. Here, to identify it from normal<br>
variables, $i instead of i is used for description.<br>
Accordingly, the following description is possible.<br>
- output_block[*] . output_html ... This means the value array of multiple elements in<br>
which all outputjitml (Refer to Fig. 12 (a)) in the array are aligned, and when comparison<br>
with letter strings and assignment computing are executed, all the elements are dealt with<br>
as a letter string in which they are linked.<br>
- vsize(output_block) = list_count ... This is the constraint to show the relationship<br>
between the array number, that is, the array size and the variables. Note, however, that,<br>
though reference to the values given with vsizeQ is a normal numeric value, modification is<br>
required to mean the modification of the array size, so the abstracted process, which is<br>
either of defining it so that it will mean the function call for size modification of which<br>
value modification is abstracted inside the process, the process of the method call by means<br>
of objects or the other, is required.<br>
To give input data for the problems that include constraint conditions with each of<br>
aforementioned data structure, the user directly modifies the relevant variables, call the<br>
procedural function bbs_additem(), which is shown in Fig. 12 (a), and such. And as for the<br>
example problems (a) and (b) in Fig. 12, with regard to output, aforementioned output_html<br>
is referred to. As a result of above-mentioned processes, Web service can be realized. By<br>
the way, output is not required to be limited to the HTML format, and it is also possible to<br>
realize input-output service on the server side at any client/server system in the same way.<br>
By the way, though the one-dimensional array vec has been used for explanation<br>
so far, needless to say, computing among arrays that have different array length and<br>
definition on computing with such arrays and variables can be executed in the same way,<br>
much more extension to multidimensional arrays such as two-dimensional arrays.<br>
Also, as mentioned above, though an example where it is possible to deal with variables<br>
with more complicated data structure as the content of constraint conditions has been<br>
shown, it goes without saying that it is not necessary to correspond with these data<br>
structures completely, and that transformation examples that skilled person could analogize<br>
from these are included.<br>
As explained above, because it is ensured that constraint conditions can deal with<br>
not only numbers but also each data structure, it becomes possible to describe the<br>
relationship between data that are presently stored and HTML output by means of<br>
constraint condition (constraints), and it enables to simply describe the programs on the<br>
server side of Web applications only with constraint conditions. It is Fig. 11 that shows the<br>
conceptual drawing of the system for data input and display with the combination of this<br>
Web server, and it is Fig. 12 (a) and (b) that an example of information and constraint<br>
conditions which are stored in Means for Function Type Definition Holding and Means for<br>
Constraint Condition Storage in that case.<br>
Also, without limiting to aforementioned HTML on the Web, as for general<br>
window interface shown in Fig. 13, configuring it so that each item is mapped to variables,<br>
it becomes possible to describe the relationship between data and user interface, and to<br>
understand as well as to describe general user interface become easy. As a result, high<br>
productivity is realized compared to the conventional programming formalities.<br><other application examples of the present invention: program></other>
Construction and Transaction Processes&gt;<br>
Then, it is explained that the present invention can be applied to the problems on<br>
constructing any application program using input interface on the Web, or the processing<br>
problems of transaction in searching databases in which any datum is accumulated.<br>
As for the aforementioned Constraint-based Solvers in the embodiments from the first to<br>
the fourth, having the procedures and processed contents to be solved with constraint<br>
conditions as history information (update history) enables to realize the UNDO function,<br>
which is one of the concepts of user interface on applications, or the transaction of<br>
databases.<br>
As a result of making this UNDO function or the transaction of databases feasible,<br>
it becomes easy to uninvent a series of operation to search for constraint solution<br>
accompanied with data modification from the start of data update. As a result, it becomes<br>
certain and quick to confirm input data, which means discovering errors included in input<br>
data through modifying the partial data values of constraint conditions, and to execute the<br>
processes to restore the original data values in canceling then.<br>
Then, it is shown that the present invention is applicable to the window systems<br>
using windows that are basic screen elements in the GUI environment and the<br>
multi-window systems. Here, an example of the window system shown in Fig. 14 is<br>
explained. By the way, needless to say, it is possible to deal with any number of windows,<br>
though three windows are shown in Fig. 14.<br>
Fig. 15 is the conceptual drawing to show the configuration on the client side of the<br>
client/server system that realizes the window system. As for the system configuration on<br>
the server side, because it is similar to what is shown in Fig.l, 3, 8 and 10, it is omitted.<br>
As shown in Fig. 15, the GUI client has the GUI processor and GUI controller, and the GUI<br>
controller controls the operation of each part shown in Fig. 16.<br>
The content of the GUI controller here has the similar configuration with Fig.l, 3, 8 and 10,<br>
and the modification of the conditions of each part is executed for the I/F controller for the<br>
input-output I/F in Fig.l, 3, 8 and 10 inside the client. As constraint conditions, cooperation<br>
rules among each part, consistency checking of input data to be processed by clients, input<br>
supports, conversion rules for data to be passed to the server side and such are described<br>
and processed.<br>
The data converted and processed at the GUI controller are transmitted to the server<br>
through variables for transmittance.<br>
Of course, it goes without saying that system configuration can be flexibly transformed and<br>
used, processing the GUI processing part of the client and the constraint processors of the<br>
server in a mass with only one machine and such.<br>
By the way, as for the sequential solution function of constraint conditions according to the<br>
value modification of variables, which is the characteristics of the present invention, the<br>
client/server system as a whole has it, and the aforementioned GUI controller has it. Also,<br>
data transfer between the client the server may be in unique form, but it is possible to<br>
realize open protocol that is compatible with the conventional method through using such<br>
standardized data formats as XML.<br>
As just described, on the GUI side, the GUI operation control, consistency<br>
confirmation of transmitted data, input supporting, GUI condition modification in<br>
accordance with data conditions, and notification processes to the server side and such can<br>
be executed based on the description of constraint conditions.<br>
Then, the window operation is explained in detail. The construction inside each<br>
window is possible by means of aforementioned constraint condition setting that permits<br>
dealing with each data structure, the UNDO function, or the user interface that can realize<br>
the transaction processes of databases, the operation of this window itself is described as<br>
follows.<br>
As information on the window, for example, the following structure is defined,<br>
struct {<br>
position x, y ;<br>
size x, y;<br>
current_display_flag;<br>
} window_information [];<br>
By the way, the following express as follows.<br>
window_information[0] ... Application 1<br>
window_information[l] ... Application2<br>
window_mformation[2] ... Application 3<br>
Reference updating of these variable values is dealt with in the similar way as the system<br>
resources in Fig. 10, and it is interlocked with the actual windows of the GUI system.<br>
An example of the cases where window operations (display/non-display,<br>
movement, size change), which are displayed on the screen to execute applications, are<br>
described with constraint conditions is shown as follows.<br>
(a) Display/Non-display of the Window n<br>
Opening a window on the screen (display) ... window_information[n].<br>
current_display_flag = true,<br>
Closing a window on the screen (non-display) ... window_information[n].<br>
current_display_flag = false,<br>
Also, when there is a [close button] to close the window on the screen, for example, it can<br>
be window_information[n]. current_display_fiag = ! <the condition of the close button><br>
is a not operator).<br>
(b) Movement of the Window n<br>
window_information[n]. position, x = <the size of x to move> ;<br>
window_information[n]. position, y = <the size of y to move> ;<br>
(c) Size Change of the Window<br>
window_information[n]. size, x = <the size of x to change> ;<br>
window_information[n]. size, y = <the size of y to change> ;<br>
Other than the above, to make Application 2 situated on the right to Application 1,<br>
the following are acceptable.<br>
window_inforrnation[l]. position, x = window_information[0]. position, x +<br>
window_information[n]. size, x ;<br>
window_information[l]. position, y = window_information[0]. position, y;<br>
Also, to fix the size of the window size, window_information[n]. size, x and<br>
window_information[n]. size, y are set unchangeable, after preparing the attributes of<br>
changeable/unchangeable as variables.<br>
As just described, as for the window systems and the multi-window systems in the<br>
GUI environment, if events take place, related operations that depend on the event<br>
situations about the operations of windows and application operations inside the windows<br>
had to be described one by one in the conventional programming method, while according<br>
to the operation control of the present invention, based on the open-and-shut constraint<br>
conditions, the complicated behaviors of applications can be simply and easily described.<br>
By the way, though the fact that the operations on window systems can be<br>
controlled with the description of constraint conditions was mentioned in the GUI<br>
environment, needless to say, skilled persons in the technical field of the present invention<br>
could easily imagine that the present invention can be applied not only when data are<br>
output on the screen, but also when the output system (for example, the form printing<br>
system), which outputs the contents that are processed with the window into any medium<br>
(for example, paper), is realized.<br>
Also, in the aforementioned explanation, specific examples on the client/server system are<br>
shown, but it is not necessary to be a client/server system, and it is acceptable to construct<br>
the client and the server as separate systems, and to enable aforementioned processes only<br>
for the client or for the server.<br><other application examples of the present invention: parallel processing and></other>
Constructed Computer Systems&gt;<br>
Also, the present invention can be applied to the problems of parallel processing, which are<br>
troublesome problems in procedural programming. As for parallel processing, it is thought<br>
that it is broadly classified into two kinds of operations. That is, the method that some<br>
CPUs execute algorithms from the step S23 to the step S30, and the method that variables<br>
and relational expressions are constructed in the architecture like data flow machines.<br>
In the former case, if parallel processing is tried with the normal procedural<br>
programming method, at the stage of constructing algorithms, the user must describe<br>
divided programming procedures, being conscious of the parallel operations of the CPU.<br>
On the other hand, in the case of parallel processing of the present invention, just operating<br>
the processes from the step S23 to the step S30 started from variable modification at the<br>
step S22 in the algorithm in Fig.22 in parallel, the user can realize parallel processing<br>
without being conscious of parallel processing directly.<br>
Specifically, as for the Constraint-based Solvers of the aforementioned<br>
embodiments from the first to the fourth, a series of operations due to modification of<br>
variable values at the step S22 with regard to other processes are executed while the steps<br>
from S23 to S30 are being executed for certain processes.<br>
In actuality, though it is necessary to realize exclusive control and synchronous control<br>
among each variable during the execution of this parallel processing, as is the case with<br>
mounting parallel algorithms for conventional procedural programming method, the<br>
method of the conventional procedural programming can be applied as it is.<br>
If relational expressions are constructed with variables in the latter architecture,<br>
relational expressions among variables become channels, for example, when realizing them<br>
on parallel computers physically. On these parallel computers, parallel processors are<br>
bound by means of complicated channels, and communication costs vary depending on the<br>
routes. Expressing these communication costs with priority orders enables automatic<br>
selection of data routes. As for the priority orders, (Constraint Conditions with Priority<br>
Orders), which has been cited as an example of constraint conditions, can be used. In the<br>
similar way with such parallel processing, in general, the present invention can be applied<br>
to the entire constructed systems.<br>
By the way, the systems here means computers and machines for exclusive use in<br>
accordance with application, which have different multiple qualities, and the compounds<br>
that are consisted of the network binding them, thus indicating general corporate systems<br>
and social systems.<br>
That is, when the present invention is applied to the entire system, conceptually, it<br>
resembles the realization method of parallel processing with aforementioned data flow<br>
machines, and the computers that are configured with the present invention are connected<br>
with the variables that are the interfaces of other computers through the variables that<br>
become the interfaces among the computers. Relational expressions among variables are<br>
channels, and communication costs are priorities, so the aforementioned entire system can<br>
be designed and constructed by means of the present invention.<br><other application examples of the present invention: fusion with existing></other>
Programming Language&gt;<br>
As explained so far, the present invention deals with event-driven calculation execution<br>
principles that the problems consisted of any constraint condition are solved with constraint<br>
propagation through modifying the variable values taking the opportunities of the<br>
directions (events) from outside (the user and such). As mentioned above, as is obvious<br>
from the fact that existing procedural programming language is used for Means for<br>
Function Definition Holding and Means for Function Definition Execution, it is assumed<br>
that it can be combined with the existing programming language, though it is shown in<br>
Fig. 18. Consequently, the fact that the present invention can be fused to the existing<br>
programming language is described further in detail.<br>
By the way, when programming languages are classified, broadly, one of them has<br>
been classified as procedural programming, and the other declarative programming so far,<br>
but actually more meticulous classification of programming languages exists. That is, in the<br>
non-declarative programming language against the declarative programming language, the<br>
functional programming language as a programming language, which is equivalent to the<br>
procedural programming language, is included. Hereinafter, the fusion of the present<br>
invention and the functional programming language is dealt with.<br>
(A) Fusion with the Functional Programming Language<br>
Here, the natural fusion method with the LISP language (Common LISP), which has the<br>
longest history and can be said to be the representative as the functional programming<br>
language, is mentioned. Now, assuming that the initial values of the two variables a and b,<br>
and the following constraint conditions are defined.<br>
a= {11, 12, 13}<br>
b={l,2,3}<br>
a[$i]=b[$i] + 10<br>
Both of the values of a and b are the arrays that have three elements. Also, if the function<br>
defconstraint, which defines the constraint in the embodiments of the present invention, is<br>
newly defined, and if assignment to variables is made to respond to binding to symbols, it<br>
can be probably described as follows.<br>
(set'a #(11 1213))<br>
(set 'b #(1 2 3))<br>
(defconstraint '(= (aref a $i) (+ (aref b $i) 10)) ... (Formula 18)<br>
Here, the function defconstraint creates solution formulas with regard to the<br>
symbols (variables) a and b from arguments to realize the data structure in Fig.9, and<br>
execute the following:<br>
(defconstraint2 '(= (aref a $i) (+ (aref b $i) 10))<br>
'(setf (aref a $i) (+ (aref b $i) 10))<br>
'(setf (aref b $i) (- (aref a $i) 10)))<br>
And the function defconstraint2 maintains the data structure in Fig.9. Though the data<br>
structure in Fig.6 and such is acceptable as the data structure of formulas, as for LISP, the<br>
structure can be described only with the functions of LISP itself, so here the characteristics<br>
of this LISP is taken advantage of, and the formulas like above are described.<br>
Though the similar things can be said about the pointers and such of the C<br>
language, as for the LISP language, there is possibility that each datum is shared, and the<br>
relationship between variables and data is not necessarily one for one. As a result, when<br>
certain data are modified, normally, whether they are related to particular symbols is not<br>
known when values are assigned to variables. Therefore, because the relational structure<br>
between such variables and data becomes a problem in realizing the constraint solution of<br>
the present invention, this is explained.<br>
Now, adding the symbol c indicating the same datum as the symbol b, an example<br>
that the internal data structure of the normal LISP language, which centers on the symbols<br>
a, b and c, is highly simplified, is shown in Fig.22. In the LISP language, all symbols are<br>
recorded in packages, and they are saved in separate name spaces, so it is described from<br>
packages here. Also, because the standard name of a name space is 'user', the symbols a, b<br>
and c are registered to 'user', but in this example the symbol b is also registered to another<br>
package.<br>
When b[l]=12 is executed with the LISP language,<br>
(setf (arefb 1) 12)<br>
is executed, but the function setf, which executes the assignment of values, is required to<br>
execute matching with constraints that are defined with the aforementioned function<br>
defconstraint2. On the other hand, data to be passed to the function setf are the pointers that<br>
are shown with (*) in Fig.22 in normal LISP, and no information to execute matching exists.<br>
Consequently, in case of such simple examples, when functions are evaluated, the method<br>
to carry about the information of not only the evaluation result but also that of the<br>
evaluated formulas until the execution of the function setf can be considered. However, in<br>
fact, response becomes difficult in cases where the data carried about become huge because<br>
they turn out to be very complicated formulas and b[l] in (setf (aref c 1) 12) is modified.<br>
To solve this, every basic data structure of the LISP language can be configured so<br>
that it can be tracked back bi-directionally. If the data structure is shown in a drawing as an<br>
example, it becomes like Fig.23. The array reference by means of the function aref, which<br>
is shown with (*) in Fig.23, holds not only the pointers inside the arrays, but also the<br>
information of arrays themselves, so that it can track back backward. All data that include<br>
array information save each kind of information, so that the information of bound symbols<br>
can be traced.<br>
Also, in fact, not only symbols but also registered package information have to be<br>
tracked back, and therefore, as for the symbols of constraints, it is necessary to consider<br>
packages. The routes in tracking back b[l] from (*), (user:b[l] including packages) are<br>
shown with bold arrows in Fig.23.<br>
By the way, the symbols of Common LISP have the information of home packages,<br>
but there are some cases where one symbol is saved in multiple packages As a result, it<br>
becomes necessary to add a new data structure, with which all packages that are registered<br>
are traced, but in this way, it becomes possible to check matching of constraints when setf<br>
is executed. As explained above, it is possible to deal with the present invention,<br>
completely fusing it with the functional programming language, which is representative as<br>
the LISP language.<br>
By means of the fusion with the functional programming language in<br>
aforementioned (A), it becomes possible to apply the present invention on the LISP<br>
language, and it becomes idealistic as the mounting on the functional programming<br>
language, but because matching of constraints is necessary every time assignment<br>
operation, for example, setf and such, is executed, execution efficiency gets worse in<br>
principle. Especially, on the occasion of matching with constraints backward in assigning<br>
(backward matching), whether relevant constraint definition exists or not cannot be known<br>
without tracking back considerably upward. Foe example, only index information, such as<br>
[1], can be known at the point of pointers, but even the simple constraints have such<br>
structures as a[x] and b[x], so it is only at the time of limited special conditions that<br>
whether any constraint conditions to be matched exist or not can be judged from only index<br>
information.<br>
On the other hand, in the case of matching tracked back from symbol names<br>
(variable names), in many cases, whether constraint conditions exist or not is known from<br>
the beginning, and it is possible to speed up the processes by adding such information to<br>
variables (symbols) themselves.<br>
Also, as for actual constraints, simple examples such as a[x] rarely appear, and matching<br>
with reverse direction always has to track back, probably completely, considerably<br>
complicated formulas fairly upward. When it is thought that this is mounted in the<br>
complicated package mechanism of actual Common LISP, mounting becomes very<br>
complicated, and though it is considered that more or less improvement can be expected by<br>
means of various methods as for execution time, compared to matching of constraints<br>
starting from variables, execution efficiency obviously becomes unrealistically bad.<br>
Consequently, as a realistic solution method, in cases where complete fusion is<br>
given up and constraint conditions are used, if formula-processing mechanism for exclusive<br>
use is prepared and limitation that values can always be referred to only from variables<br>
(symbols) inside it is added, aforementioned problems can be prevented. For example, as<br>
letter string data are expressed being enclosed within double quotations, if formula data are<br>
abstracted as one of data types and expressed being enclosed within question marks for<br>
example, the function peval is defined to execute formula processing mechanism for<br>
exclusive us, and assignment formulas are executed in the function peval, the<br>
aforementioned formula (18) can be described as follows.<br>
(peval'?a={ll,12, 13}?)<br>
(peval'?b={l,2,3}?)<br>
(defconstraint '?a[$i]=b[$i]+10?)<br>
And in cases where b[l]=12 is executed, it is acceptable to execute (peval '?b[l]=12?)<br>
In such cases, because it is decided that only reference from variables (symbols)<br>
can always be executed in formula processing, matching to opposite direction is<br>
unnecessary, so mounting problems, which are described in aforementioned (A), don't<br>
occur on the LISP language, and moreover, the other functions of the LISP language are<br>
never influenced, thus solving the problems of execution efficiency.<br>
However, needless to say, it is very unnatural as a programming language.<br>
Consequently, it is acceptable to newly define the grammar of the programming languages,<br>
and prepare parsers (syntax analysis tools) so that formula processing mechanism can be<br>
naturally used when assignment controls and such are executed. This is different from the<br>
original LISP language because the grammar is parsed in inputting and is replaced by<br>
internal expression that is LISP, but it becomes possible to realize the programming<br>
language, which has ability not to eminently decrease execution efficiency as a result of<br>
combining the advantages of the LISP language and this method.<br>
By the way, here, the basic elements of the programming languages that have the<br>
most major C-language type grammars, in which formula evaluation is always executed in<br>
the peval function basically, are shown, and thus the method to make the peval function<br>
used naturally is described. As can be understood if it is seen after conversion, though it<br>
has the C-language type grammars and can be described in the similar way as the<br>
C-language, it is LISP essentially, and there is an advantage in that it has flexible<br>
description ability. Moreover, it is possible to execute it while the pure LISP programming<br>
is completely mixed.<br>
The interpreting execution of formulas including functions that can be said to be<br>
the basic units of the present system is translated as follows. By the way, as for the type<br>
declaration, it is omitted because it is essentially irrelevant.<br>
Input:<br>
Formula interpretations and execution methods can be thought variously, and these<br>
conversion methods are just partial examples, but as for conversion methods, please note<br>
that various compiling techniques that are already established can be adapted. As just<br>
described, it is possible to design the extremely strong programming language, which<br>
naturally replaces the formula execution related with the constraints with the function peval<br>
to execute it and combines the characteristics of the present invention and LISP. Using this,<br>
as a result of describing Fig. 12 (a) and (b) with the powerful programming language, which<br>
is fused with the functional language, it becomes possible to execute it without dropping<br>
actual execution efficiency, while the Constraint-based Solvers shown in Fig.3, Fig.8 and<br>
Fig. 10 of the present invention are collecting all the functions of the existing procedural<br>
and functional programming. In this occasion, the operators shown in Fig.21 are realized in<br>
formula processing inside the function PEVAL.<br><other application examples of the present invention: combination with></other>
Designing Methods&gt;<br>
Also, the present invention can be applied in combination with designing methods. Though<br>
there are many kinds of development designing methods, whatever methods they are, there<br>
is a common concept that requirement wanted to be realized is analyzed first of all, then,<br>
the target specification that is developed to realize the requirement is determined, and the<br>
programs that satisfy the specification is developed. However, in case of the conventional<br>
procedural programming method, the behavior of the CPU had to be described as program<br>
codes in the end, whatever development method it may have. On the other hand, the<br>
declarative programming method hides the possibility to solve this problem, but it is a big<br>
problem that the execution efficiency of the computers is not good, as is described in the<br>
beginning. Accordingly, when it comes to the current general programming task, it often<br>
indicates the procedural programming method.<br>
By the way, as one of the system designing methods, there is data-oriented one.<br>
The data-oriented method is known as the method in which business systems can be<br>
designed well, but even though system designing is executed to realize requirements in this<br>
method, in the end, coding task is required, and the behaviors of the CPU have to be<br>
described as programming codes. As for the description of the behaviors of the CPU, today,<br>
even though software engineering is developed, essentially, it relies on the experience and<br>
hunch of programmers, and, in the present circumstances, development-designing task that<br>
exists in the domains of human creative task is tough. As a tool to decrease<br>
development-designing tasks, there are CASE tool and such. However, though these could<br>
decrease development tasks, as for the essential problem of making it unnecessary for<br>
humans to describe the behaviors of the CPU, it had not been solved yet.<br>
Consequently, though the solution of the aforementioned essential problems is<br>
neglected, in the conventional methods, instead, it is emphasized to reuse program codes,<br>
For example, the creation of libraries for software and the object-oriented programming<br>
languages have been conceptualized and produced with the purpose of reusing this.<br>
On the other hand, as for the present invention, though it is required to consider<br>
the behaviors of the computers, the complicated behaviors as were conventional need not<br>
be considered at all. That is, programmers are released from the task to describe the<br>
behaviors of the CPU directly, which is the common problem with each kind of designing<br>
methods, and there is no need of doing creative tasks in coding. Therefore, according to the<br>
present invention, it becomes possible to generate programming codes automatically from<br>
specifications as the advanced forms of the CASE tool, tools that resemble the CASE tools,<br>
and the other tools, and automatic programming can be realized.<br>
If the entire systems, not single computers, are designed and developed by means<br>
of the present invention, it is also possible to generate entire vast systems automatically. In<br>
this case, a great many variables and relational expressions are used, but needless to say, in<br>
the same way as the conventional designing methods, top-down designing methods and<br>
bottom-up designing methods can be realized, and moreover, dividing domains with<br>
functions and reusing divided domains are possible. Also, needless to say, the present<br>
invention can be applied to any development designing method in common.<br><other application examples of the present invention: to graphic></other>
Data and Robots&gt;<br>
As the further application examples of the present invention, applications to the models of<br>
computer graphics and moving parts of robots such as joints are explained. Here,<br>
complicated problems that are not directly related with the present invention, such as<br>
accuracy of robot controlling, are omitted, and the treatment of joints that are connected is<br>
only explained.<br>
Now, assuming that there are four joints A, B, C and D between connected dots a and e,<br>
and that the position between the joint A and B is b, B and C is c, and C and D is d, the<br>
relationships among the dots from a to e can be expressed with these five dots. In case<br>
where each dot is three-dimensional, which are expressed with vectors with three<br>
coordinates (x, y, z), the rotational behaviors of each joint are shown with the rotation<br>
matrix of 3 * 3.. By the way, it is acceptable to add the parallel movement component<br>
further to this rotation matrix and have the matrix of 4 * 4.<br>
To simplify the present problem, if only the rotation, omitting the length between<br>
each dot, is expressed with constraints, they are as follows.<br>
b = a * A . . . ( a )<br>
c = b*B...(b)<br>
d = c*C...(c)<br>
e = d * D . . . ( d )<br>
Here, A, B, C and D show the rotation matrixes of the corresponding joints.<br>
Normally, because there is limitation of movement range of the joints, there is also<br>
limitation of the values for each rotation matrix from A to B, so the user is supposed to<br>
describe this limitation with constraints. If a is fixed and the joint B is changed, it is<br>
necessary that the aforementioned order of constraint propagation, (b) -* (c) -* (d) is<br>
executed. Also, if there is the position e that is wanted to be moved against fixed a, by<br>
means of this constraint propagation, only necessary rotation components of each rotation<br>
matrix D, C, B and A is corrected and automatically fixed. The fact that a is fixed can be<br>
realized by adding variables showing that it is fixed as a constraint condition, or by making<br>
the system variables and relational expressions hold it as an attribute. Consequently, if each<br>
rotation matrix from A to B is assumed to be the angles of motors and such that control<br>
each joint, this can be applied to robot controlling. Also, if three-dimensional coordinates<br>
from a to e receive perspective transformation and they are plotted on display devices and<br>
such, they exist completely in the same way as the cases where they are applied to<br>
computer graphics.<br>
If the present invention is applied to these kinds of moving parts of robot joints and such,<br>
realistically they become more complicated, but still, it can be much more simply and<br>
naturally realized than realizing them in the procedural programming method. By the way,<br>
the application example for the moving parts of robot joints is only one of examples, and<br>
needless to say, any problem that resembles joints can be solved well.<br><other application examples of the present invention: to chemistry></other>
Fields, Physics Field and Simulation Fields &gt;<br>
Also, as the further application example of the present invention, application for Chemistry<br>
fields is explained.<br>
When Chemistry is dealt with, various modeling ways can be considered, but here, they are<br>
simplified for explanation, and only the contents that are directly related to the present<br>
invention are explained.<br>
To deal with each element in chemical formulas as objects, it is defined as a class<br>
by element type, and elements expected to be used are instantiated as appropriate. Each<br>
element object is made to have join conditions with other elements and element qualities as<br>
constraint conditions. Also, the combinations of elements are managed with chemical<br>
compound objects, and they are expressed registering element objects to chemical<br>
compound objects. In chemical compound objects, the qualities in cases where they are<br>
combined and combination conditions are held as constraint conditions. Configuring like<br>
this enables the user to modify the combinations of objects freely, but on the other hand,<br>
impossible combinations can be prohibited by means of constraint conditions, and the fact<br>
that the qualities of chemical compounds are updated can be known accordingly when the<br>
modification of the elements is successful. Also, in such occasions, for example, the<br>
conditions of electron are held as variables (attributes) in the element objects, constraint<br>
propagation related to electron variables takes place, and the behaviors of electron as<br>
physical phenomena can be expressed.<br>
As just described, the present invention can express chemical phenomena, physical<br>
ones and such efficiently, but this is the simulation of modeling certain situations and<br>
phenomenon occurrence, and constraint solution itself to variable modification is a<br>
particular phenomenon. By the way, needless to say, this method can be used for many<br>
simulation fields, without limiting them to chemical phenomena, physical ones and such.<br><other application examples of the present invention: to linear></other>
Programming (The Simplex Method and Such)<br>
Also, judging from the explanation so far, it would be obvious for skilled persons that the<br>
present invention can be applied in cases where the user can input constraint conditions of<br>
which the procedures for constraint propagation with regard to target problems are<br>
considered as for the constraint conditions described on linear programming such as the<br>
simplex method, integer programming and transportation problems typically.<br><other application examples of the present invention: to neural></other>
Network&gt;<br>
The neuron models on the neural network can be described with constraints that have<br>
threshold values as variables. Seen from this point of view, the bonds of neuron models on<br>
the neural network are special types of constraint relationship that are dealt with in this<br>
method, and can be regarded as subsets.<br>
According to the neural network, deciding the threshold values of each neuron model in the<br>
network to gain desired results is called learning, but in this learning it has been a subject<br>
how the threshold values to gain desired results are set. And as for the learning method, it<br>
has been conceptually close to conventional constraint programming for this method.<br>
However, setting the threshold values of neuron models is the variable value setting task,<br>
and it can be regarded as programming by means of the method described in the present<br>
invention. Therefore, the present invention can be applied to the neural network. That is, by<br>
means of the present invention, not only automatically adjusting values, but also the<br>
leaning method by setting partial or all of the threshold values considering behaviors can be<br>
realized.<br>
By the way, because the aforementioned contents are only partial examples to<br>
explain the technical ideas of the present invention, and they are not limited to them, so it is<br>
obvious that there is no difference in the constancy of fundamental technical ideas, even<br>
though those who have normal knowledge in the technical field of the present invention<br>
add or modify each configuration of Constraint-based Solvers and the definition methods<br>
of constraint conditions when the technical ideas of the present invention are realized.<br>
Also, needless to say, the purpose of the present invention can be attained through<br>
supplying storage media that store the programming codes of software that realize the<br>
functions of the Constraint-based Solvers 100, 200, 300 and 400 in the aforementioned<br>
embodiments with systems or devices and the computers of those systems or devices (or<br>
CPUs and MPUs) loading to execute the programming codes that are stored in storage<br>
media.<br>
In this case, programming codes themselves, which are loaded from storage media,<br>
realize the functions of these embodiments, and the storage media and the relevant<br>
programming codes turn out to configure the present invention. As storage media to supply<br>
programming codes, ROM, flexible disks, hard disks, optical disks, magnetic optical disks,<br>
CD-ROMs, CD-Rs, magnetic tapes, nonvolatile memory cards and such can be used.<br>
Also, needless to say, there included not only the cases where the<br>
above-mentioned functions of these embodiments are realized through executing<br>
programming codes that the computers load, but also the cases where the functions of these<br>
embodiments are realized by means of the processes that the OS and such, which is<br>
operating on the computer, executes partial or all of the actual processes based on the<br>
directions of such programming codes.<br>
[Simple Explanation of Drawings]<br>
[Fig.l] This is the overall configuration drawing which shows the basic constituent<br>
elements of the Constraint-based Solver in the first embodiment of the present invention.<br>
 [Fig.2] This is the flow chart that shows the operation order of the Constraint-based Solver<br>
in the first embodiment of the present invention.<br>
[Fig.3] This is the overall configuration drawing of the Constraint-based Solver in the<br>
second embodiment of the present invention.<br>
[Fig.4] This is the drawing that shows the mode example that Means for Constraint<br>
Condition Storage of the Constraint-based Solver in the first embodiment stores constraint<br>
conditions in the memory areas of computers.<br>
[Fig.5] This is the drawing that shows one example of the data structure with regard to<br>
accounting calculation problems.<br>
[Fig.6] This is the drawing that shows one example of the storage mode of constraint<br>
conditions with regard to accounting calculation problems.<br>
[Fig. 7] This is the drawing that shows one example of the data structure.<br>
[Fig. 8] This is the overall configuration drawing of the Constraint-based Solver in the third<br>
embodiment of the present invention.<br>
[Fig. 9] This is the drawing that shows the operation order of the solution method through<br>
the Means for Constraint Condition Extraction.<br>
[Fig. 10] This is the overall configuration drawing of the Constraint-based Solver in the<br>
fourth embodiment of the present invention.<br>
[Fig. 11] This is the conceptual drawing of the system that executes data display in<br>
combination with the Web server.<br>
[Fig. 12 (a) - (b)] This is the drawing that, with regard to the system that is shown in Fig.l 1,<br>
information stored in Means for Function Definition Holding and Means for Constraint<br>
Condition Storage and one example of constraint conditions are shown. [Fig. 13] This is the<br>
drawing that shows one example of describing the relationship between data and user<br>
interfaces with constraint conditions with regard to general window interfaces.<br>
[Fig. 14] This is the drawing that shows one example of the multi-window systems.<br>
[Fig. 15] This is the conceptual drawing that shows the configuration on the client side of<br>
the client/server system that realizes the window system.<br>
[Fig. 16] This is the drawing to explain that the GUI controller controls the operation of<br>
each part.<br>
[Fig. 17] This is the drawing that shows the solution order in the conventional declarative<br>
programming method.<br>
[Fig. 18] This is the conceptual drawing that shows the positioning between the<br>
conventional programming language environment and the Constraint-based Solver of the<br>
present invention, which searches for the solutions of constraint conditions.<br>
[Fig. 19] This is the conceptual drawing that shows the configuration of the conventional<br>
programming language environment.<br>
[Fig.20] This is the drawing that shows the concepts regarding classification putting data<br>
definitions together with constraints<br>
[Fig.21] This is the drawing that shows the example of operators in access the constraint<br>
conditions of the array structures.<br>
[Fig.22] This is the example of the drawing that shows one example that the internal data<br>
structure of the normal LISP language is highly simplified.<br>
[Fig.23] This is the drawing that shows one example that the basic structure of the LISP<br>
language can be tracked back bi-directionally.<br>
[Fig. 24 (a) - (h)] This is the drawing that shows the screen examples that the user inputs<br>
the constraint conditions and values and output the calculation results and such.<br>
[Explanation of Symbols]<br>
1 Means for Constraint Input<br>
2 Means for Variable Value Setting<br>
3 Means for Constraint Extraction 3<br>
4 Means for Constraint Solution Calculation<br>
5 Means for Variable Resetting<br>
6 Means for Constraint Condition Storage<br>
7 Means for Variable Value Storage<br>
8 Means for Constraint Extraction 3<br>
9 Means for Function Definition Holding<br>
10 Means for Function Definition Execution<br>
11 Databases<br>
12 System Resources<br>
100 Constraint-based Solver<br>
200 Constraint-based Solver<br>
300 Constraint-based Solver<br>
400 Constraint-based Solver<br><br><br><br><br><br><br><br><br><br><br><br>
We claim:<br>
1.	A method of shortening the time required for a processor to perform constraint-<br>
based optimization, the method comprising:<br>
receiving a set of constraints in a constraint condition inputting means (1) and storing the set of constraints in a memory;<br>
receiving a set of variable values in a variable value setting means (2) of a processor, referenced by one or more of the constraints in the set of constraints and storing the set of variable values in the memory;<br>
extracting one or more of the constraints in the set of constraints, in a constraint condition extraction means (3) of the processor, which reference variables whose values have been modified;<br>
resolving the extracted one or more of the constraints using the one or more variables values that have been modified and based on a predetermined order in a constraint condition reckoning module of the processor;<br>
characterized in that<br>
identifying variable values in a variable value resetting means (5) of the processor, that have been modified by the constraint condition reckoning module and electronically communicating to the variable value setting means (2) which variable values have been modified; and<br>
continuing to extract one or more of the constraints in the constraint condition extraction means (3), while there is at least one variable value that has been modified;<br>
whereby at least one of the constraint condition reckoning module and the variable value resetting means(5) operates to shorten the processing time required by the processor.<br>
2.	The method as claimed in Claim 1, wherein the method comprises searching for variable values in the constraint condition reckoning module to modify one or more of the extracted constraints.<br>
3.	The method as claimed in Claim 1, wherein the method comprises<br><br>
selecting a set of constraint conditions that are related to a first modified variable value of the modified variable values;<br>
selecting a first constraint condition of the set of constraint conditions;<br>
solving the first constraint condition and searching for a second set of modified variable values that had to be modified to solve the first constraint condition; and<br>
adding the second set of variable values to the identified variable values that have been modified.<br>
4.        A system implemented in the method claimed in claim 1, the system comprising:<br>
a computer-readable memory;<br>
a computer processor, the processor being communicatively connected to the memory;<br>
a constraint condition inputting module configured to cause the processor to receive a set of constraints and to store the set of constraints in the memory;<br>
a variable value setting module configured to cause the processor to receive a set of variable values referenced by one or more of the constraints in the set of constraints and to store the set of variable values in the memory;<br>
a constraint condition extraction module configured to cause the processor to extract one or more of the constraints in the set of constraints which reference variables whose values have been modified;<br>
a constraint condition reckoning module configured to cause the processor to<br>
resolve the extracted one or more of the constraints using the one or more<br>
variables values that have been modified and based on a predetermined order;<br>
wherein<br>
a variable value resetting module configured to cause the processor to identify variable values that have been modified by the constraint condition reckoning module and to electronically communicate to the variable value setting module which variable values have been modified; and<br>
the constraint condition extraction module configured to cause the processor to continue extracting one or more of the constraints while there is at least one variable value that has been modified;<br><br>
whereby at least one of the constraint condition reckoning module and the variable value resetting module operates to shorten the processing time required by the processor.</the></the></the></the></the></a></conditional></basic></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1ERUxOUC0yMDA2LUFic3RyYWN0LSgxMS0xMC0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">4503-DELNP-2006-Abstract-(11-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1ERUxOUC0yMDA2LUFic3RyYWN0LSgyMi0xMS0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">4503-DELNP-2006-Abstract-(22-11-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1kZWxucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">4503-delnp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1ERUxOUC0yMDA2LUNsYWltcy0oMTEtMTAtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">4503-DELNP-2006-Claims-(11-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1ERUxOUC0yMDA2LUNsYWltcy0oMjItMTEtMjAxMCkucGRm" target="_blank" style="word-wrap:break-word;">4503-DELNP-2006-Claims-(22-11-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1kZWxucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">4503-delnp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMTEtMTAtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">4503-DELNP-2006-Correspondence Others-(11-10-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlLU90aGVycy0oMjItMTEtMjAxMCkucGRm" target="_blank" style="word-wrap:break-word;">4503-DELNP-2006-Correspondence-Others-(22-11-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1kZWxucC0yMDA2LWNvcnJlc3BvbmRlbmNlLW90aGVycy0xLnBkZg==" target="_blank" style="word-wrap:break-word;">4503-delnp-2006-correspondence-others-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1kZWxucC0yMDA2LWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">4503-delnp-2006-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1kZWxucC0yMDA2LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">4503-delnp-2006-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1ERUxOUC0yMDA2LURyYXdpbmdzLSgyMi0xMS0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">4503-DELNP-2006-Drawings-(22-11-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1kZWxucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">4503-delnp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1kZWxucC0yMDA2LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">4503-delnp-2006-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1kZWxucC0yMDA2LWZvcm0tMTMucGRm" target="_blank" style="word-wrap:break-word;">4503-delnp-2006-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1kZWxucC0yMDA2LWZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">4503-delnp-2006-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1kZWxucC0yMDA2LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">4503-delnp-2006-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1kZWxucC0yMDA2LWZvcm0tMjYucGRm" target="_blank" style="word-wrap:break-word;">4503-delnp-2006-form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1kZWxucC0yMDA2LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">4503-delnp-2006-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDUwMy1kZWxucC0yMDA2LWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">4503-delnp-2006-form-5.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="250314-electronic-apparatus-control-method-and-program-thereof-and-battery-for-operating-electronic-apparatus.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="250316-an-inkjet-printing-apparatus.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>250315</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>4503/DELNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>52/2011</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>30-Dec-2011</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>22-Dec-2011</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>03-Aug-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>METALOGIC, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>26-14, TOYOTAMAMINAMI 3-CHOME, NERIMA-KU, TOKYO 1760014 (JP)</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>FUKUI TOSHIO</td>
											<td>26-14 TOYOTAMAMINAMI 3-CHOME, NERIMA-KU, TOKYO 1760014 (JP)</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06N 5/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/JP2005/000752</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-01-21</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>2004-013629</td>
									<td>2004-01-21</td>
								    <td>Japan</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/250315-a-method-and-system-of-shortening-the-time-required-for-a-processor-to-perform-constraint-based-optimization by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:30:24 GMT -->
</html>
