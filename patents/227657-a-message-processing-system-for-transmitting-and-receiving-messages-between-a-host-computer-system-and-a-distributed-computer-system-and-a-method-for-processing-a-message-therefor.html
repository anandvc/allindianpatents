<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/227657-a-message-processing-system-for-transmitting-and-receiving-messages-between-a-host-computer-system-and-a-distributed-computer-system-and-a-method-for-processing-a-message-therefor by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 07:45:02 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 227657:A MESSAGE PROCESSING SYSTEM FOR TRANSMITTING AND RECEIVING MESSAGES BETWEEN A HOST COMPUTER SYSTEM AND A DISTRIBUTED COMPUTER SYSTEM, AND A METHOD FOR PROCESSING A MESSAGE THEREFOR .</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A MESSAGE PROCESSING SYSTEM FOR TRANSMITTING AND RECEIVING MESSAGES BETWEEN A HOST COMPUTER SYSTEM AND A DISTRIBUTED COMPUTER SYSTEM, AND A METHOD FOR PROCESSING A MESSAGE THEREFOR .</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Exchanging electronic messages between an online transaction processing host computer system (102) and a distributed computer system (122) over a communication network (106). This communication exchange encompasses both guaranteed delivery of electronic messages and non-guaranteed delivery of native terminal screen and printer messages, utilizing a message queuing facility. A two-tier architecture is used for all message translations, blocking and reassembling, queuing, acknowledgments and retransmissions, generally reducing necessary message processing and reducing use of system resources.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>A MESSAGE PROCESSING SYSTEM FOR TRANSMITTING AND RECEIVING<br>
MESSAGES BETWEEN A HOST COMPUTER SYSTEM AND A DISTRIBUTED<br>
COMPUTER SYSTEM, AND A METHOD FOR PROCESSING A MESSAGE<br>
THEREFOR.<br>
PRIORITY AND RELATED APPLICATIONS<br>
The present application claims priority to a provisional patent<br>
application entitled, "System and Method for Exchanging Electronic Messages<br>
Between a Host Computer System and a Distributed Computer System," filed on<br>
January 2, 2001 and assigned U.S. Application Serial No. 60/259,477.<br>
TECHNICAL FIELD<br>
The present invention generally relates to exchanging electronic<br>
messages, in a defined format, between a host computer system and a distributed<br>
computer system. More specifically, the invention supports both the guaranteed<br>
delivery and the non-guaranteed delivery of messages between an online transaction<br>
processing host system and a distributed computer system using a two-tier architecture<br>
and a message queue.<br>
BACKGROUND OF THE INVENTION<br>
Increased competition in the airline industry is stimulating the<br>
development of new applications of information technology, including a new strategic<br>
focus on electronic commerce. In addition, airplane travel is becoming an<br>
increasingly popular method of travel for people today. This popularity, along with<br>
increased competition, has caused the number of airplane travelers to increase<br>
dramatically resulting in a greater volume of travelers passing through today's<br>
airports. Accordingly, airlines need more efficient ways to handle their travelers,<br>
including the wider implementation of electronic commerce applications.<br><br>
Traditionally, large enterprise computing in the airline industry has<br>
relied on using clusters of mainframes running proprietary information systems<br>
software. For example, some companies rely on clusters of IBM S/390 mainframe<br>
computers running IBM TPF (Transaction Processing Facility or "TPF") (or even<br>
older systems running IBM MVS (Multiple Virtual Storage or "MVS")), both<br>
specialized operating systems. Such traditional online transaction processing systems<br>
("OLTP") support applications that automate the majority of an airline's operational<br>
services. Systems architectures, such as TPF and MVS, have proven to be highly<br>
scaleable and available, and these systems have operated successfully over the last<br>
thirty years and through the Y2K software "bug" scare.<br>
Despite their reliability and scalability, however, it is difficult to<br>
modify these existing OLTP software applications to accommodate a changing<br>
industry. Many of the software applications utilized on OLTP systems were<br>
developed in assembly language and have evolved over a period of more than thirty<br>
years. Originally, these applications were designed to implement specific business<br>
models and currently offer little flexibility to support new business models and<br>
processes. Specifically, these applications maintain ownership of rigidly defined data<br>
sets, and their legacy data formats offer little opportunity for creating new<br>
relationships with data from other applications. Additionally, new business models<br>
have resulted in the development of new software applications, some of which<br>
leverage the Internet. These new business models and new software applications<br>
expose the legacy systems to unforeseen transaction types, formats and volumes.<br>
In response to these limitations, a novel strategy has been the addition<br>
of distributed computer systems based on newer technology and new software<br>
applications. The wealth of information in the existing OLTP systems is harvested by<br>
"grabbing" strategic transactions as they occur in "soft real-time", i.e., substantially<br>
real-time. These transactions are then transferred to the distributed computer systems<br>
and distributed software applications. In this new environment, the data resulting<br>
from the transactions is mapped into alternative evolvable formats and is correlated<br>
with previously unrelated information, as well as with information from sources other<br><br>
than the OLTP systems. The immediate correlation stimulates events, which are<br>
derived from the transaction histories. This enables an entirely new class of real-time<br>
event-based applications, which have proven to radically improve the efficiency of<br>
airline computing operations. The newer distributed computer system, considered in<br>
concert with the legacy OLTP system, serves as the basis for constructing new<br>
applications and improving airline business operations.<br>
However, the use of a distributed computer system in concert with a<br>
legacy OLTP system, is hampered by the fact that current native OLTP host systems<br>
standing alone, such as those based on IBM TPF, are only capable of communication<br>
with distributed computer systems using either terminal or printer message formats.<br>
These formats are text character data streams where the data is formatted for display<br>
on a user's terminal screen or for printing on a terminal printer. If the end user of the<br>
data is actually a non-OLTP software application, then it must programmatically parse<br>
an OLTP data stream for the critical information it needs utilizing the well-known<br>
technique referred to in the art as "screen-scraping".<br>
This situation is problematic because a software application in the<br>
OLTP host and a software application located at an individual workstation or terminal<br>
in a distributed computer system must both extract specific data based on its position<br>
within a text character data stream. Both applications also must understand a variety<br>
of error responses and understand how to respond programmatically to such<br>
responses. Providing this type of functionality to each distributed computer<br>
application has proven time consuming and inefficient.<br>
An additional problem with this type of conventional art screen-<br>
scraping system exists because terminal screen messages are generally limited to the<br>
amount of information that is displayable on one mainframe terminal screen. A<br>
mainframe terminal screen is normally limited in size to either twelve (12) or twenty-<br>
five (25) lines of text by sixty-four (64) columns of text. Larger data transfers in<br>
terminal screen message format require multiple message transfers between a host<br>
application and distributed applications. Another problem with native IBM TPF<br>
communication is that terminal messages are not considered by those skilled in the art<br><br>
to be reliable, as there is no guaranteed messaging protocol between host applications<br>
and distributed terminal applications. As a result, distributed applications utilizing<br>
terminal messages have been obligated to be designed to provide for message<br>
reliability.<br>
One conventional art proprietary system supports improved<br>
host/distributed system message communications by addressing some of the problems<br>
described above. This system allowed IBM TPF host systems and distributed<br>
computer systems to exchange data in any pre-selected format using a reliable,<br>
guaranteed, message queuing facility. The pre-selected data format is coordinated<br>
between the host system and distributed applications and can be, but is not limited to,<br>
structured, delimited text of any character set, structured binary data and/or some<br>
combination of these formats and native text terminal data streams. This system also<br>
trovided a mechanism for exchanging larger messages between the host and<br>
distributed applications by breaking larger messages from a sending application into<br>
smaller blocks of data for transmission and reassembling the message prior to<br>
delivering it to a receiving application.<br>
Because this conventional art system supported new message formats<br>
and larger message sizes, it allowed host systems and distributed computer systems to<br>
communicate more efficiently, avoided the use of "screen-scraping" and allowed<br>
multiple message transfers. In addition, the system supported message queuing and an<br>
associated protocol for guaranteed delivery of messages, thereby relieving individual<br>
applications of this burden. Thus, a copy of any particular message is held in a<br>
message queue at the delivery side of the system until the receiving end of the system<br>
sends back an acknowledgment message. If the acknowledgment is received the<br>
queued message is deleted. If the acknowledgment is not received, the delivery side<br>
of the system resends the queued message.<br>
However, the architecture of this conventional art system requires a<br>
gateway process located between the message transmission component located within<br>
the host computer system and the message transmission component located on various<br>
distributed computers, in order to enable some of its key features. The system<br><br>
gateway is required to accomplish the processes of message blocking and<br>
reassembling, message translation and message queuing, and to provide reliable<br>
protocols for communication between the host and distributed system environments.<br>
Thus, the system gateway, along with the host and the distributed system components,<br>
comprises a three-tier architecture for the guaranteed delivery of electronic messages<br>
in any defined format between a host system and a distributed computer system. The<br>
requirement of the system gateway added an additional component to the system<br>
architecture, thereby requiring additional hardware and software components and<br>
increased processing of each electronic message within the system gateway. This<br>
results in slower system performance, less reliable operation and a less scalable<br>
system.<br>
Also, the system gateway process, along with the system program<br>
interface for distributed applications, was first created for the IBM personal computer<br>
DOS platform and then was migrated to the MICROSOFT WINDOWS operating<br>
system and to various UNIX platforms. As a result, these system components were<br>
built using less efficient programming techniques that were common to the single<br>
tasking nature of the DOS environment. This fact also limited the performance and<br>
scalability of this conventional art solution when it migrated to modern computing<br>
environments like the MICROSOFT WINDOWS operating system and to various<br>
UNIX platforms.<br>
Another conventional art proprietary distributed system programming<br>
interface was also developed for use with native terminal and printer data streams in<br>
combination with distributed computer systems. The interface was designed to work<br>
with the Airline Link Control protocol ("ALC"), which is a full-duplex, synchronous<br>
6-bit protocol that is supported by the industry-standard Programmed Airline<br>
Reservation System ("PARS") and the industry-standard International Programmed<br>
Airline Reservation System ("IPARS"). Thus, until now, developers of distributed<br>
applications in the airline industry have been forced to choose between utilizing the<br>
interface from the first conventional art messaging system noted above or the<br>
conventional art ALC program interface. This choice presented a problem for<br><br>
developers as these two interfaces, while having some overlapping functionality, also<br>
have some differing functionality.<br>
Consequently, there is a need in the art for a method and system which<br>
will further improve communication between OLTP host systems and distributed<br>
computer systems over the existing three-tier message systems and the conventional<br>
art ALC interface. There is also a need for a system that will encompass both the non-<br>
guaranteed delivery of native terminal and printer messaging and delivery in the<br>
existing conventional art messaging format through a reliable, guaranteed, message<br>
queuing facility. There is also a need for a system that wall replace the interface from<br>
the first conventional art messaging system and the conventional art ALC program<br>
interface so that distributed computer application developers will no longer be forced<br>
to choose between two differing messaging interfaces.<br>
There is a further need in the art for a method and system for<br>
exchanging electronic messages between a host system and distributed computer<br>
systems that utilize modern programming techniques to achieve better performance<br>
and greater scalability. Such techniques would include using event-driven<br>
mechanisms, versus polling or event loop style logic, and multiplexing multiple<br>
communication sessions across a single physical connection between the host and the<br>
distributed systems.<br>
Finally, there is a further need in the art for a method and system that<br>
eliminates the need for a gateway process between the host and distributed systems so<br>
as to more efficiently utilize system resources.<br><br>
SUMMARY OF THE INVENTION<br>
The present invention solves the aforementioned problems existing in<br>
the conventional art by providing for a method and system for exchanging electronic<br>
messages between a host system and distributed computer systems that encompasses<br>
both native terminal and printer messaging as well as the conventional art messaging<br>
formats. The present invention provides a choice between reliable, guaranteed<br>
electronic message delivery via a message queuing facility and non-guaranteed<br>
electronic message delivery.<br>
The present invention also can eliminate the need for a gateway<br>
process between the host and distributed systems by providing for all message<br>
translations, blocking and reassembling, queuing, acknowledgments and<br>
retransmissions at the endpoints of the host and distributed systems, generally<br>
reducing necessary message processing. As a result, the present invention supports<br>
functionality residing within the host system and the distributed system resulting in a<br>
novel, two-tier messaging architecture. In addition, the present invention provides<br>
functionality that supports both the conventional art three-tier messaging system<br>
interface and the ALC interface so that distributed application developers no longer<br>
must choose between messaging interfaces.<br>
The present invention can also utilize modern programming techniques<br>
which enable it to provide for better performance and greater scalability. As a result,<br>
the present invention may allow for better message throughput rates and response<br>
times with increased utilization of existing network resources. The programming<br>
techniques utilized by the present invention may include using event-driven<br>
mechanisms versus polling or event loop style logic and multiplexing multiple<br>
communication sessions across a single physical connection between the host and the<br>
distributed systems.<br>
The present invention may utilize an online transaction processing host<br>
computer system, which includes at least one host computer program application, a<br>
distributed computer system, including at least one distributed computer workstation<br>
and at least one distributed computer program application, and a communications<br><br>
network connecting the host and distributed computer systems. In addition, the<br>
present invention may utilize a host electronic message transmission application,<br>
which includes a message queue and a distributed computer electronic message<br>
transmission application, which also includes a message queue. The present invention<br>
may also utilize a distributed computer program interface, which operates as an<br>
interface between the distributed computer electronic message transmission<br>
application and the distributed computer program application.<br>
Utilizing the above components, the present invention supports a<br>
process for delivering electronic messages between host computer program<br>
applications and distributed computer program applications. This process may be<br>
initiated by the generation of an electronic message in either a host computer program<br>
application or a distributed computer program application.<br>
If the process requires guaranteed delivery and the message is initiated<br>
in the host, the message may be passed to the host electronic message transmission<br>
application, where it is processed before being transmitted across the communications<br>
network to the distributed computer electronic message transmission application,<br>
where the message is again processed. In addition, the host transmission application<br>
may utilize a message queue which retains a copy of the message until receipt is<br>
acknowledged by the distributed computer transmission application. If no<br>
acknowledgment is received, the host resends the message until acknowledged. Next,<br>
the message is passed to the distributed computer program interface, which in turn<br>
passes the message to the distributed computer program application. If the process is<br>
initiated in the distributed computer application, the process is merely reversed, with<br>
the distributed computer transmission application retaining a copy of the message in<br>
its queue.<br>
Where the process does not require guaranteed delivery, the electronic<br>
messages may be delivered in terminal screen and/or printer format. In such cases, the<br>
host system and distributed systems do not retain copies of the messages after they are<br>
sent from their respective transmission applications.<br><br>
BRIEF DESCRIPTION OF THE ACCOMPANYING DRAWINGS<br>
Figure 1 is a functional block diagram illustrating the architecture and<br>
components of an exemplary embodiment of the present invention.<br>
Figure 2 is a logic flow diagram illustrating the interaction and<br>
functionality of the architecture and components of the present invention.<br>
Figure 3 is a logic flow diagram illustrating an exemplary process for<br>
exchanging an electronic defined format request message between a distributed<br>
computer system application and a host computer system application and for<br>
guaranteeing delivery of same.<br>
Figure 4A is an illustration of the components of an exemplary<br>
electronic defined format request or reply message utilized by an exemplary<br>
embodiment of the present invention.<br>
Figure 4B is an illustration of an exemplary data record to be<br>
exchanged between a distributed computer system application and an exemplary<br>
program interface utilized by an exemplary embodiment of the present invention.<br>
Figure 4C is an illustration of an exemplary data record to be<br>
exchanged between an exemplary program interface and a distributed computer<br>
system message transmission application utilized by an exemplary embodiment of the<br>
present invention.<br>
Figure 5 is a functional block diagram illustrating the architecture and<br>
components utilized in an electronic defined format request message delivery process<br>
carried out by an exemplary embodiment of the present invention.<br>
Figure 6 is a functional block diagram illustrating the architecture and<br>
components utilized in an electronic defined format reply message delivery process<br>
carried out by an exemplary embodiment of the present invention.<br>
Figure 7 is an illustration of the components of an exemplary electronic<br>
defined format request or reply data block to be transferred between a host computer<br>
system electronic message transmission application and a distributed message<br><br>
transmission application utilized by an exemplary embodiment of the present<br>
invention.<br>
Figure 8 is a logic flow diagram illustrating an exemplary process for<br>
exchanging an electronic defined format reply message between a host computer<br>
system application and a distributed computer system application and for guaranteeing<br>
delivery of same.<br>
Figure 9 is a logic flow diagram illustrating an exemplary process for<br>
exchanging an electronic message request/reply sequence in native terminal screen<br>
format between a host computer system application and a distributed computer system<br>
application.<br>
Figure 10 is an illustration of the components of an exemplary<br>
electronic terminal screen reply message to be transferred between a host computer<br>
system application and a distributed computer system application utilized by an<br>
exemplary embodiment of the present invention.<br>
Figure 11A is an illustration of the components of an exemplary<br>
electronic native terminal screen or printer request data block to be transferred<br>
between a distributed message transmission application and the host computer system<br>
utilized by an exemplary embodiment of the present invention.<br>
Figure 11B is an illustration of the components of an exemplary<br>
electronic terminal screen or printer reply data block to be transferred between a host<br>
computer system application a distributed message transmission application utilized<br>
by an exemplary embodiment of the present invention.<br>
Figure 12 is a functional block diagram illustrating the architecture and<br>
components utilized in an electronic terminal screen reply message delivery process<br>
carried out by an exemplary embodiment of the present invention.<br>
Figure 13 is an illustration of the components of an exemplary<br>
electronic terminal screen or printer request or reply message to be transferred<br>
between an exemplary program interface and the distributed computer system<br>
application utilized by an exemplary embodiment of the present invention.<br><br>
Figure 14 is a logic flow diagram illustrating an exemplary process for<br>
exchanging an electronic message in native printer format between a host computer<br>
system application and a distributed computer system printer application.<br>
Figure 15 is an illustration of the components of an exemplary<br>
electronic printer reply message to be transferred between a host computer system<br>
application and a distributed computer system printer application utilized by an<br>
exemplary embodiment of the present invention.<br>
Figure 16 is a functional block diagram illustrating the architecture and<br>
components utilized in an electronic printer reply message delivery process carried out<br>
by an alternative exemplary embodiment of the present invention.<br>
Figure 17 is a functional block diagram depicting the architecture and<br>
components of the distributed computer program interface of an exemplary<br>
embodiment of the present invention.<br>
Figure 18 is a flowchart depicting an exemplary process for processing<br>
a message received from an application.<br>
Figure 19 is a block diagram depicting an exemplary peer-to-peer<br>
distributed computer network structure.<br>
Figure 20 is a block diagram depicting an exemplary client-server<br>
distributed computer network structure.<br>
Figure 21 is a block diagram depicting an exemplary wide area client-<br>
server distributed computer network structure.<br>
Figure 22 is a block diagram depicting an exemplary synchronous<br>
response requested message processing service.<br>
Figure 23 is a block diagram depicting an exemplary asynchronous<br>
response requested message processing service.<br>
Figure 24 is a block diagram depicting an exemplary send-and-forget<br>
message processing service.<br>
Figure 25 is a block diagram depicting an exemplary publish-subscribe<br>
message processing service.<br><br>
DETAILED DESCRIPTION OF THE EXEMPLARY EMBODIMENTS<br>
The present invention provides for improved exchange of electronic<br>
messages, in any defined format or in native TPF terminal screen or printer format,<br>
between an OLTP host computer system and a distributed computer system.<br>
Additionally, it allows guaranteed delivery of defined format messages using a<br>
message queuing mechanism. The present invention also provides for non-guaranteed<br>
delivery when such result is desirable. In an exemplary embodiment, the present<br>
invention provides for the exchange of such messages through a two-tier architecture,<br>
which is an improvement over conventional art three-tier systems.<br>
Although the exemplary embodiments described herein include general<br>
descriptions of software modules running in a generalized distributed computing<br>
environment, those skilled in the art will recognize that the present invention can be<br>
implemented in a variety of hardware and software configurations. In a distributed<br>
computing environment, program modules may be physically located in different local<br>
and remote memory storage devices. Execution of the program modules may occur<br>
locally in a stand-alone manner or remotely in a client/server manner. Examples of<br>
such distributed computing environments include local area networks of an office,<br>
enterprise-wide computer networks, and the global Internet.<br>
Referring now to the drawings, in which like numerals represent like<br>
elements throughout the several figures, aspects of the present invention and the<br>
preferred operating environment will be described. Figure 1 illustrates the<br>
architecture and components of an exemplary embodiment of the present invention.<br>
In this embodiment, the system 100 comprises a host computer system 102, a<br>
distributed computer system 104 and a communications network 106.<br>
The host computer system 102 further comprises at least one host<br>
computer program application 108, wherein electronic messages may be generated<br>
and/or received for processing. The host computer system 102 also includes a host<br>
message transmission application 110, which further comprises a message queue 112<br>
for the purpose of assembling and disassembling messages, converting message<br>
formats, message translations, queuing, acknowledgments and retransmissions within<br><br>
the host computer system 102. In addition, the host computer system 102 includes an<br>
output formatting application 114, further comprising a message queue 116 and an<br>
input message parser 118, both of which provide functionality for the output and input<br>
of electronic terminal screen request/reply messages. Also, the host computer system<br>
includes a queue 120 for use with the transmission of electronic printer reply<br>
messages.<br>
The distributed computer system 104 further comprises at least one<br>
distributed computer system workstation 122. The distributed computer workstation<br>
122 includes a distributed message transmission application 124, further comprising a<br>
message queue 126, for the purpose of assembling and disassembling messages,<br>
converting message formats, message translations, queuing, acknowledgments and<br>
retransmissions within the distributed computer system 104. The distributed<br>
computer workstation 122 also includes at least one distributed application 128 and a<br>
distributed printer application 130, along with a terminal printer 131. In addition, the<br>
distributed computer workstation 122 includes a distributed computer program<br>
interface 132 for operation between the distributed application 128 and the distributed<br>
message transmission application 124.<br>
One of the improvements of the present invention over the<br>
conventional art that can be seen in Figure 1A is the absence of a gateway process<br>
contained within the communications network 106 and utilization of the distributed<br>
message transmission application 124 within the distributed computer workstation<br>
122. Thus, the present invention comprises a two-tier architecture, i.e., an architecture<br>
where the functions of assembling and disassembling messages occur in only two<br>
computer program applications 110, 124 within the overall message transfer system as<br>
opposed to a three-tier architecture where these functions occur in three computer<br>
applications. Specifically, all message translations, blocking and reassembling,<br>
queuing, acknowledgments, and retransmissions occur at the origination and<br>
termination points for message delivery across the communications network 106.<br>
Origination and termination points include the host message transmission application<br>
110 or the input message parser 118 in the host computer system 102 and the<br><br>
distributed message transmission application 124 in the distributed computer system<br>
workstation 122. This novel architecture generally reduces by one half the amount of<br>
message processing as conventional art systems required message processing both in a<br>
gateway process contained within the communication network 106 and through a<br>
conventional art distributed computer system message transmission application.<br>
The distributed message transmission application 124 is a separate<br>
distributed application and is the messaging endpoint for the distributed computer<br>
workstation 122. All electronic request and reply messages that are transferred<br>
between any number of other distributed applications 128 and corresponding host<br>
applications 108 pass through the distributed message transmission application 124.<br>
The distributed message transmission application 124 may be attached to each of the<br>
other distributed applications 128 through individual communication connections to<br>
multiple instances of the distributed computer program interface 132 built into each<br>
distributed application 128.<br>
The distributed message transmission application 124 may also be<br>
attached to the communication network 106 through communication connections to<br>
communication network connection devices within the communication network 106<br>
that are well known in the art. The communication network connection devices are<br>
responsible for concentrating messages from many distributed computer workstations<br>
122 onto higher capacity communication connections to the TPF host computer<br>
system 102. The distributed message transmission application 124 may have a<br>
number of communication connections to the communication network connection<br>
devices as required by the distributed computer workstations 122 for redundancy or<br>
load balancing.<br>
The distributed applications 128 may invoke the distributed computer<br>
program interface 132 to initiate a messaging session with the host computer system<br>
102 thereby indirectly creating the communication connections to the communication<br>
network connection devices noted above. The distributed message transmission<br>
application 124 further comprises a messaging queue 126 which stores guaranteed-<br>
delivery electronic messages between the distributed application 128 and the host<br><br>
electronic message transmission application 110 for retransmission in the event an<br>
electronic message is lost or otherwise unacknowledged by the host computer system<br>
102. The distributed message transmission application 124 also provides functionality<br>
for the translation and conversion of native terminal screen and printer messages<br>
between the distributed applications 128 and the host applications 108. Translation<br>
describes the process of converting ASCII characters to EBCDIC (Extended Binary-<br>
Coded Decimal Interchange Code, pronounced eb-sih-dik) in text fields.<br>
EBCDIC is an IBM code for representing characters as numbers.<br>
Although it is widely used on-large, mainframe IBM computers, most other<br>
computers, including MICROSOFT WINDOWS-based PCs and Macintosh<br>
computers, use ASCII codes. However, those skilled in the art will appreciate that<br>
such translation could occur between any commonly utilized code, like ASCII, and<br>
any proprietary code used by OLTP systems. Specifically, in an exemplary<br>
embodiment, of the present invention, translation describes the process of converting<br>
the text characters from ASCII to EBCDIC in electronic request messages from the<br>
distributed applications 128 to the host applications 108 and converting the text<br>
characters from EBCDIC to ASCII on electronic reply messages from the host<br>
applications 108 to the distributed applications 128. Conversion describes the process<br>
of reformatting the electronic request messages from the distributed computer format<br>
of the distributed application 128 to a native TPF host computer system 102 format<br>
and reformatting the electronic reply messages from the native TPF host computer<br>
system 102 format to the distributed computer program interface format of the<br>
distributed application 128.<br>
Other functionality within the distributed message transmission<br>
application 124 supports its electronic messaging functionality and includes the ability<br>
to configure the distributed message transmission application 124 from computer files<br>
and/or through an electronic interface and the ability to log electronic messaging<br>
activity and provide statistics through computer files and/or through an electronic<br>
interface.<br><br>
In addition, this exemplary embodiment utilizes a novel distributed<br>
computer program interface 132 to send and receive messages. The distributed<br>
computer program interface 132 eliminates the requirement that distributed<br>
applications 128 provide for either a conventional art message transmission interface<br>
or an ALC interface by providing translation functionality for each type of<br>
conventional art format. The distributed computer program interface 132, in<br>
combination with the distributed message transmission application 124, also provides<br>
the flexibility of sending messages with guaranteed delivery or non-guaranteed<br>
delivery. Thus, the present invention can now interact with the host computer system<br>
102 utilizing either non-guaranteed native TPF host terminal or printer messaging<br>
and/or guaranteed messaging utilizing defined format messages, each where<br>
appropriate.<br>
The functionality of the distributed computer program interface 132 is<br>
provided through a set of computer program functions invoked by the distributed<br>
applications 128. The program functions "create", "send", "sendRequest", "call",<br>
"subscribe", "unsubscribe", "startMonitor", "stopMonitor", "isActive", and "destroy",<br>
and the distributed application 128 program callback function, "handle", comprise the<br>
functionality of the distributed computer program interface 132 and are described<br>
herein.<br>
In an exemplary embodiment, the distributed application 128 invokes<br>
the "create" program function to initiate a messaging session with the TPF host<br>
computer system 102 through the distributed message transmission application 124<br>
and the communication network 106. The details of the messaging session<br>
configuration are insulated from the distributed application 128, which simply utilizes<br>
a text name to identify the messaging session. The distributed computer program<br>
interface 132 utilizes a computer configuration file, located within the distributed<br>
computer workstation 122, to reference the configuration details of the messaging<br>
session based on the name provided by the distributed application 128. The<br>
configuration details of the messaging session include information pertaining to the<br>
specific host resource utilized during the messaging session, including whether the<br><br>
messaging session is a native TPF host computer system 102 terminal or printer<br>
session, how the host portion of the messaging session maps to a communication<br>
network 106 resource and/or details on creating communication connections between<br>
the distributed computer program interface 132 and the distributed message<br>
transmission application 124, and also between the communication network<br>
connection device and the distributed message transmission application 124.<br>
Native TPF host computer system terminal messaging sessions can be<br>
utilized for either native terminal screen request and reply messages or for defined<br>
format request and reply messages. The defined format request and reply messages<br>
are identified to the TPF host computer system 102 and the distributed message<br>
transmission application 124 by the presence of a special indicator on the front of each<br>
defined format request or reply message.<br>
The distributed application 128, after preparing a request message, may<br>
invoke various program functions, including a "send," "sendRequest," or "call"<br>
program function to send the message to the host application 108 through the<br>
distributed message transmission application 124. The "send" program function is<br>
utilized by the distributed application 128 to send one-way messages to the host<br>
application 108 where no reply message is expected. The "sendRequest" and "call"<br>
program functions are utilized by the distributed application 128 to send request<br>
messages to the host application 108 where a reply message is expected. The<br>
"sendRequest" and "call" program functions differ in their interaction with the<br>
distributed application 128. Specifically, the "sendRequest" program function is an<br>
asynchronous function whereby the distributed application 128 provides a program<br>
callback function, "handle," which is invoked by the distributed computer program<br>
interface 132 to deliver the reply message after receiving it from the host application<br>
108. The asynchronous nature of the "sendRequest" program function provides a<br>
mechanism for the distributed application 128 to send a request message, immediately<br>
continue processing other tasks, and be notified by the distributed computer program<br>
interface 132, through invocation of the distributed application 128 "handle" program<br>
function, when the reply message is received from the host application 108.<br><br>
The "call" program function is a synchronous function. When the<br>
"call" program function is invoked by the distributed application 128, the distributed<br>
application 128 simultaneously provides a request message and an uninitialized<br>
reference to a memory buffer within the distributed computer workstation 122 for a<br>
corresponding reply message. Thereafter, the distributed computer program interface<br>
132 will return to the memory buffer reference a memory address for the<br>
corresponding reply message before returning from the "call" program function to the<br>
distributed application 128. The synchronous nature of the "call" program function<br>
provides a mechanism for the distributed application 128 to send a request message<br>
and receive a reply message through one invocation of the distributed computer<br>
program interface 132 without utilizing the "handle" program callback function.<br>
The "subscribe" program function of the distributed computer program<br>
interface 132 is utilized by the distributed application 128 to enable receipt of one-<br>
way messages from host applications 108 through a "handle" program callback<br>
function provided by the distributed application 128 when invoking the "subscribe"<br>
program function. Such a message is delivered and the distributed application 128<br>
notified by the distributed computer program interface 132, through invocation of the<br>
distributed application 128 "handle" program function, when a one-way message is<br>
received from the host application 108. The distributed application 128 may invoke<br>
the "subscribe" program function multiple times to enable receipt of defined format<br>
messages, native terminal screen messages, and/or native printer messages. The<br>
"unsubscribe" program function is utilized by the distributed application 128 to<br>
disable receipt of one-way messages from host applications 108.<br>
The "startMonitor" and "stopMonitor" program functions of the<br>
distributed computer program interface 132 are utilized by the distributed application<br>
128 to enable and disable receipt of distributed computer program interface 132 status<br>
messages through a "handle" program callback function provided by the distributed<br>
application 128 when invoking the "startMonitor" program function. Such status<br>
messages are delivered by and the distributed application 128 is notified by the<br>
distributed computer program interface 132, through invocation of the distributed<br><br>
application 128 "handle" program callback function, when the status of the<br>
communication connection between the distributed computer program interface 132<br>
and the distributed message transmission application 124 changes. Such status<br>
messages inform the distributed application 128 whether the communication<br>
connection between the distributed message transmission application 124 and the<br>
distributed computer program interface 132 is operational or not and provides the<br>
distributed application 128 a mechanism for notification of the current status.<br>
The "isActive" program function is a more direct mechanism for the<br>
distributed application 128 to obtain status information regarding the communication<br>
connection between the distributed message transmission application 124 and the<br>
distributed computer program interface 132 because it provides no notification other<br>
than the simple return of a true indication if the communication connection is<br>
operational or a false indication if the communication connection is not operational.<br>
The "destroy" program function of the distributed computer program<br>
interface 132 is utilized by the distributed application 128 to end a messaging session<br>
with the TPF host computer system 102.<br>
In an exemplary embodiment of the present invention, the distributed<br>
message transmission application 124 and the distributed computer program interface<br>
132 both utilize modern programming techniques which enable better performance<br>
and greater scalability than conventional art systems. One such programming<br>
improvement utilized by both the distributed message transmission application 124<br>
and the distributed computer program interface 132 is the use of "event-driven"<br>
mechanisms available on modern computer system platforms. An example of an<br>
event-driven mechanism is an operating system notification (or "callback" function) to<br>
a computer program when a certain event has occurred, such as the expiration of a<br>
timer or the arrival of a message from a communication connection, allowing an<br>
application to remain dormant until the event occurs.<br>
Conventional art systems were originally developed for use with the<br>
IBM personal computer DOS platform, which did not provide typical event-driven<br>
mechanisms. As such, conventional art systems required a constantly-executed<br><br>
program event loop to determine if a timer had expired, if there were messages to send<br>
or receive, or if there were other tasks to be performed. Thus, conventional art<br>
systems constantly occupy distributed computer processing time that could be utilized<br>
by other computer programs when conventional art systems actually had no messaging<br>
work to perform. The MICROSOFT WINDOWS operating system and various<br>
UNIX-based operating systems utilized by exemplary embodiments of the present<br>
invention provide event-driven mechanisms such that the distributed message<br>
transmission application 124 and the distributed computer program interface 132 are<br>
notified by the operating system when there is messaging work to be performed,<br>
making the present invention more efficient than conventional art systems. Further,<br>
event loop-style logic is not utilized in either the distributed message transmission<br>
application 124 or the distributed computer program interface 132, which would<br>
unnecessarily occupy distributed computer processing time. All functional processes<br>
within both components are driven by notifications or program callback functions<br>
from the distributed computer workstation's operating system, resulting in increased<br>
computer processing capacity within the distributed computer workstation 122.<br>
Another modern programming technique utilized by exemplary<br>
embodiments of the distributed message transmission application 124 of the present<br>
invention is multiplexing of multiple distributed application messaging sessions with<br>
the TPF host computer system 102 across a single communication connection between<br>
the distributed message transmission application 124 and devices within the<br>
communication network 106. Conventional art systems were typically required to<br>
create one communication connection for each distributed computer system<br>
application/host messaging session. As a result of using multiple communication<br>
connections between the distributed computer workstations 122 and the<br>
communication network 106 devices, such communication network connection<br>
devices supported far less distributed computer workstations 122, which required the<br>
use of additional communication network connection devices within the<br>
communication network 106 resulting in increased expense for the operation of<br>
conventional art systems. In contrast, the distributed message transmission<br><br>
application 124 maintains only one communication connection to any single<br>
communication network connection device within the communication network 106<br>
for all host computer system messaging sessions associated with that single device<br>
from all distributed computer system applications 128 within a given distributed<br>
computer workstation 122.<br>
Figure 3 is a logic flow diagram of an exemplary process 150 that<br>
illustrates the interaction and functionality of the architecture and components of the<br>
present invention, hi step 152, an electronic message is generated in the distributed<br>
application 128 operating within the distributed computer system 104. In step 154, a<br>
copy of the electronic message is converted into an acceptable format for transfer to<br>
the distributed message transmission application 124 by the distributed computer<br>
program interface 132. In step 156, a copy of the electronic message is placed in a<br>
message queue 126 by the distributed message transmission application 124. In step<br>
158, the electronic message is transmitted over the communications network 106<br>
between the distributed application 128 and the host application 108 by way of the<br>
distributed message transmission application 124. In step 160, the electronic message<br>
is received by the host message transmission application 110. In step 162, an<br>
electronic receipt acknowledgment message is transmitted to the distributed message<br>
transmission application 124. In step 164, the electronic message is translated into a<br>
pre-selected host application format. In step 166, the electronic message is delivered<br>
to the host application 108.<br>
Figure 3 is a logic flow diagram illustrating an exemplary process 200<br>
for exchanging an electronic defined format request message between a distributed<br>
application 128 and a host application 108 and for guaranteeing delivery of same.<br>
Although several of the exemplary processes described herein relate to request/reply<br>
messages, those skilled in the art will appreciate that details of a request from the<br>
distributed application 128 to the host application 108 and a reply from the host<br>
application 108 to the distributed application 128 each also represent the process and<br>
message flow for one-way messaging in each direction.<br><br>
In step 202, the distributed application 128 initiates the exemplary<br>
process 200 when either a system user or the distributed application 128 initiates an<br>
action which requires information to be exchanged between the host application 108<br>
and the distributed application 128, necessitating a request/reply interaction between<br>
the distributed application 128 and the host application 108.<br>
In step 204, the distributed application 128 invokes the novel<br>
distributed computer program interface 132, utilizing the "create" program function,<br>
to initiate a messaging session with the TPF host computer system 102. The<br>
distributed application 128 specifies a text-based session name in the "create"<br>
program function, which is then utilized by the distributed computer program<br>
interface 132 to access a configuration file, located within the distributed computer<br>
workstation 122, with configuration details about the host messaging session. The<br>
configuration details of the host messaging session include information pertaining to<br>
the specific host resource such as a designation for a native TPF host computer system<br>
102 terminal messaging session, how the session maps to a communication network<br>
resource, and details on creating communication connections between the distributed<br>
computer program interface 132 and the distributed message transmission application<br>
124, and also between the communication network connection device and the<br>
distributed message transmission application 124. Alternatively, the host messaging<br>
session could be initiated during startup of the distributed application 128 or at some<br>
other appropriate time. Once initiated, the host messaging session may be maintained<br>
for the duration of the execution of the distributed application 128 or only for a series<br>
of message transfers. In addition, the availability of a host messaging session may be<br>
provided exclusively for the distributed application 128 or allocated from a pool of<br>
host sessions available for use by any distributed application 128 within the<br>
distributed computer workstation 122. In step 206, the distributed application 128<br>
prepares a request message to obtain information from the host application 108 using<br>
data input by the user or generated by the distributed application 128.<br>
As shown in Figure 4A, the amount of data comprising a defined<br>
format request or reply message can be of any size and is represented logically as a<br><br>
data file 300 with one or more records 302a-n, although most request messages in the<br>
request/reply model will only comprise one record. As shown in Figure 4B, each of<br>
the individual records 302a-n, or alternatively the complete data file 300, presented to<br>
the distributed computer program interface 132 contain relevant application data 304<br>
from the distributed application 128 along with a record sequence indicator 303, an<br>
application identifier 305, a serial number 306 to uniquely identify the request, a host<br>
block type identifier 307, and an application data length indicator 308. The<br>
distributed application data 304 is typically represented by any combination of ASCII<br>
characters and binary data fields. The application and host block type identifiers 305,<br>
307 are values previously agreed upon by both the sending and receiving applications<br>
to identify the request message content, i.e., data block size and format, and to identify<br>
the appropriate host and distributed applications 108, 128 for message routing. The<br>
record sequence indicator 303 indicates "first," "middle," "last," and/or "only" records<br>
of a request message 300. Larger messages may have more than one record with a<br>
"middle" record sequence indicator 303. The serial number 306 provides a way for<br>
the sending application to match up a reply message 300 with its corresponding<br>
request message 300. The application data length indicator 308 contains the number<br>
of characters within the application data 304. The distributed application 128 can<br>
create message records 302a-n as a stream of data characters including the identifying<br>
attributes 303, 305, 306, 307, 308 and the distributed application data 304. In the<br>
alternative, message records 302a-n can be created by using functionality provided by<br>
the distributed computer program interface 132. For this alternative embodiment, the<br>
distributed application 128 simply provides the distributed application data 304 and<br>
the identifying attributes 303, 305, 306, 307, and 308 to the distributed computer<br>
program interface 132 as separate pieces of data.<br>
Returning to Figure 3, in step 208, the distributed application 128 again<br>
invokes the distributed computer program interface 132, utilizing either the "send,"<br>
"sendRequest," or "call" program functions, in order to send the complete request<br>
message 300, or alternatively, each record 302a-n of a request message 300 to the host<br>
computer system 102 and subsequently to a host application 108. In step 210, the<br><br>
distributed computer program interface 132 receives message data from the<br>
distributed application 128. In step 212, the distributed computer program interface<br>
132 converts the message data into a format acceptable to the distributed message<br>
transmission application 124.<br>
As seen in Figure 4C, the conversion step involves adding a command<br>
character 310 to the front of the request message, which informs the distributed<br>
message transmission application 124 that this is a defined format request message,<br>
and adding a total length indicator 309 to the front of the request message to represent<br>
the total length of the transmission to the distributed message transmission application<br>
124.<br>
Returning to Figure 3, in step 213, the distributed computer program<br>
interface 132 sends the reformatted request message to the distributed message<br>
transmission application 124. In step 214, the distributed message transmission<br>
application 124 converts request messages 300 that are larger than the maximum<br>
record size into a number of records 302a-n. In step 215, the distributed message<br>
transmission application 124 segments larger records 302a-n into multiple data blocks<br>
if the individual record size exceeds the maximum transmission block size on the<br>
communication network 106. In step 216, the distributed message transmission<br>
application 124 encapsulates each data block in a native TPF host terminal data block<br>
330, as shown in Figure 7, by adding a defined format message indicator 332 at the<br>
front of each data block and an end-of-message character 336 at the end of each data<br>
block. In step 217, the distributed message transmission application 124 places the<br>
converted request message 300 into the queue 126. In step 218, the distributed<br>
message transmission application 124 begins sending a copy of the data blocks stored<br>
in the queue 126 to the host message transmission application 110. In step 219, the<br>
host message transmission application 110 removes the data blocks added in step 216<br>
from the native TPF host terminal data block format, reassembles each of the data<br>
blocks into a record 302a-n and prepares to pass them to the appropriate host system<br>
application 108.<br><br>
In step 220, the host message transmission application 110, upon<br>
receipt of a complete record 302a-n, generates and sends an acknowledgment message<br>
to the distributed message transmission application 124. In step 224, the distributed<br>
message transmission application 124 queries whether it has received an<br>
acknowledgment message from the host message transmission application 110. If so,<br>
in step 225 the distributed message transmission application 124 queries whether the<br>
"last" record 302a-n of the request message 300 has been transmitted successfully by<br>
looking for a "last" record sequence indicator 303. If a "last" record sequence<br>
indicator 303 is located, in step 226 the distributed message transmission application<br>
124 deletes the request message 300 from the queue 126. If a "last" record sequence<br>
indicator is not located, in step 228 the exemplary process 200 then repeats the tasks<br>
in steps 218, 219, 220 for each subsequent record 302a-n until all records have been<br>
transmitted. If, in step 224, no acknowledgment is received for any given record<br>
302a-n, in step 230 the process 200 again returns to step 218 and the distributed<br>
message transmission application 124 resends the unacknowledged record to the host<br>
message transmission application 110.<br>
Figure 5 is a block diagram of the request message transfer process<br>
between the distributed message transmission application 124 and the host message<br>
transmission application 110. In this instance, the distributed message transmission<br>
application 124 has already received a request message 300 from the distributed<br>
computer program interface 132 consisting of a number of records 302 a-n that have<br>
been stored in the queue 126. The distributed message transmission application 124<br>
then disassembles the "first" record 302a into a number of data blocks 316, which are<br>
transmitted over the communications network 106 to the host message transmission<br>
application 110. As noted above, a record 302a-n is segmented into smaller data<br>
blocks 316 when the record size exceeds the maximum transmission block size of the<br>
communication network 106. Once the host message transmission application 110<br>
has received and reassembled the data blocks 316 into a complete record 302a-n, and<br>
placed the record into the queue 112, the host message transmission application 110<br>
generates and sends an acknowledgment message 318 to the distributed message<br><br>
transmission application 124. If the acknowledgment message 318 is not received by<br>
the distributed message transmission application 124, the relevant record 302a-n is<br>
retransmitted to the host message transmission application 110. The process is<br>
repeated for each record 302a-n of the request message 300. Once all the records<br>
302a-n are delivered successfully, the distributed message transmission application<br>
124 deletes the request message 300 from the queue 126.<br>
Figure 6 is a block diagram illustration of the reply message transfer<br>
process between the host message transmission application 110 and the distributed<br>
message transmission application 124. In this instance, the host message transmission<br>
application 110 has already received a reply message 300 from a host application 108<br>
consisting of a number of records 302a-n mat have been stored in the queue 112. The<br>
host message transmission application 110 then disassembles the "first" record 302a<br>
into a number of data blocks 320, which are transmitted over the communications<br>
network 106 to the distributed message transmission application 124. As noted<br>
above, a record 302a-n is segmented into smaller data blocks 320 when the record<br>
size exceeds the maximum transmission block size of the communication network<br>
106. Once the distributed message transmission application 124 has received and<br>
reassembled the data blocks 320 into a complete record 302a-n, and placed the record<br>
in the queue 126, the distributed message transmission application 124 generates and<br>
sends an acknowledgment message 322 to the host message transmission application<br>
110. If the acknowledgment message 322 is not received by the host message<br>
transmission application 110, the record 302a-n is retransmitted to the distributed<br>
message transmission application 124. The process is repeated for each record 302a-n<br>
of the request message 300. Once all the records 302a-n are delivered successfully,<br>
the host transmission application 110 deletes the request message 300 from the queue<br>
112.<br>
Figure 8 is a logic flow diagram illustrating an exemplary process for<br>
exchanging an electronic defined format reply message between a host computer<br>
system 102 and a distributed computer system application 104 and for guaranteeing<br>
delivery of same. In step 401, the host message transmission application 110 receives<br><br>
data blocks 330 from the distributed message transmission application 124. In step<br>
402, the host message transmission application 110 reassembles the data blocks 330<br>
into individual records 302a-n and acknowledges each record to the distributed<br>
message transmission application 124. In step 404, the host message transmission<br>
application 110 evaluates the host application identifier 305 to determine the identity<br>
of the relevant host application 108.<br>
In step 406, the host message transmission application 110 translates<br>
the distributed application data 304 into a format usable by the relevant host<br>
application 108. This translation normally involves translation of ASCII characters to<br>
EBCDIC (Extended Binary-Coded Decimal Interchange Code, pronounced eb-sih-dik)<br>
in text fields. EBCDIC is an IBM code for representing characters as numbers.<br>
Although it is widely used on large, mainframe IBM computers, most other<br>
computers, including MICROSOFT WINDOWS-based PCs and Macintosh<br>
computers, use ASCII codes. However, those skilled in the art will appreciate that<br>
such translation could occur between any commonly utilized code, like ASCII, and<br>
any proprietary code used by OLTP systems, hi addition, this translation normally<br>
requires swapping the order of multiple character binary fields if the host computer<br>
system 102 and the distributed application 128 store binary data differently.<br>
In step 408, the translated records 302a-n are placed in the queue 112.<br>
In step 410, the host message transmission application 110 begins delivering the<br>
records 302a-n to the relevant host application 108 based upon the host message<br>
transmission application's analysis of the host application identifier 305.<br>
In step 412, after receiving the complete request message 300, the<br>
relevant host application 108 processes the request message 300. In step 414, the<br>
relevant host application 108 creates a reply message for transmission to the<br>
distributed application 128. In step 416, the relevant host application 108 invokes the<br>
host message transmission application 110 to handle transmission of the reply<br>
message 300. In step 418, the relevant host application 108 transmits the reply<br>
message to the host message transmission application 110. In step 420, the host<br>
message transmission application 110 translates the reply message 300 into the format<br><br>
required by the distributed application 128. In step 422, the host message<br>
transmission application 110 places the translated reply message 300 into the queue<br>
112. The reply message 300 will normally comprise multiple records 302a-n, each<br>
containing host application data 304, the record sequence indicator 303, the<br>
distributed application identifier 305, the serial number 306 and the application data<br>
length 308.<br>
In step 424, after queuing the records 302a-n, the host message<br>
transmission application 110 segments larger records into multiple, smaller data<br>
blocks 330 when the record size exceeds the maximum transmission block size of the<br>
communication network 106. In step 425, the host message transmission application<br>
110 encapsulates each of the data blocks in a native TPF host terminal data block, as<br>
shown in Figure 7, by adding a defined format message indicator 332 at the front of<br>
each of the data blocks and an end-of-message character 336 at the end of each of the<br>
data blocks. In step 426, the host message transmission application 110 begins<br>
sending the data blocks 330 sequentially to the distributed message transmission<br>
application 124. In step 428, the distributed message transmission application 124<br>
removes each of the data blocks added in step 425 from the native TPF host terminal<br>
data block format, reassembles the data blocks 330 into a record 302a-n, and places<br>
the record 302a-n into the queue 126. In step 430, the distributed message<br>
transmission application 124, upon receipt of a complete record 302a-n, generates and<br>
sends an acknowledgment message to the host message transmission application 110.<br>
In step 432, the host message transmission application 110 queries<br>
whether it has received an acknowledgment message from the distributed message<br>
transmission application 124. If so, in step 433 the host message transmission<br>
application 110 queries whether the "last" record 302a-n of the reply message 300 has<br>
been transmitted successfully by looking for a "last" record sequence indicator 303. If<br>
a "last" record sequence indicator is located, in step 436 the host message<br>
transmission application 110 deletes the reply message 300 from the queue 112. If a<br>
"last" record sequence indicator 303 is not located, in step 435 the exemplary process<br>
400 then repeats the tasks in steps 426, 428, and 430 for each subsequent record 302a-<br><br>
n until all records have been transmitted. If, in step 432, no acknowledgment is<br>
received for any given record 302a-n, in step 431 the process 400 again returns to step<br>
426 and the host message transmission application 110 resends the unacknowledged<br>
record to the distributed message transmission application 124.<br>
In step 436, the distributed message transmission application 124<br>
converts the reply message into a format acceptable to the distributed computer<br>
program interface 132. The conversion step involves adding a command character<br>
310 to the front of the message, which informs the distributed computer program<br>
interface 132 that this is a defined format reply message, and adding a total length<br>
indicator 309 to the front of the request message to represent the total length of the<br>
transmission to the distributed computer program interface 132. In step 438, the<br>
distributed message transmission application 124 sends each record 302a-n of the<br>
reply message 300 to the distributed computer program interface 132. In step 440, the<br>
distributed computer program interface 132 passes each of the records 302a-n of the<br>
reply message 300 to the distributed application 128. The records 302a-n are passed<br>
to the application by completion of the distributed computer program interface 132<br>
"call" program function or through the handle program callback function of the<br>
distributed application 128 utilized with the "sendRequest" or "subscribe" program<br>
functions. Once each of the records 302a-n of the reply message 300 has been<br>
delivered to the distributed application 128, the exemplary process 400 ends.<br>
Figure 9 is a logic flow diagram illustrating an exemplary process 500<br>
for exchanging an electronic request/reply message sequence in native terminal screen<br>
format between a distributed computer system application 128 and a host computer<br>
system 102 without guaranteeing delivery of same. Although several of the<br>
exemplary processes described herein relate to request/reply messages, those skilled in<br>
the art will appreciate that details of a request from the distributed application 128 to<br>
the host application 108 and a reply from the host application 108 to the distributed<br>
application 128 each also represent the process and message flow for one-way<br>
messaging in each direction.<br><br>
In step 502, the distributed application 128 initiates the exemplary<br>
process 500 when either a system user or the distributed application 128 initiates an<br>
action which requires information to be exchanged between the distributed application<br>
128 and the host application 108, necessitating a request/reply interaction between the<br>
distributed application 128 and the host application 108. In step 504, the distributed<br>
application 128 invokes the distributed computer program interface 132, utilizing the<br>
"create" program function, to initiate a messaging session with the TPF host computer<br>
system 102. The distributed application 128 specifies a text-based session name in the<br>
"create" program function, which the distributed computer program interface 132<br>
utilizes to access a configuration file, located within the distributed computer<br>
workstation 122, with configuration details about the host messaging session. The<br>
configuration details of the host messaging session include information pertaining to<br>
the specific host resource such as a designation for a native TPF host computer system<br>
102 terminal messaging session, how the session maps to a communication network<br>
resource, and details on creating communication connections between the distributed<br>
computer program interface 132 and the distributed message transmission application<br>
124, and also between a communication network connection device and the<br>
distributed message transmission application 124. Alternatively, the host messaging<br>
session could be initiated during startup of the distributed application 128 or at some<br>
other appropriate time. Once initiated, the host session may be maintained for the<br>
duration of the execution of the distributed application 128 or only for a series of<br>
message transfers. In addition, the availability of a host messaging session may be<br>
provided exclusively for the distributed application 128 or allocated from a pool of<br>
host messaging sessions available for use by any distributed application 128 within the<br>
distributed computer workstation 122.<br>
In step 508, the distributed application 128 prepares a request message<br>
640, as seen in Figure 13, to obtain information from the host application 108 using<br>
data input by the user or generated by the distributed application 128. In this<br>
exemplary process 500, the request message 640 may either be a terminal screen of<br>
data (generally up to 12 lines of characters by 65 columns of characters or 768 total<br><br>
characters) or a special type of coded request consisting of a single character. As seen<br>
in Figure 13, both types of request messages consist of a single message containing a<br>
record sequence indicator 644, terminal screen data 642, and an application data<br>
length indicator 649. Screen control characters 646, 648 are not utilized for request<br>
messages. A record sequence indicator 644 for terminal screen messages is always<br>
the "only" indicator as terminal screen request messages are limited to a single<br>
message. The record sequence indicator 644 for the coded request message is always<br>
the "middle" indicator as required by the host application 108 that processes these<br>
types of requests. The data for both request types is ASCII text characters.<br>
In step 512, the distributed application 128 again invokes the<br>
distributed computer program interface 132, utilizing either the "send," "sendRequest"<br>
or "call" program functions, in order to send the terminal screen request message 640<br>
to the distributed computer program interface 132. In step 514, the distributed<br>
computer program interface 132 converts the request message 640 into a format<br>
acceptable to the distributed message transmission application 124. The conversion<br>
step involves adding a command character 310 to the front of the request message,<br>
which informs the distributed message transmission application 124 that the request<br>
message is a native terminal request message, and adding a total length indicator 309<br>
to the front of the request message to represent the total length of the transmission to<br>
the distributed message transmission application 124. In step 515, the distributed<br>
computer program interface 132 sends the reformatted request message to the<br>
distributed message transmission application 124. In step 516, the distributed<br>
message transmission application 124 translates the request message from ASCII to<br>
EBCDIC characters, i.e., into native TPF host system format. In step 518, the<br>
distributed message transmission application 124 forms the native TPF host terminal<br>
request data block 610, as shown in Figure 11 A, by converting the record sequence<br>
indicator 644 into an end of message character 614. In step 520, the distributed<br>
message transmission application 124 sends the native terminal screen request data<br>
block 610 over the communication network 106 to the host computer system 102 for<br>
processing. In step 522, the host computer system 102 receives the data block 610<br><br>
into an input message parser 118. In step 524, the input message parser 118 evaluates<br>
the content of the data block 610 and determines the relevant host application 108 to<br>
which the data block 610 is to be sent. In step 526, the input message parser 118<br>
passes the native terminal data block 610 to the relevant host application 108.<br>
In step 528, the relevant host application 108 processes the native<br>
terminal request data block 610. In step 530, the relevant host application 108 creates<br>
a native terminal screen reply message. In step 532, the relevant host application 108<br>
sends the reply message to an output formatting application 114. In step 534, the<br>
output formatting application 114 converts the reply message into a series of terminal<br>
screens of data (generally up to 12 lines of characters by 65 columns of characters or<br>
768 total characters) as shown in Figure 10. In step 536, the output formatting<br>
application 114 places the series of terminal screens into the terminal message queue<br>
116. In step 537, the output formatting application 114 segments larger screen replies<br>
into multiple data blocks 620 if the screen size exceeds the maximum transmission<br>
block size on the communication network 106. In step 538, the output formatting<br>
application 114 begins sending the data blocks associated with the first of the series of<br>
terminal screens to the distributed message transmission application 124 across the<br>
communications network 106.<br>
In step 540, the distributed message transmission application 124<br>
receives each of the data blocks comprising the terminal screen reply message 600. In<br>
step 544, the distributed message transmission application 124 translates the EBCDIC<br>
terminal screen message data 622 to ASCII format and converts the end of message<br>
character 624 to a record sequence indicator 644. The record sequence indicator 644<br>
indicates "middle" or "last" and/or "only" data block of the distributed computer reply<br>
message 640. The "first" record sequence indicator 303 is not utilized with native<br>
terminal screen reply messages. In step 545, the distributed message transmission<br>
application 124 converts the message into a format acceptable to the distributed<br>
computer program interface 132. The conversion step involves adding a command<br>
character 310 to the front of each of the data blocks, which informs the distributed<br>
computer program interface 132 that the reply message is a native terminal screen<br><br>
reply message, and adding a total length indicator 309 to the front of the request<br>
message to represent the total length of the transmission to the distributed computer<br>
program interface 132. In step 546, the distributed message transmission application<br>
124 sends the reformatted terminal screen reply message data blocks 620 to the<br>
distributed computer program interface 132. In step 548, the distributed computer<br>
program interface 132 passes the terminal screen reply messages 640 to the distributed<br>
application 128. The reply messages are passed to the application by completion of<br>
the distributed computer program interface 132 "call" program function or through the<br>
"handle" program callback function of the distributed application 128 utilized with the<br>
"sendRequest" or "subscribe" program functions. In step 550, the distributed<br>
application 128 utilizes the record sequence indicator 644 to reconstruct the messages<br>
to form a complete terminal screen reply message 600. In step 552, the distributed<br>
application 128 either parses the data for further use by the user or the application or,<br>
if displaying the information onto a terminal screen, uses the screen control characters<br>
646, 648 to determine screen placement and behavior. In step 553, the distributed<br>
application 128 queries, upon request by the user or by decision within the distributed<br>
application 128, whether additional terminal screen messages 600 are to be requested.<br>
In step 554, the distributed application 128 generates an additional request message<br>
which is routed to the output formatting application 114 through the distributed<br>
computer program interface 132 and the distributed message transmission application<br>
124 to request the next terminal screen reply message be sent from the output<br>
formatting application 114 to the distributed application 128. The exemplary process<br>
500 then returns to step 538 and repeats the process steps until all terminal screen<br>
reply messages 600 have been transmitted to the distributed application 128.<br>
Figure 10 illustrates a terminal screen reply message 600, which may<br>
consist of a number of native TPF host terminal screen data blocks 602a-n.<br>
Figure 11A illustrates a native terminal screen request data block 610<br>
between the distributed message transmission application 124 and the host computer<br>
system 102. A terminal screen request message from a distributed application 128 is<br>
limited to the size of one native terminal screen data block 610 and consists of the<br><br>
terminal screen data 612 represented as ASCII characters and an end of message<br>
character 614 which indicates either "middle" or "last" and/or "only" message of a<br>
request.<br>
Figure 11B illustrates a native terminal screen or printer reply data<br>
block 620 between a host computer system 102 and the distributed message<br>
transmission application 124. The tenninal screen reply data blocks 620 or printer<br>
reply data blocks 620 consist of the terminal screen or printer data 622 represented as<br>
EBCDIC characters, an end of message character 624, and two screen control<br>
characters 626, 628. The end of message character 624 for the terminal screen or<br>
printer reply data blocks 620 indicates either "middle" or "last" and/or "only" message<br>
of a reply. The screen control characters 626, 628 are utilized by a terminal screen<br>
distributed application 124 to determine screen placement and behavior for the<br>
terminal screen data 622.<br>
Figure 12 is a block diagram illustration of the native terminal screen<br>
reply message transfer process between a host application 108 and a distributed<br>
application 128. A host output formatting application 630 has already received a reply<br>
message from the host application 108 and placed the reply message into the terminal<br>
message queue 632. The reply message may consist of multiple terminal screens<br>
634a-n. The host output formatting application 630 sends the first terminal screen<br>
634a to the distributed application 128 as a reply message to the terminal screen<br>
request message. Subsequent terminal screens 634b-n are sent to the distributed<br>
application 128 as reply messages to additional terminal screen request messages<br>
querying for the additional terminal screens 634b-n.<br>
Figure 13 illustrates native terminal screen or printer request and reply<br>
messages 640 that are transferred between a distributed application 128 and the<br>
distributed computer program interface 132. A reply message 640 consists of tenninal<br>
screen or printer data 642 represented as ASCII characters, a record sequence<br>
indicator 644, two screen control characters 646, 648, and a data length indicator 649.<br>
The record sequence indicator 644 indicates "middle", "last", and/or "only" request or<br>
reply message 640. The screen control characters 646, 648 are only valid for terminal<br><br>
screen reply messages 640 and are utilized by a terminal screen distributed application<br>
124 to determine screen placement and behavior for the terminal screen data 642.<br>
Figure 14 is a logic flow diagram illustrating an exemplary process 700<br>
for exchanging an electronic message in native printer format between a host<br>
computer system 102 and a distributed printer application 130. Figure 15 illustrates a<br>
printer reply message 750 which may be any number of characters and may consist of<br>
multiple native TPF host printer data blocks 702a-n. It will be apparent to those<br>
skilled in the art that, although such messages are one-way messages from the host<br>
computer system 102 to a distributed printer application 130, they can be initiated by a<br>
host application 108 or alternatively, initiated by a separate distributed application 128<br>
as a native terminal request/reply sequence that instructs the host application 108 to<br>
construct a printer message 750 from the currently queued terminal screen message<br>
and send the printer message 750 to a terminal printer 131 attached to the distributed<br>
computer workstation 122. Thus, in step 701, a distributed printer application 128<br>
invokes the distributed computer program interface 132, utilizing the "create"<br>
program function, to initiate a messaging session with the TPF host computer system<br>
102. The distributed printer application 130 specifies a text-based session name in the<br>
"create" program function, which the distributed computer program interface 132<br>
utilizes to access a configuration file, located within the distributed computer<br>
workstation 122, with configuration details about the host messaging session. The<br>
configuration details of the host messaging session include information pertaining to<br>
the specific host resource such as a designation for a native TPF host computer system<br>
102 printer messaging session, how the messaging session maps to a communication<br>
network resource, and details on creating communication connections between the<br>
distributed computer program interface 132 and the distributed message transmission<br>
application 124, and also between the communication network connection device and<br>
the distributed message transmission application 124. In step 702, the distributed<br>
printer application 130 invokes the distributed computer program interface 132,<br>
utilizing the "subscribe" program function, to begin receiving one-way native printer<br>
reply messages from the TPF host computer system 102.<br><br>
In step 703, a host application 108 generates a printer reply message<br>
750. In step 704, the printer reply message 750 is segmented into multiple native TPF<br>
host printer reply data blocks 620 if the printer reply message size exceeds the<br>
maximum transmission block size on the communication network 106. In step 706,<br>
the data blocks are stored in a host printer queue 120. In step 708, a copy of each of<br>
the data blocks 620 are sequentially transmitted to the distributed message<br>
transmission application 124 across the communications network 106. The data<br>
blocks 620 are in native TPF host printer format, i.e., EBCDIC message data<br>
characters 622, an end of message character 624 and two screen control characters<br>
626, 628. This format is the same as native terminal screen reply message data blocks<br>
as shown in Figure 1 IB.<br>
In step 710, the distributed message transmission application 124<br>
receives each of the data blocks 620 of the printer reply message 750. In step 712, the<br>
distributed message transmission application 124 translates the EBCDIC message data<br>
622 to ASCII format and converts the end of message character 624 to a record<br>
sequence indicator 644. In step 713, the distributed message transmission application<br>
124 converts the message data into a format acceptable to the distributed computer<br>
program interface 132. The conversion step involves adding a command character<br>
310 to the front of the reply message, which informs the distributed computer program<br>
interface 132 that this is a native printer reply message, and adding a total length<br>
indicator 309 to the front of the request message to represent the total length of the<br>
transmission to the distributed computer program interface 132. In step 714, the<br>
distributed message transmission application 124 sends the reformatted printer data<br>
blocks 620 to the distributed computer program interface 132. In step 716, the<br>
distributed computer program interface 132 passes the printer reply message 640 to<br>
the distributed printer application 131. In step 718, the distributed printer application<br>
131 generates and sends a one-way acknowledgment message to the host computer<br>
system 102, containing only a "middle" message record sequence indicator 644, via<br>
the distributed computer program interface 132 and the distributed message<br>
transmission application 124.<br><br>
In step 720, the host printer queue 120 queries for the receipt of the<br>
acknowledgment from the distributed printer application 130. In step 722, if an<br>
acknowledgment is received, the exemplary process 700 deletes tire printer data block<br>
620 from the printer queue 120 and then returns to step 708 until there are no<br>
remaining printer data blocks 620 in the printer queue 120. If no acknowledgment is<br>
received in step 720, the exemplary process returns to step 708 and the host printer<br>
queue 120 resends the previous printer data block 620 repeatedly for a pre-selected<br>
period of time or until an acknowledgment is received.<br>
Figure 16 is a block diagram illustration of a printer data block transfer<br>
process 755 between the host computer system 102 and the distributed message<br>
transmission application 124. In this instance, a host application 108 has already<br>
generated a printer reply message 750, which has been stored in the host printer queue<br>
760. The host printer queue 760 disassembles the printer reply message 750 into a<br>
number of data blocks 762, which are then transmitted over the communications<br>
network 106 to the distributed message transmission application 124. Once the<br>
distributed message transmission application 124 has received a data block 762, it<br>
passes it to the distributed computer program interface 132 and then to the distributed<br>
printer application 130. The distributed printer application 130 then generates and<br>
sends an acknowledgment message 764 to the host printer queue 760. The process<br>
755 is repeated for each data block 762 of the printer reply message 750.<br>
As described in connection with Figure 1, the distributed message<br>
transmission application 124 may be attached to each of the other distributed<br>
applications 128 through individual communication connections to multiple instances<br>
of the distributed computer program interface 132 built into each distributed<br>
application 128. Figure 17 is a functional block diagram depicting the architecture<br>
and components of the distributed computer program interface 132 of an exemplary<br>
embodiment of the present invention. The host application 108 communicates with<br>
the distributed computer program interface as described above in connection with<br>
Figures 1 and 16. Similarly, the distributed application 128 also can communicate<br>
with the distributed computer program interface 132. Either the host application 108<br><br>
or the distributed application 128 may create a communication connection for<br>
transmitting and processing messages by invoking the distributed computer program<br>
interface 132.<br>
An application 108, 128 may access the functionality of the distributed<br>
computer program interface 132 by transmitting a program function message to the<br>
distributed computer program interface. A program function message is recognized<br>
by the application programming interface 133. The use of an application<br>
programming interface (API) 133 is a well-known means for recognizing and<br>
processing program function messages or calls. In an exemplary embodiment of the<br>
present invention, the API 133 can be configured to recognize only a relatively small<br>
number of program function messages. This set of program function messages can be<br>
referred to as a verb list. Minimizing the verb list can optimize the efficiency of the<br>
distributed computer program interface, by minimizing the time and resources<br>
required to recognizing and process a given program function message.<br>
As described above in connection with Figure 1, the distributed<br>
message transmission application 124 may be attached to the communication network<br>
106 through communication connections to communication network connection<br>
devices in the network. These communication network connection devices are<br>
commonly referred to as transports 170-176. The transports are responsible for,<br>
among other things, concentrating messages from many distributed computer<br>
workstation 122 onto higher capacity communication connections with the host<br>
computer system 102. Each transport 170-176 can have its own unique set of<br>
functions that are particularly useful for certain types of messages and/or certain types<br>
of communications between a distributed computer system workstation 122 and a host<br>
computer system 102.<br>
A host application 108 or a distributed application 128 may require the<br>
use of a particular transport 170-176 given a certain set of conditions and may require<br>
the use of a second transport given a second set of conditions. To accommodate this,<br>
an exemplary embodiment of the present invention also includes a profile manager<br>
178 that can operate in conjunction with a profile database 180 to coordinate the<br><br>
operations of the distributed computer program interface 132 and the transport 170-<br>
176. Specifically, the profile manager can determine certain characteristics of a<br>
message and can access the profile database 180 to determine how the message should<br>
be processed for transmission and which transport to use. The profile database 180<br>
could be implemented as a multi-dimensional table from which the profile manager<br>
178 can look up the relevant data with reference to the determined characteristics of<br>
the subject message. Accordingly, the appropriate transport and other message<br>
processing information can be determined for a particular message.<br>
Advantageously, the transports 170-176 can be changed, removed, or<br>
added without requiring a corresponding change in any applications 108, 128.<br>
Similarly, if a policy decision is made as to the processing of a particular message,<br>
that policy decision can be implemented in the form of a modification of the profile<br>
database 180 rather man requiring a modification.to.one or more applications 108,<br>
128. Accordingly, the profile manager 178 and profile database 180 operate as<br>
middleware to facilitate the processing of messages by the distributed computer<br>
program interface 132 in coordination with the transports 170-176. The various forms<br>
of message processing that are performed by the distributed computer program<br>
interface 132 (in conjunction with other network components), are often referred to as<br>
services. When an application 108, 128 transmits a message, a component factory<br>
135 within the distributed computer program interface 132 is triggered to create a<br>
service component 137. The service component can identify the message contents<br>
and a service identifier. A service identifier is a text string or other data that can<br>
directly or indirectly identify the manner in which a message is to be routed to a<br>
receiving application. For example, a message may be routed to a receiving<br>
application as a request-reply format, a publish-subscribe format, or a send-and-forget<br>
format. These message formats are described below in more detail, in connection<br>
with Figures 19-25. The service identifier can be associated with a message by<br>
reference to a policy defined in the profile database 180. From the perspective of the<br>
sending application, the service identifier represents a routing address. In the case of<br>
an application that is transmitting a subscription request message, the service<br><br>
identifier can indicate the publishing service to which the sending application is<br>
subscribing.<br>
Once the service component 137 has been created, the application can<br>
transmit the message using the appropriate transport 170-176, in the manner described<br>
above. In addition to service components 137, the component factory 135 can also<br>
generate an UTIL component for providing parsing and data processing functionality.<br>
The component factory can also create a fault tolerance component which functions to<br>
enable the monitoring of active and inactive applications for the purposes of<br>
determining which if any applications 108, 128 respond to a particularly message.<br>
Those skilled hi the art would appreciate that various other components could be<br>
created by the component factory 135 to facilitate the processing and management of<br>
messages.<br>
Figure 18 is a flowchart depicting an exemplary process for processing<br>
a message received from an application. The method begins at decision block 800 and<br>
continues to step 802. At step 802, a message is received from an application. The<br>
method of Figure 18 then proceeds to step 804. At step 804, the service and action<br>
implicated by the message is identified. In the exemplary embodiment described in<br>
connection with Figure 17, the distributed computer interface can perform this step by<br>
examining a received message and extracting the information pertaining to service<br>
identification and to the desired message processing action.<br>
The method of Figure 18 proceeds from step 804 to decision block<br>
806. At decision block 806, a determination is made as to whether the receipt of the<br>
message represents the first time that the service identified in the message was<br>
requested by the application. If it is determined that the service has been requested for<br>
the first time by the application, the method branches from decision block 806 to step<br>
810. Step 810, a service component is generated that corresponds to the service<br>
identified in the message. If, on the other hand, it is determined at decision block 806<br>
that the identified service has been previously requested by the application, the<br>
message branches to step 808. At step 808, an existing (i.e., previously created)<br>
service component is invoked for processing the received message. The method of<br><br>
Figure 18 proceeds from, step 808 to step 812, Notably, step 812 also can be reached<br>
from step 810. At step 812, the profile that is implicated by the service component<br>
and/or the application is identified. In the embodiment described in connection with<br>
Figure 17, this step may be performed by the profile manager 178 in conjunction with<br>
the profile database 180. In any case, a profile associated with the characteristics of<br>
the message (e.g., relevant service component, relevant message processing action)<br>
can be used to identify and associate a profile with the received message. The method<br>
proceeds from step 812 to step 814.<br>
At step 814, the transport implicated by the profile is identified. As<br>
described above in connection Figs. 1 and 16, the transport is a network component<br>
for routing messages through a distributed computer system. Where multiple<br>
transports are used, the identification of the appropriate transport to be used for a<br>
particular message can be a significant step to proper message processing.<br>
The method of Figure 18 proceeds from step 814 to step 816. At step<br>
816, the service implicated by the associated profile is identified. As described above<br>
in connection with Figure 17, a profile associated with a received message can<br>
identify a service quality with which the message should be processed. The service<br>
quality is the level of protection to which a particular message is entitled. Among<br>
other things, the service quality can identify the transport to be used to transmit the<br>
message, whether the message is a guaranteed delivery message, and whether the<br>
message is encrypted. Those skilled in the art will appreciate that the higher the<br>
message service quality, the more costly the message transmission. Because an<br>
exemplary embodiment of the present invention enables the creation and modification<br>
of message processing policies, the costs of message transmission can be minimized<br>
by tailoring the service quality in, for example, a profile database. The method<br>
proceeds from step 816 to step 818, wherein the message is transmitted over the<br>
appropriate transport. The method then proceeds to end in the block 820 and<br>
terminates.<br>
The method of Figure 18, thus, processes a received message in<br>
accordance with a profile that is associated with that message. The appropriate profile<br><br>
may be determined by reference to one or more characteristics of the message, such as<br>
the application sending the message, the message contents, the services requested by<br>
the message, etc. The applicable profile can contain information as to what transport<br>
module can be used to transmit the message, what services apply to the message, and<br>
what service quality applies to the transmission of the message.<br>
Advantageously, an exemplary embodiment of the present invention<br>
can be used to process messages generated by a variety of applications and using any<br>
number of distinct transports. An exemplary embodiment of the present invention is<br>
adaptive in that a message can be properly processed, even when an application and/or<br>
transport is changed or removed from the distributed computer system, by reference to<br>
an updated profile database. This adaptable versatility also makes the exemplary<br>
embodiments of the present invention very useful for processing messages, regardless<br>
of the structure of the distributed computer system. Figures 18-24 and the<br>
accompanying text provide a description of how exemplary embodiments of the<br>
present invention can be implemented in conjunction with various network structures<br>
and the function calls that are commonly used in those structures.<br>
Figure 19 is a block diagram depicting an exemplary peer-to-peer<br>
distributed computer network structure 900. In a peer-to-peer network structure 900,<br>
all of the distributed computers 902-910 in the network are similarly situated and there<br>
is no host computer system. All applications reside on the peer computers 902-910.<br>
Figure 20 is a block diagram depicting an exemplary client-server<br>
distributed computer network structure 912. In a client-server network structure 912,<br>
all of the distributed computers 914-922 in the network are similarly situated, but the<br>
distributed computer systems are connected to a host computer system, referred to as a<br>
server 924. The server 924 routes and processes messages transmitted between the<br>
server and each of the clients 914-922. The server also routes and processes messages<br>
transmitted between clients 914-922. Distributed applications (not shown) reside on<br>
the client computers. Host applications 928 may reside on the server 924 or may<br>
reside within a service module 926 that is functionally connected to the server.<br>
Briefly stated, a services module is a set of code or instructions that can be invoked<br><br>
when a message addressed to the module is transmitted. Such a message can be<br>
identified (i.e., associated with the services module) by reference to a service<br>
identifier that can sent as part of the message. Typically a services module receives a<br>
message as input and returns a responsive message as output.<br>
Figure 21 is a block diagram depicting an exemplary wide area client-<br>
server distributed computer network structure 930. In a wide area client-server<br>
network structure 930, all of the distributed computers (e.g., 932-940) in the network<br>
are similarly situated, but the distributed computer systems are connected to a host<br>
computer system, referred to as a server 942. The server 942 routes and processes<br>
messages transmitted by the server to each of the clients. However, unlike the client-<br>
server network depicted in Figure 20, there are typically too many client computers in<br>
the wide area network 930 to efficiently support client-to-server message<br>
transmissions or client-to-client message transmissions. Accordingly, the server 942<br>
is typically used in the messaging context to broadcast messages over the network<br>
930. Such broadcast messages are typically either received by all client computers or<br>
by those client computers that are subscribed to a particular service. A host<br>
application 944 may reside on the server 924 or may reside within a service module<br>
946 that is functionally connected to the server.<br>
Those skilled in the art will appreciate that various messaging<br>
techniques can be used in various circumstances, depending in part on the structure of<br>
the network in which the messaging is performed. For example, it would be<br>
inefficient or impossible for the server 942 to send a message to a specific client 932-<br>
940 and request confirmation of the receipt of the message and/or request a response<br>
from the client. On the other hand, it is quite common to send a message with a<br>
request for a response in a client-server network or a peer-to-peer network. Figures<br>
21-24 depict various message processing services that can be implemented by an<br>
exemplary embodiment of the present invention in the context of various network<br>
structures described in connection with Figures 18-20.<br>
Figure 22 is a block diagram depicting an exemplary synchronous reply<br>
requested message processing service 950. The network elements 952, 954 could be<br><br>
host/distributed computers operating in a network that can support the transmission of<br>
a reply message in response to a request. Such networks may include peer-to-peer<br>
networks, client-server networks, and wide area networks. In a peer-to-peer network<br>
or a client-server network, the reply request message can be sent to an application<br>
running on a particular network element (e.g., a host/server computer system) from an<br>
application running on another network element (e.g., a distributed/client computer<br>
system). In a synchronous mode of message processing, the system sending the reply<br>
request will typically force the requesting application to wait for the reply before<br>
executing other tasks. In a wide area network, the reply request message can be sent<br>
as a broadcast message by a publishing computer and received by all distributed<br>
computers that subscribe to the message service. Those distributed computers that are<br>
configured to respond to such a reply request (e.g., subscribers to the publishing<br>
service) will send reply messages to the requesting application on the publishing<br>
computer.<br>
In the exemplary synchronous reply requested message processing<br>
service 950 depicted in Figure 22, a first network element 952 is running a requesting<br>
application 956 and a second network element 954 is running a responding application<br>
958. The network elements are connected through a distributed computer<br>
programming interface, also referred to as a Service Application Programming<br>
Interface (SAPI) 964. For the purposes of brevity, the other elements of the<br>
communication network are not depicted in Figure 22. As described above, the SAPI<br>
964 will translate the request 960 received from the requesting application 956 to a<br>
format that can be understood by the responding application 958. Likewise, the SAPI<br>
964 will translate the reply 962 received from the responding application 958 to a<br>
format that can be understood by the requesting application 956. The synchronous<br>
mode reply request message 965 depicted in Figure 22 provides an example of a<br>
typical reply request. The requesting application 956 transmitting this reply request<br>
will typically wait until a reply message 962 is received from the responding<br>
application 958 before proceeding to execute other functions.<br><br>
Figure 23 is a block diagram depicting an exemplary asynchronous<br>
reply requested message processing service 966. As described in connection with<br>
Figure 22, the network elements 952, 954 could be host/distributed computers<br>
operating in a network that can support the transmission of a reply message in<br>
response to a request. Such networks may include peer-to-peer networks, client-<br>
server networks, and wide area networks. In a peer-to-peer network or a client-server<br>
network, the reply request message can be sent to an application running on a<br>
particular network element (e.g., a host/server computer system) from an application<br>
running on another network element (e.g., a distributed/client computer system). In an<br>
asynchronous mode of message processing, the requesting application will not<br>
typically wait for the reply message before executing other tasks. On the contrary, the<br>
requesting application will typically invoke a handler application or "handle" (not<br>
shown) to manage the reply message and route it to the requesting application when it<br>
is transmitted from the responding application. In a wide area network, the reply<br>
request message can be sent as a broadcast message by a publishing computer and<br>
received by all distributed computers that subscribe to the message service. Those<br>
distributed computers that are configured to respond to such a reply request (e.g.,<br>
subscribers to the publishing service) will send reply messages to the requesting<br>
application on the publishing computer.<br>
In the exemplary asynchronous reply requested message processing<br>
service 966 depicted in Figure 23, a first network element 952 is running a requesting<br>
application 956 and a second network element 954 is running a responding application<br>
958. The network elements are connected through a distributed computer<br>
programming interface, also referred to as a Service Application Programming<br>
Interface (SAPI) 964. For the purposes of brevity, the other elements of the<br>
communication network are not depicted in Figure 23. As described above, the SAPI<br>
964 will translate the request 960 received from the requesting application 956 to a<br>
format that can be understood by the responding application 958. Likewise, the SAPI<br>
964 will translate the reply 962 received from the responding application 958 to a<br>
format that can be understood by the requesting application 956. The asynchronous<br><br>
mode reply request message 963 depicted in Figure 23 provides an example of a<br>
typical reply request. The requesting application 956 transmitting this reply request<br>
will not typically wait until a reply message 962 is received from the responding<br>
application 958 before proceeding to execute other functions. Indeed, a handler can<br>
be used to notify the requesting application 956 that a reply message has been<br>
generated by the responding application. In the reply request message 963 depicted in<br>
Figure 23, the invoked handler is identified by the "replyHandler" argument.<br>
Figure 24 is a block diagram depicting an exemplary send-and-forget<br>
message processing service. The send-and-forget message can be used in virtually any<br>
network structure. As described in connection with Figure 22, the network elements<br>
970, 974 could be host/distributed computers operating in a network that can support<br>
the transmission of messages. Such networks may include peer-to-peer networks,<br>
client-server networks, and wide area networks. In a peer-to-peer network or a client- '<br>
server network, the send-and-forget message can be sent to an application running on<br>
a particular network element (e.g., a host/server computer system) from an application<br>
running on another network element (e.g., a distributed/client computer system). As<br>
indicated by the name, the send-and-forget message does not typically involve the<br>
request for or the generation of a responsive message. The send-and-forget message is<br>
particularly useful in a wide area network, where a response from the receiving<br>
applications is impossible or not particularly effective. Those distributed computers<br>
that are configured to receive such a send-and-forget message (e.g., subscribers to the<br>
publishing service) will process the received message, while those that are not<br>
configured to receive the message will ignore the message.<br>
In the exemplary send-and-forget message processing service 968<br>
depicted in Figure 24, a first network element 970 is running a sending application<br>
972 and a second network element 974 is running a receiving application 976. The<br>
network elements 970, 976 are connected through a distributed computer<br>
programming interface, also referred to as a Service Application Programming<br>
Interface (SAPI) 964. For the purposes of brevity, the other elements of the<br>
communication network are not depicted in Figure 24. As described above, the SAPI<br><br>
964 will translate the request 978 received from the sending application 972 to a<br>
format that can be understood by the responding application 976. The send-and-forget<br>
message 980 depicted in Figure 24 is an example of this kind of message.<br>
Figure 25 is a block diagram depicting an exemplary publish-subscribe<br>
message processing service 982. The publish-subscribe message set can be used in<br>
virtually any network structure. As described in connection with Figure 22, the<br>
network elements 984, 990 could be host/distributed computers operating in a network<br>
that can support the transmission of messages. Such networks may include peer-to-<br>
peer networks, client-server networks, and wide area networks. In a peer-to-peer<br>
network or a client-server network, the subscription request message 992 can be sent<br>
to an application running on a particular network element (e.g., a host/server computer<br>
system) from an application running on another network element (e.g., a<br>
distributed/client computer system). Likewise, the published response message 994<br>
can be sent to an application running on a particular network element (e.g., a<br>
host/server computer system) from an application running on another network element<br>
(e.g., a distributed/client computer system). The publish-subscribe message set does<br>
not typically involve a targeted responsive message. That is, the publishing<br>
application does not typically identify a particular subscribing application that should<br>
receive the published response 994. On the contrary, the subscribing application 986<br>
of a message handler will usually operate to identify the published response message<br>
and recognize that the published response message corresponds to a subscription<br>
message that the subscribing application transmitted previously. The publish-<br>
subscribe message is particularly useful in a wide area network, where a response<br>
from the receiving applications is impossible or not particularly effective. Those<br>
distributed computers that are configured to receive such a published message (e.g.,<br>
subscribers to the publishing service) will process the received message, while those<br>
that are not configured to receive the message will ignore the message.<br>
In the exemplary publish-subscribe message processing service 982<br>
depicted in Figure 25, a first network element 984 is running a subscribing application<br>
986 and a second network element 988 is running a publishing application 990. The<br><br>
network elements 984, 988 are connected through a distributed computer<br>
programming interface, also referred to as a Service Application Programming<br>
Interface (SAPI) 964. For the purposes of brevity, the other elements of the<br>
communication network are not depicted in Figure 25. As described above, the SAPI<br>
964 will translate the subscription request 992 received from the subscribing<br>
application 986 to a format that can be understood by the publishing application 990.<br>
Likewise, the SAPI 964 will translate the published response message 994 received<br>
from the publishing application 990 to a format that can be understood by the<br>
subscribing application 986. The subscription request message 996 depicted in Figure<br>
25 is an example of this kind of message. The subscribing application 986<br>
transmitting this subscription request will not typically wait until a published response<br>
message 994 is received from the publishing application 990 before proceeding to<br>
execute other functions. Indeed, a handler can be used to notify the subscribing<br>
application 986 that a published response message 994 has been generated by the<br>
publishing application 990. In the subscription request message 996 depicted in<br>
Figure 25, the invoked handler is identified by the "MessageHandler" argument.<br>
It will be appreciated that the present invention fulfills the needs of the<br>
conventional art described herein and meets the above-stated objects. While there has<br>
been shown and described the preferred embodiment of the invention, it will be<br>
evident to those skilled in the art that various modifications and changes may be made<br>
thereto without departing from the spirit and scope of the invention as set forth in the<br>
appended claims and equivalents thereof.<br><br>
We Claim :<br>
1.	A message processing system for transmitting and receiving messages<br>
between a host computer system application and a distributed computer system<br>
application, the message processing system comprising :<br>
a distributed message transmission application associated with the<br>
distributed computer system application being adapted to be operative to<br>
process a message generated by the distributed computer system application,<br>
and to transmit the message to the host computer system application over the<br>
communication network;<br>
a host message transmission application associated with the host<br>
computer system application and being adapted to be operative to process a<br>
message received from the distributed message transmission application ;<br>
a distributed computer program interface functionally connected to the<br>
distributed computer system application and to the distributed message<br>
transmission application and being adapted to be operative to configure the<br>
message for transmission over a communication network ; and<br>
wherein the host computer system application runs on a first computer<br>
and the distributed computer system application runs on a distributed computer<br>
system.<br>
2.	The message processing system as claimed in claim 1, wherein the<br>
configuration of the message for transmission over the communication network<br>
comprises associating a transmission profile with the message.<br>
3.	The message processing system as claimed in claim 2, comprising a<br>
distributed computer program interface that is being adapted to be operative to<br>
associate the message with a transmission profile stored in a profile database.<br><br>
4.	The message processing system as claimed in claim 3, wherein the<br>
distributed computer program interface comprises a profile manager being<br>
adapted to be operative to examine at least one characteristic of the message to<br>
determine the transmission profile to be associated with the message.<br>
5.	The message processing system as claimed in claim 4, wherein the<br>
message characteristic is an application identifier.<br>
6.	The message processing system as claimed in claim 4, wherein the<br>
message characteristic is a serial number.<br>
7.	The message processing system as claimed in claim 4, wherein the<br>
message characteristic is a record sequence indicator.<br>
8.	The message processing system as claimed in claim 4, wherein the<br>
message characteristic is an application data.<br>
9.	The message processing system as claimed in claim 4, wherein the<br>
message characteristic is a command character.<br>
10.	The message processing system as claimed in claim 4, wherein the<br>
communication network is a peer-to-peer network.<br>
11.	The message processing system as claimed in claim 4, wherein the<br>
communication network is a client-server network.<br>
12.	The message processing system as claimed in claim 4, wherein the<br>
communication network is a wide area client-server network.<br><br>
13.	The message processing system as claimed in claim 4, wherein the<br>
message is a request reply message.<br>
14.	The message processing system as claimed in claim 4, wherein the<br>
message is a send-and-forget message.<br>
15.	The message processing system as claimed in claim 4, wherein the<br>
message is a broadcast message.<br>
16.	The message processing system as claimed in claim 15, wherein the<br>
broadcast message is generated by a publishing service application and wherein<br>
the broadcast message is received by a subscribing network element.<br>
17.	A method for processing a message between a first application running on<br>
a first network element and a second application running on a second network<br>
element of a communication network, the method comprising the steps of:<br>
generating the message in the first network element;<br>
configuring the message for transmission over the communication<br>
network;<br>
transmitting the message over the communication network; and<br>
delivering the message to the second network element ;<br>
wherein the step of configuring the message for transmission comprises<br>
translating the message into a format associated with the second application,<br>
and wherein the first network element comprises a first computer and the second<br>
network element comprises a second computer.<br>
18.	The method as claimed in claim 17, wherein the step of configuring the<br><br>
message for transmission over the communication network comprises<br>
associating a transmission profile with the message.<br>
19.	The method as claimed in claim 18, wherein the step of configuring the<br>
message for transmission over the communication network comprises accessing<br>
a profile database to associate the transmission profile with the message.<br>
20.	The method as claimed in claim 19, wherein the step of configuring the<br>
message for transmission over the communication network comprises<br>
associating the transmission profile with the message, based on at least one<br>
message characteristic.<br>
21.	The method as claimed in claim 20, wherein the message characteristic<br>
is an application identifier.<br>
22.	The method as claimed in claim 20, wherein the message characteristic<br>
is a serial number.<br>
23.	The method as claimed in claim 20, wherein the message characteristic<br>
is a record sequence indicator.<br>
24.	The method as claimed in claim 20, wherein the message characteristic<br>
is an application data.<br>
25.	The method as claimed in claim 20, wherein the message characteristic<br>
is a command character.<br><br>
26.	The method as claimed in claim 18, wherein the transmission profile<br>
comprises a transport identifier being adapted to be operative to associate the<br>
message with a transport to be used to transmit the message over the<br>
communication network.<br>
27.	The method as claimed in claim 18, wherein the transmission profile<br>
comprises a service identifier being adapted to be operative to associate the<br>
message with a message format to be used to transmit the message over the<br>
communication network.<br><br>
Exchanging electronic messages between an online transaction processing host computer system (102) and<br>
a distributed computer system (122) over a communication network (106). This communication exchange<br>
encompasses both guaranteed delivery of electronic messages and non-guaranteed delivery of native<br>
terminal screen and printer messages, utilizing a message queuing facility. A two-tier architecture is used<br>
for all message translations, blocking and reassembling, queuing, acknowledgments and retransmissions,<br>
generally reducing necessary message processing and reducing use of system resources.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTMzLWtvbG5wLTIwMDMtZ3JhbnRlZC1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">933-kolnp-2003-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTMzLWtvbG5wLTIwMDMtZ3JhbnRlZC1hc3NpZ25tZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">933-kolnp-2003-granted-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTMzLWtvbG5wLTIwMDMtZ3JhbnRlZC1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">933-kolnp-2003-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTMzLWtvbG5wLTIwMDMtZ3JhbnRlZC1jb3JyZXNwb25kZW5jZS5wZGY=" target="_blank" style="word-wrap:break-word;">933-kolnp-2003-granted-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTMzLWtvbG5wLTIwMDMtZ3JhbnRlZC1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">933-kolnp-2003-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTMzLWtvbG5wLTIwMDMtZ3JhbnRlZC1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">933-kolnp-2003-granted-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTMzLWtvbG5wLTIwMDMtZ3JhbnRlZC1leGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">933-kolnp-2003-granted-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTMzLWtvbG5wLTIwMDMtZ3JhbnRlZC1mb3JtIDEucGRm" target="_blank" style="word-wrap:break-word;">933-kolnp-2003-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTMzLWtvbG5wLTIwMDMtZ3JhbnRlZC1mb3JtIDE4LnBkZg==" target="_blank" style="word-wrap:break-word;">933-kolnp-2003-granted-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTMzLWtvbG5wLTIwMDMtZ3JhbnRlZC1mb3JtIDMucGRm" target="_blank" style="word-wrap:break-word;">933-kolnp-2003-granted-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTMzLWtvbG5wLTIwMDMtZ3JhbnRlZC1mb3JtIDUucGRm" target="_blank" style="word-wrap:break-word;">933-kolnp-2003-granted-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTMzLWtvbG5wLTIwMDMtZ3JhbnRlZC1yZXBseSB0byBleGFtaW5hdGlvbiByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">933-kolnp-2003-granted-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=OTMzLWtvbG5wLTIwMDMtZ3JhbnRlZC1zcGVjaWZpY2F0aW9uLnBkZg==" target="_blank" style="word-wrap:break-word;">933-kolnp-2003-granted-specification.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="227656-bristle-method-and-device-for-producting-bristles-and-brushes.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="227658-a-telecommunications-system.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>227657</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>933/KOLNP/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>03/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>16-Jan-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>14-Jan-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>21-Jul-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>DELTA AIR LINES, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>1030 DELTA BOULEVARD, ATLANTA, GA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>MAYNARD TONY</td>
											<td>3590 STILL ROAD, CUMMING, GA 30041</td>
										</tr>
										<tr>
											<td>2</td>
											<td>GROSSKURTH DAVID</td>
											<td>4563 DANNA DRIVE AUSTELL, GA 30106</td>
										</tr>
										<tr>
											<td>3</td>
											<td>TSANG PAULUS</td>
											<td>132 MELLINGTON LANE, PEACHTREE CITY GA 30269</td>
										</tr>
										<tr>
											<td>4</td>
											<td>WHITNEY MARK</td>
											<td>1030 DELTA BOULEVARD, ATLANTA, GA 30320</td>
										</tr>
										<tr>
											<td>5</td>
											<td>LAWHORN RICK</td>
											<td>1030 DELTA BOULEVARD, ATLANTA, GA 30320</td>
										</tr>
										<tr>
											<td>6</td>
											<td>GOSLINE SCOTT</td>
											<td>1030 DELTA BOULEVARD, ATLANTA, GA 30320</td>
										</tr>
										<tr>
											<td>7</td>
											<td>AMIN DICK</td>
											<td>1030 DELTA BOULEVARD, ATLANTA, GA 30320</td>
										</tr>
										<tr>
											<td>8</td>
											<td>PINA GUS</td>
											<td>1030 DELTA BOULEVARD, ATLANTA, GA 30320</td>
										</tr>
										<tr>
											<td>9</td>
											<td>VIRMANI RAJIV</td>
											<td>1030 DELTA BOULEVARD, ATLANTA, GA 30320</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 15/16</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2002/00180</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-01-02</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/259,477</td>
									<td>2001-01-02</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/227657-a-message-processing-system-for-transmitting-and-receiving-messages-between-a-host-computer-system-and-a-distributed-computer-system-and-a-method-for-processing-a-message-therefor by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 07:45:03 GMT -->
</html>
