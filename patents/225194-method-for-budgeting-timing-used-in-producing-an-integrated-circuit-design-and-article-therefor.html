<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/225194-method-for-budgeting-timing-used-in-producing-an-integrated-circuit-design-and-article-therefor by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 22:41:26 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 225194:METHOD FOR BUDGETING TIMING USED IN PRODUCING AN INTEGRATED CIRCUIT DESIGN AND ARTICLE THEREFOR</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD FOR BUDGETING TIMING USED IN PRODUCING AN INTEGRATED CIRCUIT DESIGN AND ARTICLE THEREFOR</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The present invention discloses a method for budgeting timing in a hierarchically decomposed integrated circuit design, which includes:1) optimizing (310) at least one path through block pins, the optimization resulting in assigned gains for all the cells along said at least one path; 2) performing timing analysis (330) on the at least one path, the timing analysis using the assigned gains in order to generate arrival times for signals at said block pins; and 3) deriving a timing budget (340) by examining said estimated arrival times at said block pins.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>METHOD FOR BUDGETING TIMING USED IN PRODUCING AN INTEGRATED<br>
CIRCUIT DESIGN AND ARTICLE THEREFOR<br>
BACKGROUND<br>
In Electronic Computer Aided Design (ECAD) software systems, an integrated circuit design<br>
specification and implementation data must be stored as a set of database records, and these records have<br>
some finite maximum size based on the virtual memory capacity of the computer on which the software is<br>
running. In addition, the execution time of the ECAD software normally increases with the size cf the<br>
design. The data to represent a very large integrated circuit design may be too large to fit in a computer's<br>
memory, or the execution time required to design or simulate the entire design may be prohibitive. This<br>
is particularly true where the number of components (i.e. gates) and attendant connections within an<br>
integrated circuit are in the 10s or 100s of millions or more.<br>
Hierarchical decomposition or "partitioning" is a technique which may be used to reduce the<br>
complexity of a large integrated circuit design specification so that the memory and/or execution time<br>
required to complete the design remains manageable. Instead of representing the design as a single flat<br>
database, the design is partitioned into pieces, often called "blocks", which can be designed and verified<br>
independently. With a given single level of hierarchy, the design specification consists of a set of blocks<br>
and the top-level interconnections between those blocks. With multiple levels of hierarchy the blocks<br>
may themselves consist of smaller sub-blocks and their interconnections.<br>
Hierarchical decomposition may also be used simply as an organizational tool by a design team<br>
as a method for partitioning a design project among several designers. However, this logical hierarchy<br>
created by the design team in the design specification does not need to be the same as the physical<br>
hierarchy used to partition the design for implementation. Often the logical hierarchy is much deeper<br>
than the physical hierarchy. A process of block flattening may be used to transform the logical hierarchy<br>
into an appropriate physical hierarchy.<br>
A conventional hierarchical design project typically proceeds in two major steps: a top-down<br>
block planning step followed by a bottom-up verification step. If the blocks themselves are implemented<br>
during the top-down phase (i.e. each block is implemented before its children) the flow is referred to as a<br>
top-down flow. Conversely, if the blocks are implemented during the bottom-up phase (i.e. each block is<br>
implemented after all of its children have been completed) the flow is referred to as a bottom-up flow.<br>
The top-down and bottom-up flows each have their advantages and disadvantages. Without loss of<br>
generality, a top-down flow is used as an example in the remainder of this document. A bottom-up flow<br>
could be implemented using identical techniques.<br>
Figure 1 shows a typical top-down block planning and implementation flow. It begins with a<br>
partitioning of the design netlist to map the logical hierarchy into the physical hierarchy, defining the top-<br>
level block and the set of sub-blocks to be implemented (step 110). Each sub-block is then assigned a<br>
width and height value and a placement in the floorplan (step 115). Locations are then assigned to the<br>
pins on each sub-block, which represent the locations where nets cross the sub-block boundaries (step<br>
120). This is followed by a time budgeting step indicating which portion of the clock cycle is allocated to<br>
the timing paths that cross the sub-block boundaries (step 135).<br>
At this point in a top-down flow, after the top-level block has been planned, the process is<br>
prepared to implement the block. All leaf-cells (standard cells and macros) owned by the block are<br>
assigned a placement, and all nets owned by the block are routed (step 140). If any of the nets were<br>
routed over the sub-blocks (so-called "feedthrough nets") these wires are pushed down into the sub-<br>
blocks that they overlap, and new pins are created on the sub-block where the wires cross the sub-block<br>
boundaries (step 145). Then, recursively implement the sub-blocks according to the same process (step<br>
150). This involves recursively performing steps 110 to 170 while treating each sub-block as the top-<br>
level block.<br>
For the above process to complete successfully the shapes, pin locations, and timing budgets<br>
assigned to each block (steps 115 through 135) must represent achievable constraints. Otherwise the<br>
system may not be able to complete the implementation of some blocks according to their specifications.<br>
In such a case the specifications may need to be refined and the top-down process may need to be<br>
repeated before a correct implementation can be realized. Such an iterative refinement is time-consuming<br>
and should be avoided. Thus, methods for achieving high-quality results in these steps are of critical<br>
importance.<br>
When the recursive top-down planning and implementation step is complete the bottom-up<br>
verification process can commence. Proceeding from the lowest-level blocks toward the top-level, each<br>
block is independently analyzed for logical correctness, as well as its timing and electrical performance,<br>
and compared against its specification (step 155). After all sub-blocks of a block have been<br>
independently verified the block itself can be analyzed (step 170), under the assumption that the sub-<br>
blocks are correct.<br>
To work on an individual module, a designer or software tool requires a representation of the<br>
environment in which that module must operate. This includes the physical shape of the space in which<br>
the module is placed, the location of its input and output pins, power and other important signal routing<br>
information, the operating conditions (temperature and voltage), the expected details of the process used<br>
to fabricate the module, and the timing characteristics of the interface between the module and its<br>
environment. The focus of this method is to provide a representation of the timing characteristics. The<br>
problem is complicated by the fact that this representation must be generated before other modules or the<br>
top-level netlist has been completed. The result is that the timing characteristics used for design must be<br>
an approximation of the timing characteristics of the final product.<br>
This set of timing characteristics is called the "timing budget" of a module. Good timing budgets<br>
must have the following characteristics—Completeness, Balance, and Achievability.<br>
Completeness describes the characteristics of a budget at the block boundary. A complete timing<br>
budget describes the entire relevant context of a module. It should include signal arrival time constraints<br>
for all input pins (including bidirectional pins) and signal required time constraints for all output pins<br>
(also including bidirectional pins). It should include descriptions of all clocks that are applied as inputs of<br>
the design, generated within the design, or used as a reference for the timing constraints applied at the<br>
module outputs. It should also include any other special constraints that must be satisfied inside the<br>
module, such as global limits on signal transition times (i.e. slew limits). When the timing budget for a<br>
module is incomplete, the module cannot be fully designed without its context and the final design is<br>
likely to contain errors associated with violated constraints that were omitted from the budget. This is the<br>
minimal requirement for a timing budget.<br>
Next, for successful integration of the top-level design, a set of timing budgets must be balanced.<br>
Balance describes the relationship between a budget, the top-level timing, and other budgets in the design.<br>
Balanced tuning budgets guarantee that if all modules' timing constraints are satisfied, the top-level<br>
timing constraints will also be satisfied. When timing budgets are unbalanced, designers are forced to<br>
rework the final design to resolve problems that appear during integration of the top level. This rework<br>
often occurs very late in the design process and may require drastic and painful changes. Failure to<br>
generate balanced timing budgets may be seen as a lack of design discipline that has delayed timing<br>
closure in design methodologies.<br>
The requirements of completeness and balance make achievability the most challenging aspect of<br>
the time budgeting problem. Achievability relates to the relationship between a tuning budget and the<br>
block to which it applies. The difficulty is to create budgets that are achievable while maintaining<br>
balance and completeness. To achieve rapid design closure, it is crucial for the designer or design tool to<br>
have the ability to meet the timing constraints that are specified for each module. When the timing<br>
budget for a module is unachievable, designers are forced into a difficult cycle of iterative implementation<br>
and renegotiation of budgets. Each iteration attempts to resolve the conflicts between the timing<br>
requirements of the top-level netlist and other modules in a design and the difficulties found in<br>
implementing the module being designed. The inability to measure achievability is the biggest problem<br>
faced by design teams today and is the largest contributor to the failure to achieve timing closure that is<br>
experienced in contemporary design methodologies.<br>
There is a need to provide a timing budgeting solution that better conforms to the completeness,<br>
balance, and achievability necessary but that does so in a resource-utilization friendly manner.<br>
SUMMARY<br>
What is disclosed is a method for budgeting timing used in producing an integrated circuit design.<br>
The circuit design has register cells and combinational logic cells, and has a representation that is<br>
hierarchically decomposed into a top-level and a plurality of blocks. At least some of the plurality of<br>
blocks are capable of being further hierarchically decomposed. The register cells and combinational logic<br>
cells have at least one cell pin. The blocks have boundaries, and these block boundaries represented by at<br>
least one block pin. The method includes:<br>
1) optimizing at least one path, that path through a block pin, the optimization resulting in<br>
assigned gains for all the cells along that path;<br>
2) performing timing analysis on that path, the timing analysis using the assigned gains in order<br>
to generate arrival times for signals at the block pins; and<br>
3) deriving a timing budget by examining the estimated arrival times at the block pins. The<br>
timing analysis is performed, in some embodiments, following a zero-slack trimming algorithm which<br>
adjusts gains of cells until the slacks converge about a certain tolerance of zero.<br>
ACCOMPANYING<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
These and other objects, features and advantages of the present invention are better understood by<br>
reading the following detailed description, taken in conjunction with the accompanying drawings, in<br>
which:<br>
Figure 1 illustrates an exemplary hierarchical design process;<br>
Figure 2 illustrates the role of time budgeting in a hierarchical design flow using abstractions.<br>
Figure 3 illustrates a time budgeting approach which can be used in a hierarchical system which<br>
generates an abstraction of design modules;<br>
Figure 4 represents a time budgeting process1 according to at least one or more embodiments of<br>
the invention;<br>
Figure 5 illustrates a zero-slack "trimming" algorithm according to one or more embodiments of<br>
the invention; and<br>
Figure 6 illustrates an exemplary circuit for which a time budgeting solution can be evaluated<br>
using one or more embodiments of the invention; and<br>
Figure 7 illustrates a computer system capable of implementing one or more embodiments of the<br>
invention.<br>
DETAILED DESCRIPTION<br>
One way of implementing the top-down hierarchical design process is the hierarchical design<br>
flow shown and described in Figure 2. The design flow shown in Figure 2 is a refinement of the top-<br>
down flow shown in Figure 1, with three additional steps, 230,260, and 265. The refinement concerns a<br>
method for modeling a sub-block, in the context of its parent and sibling blocks, during the top-down<br>
budgeting and block implementation steps, as well as the bottom-up verification steps. These steps<br>
represent places in the flow at which the clean hierarchical boundaries are violated and there is a need for<br>
cross-boundary analysis. Without an effective technique for managing this cross-boundary analysis the<br>
primary advantage of the hierarchical design process-its ability to reduce the memory and runtime<br>
required to design a large integrated circuit—may be lost.<br>
During the top-down budgeting step one objective is to analyze the combinational logic paths<br>
(combinational logic gates between registers (latches and/or flip-flops)) that cross one or more<br>
hierarchical boundaries, and determine what fraction of the clock cycle should be budgeted for each<br>
segment of the path.<br>
During the top-down block implementation step, a block is placed and routed before its sub-<br>
blocks have been implemented. In most cases the placement and routing is fairly decoupled across<br>
hierarchical boundaries. However, many modem manufacturing processes require the routing wires to<br>
obey a set of rules called "antenna rules" that require detailed knowledge of the routing wires present on<br>
both sides of a hierarchical boundary.<br>
During the bottom-up verification process there is also a need to analyze the combinational logic<br>
paths that cross the hierarchical boundaries. When analyzing a block that contains sub-blocks, it would<br>
be desirable to take advantage of the fact that the sub-blocks have been pre-verified, avoiding the need to<br>
re-analyze the sub-blocks while analyzing their parents.<br>
To address this, some embodiments of the invention disclose, the use of a reduced model, referred<br>
to as a block "abstraction", that captures the structure and behavior of the block in sufficient detail that<br>
the interface with its parent block and its sibling blocks may be correctly analyzed. The goal of the<br>
abstraction is to reduce the amount of memory required to represent a block to its ancestors in the<br>
hierarchy, and reduce the amount of execution time required to analyze each instance of the block in the<br>
context of its parents and sibling blocks.<br>
As mentioned above, in this regard, the hierarchical design flow of Figure 1 is supplemented and<br>
enhanced by additional steps 230,260, and 265. In step 230, prior to the time budgeting step, abstractions<br>
of each sub-block are created for use during budgeting. Because the sub-block has not yet been<br>
implemented it contains no physical implementation data, only its netlist description. Therefore the<br>
abstraction used during budgeting is intended to model the logical behavior of the sub-block only, details<br>
of the physical and electrical behavior are not yet available. This initial abstraction is used during<br>
budgeting and then discarded.<br>
One key difference between a top-down block implementation flow and a bottom-up block<br>
implementation flow is that, in the former, a block is implemented before its children, while in the latter a<br>
block is implemented after its children. The hierarchical implementation flow in Figure 2 would be<br>
modified to place blocks 240 and 245 between blocks 265 and 270.. The main impact is that, in a top-<br>
down flow, the top-level block is being implemented before the implementation of its children is<br>
complete. Therefore the invention makes use of the sub-block budgets as idealized optimization target<br>
while implementing their parent. In a bottom-up flow, on the other hand, a block must be implemented<br>
before its parent's or sibling block's implementations are known. It must therefore also make use of its<br>
timing budget as an idealized optimization target.<br>
This design process is further detailed in a co-pending patent application entitled "Representing<br>
the Design of a Sub-module in a Hierarchical Integrated Circuit Design and Analysis System," filed on<br>
June 10,2002 (Attorney's reference number 054355-0293259). One critical step in the overall design<br>
process is time budgeting (as outlined in step 235).<br>
Figure 3 illustrates a time budgeting approach which can be used in a hierarchical system which<br>
generates either blocks or an abstraction of blocks mentioned above. The time budgeting approach<br>
discussed herein can be used where blocks, while capable of being hierarchically decomposed, have not<br>
been abstracted. By way of definition, "cells" refer herein to either "register" cells such as latches and<br>
flip-flops or to "combinational logic" cells such as AND gates, OR gates and other non-memory circuit<br>
components. Each of the cells have input "pins" and output "pins".. Pins in this context refers to a way of<br>
representing interconnects such as actual pins and/or wires. A "top-level" refers to that part of integrated<br>
circuit design contained by no blocks other than itself. The top-level and blocks both have cells contained<br>
within them. Further, each block, as described above, has a "boundary" which may be logical or physical<br>
or both.<br>
Time budgeting, in one embodiment of the invention, First, according to step 310, optimize paths<br>
between register cells of the top-level and register cells of the blocks and/or abstractions of the blocks.<br>
Next, according to step 312, optionally partition the blocks into clusters. Also, optionally, whether or not<br>
step 312 is performed, according to step 314, perform a placement of the clusters (if any) or the cells in<br>
the design. Next, in step 316, optionally perform a routing between the placed cells. This routing is often<br>
referred to as global routing. Then, according to block 320, optionally buffer long nets between blocks.<br>
Next, a timing analysis of the top-level and then the blocks (and/or abstractions) is performed (block 330)<br>
resulting in arrival times. One key aspect of the invention is that the timing analysis is based upon gains<br>
of cells. Finally, time budgets can be derived (block 340) by allocating delays (using gains) to achieve<br>
zero slack and examining the arrival times at pins on the block boundaries.<br>
The time budgeting method above can be implemented by the integration of several components<br>
into a common platform. These include:<br>
(1) A timing analysis engine. The timing engine supports incremental timing analysis of<br>
hierarchical design descriptions and incorporates a variety of delay models.<br>
(2) An engine and method for the characterization of cell delays as a function of gain.<br>
Families of cells with equivalent logic function are grouped together and characterized to express the<br>
delays of their cells as a function of their gain, which is a quantity defined to be proportional to the ratio<br>
of the capacitance a cell drives to its input capacitance. Gains are normalized so that a delay of 1.0<br>
corresponds to the loading that is considered optimal. Under this characterization, the delays of cells are<br>
independent of their load. This indicates that specific cell size or wire capacitance information is not<br>
required to perform timing analysis. This allows deferring sizing decisions to later in the design process<br>
and also gives an important metric that can be used to measure the achievability of a design.<br>
(3) A gain-based zero slack process referred to as "trimming". The trimming algorithm<br>
draws from the Theory of Logical Effort, which states that the optimal performance of a path is obtained<br>
when the gains of the cells along that path are equal. To obtain a zero-slack solution, the trimming<br>
algorithm smoothly increases and decreases gain in response to local slack information provided by the<br>
timing analysis engine.<br>
(4) An optional clustering process. Cells are optionally grouped and placed in clusters to<br>
speed global placement.<br>
(5) An optional coarse cell placer. This placer incorporates information from each of the<br>
previously described components to allow approximate cell sizes to be used to generate a placement with<br>
minimal overlap. As soon as an initial placement is available, the timing analysis engine begins including<br>
the effects of this placement by using models of wire capacitance, resistance, and delay that are based on<br>
the Manhattan distances between pins.<br>
(6) An optional coarse routing tool. It too integrates guidance from each of the previous<br>
components to assign locations to wires in the top-level design. If included, it allows inclusion of wire<br>
models based on global routing topologies into the analyses performed by the timing engine.<br>
For inputs, the time budgeting process of Figure 3 would need the following:<br>
(1) An initial netlist. This netlist should be partitioned hierarchically in correspondence with the<br>
desired hierarchical design structure. Each block in the hierarchy must be represented, preferably by a<br>
netlist or alternatively in the form of a precharacterized block such as one would find in a description of a<br>
standard cell library. Both representations are only estimates of the blocks' final characteristics.<br>
Although typical hierarchical designs are implemented with two levels of hierarchy, it is important to note<br>
that the method can be applied to designs with an arbitrary number of levels.<br>
(2) A description of a cell library. This should include description of the logic function<br>
performed by each cell so that cells can be grouped into classes of cells that have equivalent inputs,<br>
outputs, and functions. The cell library description should also contain information that allows<br>
calculation of the delay of each cell as a function of the load capacitance it drives and other optional<br>
parameters such as the signal transition time at a cell's inputs.<br>
(3) A description of the process technology such as VLSI design technology. Primarily this<br>
should contain enough information to allow wire capacitance and resistance to be computed as a function<br>
of wire length and routing layer.<br>
(4) The timing constraints for the top-level netlist. These include definitions of any clocks that<br>
are used in the design, top-level input and output signal timing constraints, exceptions to any of the<br>
normal rules of timing analysis, and limits or other restrictions on quantities computed by timing analysis,<br>
such as signal transition times.<br>
Figure 4 represents a time budgeting process according to at least one or more embodiments of<br>
the invention. First, according to step 410, all inputs are read in. This includes reading in the library<br>
description, the hierarchical netlist, and the top-level timing constraints. Libraries may be represented in<br>
a text format that presents the available cells in a library, the function of each cell, and information that<br>
can be used to compute the delay and output signal transition times of each cell. Netlists may be<br>
represented in a hardware description language (e.g. Verilog). Next, if a reduced description of a blocks<br>
netlist is desired (checked at step 415), blocks may be reduced (step 420) by removing components of the<br>
respective netlists that have no influence on boundary timing. Such a step would reduce the amount of<br>
resources needed to process the design.<br>
In accordance with one aspect of the invention, the next step is to process the library to create<br>
"supercells" (block 425). A "supercell" refers to a family of gates with common pins and function. This<br>
family would ideally include a wide range of device sizes with different input capacitances and output<br>
drive strengths. The delay of a supercell is characterized as a function of its gain and if available, the<br>
input transition time of the supercell. For ease of analysis, delays are characterized as a function of a<br>
scaled gain that allows considering a gain of 1.0 as a "good" gain. This unit gain is loosely related to the<br>
gain of an inverter driving a "typical" fan-out of approximately 4. Delay varies roughly linearly with gain<br>
and increases as gain is increased and falls as gain is reduced.<br>
If any one or more of clustering, placement or routing are desired/required (checked at step 430),<br>
then these optional routines are performed (step 435). Clustering reduces the number of objects being<br>
placed, which can improve the performance of the global placement step. Placement gives initial locations<br>
for all cells. If a cell was placed as part of a clusters, its location is taken from the cluster location. This<br>
global placement should be done "virtually flat", ignoring hierarchy boundaries. Global routing increases<br>
the accuracy of the wire models.<br>
Next, gains are adjusted until top-level timing constraints are satisfied (step 440). Gains can be<br>
adjusted using an enhanced zero-slack trimming algorithm which is discussed below with respect to<br>
Figure 5. Also, in accordance with some embodiments of the invention, these gains can be checked to<br>
measure achievability (step 445). In implementing an embodiment of the invention, as one condition, no<br>
gain can be less than 0.2, although in many situations, tighter bounds may be more appropriate. In<br>
general, achievability is measured as a function of the gain profile of the cells in a design and observe<br>
design experiments that indicate that as the percentage of cells with gains less than 1.0 increases above<br>
2.5%, it becomes increasingly difficult to achieve design convergence and note that when all cells have<br>
gains greater than 1.0, design success is virtually guaranteed.<br>
Zero-slack based analysis<br>
The most preferred timing analysis results for generating a budget are those in which all slacks in<br>
a design are zero. Slack measures how closely a timing constraint is satisfied. Positive slack indicates<br>
that a constraint is satisfied with a safety margin equal to the slack value. Circuits with positive slack are<br>
usually considered to be overdesigned, since the slack indicates that the circuit could either be operated at<br>
a higher speed or redesigned to operate at the same speed using less area or power. Negative slack<br>
indicates that a constraint is unsatisfied and cannot be satisfied unless delays in the circuit are modified by<br>
the amount of the slack. Ideally, zero slack indicates that constraints are exactly satisfied with no margin<br>
for error and no unnecessarily wasted resources. However, it is rare to find a circuit for which all timing<br>
constraints have slack of exactly zero. Even when the most critical paths in a design have zero slack,<br>
most of the remaining paths have slacks that are positive by a large margin.<br>
The invention in various embodiments utilizes a novel zero-slack algorithm to apportion slack<br>
along a path. Zero-slack algorithms typically work by increasing or reducing delay budgets for individual<br>
gates and wires until the slack of the circuit based on the budgeted delays is zero. While many different<br>
conventional zero-slack algorithms are in vogue, they are often ad hoc heuristic algorithms that rely on<br>
trial-and-error by the algorithm designer to obtain the best method to modify gate delays. Details of a<br>
novel zero-slack algorithm are presented with reference to Figure 5 and described below.<br>
Figure 5 illustrates a zero-slack "trimming" algorithm according to one or more<br>
embodiments of the invention. First, all gains are set to nominal value (block 510). Next, use static<br>
timing analysis to obtain slacks on each cell (block 520). The methodology checks to see whether any of<br>
the obtained slacks are non-zero (block 525) (non-zero in this context means greater than a certain<br>
tolerance limit about zero). If so, the gains of cells with the non-zero slacks are adjusted (block 530)<br>
(within feasible limits). After adjusting the gains in this manner, flow control returns to block 520 and<br>
static timing analysis is once again employed to obtain slacks on each cell. This timing analysis can be<br>
incremental, but note that even when the gains of only a few cells change, the slacks of many cells may be<br>
affected. The trimming algorithm is discussed in greater detail below.<br>
The trimming algorithm works on networks of supercells. Each supercell represents the delay of<br>
a family of gates (such as 2-input AND gates). The delay of a supercell is a function of its gain, which<br>
determines the ratio of output capacitance to gate input capacitance. Increasing the gain of a supercell<br>
increases its delay, and reducing gain reduces delay.<br>
The trimming algorithm adjusts the drive strengths of gates until all slacks in the circuits are zero<br>
or all gates to be changed are at their maximum or minimum allowable gain. It begins with all supercells<br>
initialized to a nominal gain value (block E10). Then, static timing analysis is used to compute the worst<br>
timing slack on each gate (block 520). The gains of each gate are then adjusted by an amount that<br>
depends on this slack value if this slack value is non-zero (blocks 525 and 530). Gates with negative<br>
slack have their gains reduced (to make the gates faster) and gates with positive slack have their gains<br>
increased (since these gates can be made slower). The size of each gain adjustment is chosen to make the<br>
adjustment process converge smoothly. The amount of each change is related to the magnitude of the<br>
slack; larger gain reductions are made for gates with large negative slack than for gates with small<br>
negative slack. Similarly, larger gain increases are made for gates with large positive slack than for gates<br>
with small positive slack. The amount of each change is also related to the length of the critical path<br>
through each gate. Smaller changes are made to gates that lie on long paths (paths with a large number of<br>
gates) than gates that lie on shorter paths. After these changes are made, a new static timing analysis is<br>
performed, and new set of gain adjustments is made. The process stops when no more changes can be<br>
made, either because all slacks are zero (and no changes are necessary) or all the gates to be changed are<br>
already set to have their largest or smallest possible gain.<br>
Although the trimming algorithm specifically adjusts delays of cells, it can also include the<br>
effects of wire delays. Such an inclusion is possible when performing initial placement and routing in the<br>
disclosed budgeting procedure. A placement allows modeling wire delays as a function of the distance<br>
between cells. If a routing is also done, the timing analysis can model wire delays even more accurately<br>
by following the globally routed path of each wire. It is even possible to interleave global placement and<br>
routing between steps of the trimming algorithm so that the placement and sizing converges<br>
simultaneously.<br>
Figure 6 illustrates an exemplary circuit for which a time budgeting solution can be evaluated<br>
using one or more embodiments of the invention. The circuit shown is logically divided into a block 650<br>
which connects with other components in a top-level portion. The top-level portion includes a register<br>
element D10 which outputs to a buffer 611. The buffer 611 and an unspecified other signal serve as<br>
inputs to an AND gate 612. The result of the AND gate is buffered through 613 after which it approaches<br>
the boundary of block 650. The output of 613 is connected to the input of a buffer 614 inside block 650.<br>
Buffer 614 and an unspecified signal serve as inputs to an AND gate 615. The output of AND gate 615 is<br>
sent to a register element 620. Register element 620 feeds other combinational logic 625 which then<br>
feeds a register 630. Registers 610,620 and 630 are all clocked by a clocking signal CLK (not shown).<br>
The timing of this circuit is dependent on what happens inside the block as well as what happens<br>
outside the block. However, some paths inside and outside block 650 are unrelated to the timing at the<br>
boundary of the top-level and block 650. During budgeting, these paths can be completely ignored. For<br>
example, the path through combinational logic block 625 is contained entirely within the block. With the<br>
exception of the clock input, the timing of this path is unaffected by all signals at the block boundary.<br>
And as long as the clock period is held constant, the timing of this path is unaffected by the specific time<br>
at which clock signals enter the block.<br>
Those gates/elements which do not contribute to the timing at the boundary can be discarded<br>
according to the abstraction process discussed above. This abstraction retains the parasitic information<br>
needed while discarding what is irrelevant. For the example in Figure 6, the logic in block 625 can be<br>
removed or ignored during timing analysis and trimming. The trimming algorithm would then adjust the<br>
delays of gates 611-615 until the slack on the path from 610 to 620 was zero. The signal arrival time at<br>
the boundary of block 650 would become the budgeted arrival time for this input.<br>
The initial placement provides useful estimates of the delays of wires in a design. When there are<br>
too many cells in the netlists to place individually, one can use a clustering algorithm to merge them<br>
together into groups which are then placed based on the connectivity between groups. The location of<br>
individual cells is then derived from the locations of the placed clusters.<br>
With an initial placement, one can use Manhattan-based wire models to compute estimated<br>
resistance, capacitance, and delays of individual wires in the design. Although the cell delay models<br>
presented herein do not depend on capacitance, the wire delay estimates are extremely useful for<br>
improving the zero-slack trimming algorithm that seeks to optimize a design by adjusting the gain of each<br>
cell.<br>
The trimming algorithm iteratively interleaves a global timing analysis with a gain-adjustment<br>
step that can potentially adjust the gain for every cell in the design. In each gain-adjustment step, the gain<br>
at each gate is smoothly increased or decreased by an amount proportional to the local slack at the gate<br>
and inversely proportional to the maximum topological path length through the gate. This ensures that<br>
the gains along critical paths move smoothly and simultaneously toward their final trimmed value and<br>
that the trimmed gains for each cell along a critical path are equal.<br>
Trimming is not the only tool available for timing optimization. As a workaround for situations<br>
in which trimming produces dangerously low gains, optional steps can be performed to fix structural<br>
problems in the netlist. Such steps include:<br>
remapping<br>
• architecture selection (metacell swapping)<br>
• speedup restructurings<br>
Each of these operations is a discrete change to the circuit that necessitates further trimming to smoothly<br>
absorb nonzero slack into individual gate delay budgets.<br>
Shell abstractions can be used to cut out parts of the modules that are not visible at the interface.<br>
These parts should be excluded from the top-level timing analysis and any trimming or structural<br>
optimization that is done at the top level. Similarly, the top-level netlist can be pruned to remove parts of<br>
the netlist that are not visible to specific blocks for which budgets are needed.<br>
Creating Timing Constraints for Modules<br>
Budgets may be generated by converting properties of the top-level model into constraints for<br>
lower level modules (step 450). When a zero-slack timing solution has been obtained, the arrival and<br>
required times at each node in the circuit are equal. At module boundaries, these times may be interpreted<br>
as budgeted values. For module inputs, they represent arrival times, the latest or earliest times that signal<br>
transitions are presented to the block boundary from the environment. For module outputs, these times<br>
represent required times, the latest or earliest times that signal transitions at module outputs can occur<br>
without causing a timing failure in another part of the circuit.<br>
Input arrival and output required times may be relative to one or more reference clocks, and it is<br>
also possible for clocks to enter a module to control internal storage elements. As a result, it is also<br>
desirable to include definitions of these clocks in the timing budget. These clock definitions are<br>
represented by special constraints that describe clocks in the timing model for the budgeted module. The<br>
difference between the ideal time of each clock and the actual time at which the clock arrives at the input<br>
is represented with another special constraint that specifies the external latency of a clock.<br>
A few other miscellaneous timing constraints in the top-level timing model are copied down into<br>
the timing budget for a module. User-specified constants indicate that certain nets are always at constant<br>
logic values. This indicates that the timing of signal transitions on these nets can be ignored and also<br>
allows other constants to be derived by combining user-specified constants with the logical function of<br>
the gates in the design. All user-specified or derived constants that affect a module are included in its<br>
budget. Also, any constraints that represent limits and margins are also copied down into the timing<br>
budget for the module.<br>
There is one remaining type of constraint which must be represented in timing budgets; these<br>
constraints are called path exceptions. Path exceptions describe exceptions to the normal rules of timing<br>
analysis and are applied to user-specified paths in a circuit. They identify false paths, multicycle paths,<br>
and paths that are constrained to have either a minimum or maximum specified delay. All path<br>
exceptions that affect a module should be included in its budget. However, many path exceptions may<br>
refer to pins outside the module itself. This requires us to rewrite these exceptions into a form suitable for<br>
timing analysis of the module.<br>
To explain this rewriting, consider one way in which path exceptions may be supported in a static<br>
timing analyzer. To properly apply a path exception, it is necessary to partition the signal arrival times at<br>
a pin into two groups, a group which is affected by the exception and a group which is not. To enable this<br>
partitioning, associate a special symbol, called a "mark", with each pin which is named in a path<br>
exception. Each pin may have a unique mark, or to reduce resource usage, marks may be assigned to<br>
groups of pins. These marks are then associated with the signal arrival time at each marked pin and are<br>
propagated to all arrival times that are dependent on the arrival times at marked pins. Any pin in a design<br>
may have a number of different arrival times associated with it, each arrival time being identified with a<br>
different combination of marks. This can occur because a number of different paths may exist to any pin<br>
in a design, and some of those paths may be affected by path exceptions while others are not. Because<br>
each marked arrival time may be affected by a different path exception, each marked arrival time<br>
associated with a pin may have a different required time and corresponding slack value.<br>
For example, a multicycle path constraint specified from a pin named "A" and through a pin<br>
named "B" would create a mark for all arrival times that result from paths through pin A and a second<br>
mark for all arrival times that result from paths through pin B. At any endpoint, only arrival times with<br>
both marks A and B would be affected by the exception.<br>
When an exception refers to pins outside a module, it is modified by replacing each reference to<br>
an external pin with the name of the associated mark. The mark is essentially an abas for the external pin;<br>
it is included explicitly because one cannot directly refer to the external pin.<br>
To support path exceptions that cross module inputs, make the arrival time constraints for<br>
module inputs specifically associate marks with the arrival times that they present to the module inputs.<br>
Each module input may thus have a number of arrival times, which allows us to associate different arrival<br>
times with different paths through the block inputs.<br>
To support path exceptions that cross module outputs, make the required time constraints at<br>
module outputs specifically associate marks with the required times being enforced at the module outputs.<br>
Each marked required time will only apply to an arrival time with the exact same marking. This allows<br>
associating different required times with different paths through block outputs. If a path exception is<br>
wholly contained inside a module, there is no need for it to be modified, since all of the associated pins<br>
are available inside the module.<br>
Figure 7 illustrates a computer system capable of implementing one or more embodiments of the<br>
invention. Illustrated is a computer system 710, which may be any general or special purpose computing<br>
or data processing machine such as a PC (personal computer) which can optionally be coupled to a<br>
network 700. The memory 711 of computer system 710 may be insufficient to budget the entire circuit<br>
design and thus, the budgeting process may need to be broken up. In this way, pieces of the budgeting<br>
can be handled by several different computer systems each of which may be similar to computer system<br>
710.<br>
One of ordinary skill in the art may program computer system 710 to perform the task of<br>
budgeting through zero-slack trimming algorithms and static timing analysis as set forth in various<br>
embodiments of the invention. Such program code may be executed using a processor 712 such as CPU<br>
(Central Processing Unit) and a memory 711, such as RAM (Random Access Memory), which is used to<br>
store/load instructions, addresses and result data as needed. The applications) used to perform the<br>
functions of time budgeting and timing analysis may derive from an executable compiled from source<br>
code written in a language such as C++. The executable may be loaded into memory 711 and its<br>
instructions executed by processor 712. The instructions of that executable file, which correspond with<br>
instructions necessary to perform time budgeting and timing analysis, may be stored to a disk 718, such as<br>
a floppy drive, hard drive or optical drive 717, or memory 711. The various inputs such as the netlist(s),<br>
constraints, delays, capacitances, wire models, cell library and other such information may be written<br>
to/accessed from disk 718, optical drive 717 or even via network 700 in the form of databases and/or flat<br>
files.<br>
Computer system 710 has a system bus 713 which facilitates information transfer to/from the<br>
processor 712 and memory 711 and a bridge 714 which couples to an I/O bus 715. I/O bus 715 connects<br>
various I/O devices such as a network interface card (NIC) 716, disk 718 and optical drive 717 to the<br>
system memory 711 and processor 712. Many such combinations of I/O devices, buses and bridges can<br>
be utilized with the invention and the combination shown is merely illustrative of one such possible<br>
combination.<br>
The present invention has been described above in connection with a preferred embodiment<br>
thereof; however, this has been done for purposes of illustration only, and the invention is not so limited.<br>
Indeed, variations of the invention will be readily apparent to those skilled in the art and also fall within<br>
the scope of the invention.<br>
WE CLAIM:<br>
1. A method for budgeting timing used in producing an integrated circuit design, said circuit<br>
design having register cells and combinational logic cells, said circuit design having a representation<br>
that is hierarchically decomposed into a top-level and a plurality of blocks, at least some of the plurality<br>
of said blocks being capable of being further hierarchically decomposed, said register cells and<br>
combinational logic cells having at least one cell pin, said blocks having boundaries, said block<br>
boundaries represented by at least one block pin, said method comprising :<br>
optimizing at least one path, through block pins bv zero-slack trimming that involves<br>
adjustment of gains within at least some of said cells along said at least one path to apportion slack<br>
between said cells along said at least one path, said optimization resulting in assigned gains for all said<br>
cells along said at least one path ;<br>
performing timing analysis on said at least one path, said timing analysis using said assigned<br>
gains in order to generate arrival times for signals at said block pins ; and<br>
deriving a timing budget by examining said generated arrival times at said block pins wherein<br>
said timing budget at said block pins is derived using said generated arrival times at block inputs and<br>
required times at block outputs.<br>
2. A method as claimed in claim 1, comprising :<br>
buffering long nets between blocks.<br>
3. A method as claimed in claim 1, comprising :<br>
partitioning of said blocks into clusters.<br>
4. A method as claimed in claim 3, comprising :<br>
placing of said clusters.<br>
5. A method as claimed in claim 4, comprising :<br>
placing of cells contained in said top-level and in said blocks.<br>
6. A method as claimed in claim 5, comprising :<br>
routing among said cells, in the event of said cells being placed.<br>
7. A method as claimed in claim 1, wherein said input arrival times and output required times are<br>
considered by having definitions of reference clocks in said timing budget.<br>
8. A method as claimed in claim 1, wherein said timing budget has at least one of user-specified<br>
constants, derived constants, and constraints representing limits and margins.<br>
9. A method as claimed in claim 1, comprising :<br>
reading in a set of inputs related to the design.<br>
10. A method as claimed in claim 9, wherein optimizing comprises :<br>
optionally making an abstraction of said blocks ; and<br>
processing said set of inputs to create supercells.<br>
11. A method as claimed in claim 9. wherein said set of inputs comprises at least one of an initial<br>
netlist. a description of a cell library, a description of process technology to be employed, and timing<br>
constraints for the top-level netlist.<br>
12. The method as claimed in claim 1, wherein said blocks can be represented by one or more<br>
abstractions.<br>
13. The method as claimed in claim 1, wherein said optimizing is performed in a concurrent fashion<br>
among all paths that cross block boundaries.<br>
14. A method for budgeting timing used in producing an integrated circuit design, said circuit<br>
design having register cells and combinational logic cells, said circuit design having a representation<br>
that is hierarchically decomposed into a top-level and a plurality of blocks, at least some of the plurality<br>
of said blocks being capable of being further hierarchically decomposed, said register cells and<br>
combinational logic cells having at least one cell pin, said blocks having boundaries, said block<br>
boundaries represented by at least one block pin, said method comprising :<br>
optimizing at least one path through a block pin by zero-slack trimming to apportion slack along<br>
said at least one path, said optimization results in assigned gains for all said cells along said at least one<br>
path wherein said zero-slack trimming comprises :<br>
setting said assigned gains to nominal values ; and<br>
obtaining slack values on all said cells based on those said assigned gains,<br>
performing timing analysis on said at least one path, said timing analysis using said assigned<br>
gains in order to generate arrival times for signals at said block pins ;;<br>
and deriving a timing budget by examining said generated arrival times at said block pins.<br>
15. A method as claimed in claim 14, comprising :<br>
adjusting said assigned gains on cells having slack values that diverge beyond a certain<br>
tolerance about a zero value ; and<br>
repeating obtaining and adjusting until all said cells have slack values within said certain<br>
tolerance about zero or until the assigned gains on cells have reached their limits.<br>
16. A method as claimed in claim 15, wherein adjusting involves :<br>
reducing assigned gains on cells whose obtained slack value is negative ;<br>
and increasing assigned gains on cells whose obtained slack value is positive.<br>
17. A method as claimed in claim 16, wherein the amount by which said assigned gains are adjusted<br>
is proportional to the magnitude of the obtained slack value.<br>
18. A method as claimed in claim 17, wherein the amount by which said assigned gains are adjusted<br>
is further related to the length of a critical path through the cells.<br>
19. A method as claimed in claim 14, wherein said trimming involves consideration of the effects of<br>
wire delays.<br>
20. A method as claimed in claim 14, wherein said zero-slack trimming is preceded by at least one<br>
of step of structural optimization comprising remapping, architecture selection and speedup<br>
restructuring.<br>
21. A method for budgeting timing used in producing an integrated circuit design, said circuit<br>
design having register cells and combinational logic cells, said circuit design having a representation<br>
that is hierarchically decomposed into a top-level and a plurality of blocks, at least some of the plurality<br>
of said blocks being capable of being further hierarchically decomposed, said register cells and<br>
combinational logic cells having at least one cell pin, said blocks having boundaries, said block<br>
boundaries represented by at least one block pin, said method comprising :<br>
optimizing at least one path through a block pin, said optimization resulting in assigned gains<br>
for all said cells along said at least one path ;<br>
performing timing analysis on said at least one path, said timing analysis using said assigned<br>
gains in order to generate arrival times for signals at said block pins ; and<br>
deriving a timing budget by examining said generated arrival times at said block pins, wherein<br>
said timing budget also has path exceptions.<br>
22. A method as claimed in claim 21, wherein path exceptions comprises false paths, multi-cycle<br>
paths and paths constrained to have specified delay limits.<br>
23. A method as claimed in claim 22, wherein path exceptions that refer to pins outside said blocks<br>
are modified to refer to marks that uniquely correspond to external pins or groups of pins.<br>
24. A method as claimed in claim 23, wherein separate arrival times are specified at each block<br>
boundary for each possible combination of marks that can correspond to pins in the fan-in set of the<br>
block input.<br>
25. A method as claimed in claim 23, wherein separate required times are specified at each block<br>
output for each possible combinations of marks that can correspond to pins in the fan-out set of the<br>
block output.<br>
26. An article comprising a processing system for implementing a method for budgeting timing<br>
used in producing an integrated circuit design, said circuit design having register cells and<br>
combinational logic cells, said circuit design having a representation that is hierarchically decomposed<br>
into a top-level and a plurality of blocks, at least some of the plurality of said blocks being capable of<br>
being further hierarchically decomposed, said register cells and combinational logic cells having at<br>
least one cell pin, said blocks having boundaries, said block boundaries represented by at least one<br>
block pin. said processing system being adapted to execute the steps of:<br>
optimizing at least one path through [a] block pins by zero-slack trimming that involves<br>
adjustments of gains within at least some of said cells along said at least one path to apportion slack<br>
between said cells along said at least one path, said optimization resulting in assigned gains for all said<br>
cells along said at least one path ;<br>
performing timing analysis on said at least one path, said timing analysis using said assigned<br>
gains in order to generate arrival times for signals at said block pins ;<br>
deriving a timing budget by examining said generated arrival times at said block pins wherein<br>
said timing budget at said block pins is derived using said generated arrival times at block inputs and<br>
required times at block outputs.<br>
27. The article as claimed in claim 26, causing :<br>
buffering long nets between blocks.<br>
28. The article as claimed in claim 26, causing :<br>
partitioning of said blocks into clusters.<br>
29. The article as claimed in claim 28, causing :<br>
placing of said clusters if any.<br>
30. The article as claimed in claim 29, causing :<br>
placing of cells contained in said top-level and said blocks.<br>
31. The article as claimed in claim 30, causing :<br>
routing among said cells.<br>
32. The article as claimed in claim 26, wherein said zero-slack trimming is caused by :<br>
setting said assigned gains to nominal values ; and<br>
obtaining slack values on all said cells based on those assigned gains.<br>
33. The article as claimed in claim 32, causing :<br>
adjusting said assigned gains on cells having slack values that diverge beyond a certain<br>
tolerance about a zero value ; and<br>
repeating obtaining and adjusting until all said cells have slack values within said certain<br>
tolerance about zero or until the assigned gains on cells have reached their limits.<br>
34. The article as claimed in claim 33, wherein adjusting is caused by :<br>
reducing assigned gains on cells whose obtained slack value is negative ; and<br>
increasing assigned gains on cells whose obtained slack value is positive.<br>
35. The article as claimed in claim 34, wherein the amount by which gains are caused to be adjusted<br>
is proportional to the magnitude of the obtained slack value.<br>
36. The article as claimed in claim 35, wherein the amount by which assigned gains are caused to be<br>
adjusted is further related to the length of a critical path through the cells.<br>
37. The article as claimed in claim 26, wherein said trimming has the effects of wire delays.<br>
38. The article as claimed in claim 26, wherein said zero-slack trimming is preceded by at least one<br>
of step of structural optimization comprising remapping, architecture selection and speedup<br>
restructuring.<br>
39. The article as claimed in claim 26, wherein said input arrival times and output required times<br>
are caused to be considered by having definitions of reference clocks in said timing budget.<br>
40. The article as claimed in claim 26, wherein said timing budget has at least one of user-specified<br>
constants, derived constants, and constraints representing limits and margins.<br>
41. The article as claimed in claim 26, wherein said timing budget also has path exceptions.<br>
42. The article as claimed in claim 41, wherein path exceptions, comprises false paths, multi-cycle<br>
paths and paths constrained to have specified delay limits.<br>
43. The article as claimed in claim 42, wherein path exceptions that refer to pins outside the module<br>
are caused to be modified to refer to marks that uniquely correspond to external pins or groups of pins.<br>
44. The article as claimed in claim 43, wherein separate arrival times are specified at each module<br>
input for each possible combination of marks that can correspond to pins in the fan-in set of the module<br>
input.<br>
45. The article as claimed in claim 43. wherein separate required times are specified at each module<br>
output for each possible combinations of marks that can correspond to pins in the fan-in set of the<br>
module output.<br>
46. The article as claimed in claim 26, adapted to :<br>
read in a set of inputs related to the design.<br>
47. The article as claimed in claim 26, wherein optimizing is caused by :<br>
optionally making an abstraction of said blocks ; and<br>
processing said set of inputs to create supercells.<br>
48. The article as claimed in claim 47, wherein said set of inputs comprises at least one of an initial<br>
netlist, a description of a cell library, a description of process technology to be employed, and timing<br>
constraints for the top-level netlist.<br>
49. The article as claimed in claim 26. wherein said blocks can be represented by one or more<br>
abstractions.<br>
50. The article as claimed in claim 26, wherein said optimizing is caused to be performed in a<br>
concurrent fashion among all paths that cross block boundaries.<br>
The present invention discloses a method for budgeting timing in a hierarchically<br>
decomposed integrated circuit design, which includes:1) optimizing (310) at least one<br>
path through block pins, the optimization resulting in assigned gains for all the cells<br>
along said at least one path; 2) performing timing analysis (330) on the at least one<br>
path, the timing analysis using the assigned gains in order to generate arrival times for<br>
signals at said block pins; and 3) deriving a timing budget (340) by examining said<br>
estimated arrival times at said block pins.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
		<br>
		<div class="pull-left">
			<a href="225193-apparatus-for-the-production-of-granulate.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="225195-tangential-cutting-insert-and-milling-cutter.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>225194</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>01633/KOLNP/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>45/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>07-Nov-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>05-Nov-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>16-Dec-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>MAGMA DESIGN AUTOMATION, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>1650 TECHNOLOGY DRIVE, SANJOSE, CALIFORNIA 95110</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>BURKS TIMOTHY M</td>
											<td>4080 WILKIE WAY, PALO ALTO, CA 94306</td>
										</tr>
										<tr>
											<td>2</td>
											<td>RIEPE MICHAEL A</td>
											<td>762 SCHIELE AVENUE, SAN JOSE, CA 95126</td>
										</tr>
										<tr>
											<td>3</td>
											<td>SAVOJ HAMID</td>
											<td>1550 MEDFORD DRIVE, LOS ALTOS, CA 94024</td>
										</tr>
										<tr>
											<td>4</td>
											<td>SWANSON ROBERT M</td>
											<td>3372 SOUTH COURT, PALO ALTO, CA 94306</td>
										</tr>
										<tr>
											<td>5</td>
											<td>VAHTRA KAREN E</td>
											<td>723 BANTRY COURT, SUNNYVALE, CA 94987</td>
										</tr>
										<tr>
											<td>6</td>
											<td>VAN GINNEKEN LUKAS</td>
											<td>4792 COUNTRY LANE, SAN JOSE, CA 95129</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 17/50</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US02/18423</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-06-10</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60 / 296, 792</td>
									<td>2001-06-08</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/225194-method-for-budgeting-timing-used-in-producing-an-integrated-circuit-design-and-article-therefor by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 22:41:27 GMT -->
</html>
