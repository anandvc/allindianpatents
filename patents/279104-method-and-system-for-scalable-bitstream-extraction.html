<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/279104-method-and-system-for-scalable-bitstream-extraction by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:19:41 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 279104:METHOD AND SYSTEM FOR SCALABLE BITSTREAM EXTRACTION</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD AND SYSTEM FOR SCALABLE BITSTREAM EXTRACTION</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>METHOD AND SYSTEM FOR SCALABLE BITSTREAM EXTRACTION ABSTRACT OF THE DISCLOSURE A scalable video compression system (100) having an encoder (120), bit extractor (140), and decoder (160) for efficiently encoding and decoding a scalable embedded bit stream (130) at different video resolution, frame rate, and video quality levels is provided. Bits can be extracted in order of reinsertion layer (136), followed by temporal level (132), followed by spatial layer (134), wherein each bit extracted provides an incremental improvement in video decoding quality. Bit extraction can be truncated at a position in the embedded bitstream corresponding to a maximum refinement layer, a maximum temporal level, and a maximum spatial layer. For a given refinement layer, bits are extracted from all spatial layers In a lower temporal level prior to extracting bits from spatial layers in a higher temporal level for prioritizing coding gain to increase video decoding quality, and prior to .moving to a next refinement layer.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>METHOD AND SYSTEM FOR SCALABLE BITSTREAM EXTRACTION<br>
FIELD OF THE INVENTION<br>
The present invention relates to video coding, and more particularly, to scalable video compression.<br>
BACKGROUND OF THE INVENTION<br>
The use of portable electronic devices and mobile communication devices has increased dramatically in recent years. Moreover, the demand for video enabled mobile devices is rapidly increasing. Video processing requires a significant amount of signal processing and places high processing demand on a mobile device having limited computational power and battery power. Accordingly, video is generally received in a compressed format to reduce the amount of data required to represent the images. The compressed data also facilitates real time data delivery as the amount of data to be transmitted is decreased. Video coding is the process of encoding the video Into a compressed format.<br>
In traditional video compression, a video sequence is encoded into a compressed bitstream, which can later be decoded to obtain a reconstruction of the original video sequence. This system consists of one encoder and one decoder. Video compression can be extended upon to provide scalability. Scalability allows for an adjustment of video quality based on available hardware or software resources. Scalability also provides a platform for seamless mobility and which allows users to efficiently consume video contents across different video devices and transmission channels. For example, certain hardware may only support a range of framerates or a range of bitrates. A scalable video compression system allows the hardware to support various decoding options scaling to the hardware resources.<br>
Scalable video compression (SVC) produces an embedded bitstream that can be truncated at different segmentation points (i.e. locations within the embedded bitstream) to produce reconstructed videos with different desired parameters such as resolution, framerate, and quality. As an example, referring to FIG. 1, a scalable video compression (SVC) system can consist of<br>
1<br>
 <br>
an encoder 120, a bitstream extractor 140, and a decoder 160. The encoder 120 can compress the video input and generate an embedded bitstream 130 with bits representing the video input. The SVC system 100 can receive user input parameters 145 for setting a video decoding quality. The SVC system 100 is scalable in the sense that the video decode quality can be scaled in accordance with the parameters 145.<br>
Referring to FIG, 2, an exemplary scalable bitstream representation is shown. It should be noted that the bitstream segments (B0-B35) can be saved in various orderings. In the illustration of FIG. 2, the bits are shown in a row (.e.g. temporal layers) and column (e.g. spatial levels) format. In practice, each bit 131 of the bitstream is received in a sequential manner that may be dictated by the encoding order. The progressive refinement (PR) slices in the refinement layers of a scalable bitstream can be truncated at any location in the related bitstream segments, with each<br>
additional bit providing an improvement to reconstructed video quality. For example, the scalable bitstream may be truncated at the end of the bitstream segment B14 thereby providing only bit segments BO through B14 for decoding which may be sufficient for a low quality image. Referring back to FIG. 1, the bitstream extractor 140 can truncate an encoded bitstream to obtain a stream at a lower bit rate that will decode at a desired spatial resolution and temporal frame rate, with a SNR quality that is based on the provided user input parameters 145. A range of bit-rates is allowed at each resolution and framerate, with higher rates yielding better SNR quality. For constant bitrate video coding applications, the bitstream extractor shall sequentially collect the relevant bit segments from the given scalable bitstream following the designed bitstream extraction path until the target bit budget is reached. While a theoretically optimal extraction ordering is not clear, various schemes of bit extraction can perform differently for a wide variety of video sequences.<br>
There are three main types of scalability: spatial, temporal, and SNR (quality). Spatial scalability is the ability to decode the bitstream at many different resolutions. Temporal scalability is the ability to decode the bitstream at many different frame rates. SNR scalability is the ability to decode the bitstream at different bit rates to achieve desired quality. For example, a user can adjust parameters 145. such as resolution, frame rate, and quality for<br>
 <br>
setting the spatial, temporal, and SNR scalability. Spatial and temporal scalability are generally provided in a layered manner, where there are a small set of possible resolutions and frame rates. That is, information is provided in layers such that each layer provides an incremental improvement in the video decoding quality. It is possible to provide SNR scalability in a similar layered manner, or in a more continuous manner with an embedded bitstream.<br>
BACKGROUND ART<br>
The joint video team (JVT) of the ITU-T and MPEG standard organizations is in the process of developing new international scalable video coding standards, as a new amendment for the scalable video coding extension of the MPEG-4 AVC/H.264 standard. The new standard Is evolved through the Joint Scalable Video Model (JSVM). The reference software, incorporated with the adopted new coding tools, is developed for conduction coding experiments during the standardization activities. The JSVM reference software provides two methods for bit extraction, herein termed Point Extraction and Layer, Level, and Refinement Extraction (LLR) extraction.<br>
For the method of point extraction, a user specifies a point (e.g. bit location) in the embedded bitstream 130 for decoding. The point is associated with a resolution, framerate, and bitrate for video decoding quality. Point Extraction is an intuitive method for bit extraction and one which is user friendly since a desired bitrate is already provided. The method of point extraction 200 is graphically represented in FIG. 3. Bits are extracted from the embedded bit stream 130 as shown by the bit extraction order 141. Notably, Point Extraction 200 is along the same path that the bits were encoded. This may be necessary to avoid 'drift'. The point extraction 200 method operates in accordance with the bit extraction order 141 as follows. It starts at a lowest spatial layer and a lowest temporal level. It includes fine grain scalable (FGS) refinements in order from lowest to highest at this layer and level. While there are more levels at this layer, the codec moves to the next level, and extracts all refinements at this level. For example, there are 2 refinements (A then B) at temporal level 0, spatial level 0. There are also two refinements (G and H) at temporal level 1, spatial layer 1. The number of refinements equal the number of refinement<br>
 <br>
layers. After all refinements for all levels at the low/est layer are extracted, the codec moves to the next higher spatial layer and repeats the process. When the target data rate is met, the codec truncates the data at the current refinement appropriately, and exits. At the highest spatial layer, the codec ensures that all levels v^ill use the same fraction of refinement layers. Another representation of the FGS point extraction method is shov^n in FIG. 4.<br>
For LLR extraction, the user specifies a number of spatial layers, a number of temporal levels, and a number of FGS refinements to be included in the bitstream. The user is generally restricted to integer values for spatial layers and temporal levels, but may choose decimal values for the FGS refinements, or called progressive refinement slices in the JSVM. In LLR extraction, the bitrate of the extracted stream is not specified. For every spatial layer equal to or less than the given maximum spatial layer, and for every temporal level equal to or less than the given maximum temporal level, refinements are included up until the given refinement truncation point. Because there is no bitrate constraint for this mode and the extracted bitstream segments are fully determined by the input parameters, the order of the bitstream extraction has no impact on the final decoding quality.<br>
The JSVM implements Point Extraction 200 and LLR extraction 250 in different ways. The reconstruction of a point extracted bitstream at a certain bitrate may have a significantly different PSNR value than the reconstruction of an LLR extracted bitstream at the same bitrate. Neither method always outperforms the other w/ith respect to PSNR; selecting the best method is dependent on the point of extraction. Because the JSVM codec is the first international video coding standard to flexibly combine scalability in the temporal, spatial, and FGS dimensions, the problem of optimal bitstream extraction ordering has not been relevant nor addressed in the past outside the current ongoing standardization activities.<br>
SUMMARY<br>
Broadly stated, embodiments of the invention are directed to a bit extractor and method thereof for efficiently decoding a scalable embedded bitstream at different video resolution, framerate. and video quality levels. Embodiments of the invention enable a single compressed scalable bitstream<br>
 <br>
to be more efficiently decided at different video resolution, frame-rate, and quality fevefs. In particular, the bit extractor extracts bits in order of the refinement layer, followed by the temporal level, followed by the spatial layer, wherein each bit extracted provides a refinement to a video decoding quality. In one arrangement, the bit extractor can receive a maximum refinement layer, a maximum temporal level, and a maximum spatial layer to set a video decoding quality for the embedded bitstream. The bit extractor can truncate bit extraction at a position in the embedded bitstream corresponding to the maximum refinement layer, the maximum temporal level, and the maximum spatial layer for achieving the video decoding quality. The bit extractor provides a range for signal-to-noise ration (SNR) scalability given the maximum refinement layer, a range for temporal scalability given the maximum temporal level, and a range for spatial scalability given the maximum spatial layer. For a given refinement layer, the bits are extracted from all spatial layers in a lower temporal level of a refinement layer prior to extracting bits from spatial layers in a higher temporal level of the refinement layer for prioritizing coding gain to increase video decoding quality. In one aspect, the bit extractor can specify a range of bit rates that are available to provide signal-to-noise (SNR) scalability. In another aspect, the bit extractor can specify a range of bit rates that are allowed for each resolution and frame rate.<br>
The bit extractor can start at a lowest spatial layer of a lowest temporal level of a lowest refinement layer. At the lowest refinement layer, for each refinement, bits can be extracted from the lowest temporal level of the lowest spatial layer to a highest temporal level of a highest spatial layer in order of lowest to highest spatial layer. The bit extractor can move to a higher refinement layer, and for each refinement, extract bits from the lowest temporal level of the lowest spatial layer to the highest temporal level of the highest spatial layer in order of lowest to highest spatial layer. The bit extractor can repeat the step of moving to the next refinement layer up until and including the highest refinement layer. For each refinement layer, the bits are extracted from the embedded bitstream in order of refinement for each temporal level layer, followed by each spatial layer. The bit extractor can gather the bits in the embedded bitstream for the decoder in order of coding gain prioritization, such that each additional extracted bit provides a refinement to video decoding<br>
 <br>
quality. The bit extractor can prioritize the bits in the embedded bitstream for coding gain in order of refinement for the refinement layer, followed by the temporal level, followed by the spatial layer. The bits from the spatial layer can provide the highest contribution to video quality, followed by bits from the temporal level, followed by bits from the refinement layer.<br>
Embodiments of the invention are also directed to a method for video encoding. The method can Include encoding a first group of bits to create at least one refinement layer of an embedded bitstream, encoding a second group of bits to create at least one temporal level of the embedded bitstream, and encoding a third group of bits to create at least one spatial layer in the embedded bitstream, wherein each spatial layer is encoded using a previous spatial layer for prediction. Bits in the embedded bitstream can be prioritized on coding gain in order of refinement for the refinement layer, followed by the temporal level, followed by the spatial layer. Bits from all spatial layers at the lowest temporal level and refinement are prioritized from lowest spatial layer to highest spatial layer to provide the highest contribution to video quality  This is followed by followed by bits from lowest spatial layer to highest spatial layer at the next temporal level for the lowest refinement. This will continue until all spatial layers for all temporal levels are included for the lowest refinement. Bits from the next refinement will then be included in the same order.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
The features of the system, which are believed to be novel, are set forth with particularity in the appended claims. The embodiments herein, can be understood by reference to the following description, taken in conjunction with the accompanying drawings, in the several figures of which like reference numerals identify like elements, and in which:<br>
FIG. 1 is a block diagram of a scalable video compression system;<br>
FIG. 2 is a table representation of an embedded bitstream;<br>
FIG. 3 is a diagram of Point Extraction of the prior art;<br>
FIG. 4 is another diagram of Point Extraction of the prior art;<br>
FIG. 5 is an illustration of tempora) level, spatial layer, and refinement layer of an embedded bitstream in accordance with the embodiments of the invention;<br>
 <br>
FIG. 6 is an illustration of adjusting the temporal level, spatial layer, and refinement layer of an embedded bitstream in accordance with the embodiments of the invention;<br>
FIG. 7 is a method of Refinement layer, Temporal Level, and Spatial Layer (FTS) in accordance with the embodiments of the invention;<br>
FIG. 8 is a first pass of a bit extraction order for FTS in accordance with the embodiments of the invention;<br>
FIG. 9 is a second pass of a bit extraction order for FTS in accordance with the embodiments of the invention; and<br>
FIG. 10 is pseudo code for the method of FTS in accordance with the embodiments of the invention.<br>
DETAILED DESCRIPTION<br>
While the specification concludes with claims defining the features of the embodiments of the invention that are regarded as novel, it is believed that the method, system, and other embodiments will be better understood from a consideration of the following description in conjunction with the drawing figures, in which like reference numerals are carried forward.<br>
As required, detailed embodiments of the present method and system are disclosed herein. However, it is to be understood that the disclosed embodiments are merely exemplary, which can be embodied in various forms. Therefore, specific structural and functional details disclosed herein are not to be interpreted as limiting, but merely as a basis for the claims and as a representative basis for teaching one skilled in the art to variously employ the embodiments of the present invention in virtually any appropriately detailed structure. Further, the terms and phrases used herein are not intended to be limiting but rather to provide an understandable description of the embodiment herein.<br>
The terms "a" or "an," as used herein, are defined as one or more than one. The term "plurality," as used herein, is defined as two or more than two. The term "another," as used herein, is defined as at least a second or more. The terms "including" and/or "having," as used herein, are defined as comprising (i.e., open language). The term "coupled," as used herein, is defined as connected, although not necessarily directly, and not necessarily<br>
 <br>
mechanically. The term "refinement layer" can be defined as a coding level used for both Fine Grain Scaling (FGS) quality enhancement and for an overall process of providing better video to a decoder. The term "embedded bit stream" can be defined as a collection of bits inter-dispersed w/ithin a memory, or communication channel. The term "temporal level" can be defined as collection of bits that are ordered based on time. The term "spatial layer" can be defined as a collection of bits that are ordered based on association. The term "bit budget constraint" can be defined as a limitation on a number of bits used for encoding. The term "quality enhancement" can be defined as an increase in temporal resolution, spatial<br>
resolution, or combination thereof. The term "video decoding quality" can be defined as an increase in signal to noise ratio in temporal resolution, signal to noise ratio in spatial resolution, or combination thereof.<br>
FIG. 1 shovi/s the Scalable Video Compression (SVC) system 100 for efficient video coding. The SVC system 100 may be implemented in softw/are by a processor such as a microprocessor or a digital signal processor (DSP) as is known in the art, or any other suitable electronic device. The functions of the SVC system 100 may also be implemented in hardware such as an ASIC or FPGA as is know/n in the art, or any other suitable hardware. As previously noted, the SVC system 100 can include the encoder 120, the bitstream extractor 140, and the decoder 160, The encoder 120 can receive a stream of video input representing a plurality of images over time. The encoder 120 can compress the video input and generate the embedded bitstream 130 representing the video input. The embedded bitstream 130 is shown in FJG. 2 The SVC system 100 can also receive input parameters 145 for setting a video decode quality. The SVC system 100 is scalable in the sense that the video decode quality can be scaled In accordance with the parameters 145. The SVC system 100 is capable of offering a wide variety of single or combined scalable decoding options, such as spatial, temporal, and quality, from a single embedded bitstream. This allows the SVC system 100 to provide low-end video embedded in high-end video bit-stream data.<br>
The operations of the encoder 120 and decoder 160 are separated to provide efficient storage, transmission, media management, and error resiliency. The encoder 120 can encode input video and extract the relevant<br>
8<br>
 <br>
bit-stream segments for serving different decoding resource constraints. The Encoder 120 can generate a scalable bit-stream that can be flexibly extracted in different ways to meet spatio-temporal resolution and bit-rate constraints of the video decoder 160. The bit extractor 140 can extract bits from the embedded bitstream 130 in a specified order. The bit extraction may depend on the number of spatial layers, the temporal levels, and the refinement layers and bitrate desirable for decoding. The bit extractor can extract the bits in the embedded bitstream for the decoder in order of coding gain prioritization, such that each additional extracted bit provides an efficient refinement to video decoding quality.<br>
Referring to FIG. 5, an illustration for the embedded bitstream 130 as arranged by temporal level, spatial layer, and refinement level is shown. In particular, the embedded bitstream 130 can be represented by a number of temporal levels 132, a number of spatial layers 134, and a number of refinement layers 136. The number of temporal levels 132 can be given as an input to establish the temporal scalability, the number of spatial layers 134 can be given as an input to establish the spatial scalability, and a number of refinement layers 136 can be given as an input to establish the SNR scalability. The embedded bitstream representation 130 presents a visual relationship between temporal scalabUity, spatla\ scalability, and SNR scaJabifity.<br>
Referring to FIG. 6, various representations of the embedded bitstream 130 are shown. As one example, referring to the embedded bitstream 142, increasing the number of temporal levels can improve temporal quality. As another example, referring to the embedded bitstream 144, increasing the number of spatial layers can improve spatial quality. As yet another example, referring to the embedded bitstream 146, increasing the number of refinement layers can improve SNR quality. Notably, the number of temporal levels, spatial levels, and refinement levels can be set by the user parameters 145 of FIG. 1. Changing the number of temporal levels, spatial levels, or refinement levels can change the video decoding quality.<br>
Referring back to FIG. 1, the hit extractor 140 can extract bits from the embedded bitstream 130 in order of refinement layer 136, followed by temporal level 132, followed by spatial layer 134, The decoder 160 can<br>
 <br>
create a video from the bits extracted by the bit extractor. The bit extractor 140 can receive parameters including a resolution, a frame rate, and a bit rate to provide scalable video decoding, and convert the parameters to the corresponding given refinement layer, the given temporal level, and the given spatial layer for achieving the resolution, the frame rate, and the bit rate. The video can have a video decoding quality dependent on the given number of refinement layers 136, the given number of temporal levels 132, and the given number of spatial layers 134. The bit extractor 140 can specify a range of bit rates that are allowed for each resolution and frame rate, and a range of bit rates that are available to provide signal-to-noise (SNR) scalability. For example, the bit-extraction module 140 can receive the given refinement layer, the given temporal level, and the given spatial layer for setting a video decoding quality, and truncate the bit extraction at a position in the embedded bitstream 130 corresponding to the given refinement layer 136, the given temporal level 132, and the given spatial layer 134 for achieving the video decoding quality.<br>
Referring back to FIG. 1, the bit extractor 140 can extract bits in different orders. One such bit extraction order, as previously recited in the prior art, is the method of Point Extraction 200 as shown in FIG. 3. Another bit extraction order, as previously recited in the prior art, is the method of Layer, Level, and Refinement (LLR) 250 as shown in FIG. 4. One drawback of the point extraction 200 and LLR extraction 250 methods is that splitting bits among all temporal levels in not efficient.<br>
The authors have demonstrated that bits from lower temporal levels provide more gain than bits from higher temporal levels. Accordingly, the bits can be reordered, with respect to bit extraction, based on the priority of the bits for coding gain. Rate-distortion curves in simulation have shown that up to 2dB can be gained In end-to-end video decoding quality gain by re-ordering the bits in accordance with the embodiments of the invention. In practice, bits from lower temporal levels are extracted before bits from<br>
higher temporal levels. Specifically, bits are extracted in order of refinement, followed by temporal level, followed by spatial layer. Such a bit extraction ordering via a prioritization-based reordering of the bit extraction scheme yields higher end to end quality. The spatial followed by the temporal followed by the<br>
10<br>
 <br>
refinement is referred to as FTS, and is a novel aspect of the invention. The order of bit extraction is distinguished from the bit extraction ordering of the LLR and Point Extraction methods.<br>
Referring to FIG. 7, the bit extraction order 137 for the FTS method is shown. The FTS method operates in accordance with the bit extraction order 137 as follows. For each refinement in a refinement layer 136, bits from the lowest temporal level of the lowest spatial layer are first extracted. Bits from all the spatial layers at this temporal level and refinement layer are then extracted in order. Then, the bit extractor 140 moves to the next temporal level 132 and extracts bits from the spatial layers 134 in order from lowest to highest. Once all temporal levels and spatial layers are extracted at the lowest refinement, the encoder moves to the next refinement and repeats the process.<br>
For example, referring to FIG. 8, a first pass for extracting bits in accordance with the bit extraction order 137 from the embedded bitstream 130 is shown. The bit extraction order explicitly specifies a distinct order of extraction for the bits in the embedded bitstream 130. In particular, the first pass is associated with Refinement Layer 0, which is the lowest refinement layer. That is, bits are first extracted from the all spatial layers 134 and all temporal levels 132 before bits from Refinement Layer 1 are extracted. All the bits are extracted in order of refinement, followed by temporal level, followed by spatial layer as shown by the bit extraction order 137. Notably, all bits are extracted from all spatial layers in a lower temporal level prior to extracting bits from spatial layers in a higher temporal level for prioritizing coding gain.<br>
Referring to FIG. 9, a second pass for extracting bits in accordance with the bit extraction order 137 from the embedded bitstream 130 is shown. In particular, the second pass is associated with Refinement Layer 1, which is the next highest refinement layer. Bits are extracted from the all spatial layers 134 and all temporal levels 132 in Refinement Layer 1, Since the Refinement Layer only contains two refinements, the bit extraction ends at the completion of the second pass. Notably, the method of bit extraction exemplified by the bit extraction order 137 would be replicated for further refinements.<br>
The FTS method can be implemented with the below pseudo code as also shown in FIG. 10.<br>
(310) For FGS_reflnement = 0 : highest_refinement<br>
11<br>
 <br>
(312) For Temporaljevei = 0 : highestjevel (314) For Spatialjayer = 0 : highestjayer<br>
(316) Include data from the current refinement, spatial layer, and temporal level.<br>
If the assigned  bit budget  is  reached  (use fractional refinement if necessary), then exit<br>
In practice, (310) for a given refinement layer 136, (312) for a given temporal level 132, and (314) for a given spatial layer 134, (316) bits are extracted from a lovi/est spatial layer to a highest spatial layer for the given temporal level and the given refinement layer. The FTS method 300 repeats (314) for a lowest spatial layer up to a maximum spatial layer, repeats (312) for a lowest temporal level up to a maximum temporal level, and repeats (310) for a lowest refinement layer up to a maximum refinement layer.<br>
Referring back to FIG. 5, it should be noted that the bit extractor 140 performs the method for extracting bits from the embedded bitstream 130. The bit extractor 140 extracts bits from the embedded bit stream in order of coding gain priority. That is, bits are extracted in an order that can most efficiently reduce coding distortion. For example, referring to FIG. 5, bits at lower temporal levels, such as those in Level 0, provide more gain than bits at higher temporal levels, such as those in Level 3. Accordingly, the bits are extracted before bits from higher temporal levels to exploit coding gain. In another arrangement, the bits can be extracted by a host processor (not shown) that is communicatively coupled to the SVC system 100 of FIG. 1.<br>
Notably, the bit extraction method of FTS is significantly different from the bit extraction performed by the prior art methods of Point Extraction 200 and LLR. In Point Extraction 200, bits are extracted in order of spatial layer 134, followed by temporal level 132, followed by refinement layer 136.  In FTS 300, bits are extracted in order of refinement layer, followed by temporal level 132, followed by spatial layer 134. LLR is not directly applied to constant bit-rate coding.<br>
Embodiments of the invention are also directed to a method for creating an embedded bitstream suitable for use in scalable video encoding. The method includes prioritizing the bits in the embedded bitstream for coding gain<br>
12<br>
 <br>
in order of refinement for the refinement layer, followed by the temporal level, followed by the spatial layer.<br>
Where applicable, the present embodiments of the invention cari be realized in hardware, software or a combination of hardware and software. Any kind of computer system or other apparatus adapted for carrying out the methods described herein are suitable. A typical combination of hardware and software can be a mobile communications device with a computer program that, when being loaded and executed, can control the mobile communications device such that it carries out the methods described herein. Portions of the present method and system may also be embedded in a computer program product, which comprises all the features enabling the implementation of the methods described herein and which when loaded in a computer system, is able to carry out these methods.<br>
While the preferred embodiments of the invention have been illustrated and described, it will be clear that the embodiments of the invention is not so limited. Numerous modifications, changes, variations, substitutions and equivalents will occur to those skilled in the art without departing from the spirit and scope of the present embodiments of the invention as defined by the appended claims.<br>
What is claimed is;<br>
<br>
<br>
CLAIMS<br>
1.	A method for scalable bitstream extraction suitable for use in video<br>
processing, comprising the steps of:<br>
receiving an embedded bitstream having at least one refinement layer, at least one temporal level, and at least spatial layer; and<br>
extracting bits given a bit budget constraint in order of the refinement layer, followed by the temporal level, followed by the spatial layer, to provide a quality enhancement to a video decoding quality.<br>
2.	The method of claim'1, further comprising:<br>
receiving a maximum refinement layer, a maximum temporal level, and a maximum spatial layer for setting a video decoding quality: and<br>
truncating the step of extracting the bits at a position in the embedded bitstream corresponding to the maximum refinement layer, the maximum temporal level, and the maximum spatial layer for achieving the video decoding quality.<br>
N<br>
3.	The method of claim 2, further comprising:<br>
T<br>
providing a range for signal-to-noise ratio (SNR) scalability in view of the maximum refinement layer;<br>
providing a range for temporal scalability in view of the maximum temporal level; and<br>
providing a range for spatial scalability in view of the maximum spatial layer.<br>
4.	The method of claim 1, further comprising:<br>
for a given refinement layer, extracting bits from all spatial layers in a lower temporal level prior to extracting bits from spatial layers in a higher temporal level for prioritizing coding gain to increase video decoding quality.<br>
 <br>
5.	The method of claim 1, wherein the step of extracting bits is an extraction<br>
order comprising:<br>
for a lowest refinement layer to a highest refinement layer; for a lowest temporal level to a highest temporal level; for a lowest spatial layer to a highest spatial layer; extracting data from the current refinement, spatial layer, and temporal level; if the assigned bit budget is reached, then stop extracting data.<br>
6.	A scalable video compression system suitable for use in video processing,<br>
comprising:<br>
an encoder that compresses the video input and generate an embedded bitstream with at least refinement layer, at least one temporal level, and at least one spatial layer;<br>
a bit extractor that extracts bits, given a bit budget constraint, from an embedded bitstream in order of refinement layer, followed by temporal level, followed by spatial layer; and<br>
a decoder that creates an image from the extracted bits that has a video decoding quality dependent on a given refinement layer, a given temporal level, and a given spatial layer.<br>
7.	The scalable video compression system of claim 6, wherein the bit extractor receives parameters including a resolution, a frame rate, and a bit rate to provide scalable video decoding, and converts the parameters to the corresponding given refinement layer, the given temporal level, and the given spatial layer for achieving the resolution, the frame rate, and the bit rate.<br>
8.	The scalable video compression system of claim 7, wherein the bit extractor specifies a range of bit rates that are allowed for each resolution and frame<br>
rate.<br>
9.	The scalable video compression system of claim 7, wherein the bit extractor<br>
specifies a range of bit rates that are available to provide signal-to-noise (SNR)<br>
scalability.<br>
15<br>
 <br>
i!<br>
10. The scalable video compression system of claim 6, wherein the bit  extractor extracts bits from all spatial layers in a lower temporal level before extracting bits from spatial layers in a higher temporal level for prioritizing coding gain to increase a video decoding quality.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=Hh2EM1fnlQNZUhBUNpDJCw==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=Hh2EM1fnlQNZUhBUNpDJCw==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==</a></p>
		<br>
		<div class="pull-left">
			<a href="279103-ring-gear-internal-combustion-engine-starting-torque-transmission-mechanism-and-method-of-manufacturing-ring-gear.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="279105-device-and-method-for-cooling-solid-particles.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>279104</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2748/CHENP/2009</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>02/2017</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>13-Jan-2017</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>11-Jan-2017</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>15-May-2009</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>GOOGLE TECHNOLOGY HOLDINGS LLC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>1600 Amphitheatre Parkway Mountain View, CA , United States of America, 94043</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>MARK R. TRANDEL</td>
											<td>298 FAIRVIEW CIRCLE, PALATINE, ILLINOIS 60067</td>
										</tr>
										<tr>
											<td>2</td>
											<td>AGGELOS K. KATSAGGELOS</td>
											<td>714 W. CORNELIA AVENUE, CHICAGO, ILLINOIS 60657</td>
										</tr>
										<tr>
											<td>3</td>
											<td>SEVKET D BABACAN</td>
											<td>2206 SHERMAN AVENUE, APT. G2, EVANSTON, ILLINOIS 60201</td>
										</tr>
										<tr>
											<td>4</td>
											<td>SHIH-TA HSIANG</td>
											<td>2605 BRIAR TRAIL, APT. 107, SCHAUMBURG, ILLINOIS 60173</td>
										</tr>
										<tr>
											<td>5</td>
											<td>FAISAL ISHTIAQ</td>
											<td>5415 N. SHERIDAN, CHICAGO, ILLINOIS 60640</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04N 7/24</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US07/82182</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2007-10-23</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/752,567</td>
									<td>2007-05-23</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/868,067</td>
									<td>2006-11-30</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/279104-method-and-system-for-scalable-bitstream-extraction by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 00:19:42 GMT -->
</html>
