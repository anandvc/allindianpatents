<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/224196-a-method-scalably-accessing-data-in-a-document by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:16:59 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 224196:A METHOD SCALABLY ACCESSING DATA IN A DOCUMENT</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD SCALABLY ACCESSING DATA IN A DOCUMENT</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Techniques for accessing data residing in a document on a computer-readable medium by a device with device of limited resource amount include determining usage for each portion of the document independently that consumes the device resources. Based on the usage, a portion of the document is selected to cease consuming the device resources. The techniques allow a document-processing device with limited resources to scale up to process a large document. Thisn capability is an advantage when first inserting a large XML document, which cannot be fully manifested in available memory, as multiple loadable units into a database or other persistent store.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FIELD OF THE INVENTION:<br>
The present invention relates to techniques for accessing data in an arbitrarily large document<br>
that scale with the limited resources available to a device, and in particular, processing data<br>
stored in an XML document that is larger than available memory can manifest.<br>
The number of businesses exchanging information electronically is proliferating. Businesses that<br>
exchange information have recognized the need for a common standard for representing data.<br>
Extensible Markup Language ("XML") is rapidly becoming the common standard for representing<br>
data.<br>
XML describes and provides structure to a body of data, such as a file or data packet, referred to<br>
herein as an XML document. XML standards provide for tags that delimit sections of an XML<br>
document referred to as XML elements, or simply "elements".<br>
An element may contain various types of data, including element attributes and other elements.<br>
An element that is contained by another element is referred to as a descendant of that element.<br>
By defining an element that contains attributes and descendent elements, the XML document<br>
defines parent-child hierarchical relationships between the element, its descendant elements, and<br>
its attributes.<br>
The term node is used to refer to individual elements and element attributes in an XML<br>
document. Thus, an XML document defines a hierarchy of nodes having parent-child<br>
relationships. Such a hierarchy is referred to herein as a node tree or a node hierarchy.<br>
The term attribute is used herein to refer to a discrete part or element of a structure, such as a<br>
data structure or an object that belongs to an object type according to the object-oriented<br>
methodology. An attribute may be a complex construct one........<br>
or more other attributes, referred to herein as a member of the attribute. XML standards provide<br>
for element attributes in the form of name-value pairs. While the meaning of the term attribute,<br>
as used herein, encompasses element attributes, the term is not so limited.<br>
Industry standards define structures for representing XML documents. One such standard is the<br>
Document Object Model (DOM), promulgated by the World Wide Web Consortium (W3C).<br>
In order for a computer to operate on an XML document, an in-memory representation of the<br>
XML document is generated. In general, an XML document is loaded from a storage device (e.g.<br>
a disk that stores files that contain XML entities) or from data received over a communications<br>
channel, to generate in-memory data structures used to represent an XML document. The in-<br>
memory data structures are manipulated by computer processes executing software and<br>
programs. The process of loading an XML document into memory and generating an in-memory<br>
representation of the XML document is referred to as manifestation or manifesting an XML<br>
document. Typically, applications access and manipulate the in-memory data structures, created<br>
by manifestation, through an API.<br>
Under conventional approaches for manifestation, when an XML document is manifested, the<br>
entire XML document is manifested. XML documents can be very large, and thus require a<br>
significant amount of memory when manifesting them. Some XML documents are so large that<br>
memory needed to manifest them far surpasses the memory allocated to them and may also far<br>
surpass the capacity of many computers.<br>
Based on the foregoing, it is desirable to provide a mechanism that reduces the amount of<br>
memory needed to manifest an XML document.<br>
In one approach described in US Patent Application Ser.No. 10/256,777, an XML document is<br>
broken up into a plurality of loadable units that can be separately stored in database objects of a<br>
database system. Then, when a process attempts to manifest data from the XML document, only<br>
the loadable units that contain the data of interest are loaded into memory from the database.<br>
The entire XML document is not manifest. A loadable unit is a set of one or more nodes in an<br>
XML document. When one node in the loadable unit is manifest, all the nodes in the loadable unit<br>
are also manifest. Loadable units may, but not necessarily, correlate to content structures that<br>
store the nodes on persistent storage.<br>
While the system of US Patent Application Ser.No. 10/256,777 is useful for many purposes,<br>
certain operations fail to take advantage of the separately stored and loaded loadable units. Such<br>
operations continue to demand excessive amounts of........<br>
memory; they do not scale to large XML documents. Such operations include operations that<br>
express an interest in many or all of the loadable units of a large XML document, and the<br>
operations that initially insert an entire large XML document onto persistent storage, such as into<br>
a database system.<br>
Based on the foregoing, it is desirable to provide techniques for reducing the amount of memory<br>
needed by operations that involve enough loadable units of an XML document to exceed available<br>
memory.<br>
In addition, the approach of US Patent Application Ser.No. 10/256,777 assumes the contents of<br>
the loadable units loaded into memory are not changed there, so that a loadable unit can always<br>
be replaced by reloading that loadable unit from persistent storage. However, in many<br>
operations, one or more of the loadable units have different contents in memory than they have<br>
stored separately on persistent storage. For example, during the initial insert into a database<br>
system, none of the loadable units first loaded into memory reside as separately stored units in<br>
the database on persistent storage. Such loadable units are said to be "dirty". The approach of<br>
US Patent Application Ser.No. 10/256,777 is not suitable for dirty loaded units.<br>
Based on the foregoing, it is further desirable to provide techniques for retaining information<br>
during operations that involve dirty loadable units of an XML document.<br>
The past approaches described in this section could be pursued, but are not necessarily<br>
approaches that have been previously conceived or pursued. Therefore, unless otherwise<br>
indicated herein, the approaches described in this section are not to be considered prior art to<br>
the claims in this application merely due to the presence of these approaches in this background<br>
section.<br>
BRIEF DESCRIPTION OF THE ACCOMPAYING DRAWINGS:<br>
The present invention is illustrated by way of example, and not by way of limitation, in the<br>
figures of the accompanying drawings and in which like reference numerals refer to similar<br>
elements and in which :<br>
Fig. 1 is a block diagram that illustrates structures used by a server to process an XML document<br>
that exceeds available memory, according to an embodiment;<br>
Fig. 2 is a flow diagram that illustrates a high level method for processing an XML document that<br>
exceeds available memory, according to an embodiment; and<br>
Fig. 3 is a block diagram that illustrates a computer system upon which an embodiment of the<br>
invention may be implemented.<br>
DETAILED DESCRIPTION OF THE INVENTION:<br>
A method and article of manufacture for accessing data in a large document by a device with<br>
limited resources is described. In the following description, for the purposes of explanation,<br>
numerous specific details are set forth in order to provide a thorough understanding of the<br>
present invention. It will be apparent, however, that the present Invention may be practiced<br>
without these specific details. In other instances, the well-known structures and devices are<br>
shown in block diagram form in order to avoid unnecessarily obscuring the present invention.<br>
Embodiments of the invention are described herein in the context of using all or part of an XML<br>
document, which, if manifested fully in memory, would exceed the amount of memory available<br>
on a database server. However, the invention is not limited to this context. Other embodiments<br>
of the invention may be applied to other contexts in which the server is not a database server but<br>
provides other services based on the XML document. In still other embodiments, the XML<br>
document may be used as input to a stand-alone application that is not a server, i.e. an<br>
application that does not respond to requests from a separate client process. In some<br>
embodiments, the document accessed is not an XML document but is a document that is<br>
composed of multiple constructs according to another markup language. In some embodiments,<br>
it is not memory that is limited but some other resource, such as buffers on an input or output<br>
device connected to the host computer of the application processing the document, or bandwidth<br>
on a network connection over which the document is to be sent.<br>
In the illustrated embodiments, separately accessible portions of the XML document (for<br>
example, the "loadable units", LU, of US Patent Application Ser.No. 10/256,777) are loaded into<br>
memory and usage of those portions is monitored. When additional memory is desired, the<br>
memory allocated to one or more of those portions is released, based on the usage. For<br>
example, the memory allocated to the least recently used portion is released. The portion that<br>
loses the memory allocated to it is said to be "unloaded" from memory. In some embodiment,<br>
if the portion to be unloaded is dirty (e.g. contains data that is not stored persistently as a<br>
separate portion, such as a loadable unit, in one or more containers of a database), then the<br>
portion is stored persistently before the memory is reallocated to another portion of the<br>
document. Because each loadable unit is independently accessible from the persistent storage,<br>
the loadable unit can be retrieved from persistent storage subsequently, if it is to be used again.<br>
In some embodiments, the portion is persistently stored directly into an object-related database<br>
structure of a database; in some...<br>
embodiments the portion is persistently stored in a temporary file on a persistent storage<br>
device.<br>
[0025] The techniques of the present invention allow a document-processing device<br>
with limited resources to scale up to process a large document that would otherwise<br>
exceed the available resources. This is an advantage when first inserting a large XML<br>
document, which cannot be fully manifested in available memory, as multiple loadable<br>
units into a database, or other persistent store. This is also an advantage after the different<br>
portions of the large XML document have been inserted separately into a persistent data<br>
store, if an operation involves more portions than can be manifested in memory at one<br>
time, or if the operation modifies the contents of a loadable unit. An example of such<br>
operations are an operation to format the entire document for presentation on a graphical<br>
interface using an XML style sheet, and an operation that edits any elements of a large<br>
XML document<br>
STRUCTURAL OVERVIEW<br>
[0026] FIG. 1 is a block diagram that illustrates data structures used by a server in an<br>
XML processing system 100 to process an XML document that exceeds available<br>
memory, according to an embodiment The system 100 includes a database server 120<br>
that includes server fast memory 150 that is allocated for processing an XML document<br>
As used herein, the term fast memory refers to memory most readily available to a<br>
processor for storing data and instructions outside the processor. In current technologies,<br>
memory used for this purpose has quick response time; but data does not persist in such<br>
memory if power to the memory is lost. Fast memory tends to be more expensive than<br>
other types of memory, so, it is often more scarce than other types of memory. The server<br>
120 also includes one or more persistent storage devices that provide server persistent<br>
storage 130. In current technologies, such persistent storage retains data if power is lost;<br>
but, such storage is slow and is not desirable for use as the most readily available memory<br>
for a processor. The persistent storage includes a storage area reserved for temporary<br>
storage 132 and a storage area used for database storage space 140.<br>
[0027] The database storage space 140 includes storage for one or more object-<br>
relational structures, 144a, 144b and others indicated by ellipsis 146, collectively<br>
referenced hereinafter as object relational structures 144. The object-relational structures<br>
144 store data objects in one or more relational database data structures, such as tables,<br>
rows, columns, and stored procedures.<br>
The system 100 processes an XML document type data structure 102 that defines the attributes<br>
of each element type that may be used by an XML document that is an instance of the type. The<br>
data structure may reside on any computer readable medium, described in more detail in a later<br>
section, which can be read by server 120, such as on a removable magnetic or optical disk, or<br>
over a communication channel. The database storage space 140 includes a mapping 142<br>
between element attributes, or elements, used in the XML documents and the data objects in one<br>
or more object-relational structures 144. The system 100 generates the contents of the mapping<br>
142 based on the contents of the XML document type data structure 142 using any mechanism<br>
known in the art. In some embodiments, the object-relational structures are actually defined and<br>
created based on the contents of the XML document type data structure 102. In one<br>
embodiment, the mechanism described in US Patent Application Ser.No. 10/256,777 is employed<br>
to map elements and attributes of the XML document type data structure to data objects of the<br>
object-relational data structures 144.<br>
An XML document 110 is an instance of the type defined in data structure 102. The XML<br>
document 110 includes one or more elements that each may comprise one or more attributes,<br>
which each may be another element, as defined in the document type data structure 102. The<br>
XML document 110 thus establishes a particular hierarchy of nodes, where each child node<br>
represents an attribute of its parent node, and each attribute has a value appropriate for its type.<br>
For purposes of illustration, it is assumed that XML document 110 has several attributes,<br>
including on attribute represented by element 112a and another attribute represented by<br>
element 112b. It is further assumed that element 112a has several attributes, including<br>
attributes represented by elements 114a, 114b, 115, and other elements represented by the<br>
ellipsis 113. It is further assumed that elements 114a, 114b may include other attributes that<br>
include other elements, not shown. It is also assumed that element 115 is a block of data that is<br>
not further divided or defined by the XML type data structure 102; it is called an "opaque"<br>
element, and can be quite large. For example, opaque element 115 might include text for a long<br>
description of terms and conditions of a purchase order contract, or might include a string of<br>
characters that represents a genetic code sequence. It is further assumed that element 112b has<br>
several attributes, including attributes represented by elements 116, 117, and other elements<br>
represented by the ellipsis 118.<br>
The server establishes one or more loadable unit (LU) data structures, such as 152a, 152b, and<br>
others represented by ellipsis 153, collectively referenced hereinafter as LU data structures 152.<br>
During processing, data for one or more nodes of XML.....<br>
document 110 are converted to a LU in memory 150 for storage on permanent storage<br>
130. For some LU, the values of the attributes are included in the LU. For some LU, the<br>
value for an attribute, such as a child element, is not included in the LU. Instead, the<br>
other attribute is itself a different LU. A locator indicates a location for the different LU<br>
in permanent storage 130. The locator for the different LU is included in the parent LU.<br>
Thus the LU contains enough information to load the rest of the XML tree, at nodes<br>
beyond the nodes in the parent LU. An LU indicated by a locator in a parent LU is<br>
sometimes called an "out-of-line" LU because it are often stored in a one or more<br>
different data structures from the data structure mat stores the parent LU.<br>
[0032] The server 120 also establishes a usage data structure 156 for recording usage<br>
of the data in the LU data structures 152. For example, the usage data structure 156<br>
includes a first data item that indicates whether a process on server 120 is finished with<br>
the data in a particular LU data structure 152 in memory 150. In some embodiments, the<br>
usage data structure includes a second data item mat indicates a relative time when the<br>
data in the particular LU data structure 152 was last used.<br>
[0033] The server 120 also establishes a locators data structure 158. The locators data<br>
structure 158 holds a locator that indicates where on persistent storage 130 a particular<br>
LU is stored and associates that locator with a LU identifier, such as a LU name. For<br>
example, a locator indicates a file name and offset for data written to a large object (LOB)<br>
in temporary storage 132. In another example, a locator indicates a data item, such as a<br>
row, in one or more object-relational structures 144 in database storage space 140.<br>
Object-relational structures 144 may include a database LOB structure, among others.<br>
FUNCTIONAL OVERVIEW<br>
[0034] FIG. 2 is a flow diagram that illustrates a high level method 200 for processing<br>
an XML document that exceeds available memory, according to an embodiment. Though<br>
steps are depicted in FIG. 2 in a particular order, in other embodiments the steps may be<br>
performed in a different order, or overlapping in time.<br>
[0035] In step 202, the loadable units for a document are determined based on the<br>
element type definitions in the XML document type data structure 102. Standards for<br>
XML define a schema language for specifying the structure of an XML document, which<br>
language may be used in the data structure 102. The structure defined in the XML<br>
document type data structure 102 is referred to herein as an XML schema. The database<br>
server 120 has the ability to interpret an XML document type data structure 102 and<br>
create or modify object-relational structures 144 needed to support the XML schema. For<br>
example, the XML schema construct "<complextype>" is mapped to an object type in<br>
the database. Additional user annotations in the XML schema are used to specify<br>
particular storage parameters, thus allowing some portions of the XML document to be<br>
stored in additional tables, large objects (LOBs) and other database containers. In other<br>
embodiments, a different server has the ability to interpret an XML document type data<br>
structure 102 and create or modify other data containers needed to support the XML<br>
schema.<br>
[0036] In step 210, a loadable unit (LU) is loaded into fast memory 150 allocated to<br>
processing the XML document and stored in a LU data structure 152. The LU may be<br>
retrieved from the database in database storage space 140, or from temporary storage 132,<br>
or from an XML document 110 on some other computer-readable medium. When an LU<br>
that uses a locator for one or more attributes is loaded from temporary storage 132 or<br>
XML document 110, a value for the locator might not yet be established for the attribute's<br>
location in the database; in such cases a temporary value for the locator is used, such as a<br>
name of the first element that corresponds to the LU.<br>
[0037] For example, it is assumed for purposes of illustration that element 112a<br>
corresponds to one loadable unit, and elements 114a, 114b, and 115 are each different<br>
loadable units. Thus the LU for element 112a uses locators instead of actual values for<br>
attributes that correspond to elements 114a, 114b and 115. When element 112a is read<br>
from new XML document 110 by server 120, a LU data structure 152 (e.g., 152b) is<br>
generated in memory 150 to hold this element, but elements 114a, 114b, 115 have not yet<br>
been read in or stored on persistent storage 130, so no locators are yet defined for the LU<br>
data structures mat will hold these LUs. When these elements are read, LU data<br>
structures are created.<br>
[0038] In step 220, usage is determined for the LUs stored in memory data structures<br>
152 and the usage is stored in usage data structure 156. In an embodiment, the usage data<br>
structure 156 includes a LU memory address field (designated hereinafter<br>
"MEM_ADDR"), a count field (designated hereinafter "COUNT") and a time field<br>
(designated hereinafter "TIME") for each LU data structure in memory 150. In some<br>
embodiments, the usage data structure 156 is separate from the LU data structures 152,<br>
and a separate record is included in the usage data structure 156 for each LU data<br>
structure 152. When a LU data structure 152 is created in memory 150, a row is added to<br>
the usage data structure 158 with values in these fields. The value for the MEM_ADDR<br>
field indicates where in the memory 150 the LU data structure 152 begins. The value for<br>
the COUNT field is set to "1," to indicate that one process is using the LU data structure<br>
(in this case the process that is creating the data structure). The value for the TIME field<br>
is set to the current system time to indicate when the LU data structure was last used.<br>
[0039] In other embodiments, more or fewer fields are used in usage data structure<br>
156. For example, in some embodiments, a size field (designated hereinafter "SIZE") is<br>
included for each LU data structure 152 to indicate the size of the LU data structure 152.<br>
In some embodiments a dirty flag field (designated hereinafter "DIRTY" field) is<br>
included for each LU data structure 152 to indicate whether contents of the LU are dirty,<br>
i.e., possibly different from the contents of that LU on persistent storage 130. The<br>
DIRTY field holds one of two values; one value indicates that the corresponding LU is<br>
dirty, and the other indicates that the corresponding LU is not dirty.<br>
[0040] m some embodiments usage data structure 156 is part of the LU data structure<br>
152. In such embodiments, the MEM_ADDR field may be omitted and, when a LU data<br>
structure 152 is created in memory 150, values are stored in the other fields of usage data<br>
structure 156, as described above.<br>
[0041] Whenever a process of server 120 that uses a LU data structure 152 begins, the<br>
value in the COUNT.field corresponding to that LU is incremented by one, and the value<br>
of the TIME field corresponding to that LU is updated. The beginning of a process that<br>
uses a LU data structure is called, hereinafter, a "touch" of that LU data structure.<br>
Whenever a process of server 120 that uses a LU data structure 152 ends, the value in the<br>
COUNT field corresponding to that LU is decremented by one, and the value of the<br>
TIME field corresponding to that LU is updated. For example, a process that simply<br>
loads data from the XML document 110 causes the value of the corresponding COUNT to<br>
be 1 when the LU data structure 152 is created, and decrements the value of COUNT to<br>
zero when the LU is fully loaded into the data structure 152. As soon as the LUs<br>
corresponding to the attributes are loaded, the parent LU is considered fully loaded.<br>
[0042] In an illustrated embodiment, the usage data structure 156 includes a list of<br>
unloadable units. When the value of the COUNT field reaches zero, the corresponding<br>
LU data structure is added to the list Any method may be used to indicate the LU on the<br>
list. In one example, an LU in the list is indicated by its memory address. In other<br>
embodiments, values of the COUNT field other than zero may be used to qualify the LU<br>
data structure for inclusion on the list of unloadable units. Embodiments that use this list<br>
need not maintain the TIME field in the usage data structure 156, because the LU data<br>
structures are added to the list of unloadable units in order of time from the earliest to the<br>
latest that became unloadable.<br>
[0043] In step 230, it is determined whether a condition for releasing memory<br>
allocated to one or more LU data structures 152 is satisfied. In the illustrated<br>
embodiment, the condition for releasing memory is that total use of memory 150 by the<br>
LU data structures 152 exceeds a threshold value. The threshold value is typically chosen<br>
to be less than the total memory allocated. For example, the condition for releasing<br>
memory may be that more than 75% of the memory 150 is consumed by the LU data<br>
structures 152. The total memory consumed may be computed by adding all the values of<br>
the SIZE fields in the usage data structure 156. If it is determined in step 230 that the<br>
condition for releasing memory is not satisfied, then control passes back to step 210 to<br>
load the next LU into fast memory. If it is determined in step 230 that the condition for<br>
releasing memory is satisfied, then control passes to step 240.<br>
[0044] In step 240, one or more of the LU data structures are selected to be unloaded,<br>
based on usage. For example, the least recently used LU data structure is selected to be<br>
unloaded. The least recently used LU data structure can be determined by finding the LU<br>
data structure 152 corresponding to the earliest value in the TIME field.<br>
[0045] In order to avoid unloading a LU that is still in use by a process, in some<br>
embodiments, only LU data structures with COUNT values of zero are considered for<br>
unloading. In some such embodiments, the least recently used LU is determined only<br>
from the list of unloadable units, described above. The least recently used LU data<br>
structure is the first LU data structure indicated in the list of unloadable units.<br>
[0046] In step 250, the memory allocated to the selected LU data structure is released.<br>
In some embodiments, step 250 includes steps 252,254,256.<br>
[0047] In step 252, it is determined whether the contents of the selected LU data<br>
structure 152 are stored separately in persistent storage. In embodiments with a DIRTY<br>
field associated with each LU data structure 152, step 252 may be performed by<br>
determining whether the DIRTY filed indicates the LU data structure 152 is not dirty. If<br>
it is determined that the selected LU data structure 152 is not dirty, then control passes to<br>
step 256, described below, without writing the contents to persistent storage.<br>
[0048] If it is determined in step 252 that the selected LU data structure is dirty,<br>
control passes to step 254. In step 254, the LU contents in the LU data structure 152 are<br>
written to a LU data structure on persistent storage 130. In some embodiments, the LU is<br>
written to a data structure on temporary storage 132. In some embodiments, the LU is<br>
written to an object-relational structure 144 on database storage space 140. In either or<br>
other embodiments, a locator is returned that indicates a location for the LU on persistent<br>
storage 130, so that the LU can be reloaded into memory 150 at a later time. In the<br>
[0052J During step 210, the server 120 creates a first LU data structure 152a, called<br>
hereinafter "LU-A" to store the highest node in the XML hierarchy, the document level<br>
node for document 110. The COUNT field is initialized with the value 1. The DIRTY<br>
field is initiated with the value 1, which is assumed, for purposes of illustration, to<br>
indicate a dirty LU data structure. The LU data structure LU-A 152a is dirty because the<br>
contents have not yet been stored persistently as a LU. The SIZE field is initiated with a<br>
minimum size for document level LU, which comprises enough room for the values of<br>
attributes and locators for the elements 112a, 112b etc. up to the minimum number of<br>
elements expected for document 110 based on its schema. It is assumed for purposes of<br>
illustration that the SIZE of LU-A is 0.01 MB. The server 120 processes the first few<br>
lines of the XML document 110 and loads the values of the attributes of the document<br>
into LU-A, 152a. The server then comes to a line of the XML document that begins the<br>
element 112a, before locators for the out-of-line LUs associated with elements 112a, 112b<br>
are determined. Thus the loading process is not finished with LU-A and the COUNT<br>
remains set with a value of 1.<br>
[0053] During step 220 it is determined that the total memory used by the LU data<br>
structures 152 is the SIZE of LU-A. The list of unloadable units in usage data structure<br>
156 is empty. In step 230 it is determined that this amount of memory (0.01MB) does not<br>
exceed the threshold of 1.5MB and control passes back to step 210 to begin loading the<br>
next LU.<br>
[0054] During this iteration of step 210, the server 120 creates a second loadable unit<br>
data structure 152b, called hereinafter "LU-B" to store the node associated with element<br>
112a. The COUNT field and the DIRTY field are each initialized with the value 1. The<br>
SIZE field is initiated with a minimum size for the LU for element 112, which comprises<br>
enough room for the values of attributes and locators for the elements 114a, 114b, 115,<br>
etc. up to the minimum number of elements expected for element 112a, based on its<br>
schema. It is assumed for purposes of illustration that the SIZE of LU-B is 0.1 MB. The<br>
server 120 processes the first few lines of the element 112a and loads the values of the<br>
attributes of the element into LU-B, 152b. The server then comes to a line of the XML<br>
document that begins the element 114a, before locators for the out-of-line LUs associated<br>
with elements 114a, 114b, 115 are determined. Thus the loading process is not finished<br>
with LU-B and the COUNT remains set with a value of 1.<br>
[0055] During the next iteration of step 220 it is determined that the total memory<br>
used by the LU data structures 152 is the SIZE of LU-A and LU-B. The list of unloadable<br>
units in usage data structure 156 is empty. In the next iteration of step 230, it is<br>
determined that this amount of memory (0.11MB) does not exceed the threshold of<br>
1.5MB and control passes back to step 210 to begin loading the next LU.<br>
[0056] The process continues with the next LUs associated with the child elements of<br>
112a, including elements 114a, 114b, 115. It is assumed for purposes of illustration that<br>
elements 114a, 114b and 115 do not include child elements, and mat the values for the<br>
SIZE fields of the three elements are 0.2 MB, 0.2 MB, and 1.1 MB, respectively. It is<br>
further assumed that based on the existence of elements 114b and 115, additional locators<br>
have been added to LU-B and the value of the SIZE field in LU-B is thereby increased to<br>
0.11. As soon as each is loaded completely into LU data structures LU-C, LU-D, LU-E,<br>
respectively, (not shown) in memory 150, the values of the COUNT field is decremented<br>
to zero, and the addresses-of the three LU data structures are added to the list of<br>
unloadable units in usage data structure 156.<br>
[0057] During the next iteration of step 220 it is determined that the total memory<br>
used by the LU data structures 152 is the sum of the values in the SIZE fields of LU-A,<br>
LU-B, LU-C, LU-D and LU-E. The list of unloadable units in usage data structure 156<br>
includes the memory addresses of LU-C, LU-D, and LU-E. In the next iteration of step<br>
230, it is determined that this amount of memory (1.62 MB) does exceed the threshold of<br>
1.5 MB and control passes back to step 240 to select a LU data structure 152 to unload<br>
from memory 150.<br>
[0058] In step 240, the least recently used LU data structure in the list of unloadable<br>
units is selected. The first LU data structure in the list, which is LU-C corresponding to<br>
element 114a, is the least recently used. Therefore LU-C is selected as the LU data<br>
structure to unload. In other embodiments, other selection criteria may be used. For<br>
example, the LU data structure LU-E with the largest value (1.1 MB) of SIZE may be<br>
selected. The proper selection is determined based on the manner in which a system is<br>
used. It is expected that the most recently used LU is the most likely to be used again,<br>
and that the least recent is least likely to be used again. Therefore the least likely is<br>
selected to avoid unloading a LU that is more likely to be loaded again.<br>
[0059] In step 252, it is determined whether LU-C is dirty. Because the value of the<br>
DIRTY field indicates LU-C is dirty, control passes to step 254. In step 254, LU-C is<br>
written to an object-relational structure 144 of the database and a locator for LU-C,<br>
designated herein as "L-C" is returned in the process. The server 120 writes the value "L-<br>
C" to the locators data structure 158 in association with an identifier to the LU formed for<br>
element 114a. All LU data structures 152 in memory, which have unresolved references<br>
to element 114a as an attribute, have those references resolved by using this locator "L-<br>
C." Any LU data structure that receives its last unresolved locator has its COUNT field<br>
decremented. If the LU data structure is associated with a COUNT value that reaches<br>
zero, then the LU data structure is added to the list of unloadable units, in step 256, the<br>
memory allocated to LU-C is freed, so it can be allocated to another LU data structure.<br>
Also in step 256, the usage information for LU-C in usage data structure 156 is deleted.<br>
[0060] Control then passes back to step 230 to determine if the memory usage still<br>
exceeds the threshold. The total memory used by the LU data structures 152 is the sum of<br>
the values in the SIZE fields of LU-A, LU-B, LU-D and LU-E (without LU-C). The list<br>
of unloadable units in usage data structure 156 includes the memory addresses of LU-D,<br>
LU-E (without LU-C). It is determined that this amount of memory (1.42 MB) does not<br>
exceed the threshold of 1.-5 MB and control passes back to step 210 to load the next<br>
loadable unit into memory 150.<br>
[0061] Thus an XML document of arbitrary size may be inserted into a database<br>
using a server with a limited amount of fast memory allocated to the document<br>
[0062] In some embodiments, the XML document is a transient document that is only<br>
used for a short time, but is not to be permanently stored in the database. In such<br>
embodiments, the steps are similar, except during writing to persistent storage, step 254,<br>
the LU are written to data structures in temporary storage. In one embodiment in this<br>
group, the temporary storage data structure is a LOB file with a number of offset bytes<br>
where the LU begins and the mapping 142 is still stored within the database.<br>
PROCESSING AN XML DOCUMENT FROM A DATABASE<br>
[0063] For purposes of illustrating this case, the assumptions used in the previous<br>
case are made again, except that, instead of obtaining the XML document 110 from an<br>
external source, it already resides in the database. Thus every LU that uses an out-of-line<br>
child LU has a defined locator for that child LU. It is further assumed that the entire<br>
XML document is to be operated on to form a presentation that is styled according to an<br>
XSL document, with the styled result sent to a display device.<br>
[0064] During step 210, the server 120 creates the first loadable unit data structure<br>
152a, called "LU-A" to store the highest node in the XML hierarchy, the document level<br>
node for document 110. The COUNT field is initialized with the value 1. The DIRTY<br>
field is initiated with the value 0, to indicate a LU data structure that is not dirty. The LU<br>
data structure is not dirty because the contents have been retrieved from persistent storage<br>
in the database and have not been changed. The SIZE field is initiated with actual size for<br>
document level LU. The server 120 processes the first few attributes of the XML<br>
document 110 according to the XSL document and sends the result to the destination, the<br>
display device. The server then must start styling element 112a, before the whole<br>
document is styled. Thus the styling process is not finished with LU-A and the COUNT<br>
remains set with a value of 1.<br>
[0065] As above, during step 220 it is determined that the total memory used by the<br>
LU data structures 152 is the SIZE of LU-A. The list of unloadable units in usage data<br>
structure 156 is empty. In step 230 it is determined that this amount of memory<br>
(0.01MB) does not exceed the threshold of 1.5MB and control passes back to step 210 to<br>
begin loading the next LU.<br>
[0066] During this iteration of step 210, the server 120 creates a second loadable unit<br>
data structure 152b, called "LU-B" to store the node associated with element 112a. The<br>
COUNT field and the DIRTY field are initialized with the values 1,0, respectively. The<br>
SIZE field is initiated with the actual size for the LU for element 112. It is assumed for<br>
purposes of illustration that the SIZE of LU-B is 0.11 MB. The server 120 styles the first<br>
few attributes of element 112a and sends the results to the destination display device.<br>
The server comes to style an attribute that corresponds to element 114a, before finishing<br>
the styling of element 112a. Thus the styling process is not finished with LU-B and the<br>
COUNT remains set with a value of 1.<br>
[0067] During the next iteration of step 220 it is determined that the total memory<br>
used by the LU data structures 152 is the SIZE of LU-A and LU-B. The list of unloadable<br>
units in usage data structure 156 is empty. In the next iteration of step 230, it is<br>
determined that this amount of memory (0.12 MB) does not exceed the threshold of<br>
1.5MB and control passes back to step 210 to begin loading the next LU.<br>
[0068] The process continues with the next LUs associated with the child elements of<br>
112a, including elements 114a, 114b, 115. As above, it is assumed for purposes of<br>
illustration that elements 114a, 114b and 115 do not include child elements, and that the<br>
values for the SIZE fields of the three elements are 0.2 MB, 0.2 MB, and 1.1 MB,<br>
respectively. As soon as each is loaded completely into LU data structures LU-C, LU-D,<br>
LU-E, respectively, (not shown) in memory 150, COUNT is incremented to 1; when the<br>
styling begins the COUNT is incremented again to 2. When the styling is finished, the<br>
COUNT is decremented to 1, and when the result is sent to the destination display device,<br>
the COUNT field is decremented again to zero. When the COUNT is decremented to<br>
zero for each of the three LU data structures, the address of each is added to the list of<br>
unloadable units in usage data structure 156.<br>
illustrated embodiment, the locator returned is stored in the locators data structure 158,<br>
where the locator is associated with the LU identifier, such as the LU name or name of<br>
the first corresponding XML element<br>
[0049] In step 256, the memory allocated to the selected LU data structure 152 in fast<br>
memory 152 is de-allocated and made available for allocation to a different LU data<br>
structure. In some embodiments, this step includes deleting usage information<br>
corresponding to the selected LU data structure from the usage data structure 156.<br>
Control then passes back to step 230 to determine whether the condition for releasing<br>
memory is still satisfied.<br>
[0050] These techniques allow a device with limited resources, such as a limited<br>
amount of fast memory, to scale up to process documents of arbitrarily large size. This<br>
capability is an advantage when first inserting a large XML document, which cannot be<br>
fully manifested in available memory, as multiple loadable units into a database or other<br>
persistent store. This capability is also an advantage after the different portions of the<br>
large XML document have been inserted separately into a persistent data store, if an<br>
operation involves more portions than can be manifested in memory at one time, such as<br>
while processing an entire XML document to apply styles specified in an XML style<br>
sheet (XSL) document. The uses of the illustrated embodiment for these two cases are<br>
described in the next two sections.<br>
INSERTING AN XML DOCUMENT INTO A DATABASE<br>
[0051] For purposes of illustrating this case, it is assumed that the object relational<br>
structures 144 in the database have already been created or modified based on an XML<br>
schema presented in the XML document type data structure 102, during step 202. It is<br>
further assumed that XML document 110 is received from some external source, such as<br>
over a communications channel or from a removable, optical disk, and is to be inserted<br>
into the database. It is further assumed that server fast memory 150 has been allocated to<br>
process the document 110. It is further assumed that the COUNT field, the SIZE field,<br>
and a DIRTY field of the usage data structure 156 are included in each LU data structure,<br>
and that the usage data structure 156 includes, outside the LU data structures 152, a list of<br>
unloadable units that indicates the LU data structures where the COUNT value is zero. A<br>
LU data structure is identified in the list by the memory address of the first byte in the LU<br>
data structure 152. It is further assumed that the amount of fast memory 150 allocated to<br>
this document is 2 million bytes (2 MB) and the threshold for unloading a loadable unit is<br>
1.5 MB.<br>
[0069] During the next iteration of step 220 it is determined that the total memory<br>
used by the LU data structures 152 is the sum of the values in the SIZE fields of LU-A,<br>
LU-B, LU-C, LU-D and LU-E. The list of unloadable units in usage data structure 156<br>
includes the memory addresses of LU-C, LU-D, LU-E. In the next iteration of step 230,<br>
it is determined that this amount of memory (1.62 MB) does exceed the threshold of 1.5<br>
MB and control passes back to step 240 to select a LU data structure 152 to unload from<br>
memory 150.<br>
[0070] In step 240, the least recently used LU data structure in the list of unloadable<br>
units is selected. The first LU data structure in the list, which is LU-C corresponding to<br>
element 114a, is the least recently used. Therefore LU-C is selected as the LU data<br>
structure to unload.<br>
[0071] In step 252, it is determined whether LU-C is dirty. Because the value of the<br>
DIRTY field indicates LU-C is not dirty, control passes to step 256. In step 256, the<br>
memory allocated to LU-C is freed to be allocated to another LU data structure and the<br>
usage information for LU-C in usage data structure 156 is deleted.<br>
[0072] Control then passes back to step 230 to determine if the memory usage still<br>
exceeds the threshold. It is determined that the total memory used by the LU data<br>
structures 152 is the sum of the values in the SIZE fields of LU-A, LU-B, LU-D and LU-<br>
E (without LU-C). The list of unloadable units in usage data structure 156 includes the<br>
memory addresses of LU-D, LU-E (without LU-C). In the next iteration of step 230, it is<br>
determined that this amount of memory (1.42 MB) does not exceed the threshold of 1.5<br>
MB and control passes back to step 210 to load the next loadable unit into memory 150.<br>
[0073] Thus an XML document of arbitrary size may be processed from a database<br>
using a server with a limited amount of fast memory allocated to the document.<br>
HARDWARE OVERVIEW<br>
[0074] Figure 3 is a block diagram that illustrates a computer system 300 upon which<br>
an embodiment of the invention may be implemented. Computer system 300 includes a<br>
bus 302 or other communication mechanism for communicating information, and a<br>
processor 304 coupled with bus 302 for processing information. Computer system 300<br>
also includes a main memory 306, such as a random access memory (RAM) or other<br>
dynamic storage device, coupled to bus 302 for storing information and instructions to be<br>
executed by processor 304. Main memory 306 also may be used for storing temporary<br>
variables or other intermediate information during execution of instructions to be<br>
executed by processor 304. Computer system 300 further includes a read only memory<br>
(ROM) 308 or other static storage device coupled to bus 302 for storing static information<br>
and instructions for processor 304. A storage device 310, such as a magnetic disk or<br>
optical disk, is provided and coupled to bus 302 for storing information and instructions.<br>
[0075] Computer system 300 may be coupled via bus 302 to a display 312, such as a<br>
cathode ray tube (CRT), for displaying information to a computer user. An input device<br>
314, including alphanumeric and other keys, is coupled to bus 302 for communicating<br>
information and command selections to processor 304. Another type of user input device<br>
is cursor control 316, such as a mouse, a trackball, or cursor direction keys for<br>
communicating direction information and command selections to processor 304 and for<br>
controlling cursor movement on display 312. This input device typically has two degrees<br>
of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the<br>
device to specify positions in a plane.<br>
[0076] The invention is related to the use of computer system 300 for implementing<br>
the techniques described herein. According to one embodiment of the invention, those<br>
techniques are performed by computer system 300 in response to processor 304 executing<br>
one or more sequences of one or more instructions contained in main memory 306. Such<br>
instructions may be read into main memory 306 from another computer-readable<br>
medium, such as storage device 310. Execution of the sequences of instructions<br>
contained in main memory 306 causes processor 304 to perform the process steps<br>
described herein. In alternative embodiments, hard-wired circuitry may be used in place<br>
of or in combination with software instructions to implement the invention. Thus,<br>
embodiments of the invention are not limited to any specific combination of hardware<br>
circuitry and software.<br>
[0077] The term "computer-readable medium" as used herein refers to any medium<br>
that participates in providing instructions to processor 304 for execution. Such a medium<br>
may take many forms, including but not limited to, non-volatile media, volatile media,<br>
and transmission media. Non-volatile media includes, for example, optical or magnetic<br>
disks, such as storage device 310. Volatile media includes dynamic memory, such as<br>
main memory 306. Transmission media includes coaxial cables, copper wire and fiber<br>
optics, including the wires that comprise bus 302. Transmission media can also take the<br>
form of acoustic or light waves, such as those generated during radio-wave and infra-red<br>
data communications.<br>
[0078] Common forms of computer-readable media include, for example, a floppy<br>
disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-<br>
ROM, any other optical medium, punchcards, papertape, any other physical medium with<br>
patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory<br>
chip or cartridge, a carrier wave as described hereinafter, or any other medium from<br>
which a computer can read.<br>
[0079] Various forms of computer readable media may be involved in carrying one or<br>
more sequences of one or more instructions to processor 304 for execution. For example,<br>
the instructions may initially be carried on a magnetic disk of a remote computer. The<br>
remote computer can load the instructions into its dynamic memory and send the<br>
instructions over a telephone line using a modem. A modem local to computer system<br>
300 can receive the data on the telephone line and use an infra-red transmitter to convert<br>
the data to an infra-red signal. An infra-red detector can receive the data carried in the<br>
infra-red signal and appropriate circuitry can place the data on bus 302. Bus 302 carries<br>
the data to main memory 306, from which processor 304 retrieves and executes the<br>
instructions. The instructions received by main memory 306 may optionally be stored on<br>
storage device 310 either before or after execution by processor 304.<br>
[0080] Computer system 300 also includes a communication interface 318 coupled to<br>
bus 302. Communication interface 318 provides a two-way data communication coupling<br>
to a network link 320 that is connected to a local network 322. For example,<br>
communication interface 318 maybe an integrated services digital network (ISDN) card<br>
or a modem to provide a data communication connection to a corresponding type of<br>
telephone line. As another example, communication interface 318 maybe a local area<br>
network (LAN) card to provide a data communication connection to a compatible LAN.<br>
Wireless links may also be implemented. In any such implementation, communication<br>
interface 318 sends and receives electrical, electromagnetic or optical signals that carry<br>
digital data streams representing various types of information.<br>
[0081] Network link 320 typically provides data communication through one or more<br>
networks to other data devices. For example, network link 320 may provide a connection<br>
through local network 322 to a host computer 324 or to data equipment operated by an<br>
Internet Service Provider (ISP) 326. ISP 326 in turn provides data communication<br>
services through the world wide packet data communication network now commonly<br>
referred to as the "Internet" 328. Local network 322 and Internet 328 both use electrical,<br>
electromagnetic or optical signals that carry digital data streams. The signals through the<br>
various networks and the signals on network link 320 and through communication<br>
interface 318, which carry the digital data to and from computer system 300, are<br>
exemplary forms of carrier waves transporting the information.<br>
[0082] Computer system 300 can send messages and receive data, including program<br>
code, through the network(s), network link 320 and communication interface 318. In the<br>
Internet example, a server 330 might transmit a requested code for an application program<br>
through Internet 328, ISP 326, local network 322 and communication interface 318.<br>
[0083] The received code may be executed by processor 304 as it is received, and/or<br>
stored in storage device 310, or other non-volatile storage for later execution, Is this<br>
manner, computer system 300 may obtain application code in the form of a carrier wave.<br>
[0084] In the foregoing specification, the invention has been described with reference<br>
to specific embodiments thereof. It will, however, be evident that various modifications<br>
and changes may be made thereto without departing from the broader spirit and scope of<br>
the invention. The specification and drawings are, accordingly, to be regarded in an<br>
illustrative rather than a restrictive sense.<br>
1. A method for scalably accessing data in a document with content structured according to a<br>
markup language, on a computer-readable medium using a device with device resources of<br>
limited resource amount, the method comprising the steps of:<br>
for each portion of the document, of a plurality of portions to the document, determining usage<br>
that indicates how much the portion is being accessed;<br>
wherein each portion is based on one or more constructs of the markup language;<br>
based on the usage, selecting a particular portion of the document to cease consuming the<br>
device resources; and<br>
releasing the device resources consumed by the particular portion;<br>
characterized in that<br>
said step of determining usage comprises determining a number of uncompleted operations by<br>
the device resources; and<br>
said step of selecting the particular portion comprises determining that the number of<br>
uncompleted operations on the particular portion is less than a minimum number.<br>
2. The method as claimed in claim 1, wherein the method additionally comprises the step of<br>
determining whether a condition for releasing a resource is satisfied and said step of selecting<br>
the particular portion is performed only if it is determined that the condition for releasing a<br>
resource is satisfied.<br>
3. The method as claimed in claim 2, wherein said step of determining usage comprises<br>
determining total resource usage by all portions of the document that consume the device<br>
resources; and the condition for releasing a resource comprises that the total resource usage<br>
exceed a threshold resource amount that is less than the limited resource amount.<br>
4. The method as claimed in any one of claims 1 to 3, wherein the minimum number is one.<br>
5. The method as claimed in any one of claims 1 to 4, wherein said step of selecting the<br>
particular portion comprising the step of selecting the particular portion that is least recently used<br>
of a plurality of portions for which the number of uncompleted operations Is less than the<br>
minimum number.<br>
6. The method as claimed in any one of claims 1 to 5, wherein said step of releasing the device<br>
resources consumed by the particular portion comprising the steps of:<br>
determining whether contents of the particular portion reside in persistent storage separately<br>
from a different portion of the document; and<br>
if it is determined that the contents do not reside in persistent storage separately from a<br>
different portion, then writing the contents to persistent storage separately from a different<br>
portion before releasing the device resources consumed by the particular portion.<br>
7. The method as claimed in claim 6, wherein said step of releasing the device resources<br>
consumed by the particular portion comprising, if it is determined that the contents do reside in<br>
persistent storage separately from a different portion, then performing the step of releasing the<br>
device resources consumed by the particular portion without writing the contents to persistent<br>
storage.<br>
8. The method as claimed in claim 6 or claim 7, wherein the persistent storage is to file in a file<br>
system.<br>
9. The method as claimed in claim 6 or claim 7, wherein the persistent storage is a database<br>
object in a database system.<br>
10. The method as claimed in any one of claims 1 to 9, comprising the steps of:<br>
determining the hierarchical elements of the document from a type definition document<br>
associated with the document; and<br>
determining the plurality of portions of the document based on the hierarchical elements.<br>
11. The method as claimed in any one of claims 1 to 10, wherein the document is an extensible<br>
markup language (XML) document.<br>
12. The method as claimed in claim 10, wherein the document is an XML document and the type<br>
definition document is a document type definition (DTD) document.<br>
13. The method as claimed in claim 10, wherein the document is an XML document and the type<br>
definition document is a XML schema document.<br>
14. The method according to any one of claims 6 to 9, said step of releasing the device resources<br>
comprising the step of returning a reference to the particular portion in the persistent storage.<br>
15. A method for performing an operation on a document with content structured according to a<br>
markup language, the method comprising the steps of:<br>
determining that said operation Involves a plurality of portions of said document, including a<br>
first set of one or more portions and a second set of one or ore portions, wherein each<br>
portion is based on one or more constructs of the markup language;<br>
during performance of said operation, performing the steps of:<br>
loading the first set of one or more portions of the document into a volatile memory;<br>
prior to completion of said operation, for each portion of the first set of one or more portions<br>
of the document, determining usage that indicates how much the portion is being accessed,<br>
comprising determining a number of uncompleted operations on each portion of the first set<br>
of one or more portions of the document;<br>
prior to completion of said operation, selecting, based on the usage, at least one portion in<br>
said first set of portions to cease consuming volatile memory, comprising determining that<br>
the number of uncompleted operations on the particular portion is less than a minimum<br>
number, and<br>
prior to completion of said operation and after selecting said at least one portion, freeing up<br>
the volatile memory that held said at least one portion in order to load into volatile memory<br>
said second set of one or more portions of the document.<br>
16.The method as claimed in claim 15, wherein :<br>
the document is an extensible markup language (XML) document that has a size that exceeds<br>
the volatile memory of a computer device;<br>
the operation involves loading the document into the volatile memory of the computer device<br>
by receiving into volatile memory of the computer device a stream of data representing the<br>
XML document;<br>
the step of selecting at least one portion includes determining a particular portion of a<br>
plurality of portions of the document based on one or more XML constructs;<br>
the method additionally comprises the steps of:<br>
before all of the XML document has been received into the volatile memory, storing the<br>
particular portion separately on persistent storage; and<br>
in the volatile memory, associating a locator for the particular portion with an XML construct<br>
that corresponds to a parent node for at least one XML construct upon which the particular<br>
portion is based.<br>
Techniques for accessing date residing in a document on a computer-readable<br>
medium by a device with device of limited resource amount include determining<br>
usage for each portion of the document independently that consumes the device<br>
resources. Based on the usage, a portion of the document is selected to cease<br>
consuming the device resources. The techniques allow a document-processing<br>
device with limited resources to scale up to process a large document. This<br>
capability is an advantage when first inserting a large XML document, which<br>
cannot be fully manifested in available memory, as multiple loadable units into a<br>
database or other persistent store.</complextype></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
		<br>
		<div class="pull-left">
			<a href="224195-fission-reactor-for-a-claus-plant.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="224197-honeycomb-carrer-for-exhaust-gas-clarification-catalyst-and-method-for-production-trereof.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>224196</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>01072/KOLNP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>41/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>10-Oct-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>03-Oct-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>06-Jun-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>ORACLE INTERNATIONAL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>500 ORACLE PARKWAY, REDWOOD SHORES, CA 94065</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>CHANDRASEKAR, SIVASANKARAN</td>
											<td>540 EVERETT AVENUE, PALO, CA 94301</td>
										</tr>
										<tr>
											<td>2</td>
											<td>MURTHY,RAVI</td>
											<td>33227 JAMIE CIRCLE, FREMONT, CA 94555</td>
										</tr>
										<tr>
											<td>3</td>
											<td>AGARWAL, NIPUN</td>
											<td>4768 CHEENEY STEET, SANTA CLARA, CA 95954</td>
										</tr>
										<tr>
											<td>4</td>
											<td>SEDLAR, ERIC</td>
											<td>4270 CESAR CHAVEZ STREET, SAN FRANCISCO, CA 94131</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 17/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2003/035551</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2003-11-06</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/306,130</td>
									<td>2002-11-26</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/424,543</td>
									<td>2002-11-06</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/224196-a-method-scalably-accessing-data-in-a-document by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:17:00 GMT -->
</html>
