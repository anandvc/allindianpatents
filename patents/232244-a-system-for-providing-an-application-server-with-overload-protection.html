<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/232244-a-system-for-providing-an-application-server-with-overload-protection by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:03:05 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 232244:A SYSTEM FOR PROVIDING AN APPLICATION SERVER WITH OVERLOAD PROTECTION</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A SYSTEM FOR PROVIDING AN APPLICATION SERVER WITH OVERLOAD PROTECTION</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A system and method for application server with overload protection. A system, for example a server or a cluster, is designed to generate a message, and/or reject further work, whenever the server becomes overloaded. It does this in a processor-efficient manner so as not to place even more strain on the already burdened server. The rejection message or action is customizable. In accordance with an embodiment, the system determines where the request would appear in a priority queue, and rejects those further down the queue. It does this quickly and with minimal processing time by determining to which workload manager the request is going to be delivered.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
SYSTEM AND METHOD FOR APPLICATION SERVER WITH OVERLOAD PROTECTION<br>
Copyright Notice A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.<br>
Claim of Priority:<br>
U.S. Provisional Patent Application entitled SYSTEM AND METHOD FOR APPLICATION SERVER WITH OVERLOAD PROTECTION, Application No. 60/573,307, filed May 21, 2004, by Naresh Revanuru and Anno Langen (Atty. Docket No.: BEAS-01561US0), and incorporated herein by reference.<br>
U.S. Patent Application entitled SYSTEM AND METHOD FOR  APPLICATION   SERVER  WITH   OVERLOAD   PROTECTION,<br>
Application No.	, filed May 19, 2005, by Naresh Revanuru<br>
and Anno Langen (Atty. Docket No.: BEAS-01561US1), and incorporated herein by reference<br>
Field of the Invention:<br>
The invention is related generally to application servers and messaging systems, and specifically to a system and method for application server with overload protection.<br><br>
Background:<br>
In a typical application server or web server environment, a server may be receiving thousands of requests within a very short timeframe. In certain instances the server would become overloaded and be unable to process further requests. To the user this appears as a page error, or a frozen page. The user will typically keep hitting the server with requests, when this really doesn't have any effect and only serves to worsen the problem. What is needed is a mechanism that can notify the user that the server is currently overloaded, and which will allow the server to regain stability while not having to deal with further requests. The traditional approach has been to generate a server "object not found", or to place the requests in a fixed-length queue. However, no attempt is made to characterize the requests or to, for example, reject those requests that will take longer than one minute, while servicing the others.<br>
Summary:<br>
In accordance with an embodiment of the invention, a system, for example, a server or a cluster, is designed to generate a message, and/or reject further work, whenever the server becomes overloaded. It does this in a processor-efficient manner so as not to place even more strain on the already burdened server. The rejection message or action is customizable. However, there is a thin line between customizing to the point of being flexible, and overly customizing to the point of adding more processor requirements. Above all, the rejection must be handled quickly. The traditional approach fails to adapt for certain requests, such as for example ensuring payment requests are communicated at the expense of simple browsing requests. A company<br><br>
might address this by installing multiple servers. However, the invention allows for optimal processing even within a single server.<br>
In accordance with an embodiment, the system determines where the request would appear in a priority queue, and rejects those further down the queue. It does this quickly with minimal processing time by determining which workload manager the request, (for example an http request), is going to be delivered to. The http request is parsed by a queuing logic, and the destination servlet determined. An administrator can configure which servlets should be prioritized above others. The parsing thus implies a particular workload manager associated with that servlet, and the corresponding priority for the request. The request is not looked at too rigorously, but primarily only at the URL level to determine which workload manager or servlet will handle the request. The system can also be used to provide feedback to the user or an administrator that certain requests will not be handled at the current time, but for example that other requests could be handled. This message may also be customized within reasonable limits which is not possible with existing methodologies.<br>
In accordance with an embodiment the system is configured to specify a threshold for an individual workload manager, together with a global overload threshold. Requests are given virtual time stamps and queued accordingly, according to priority. When the threshold is exceeded, requests below the threshold priority are rejected.<br>
Brief Description of the Figures:<br>
Figure 1 shows an illustration of an environment including a system which uses server overload protection in accordance with an embodiment of the invention.<br><br>
Detailed Description:<br>
Overload protection plays an important part in the overall availability of a server or a cluster. In a typical application server or web server environment, a server may be receiving thousands of requests within a very short time-frame. In certain instances the server would become overloaded and be unable to process further requests. To the user this appears as a page error, or a frozen page. The user will typically keep hitting the server with requests, when this really doesn't have any effect and only serves to worsen the problem. The traditional approach has been to generate a server "object not found", or to place the requests in a fixed-length queue. However, no attempt is made to characterize the requests or to, for example, reject those requests that will take longer than one minute, while servicing the others. Other implementations are unaware of overload conditions and continue to accept requests. Accepting requests will aggravate the situation resulting in poor performance and stability. What is desired is fast fail of requests in such conditions. This works w&amp;ii in a cluster as the load is distributed amongst the remaining members of the cluster.<br>
In accordance with an embodiment of the invention, a system, for example a server or a cluster, is designed to generate a message, and/or reject further work, whenever the server becomes overloaded. It does this in a processor-efficient manner so as not to place even more strain on the already burdened server. The rejection message or action is customizable. However, there is a thin line between customizing to the point of being flexible, and overly customizing to the point of adding more processor requirements. Above all, the rejection must be handled quickly. The traditional approach fails to adapt for certain requests, such as for example ensuring payment requests are communicated at the expense of simple browsing requests. A company<br><br>
might address this by installing multiple servers. However, the invention allows for optimal processing even within a single server.<br>
In accordance with an embodiment, the system determines where the request would appear in a priority queue, and rejects those further down the queue. It does this quickly with minimal processing time by determining which workload manager the request, {for example an http request), is going to be delivered to. The http request is parsed by a queuing logic, and the destination servlet determined. An administrator can configure which servlets should be prioritized above others. The parsing thus implies a particular workload manager associated with that servlet, and the corresponding priority for the request. The request is not looked at too rigorously, but primarily only at the URL level to determine which workload manager or servlet will handle the request. The system can also be used to provide feedback to the user or an administrator that certain requests will not be handled at the current time, but for example that other requests could be handled. This message may also be customized within reasonable limits which is not possible with existing methodologies.<br>
In accordance with an embodiment the system is configured to specify a threshold for an individual workload manager, together with a global overload threshold. Requests are given virtual time stamps and queued accordingly, according to priority. When the threshold is exceeded, requests below the threshold priority are rejected.<br>
Figure 1 shows an illustration of an environment including a system which uses server overload protection in accordance with an embodiment of the invention. As shown in Figure 1, a server 100 accepts requests from multiple clients 102, 104, 106. In this instance server 100 includes a plurality of servlets 108, 110, 112, each with their associated workload manager. The server includes a server state monitor 116 or similar mechanism for determining current server load.<br><br>
The server also includes a priority queue 118 for accepting requests prior to communicating the requests to the servlets, and a queuing logic 124 that accepts status information from the server state monitor and controls entry into the priority queue. In operation, as clients make requests 126, 130,138, the queuing logic will only queue those requests that it deems acceptable given the current system state. Servlets configured with a higher priority have their requests queued at a higher priority. Servlets configured with a lower priority may find incoming requests are rejected 138, in some instances with a customer message or action.<br>
Example Implementation<br>
The following sections describe an example implementation including the overload actions taken on exceeding the execute queue length, transaction count, HTTP session count and on encountering an OOME. In accordance with an embodiment, JRockit specific API's are used to calculate memory usage after every GC interval and provide notification if the average free memory drops below the configured threshold. This aiso ensures faster faiiover of RMi ciients in an overloaded cluster by directing them to a member that is still available to take requests.<br>
Definition of Terms, Acronyms, and Abbreviations<br>
Overload - A server condition in which accepting more requests would result in deterioration of server performance and stability. The server has exceeded it's resource capacity, such as available memory.<br>
OOM - java.lang.OutOfMemoryError thrown by the VM<br>
FD - File descriptor<br><br>
OOM Protection<br>
This feature enables the server to exit on encountering OOM error. On JRockit VM's, proprietary API's are used to calculate memory usage after every full GC and generate events when the average free memory goes below a threshold.<br>
There are two parts to OOM protection - exit on OOME and mbean notification's when the average free memory is below a threshold. The server will catch OOM errors thrown during the execution of a request and exit immediately if configured to do so. This is based on the assumption that application's do not catch OOM error's themselves. This feature is useful if the server is backed by the NodeManager or by a HA solution. The server will exit with a well defined exit code distinguishable from normal VM termination.<br>
On JRockit, it's management API is used to calculate memory usage after every GC interval. A low memory event will be sent to the registered listeners if the average free memory goes below a configured threshold. The server is treated as overloaded and the configured overload action is taken. Note that the design of the notification mechanism isn't JRockit specific, but will work on other VM's that include this functionality.<br>
Hysteresis can be built into the low memory notification. There is an upper bound on the used memory after which low memory notification is sent out. There is a lower bound after which the low memory notification is withdrawn<br>
The console can have an overload protection section that will contain the following options:<br>
Exit server process on encountering OutOfMemoryError<br>
Average free memory threshold &amp; number of memory )     samples used to calculate the free memory.<br><br>
The server can catch OOME generated during execution of a request and exit with a well defined error code. It is assumed that applications will not handle OOME themselves. The system will also handle OOME similarly in internal subsystem's wherever possible.<br>
Administrators can configure a free memory threshold as a percentage of total memory. The server is considered overloaded after this threshold and the configured overload action is taken. The parameters used to determine low memory condition already exist in the ServerMBean (e.g. LowMemorySampleSize). The system goes one step further and executes the overload action on Jrockit and comparable VM products.<br>
Java Programming Interfaces<br>
Subsystems can register for memory notifications using the standard MBean notification scheme. The following is an example:<br>
1.	Adding a MemoryListener to the JVMRuntime<br>
JVMRuntimeMBean jvmRuntime = serverRuntime. get JVMRuntime () ;<br>
mbeanServer.addNotificationListener(jvmRuntime.getObj ectName(),<br>
myMemoryListener, myMemoryFilter, null);<br>
2.	Implementation of MyMemoryFilter<br>
import weblogic.management.runtime.MemoryNotification; public class MyMemoryFilter implements j avax. management.NotificationFilter {<br>
public boolean isNotificationEnabled( Notification n ) { if (n instanceof MemoryNotification) { long freeMemory = ((MemoryNotification)n).getFreeMemory{);<br>
long totalMemory =<br><br>
((MemoryNotification)n).getTotalMemory();<br>
if (freeMemory 
} }<br>
return false;<br>
}<br>
} // end of MyMemoryFilter<br>
Theweblogic.management.mntime.MemoryNotificationcan have two methods, getFreeMemory() and getTotaIMemory(). The getFreeMemory() returns the average free memory over "ServerMBean.LowMemorySampleSize" samples.<br>
Periodic notifications about the average free memory is sent to listeners who have specified notification filters. If a notification filter is not specified, a notification is sent only when the free memory is below the globally configured memory threshold.<br>
Execute Queue Length Protection<br>
This feature allows administrator's to limit the number of outstanding requests in the execute queue. Basically, administrators can define a global queue threshold after which requests will be throttled. The self-tuning dispatch model also allows an enqueued request to be associated with an OverloadManager. The OverloadManager decides the maximum pending requests for that request class. OverloadManager's override the global queue threshold.<br>
Non-transactional RMI requests with a low fair share will be rejected immediately in an overloaded server. This applies to one-way, synchronous or asynchronous RMI. If the overload condition continues to persist, higher priority requests will start getting rejected. There are some exceptions to this rule:<br><br>
Requests destined for subsystems like JMS and transactions are allowed in since they perform their own overload management.<br>
Admin requests are allowed.<br>
webapp requests apart from the internal management one's like the console will be rejected immediately.<br>
Faster RMI Client Failover<br>
A clusterable RMI client is given a special ref if some or all cluster nodes are overloaded. The special ref points to a cluster node that is not overloaded and is still available to take application requests. This will prevent clients from trying multiple cluster node's and failing.<br>
This feature enables RMI client's to quickly identify healthy nodes in an overloaded cluster without having to try every entry in the replica list. If administrators start new cluster nodes to help reduce the overload, it will direct clients to the newly started nodes.<br>
Each server's availability information is transmitted in the cluster heartbeats. The avaiiabiiiiy information wiii ieii if the server is running, overloaded or suspended. A server is considered as overloaded if it either exceed's the execute queue threshold or running low on memory. The availability information is transmitted back to the clients and used as follows:<br>
All servers in a cluster are healthy. The replica list sent back to the client will have all the server entries. The client is free to choose any server based on it's load balancing policy.<br>
One or more servers in a cluster are overloaded. As a part of the piggyback response, the system will send a special ref to the client that points to a server that is not overloaded. The client will try this special ref for it's next request since it has a better change of success. After execution, the server can send back another special ref or retain the<br><br>
same one for the next client execution. This will continue till the overload condition goes away. The server rotates the special ref if there are a multiple of them.<br>
If a new cluster node is started to reduce the overload condition, the special ref will point to the newly started node. To avoid flooding at the new node, the special ref can be withdrawn after a few requests. If all the cluster nodes are'overloaded, the client is asked not to try till a certain period of time. The waiting time is determined by the server's throughput, the number of pending requests in the execute queue etc.<br>
Active Transactions Limit<br>
This feature allows an administrator to limit the number of active transactions in the server. Once the maximum limit is reached, the server will refuse to participate in new transactions. Note that RMI calls that are associated with an existing transaction will be allowed in. Only RMI calls that try to start a new transaction will be refused.<br>
The console can have an option to specify the transaction limit. The transaction subsystem will throw a javax.transaction.SystemException when the transaction limit is exceeded.<br>
Active HTTP Sessions Limit<br>
This feature allows an administrator to limit the number of active HTTP sessions in the server. Limiting the number of new sessions prevents OOME.<br>
The system will refuse requests that create new HTTP sessions if the maximum session limit is reached. In a cluster, the plugin will redirect the request to another cluster node. In a non-clustered scenario, the server can redirect requests to an alternate server.<br><br>
The maximum number of primary HTTP sessions allowed in the server can be set in the console. The session limit is global across all applications.<br>
The servlet container will execute one of the following actions if the max-sessions limit is reached:<br>
If the server is in a cluster, a 503 response is sent back and the plugin will failover the request.<br>
If the server is not in a cluster but an alternate server is specified, the servlet container will redirect the request to the alternate server.<br>
If an overload-error-page is specified in the webapp descriptor, the server will use it to send the overload response back to the client.<br>
If an overload redirection url is specified in the console, it will be used to send the overload response.<br>
Deadlock Detection<br>
\~f\\   UIWVsTMl,   LI IO   OyOlCIM   UGUI   UCICI11 III IC   II   III CI C   IO   d   LI II C(3U<br>
deadlock and exit if desired. This feature is possible only on VM's that have the ability to detect thread deadlocks.<br>
The server will check for stuck threads periodically. If more than one thread is stuck, the system can use the JRockit management API to check if the threads are involved in a deadlock. The server can be configured to exit in this condition. This is useful if the server is backed by the NodeManager or a HA solution like Veritas. The HA backend will restart the server. This provides automatic failure recovery. Note that the system will only detect deadlocks within the same process. Inter process deadlocks is out of the scope. The above actions are also executed if all the threads in a server are stuck and the self-tuning thread model cannot add more threads.<br><br>
The console can have an option to exit the server process on detecting a thread deadlock. The server will regularly monitor the health of its threads and determine if any of them are stuck. The stuck time interval is already configurable through the console. If more than one thread is stuck, we will use the JRockit management API to check if the stuck threads are involved in a deadlock. The server will save a thread dump in the logs before killing itself.<br>
Per-Channel FD Reservation<br>
Administrators can make file descriptor reservations per network channel. This will enable administrators to access the server even during DOS attacks. This will guarantee that admin users will always gain access to the server even if it is heavily loaded. The server will be administrative even during DOS attacks.<br>
It is possible to specify the number of FD's reserved per network channel for admin users. The server will ensure that at least the reserved number of FD's are assigned to admin users at all times.<br>
Weil-Defined Exit Codes<br>
The server uses well defined exit codes while terminating itself in certain overload conditions. The exit codes can be used by shell scripts or HA agents to decide whether a server restart is necessary.<br>
The exit codes shown in Table 1 are defined for server terminations.<br><br><br>
Table 1<br>
Overloaded Server State<br>
A state "OVERLOADED" can be added as a new server state. This state will be returned by the ServerRuntimeMBean.getState() and ServerLifeCycleRuntimeMBean,getState() if the server is RUNNING but is overloaded. The overload condition can happen either due to the execute queue length reaching it's threshold or due to low memory. The server state will change back into RUNNING after the overload condition goes away. The state transitions are as follows:<br>
1. SHUTDOWN --&gt; STANDBY --&gt; RUNNING --&gt; OVERLOADED --&gt; RUNNING --&gt; SHUTDOWN<br><br>
2. SHUTDOWN --&gt; STANDBY --&gt; RUNNING --&gt; OVERLOADED --&gt; FAILED --&gt; SHUTDOWN<br>
Operations available in the RUNNING state are also supported in the OVERLOADED state. So, a server can be suspended or shutdown from the OVERLOADED state. Having a separate OVERLOADED state ensures that overload conditions are prominently displayed in the management console and through the various MBean utilities. It is also convenient for subsystems to add notification listener's to the ServerLifeCycleRuntime and get OVERLOADED notification as a part of the regular state change notification scheme.<br>
The present invention may be conveniently implemented using a conventional general purpose or a specialized digital computer or microprocessor programmed according to the teachings of the present disclosure. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art.<br>
In some embodiments, the present invention includes a computer program product which is a storage medium (media) having instructions stored thereon/in which can be used to program a computer to perform any of the processes of the present invention. The storage medium can include, but is not limited to, any type of disk including floppy disks, optical discs, DVD, CD-ROMs, microdrive, and magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and/or data.<br>
The foregoing description of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed.<br><br>
The embodiments were chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. Particularly, while various embodiments are described as using or working with JRockit, it will be evident that other VM products can be used. It is intended that the scope of the invention be defined by the following claims and their equivalence.<br><br><br>
 Claims:<br>
What is claimed is:<br>
1.	A system for providing an application server with overload<br>
protection, comprising:<br>
a server, configured to receive requests from clients, and having a plurality of workload managers operating thereon;<br>
a queuing logic that determines the priority of requests being received as determined by the priority of the workload manager the request is directed to; and<br>
wherein the queuing logic is configured to reject certain of said requests when the server state indicates a possible overload condition.<br>
2.	The system of claim 1 wherein each workload manager is associated with a servlet, and wherein the requests are directed to servlets operating on said server and reached by said workload managers.<br>
3.	The system of claim 1 wherein the workload managers are prioritized by allocating a portion of available thread time for their use.<br>
4.	The system of claim 3 wherein the portion of available thread time is specified as a relative share value of allowed thread time for one workload manager compared to another.<br>
5.	The system of claim 1 wherein the workload managers can be manually prioritized by a system administrator.<br><br>
6.	The system of claim 5 wherein the system includes a console application for use by said system administrator in prioritizing said workload managers.<br>
7.	The system of claim 1 wherein the requests thus prioritized according to destination workload manager are placed in a queue according to their priority.<br>
8.	The system of claim 7 wherein requests that are not placed in the queue are rejected.<br>
9.	The system of claim 1 wherein the request can be rejected with a custom message sent back to the client.<br>
10.	The system of claim 1 wherein the system receives state information about the current state of the server which it uses to determine a possible overload condition.<br>
11.	A method for providing an application server with overload protection, comprising the steps of:<br>
receiving at a server requests from clients, said server having a plurality of workload managers operating thereon;<br>
determining the priority of requests being received as determined by the priority of the workload manager the request is directed to; and<br>
rejecting certain of said requests when the server state indicates a possible overload condition.<br>
12.	The method of claim 11 wherein each workload manager is<br>
associated with a servlet, and wherein the requests are directed to<br><br>
servlets operating on said server and reached by said workload managers.<br>
13.	The method of claim 11 wherein the workload managers are prioritized by allocating a portion of available thread time for their use.<br>
14.	The method of claim 13 wherein the portion of available thread time is specified as a relative share value of allowed thread time for one workload manager compared to another.<br>
15.	The method of claim 11 wherein the workload managers can be manually prioritized by a system administrator.<br>
16.	The method of claim 15 wherein the system includes a console application for use by said system administrator in prioritizing said workload managers.<br>
17.	The method of claim 11 wherein the requests thus prioritized according to destination workload manager are placed in a queue according to their priority.<br>
18.	The method of claim 17 wherein requests that are not placed in the queue are rejected.<br>
19.	The method of claim 11 wherein the request can be rejected with a custom message sent back to the client.<br>
20.	The method of claim 11 wherein the system receives state information about the current state of the server which it uses to determine a possible overload condition.<br><br>
21. A computer readable medium including instructions stored thereon which when executed cause the computer to perform the steps of:<br>
receiving at a server requests from clients, said server having a plurality of workload managers operating thereon;<br>
determining the priority of requests being received as determined by the priority of the workload manager the request is directed to; and<br>
rejecting certain of said requests when the server state indicates a possible overload condition.<br>
Dated this 6 day of June 2006 <br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1DSEVOUC0yMDA2ICBDTEFJTVMgR1JBTlRFRC5wZGY=" target="_blank" style="word-wrap:break-word;">1999-CHENP-2006  CLAIMS GRANTED.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1DSEVOUC0yMDA2ICBDT1JSRVNQT05ERU5DRSBPVEhFUlMucGRm" target="_blank" style="word-wrap:break-word;">1999-CHENP-2006  CORRESPONDENCE OTHERS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1DSEVOUC0yMDA2ICBDT1JSRVNQT05ERU5DRSBQTy5wZGY=" target="_blank" style="word-wrap:break-word;">1999-CHENP-2006  CORRESPONDENCE PO.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1DSEVOUC0yMDA2ICBGT1JNLTIucGRm" target="_blank" style="word-wrap:break-word;">1999-CHENP-2006  FORM-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1jaGVucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1999-chenp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1jaGVucC0yMDA2LWFzc2lnbmVtZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">1999-chenp-2006-assignement.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1jaGVucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1999-chenp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1jaGVucC0yMDA2LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">1999-chenp-2006-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1jaGVucC0yMDA2LWRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">1999-chenp-2006-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1jaGVucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1999-chenp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1jaGVucC0yMDA2LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">1999-chenp-2006-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1jaGVucC0yMDA2LWZvcm0gMTgucGRm" target="_blank" style="word-wrap:break-word;">1999-chenp-2006-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1jaGVucC0yMDA2LWZvcm0gMjYucGRm" target="_blank" style="word-wrap:break-word;">1999-chenp-2006-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1jaGVucC0yMDA2LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">1999-chenp-2006-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1jaGVucC0yMDA2LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">1999-chenp-2006-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTk5OS1jaGVucC0yMDA2LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">1999-chenp-2006-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="232243-particulate-water-absorbent-resin-composition-and-its-production-process.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="232245-silver-alloy-reflective-films-for-optical-information-recording-media.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>232244</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1999/CHENP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>27-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>16-Mar-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>06-Jun-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>BEA SYSTEMS, INC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2315 North First Street, San Jose, California 95131,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>REVANARU, Naresh</td>
											<td>2000 Walnut Avenue, #H-106, Fremont, California 94538,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>LANGEN, Anno, R</td>
											<td>973 Indian Rock, Berkeley, CA 94707,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F7/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2005/017861</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-05-20</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/573,307</td>
									<td>2004-05-21</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>11/132,782</td>
									<td>2005-05-19</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/232244-a-system-for-providing-an-application-server-with-overload-protection by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:03:06 GMT -->
</html>
