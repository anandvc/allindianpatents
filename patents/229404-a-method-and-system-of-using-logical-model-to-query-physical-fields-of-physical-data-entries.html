<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/229404-a-method-and-system-of-using-logical-model-to-query-physical-fields-of-physical-data-entries by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:05:38 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 229404:A METHOD AND SYSTEM OF USING LOGICAL MODEL TO QUERY PHYSICAL FIELDS OF PHYSICAL DATA ENTRIES</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD AND SYSTEM OF USING LOGICAL MODEL TO QUERY PHYSICAL FIELDS OF PHYSICAL DATA ENTRIES</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The present invention is generally directed to a system, method and article of manufacture for accessing data represented abstractly through an abstraction model (512). In one embodiment, a data abstraction model (512) provides a logical view of an underlying data repository (518) that is independent of the particular manner of data representation. For a given abstract query (506) the abstract query (506) is augmented with additional computer-selected result fields (520). In addition, the data abstraction model (512) is also augmented with fields (528) corresponding to the result fields (514) of the previously executed abstract query.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
ITERATIVE DATA ANALYSIS PROCESS VIA QUERY RESULT AUGMENTATION AND RESULT DATA FEEDBACK<br>
CROSS-RELATED APPLICATIONS<br>
One approach for accessing a multiplicity of data sources is described in more detail in United States Patent Application No. 10/131,984, entitled "REMOTE DATA ACCESS AND INTEGRATION OF DISTRIBUTED DATA SOURCES THROUGH DATA SCHEMA AND QUERY ABSTRACTION" and assigned to International Business Machines, Inc.<br>
BACKGROUND OF THE INVENTION Field of the Invention<br>
The present invention generally relates to data processing, and more particularly, to the accessing data through a logical framework.<br>
Description of the Related Art<br>
Databases are computerized information storage and retrieval systems. The most prevalent type of database is the relational database, a tabular database in which data is defined so that it can be reorganized and accessed in a number of different ways. A relational database management system (DBMS) is a database management system that uses relational techniques for storing and retrieving data.<br>
Regardless of the particular architecture, in a DBMS, a requesting entity (e.g., an application, the operating system or a user) demands access to a specified database by issuing a database access request. Such requests may include, for instance, simple catalog lookup requests or transactions and combinations of transactions that operate to read, change and add specified records in the database. These requests are made using high-level query languages such as the Structured Query Language (SQL). Illustratively, SQL is used to make interactive queries for getting information from and updating a database such as International Business Machines' (IBM) DB2, Microsoft's SQL Server, and database products from Oracle, Sybase, and Computer Associates. The term "query" denominates a set of<br><br>
commands for retrieving data from a stored database. Queries take the form of a command language that lets programmers and programs select, insert, update, find out the location of data, and so forth.<br>
In many cases, particularly in research-oriented environments, the task of analyzing information is typically a multi-step, iterative process involving generation of an initial set of query results, analysis of initial set of query results, and comparison of the initial set of query results with other available information to yield another set of data results. For example, in a medical research environment, a first query could be posed to find a set of research candidates meeting a particular diagnosis or test result profile. In a large data warehouse environment, it may take a lot of time and resources to process a query of this nature, in particular if the criteria specified is complex. Once the query results are returned, it may be desirable to run a second query correlating the results of the first query with other information in the full data repository to find, e.g., all individuals living at the same address or within the same town as those individuals found to meet the particular diagnosis or test result profile specified in the first query. Accordingly, information returned by the first query is correlated with other information in the data repository to yield additional information and knowledge discovery.<br>
Unfortunately, current methods to address this scenario are typically rather manual and error prone. Specifically, the user is required to go through several steps to save the results from the original query in a form that would allow for subsequent queries to be performed against it. In a relational environment, this would require a table to be created to hold the results of the original query. Similariy, in an XML-based repository, query result data would need to be stored in the repository in order to be re-queried. In either case, the user would then need to understand the physical schema used to represent the initial query results and express a subsequent query taking this schema into account. Also, in order to correlate initial query results with other information in the data repository, the user must be aware of key relationships between the query result set and other entities in the data repository and must include this key relationships in the original query and corresponding result set to enable correlation with the rest of the data repository.<br><br>
Therefore, what is needed is a query framework providing flexibility in data analysis.<br>
SUMMARY OF THE INVENTION<br>
The present invention provides a method, system and article of manufacture for accessing physical data through an abstraction model. The abstraction model includes metadata describing and defining a plurality of logical fields.<br>
One embodiment provides a method of using a logical model to query physical fields of physical data entities. The method includes defining the logical model to logically describe the physical fields; and for each abstract query comprising query conditions and query result fields to be returned, augmenting the logical model to logically describe, in addition to the physical fields, results returned for each abstract query based on the query result fields.<br>
Another embodiment provides a method of using a logical model to query data, and includes defining the logical model to logically describe the data, wherein the logical model comprises a plurality of logical field definitions mapping to physical fields of physical entities of the data; receiving a user-defined abstract query, wherein the user-defined abstract query is created using the logical field definitions of the logical model and includes at least one condition and at least one user-selected result field selected from the logical field definitions; augmenting the user-defined abstract query with at least one computer-selected result field to produce an augmented abstract query; and wherein the augmented abstract query returns results for each of the user-selected result field and the computer-selected result field; and augmenting the logical model to logically describe, in addition to the data, the results returned based on the result fields.<br>
Another embodiment provides a method for processing abstract queries defined by logical fields. The method includes providing an initial abstract data model defining a plurality of logical fields mapped to physical data having a particular schema and further defining a plurality of relationships between at least a<br><br>
portion of the plurality of logical fields; receiving a first abstract query comprising at least one condition and a user-selected result field comprising at least one of the plurality of logical fields; based on defined relationships between the user-selected result field and the other plurality of logical fields, augmenting the first abstract query with at least one computer-selected logical field selected from the plurality of logical fields; transforming the first abstract query into a first executable query with reference to the initial abstract data model; executing the first executable query; returning results produced by execution of the first executable query; and adding at least one additional logical field to the initial abstract data model to produce a first augmented abstract data model, the at least one additional logical field mapping to at least a portion of the results.<br>
Yet another embodiment provides a computer readable medium containing a program which, when executed, performs an operation with respect to abstract queries and a logical model comprising a plurality of logical field definitions mapping to physical fields of physical entities of the data. The operation includes, for each abstract query comprising query conditions and query result fields to be returned, augmenting the abstract query with at least one additional query result field, thereby producing an augmented abstract query; and for each executed augmented abstract query which returns results based on the query result fields of the executed augmented abstract query, augmenting the logical model to logically describe the results returned for the executed augmented abstract query.<br>
Still another embodiment provides a computer readable medium containing a program which, when executed, performs an operation with respect to abstract queries and a logical model comprising a plurality of logical field definitions mapping to physical fields of physical entities of the data. The operation includes receiving a user-defined abstract query, wherein the user-defined abstract query is created using the logical field definitions of the logical model and includes at least one condition and at least one user-selected result field selected from the logical field definitions; augmenting the user-defined abstract query with at least one computer-selected result field to produce an augmented abstract query; and wherein the augmented abstract query returns results for each of the user-selected result field<br><br>
and the computer-selected result field; and augmenting the logical model to logically describe, in addition to the data, the results retumed based on the result fields.<br>
Still another embodiment provides a computer system, comprising memory and at least one processor, and further comprising a logical model comprising a plurality of logical field definitions mapping to physical fields of physical entities of data, whereby the logical model provides a logical view of the data; an abstract query augmenter configured to (i) receive an abstract query comprising at least one condition and at least one user-selected result field selected from the logical field definitions of the logical model; and (ii) augment the abstract query with at least one computer-selected result field selected from the logical field definitions of the logical model, thereby producing an augmented abstract query; and a logical model generator configured to augment the logical model with additional logical field definitions based on (i) the result fields of the augmented abstract query; and (ii) results returned for the augmented abstract query.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
So that the manner in which the above recited features, advantages and objects of the present invention are attained and can be understood in detail, a more particular description of the invention, briefly summarized above, may be had by reference to the embodiments thereof which are illustrated in the appended drawings.<br>
It is to be noted, however, that the appended drawings illustrate only typical embodiments of this invention and are therefore not to be considered limiting of its scope, for the invention may admit to other equally effective embodiments.<br>
FIGURE 1 is a block diagram of an illustrative computer architecture.<br>
FIGURE 2 is a relational view of software components of one embodiment of the invention configured to process queries against a physical data source through an abstract representation of the physical data source.<br><br>
FIGURE 3 is a flow chart illustrating the operation of a runtime component.<br>
FIGURE 4 is a flow chart illustrating the operation of a runtime component.<br>
FIGURE 5 is a block diagram showing a query augmenter configured to add result fields to an abstract query and a data repository abstraction generator configured to generate abstract data models mapping logical fields to results of an augmented query.<br>
FIGURE 6 is a block diagram illustrating the augmentation of an abstract query based on defined relationships between user-specified result fields and other logical fields.<br>
FIGURE 7 is a block diagram illustrating the generation of an abstract data model based on results of an augmented abstract query.<br>
FIGURE 8 it is a flow chart illustrating an algorithm to augment an abstract query.<br>
FIGURE 9 it is a flow chart illustrating an algorithm to augment an abstract data model based on augmented query.<br>
FIGURES 10-12 are screens of a user interface configured for constructing abstract queries based on displayed logical fields, each of which is defined by an abstract data model.<br>
DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS<br>
INTRODUCTION<br>
One embodiment of the invention is implemented as a program product for use with a computer system and described below. The program(s) of the program product defines functions of the embodiments (including the methods described herein) and can be contained on a variety of signal-bearing media. Illustrative<br><br>
signal-bearing media include, but are not limited to: (i) information permanently stored on non-writable storage media (e.g., read-only memory devices within a computer such as CD-ROM disks readable by a CD-ROM drive); (ii) alterable information stored on writable storage media (e.g., floppy disks within a diskette drive or hard-disk drive); or (iii) information conveyed to a computer by a communications medium, such as through a computer or telephone network, including wireless communications. The latter embodiment specifically includes information downloaded from the internet and other networks. Such signal-bearing media, when carrying computer-readable instructions that direct the functions of the present invention, represent embodiments of the present invention.<br>
In general, the routines executed to implement the embodiments of the invention, may be part of an operating system or a specific application, component, program, module, object, or sequence of instructions. The software of the present invention typically is comprised of a multitude of instructions that will be translated by the native computer into a machine-readable format and hence executable instructions. Also, programs are comprised of variables and data structures that either reside locally to the program or are found in memory or on storage devices. In addition, various programs described hereinafter may be identified based upon the application for which they are implemented in a specific embodiment of the invention. However, it should be appreciated that any particular nomenclature that follows is used merely for convenience, and thus the invention should not be limited to use solely in any specific application identified and/or implied by such nomenclature.<br>
In one embodiment, a particular data definition framework, also referred to herein as a data abstraction model (DAM), is provided for accessing (e.g., querying and modifying) data independent of the particular manner in which the data is physically represented. The DAM includes metadata describing and defining a plurality of logical fields which map to physical data. A user-specified query is augmented to include additional return fields needed, for example, to correlate query results with other physical data. In addition, the DAM is augmented to include additional logical fields which map to the fields of the results of the query. The DAM<br><br>
may also be augmented to reflect relationships between the results and other data of the complete database. A subsequent query is then executed based on the augmented DAM.<br>
PHYSICAL VIEW OF ENVIRONMENT<br>
FIG. 1 depicts a block diagram of a networked system 100 in which embodiments of the present invention may be implemented. In general, the networked system 100 includes a client (i.e., generally any requesting entity such as a user or application) computer 102 (three such client computers 102 are shown) and at least one server computer 104 (one such server computer 104 is shown). The client computer 102 and the server computer 104 are connected via a network 126. In general, the network 126 may be a local area network (LAN) and/or a wide area network (WAN). In a particular embodiment, the network 126 is the Internet. However, it is noted that aspects of the invention need not be implemented in a distributed environment. As such, the client computers 102 and the server computer 104 are more generally representative of any requesting entity (such as a user or application) issuing queries and a receiving entity configured to handle the queries, respectively.<br>
The client computer 102 includes a Central Processing Unit (CPU) 110 connected via a bus 130 to a memory 112, storage 114, an input device 116, an output device 119, and a network interface device 118. The input device 116 can be any device to give input to the client computer 102. For example, a keyboard, keypad, light-pen, touch-screen, track-ball, or speech recognition unit, audio/video player, and the like could be used. The output device 119 can be any device to give output to the user, e.g., any conventional display screen. Although shown separately from the input device 116, the output device 119 and input device 116 could be combined. For example, a display screen with an integrated touch-screen, a display with an integrated keyboard, or a speech recognition unit combined with a text speech converter could be used.<br><br>
The network interface device 118 may be any entry/exit device configured to allow network communications between the client computer 102 and the server computer 104 via the network 126. For example, the network interface device 118 may be a network adapter or other network interface card (NIC).<br>
Storage 114 is preferably a Direct Access Storage Device (DASD). Although it is shown as a single unit, it could be a combination of fixed and/or removable storage devices, such as fixed disc drives, floppy disc drives, tape drives, removable memory cards, or optical storage. The memory 112 and storage 114 could be part of one virtual address space spanning multiple primary and secondary storage devices.<br>
The memory 112 is preferably a random access memory sufficiently large to hold the necessary programming and data structures of the invention. While the memory 112 is shown as a single entity, it should be understood that the memory 112 may in fact comprise a plurality of modules, and that the memory 112 may exist at multiple levels, from high speed registers and caches to lower speed but larger DAMM chips.<br>
Illustratively, the memory 112 contains an operating system 124. Illustrative operating systems, which may be used to advantage, include Linux and Microsoft's Windows®. More generally, any operating system supporting the functions disclosed herein may be used.<br>
The memory 112 is also shown containing a browser program 122 that, when executed on CPU 110, provides support for navigating between the various servers 104 and locating network addresses at one or more of the servers 104. In one embodiment, the browser program 122 includes a web-based Graphical User Interface (GUI), which allows the user to display Hyper Text Markup Language (HTML) information. More generally, however, the browser program 122 may be any GUI-based program capable of rendering the information transmitted from the server computer 104.<br><br>
The server computer 104 may be physically arranged in a manner similar to the client computer 102. Accordingly, the server computer 104 is shown generally comprising a CPU 130, a memory 132, and a storage device 134, coupled to one another by a bus 136. Memory 132 may be a random access memory sufficiently large to hold the necessary programming and data structures that are located on the server computer 104.<br>
The server computer 104 is generally under the control of an operating system 138 shown residing in memory 132. Examples of the operating system 138 include IBM OS/400®, UNIX, Microsoft Windows®, and the like. More generally, any operating system capable of supporting the functions described herein may be used.<br>
The memory 132 further includes one or more applications 140 and an abstract query interface 146. The applications 140 and the abstract query interface 146 are software products comprising a plurality of instructions that are resident at various times in various memory and storage devices in the computer system 100. When read and executed by one or more processors 130 in the server 104, the applications 140 and the abstract query interface 146 cause the computer system 100 to perform the steps necessary to execute steps or elements embodying the various aspects of the invention. The applications 140 (and more generally, any requesting entity, including the operating system 138 and, at the highest level, users) issue queries against a database. Illustrative sources against which queries may be issued include local databases 156I...156N, and remote databases 157I...157N, collectively referred to as database(s) 156--157). Illustratively, the databases 156 are shown as part of a database management system (DBMS) 154 in storage 134. More generally, as used herein, the term "databases" refers to any collection of data regardless of the particular physical representation. By way of illustration, the databases 156-157 may be organized according to a relational schema (accessible by SQL queries) or according to an XML schema (accessible by XML queries). However, the invention is not limited to a particular schema and contemplates extension to schemas presently unknown. As used herein, the term "schema" generically refers to a particular arrangement of data which is described<br><br>
by a data repository abstraction 148.<br>
In one embodiment, the queries issued by the applications 140 are defined according to an application query specification 142 included with each application 140. The queries issued by the applications 140 may be predefined (i.e., hard coded as part of the applications 140) or may be generated in response to input (e.g., user input). In either case, the queries (referred to herein as "abstract queries") are composed using logical fields defined by the abstract query interface 146. In particular, the logical fields used in the abstract queries are defined by the data abstraction model (DAM) 148 of the abstract query interface 146. The abstract queries are processed by a runtime component 150 which transforms the abstract queries into a form (referred to herein as a concrete query) consistent with the physical representation of the data contained in one or more of the databases 156-157. In particular, this processing is performed by a physical query builder 161 of the runtime component 150. The runtime component 150 also includes an analysis tool 162, so-called because it enables a data analysis feature described herein. Illustratively, the analysis tool 162 includes a DAM generator 164, a query augmenter 166 and a table builder 168. It is noted that the functions of the runtime component 150 are merely illustrative. Persons skilled in the art will recognize that these functions may be implemented elsewhere (e.g., in the database management system 154 itself). Each of the components/functions of the abstract query interface 146 is further described below.<br>
The abstract queries processed by the runtime component 150 may be configured to access the data and return results, or to modify (i.e., insert, delete or update) the data. In one embodiment, elements of a query are specified by a user through a graphical user interface (GUI). The content of the GUIs is generated by the application(s) 140. In a particular embodiment, the GUI content is hypertext markup language (HTML) content which may be rendered on the client computer systems 102 with the browser program 122. Accordingly, the memory 132 includes a Hypertext Transfer Protocol (http) server process 138 (e.g., a web server) adapted to service requests from the client computer 102. For example, the process 138 may respond to requests to access a database(s) 156, which illustratively resides on<br><br>
the server 104. Incoming client requests for data from a database 156-157 invoke an application 140. When executed by the processor 130, the application 140 causes the server computer 104 to perform the steps or elements embodying the various aspects of the invention, including accessing the database(s) 156-157. In one embodiment, the application 140 comprises a plurality of servlets configured to build GUI elements, which are then rendered by the browser program 122. Where the remote databases 157 are accessed via the application 140, the data abstraction model 148 is configured with a location specification identifying the database containing the data to be retrieved. This latter embodiment will be described in more detail below.<br>
FIG. 1 is merely one hardware/software configuration for the networked client computer 102 and server computer 104. Embodiments of the present invention can apply to any comparable hardware configuration, regardless of whether the computer systems are complicated, multi-user computing apparatus, single-user workstations, or network appliances that do not have non-volatile storage of their own. Further, it is understood that while reference is made to particular markup languages, including HTML, the invention is not limited to a particular language, standard or version. Accordingly, persons skilled in the art will recognize that the invention is adaptable to other markup languages as well as non-markup languages and that the invention is also adaptable future changes in a particular markup language as well as to other languages presently unknown. Likewise, the http server process 138 shown in FIG. 1 is merely illustrative and other embodiments adapted to support any known and unknown protocols are contemplated.<br>
LOGICAL/RUNTIME VIEW OF ENVIRONMENT<br>
FIGS. 2A-B show a plurality of interrelated components of the invention. The requesting entity (e.g., one of the applications 140) issues a query 202 as defined by the respective application query specification 142 of the requesting entity. The resulting query 202 is generally referred to herein as an "abstract query" because the query is composed according to abstract (i.e., logical) fields rather than by direct reference to the underlying physical data entities in the databases 156-157. As a<br><br>
result, abstract queries may be defined that are independent of the particular underlying data representation used. In one embodiment, the application query specification 142 may include both criteria used for data selection (selection criteria 204) and an explicit specification of the fields to be returned (return data specification 206) based on the selection criteria 204.<br>
The logical fields specified by the application query specification 142 and used to compose the abstract query 202 are defined by the data abstraction model 148. In general, the data abstraction model 148 exposes information as a set of logical fields that may be used within a query (e.g., the abstract query 202) issued by the application 140 to specify criteria for data selection and specify the form of result data returned from a query operation. The logical fields are defined independently of the underlying data representation being used in the databases 156-157, thereby allowing queries to be formed that are loosely coupled to the underlying data representation. The data to which logical fields of the DAM 148 are mapped may be located in a single repository (i.e., source) of data or a plurality of different data repositories. Thus, the DAM 148 may provide a logical view of one or more underlying data repositories. By using an abstract representation of a data repository, the underlying physical representation can be more easily changed or replaced without affecting the application making the changes. Instead, the abstract representation is changed with no changes required by the application. In addition, multiple abstract data representations can be defined to support different applications against the same underlying database schema that may have different default values or required fields.<br>
In general, the data abstraction model 148 comprises a plurality of field specifications 2081, 2O82, 2O83, 2O84 and 2O85 (five shown by way of example), collectively referred to as the field specifications 208. Specifically, a field specificafion is provided for each logical field available for composition of an abstract query. Each field specification comprises a logical field name 210i, 2102, 2IO3, 2104, 2105 (collectively, field name 210) and an associated access method 212i, 2122, 2123, 2124, 2125 (collectively, access method 212). The access methods associate (i.e., map) the logical field names to a particular physical data<br><br>
representation 214i, 2142...214N in a database (e.g.. one of the databases 156) according to parameters referred to herein as physical location parameters. By way of illustration, two data representations are shown, an XML data representation 214i and a relational data representation 2142. However, the physical data representation 21 4N indicates that any other data representation, known or unknown, is contemplated.<br>
Any number of access methods are contemplated depending upon the number of different types of logical fields to be supported. In one embodiment, access methods for simple fields, filtered fields and composed fields are provided. The field specifications 2081, 2O82 and 2O85 exemplify simple field access methods 2121, 2122, and 2125, respectively. Simple fields are mapped directly to a particular entity in the underlying physical data representation (e.g., a field mapped to a given database table and column). By way of illustration, the simple field access method 212i shown in FIG. 2B maps the logical field name 2101 ("FirstName") to a column named "f_name" in a table named "contact", where the table name and the column name are the physical location parameters of the access method 2121. The field specification 2O83 exemplifies a filtered field access method 2123. Filtered fields identify an associated physical entity and provide rules used to define a particular subset of items within the physical data representation. An example is provided in FIG. 2B in which the filtered field access method 2123 maps the logical field name 2103 ("AnytownLastName") to a physical entity in a column named "i_name" in a table named "contact" and defines a filter for individuals in the city of Anytown. Another example of a filtered field is a New York ZIP code field that maps to the physical representation of ZIP codes and restricts the data only to those ZIP codes defined for the state of New York. The field specification 2O84 exemplifies a composed field access method 2124. Composed access methods compute a logical field from one or more physical fields using an expression supplied as part of the access method definition. In this way, information which does not exist in the underlying data representation may computed. In the example illustrated in FIG. 2B the composed field access method 2123 maps the logical field name 2103 "AgelnDecades" to "AgelnYears/10". Another example is a sales tax field that is<br><br>
composed by multiplying a sales price field by a sales tax rate.<br>
It is noted that the data abstraction mode! 148 shown in FIG. 2B is merely illustrative of selected logical field specifications and is not intended to be comprehensive. As such, the abstract query 202 shown in FIG. 2B includes some logical fields for which specifications are not shown in the data abstraction model 148, such as "State" and "Street".<br>
It is contemplated that the formats for any given data type (e.g., dates, decimal numbers, etc.) of the underlying data may vary. Accordingly, in one embodiment, the field specifications 208 include a type attribute which reflects the format of the underlying data. However, in another embodiment, the data fomriat of the field specifications 208 is different from the associated underlying physical data, in which case an access method is responsible for returning data in the proper format assumed by the requesting entity. Thus, the access method must know what format of data is assumed (i.e., according to the logical field) as well as the actual format of the underlying physical data. The access method can then convert the underlying physical data into the format of the logical field.<br>
By way of example, the field specifications 208 of the data abstraction model 148 shown in FIG. 2A are representative of logical fields mapped to data represented in the relational data representation 2142. However, other instances of the data abstraction model 148 map logical fields to other physical data representations, such as XML. Further, in one embodiment, a data abstraction model 148 is configured with access methods for procedural data representations.<br>
An illustrative abstract query corresponding to the abstract query 202 shown in FIG. 2 is shown in Table I below. By way of illustration, the data repository abstraction 148 is defined using XML. However, any other language may be used to advantage.<br><br>
TABLE I - QUERY EXAMPLE<br>
1	<?xml version="1.0"?><br>
2	
3	"McGoon") OR State = "NC"-&gt;<br>
4	<queryabstraction><br>
005	<selection><br>
006	<condition intemalld="4"><br>
007	<condition fielcl="FirstName" operator="EQ" value="Mary"></condition>
008	internallD="r7&gt;<br>
009	<condition field="LastName" operator="EQ" value="McGoon"></condition>
010	internallD="3" relOperator="AND"&gt;</condition><br>
Oil	<br>
012	<condition field="State" operator="EQ" value="NC" intemalld="2"></condition>
013	relOperator="OR"&gt;<br>
14	</selection><br>
15	<results><br><br>
16	<field name="FirstName"></field><br>
17	<field name="LastName"></field><br>
18	<field name="State"></field><br>
019	</results><br>
020	</queryabstraction><br>
Illustratively, the abstract query shown in Table I includes a selection specification (lines 005-014) containing selection criteria and a results specification (lines 015-019). In one embodiment, a selection criterion consists of a field name (for a logical field), a comparison operator (=, &gt;, 
An illustrative instance of a data abstraction model 148 corresponding to the abstract query in Table I is shown in Table II below. By way of illustration, the data abstraction model 148 is defined using XML. However, any other language may be used to advantage.<br><br>
TABLE II - DATA ABSTRACTION MODEL EXAMPLE<br>
1	<?xml version="1.0"?><br>
2	<datarepository><br>
003	<category name="Demographic"><br>
004	<field queryable="Yes" name="FirstName" displayable="Yes"><br>
005	<accessmethod><br>
006	<simple columnname="f_name"></simple>
tableName="contact"&gt;<br>
7	</accessmethod><br>
8	<type basetype="char'&gt;&lt;/Type&gt;&lt;br/&gt;
&lt;br/&gt;
9	&lt;/Field&gt;&lt;br/&gt;
10	&lt;Field queryable=" yes name="LastName" displayable='Yes"'><br>
011	<accessmethod><br>
012	<simple columnname="1_name"></simple>
tableName="contact"&gt;<br>
13	</accessmethod><br>
14	<type basetype="char'&gt;&lt;/Type&gt;&lt;br/&gt;
&lt;br/&gt;
15	&lt;/Field&gt;&lt;br/&gt;
16	&lt;Field queryable=" yes name="State" displayable="Yes"><br>
017	<accessmethod><br>
018	<sinriple columnname="state"></sinriple>
tableName="contact"&gt;<br>
19	</accessmethod><br>
20	<type basetype="char"></type><br>
021	</type></type></field><br>
22	</category><br>
23	</datarepository><br>
Note that lines 004-009 correspond to the first field specification 208i of the DAM 148 shown in FIG. 2B and lines 010-015 correspond to the second field specification 2O82. For brevity, the other field specifications defined in Table I have not been shown in FIG. 2B. Note also that Table I illustrates a category, in this case "Demographic". A category is a grouping of one or more logical fields. In the present example, "First Name", "Last Name" and "State" are logical fields belonging to the common category, "Demographic".<br>
In any case, a data abstraction model 148 contains (or refers to) at least one access method that maps a logical field to physical data. However, the foregoing embodiments are merely illustrative and the logical field specifications may include a variety of other metadata. In one embodiment, the access methods are further configured with a location specification defining a location of the data associated<br><br>
with the logical field. In this way, the data abstraction model 148 is extended to include description of a multiplicity of data sources that can be local and/or distributed across a network environment. The data sources can be using a multitude of different data representations and data access techniques. In this manner, an infrastructure is provided which is capable of capitalizing on the distributed environments prevalent today. One approach for accessing a multiplicity of data sources is described in more detail in United States Patent Application No. 10/131,984, entitled "REMOTE DATA ACCESS AND INTEGRATION OF DISTRIBUTED DATA SOURCES THROUGH DATA SCHEMA AND QUERY ABSTRACTION" and assigned to International Business Machines, Inc.<br>
FIG. 3 shows an illustrative runtime method 300 exemplifying one embodiment of the operation of the runtime component 150. The method 300 is entered at step 302 when the runtime component 150 receives as input an instance of an abstract query (such as the abstract query 202 shown in FIG. 2). At step 304, the runtime component 150 reads and parses the instance of the abstract query and locates individual selection criteria and desired result fields. At step 306, the runtime component 150 enters a loop (comprising steps 306, 308, 310 and 312) for processing each query selection criteria statement present in the abstract query, thereby building a data selection portion of a Concrete Query. In one embodiment, a selection criterion consists of a field name (for a logical field), a comparison operator (=, &gt;, 
 <br>
the concrete query is used to locate and retrieve data from a physical data repository, represented by the databases 156-157 shown in FIG. 1. The Concrete Query Contribution generated for the cun-ent field is then added to a Concrete Query Statement. The method 300 then returns to step 306 to begin processing for the next field of the abstract query. Accordingly, the process entered at step 306 is iterated for each data selection field in the abstract query, thereby contributing additional content to the eventual query to be performed.<br>
After building the data selection portion of the concrete query, the runtime component 150 identifies the information to be returned as a result of query execution. As described above, in one embodiment, the abstract query defines a list of abstract fields that are to be returned as a result of query execution, referred to herein as a result specification. A result specification in the abstract query may consist of a field name and sort criteria. Accordingly, the method 300 enters a loop at step 314 (defined by steps 314, 316. 318 and 320) to add result field definitions to the concrete query being generated. At step 316, the runtime component 150 looks up a result field name (from the result specification of the abstract query) in the data repository abstraction 148 and then retrieves a Result Field Definition from the data repository abstraction 148 to identify the physical location of data to be returned for the current logical result field. The runtime component 150 then builds (as step 318) a Concrete Query Contribution (of the concrete query that identifies physical location of data to be returned) for the logical result field. At step 320, Concrete Query Contribution is then added to the Concrete Query Statement. Once each of the result specifications in the abstract query has been processed, the query is executed at step 322.<br>
One embodiment of a method 400 for building a Concrete Query Contribution for a logical field according to steps 310 and 318 is described with reference to FIG. 4. At step 402, the method 400 queries whether the access method associated with the current logical field is a simple access method. If so, the Concrete Query Contribution is built (step 404) based on physical data location information and processing then continues according to method 300 described above. Otherwise, processing continues to step 406 to query whether the access method associated<br><br>
with the current logical field is a filtered access method. If so, the Concrete Query Contribution is built (step 408) based on physical data location information for some physical data entity. At step 410, the Concrete Query Contribution is extended with additional logic (filter selection) used to subset data associated with the physical data entity. Processing then continues according to method 300 described above.<br>
If the access method is not a filtered access method, processing proceeds from step 406 to step 412 where the method 400 queries whether the access method is a composed access method. If the access method is a composed access method, the physical data location for each sub-field reference in the composed field expression is located and retrieved at step 414. At step 416, the physical field location information of the composed field expression is substituted for the logical field references of the composed field expression, whereby the Concrete Query Contribution is generated. Processing then continues according to method 300 described above.<br>
If the access method is not a composed access method, processing proceeds from step 412 to step 418. Step 418 is representative of any other access methods types contemplated as embodiments of the present invention. However, it should be understood that embodiments are contemplated in which less then all the available access methods are implemented. For example, in a particular embodiment only simple access methods are used. In another embodiment, only simple access methods and filtered access methods are used.<br>
As described above, it may be necessary to perform a data conversion if a logical field specifies a data format different from the underlying physical data. In one embodiment, an initial conversion is performed for each respective access method when building a Concrete Query Contribution for a logical field according to the method 400. For example, the conversion may be performed as part of, or immediately following, the steps 404, 408 and 416. A subsequent conversion from the format of the physical data to the format of the logical field is performed after the query is executed at step 322. Of course, if the format of the logical field definition is the same as the underlying physical data, no conversion is necessary.<br><br>
DATA ANALYSIS<br>
In one embodiment, a user invokes the tool 162 to perform iterative data analysis. Illustratively the tool 162 performs various functions including augmenting the original user-defined abstract query (a function performed by the query augmenter 166), extending the underiying data repository 156 with query results of the executed augmented query (a function perfomned by the table builder 168) and extending the data abstraction model 148 with additional metadata to account for the physical data added to the underiying data repository (i.e., the query results of the executed augmented query).<br>
Query augmentation is a function performed by the query augmenter 166. Since a user invokes the tool 162 when they intend to perform additional queries to correlate initial query results with other information in a data repository, the specified set of logical return fields (i.e., the set of logical fields in the abstract query to be returned) is extended to include fields (e.g., key fields) that may be used to correlate with other data entities in the data repository being queried.<br>
Extending the data abstraction model 148 is a function of the DAM generator 164. A data abstraction model is augmented for each iterative query based on the results of the executed augmented query. That is, the DAM is augmented to include a logical field for each physical field (e.g., column in a relational database) in the result set of the executed query. A subsequent query is then executed based on the augmented DAM. This may be an iterative process, so that each query execution results in another update to the DAM. In addition, the DAM may be augmented with relationship metadata specifying relationships between the results of the last executed query and the other available data of a database. In one embodiment, an augmented DAM persists in memory only for a user session. For example, an updated DAM may be discarded once a user logs off of the system. Alternatively, an augmented DAM may be stored and retrieved for later use.<br>
Extending the underiying data repository with the results of an augmented query is a function of the table builder 168. As noted above, the invention may be<br><br>
used to advantage with any data schema. Accordingly, it is emphasized that the term "table builder" is merely illustrative of one embodiment and does not limit the scope of the invention to data organized as tables.<br>
Referring now to FIGURE 5, a first DAM 512 (DAM_1) is shown in a pre-execution environment 502. The DAM 512 includes a plurality of logical fields 514 (shown as "original logical fields") that map to data in a database 506, and a relationship specification 516 (shown as "original relationship specification"). An abstract query 506 issued by a requesting entity (e.g., a user or application) against a database 518 is configured with conditions 508 and return criteria 510. The conditions 508 generally include one or more logical fields defined in the first DAM 512 and a related value for each field. An illustrative condition may be "State = Ohio". Multiple conditions may be connected by Boolean operators such as AND and OR. As an example consider the following: (Gender = 'Female' AND State = *Ohio'). The result criteria 510 includes one or more logical fields for which results are to be returned. In an SQL counterpart statement (after the abstract query 506 is transformed into a concrete query), the return criteria 510 are the SELECT clause and the conditions 508 are the WHERE clause of the statement.<br>
Prior to execution, the query augmenter 166 is invoked to add additional result fields 520 to the results criteria 510 of the query 506. In particular, the added result fields are those key fields required to correlate the data returned from the query 506 with additional data that exists in other, related entities within the database 518. Adding these key fields to the query 506 results in an augmented query 506'.<br>
When executed (represented by the arrow 522), the augmented query 506' returns a result set 524. The table builder 168 formats the result set 524 according to the schema of the database 518 and stores the resulting data structure 526 to the database, resulting in an updated database 518'. The DAM generator 164 creates new logical fields 528 which map to the physical fields of the data structure 526 (mapping between physical fields and the new logical fields 528 is identified by a dashed line, as distinguished from the solid line representing mapping between<br><br>
physical fields and the original logical fields 514). The DAM generator 164 also updates the original relationship specification 516 with new entity relationships 530, resulting in the augmented DAM 512' (DAM_1). This process may be performed for each successive abstract query.<br>
Referring now to FIGURE 6, additional details of the invention are described. Illustratively, FIGURE 6 shows an initial DAM 608. The DAM 608 includes a plurality of field specifications 610 each of which map to data in a data repository 618. In the present example, the data repository 618 is a relational database including a plurality of tables 620A-D (four shown). Accordingly, the field specifications 610 are defined by a logical field name 612, a table name 614 and a column name 616. As described above with respect to FIGURE 2B, the values of the table name 614 and column name 616 are the parameters passed to the access method of the respective logical field in order to retrieve data from the repository 618. Illustratively, the logical fields also include category metadata, whereby the logical fields 1-6 are part of Category 1 and logical fields 7-10 are part of Category 2.<br>
A first abstract query 602 is shown configured with a condition 604 and return criteria 606. The condition 604 and return criteria 606 of the abstract query 602 are each configured with one or more logical fields, each of which are represented in the DAM 608. By way of example, the condition 604 specifies a value of "5" for Field 4 and the return criteria 606 specifies that data is to be returned for Field 2 and Field 4 where the condition 604 is satisfied.<br>
The DAM 608 further includes a relationship specification 622. In general, the relationship specification 622 specifies relationships between logical fields which correspond to defined relationships between respective physical fields. Illustratively, the database 618 has a plurality of primary-foreign key relationships defined. Each foreign key is identified by an apostrophe (') and its relationship to a primary key is represented by an arrow connecting the respective columns. In one embodiment, the relationship specification 622 includes a "primary entity" column 624, a "primary entity field" column 626, a "secondary entity" column 628 and a "secondary entity field" column 630. The "primary entity" column 624 contains entries corresponding<br><br>
to tables of the database 618. The "primary entity field" column 626 contains entries corresponding to logical fields of the DAM 608. As such, the columns 624 and 626 identify a primary entity column of the database 618. The columns 628 and 630 of the relationship specification 622 identify a secondary entity column of the database 618 having a relationship with the primary entity column. For example, the first row in the relationship specification 622 identifies a relationship between the column AK of TABLE A and column AK' in TABLE B.   It is noted that, in an alternative embodiment, the relationships in the relationship specification 622 may be described using only the "primary entity field" column 626 and the "secondary entity field" column 630 (i.e., without reference to the "primary entity" column 624 and the "secondary entity" column 628.<br>
A user may then submit an abstract query 602 for execution with respect to the DAM 608. Prior to execution, the query augmenter 166 augments (represented by the arrow 632) the abstract query 602 to produce an augmented query 602\ In general, the augmentation process adds additional fields to the results criteria 606 to produce augmented results criteria 606'. The additional fields 634 added to the results criteria 606 of the abstract query 602 are selected according defined relationships (i.e., defined in the relationship specification 622) between physical fields of the corresponding tables associated with each of the user-specified logical fields in the results criteria 606. The query augmentation process will be described in more detail below with respect to FIGURE 8.<br>
Reference is now made to FIGURE 7 to describe the environment after execution of the augmented abstract query 602'. Following execution of the augmented abstract query 602' the database 618 is updated to include a table 702 (TABLE R) corresponding to results returned for the augmented abstract query 602'. The table 702 is created by the table builder 168 and is arranged to be consistent with the particular schema of the database 618 (in the present example, the database 618 is a relational database). The resulting database 618', therefore, includes all the original data of the original database 618 as well as the results of the augmented query 602'. It is noted that, in the present example, the first two columns (R1 and R2) of the result table 702 correspond to the columns A1 and B1 (as per the<br><br>
original result fields 606 of the pre-augmented query 602). The last three columns in the illustrative result table 702 are the columns corresponding to the additional fields of the augmented query 606' Each of the result columns may include only a subset of entries of their corresponding original columns, since only those results satisfying the condition 604 are returned. Accordingly, those columns corresponding to user-specified result fields are indicated by an "R", as in R1 and R2; and those columns corresponding to augmented result fields are indicated by a subscript, "sub", as in AKsub which corresponds to the original column AK, and CK sub and DKsub which correspond to the original columns CK' AND DK', respectively.<br>
Further, the DAM generator 162 generates an augmented DAM 608' based on the results returned for the augmented abstract query 602'. Specifically, the DAM generator 162 updates the original DAM 608 to include additional logical fields 704 mapping to each field (i.e., each column) of the generated table 702.<br>
In one aspect, the augmented DAM 608' also reflects relationships between columns of the generated table 702 and the original tables 620A-D of the original database 618. In the physical data, these relationships are represented by an-ows connecting selected columns of the table 702 with columns of the original tables 620A-D. In the augmented DAM 608', these relationships are represented by additional fields 706 of the updated entity relationship specification 622'.<br>
Referring now to FIGURE 8, a flowchart illustrates one embodiment of a method 800 implemented by the query augmenter 166 for creating an augmented query from an initial query 802. At step 804, an augmented query 806 is initialized with the conditions and result fields from the initial query 802. A loop is then entered (at step 808) for each initial query result field. For a given result field of the initial query 808, the DAM 812 is accessed to retrieve the corresponding physical entity information (step 814), which information is then stored to a physical entity list 816 (step 814).<br>
After populating the physical entity list 816 with a reference to the corresponding physical entity for each result field of the initial query 808, a loop is<br><br>
entered for each physical entity referenced in the physical entity list 816 (step 818). The loop includes, for a given physical entity, identifying all relations in the DAM 812 involving the given physical entity (step 820). That is, the entity relationship specification of the DAM 812 (e.g., the entity relationship specification 622 of FIGURE 6) is accessed to determine each relationship involving the given physical entity. The query augmenter 166 then determines, for each relationship (step 821), whether each identified related entity is already included in the physical entity list 816 (step 822). If not, the specified logical fields (i.e., the key fields) for the given physical entity are added to the augmented query 806 (step 824). If so, the primary entity fields (i.e., the primary key fields) associated with the primary entity of the given relationship (as specified in the entity relationship specification) are added to the augmented query 806. When each relationship for each physical entity in the physical entity list 816 has been processed in this manner the method 800 is complete.<br>
The foregoing method may be illustrated with reference to FIGURE 6. For the first of the two return fields of the initial query 602, i.e,, Field2, the corresponding physical entity is Table A (determined at step 810). Referencing the entity relationship specification 622, the query augmenter 166 determines that the first and second relationships of the specification 622 include Table A (step 820). The query augmenter 166 then determines whether the other physical entity of each relationship is already in the physical entity list 816 (step 822). In this illustration, the first relationship relates Table A and Table B and the second relationship relates Table C and Table A. Regarding the first relationship, Table B is already included in the physical entity list 816 as a result of the initial return field, Field4; therefore, the primary entity field (specified in the primary entity field column 626 of the relationship specification 622), Field 1, is added to the augmented query 602'. Regarding the second relationship, Table C is not included in the physical entity list 816. Therefore, the specified key field corresponding to Table A, i.e., Fields, is added to the augmented query 6021' The same processing is repeated for Table B, the physical entity corresponding to the initial return field, Field4, resulting in the addition of Field6 being added to the augmented query 602.<br><br>
Refemng now to FIGURE 9, a flowchart illustrates one embodiment of a method 800 implemented by the DAM generator 164 for creating an updated DAM. The method 900 is entered after executing the augmented abstract query 806 (as performed by the method 800 described with reference to FIGURE 8). At step 902, the DAM generator 164 initializes an augmented DAM 906 with an initial DAM 904 (step 902). At step 908, a new category is added to the augmented DAM 906 for the query results of the augmented query 806. A loop is then entered (at step 910) for each result field in the result criteria of the augmented abstract query 806. For a given result field, the processing perf'ormed in the loop includes retrieving (step 912), from the initial DAM 904, the field definition corresponding to the given result field. The field definition is then updated (step 914) so that the access method refers to the corresponding query result entity (e.g., the appropriate column of Table R shown in FIGURE 7). The updated field definition is then added to the augmented DAM 906 (step 916). The DAM generator 164 then determines (step 918) whether the given result field of the augmented query is involved in a relationship with another entity (e.g., "El") as defined in the entity specification of the initial DAM 904. If so, a relationship is created in the entity relationship specification of the augmented DAM 906 between the query result entity (i.e., the entity corresponding the given result field of the augmented query) and the other entity, E1 (step 920). Further, if the given result field of the augmented query is a primary key for yet another entity (e.g., "E2"), as determined at step 922, then a relationship is created in the entity relationship specification of the augmented DAM 906 between the query result entity and the other entity, E2 (step 924). The foregoing process is preformed for each result field of the augmented query.<br>
The method 900 may be illustrated with reference to FIGURE 6 and FIGURE 7. Consider, for example, the first of the user-specified query result fields, "Category 1/Field2". In this case, a new logical field "CategoryR/Fieldl 1" is added to the augmented the DAM 608'. The new logical field maps to Table R, Column R1. Since the corresponding query result field, "Category 1/Field2", is not related to any other entity in the initial DAM 608, no new relations are created. The same is true for the new logical field "CategoryR/Fieldl 2". Consider now the first of the added<br><br>
query result fields 634 in the augmented query 602', i.e., "Categoryl/Field 1". In this case, a new logical field "CategoryR/Field 13" is added to the augmented the DAM 608'. The new logical field maps to Table R, Column AKsub- Since "Category 1/Field 1 is involved in a relation with another entity as defined in the entity relationship specification 622 of the initial DAM 608, i.e., "Category 1/Field 1" is related to "Categoryl/Field5", a new relationship between the new logical field "CategoryR/Field13" and "Categoryl/FieldS" is defined in the augmented entity relationship specification 622', as represented by the second row of the additional logical fields 706 in FIGURE 7. In addition, since the abstract query result field, "Category 1/Field 1" is a primary key field, a new relationship between the new logical field "CategoryR/Field13" and "Category 1/Field 1" is defined in the augmented entity relationship specification 622', as represented by the first row of the additional logical fields 706 in FIGURE 7.<br>
In one aspect, an advantage is provided to users constructing queries against data repository abstraction models. Since the view of the underlying data is dictated by the DAM, the user is given an increasingly augmented view of the data with each successive query. The user may then create queries including data selection conditions that involve information in the initial DAM, information from prior query results (i.e., information from the augmented DAM) or both. This aspect of the invention may be illustrated with reference to FIGURES 10-12.<br>
Referring first to FIGURE 10, a screen 1000 is shown which may be viewed through the browser program 122 (FIGURE 1). The screen 1000 includes a Selection panel 1002, a Query Conditions panel 1004, a Query Results Fields panel 1006 and a Query Result Name field 1008. The Selection panel 1002 displays each of the logical fields defined by a DAM. If defined, categories are also displayed. Using the displayed logical fields, the user may construct a query by specifying conditions in the Query Conditions panel 1004 and specifying result fields in the Query Results Fields panel 1006, as illustrated by the screen 1000 FIGURE 11. In this particular illustration, user has specified query conditions for the logical fields Gender and State and the Query Results Fields panel 1006 includes six user-selected logical fields (result fields): Gender, State, Glucose Test, Test Date. First<br><br>
Name and Last Name. The user has selected Ohio Females (as shown in the Query Result Name field 1008) as the name under which to categorize the results of the query. The query augmenter 166 is then invoked (e.g., in response to the user clicking on an Augment Query button 1010), resulting in the addition of "Patient ID" as a result field in the Query Results Fields panel 1006. The query may then be executed by clicking the Submit the 1012. After execution of the query, the results of the query may be displayed to the user in another screen (not shown).<br>
For the next query, the Selection panel 1002 shows the logical fields of the augmented DAM generated by the DAM generator 164 based on the query results fields of the executed augmented query. For the illustrative query of FIGURE 11, the logical fields of the augmented DAM are shown under the user-specified category name (Ohio Females) in the Selection panel 1002 of FIGURE 12. Accordingly, the displayed logical fields include Gender, State, Glucose Test, Test Date, First Name, Last Name, Patient ID, Based on the displayed logical fields, the user may construct another query. This process may be performed iteratively whereby the number of displayed/available logical fields is successively increased.<br>
In various embodiments, numerous advantages may be provided. In some cases, these advantages may be substantial improvements over the prior art. Some of these advantages are now described. However, whether or not an embodiment achieves an advantage, and whether or not such an advantage may be considered a substantial improvement, is not limiting of the invention. Therefore, the advantages described below do not define or limit the invention, which is limited only by the claims that follow.<br>
In one aspect, advantages are achieved by defining a loose coupling between the application query specification and the underlying data representation. Rather than encoding an application with specific table, column and relationship information, as is the case where SQL is used, the application defines data query requirements in a more abstract fashion that are then bound to a particular physical data representation at runtime. The loose query-data coupling of the present invention enables requesting entities (e.g., applications) to function even if the<br><br>
underlying data representation is modified or if the requesting entity is to be used with a completely new physical data representation than that used when the requesting entity was developed. In the case with a given physical data representation is modified or restructured, the corresponding data repository abstraction is updated to reflect changes made to the underlying physical data model. The same set of logical fields are available for use by queries, and have merely been bound to different entities or locations in physical data model. As a result, requesting entities written to the abstract query interface continue to function unchanged, even though the coresponding physical data model has undergone significant change. In the event a requesting entity is to be used with a completely new physical data representation different than that used when the requesting entity was developed, the new physical data model may be implemented using the same technology (e.g., relational database) but following a different strategy for naming and organizing information (e.g., a different schema). The new schema will contain information that may be mapped to the set of logical fields required by the application using simple, filtered and composed field access method techniques. Alternatively, the new physical representation may use an alternate technology for representing similar information (e.g., use of an XML based data repository versus a relational database system). In either case, existing requesting entities written to use the abstract query interface can easily migrate to use the new physical data representation with the provision of an alternate data repository abstraction which maps fields referenced in the query with the location and physical representation in the new physical data model.<br>
in another aspect, the ease-of-use for the application builder and the end-user is facilitated. Use of an abstraction layer to represent logical fields in an underlying data repository enables an application developer to focus on key application data requirements without concern for the details of the underlying data representation. As a result, higher productivity and reduced error rates are achieved during application development. With regard to the end user, the data repository abstraction provides a data filtering mechanism, exposing pertinent data and hiding<br><br>
nonessential content that is not needed by a particular class end-user developing the given query.<br>
In one aspect, this model allows solutions to be developed independent of the physical location or representation of the data used by the solution, making it possible to easily deploy the solution to a number of different data topologies and allowing the solution to function in cases where data is relocated or reorganized over time. In another aspect, this approach also simplifies the task of extending a solution to take advantage of additional information. Extensions are made at the abstract query level and do not require addition of software that is unique for the location or representation of the new data being accessed. This method provides a common data access method for software applications that is independent of the particular method used to access data and of the location of each item of data that is referenced. The physical data accessed via an abstract query may be represented relationally (in an existing relational database system), hierarchically (as XML) or in some other physical data representation model. A multitude of data access methods are also supported, including those based on existing data query methods such as SQL and XQuery and methods involving programmatic access to information such as retrieval of data through a Web Service invocation (e.g., using SOAP) or HTTP request.<br>
While the foregoing is directed to embodiments of the present invention, other and further embodiments of the invention may be devised without departing from the basic scope thereof, and the scope thereof is determined by the claims that follow.<br><br><br><br>
WHAT IS CLAIMED IS:<br>
1.	A method of using a logical model to query physical fields of physical data<br>
entities, comprising:<br>
defining the logical model to logically describe the physical fields; and for each abstract query comprising query conditions and query result fields to be returned, augmenting the logical model to logically describe, in addition to the physical fields, results returned for each abstract query based on the query result fields<br>
2.	The method of claim 1, wherein the logical model comprises a plurality of logical<br>
field definitions mapping to physical fields of physical entities of the data, the method<br>
further comprising:<br>
receiving a user-defined abstract query, wherein the user-defined abstract query is created using the logical field definitions of the logical model and includes at least one condition and at least one user-selected result field selected from the logical field definitions, wherein the augmenting step comprises augmenting the user-defined abstract query with at least one computer-selected result field to produce an augmented abstract query; and wherein the augmented abstract query returns results for each of the user-selected result field and the computer-selected result field, and wherein the method further comprises augmenting the logical model to logically describe, in addition to the data, the results returned based on the result fields.<br>
3.	The method of claim 1, wherein a portion of the query result fields are user-selected and a remaining portion of the query result fields are computer-generated.<br>
4.	The method of claim 35, wherein defining the logical model further comprises logically defining key relationships between the physical fields and wherein the computer-selected query result fields are selected based on the key relationships<br>
5.	The method of any preceding claim 1, wherein the logical model is represented by a plurality of logical fields in a user interface and wherein augmenting the logical model results in displaying additional logical fields in the user interface after execution of a given abstract query.<br>
6.	The method of claim 214, wherein augmenting the user-defined abstract query comprises:<br>
for each result field of the augmented abstract query, determining a corresponding physical entity;<br>
for each corresponding physical entity, determining all key relations involving the corresponding physical entity, wherein each key relation relates fields of the corresponding physical entity to fields of a related physical entity as either primary or secondary with respect to the fields of the related physical entity;<br><br>
for each key relation involving the corresponding physical entity, determining whether at least one logical field definition corresponding to the related physical entity is included in the augmented abstract query; and<br>
if, for a given key relation involving the corresponding physical entity, at least one logical field definition corresponding to the related physical entity is included in the augmented abstract query: adding as the at least one computer-selected result field a logical field definition corresponding to a primary key field in the given key relation.<br>
7.	The method of claim 6, further comprising, if, for the given key relation involving<br>
the corresponding physical entity, the logical field definition corresponding to the<br>
related physical entity is not included in the augmented abstract query:<br>
adding as the computer-selected result field a logical field definition corresponding to a key field of the corresponding physical field as defined by the given key relation.<br>
8.	The method of claim 6 or 7, wherein the key relations are defined in the logical model.<br>
9.	The method of claim 6, 7 or 8, wherein augmenting the logical model comprises, for each given result field in a given abstract query: identifying a corresponding logical field definition from the logical model; and based on the corresponding logical field definition, generating a new logical field definition referring to a physical field of a result entity returned by the given result field.<br><br>
10.	The method of claim 9, wherein defining the logical model to logically describe the data comprises defining a plurality of relationships between the logical field definitions and wherein augmenting the logical model further comprises generating an additional relationship between at least a portion of the new logical field definitions and at least one of the previously existing plurality of logical field definitions.<br>
11.	The method of claim 10, wherein generating the additional relationship comprises:<br>
determining whether a physical data entity corresponding to the new logical field definition has a key relationship with another physical data entity having a corresponding logical field definition in the logical model; and<br>
if so:<br>
defining a relationship between the new logical field definition and the<br>
corresponding logical field definition of the physical data entity;<br>
determining whether the physical data entity corresponding to the new logical field definition is a primary key with respect to yet another physical data entity; and<br>
if so, defining a relationship between the new logical field definition and the yet another physical data entity.<br>
12.	A computer program comprising program code means adapted to perform the<br>
method of any of claims 1 to 11 when said program is run on a computer.<br><br>
13. A computer system, comprising memory and at least one processor, and further comprising:<br>
a logical model comprising a plurality of logical field definitions mapping to physical fields of physical entities of data, whereby the logical model provides a logical view of the data;<br>
an abstract query augmenter configured to (i) receive an abstract query comprising at least one condition and at least one user-selected result field selected from the logical field definitions of the logical model; and (ii) augment the abstract query with at least one computer-selected result field selected from the logical field definitions of the logical model, thereby producing an augmented abstract query; and<br>
a logical model generator configured to augment the logical model with additional logical field definitions based on (!) the result fields of the augmented abstract query; and (ii) results returned for the augmented abstract query<br><br><br>
ROC920030064<br>
ITERATIVE DATA ANALYSIS PROCESS VIA QUERY RESULT AUGMENTATION AND RESULT DATA FEEDBACK<br>
5<br>
The present invention is generally directed to a system, method and article of<br>
manufacture for accessing data represented abstractly through an abstraction model<br>
(512). In one embodiment, a data abstraction model (512) provides a logical view of<br>
an underlying data repository (518) that is independent of the particular manner of<br>
10	data representation. For a given abstract query (506), the abstract query (506) is<br>
augmented with additional computer-selected result fields (520). In addition, the data abstraction model (512) is also augmented with fields (528) corresponding to the result fields (514) of the previously executed abstract query.<br>
35<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDE2MC1jaGVucC0yMDA2IGFic3RyYWN0ICBkdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">0160-chenp-2006 abstract  duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDE2MC1jaGVucC0yMDA2IGNsYWltcyAgZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">0160-chenp-2006 claims  duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDE2MC1jaGVucC0yMDA2IGRlc2NyaXBpdGlvbiBjb21wbGV0ZWQgIGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">0160-chenp-2006 descripition completed  duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDE2MC1jaGVucC0yMDA2IGRyYXdpbmdzICBkdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">0160-chenp-2006 drawings  duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYwLWNoZW5wLTIwMDYtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">160-chenp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYwLWNoZW5wLTIwMDYtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">160-chenp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYwLWNoZW5wLTIwMDYtY29ycmVzcG9uZG5lY2Utb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">160-chenp-2006-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYwLWNoZW5wLTIwMDYtY29ycmVzcG9uZG5lY2UtcG8ucGRm" target="_blank" style="word-wrap:break-word;">160-chenp-2006-correspondnece-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYwLWNoZW5wLTIwMDYtZGVzY3JpcHRpb24oY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">160-chenp-2006-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYwLWNoZW5wLTIwMDYtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">160-chenp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYwLWNoZW5wLTIwMDYtZm9ybSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">160-chenp-2006-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYwLWNoZW5wLTIwMDYtZm9ybSAzLnBkZg==" target="_blank" style="word-wrap:break-word;">160-chenp-2006-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYwLWNoZW5wLTIwMDYtZm9ybSA1LnBkZg==" target="_blank" style="word-wrap:break-word;">160-chenp-2006-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTYwLWNoZW5wLTIwMDYtcGN0LnBkZg==" target="_blank" style="word-wrap:break-word;">160-chenp-2006-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="229403-a-process-and-apparatus-for-producing-cholorine-dioxide.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="229405-a-process-for-the-continuous-high-throughput-preparation-of-high-temperature-superconducting-tape.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>229404</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>160/CHENP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>12/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>20-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>17-Feb-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>12-Jan-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTERNATIONAL BUSINESS MACHINES CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>Armonk, New York 10504,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>DETTINGER, Richard, D</td>
											<td>5305 Kensington Lane N.W., Rochester, MN 55901,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>STEVENS, Richard, J</td>
											<td>3707 Arbor Drive N.W., Rochester, MN 55901,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US04/18508</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-06-10</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/459,734</td>
									<td>2003-06-12</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/229404-a-method-and-system-of-using-logical-model-to-query-physical-fields-of-physical-data-entries by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:05:39 GMT -->
</html>
