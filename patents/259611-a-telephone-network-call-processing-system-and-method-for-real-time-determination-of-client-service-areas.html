<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/259611-a-telephone-network-call-processing-system-and-method-for-real-time-determination-of-client-service-areas by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:12:52 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 259611:A TELEPHONE NETWORK CALL PROCESSING SYSTEM AND METHOD FOR REAL TIME DETERMINATION OF CLIENT SERVICE AREAS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A TELEPHONE NETWORK CALL PROCESSING SYSTEM AND METHOD FOR REAL TIME DETERMINATION OF CLIENT SERVICE AREAS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A system and method for automatically and seamlessly routing mobile telephone calls across a telephone network. The system includes a telephone network interface box, a computer, and a client file. The client file has a plurality of records having a spatial key and a client telephone number. One embodiment (1500) of the system utilizes a spatial coordinate (1502) of an instantaneous location of a caller&amp;quot;s mobile telephone as an input to a real-time process (1510) which identifies one or more client service locations (1460) from the client file corresponding to the location of the caller&amp;quot;s telephone (110). FIGURE 40</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>Telephone networke call for ceseinp systrem and method for to cerrealtive determination of client service areas.<br>
Background of the Invention  <br>
In the increasingly competitive business world, there have been various attempts to automatically route telephone calls made to an "1-800" number or equivalent for a local store, franchise, branch, dealer or serace company (henceforth, service location), whose service area encompasses the caller location (or the product or service associated with the "1-800" number. For example, a person would dial 1-800-ltalian from any telephone in the United States, and the phone would ring at the MyPizza (a fictitious business) service location that delivers pizza to the location of the calling telephone.<br>
There have been several previous simplistic attempts to automatically route calls to a service location that is geographically proximate to the caller. These routing technologies are based on routing the incoming call to a location with the same telephone area code and prefix as the originating call, to the same 5-digit zip code, to all zip codes that have the same city name, or a combination of the above. There are many different terms used to describe the various components of a 10-digit telephone number. In the telecommunications industry, it is called the NPA-NXX-XXXX, where the NPA is the area code, the NXX is the prefix or exchange and the XXXX is the suffix or line number. For example, in the 10-digit telephone number 619-942-9999, 619 is the NPA or area code; 942 is the NXX, prefix or exchange; and 9999 is the XXXX, suffix or line number. Usually all telephone numbers with the same area code and prefix are serviced by the same wire center. A wire center is the geographical area serviced by a single telephone company office. The wire center is usually one switch, but can be multiple switches, and usually provides service to about ten exchanges. By definition of the telephone companies, wire centers do not overlap.<br>
A. Prior Routing System Structure<br>
The earth is a sphere, and any point on its surface can be defined by a latitude and longitude spherical coordinate system developed several centuries ago. Using this coordinate system, spherical trigonometry, and a computer, it is possible to calculate the distance between any two locations on the earth and determine rf one location lies within a specified radius of another or determine if a location is contained within an irregular service area defined as a spherical polygon.<br>
Several years ago, AT&amp;T instituted the technology of passing the calling telephone number along the telephone network, by use of Automatic Number Identification (AND, to facilitate billing. The "Caller ID" feature, available on some telephone networks, utilizes the AN) technology to identify the telephone number of the calling party. Since a modern telephone switch is just a special purpose computer, it is a simple process for the switch handling the call to look up in a record table (of over one hundred million records) the calling telephone number with an assigned service location telephone number and route the call to the service telephone number.<br>
However, there were some fairly formidable problems that needed to be solved before this routing process could be a commercially viable and practical service. The first problem was initially determining the latitude and longitude of every telephone number in the United States and keeping them updated when twenty percent of the consumer population moves every year and businesses are continually opening and dosing locations. The second problem was performing the multitude of spherical trigonometric calculations which is several orders of magnitude beyond today's most powerful computers that are required to create the calling telephone number to the service location telephone number tables and to keep them updated in a constantly changing environment.<br>
Several key databases and technologies are necessary to solve these problems. The United States Census Bureau, as part of the 1990 census, buit a national latitude and longitude cartographic map of the United States called TIGER (Topological Integrated Geographical Encoding and Referencing) that contains almost every street link in the United States. A street link is a street segment intersected by other streets at each end. The TIGER record for all street links contains the latitude and longitude coordinates at each end of the street segment accurate to within plus or minus thirty feet and, for most street segments, the starting and ending address ranges for each side of the street. Where the Census Bureau did not complete the address ranges, private companies have filled in the gaps and are updating TIGER as new streets are built.<br>
In the past, the U.S. Postal Service (the "Post Office") divided the U.S. into postal delivery areas called zip (zone improvement plan) codes to help automate the routing of mail. At the nine digit level (called "zip+4"), these zip codes usually correspond to a single side of a street link, IN addition to geographically dividing the United States into small postal delivery areas, the Post Office also set standards for the naming of places and streets. For direct mailers to get discounts, they had to standardize their mailing addresses to match the Post Office's naming conventions and provide a zip+4 code. To facilitate the process of postal address standardization and zip+4 coding, the Post Office provides a national zip+4 Address Coding Guide and has certified several commercially available software packages that correctly address standardize and zip+4 code 99 percent phis of the address records on a Post Office test file.<br>
Recently, the Post Office and some private companies have matched the Post Office's Zip+4 Address Coding Guide with TIGER and have created files containing zip+4 codes with latitude and longitude centroids (a zip+4 centroid is the approximate geographical mid-point of a zip+4 code). This type of file is referred to as a zip+4 latitude and longitude centroid file 100 (Figure la). These centroids are accurate 95 percent of the time to within plus or minus 105 feet hi relation to a house or business receiving mail at a street address assigned to a given zip+4 code. Today, it is a very reliable and economical process to address standardize and zip+4 code a list identifying physical locations, such as a master list of phone numbers of the present invention.<br>
Other changes and improvements in telecommunications technology were needed to make the automated telephone call routing process a commercially viable and practical service. Improvements in the telecommunication infrastructure in the U.S. have changed the telecommunication cost structure. Presently the cost of a telephone call from Los Angeles to New York is about the same as for a call from Los Angeles to San Diego. Therefore, the physical location<br>
of central routing system hardware and facilities is no longer critical, or in other words, can be anywhere in the continental<br>
U.S.<br>
Another improvement of telecommunications technology is the advent of Geographic Information Systems, commonly called GIS. These systems allow the aggregation and display of almost any data for any area, any sue or shape, anywhere in the United States by interactive maps. The popularity of these systems has lead to the development of sophisticated techniques and algorithms to handle geographically based information: Of primary interest is the linking of the geographic information to telephone numbers, especially at the 10-digit level.<br>
The complex process of spherical trigonometric distance calculations on billions of possible permutations has been alleviated by making the process less computer intensive. Instead of performing complex trigonometric spherical calculations, a technique that is less than one-thousandth as computer intensive is used. This technique is based on doing a polyconic projection from each service location and performing simple two dimensional distance squared tests. There are approximately 68.9404 miles per degree latitude. However, the miles per degree longitude varies with the latitude. At a given latitude, the miles per degree longitude is equal to the cosine of the latitude multiplied fay 68.9404. By using the service location as the latitude point and knowing the latitude and longitude of calling points, it is easy to obtain a delta latitude and longitude, translate them into miles, and perform a simple distance calculation, i.e., "distance - SQRT(X••2 + Y••2)". This polyconic projection technique results hi a distance calculation error of approximately 12 feet for two locations that are 100 mfles apart at 40 degrees latitude. However, additional reduction of the computational effort is necessary to have a practical efficient, and commercially viable routing process for high call volume applications. B. Prior Routing System Operation<br>
Previous technologies for routing "1-800" telephone number calls to a service location have one or more of the following three problems:<br>
(1)	Many such routing systems are very coarse in their level of precision and cannot handle small service areas<br>
with specifically defined franchise territory boundaries like those for pizza delivery franchises. The franchise territory may<br>
be, for example, an irregularly shaped polygon. A much more precise system is desired that is accurate to within about<br>
105 feet rather than previous systems having accuracies to within about 10 miles. Such a system would utilize very<br>
precise measurement determinations made possible by knowing the physical location on the earth, most typically<br>
expressed as a latitude and longitude, of nearly every non-mobile telephone in the United States. Other coordinate systems<br>
could be used in other countries.<br>
(2)	Another problem in routing systems is that they divide the United States into many large arbitrarily defined<br>
areas and there is no ability to route a call to the closest service location if the closest location is not located in the same<br>
artificially created area as the caller. In many instances, a caller located near the border of an exchange area or 5-digit zip<br>
code is much closer to a service location with a different zip code or telephone prefix than the one to which h is routed. A<br>
seamless system is desired that does not use artificially created areas such as telephone wire centers, telephone prefixes,<br>
or 5-digit zip codes where cads can only be routed within their area. A business may want an option of choosing to route a<br>
cad to the closest branch whose service area may be defined by either a predetermined radius, e.g., 5 miles, that<br>
encompasses the location of the caller or by a predetermined irregularly shaped polygon that encompasses the location of the caller. Furthermore, a business may want an option of choosing to route a call to any branch whose service area may be defined by either a predetermined radius that encompasses the location of the caller or by an irregularly shaped polygon that encompasses the location of the caller, rather than the closest branch.<br>
(3) Finally, known routing systems often rtiy on third party telephone directories that are always inaccurate due to publishing, key entry, and optical character recognition (OCR) scanning time lags and which do not include unlisted numbers. Over 30 percent of the U.S. telephone numbers are unlisted, which includes public pay phones and multiple bites going into businesses and households where only one ine is feted. The information in such directories becomes rapidly outdated as the locations and related information of listed consumers and businesses change. Thus, a system is desired that correctly routes a much higher percentage of cab than the previous systems. In the U.S., such a system would require direct access to the AT&amp;T universe of telephone numbers. Such a system would preferably utilize daily updated and unlisted telephone numbers and involve passing information between regulated telephone databases maintained by the telephone companies and client databases maintained by third parties.<br>
The three deficiencies discussed above result in lower customer service and satisfaction, higher costs because of manual exception handling for calls that cannot be routed due to a variety of reasons, costs of misrouting. and high on going maintenance costs. Manual exception handling generally requires operator intervention in the "1-800" call.<br>
Other previous systems require the consumer to enter their zip code or telephone prefix on the Touch Tone keypad in response to voice prompting from the system. Based on the caller-entered data on the keypad, the telephone call is forwarded to a destination telephone. Other similar systems wil simpry inform the consumer, by a voice message, of another telephone number for the local dealer, which must be manually dialed rather than forwarding the call automatically. A system is desired that does not require any additional customer interaction or input. Such a system would be totally automatic by utilizing, at a minimum, the 10-digit telephone numbers in the standard telephone packet that can only be accessed and utihzed by regulated telephone companies on a national basis. The telephone packet includes the complete origin and destination telephone numbers.<br>
The basis of an automatic telephone routing system must include a means to automatically identify the telephone number of the calling party. Such a system is disclosed by Kaplan. U.S. Patent No. 5,163,087. This system translates an Automatic Number Identification (AMI) of the calling party into a customer database key previously defined by the called party. The database key. e.g., customer account number, is then provided to the called party instead of the ANI information such that a computer at the called business can process the key to look up and present customer information to an agent of the business. This system assumes that the caller has called this business at a previous time to provide information to the agent of the business to create a customer record or other similar information. The Kaplan system delivers the database key to one business location rather than a plurality of service locations throughout the country. The defivery of the database key to the business requires an Integrated Services Digital Network (ISDN) or similar facility, which is an additional burden for the business.<br>
An automatic routing system should not need to deliver a database key or message to the final destination, but<br>
would merely utilize the AMI information as an index to a table containing partitions of a country into small geographic<br>
areas, such as postal service zip+4 codes. These partitions would be further utilized to access one of a plurality of service<br>
locations that may be anywhere within the country. A current system for telephone call routing is described m U.S. Patent<br>
No. 4,757,267 to Riskin. Riskin employs automatic number identification (AM) for routing calls from a caller to a dealer<br>
located within the same area code and prefix (first six digits of a 10-digit telephone number, the "6-digit number") as the<br>
caller. Because the area identified by the 6 digit number is fairly large and there may be several dealers within the area,<br>
the dealer location is usually selected from a list of several locations based on random selection, or weighted percentage<br>
assigned to each location.  Alternatively, the caller is presented with a list of possible dealer locations for the large<br>
geographic area because the system does not know which service locations are closer than the others. Riskin uses the 6<br>
digit number to determine the location of both the cater and the service location. Riskin assumes the location of the caller<br>
to be the location of the central office switch that services the caller's 6-digit exchange (which can be 0 to 5 miles from its<br>
true location), and assumes the location of the dealer location to be the location of the central office switch that services<br>
the dealer location's 6-digit exchange (which can be 0 to 5 miles from its true location) utilizing a coordinate system that is<br>
accurate to phis or minus 2300 feet. What is desired is a system that uses all ten digits of the calling and service location<br>
telephone numbers and the physical street address of the location of the numbers in connection with a GIS-type database<br>
lutfoing a coordinate system and associated coordinate data that is accurate to within 30 feet) to provide geographic<br>
precision to within 105 feet for the location of the calling and destination telephones.<br>
Consequently there is a need for an automated telephone routing system that provides the ability to reduce costs fay routing a very high percentage of calls made to a single national telephone number without any human intervention; the marketing advantage for a client of a single, easy to remember, toll free or nominal fee national telephone number; geographically precise results; and the ability of businesses to define custom service areas around each servicing location of any desired size and shape. Preferably, a client may define each location's service area as an area with a radius of any size or a polygon of any size and shape. A diem can intermix radius and polygon definitions as well as have service areas be overlapping or non-overlapping.<br>
Frequently, a caller may not need to have a telephone call actually completed to the service business location, but rather, the caller needs information about the business. For example, the caller may want to determine the location of the three closest service locations, or more specifically, the caller desires to know that the business is stiH-open, or has inventory of a desired item, and so forth.<br>
C. Prior Voice Response Unit Utilization<br>
Traditionally, businesses, non-profit organizations and government agencies with one to tens of thousands of service locations provided customers multiple telephone number points of contact with usually at least one telephone number for each service location, department and individual This put a major burden on customers and prospective customers to find, remember, dial and be connected to the correct intra-entity telephone number for the location or services desired. In the new world of electronic commerce, these entities have started promoting vanity telephone<br>
numbers as their preferred single initial point of customer contact. These vanity numbers are easy to remember telephone numbers, e.g.. 1-800 FLORIST, that are selected by a business. The vanity telephone numbers typically have "800", "888" or "900" as area codes or local exchange prefixes "555" or "950".<br>
Based on the large volume of cads going to these vamty numbers, customer demands for extended support hours of seven days a week and 24 hours a day, and the goal of reduced telephone busy and on-hold times has resulted in many vanity advertisers answering vanity number cads with Voice Response Units (VRU). The proliferation of vanity numbers and the utilization of the VRU have created a need to automate, through what is now called intelligent call processing, a higher percentage of calls being answered by the VRU.<br>
In this context, automated intelligent cal processing is defined as the capture of network-provided data, such as ANI and dialed number identification service (DNIS), and caller-provided data, such as data entered by Dual Tone Multi-Frequency (OTMF) through a Touch Tone telephone key pad or the caller speaking directly, at the VRU. The intelligent VRU further can decipher, validate, process and furfi the caller's request by playing pre-recorded messages, creating call specific test messages and speaking them to the cader, and/or routing and connecting the caller to the servicing location. In contrast semi-automated call processing means that components of the customer request can be automated through intelligent call processing but some portions of the request still require support during the cad by a live operator.<br>
A further category of automated intelligent cafl processing includes the situation where the client does not desire to use the voice response capabilities but uses the automated routing features of the system. In such a situation, the VRU may be replaced by a network terminating point interface (NTPI) box which does not have voice/speech features.<br>
For the VRU or NTPI box to handle a higher percentage of cater requests, more information must be immediately accessible to the VRU or NTPI box. This requires the real-time access to many different databases, stored on different computer systems. Recent advances in computer networking technology, networking standards, increases in speed and bandwidth, and reduction in costs for long distance data communications have made wide-area networking a common practice. This is demonstrated in part by the variety of computer-interface applications supported by computer network services, such as CompuServe9, America Online9, Microsoft Network™ and the Internet<br>
In the national telecommunications network with its nearly 200 million access points, most with only basic Touch Tone or old rotary telephone input and output capaWity. VRU or NTPI switch database access has been primarily limited to client proprietary customer databases indexed by telephone number. This type of access works acceptably for many applications with existing customer calls. However, for new customers, new businesses or new applications that service different target markets, these internal databases are too sparse in coverage to make VRU database lookup applications economical. On the other hand, there are national databases, such as the GOT Zip+4 Latitude and Longitude files, that do not contain a telephone number. Accordingly, these databases, and derivatives of these databases that do not contain a telephone number field, have not been utifced in VRU telephone can processing applications.<br>
The missing link in making almost unlimited amounts of data immediately available to the VRU or NTPI box is creating a standardized, precise and universal database linkage key that can be assigned to afl telephone numbers in the United States and U.S. territories. This key needs to act as a direct and/or translator linkage mechanism between the<br>
telephone number and spatial geographic, and client service location databases, where the service area may be ot any defined size and shape. Since the common trait shared among the above-mentioned databases is then geographtcispatial location, definition and/or relationship, what is needed is a robust solution of a universal hierarchical geographic/spatial linkage key that is termed herein, the Spatial Key. Utilizing the Spatial Key, it becomes practical to automate many VRU applications that provide the caller with information and/or connect the caller with a servicing location.<br>
The option of choosing from among several embodiments of the spatial linkage or spatial key bnkage with a VRU or NTPI box would be desirable. These include: (1) Use of a master table having caller-provided telephone numbers with an associated spatial key and an automatically generated client table linking spatial keys to client service location information. (2) Use of a single taUe finking telephone numbers to other telephone numbers when routing speed is very important or where compatibility is necessary with the current telecommunications network. Telecommunications networks generally require long lead tones to incorporate new technology. Because such an embodiment uses a single table, it would be the simplest embodiment to implement from the telecommunications network perspective. (3) Use of real-time spatial processing to associate precise caller locations to precise servicing locations in situations when high caD volumes and transaction processmi speed are not an issue andJor where computer storage is a limited resource and the application does not require a Spatial Key linkage to other Spatial key indexed databases. Such a system would be the simplest embodiment to update and the required files could be independently maintained.<br>
Prior attempts an real-time call processing have lacked precision. Typical prior attempts use the area code and exchange numbers (6 digits) rather than all ten digits of a U.S. telephone number. For example, the Riskin patent uses Bellcore's V&amp;H coordinate system to identify the caller location and the service location to a pius or mmus five mile precision. This prior system does not use a precise service area definition for the service location, but rather uses a client-defined search radius around the cater location. However, the location of the caller is defined by the V&amp;H coordinates of the telephone switch to which the caller's telephone is physically connected, so the search radius is actually around each telephone switch. The search radks is used to access a V&amp;H coordinate interleaved index to a service location file to get a Kst of potential service locations. Calculations are then made to determine the distance between the location of the caller's switch and the location of the switch for each of the potential service locations. This information is used te develop a final 1st of service locations.<br>
What is desired is a system that can precisely determine the location of the caller or caller-provided telephone number and of the service location. Also desired is the ability for the client to precisely define a service area around each service location. Further desired is the capability to quickly route the telephone call, such that the caller is not aware that it is happening. The imprecise distance calculation from the caller location to the service location used by prior systems for determining servicing locations) is no longer required for this purpose. The ability of the system disclosed herein to precisely determine the distance between the above two mentioned points provides a valuable item of information for further selecting between multiple caller servicing locations and providing information regarding the proximity of a servicing location to the caller.<br>
Also desired a the thirty to utilize an instantaneous location, deimed by coordinates, of a mobile or portable telephone to identify one or more caller servicing locations by use of a real-time process in the system. The real-tune process may calculate one or more service locations for the caller in real-time (on-the-fly). In one embodiment, the system would obtain the coordinates, such as latitude and longitude, of the mobile telephone from the telephone network. Other embodiments may use other coordinate types or processes other than a real-time process.<br>
In an of the desired embodiments, it would be preferable to utilize a service area, associated with a client service location, of any desired size and shape. Further, it would be desirable to optionally allow the client to provide service area information to the caller. Such an option would preferably utilize an NTPI box having voice/speech features linked to a file comprising client service information by a service location 10 or telephone number, for example. The optional client service location information could include, for example, providing the caller with such things as the addressfes) of the servicing location(s) for mailing, picking up and/or dropping off something to the selected servicing location; providing the caller with pre-stored micro-area directions to the service location(s); or providing the caller with the location's open hours, drop-off times or pick-up times.<br>
Summary of the Invention<br>
The present invention includes a system and method for automatically processing telephone calls by either connecting the caller to a servicing location and/or providing the caller information regarding the servicing location.<br>
The present invention provides a method of routing att published and unpublished telephone numbers, including unlisted numbers, secondary unpublished business fanes, mobile phones, and public pay phones. The present invention also provides a method for legally conforming to contracted franchise territory definitions executed between franchisers and franchisees by routing customer's cats precisely to the correct legal franchisee area. Additionally, the present invention provides a method for precisely routing telephone calls based on any geographic definition including postal geography, census geography, telecommunications geography, special grid coordinate geography, and all custom geography.<br>
The present invention provides a method for automatically routing and processing customer calls that do not meet the pre-set client protocols. This "exceptions handling' process routes to a "live" operator who executes preset exceptions handling protocols. The present invention also provides for a method of integrating unrelated geographic information systems and database technology, telecommunications systems and database technology, postal systems and database technology, and computer technology into a common applications driven architecture. Additionally, the present invention provides a method for dynamically and instantaneously updating and integrating Client and Master Tables with no time lags. Furthermore, the present invention provides a method for automating the processing of information that is input by a customer using a customer interface that automatically routes telephone calls to customer requested destinations.<br>
The present invention provides a Two Table system to determine the precise location of a telephone associated with a caller fay utilizing the caller's telephone number, determining a spatial key for the location, and spatially associating the key with servicing locatton(s) whose service areas can be defined as any size or shape. Alternatively, a caller-provided telephone number may be substituted for the caller's telephone number, in which case the location is of a telephone<br>
associated with the cafler-provided telephone number. This process starts by retrieving a telecommunications network captured caller 10-digit telephone number with its associated spatial key from the first table. Next, records) with the associated spatial key are retrieved from a second table created by an automated process that mathematically establishes spatially overlapping relationships between spatial keys and service area(s) of any defined size and shape. Finally the retrieved service location dependent data is passed back to the telecommunications network to connect the caller to a selected service location or for further network processing.<br>
Key components of the system include a caller location identifier to identify the precise spatial and geographic location of the caller, or caller-provided telephone number, with a spatial key and a routing kernel. The routing kernel utilizes a dialed number to efficiently determine which geographically defined client service areas encompass the location of the caller-provided telephone number and determines a distance and direction from the caller's location to each of these service locations.<br>
The present invention provides the creation and maintenance advantages of an automated table build process versus the manual process of building and maintaining a Caller Telephone Number to Service Location Telephone table used in prior systems. Automatically created client tables are built by accessing a list of service areas one area at a time to determine which spatial keys, e.g., ZIP+4s, are within each service area, calculating the distance from each ZIP+4 to the service location, writing a record for each coiiidined ZIP--4 to a file, and sorting and indexing the file by reference to the ZIP+4 and by ascending distance.<br>
In one Real-Tune Processing embodiment, the system determines a latitude and longitude of a caller and based on this latitude and longitude, the system spatially determines a list of locations that potentially service the caller's location. The system then periorms a detailed spatial test on each potential location in the list to determine if the caller's latitude and longitude is inside the service location's service area. If rt is inside, the distance from the caHer to the service location is determined and added to the list of servicing locations. After all potential locations have been processed, the servicing fist is sorted in ascending order based on distance and passed back to the application job stream for use by the telephone network in routing the caL<br>
To facfttate efficient real-time processing, a Service Area Windows file is utilized. Each record in this file comprises a service location telephone number or ID and a latitude/longitude window determined from the latitude and longitude extremes of the radially-defined service area or the polygon-defined service area, as applicable.<br>
A further derivative of the Two Table system (Master and Client tables) is a Three Table system which incorporates a Cient Service Location table. Alternately, the Client Service Location table can be incorporated into either the One Table system or the Real Time Process system. Thus, the Client Service Location table is an enhancement to any of these systems.<br>
In the Two Table system, the Master Table and the Client Table are used to determine the spatial service relationship of the caller provided telephone number and the servicing locations. However, in call processing where there are multiple service locations that service a caller, there is other service location dependent data that does not have any spatial attributes, e.g., hours open, days open, product inventories, that is required for selecting the best service location<br>
for the caller. This data is most efficiently stored in a third table called the Client Service Location table. There is one record per service location in this table, which is indexed by service location identification (10) or by service location telephone number. This table can also contain informational data. e.g.. service location, name, address, general directions to a service location, a termination telephone number, a fa: number and so forth, that can be spoken to the caller by a Voice Response Unit.<br>
One aspect of the present invention includes a telephone network cat processing system having a cafl decoding module capable of receiving a dialed number and a caUer spatial coordinate corresponding to an nstantaneous location of a caller telephone; a real-time processing module responsive to the dialed number and the caller spatial coordinate for providing a client service location telephone number corresponding to a selected service location, wherein the service location is provided if the caller spatial coordinate is included in a service area having a client defined geographic configuration of substantially any desired shape and size; and an outbound calling module for transmitting the provided client service location telephone number to the telephone network.<br>
Another aspect of the present invention includes a real-time method of call processing lot use in a telephone network, the method comprising receiving a dialed telephone number and a caller spatial coordinate corresponding to an instantaneous location of a caller telephone; providing a client service location telephone number corresponding to a selected service location in response to the dialed telephone number and the caller spatial coordinate, wherem the service location is selected if the caller spatial coordinate is included hi a service area having a client-defined geographic configuration of substantially any desired shape and size; and transmitting the provided client service location telephone number to the telephone network.<br>
Yet another aspect of the present invention includes an automated call processing system and method capable of caller location based routing for use with mobile phones. One embodiment of the system includes a call decoding module capable of receiving a caller spatial coordinate corresponding to an instantaneous location of a caller telephone; a central switch process capable of retrieving caller spatial coordinate dependent data corresponding to a selected client service location, wherein the central switch process utilizes a client database and wherein the client database is created based on a plurality of client service locations, each cfctnt service location having an associated client-defined service area of substantially any desired shape and size; and an outbound calling module for transmitting the cater spatial coordinate dependent data to the telephone network.<br>
Yet another aspect of the present invention includes, in a telephone network, an automated call processing system capable of caller location based routing for use with mobile phones, the system having an inbound receiving module capable of receiving a caller spatial coordinate corresponding to an instantaneous location of a mobile telephone cater; a call processing process responsive to the caller spatial coordinate for providing a client service location telephone number, wherein a service location is provided if the caller spatial coordinate is included in a service area having a client defined geographic configuration of substantially any desired shape and size; and an outbound calling module for transmitting the provided client service location telephone number to the telephone network.<br>
Brief Description of the Drawings<br>
Figure la is a block diagram ol the files utized in the presently preferred Client table Build process of the present invention;<br>
Figure 1b is a block diagram of a portion of a dynamic central switch linking process of the present invention that uses the result of the Table Build process of Figure la;<br>
Figure 1c is a system level diagram of a presently preferred embodiment of the central switch linking process interconnecting a calling telephone and a destination telephone of the present invention;<br>
Figure 2 is a map diagram illustrating an example of a routing network for the system of Figure k;<br>
Figure 3 is a top-level flow diagram of a process to build a Client table using radius defined service areas for the system cf Figure 1c;<br>
Figure 4 is a map diagram illustrating an example area utilized in the description of the process shown in Figure 3;<br>
Figure 5 is a flow diagram of the zip window fist function indicated at 182 in Figure 3;<br>
Figure 6 is a flow diagram of the zip windows function indicated at 262 in Figure 5;<br>
Figure 7 is a flow diagram of the initial zip list function indicated at 184 in Figure 3;<br>
Figure 8 is a flow diagram of the remove duplicates from zip list function indicated at 322 in Figure 7;<br>
Figure 9 is a flow diagram of the final zip fist function indicated at 186 in Figure 3;<br>
Figure 10 is a flow diagram of the zip+4 site radius check function indicated at 188 in Figure 3;<br>
Figure 11 is a flow diagram of the service location closest to the caller function indicated at 196 in Figure 3;<br>
Figure 12a is a top-level flow diagram of a process to build a Client table using polygon defined service areas for the system of Figure 1;<br>
Figure 12fa is a block diagram of the files utilized in the process of Figure 12a;<br>
Figure 13 is a diagram illustrating an example area utilized in the description of the process shown in Figure 12a;<br>
Figure 14 is a flow diagram of the zip window list function indicated it 612 in Figure 12a;<br>
Figure 15 is a flow diagram of the zip windows function indicated at 680 in Figure 14;<br>
Figure 16 is a flow diagram of the initial zip fist function indicated at 614 in Figure 12a;<br>
Figure 17 is a flow diagram of the remove duplicates from zip list function indicated at 752 in Figure 16;<br>
Figure 18 is a flow diagram of the final zip fist function indicated at 616 in Figure 12a:<br>
Figures 19a and 19b are a flow diagram of the line index file function indicated at 618 in Figure 12a;<br>
Figure 20 is a flow diagram of the zip+4 site polygon check function indicated at 620 in Figure 12a;<br>
Figure 21 is a flow diagram of the point in polygon test function indicated at 930 in Figure 20;<br>
Figure 22 is a block diagram illustrating files and processes utilized in the Client Table Build process where the Client table is a Telephone Number to Telephone Number table for a first embodiment of a One Table system;<br>
Figure 23 is a block diagram illustrating files and processes utilized in a merge operation for a second embodiment of the One Table system;<br>
Figure 24 is a (low diagram of the Match and Append function indicated at 1040 in Figure 23;<br>
Figure 25 is a flow diagram of the buid Master table list subroutine 1050 shown in Figure 24;<br>
Figure 26 is a flow diagram of the build Ghent table list subroutine 1052 shown in Figure 24;<br>
Figure 27 is a block diagram of the One Table system, including a network configuration utilized at a switch;<br>
Figure 28 is a flow diagram of an embodiment of the call processing Unking process for interconnecting a caller at a calling telephone and a destination telephone using the tables of Figure 22 or Figure 23 and the network configuration of Figure 27;<br>
Figure 29 is a block diagram of the Tiles and processes utilized in a Real-Time Process embodiment of the system;<br>
Figure 30 is a Mock diagram of the Real Time Process system, including a network configuration utilized at a call processing center;<br>
Figure 31 is a flow diagram of the Service Area Windows File Build process indicated at 1212 in Figure 29;<br>
Figure 32 is a flow diagram of the Radius Latitude/Longitude function indicated at 1250 in Figure 31;<br>
Figure 33 is a flow diagram of the Polygon Latitude/Longitude function indicated at 1252 in Figure 31 ;<br>
Figure 34 is a flow diagram of the Write Service Area Window Record function indicated at 1254 in Figure 31;<br>
Figure 35 is a top-level flow diagram of the Real-Time process indicated at 1220 in Figure 29 to build a list of service locations whose service areas contain the caller location;<br>
Figure 36 is a flow diagram of the Initial Service Area List function indicated at 1346 in Figure 35;<br>
Figure 37 is a flow diagram of the Caller Location Inside Service Area Extremes function indicated at 1348 in Figure 35;<br>
Figure 38 is a flow diagram of the Caller Inside Service Area Test function indicated at 1380 in Figure 37;<br>
Figure 39 is a flow diagram of an embodiment of the call processing linking process for interconnecting a caller at a calling telephone and a destination telephone using the tables of Figure 29 and the network configuration of Figure 30; and<br>
Figure 40 is a flow diagram of an embodiment of the call processing linking process for interconnecting a caller at either a fixed location calling telephone or a mobile calling telephone to a destination telephone using the tables of Figure 29 and the network configuration of Figure 30.<br>
Detailed Description of the Preferred Embodiments<br>
The following detailed description of the preferred embodiments presents a description of certain specific embodiments to assist in understanding the claims. However, the present invention can be embodied in a multitude of different ways as defined and covered by the claims.<br>
Reference is now made to the drawings wherein like numerals refer to like pans throughout.<br>
For convenience, the discussion of the preferred embodiments will be organized into the following sixteen principal sections:<br>
I.	System Overview;<br>
II.	Routing Example;<br>
III.	General Client Table Buid Process;<br>
IV.	Client Table Build Process tor a Radius Defined Service Area;<br>
V.	Client Table Build Process tor the Service Location Closest to the Caller;<br>
VI.	Client Table Build Process tor a Polygon Defined Service Area;<br>
VII.	Overview of One Table System:<br>
VIII.	One Table System Table Build Processes:<br>
IX.	Computer-Telephone Integration Network Configuration for One Table System;<br>
X.	One Table System Eumpte;<br>
XI.	Overview of Real-rime Process System;<br>
XII.	Computer-Telephone Integration Network Configuration for Real-Time Process System;<br>
XIII.	Real-Time Process: Off-line Process to Build Service Area Windows File;<br>
XIV.	Real-Time Process: During CaO Process to Build List of Servicing Locations whose Service Areas<br>
Encompass the Location of Caller Provided Telephone Number:<br>
XV.	Real-Time Process System Example;<br>
XVI.	Real-Time Process with Mobile Telephones;<br>
XVII.	Other Mobile Telephone Embodiments; and<br>
XVIII.	Summary.<br>
I. System Overview<br>
The present invention includes an automated telephone routing system which receives mput from a common carrier, such as AT&amp;T and AT&amp;T American Transtech. This input includes an updated national fast of telephone numbers, telecommunication infrastructure, and exception handkng support.<br>
A system and method for automatically and seamlessly routing a telephone cad from a calling telephone to a destination telephone selected by a diem wi be described. Optional information about the client service location can be provided to the caller if a particular client so dtsres. In addition, a method of creating the tables utilized by the routing system, according to criteria established by the client, will also be described. The tables discussed below may also be referred to as files or databases.<br>
Referring to figure la, the number of calculations to be performed and permutations that must be tested is reduced in creating the calling telephone number-to-service location telephone number tables used in the * 1-800* routing of the present invention. Accordingly, a Zip Windows tile 104 (Figure 1 a) and a process 105 to spatially access and operate on this file are a part of the present invention. It will be understood that the Zip Windows file 104 is just one embodiment of a Spatial Windows file which could include different types of spatial keys. The Zip Windows file 104 contains a list of all zip codes that potentially touch a tenth of a degree (0.1°) latitude and longitude spatial window. By utilizing a set o1 latitude and longitude extremes (miramums and maximums) for a service area in process 105, a list of 5-digrt zip codes that<br>
could overlap with the service area is generated tt is then only necessary to perform an "inside semce area" test tor each service location and a small subset of zip+4 codes contained within each service area's returned list of 5 dtgtt Tip codes. File 104 and process 105 will be explained further and an example given hereinbelow.<br>
Update problems and costs associated with continually updating and periodically rebuilding a hundred miflion plus record, telephone number-to-telephone number table for each business or client using the automated telephone routing system is solved, in one embodiment, by creating a dynamically linked, updatable system. Instead of creating a telephone number-to-telephone number table for each client two tables linked by zip+4 codes, as shown m Figure 1b, are created. A telephone number with its corresponding physical street address is assigned to a zip+4 code, and a Master Telephone Number to zip+4 Table 107 (Figure 1b) (the "Master Table') is built using the Postal Service's Zip+4 Address Coding Guide, and commercially available software, e.g.. CODE-1® (for mainframes and large machines) or AccoMaiP (for personal computers or small machines), both available from GROUP 1 Software, Inc. The preferred Master Table, presently maintained by AT&amp;T American Transtech, is indexed or keyed by telephone number, and is updated on a daily basis. When phone numbers are added, changed or deleted, the table is updated. This table is also updated on a periodic basis to handle the approximate one hundred 5-digrt zip code changes per quarter year, e.g., when a new zip code is created, telephone numbers in the new code area must be assigned a new zip+4 code. This represents a fairly small amount of change in relation to the 43,000 zip codes (5-digit) in the United States. This table must also be periodically updated to handle NPA-NXX spins. At routing time, the present system allows all clients to use the same Master Telephone Number to Zip+4 Table 107.<br>
Independently, and on an individual client basis, each of over 28 million zip+4 codes is assigned, based on their latitude and longitude centroid coordinates, to one or more service locations using standard "inside service area" determination processes.<br>
Hence, the present invention builds a Client Zip+4 to Service Location Telephone Number Table 106 (the "Client Table", Figures 1a and 1bl A different table is built for each client or for every "1-800" telephone number that a client may have. The Client table build process processes one client location record at a time. The routines required to process each record are a function of the location's service area definition: radius or polygon. Once an intermediate Client file is created, the disk storage requirements can be reduced by eliminating locations that are not the closest location to the caller. The building of radius and polygon client table records as wed as the post-build process of creating a "closest location" Client fHe win be described hereinbelow.<br>
The Client Table 106 is then preferably provided to AT&amp;T American Transtech for centralized routing at a call processing center. This table is indexed or keyed by zip+4 code and is updated for each client as they add and delete locations, when they change telephone numbers, and on a periodic basis to handle Post Office zip code changes and telephone network NPA-NXX splits.<br>
Using the presently preferred system, both the Master Table 107 and the Client Tables 106 are independently maintained by separate organizations. Using the zip+4 code as a spatial key linkage, a calling phone number in the Master Table 107 is then dynamically linked, as shown m Figure 1b, to a service location phone number m the Client Table 106<br>
and the call is automatically routed. The spatial key is a single number that identifies a specific geographically defined area. line, or pomt that is defined fay a set of coordinates. For simple geographies like points and rectangles the spatial key can be a coded version of the coordinate description of the geography.<br>
The postal zip+4 code is the preferred spatial key used to link the master table to the chent table, but there are other small geographic areas capable of having unique spatial keys, such as zip+6 code areas, census blocks, or very small latitude/longitude grids, ties, windows, or quad-trees. This two-table indexing approach provides a much higher automated routing rate and a higher percentage of correctly routed calls in an environment where consumers are continually moving and businesses are opening, closing, and/or moving. In addition, the two-table indexing approach also acts as a "fire wall" or buffer between regulated telephone number information and client marketing information to satisfy government regulations.<br>
The system of the present invention directly routes the telephone call from the caller to the closest service location in approximately 40 milliseconds using the AT&amp;T telecommunications network. The system described by Riskm intercepts the call with a private switch, answers the call with a client recorded message and asks the caBer to wait, while it takes approximately 15.000 milliseconds to find the closest service location and then can forwards the call to the service location.<br>
To route a call, the system ot the present invention looks up the caller's 10-digit telephone phone number in its 100,000,000 phis record Master Table, retrieves the spatial key that identifies the location of the caller's phone, looks up the spatial key in the 28.000.000 plus record Client Table, and retrieves the telephone number of the location that services the caller's spatial key or location. The system described by Riskm looks up the caller's 6-digit exchange in its 64.000 record Exchange file having only 18,000 unique coordinates, retrieves the V-H (vertical-horizontal) coordinates of the exchange, interleaves the V-H coordinates, and starts a binary-iterative, V-H key based, size search of the N record client service location database. The Riskm system iterates through this process, adjusting the size of the geographic areas searched, until it retrieves a number of service locations that fall within a predetermined range. Rtskin then calculates the distance to each service location. If more than one location fits the criteria to be considered the closest distance, one location is randomly selected as the closest service location.<br>
IL Routing Example<br>
Prior to discussing the building of Client Tables in more detail, it will be helpful to first discuss use of this table and the Master Table in a "1-800" routing example. Referring to a central switch process 108 shown in Figure 1c and a routing network shown in Figure 2. an example of telephone call routing will now be given. In this example, a caller dials 1-800-ltalian to order a "MyPizza" pizza from his phone (619-755-5666) located at 498 Stevens Avenue in Solatia Beach. CA 92075-2064. Of course, the present invention is not limited to use of "800" telephone numbers as other numbers may be used in other embodiments.<br>
Figure 1c includes process states and also data at 114, 132, and 146, indicated by parallelogram blocks. Also, the central switch process is handled inside a switch as will be described below.<br>
The steps involved in having this cal automatically routed to the caller's local MyPizz? Restaurant are as follows:<br>
1.	A caller at "Location A* 160 (Figure 2). dials 1-800-ltafian at block 110 (Figure Icl to order, for example, a<br>
pizza.<br>
2.	Based on the 1-800 dialed and the caller's long distance carrier, the cad is routed by various telephone<br>
companies to an intelligent central switch in Jacksonville, Florida, indicated on Figure 2 by "Location B" 162. The process<br>
associated with the switch is shown in Figure 1c as being below the dotted line |ust before state 112 and above the<br>
dotted Ime just after state 148. The central switch 111 is preferably a *4 ESS™" digital switch available from AT&amp;T.<br>
The switch includes a general purpose computer (not shown) such as a network control point computer with a memory.<br>
3.	Once the Jacksonville switch has the call, it pulls the caller's telephone number from the calling information<br>
packet 114, by call decoding hardware 112 which performs Automatic Number Identification (AMI).   The preferred<br>
information packet 114 corresponds to the operation parameter field of the SS7 TCAP message available at the switch<br>
111. The hardware to perform AM is described in U.S. Patent No. 5,163.087 to Kaplan, and is hereby incorporated by<br>
reference. The number equivalent of 1-800-halian is 1-800-482-5426, and the information packet looks as follows:<br>
Packet:	6197555666...... 18004825426	<br>
The "1-800" number is an IN-WATS (inbound wide area telephone service) number and must be translated by a wide area carrier to a POTS (plain old telephone service) number to be routed to the switch 111. Upon receiving the POTS number, the switch 111 translates the number back to the WATS format.<br>
4.	Then, at decision state 116. the process 108 determines whether the client has chosen to give the caller an<br>
option to enter a telephone number on a Touch Tone telephone keypad or other means,  in other embodiments, other<br>
characters are entered, such as a credit card number, an account number, or product order information, to enable other<br>
features of the system. In the presently preferred embodiment, the telephone number represents the location where the<br>
caller desires, for example, a product to be delivered or a service to be performed. As an example, if a client had a<br>
telephone number such as 800-FLORIST and desires the optional input future, the cater could choose to have the flowers<br>
delivered to the address corresponding to a utter entered telephone number. If the decision state 116 is determined to be<br>
true, the process 108 moves to state 118 to capture the telephone number entered by the caller. This number is then used<br>
in place of the calling number in the information packet for further handling.  However, if the decision state 116 is<br>
determined to be false, the original caing number is unchanged, and the process 108 moves to a decision state 120.<br>
5.	At decision state 120, the process 108 determines if the caSng number in the information packet is that of a<br>
mobile telephone. A file in the computer of the switch 111 listing mobile telephone numbers is presently maintained by<br>
AT&amp;T American Transtech and is updated on an as-needed basis. Mobie telephones are assigned a number from a set of<br>
prefixes unique to each area code in the U.S. Therefore the Mobile Telephone Number file only needs to contain the area<br>
code and prefix combination (6 digits) to identify that the calling number is that of a mobile telephone.  Because the mobile<br>
telephone user, as determined at decision state 120. is not associated with a fixed location, the process 108 moves to a<br>
state 128 for handling non-routable exceptions.   An operator will then request location information from the mobile<br>
telephone caller.   Additional information about state 128 will be provided below,  H the caller a not using a mobile telephone, the process 108 continues from state 120 to state 121<br>
6. At state 122, the process 108 performs a look-up function. Le.. looks up the caller's telephone number preferably using the well-known Indexed Sequential Access Method (ISAM), in one embodntent to index the Master Telephone Number to Zip+4 Table 107 (Figure 1b). ISAM is a well known method of searching described in the book Operating System Concepts by Peterson and Srtberschatz. In other embodiments, a determnet (unction is used to determine the appropriate spatial key. Other look-up or determining techniques may be used m other embodiments. The Master Table 107 was described in the System Overview section. As an example, a segment of a Master Table 107 is shown in Table 1. This table is indexed by phone number and also contains the zip+4 code 132 of the physical address where the calling phone is physically located.<br>
TABLE 1<br>
Example: Master Telephone Number to Zip+4 Table segment<br>
(Table Removed) <br>
7.	A test is performed at a decision state 126 to determine if the calling number is listed m the Master Table<br>
107. If not. the process 108 moves to state 128 wherein operator assistance is provided to route the cad. The non-<br>
routable exception handling at state 128 is for situations wherein a Master Table 107 or Client Table (Figure 1a) entry is<br>
missing, incorrect, or the caller is using a mobile telephone. In the presently preferred embodiment operator assistance is<br>
provided by AT&amp;T American Transtech, hi general, only a small percentage of the calling numbers are not listed in the<br>
Master Table 107. If the calling number is listed in the Master Table 107. the process 108 advances to a decision state<br>
130 to determine rf there is a zip+4 code 132 corresponding to the calling number in the packet 114. H not the process<br>
108 moves to state 128 wherein operator assistance is provided to route the call as mentioned previously. If a zip+4<br>
code 132 is located in the Master Table 107, the process 108 moves on to state 134.<br>
8.	Since the information packet 114 also contains the number dialed, at state 134 the process 108 opens the<br>
Client Zip+4 to Service Location Table A 106a that is associated with the client having the telephone number 800482<br>
5426. The Client Table 106 is selected from a plurality of Client Tables based on the telephone number dialed by the<br>
caller.  Client Table B 106b and additional tables, as necessary, are for other clients or other phone numbers, e.g., another<br>
"800" number, of the same client. The Client Tables are built by the assignee of the present invention, the client or a third<br>
pany to the assignee'! specifications. There are two types of Client Tables. If calls are to be routed to the closest location or to a service location servicini a non-overlapping polygon trade area, the first type of Client Table contains only a single entry per zip+4 code with its corresponding service phone number 146 and distance. In cases where the client wants a random or weighted selection, from multiple selections, whose service areas service the caller or provide the caller a choice, the second type of Client Table CM have multiple records per zip+4 code, with each record having a different service telephone number and distance. The process 108 looks up the caller's zip+4 code in the MyPtzza Client Table 106a using the Indeied Sequential Access Method.<br>
9. A test is performed at a decision state 140 to determine if the zip+4 code 132 is listed in the Client Table 106a. If not the process 108 moves to state 128 wherein operator assistance is provided to route the call. If the zip+4 code is in the Client Table 106a, the process 108 proceeds to a decision state 142 to determine whether there is a client telephone listing for the zip+4 code 132. If not, the process 108 moves to state 144 wherein operator assistance is provided to route the call, provide information, or take other action as determined by the client. A negative test result determined at state 142, may arise, tor example, if there is no service location whose service area encompasses the location of the calling party. The exception handling at state 144 is for situations where the call is correctly routed, taut the calling party does not get what is expected, Le., the call is not satisfactorily completed (as in states 142. 15Z and 154). In these situations, the client may select from a set of alternatives that can be handled by an automated process. An example exception handling message is as follows: "We are sorry, but there is currently no service location that services your location. If you desire to talk to a representative, please press zero."<br>
If there is a client telephone number associated with the zip+4 code 132, the process 108 advances to state 148. As an example, a segment of Client Table 106a is shown in Table 2.<br>
TABLE 2 Example: 800482-5426 Client Table segment<br>
(Table Removed)<br>
10.	After fining the cafler's zip+4 code 132 and the corresponding service telephone number 146, the switch,<br>
at state 148, sends the information packet over the telephone network to ring at the telephone associated with the<br>
number 619481-7777.<br>
11.	At block 150. the telephone at MyPizza located at 2688 Via De La Valle in Del Mar, CA 92014-1909.<br>
"Location C" 164 (Figure 2), rings.<br><br>
12. If the telephone at the dtent service location ts "busy* 152 or there is "no answer* 154. the process 108 proceeds to the exception handling state 144 as described previously. At the client's request, the exception handling at state 144 may. for instance, route the cal to the next closest service location. Otherwise, if the "busy" or "no answer" conditions are false, the telephone cal is answered and the cater may. for example, order a pizza.<br>
III. General Client Table Build Process<br>
The process 105 (Figure la) of creating or building a Client Table 106 for each client or each "BOO", or similar number, for the client will now be described. This process is preferably performed on a general purpose computer, such as an AT&amp;T 3600 UNIX box. As previously mentioned, the present invention includes two types of service area definitions: radius and polygon. Mow these two derntions are incorporated into the client table build process will be discussed below, in addition, the post-build process of eliminating more distant records from the client table to create a client table containing only the closest service location to a caller will also be discussed. This is used to reduce disk storage in applications where there is no means for providing the caller a choice and only one service location telephone number can be passed to the telecommunications network. An example of the process steps win be given using a fictitious food service business.<br>
The process for each type of service area definition utilizes four input files as shown in Figure la. The Zip+4 Centroid file and Zip Windows file were briefly discussed in the System Overview section. Each input file is now further described. The following discussion again refers to Figure la.<br>
A.	Client Service Locations Rle<br>
The first file is a Client Service Locations file 109 containing a list of service locations provided by the client. The service locations and their service areas are defined by either a latitude/longitude location and a radius or a latitude/longitude location and a latitude/longitude polygon. Further detail about file 109 is provided in conjunction with state 174 of Figure 3 (radius) and state 604 of Figure 12a (polygon).<br>
B.	zip+4 Lat Ion Centroid File<br>
The second file is the Zip+4 Latitude and Longitude Centroid file 100 or Zip+4_lat_lon Centroid fie previously described. This file is available from the U.S. Postal Service or from, for example. Geographic Data Technology, Inc. (GOT).<br>
C.	Zip Array Fite<br>
The third file is a Zip Array fife 103 created from the Zip+4 Latitude and Longitude Centroid file 100 and provides three benefits that mprove processing efficiency.<br>
The first benefit is building an array where the row number of the array is equal to a 5-digit zip code. This provides a very efficient method of indexing to a 5-digit zip code where the 5-digit zip code number is the row number of the array.<br>
The second benefit is once the 5 digit zip code is accessed in the array, the exact byte offset of where the first zip+4 code for this 5-digit zip code starts in the Zip+4 Latitude and Longitude Centroid file 100 is known. Using this method, it is very efficient to advance te the location of the first zip+4 record and read all the zip+4 records tor a 5-digit zip code m the over 28 million record Zip+4 Latitude and Longitude Centroid file 100.<br>
The third benefit of the Zip Array file 103 is that for each five digit zip code, the file contains the latitude and longitude minimum: and maximum for all the zip+4 codes in the 5 digit zip code. By checking to see if a radius or a polygon service area set of extremes overlap with the 5-digh zip code extremes, testing each zip+4 in a 5-digit zip code is eliminated, if it is determined beforehand that there is no spatial overlap between the zip+4 extremes in a 5-digit zip code and the radius or polygon service area.<br>
The Zip Array file 103 is created using the GOT or Post Office supplied zip+4 Latitude and Longitude Centroid file 100. Each record in the Centroid file 100 contains a zip+4 number, and the latitude and longitude defined centroid for each zip+4. A four step. Zip Array File Build process 101, as follows, is used to create the Zip Array file 103:<br>
1.) A 32-bit integer array of 99,999 rows and 6 columns is initialized to zero. Column one is initialized to the row number which is then utilized as the 5-digit zip code.<br>
2.1 For a 5-digit zip code, every zip+4 record in the Zip+4 Latitude and Longitude Centroid file 100 is read in a sequential manner. The byte offset for the first zip+4 within the 5-digit zip code is noted. Temporary variables are initialized and then used to determine the latitude and longitude minimums and maximums of the zip+4 centroids for the current 5-digit zip code. The greatest and least of both the latitudes and longitudes among all zip+4 codes for the current 5-digit zip code are then passed on to the next step.<br>
3.) With each change in 5-digit zip code, the byte offset for the first zip+4 within a 5-digit zip code and the latitude and longitude minimums and maximums for all zip+4 codes within a five digit zip code are written to memory lor the previous 5-digit zip code to its location in the Zip Array file 103. The latitude and longitude minimum and maximum values are then reinitiated, and the previous and current steps are repeated with the next 5-digit zip code until the end ol the zip+4 Centroid file 100 is reached.<br>
4.) Upon reaching the end of the Zip+4 Centroid file 100, the last 5-digit zip code record is written to memory, and then the Zip Array file stored in memory is written to a mass storage device such as a magnetic disk.<br>
The column definitions for each row of the Zip Array file 103 are as follows:<br>
column(1) is the 5-digit zip code number;<br>
column(2) is the byte_offset into the zip+4 lat lon Centroid file 100 of the location of the lowest numbered zip+4 for the 5-digit zip code of that row:<br>
column(3) is a minimum latitude for the zip code of that row (zip_lat_min);<br>
column(4) is a maximum latitude (zip_lat_max);<br>
column(S) is a minimum longitude (zip_lon_min); and<br>
column(6) is a maximum longitude (zip_lon_max). D. Zio Windows Re<br>
The fourth file is the Zip_windows file 104. The purpose of this file is to build a linkage between a latitude and longitude defined area on the earth and the zip codes that could theoretically touch this area. This linkage provides benefit by making spatial computer searches of postal geography much faster and much more efficient.<br>
The Zip_windows file 104 is created from the GOT or Post Office zip+4 Latitude and Longitude Centroid file 100 using latitude and longitude 5 digit zip code extremes created from the Zip+4 extremes within a 5 digit zip code. The general concept is to divide the earth into one tenth of one degree (0.1°) latitude and longitude rectangles, which, for example, are approximately 6.9 mites by 5.2 miles m dimension at 40" latitude, and then tabulate al zip codes that overlap each rectangle.<br>
The Zip_windows file 104 is created by a Zip Windows File Build process 102 that reads each record from the over 28 million record Zip+4 Centroid file 100 and writes a corresponding record that contains a latitude and longitude (lat/lon) window and a 5-digit zip code. The Ut/lon window field is created by multiplying the latitude in degrees times 10, taking the integer portion (INT) of the product multiplying the integer portion by 10.000, and then adding the integer portion of the product of the longitude in degrees times 10.<br>
For example, if the input zip+4 record is 920141909. the latitude is 32.9862 North and the longitude is 117.2522 West, the output zip_window record would be 3291172 for the lat/lon window and a zip code of 92014. After all records have been written to an initial or temporary Zip_windows file (not shown), the file is then sorted by the lat/lon window value or key with the corresponding 5-digit zip code, and duplicate records are eliminated. The resultant final Zip_wmdows file 104 is then written with each record composed of the lat/lon window key and the corresponding 5-digit zip code. Four lat/lon windows 210,212. 214, 216. corresponding respectively to zip window keys 3301172. 3301171, 3291172.3291171, are illustrated in Figure 4.<br>
Now that the input files utilized by the Client Table Build process have been described, each of the three different service area definition build processes wiH be described.<br>
IV. Client Table Build Process for a Radius Defined Service Area<br>
Referring generally to Rgures 3 and 4, a Client Table Process 170 for a radius defined service area will be described. Process 170 is a specific version of the client table build process 105 shown in Figure la.<br>
The process 170 begins at a start state 172 and moves to state 174 wherein a diem provides a Client Service Locations file 109 (Figure 1a) of service locations in machine readable form with information and format as shown 'm Table 3. The file 109 can be created by. for example, a commonly available word processing program or a database program, and submitted on a floppy disk or other suitable media. Table 3 includes example information for a service location 218 named MyPizza Ristorante. The map of Figure 4 illustrates some of the same information including a circle 220 to show a 2.5 mile radius from the MyPizza Ristorante as the service area.<br>
TABLE 3<br>
Record layout m ASCII Characters<br>
(Table Removed)<br>
Of course, other forms, information, and formats may be substituted in other embodiments.<br>
The process 170 moves to state 176 wherein the list of service locations in file 109 is address standardized, zip+4 coded, and latitude and longitude geocoded using commercially available services through companies such as Group t and Geographic Data Technology. Table 4 is an example of a standardized record with latitude and longitude appended.<br>
TABLE 4<br>
(Table Removed)<br>
Moving to state 178, the process 170 establishes the constant of 68.9404 mites per degree latitude and reads the Zip Array file 103 (Figure la) into memory of the computer. At state 180, the process 170 reads a record from the file of service location records and calculates the number of miles per degree longitude for the service location. The miles per degree longitude - 68.9404 * COSINE(latitude). For the example given in Table 4. at 32.9862 degrees latitude, the result is 57.8297 miles per degree longitude.<br>
The process 170 proceeds to a function 182 which creates a fist of zip windows that the service location touches. Touching a zip window means that at least part of the service area is in or overlaps the zip window. The zip windows 210.212.214,216 for the example given in Table 4 are illustrated in Figure 4. The function 182 will be further described in conjunction with Figure 5 hereinbelow.<br>
Moving to a function 184, the process 170 generates a list of 5-digit zip codes that touch any of the zip windows identified by function 181 This zip list is sorted in ascending order and duplicate zip codes are removed in the function 184. The function 184 wi be further described in conjunction with Figure 7 hereinbelow.<br>
The process 170 proceeds to a function 186 wherein 5-digit zip codes that are not within the service location site radius specified in state 174 are removed from the zip list generated by function 184, and a zip final list is created. The function 186 will be further described in conjunction with Figure 9 hereinbelow.<br>
Advancing to function 188. the process 170 retrieves all the zip+4 records corresponding to the zip codes in the zip final list (generated by function 186), used in conjunction with a zip pointer list (also generated by function 186), and<br>
determines if the zip+4 is at of inside the service area radius. This determination also yields the distance from the service location to the zip+4 centroid (recaing that the zip+4 centroids are stored in the Zip+4 Centroid file 100). If the zip+ 4 is determined to be at or inside the service area radius, a raw Client Table record is written that includes the zip+4 code. the dient telephone number for the instant service location, and the distance of the zip+4 centroid to the service location. The function 188 will be further described in conjunction with Figure 10 hereinbelow.<br>
The process 170 moves to a decision state 190 to determine if additional client service records are to be processed. If so, the loop of states 180 to 188 is repeated for the next service location record. If all service location records have been processed for the instant Client Table, the process 170 advances to state 192. At state 192, the process 170 sorts the raw records, written by function 188. by ascending zip+4 code and then by descending distance if the same zip+4 code is listed more than once. The same zip+4 code could be listed more than once if there are multiple service locations whose service areas overlap the zip+4.<br>
Moving to a decision state 194. a determination is made if the client has selected the post-build option of generating the client table for the service locations closest to the caller. If not. the client table build process is complete except for loading the file to the production system computer at state 198. However, if the client has selected the post-build option of 'closest service location*, as determined at decision state 194. the process 170 moves to a function 196 to finish the Client Table build process. The function 196 will be further described in conjunction with Figure 11 hereinbelow.<br>
If the client has not selected the "closest location" option at decision state 194, the process 170 moves to a state 198 wherein the sorted Client Table from state 192 is loaded into the computer in the telephone network switch 111 (Figure 1c), and an index key on the zip+4 codes is built. Upon completion of either function 196 or state 198, the Client Table build process ends at state 200.<br>
Referring generally to Figure 5, the function 182 defined in Figure 3 will be described. Function 182 generates a list of zip windows that the site touches by first calculating site latitude and longitude extremes. For this calculation, the absolute value is used for both the latitude and longitude.<br>
In another embodiment of the present invention, a prefix is assigned to the window key based on the sign of the latitude or longitude. The United Stales is located in the Northwest quadrant and the key for this quadrant is zerolOL A leading zero has no impact on the value of the numeric key. The other quadrants are Northeast east of the prime meridian at Greenwich, England in the Northern hemisphere; Southwest, west of the prime meridian in the Southern hemisphere; and Southeast, east of the prime meridian in the Southern hemisphere.<br>
Since almost aR countries of the world are only in one quadrant using the absolute value of the latitude and longitude works weft. In the few countries that are exceptions (that are in two quadrants), a different coordinate system may be used, e.g., the Ordinance Survey system used in the United Kingdom.<br>
Beginning at a start state 252 shown in Fqure 5. the process 170 moves to a state 254 to calculate latitude extremes of the service area. Several abbreviations wiH be used heremforward: "min" for minimum, "max" for maximum, "lat" for latitude, "Ion" for longitude and "she" for the site or location of the service location.<br>
Sitejat_mm - site_lat - radiuslmtest/miles per degree Ut Site lat_mai - she_lat + radmsdnilesl/intles per degree lat.<br>
Computation for the example service location and radius given in Table 4 yields: Sitejatjnin - 32.9862-2.5/68.9404 - 32.9499; Sitejatjnax - 32.9862 + 2.51683404 - 33.0228.<br>
The process continues at state 256 wherein longitude eitremes of the service area are calculated: Srte_lon_min - shejon- raafeswritesUmiies per degree ion; Site_lon_max - sitejon + radHKfrnilesWmfes per degree Ion.<br>
Computation for the example service location and radius given in Table 4 yields: Srte_lon_min - 117.2522-15/57.8297 - 117.2089; Shejonjnax - 117.2522 * 2,5/57.8297 - 117.2954.<br>
Moving to states 258 and 260, the process 170 builds values for zip window minimum and maximum based on the site latitude and longitude, respectively. Computation using the above example and results yields: Site_lat_window_min - lnt(10*Site_lat_min) - 329; Site_lat_window_max - IntdO'Site_lat_max) - 330; Sitejon_window_min - lM(10*siteJonjnin) - 1172; Site_ton_window_min - lnt(10*sitejonjnax&gt; - 1172.<br>
Moving to a function 262, the process 170 generates zip windows based on latitude min and max values, and longitude min and max values and stores them n a zjpjmndowsjist. which is distinct from the 2ip_wmdows file 104 (Figure 1a). Function 262 wiH be further described below in conjunction with Figure 6. The function 1B2 returns at state 264 to Figure 3.<br>
Referring to Figure 6, the function 262 defined in Figure 5 win be described. Function 262 builds the actual zJp_wmdow_Bst for the service location. The function begins at a start state 270 and moves to state 272 wherein the variable I is set to equal zero (0), and the variable J is set to equal the value for the site latitude window minimum. After the initialization of state 272. the process 170 moves to state 274 wherein the variable K is set equal to the value for the site longitude window minimum. Moving to state 276, the value of variable I is incremented by one.<br>
At state 278, a value of the zip_window_ist identified or addressed by the value of variable I. is calculated as the value of the variable J multiplied by 10000 and then adding the value of variable K. State 280 determines whether the value of K has reached the maximum value, and if not the value of K is incremented by one (1) at state 282, and a loop to state 276 is performed. If K has reached the maximum site longitude value, the process 170 continues at state 284 to determine whether the value of J has reached the maximum value, and if not, the value of J is incremented by one (1) at<br><br>
state 286, and a loop to state 274 is performed.  If J has reached the maximum she latitude value, the function 262 returns at state 288 to Figure 5.<br>
Continuing the example given in conjunction with Figure 5. the result of (unction 262 is as follows:<br>
Zip_windowjist{1) - 3291172<br>
Zip_window_list(2) - 3301172<br>
Referring to Figure 7. the function 184 defined in Figure 3 will be described. Function 184 generates a fast of 5 digit zip codes touching the zip windows identified by fcfiiction 182 (Figure 5). Beginning at a start state 300. the process 170 moves to a state 302 and retrieves the Zip_windows file 104 (Figure la) previously described and the zip_window_list from function 182. The Zip_windows file 104 is indexed by the zip_window key and contains a list of all zip codes that touch the zip window. A sample of the Zip_windows file 104 is given in Table 5. which corresponds with Figure 4.<br>
TABLE 5<br>
(Table Removed)<br>
Continuing at state 304. the process 170 initializes the variable K to the value of zero (0) and the variable J to the value of one (1). Then at state 306, the process 170 advances to the record in the Zip_windows file 104 having the key equivalent to the value of the zip_window_fist addressed by the variable J. At state 308, the record accessed at state 306 is read to get the np_window and the associated zip code. Moving to state 310, the variable K is incremented by one (1), followed by state 312 wherein zip code read at state 308 is written to a zipjist addressed by the variable K. A check is then made at a decision state 314 to determine if the value of the zip_wmdow from state 308 is greater than the value of the zip_window_list addressed by the variable J. If not, the next record in the Zip_wmdows (He 104 is read by looping back to state 308.<br>
If the decision state 314 test is true, the process moves to a decision state 316 to determine if the value of J is equivalent to the number of windows in the zip_window_list. If not the value of J is incremented by one (1) and a loop<br>
back to state 306 is performed to process the next window,   li the decision state 316 is true, all windows in the<br>
zip_window_list have been processed, and the function 184 continues at state 320 wherein the zipjist of 5-digit zip codes is sorted in ascending order.  For the continuing example, after state 320. the zipjist appears as follows:<br>
92007<br>
92014<br>
92014<br>
92024<br>
92029<br>
92075<br>
92075<br>
92130<br>
Moving to a function 322, the process 170 removes duplicate entries in the zipjist to generate a deduped_zipjist. Function 322 will be further described in conjunction with Figure 8 below. The function 184 returns at state 324 to Figure 3.<br>
Referring to Figure 8. the function 322 defined in Figure 7 will be described. Function 322 removes duplicate 5-digit zip codes from the zipjist as sorted in state 320 of Figure 7. Beginning at a start state 340, the process 170 moves to a state 342, and the first entry of zipjist is defined to be the first entry of a deduped_zipjist. Proceeding to state 344. a variable L is assigned the value of one (1) and a variable J is assigned the value of two (2). Then at a decision state 346, the process 170 determines whether the value of zipjist addressed by J is equivalent to the value of zipjist addressed by "J minus one". If not, variable L is incremented by one at state 348, and the next entry in deduped_zip Jist as addressed by L is written to be equivalent to the entry in the zipjist as addressed by J.<br>
If the decision state 346 is false or at the completion of state 350, the process 170 moves to a decision state 352 to determine rf the value of variable J is equal to the number of zip codes in the zipjist   If not variable J is incremented by one at state 354, and the process 170 loops back to state 346 to check the next entry in zipjist However, if all zip codes in zipjist are checked, as determined by state 352. the function 322 returns at state 356 to Figure 7. For the continuing example, the deduped_zip_list at the completion of function 322 is as follows:<br>
92007<br>
92014<br>
92024<br>
92029<br>
92075<br>
92130<br>
Refemng to Figure 9. the function 186 defined in Figure 3 will be described Function 186 builds a zip final list and a zip pointer list by checking zip boundary extremes and getting an offset to the start of the Zip+4_lat_lon Centroid file 100 (Figure la) from the Zip Array file 103. This procedure eliminates zip codes that do not touch the area covered by the radius of the service area. Beginning at a start state 370. the process 170 moves to a state 372 and accesses the Zip Array file 103 (Figure la). Function 186 utilizes all columns, as previously described, of the Zip Array file 103 (Figure la). Moving to state 374. variable I is set to a value of zero, and variable J is set to a value of one. Proceeding to state 376, variable M is set equivalent to the entry in deduped_zip_hst. from function 184, addressed by J.<br>
Using the she information calculated in Function 182 and the information from the zip array table, a series ot checks are performed by decision states 378 to 384. At decision state 378, the process 170 determines whether the sitejatjnax is less than the zipjatjnin for the Zip Array file entry addressed by the variable M. If so. the process 170 moves to a decision state 386. II not. the process continues at decision state 380. At decision state 380, the process 170 determines whether the sitejatjnin is greater than the zip_lat_max for the Zip Array file entry addressed by the variable M. if so. the process 170 moves to decision state 386. If not the process continues at decision state 382.<br>
At decision state 382, the process 170 determines whether the sitejonjnax is less than the zip_lon_min for the Zip Array file entry addressed by the variable M. If so. the process 170 moves to decision state 386. If not, the process continues at decision state 384. At decision state 384, the process 170 determines whether the sitejon_mm is greater than the zip_lon_max for the Zip Array file entry addressed by the variable M. If so, the process 170 moves to decision state 386. If not, the process continues at state 391 To get to state 392, a determination has been made that the zip code does touch the area covered by the radius of the site. At state 392. variable I is incremented by one, and at state 394. the process 170 writes the value of M to the zip_final list entry addressed by I. Moving to state 396, the process 170 writes the value of byte_offset from the Zip Array file entry addressed by the variable M to the zip_pointer hst entry addressed by I, and the process moves to state 386.<br>
If any of the decision states 378 to 384 is true, the current zip code entry from deduped_zip_list is not further used. At decision state 386. a determination is made whether all entries in the dsduped_zip_list have been checked. If not. J is incremented by one at state 388, and the process 170 loops back to state 376 to check the next entry. If all entries have been checked as determined by state 386, the function 186 returns at state 398 to Figure 3. For the continuing example, the zipjinal list at the completion of function 186 is as follows:<br>
92007 92014 92075 92130<br>
Referring to Figure 10. the function 188 defined in Figure 3 will be described. Function 188 reads all zip+4 records as identified by the combination of the zip_final list and zip_pointer list, and determines if the zip+4 centroids are inside the site radius. Beginning at a start state 420, the process 170 moves to a state 422 and gets the zipjinal list.<br>
the zip_pointer list, and the Zip+4 Centred file 100. At state 424, variable J is set to a value of one. Moving to state 426, the process 170 advances in the Zip+4 Centroid fie to the address contained in the zip_pointer list addressed by the variable J. Then, at state 428, the zip+4 latitude/longitude record is read at the address from state 426. The Zip+4 Centrotd fie 100 (Figure la) is sorted in ascending zip+4 order, and each record in this file contains three fields: zip+4 code, latitude in degrees, and longitude in degrees. Moving to state 430, the process 170 calculates the distance from the service location to the zip+4 centroid. The site latitude and longitude are available from state 176 while the zip+4 latitude and longitude are available from state 428. Moving to state 432. the process 170 determines rf the distance squared from state 430 is greater than the radius squared (which is available from state 174). If not, the zip+4 code is inside the she radius, and the process 170 moves to state 434 to write a raw client table zip+4 telephone number record. This record contains the zip+4 code, the telephone number of the client service location, and the square root of the distance squared.<br>
H the distance squared is greater than the radius squared, the zip+4 code is outside the site radius, and the process moves to a decision state 438. At state 438, the process 170 determines rf the current zip+4 code is greater than 10000 times the value of the zipjinal list entry addressed by the variable J plus 9999. The current zip+4 is compared to a value for the highest possible numbered zip+4 for the current zip code by appending 9999 to the 5-digrt zip code. For example, if the zip code is 92007, the highest possible number for a zip+4 for this zip code is 920079999. While reading the zip+4 records for zip code 92007, if the zip+4 record read is greater than 920079999, then the end of zip+4 records for the 92007 zip code is passed, and the process 170 moves to the next zip code in the zip_final list. If the decision state 436 is false, the process 170 moves to state 438 and advances to the next zip+4 record for the same 5-dkjrt zip code in the Zip+4 Centroid file 100. The next record is read by looping back to state 428.<br>
If decision state 436 is true, the process 170 moves to a decision state 440 to determine if all records m the npjmal list have been read. If not the variable J is incremented by one at state 442, and the process loops back to state 426 and repeats the procedure for the next 5-digit zip code in the zipjinal list. If all 5-digit zip codes have been processed as determined by state 440, the function IBS returns at state 444 to Figure 3. For the continuing example, a sample record of the raw Client table at the completion of state 434 is as follows: Sample record: 920752064 6194817777 1.2865.<br>
V. Client Table Build Process for the Service location Closest to the Caller<br>
The "closest" process, function 196 (Figure 31 is a post-build process for building a Client Table 106 created from radius defined service areas, polygon defined service areas or a mix of both types of service areas. The primary functions of the "closest" process are to reduce disk storage and dean up polygon digitizing errors that create minor overlaps in non-overlapping service areas. States 172 to 194 (Figure 3) in the radius process or states 602 to 624 (Figure 12a) in a polygon process must be completed to create an intermediate client table that can be reduced in size and or cleaned up by the post-build process 196.<br>
Referring to Figure 11. function 196 as defined in Figure 3 will be described. Function 196 removes multiple assignments of a zip+4 code and keeps the one with the shortest distance. Beginning at a start state 500. function 196<br>
accesses the sorted intermediate Client Table (not shown) which is available at the completion of state 192. Moving to state 504, a variable "last_zip+4" is set equal to the value of zero. Then, at state 506. beginning with the first record, a record is read from the intermediate Client Table. Moving to a decision state 508, a determination is made whether the zip+4 just read in the record from state 506 is equivalent to the value of last_zip+4. If not, the current record is written to the Client Table 106 at state 510, followed by setting the variable last zip+4 equivalent to the current zip+4 code at state 511<br>
At the completion of state 512, a decision state 514 determines if the end of the sorted intermediate Client Table has been reached. If not, the function 196 advances to the next zip+4 code in the intermediate Client Table and loops back to state 506 to process the next record. H the end of the intermediate Client Table has been reached as determined by state 514, the Client Table 106 is loaded in the computer of the telephone switch 111 and an index key on the zip+4 code is built. Function 196 returns at state 520 to state 200 of Figure 3 to end the "closest" process. VI. Client Table Build Process for a Polygon Defined Service Area<br>
In general, there are two types of polygon defined service areas. The first type is an exclusive or non-overlapping trade area, and the second type is a non-exclusive or overlapping trade area.<br>
For a non-overlapping polygon defined service area, each franchisee has a defined trade area, such as the area in which they deliver a product. The following situation is given to illustrate this concept. A customer could be located closer to, say, Franchisee 8 than Franchisee A, but if the customer is in the polygon area for Franchisee A, only the telephone number for Franchisee A will be in the Client Table 106 (Figure la) record corresponding to the location of the customer. However, if the service areas for Franchisee A and Franchisee B are overlapping, the Client Table 106 would have one record with the telephone number and distance for Franchisee A, and another record with the telephone number and distance for Franchisee B. Therefore, the client table build process 105 accommodates both types of polygon defined service areas.<br>
Referring generally to Figures 12a, 12b, and 13, a Client Table process 600 for a polygon defined service area . will be described. Process 600 is another specific version of the general process 105 shown in Figure la. Many parts of the polygon defined service area process 600 (also referred to as the polygon process) are identical with those of the radius defined service area process 170. Some functions have minor changes. Other functions are totally different For functions that are almost identical only the differences wl be identified and explained to avoid repetition. The new functions will be described in some detail.<br>
The process 600 begins at a start state 602 and moves to state 604 wherein a client provides a Client Service Locations file 109 (Figure la) of service locations in machine readable form with information and format as previously shown in Table 3. The client also provides a detailed street map with the polygon service area of the service location drawn on the street map with the telephone number of the service location written inside the polygon service area. The map of Figure 13 illustrates an example polygon service area 640.<br>
The process 600 moves to state 606 wherein the list of service locations in file 109 is address standardized, zip+4 coded, and latitude and longitude geocoded using commercially available services through companies such as Group<br>
I and Geographic Data Technology. Table 4 is the example of a standardized record with latitude and longitude appended. In addition, the latitude and longitude vertices for the polygon service area drawn on the street map are digitized using a commercially available GIS system such as Infomark for Windows available from Equifax National Decision Systems. The digitizing process of state 606 assigns latitude and longitude coordinates for the vertices of the polygon and creates a Polygon file 607 as shown in Figure 12b. An example of the Polygon file 607 is shown in Table 6 with the following data items:<br>
TABLE 6<br>
(Table Removed)<br>
The last latitude/longitude vertex pair must equal the first pair to close the polygon. This example is for a very simple polygon. Typical franchise polygons are very complex; the polygon may follow non-linear street boundaries and contain hundreds of vertices. The geocode is the telephone number of the service location. The Polygon file data is appended to the end of its corresponding record of the Client Service Locations file 109, creating a variable length record.<br>
Moving to state 60S, the process 600 establishes tne constant of 68.9404 miles per degree latitude and reads the Zip Array file 103 (Figure 1a) into memory of the computer. At state 610, the process 500 reads a record from the Client Service Location file 109 and calculates the number of miles per degree longitude for the service location. The miles per degree longitude - 68.9404 * COStNE(latitude). For the example given hi Table 4, at 319862 degrees latitude the result is 57.8297 mites per degree longitude.<br>
The process 600 proceeds to a function 612 which generates a fist of zip windows that the service location touches. Touching a zip window means that at least part of the service area is in or overlaps the zip window. The zip windows for the example given in Table 4 are illustrated in Figure 13. The function 612 will be further described in conjunction with Figure 14 hereinbdow.<br>
Moving to a function 614, the process 600 generates a list of 5-digrt zip codes that touch any of the zip windows identified by function 611  This zip Est is sorted in ascending order and duplicate zip codes are removed in function 614. The function 614 wiH be further described in conjunction with Figure 16 nereinbelow.<br>
The process 600 proceeds to a function 616 wherein 5-digrt zip codes that are not within the polygon service area specified in state 604 are removed from the zip list generated by function 614, and a zip final list is created. The function 616 will be further described in conjunction with Figure 18 hereinbelow.<br>
Advancing to function 618, the process 600 builds a Line Index file 619 shown in Figure 12bof discrete latitude and longitude points that define the polygon. Function 618 will be further described in conjunction with Figure 19a and 19bhereinbelow.<br>
Continuing to function 620, the process 600 retrieves an the zip+4 records corresponding to the zip codes in the zip final list generated by function 616 and determines if the zip+4 code is at or inside the polygon service area. If so, a record is written in a raw Client Table Inot shown) that includes the zip+4 code, the client telephone number for the instant service location, and the distance of the zip+4 cemroid to the service location. The function 620 will be further described in conjunction with Figure 20 hereinbelow.<br>
The process 600 moves to a decision state 622 to determine if additional client service records are to be processed. If so, the loop of states 610 to 620 is repeated for the next service location record. If all service location records have been processed for the instant raw Client Table, the process 600 advances to state 624. At state 624, the process 600 sorts the raw records, written by function 620, by ascending zip+4 code and then by descending distance, if the same zip+4 code is listed more than once. The same zip+4 code could be listed more than once if there are multiple overlapping polygon service locations, each with a different client telephone number.<br>
The process 600 then moves to a state 626 wherein the sorted Client Table from state 624 is loaded onto the computer of the telephone network switch 111, and an index key on the zip+4 codes is built. Upon completion of state 626. the Client Table build process 600 for a polygon defined service area ends at state 628.<br>
Referring generally to Figure 14, the function 612 defined in Figure 12a will be described. Function 612 generates a list of zip windows that the site touches by first calculating site latitude and longitude extremes. For this function, the absolute value is used for both the latitude and longitude.<br>
Beginning at a start state 670, the process 600 moves to a state 672 to establish latitude extremes of the service area. The Polygon file 607 is accessed to retiieve the polygon vertices latitude minimum and maximum values.<br>
Site_lat_min - polygon_lat_min;<br>
She_lat_max - polygon_lat_mar.<br>
For the example service location and polygon given in Table 6, the results are as follows: Sitejatjnin - 32.9503; Site_lat_max - 33.0187.<br>
The process continues at state 674 wherein longitude extremes of the service area are established. The polygon vertices longitude minimum and maximum values are retrieved from the Polygon file 607.<br>
Sitejonjnin - polygonjonjnin;<br>
Sitejonjnax - polygon_tan_max.<br>
For the example service location and polygon given m Table 6. the results are as follows:<br>
Sttejonjmn - 117.2084; Sitejonjnax - 117.2910.<br>
States 676 and 678 are identical to states 258 and 260 of function 162 (Figure 5). As defined in Figure 14, function 680 (Figure 15) is identical to function 262 (Figure 6). Function 612 returns at state 682 to Figure 12a.<br>
As defined in Figure 12a, function 614 (Figure 16) is identical to function 184 (Figure 7). As defined in Figure 16, function 752 (Figure 17) is identical to function 322 (Figure 8). As defined in Figure 12a, function 616 (Figure 18) is identical to function 186 (Figure 9).<br>
Referring to Figures 19a and 19b, the function 618 defined in Figure 12a will be described. Function 618 builds the Line Index file 619 by rounding all modified polygon vertices latitudes and longitudes to an integer value, thereby creating a record of every discrete point along the line generated by connecting adjacent vertices listed in the Polygon file 607. The modification performed to the polygon vertices is subtracting the sitejatjnin or sitejonjnin as will be seen below.<br>
Beginning at a start state 830. the process 600 moves to a state 832 and initializes a variable J to equal the value one. Moving to state 834. the process 600 initializes a tangent (denoted by T in Figure 19) array element addressed by the variable J to equal the value zero. At state 836, a latitude array (denoted by "LAT" in Figure 19) element addressed by J is written to the value calculated by. subtracting shejatjnin (available from function 612. Figure 14) from the vertices latitude (lat_vertices) addressed by J in the Polygon file 607 (available from state 606), multiplying the result by 10,000, and then taking the integer (INT) portion of the product. Advancing to state 838, a longitude array (denoted by ION" in Figure 19) element addressed by J is written to the value calculated by: subtracting sitejonjnin (available from function 612, Figure 14) from the vertices longitude (lon_vertices) addressed by J in the Polygon file 607 (available Irom state 606), multiplying the result by 10,000. and then taking the integer portion of the product.<br>
At a decision state 840. the process 600 determines if all vertices in the Polygon file 607 have been processed. The number of vertices is available from state 606 as shown in the example in Table 6. If not. variable J is incremented by one at state 842. and the process 600 loops back to state 834 to process the next vertices. If all vertices have been processed, variable J is set equal to the value two at state 844.<br>
States 846 through 860 are used to find vertices that are tangent to a latitude line. States 846 through 854 form a loop to sequence through al elements of the LAT array to determine if either of the conditions ot decision states 846 or 850 are met. If so. the element of the tangent array addressed by J is set equal to one. If not. the next element is checked, by incrementing J at state 854 and looping back to state 846. until the end of the LAT array is reached, i.e., all vertices are tested, and decision state 852 is true. Decision state 846 determines whether the values of the elements of array LAT immediately before and immediately after the current element are greater than the value of the current element. In other words, decision state 846 determines whether a latitude line is tangent to vertex(J). Decision state 850 determines whether the values of the elements of array LAT immediately before and immediately after the current element<br>
are less than the value of the current element in other words, decision state 850 determines whether a latitude line is tangent to vertexlJ).<br>
When J equals the number of vertices minus one, the process 600 moves to states 856 through 860 to perform the follow tests:<br>
decision state 856: If LATUI &gt; IAT(2) ANDLAT(I) &gt; LAT(number_vertices-1| thenT(J) - 1; decision state 860: If LAT(1) 
Number_vertices is used to represent the number of vertices as available from state 606. Decision states 856 through 860 test for a special case of previous states 846 through 854 to determine if vertex(l) is tangent to a latitude line. If so, the element of the tangent array addressed by J is set equal to one.<br>
At state 862, the process 600 sets variable J equal to one. Block 864 is an off page connector from Figure 19a to Figure 19b. Continuing on from block 864 on Figure 19b, the process 600 generates a pseudo-line of discrete latitude points connecting the polygon vertices. Each point that defines the line is deserted by an X.Y coordinate. Each Y coordinate or latitude point is one ten-thousandth of a degree latitude apart on the Y axis.<br>
Decision state 866 checks for parallel latitude lines, and if true, the process 600 moves to decision state 886 to determine if all vertices have been processed. If not J is incremented by one at state 888, and the process loops back to decision state 866 to check the next element of array LAT. If LAT(J) does not equal LAT(J+1) as determined by decision state 866, the process 600 moves to state 868, sets a variable K to equal the value of LAT(J), and moves to state 870.<br>
State 870 is used to leave out latitude tangent vertices points. State 870 determines if K is equivalent to LAT(J) and T(J) equals one. If so, the process 600 moves to decision state 882 to determine if K should be incremented by one at state 884, or if K has reached the value "LAT(J+1) 1" and decision state 886 is to be performed. If K is incremented at state 884. the process 600 loops back to decision state 870.<br>
If decision state 870 is false, the process 600 moves to state 872 to calculate a variable "deltajat' to be 'LAT(J) • LAT(J+11". At state 874, a variable "deltaJon* is calculated as the difference between the value of the array LON element addressed by J and the value of the array LON element addressed by J plus one. Moving to state 875. a variable "lat_point* is set equivalent to the value of variable K. State 878 is used to calculate a longitude (variable "lon_poim") for latitude line point using the following equation: lon_potnt - IMT«K-LAT(JI/delta_lat)' dehaJon+LONUI).<br>
Moving to state 880, the process 600 writes the values of latjraint and lon_point to the Line Index file and then loops back to decision state 882 to check on the value of K.<br>
At decision state 886, if J equals the number of vertices minus one, all vertices have been processed, and the process 600 moves to slate 890. At state 890, the process 6CO sons the Line Index file by ascending latitude point, and then by ascending longitude point within the latitude point. Moving to state 894, process 600 builds the Polygon Line Index file 619 using the latitude point as the indexing key. Function 618 returns at state 894 to Figure 12a.<br>
Referring to Figure 20, the function 620 defined m Figure 12a will be described. Function 620 reads all zip+4 records as identified by the combination of the zip_final list and zip_pomter list and determines if the zip+4 cemroids are inside the polygon service area.<br>
Beginning at a start state 910. the states 912 through 918 are identical to states 422 through 428 of function 188 (Figure 10). Then beginning at state 920 through state 926. the process 600 compares the latitude and longitude of the zip+4 centroid to the minimums and maximums of the site latitude and longitude available from function 612 (Rgure 14). In other words,the process 600 determines if the zip+4 centroid is inside the latitude and longitude extremes of the polygon service area. If not. at state 928 the process 600 advances to point to the next zip+4 record and then loops back to state 918 to read the zip+4 record.<br>
However, if the zip+4 centroid is determined to be inside the latitude and longitude extremes of the polygon service area by states 920 through 926. the process 600 moves a function 930. Function 930 is a final test to determine if the zip+4 centroid is indeed inside the polygon. The point-ii-polygon test of function 930 returns with either an "inside" flag or "outside" flag. If the zip+4 centroid is not inside the polygon, the "outside" flag is set by function 930, and the process 600 moves to state 928 to advance to the next zip+4 record. However, if the zip+4 centroid is inside the polygon, the "inside" flag is set by function 930, and the process 600 moves to state 932 to perform a distance calculation. State 932 is identical to state 430 of function 188 (Figure 10). States 934 through 940 and 928 are identical to states 434 through 442 of function 188. Function 620 returns at state 942 to Figure 12a.<br>
Referring to Figure 21, the function 930 defined in Rgure 20 will be described. Function 930 tests to determine if the zip+4 centroid is inside the polygon. Function 930 conceptually draws a line from the zip+4 latitude in a negative longitude direction and then counts the number of times the fine crosses the polygon boundary. If the line crosses an odd number of times, the ap+4 centroid is inside the polygon, but an even number of line crossings determines that the zip+4 centroid is outside the polygon.<br>
Beginning at a start state 960. the process 600 moves to state 962 to calculate a value for a variable "lat" by: subtracting srtejatjnin (available from function 612. Figure 14) from zip«-4Jat (available from the Zip+4 Centroid Tile 100), multiplying the result by 10,000, and then taking the integer (INT) portion of the product. Moving to state 9S4, the process 600 calculates a value for a variable "Ion" by: subtracting shejonjnin (available from function 612) from zip+4_ton (available from the Zip+4 Centroid We 1001 multiplying the result by 10,000, and then taking the integer portion of the product.<br>
Moving to state 966, the process 600 mro'afizes the variable "count" to a value of zero and proceeds to state 968 to access the Line Index file 619. At state 970. the process 600 reads the Polygon Line Index file 619 (available from function 618, Figure 19) to retrieve the values for the variables "latjioint" and "lon_point". The process 600 advances in the Polygon Line Index Tile 619 to the first occurrence of "lat" in the file by use of the file ISAM index. Moving to a decision state 972. the process 600 determines if "lat_point" is greater than "lat". If "lat_point" is greater than "lat", then all records in the Polygon Line Index file 619 have been read. If not, a test is performed at a decision state 974 to determine if "tonjioint" is less than "Ion". If *lon_point* is less than "Ion", a line drawn from the zip+4 centroid<br>
toward negative infinity is defined to cross a polygon boe. At state 976, "count" is incremented by one to indicate the fine crossing exists, and the process 600 loops back to state 970. However, ri decision state 974 is false, the process 600 loops back to state 970 to perform the next read of the Line Index Trie 619.<br>
If process 600 determines at decision state 972 that "lat_pomt" is greater than "lat", process 600 moves to a decision state 978 to check rf "count MODULUS 2" is equal to zero. If so, an even number of line crossings exist, the "outside" flag is then set, and the function 930 returns at state 980 to Figure 20. If decision state 978 is false, te.. "count MODULUS 2* is not equal to zero, an odd number of brie crossings exist which denotes that the zip+4 centroid is inside the polygon. The process 600 sets the "inside" Hag, and the function 930 returns at state 982 to Figure 20. VII. Overview of One Table System<br>
A derivative of the Two Table system (Master and Client tables) shown in Figures Ib and Ic is a One Table system 1000 (Figure 27). The One Table system provides the fastest way to route a telephone call. Because it is based on a single table, it is the simplest to implement m a telecommunications network.<br>
Implementation of the One Table system is not trivial because of the magnitude of the off-line maintenance required to synchronize telephone number changes, diem service location changes and to maintain the spatial relationship between the telephone number and each client's service locations. Since there is one table per client, each telephone number change must be reassociated with each client's servicing locations. There are several million telephone number changes nationwide per month. The resultant number of changes to the tables is the number of telephone number changes times the number of tables. Each table also must be updated for the addition and deletion of service locations, as well as changes in service location service area definitions or telephone numbers and these changes must be reassociated with the list of potential caller telephone numbers. Further, the more clients that are supported by the system, the more tables that are required, which could result in massive storage requirements.<br>
In the One Table system, there are two preferred ways of creating a Telephone Number to Service Location Telephone Number or ID table that»incorporated into the telecommunications network. Once the single table is created, the One Table system only requires a single mass storage. e.g., disk, lookup operation to determine the telephone number of the desired service location, and thus, provides the fastest call routing embodiment.<br>
A first method of building the Caller Telephone Number to Dealer Telephone Number table in the One Table system is an enhancement of the Client Table Build process previously described above. The files and processes utilized to generate the table are further described in conjunction with Figure 22 hereinbelow.<br>
A second method of building the Caler Telephone Number to Dealer Telephone Number table in the One Table system merges records from the Master Table and Client Table of the Two Table system using an off-line process. This process is described in general in conjunction with Figure 23 hereinbelow. A Build Master Table List function and a Build Client Table List function are both described by reference to Figure 24 and generally referenced to at 1050 and 1052. respectively, and are further discussed in conjunction with Figures 25 and 26, respectively.<br>
The Caller Telephone Number to Dealer Telephone Number table that results from either of the two methods of table building mentioned above is utilized in a telephone network for the One Table system. The One Table system and its<br>
network configuration is described by reference to figure 27 and is generally referenced to at 1000.   The hardware components, tables and files utilized by the One Table system are described in more detail in conjunction with Figure 27. The operational flow of the One Table system is described by reference to Figure 28 and is generally referenced to at 1160.<br>
VIII. One Table System Table Build Processes<br>
The following description explains two automated methods of creating and maintaining a Telephone Number to Service Location Telephone Number or ID table that can be incorporated into a telecommunications network.   These methods for building a One Table system use techniques that are similar in some respects to those used in creating the Two Table system. Special case of Client Tabte Build<br>
The first method to be described in building the Caller Telephone Number to Dealer Telephone Number table is a special case of the Client Table Build processes described above in conjunction with the Two Table system. This new process is described by reference to Figure 22. and is generally referred to at 1001 Process 1002 begins with a ZIP+4 Centroid fite, as described above in conjunction with the Two Table system. The ZIP+4 is the preferred Spatial Key in the United States. By substituting a 10-digit telephone number for the ZIP+4 as our Spatial key, a 10-digit Telephone Number Latitude &amp; Longitude Centroid file 1010 is created. Utilizing fite 1010 as an input to a Client Tabte Build process 1020, along with a Phone Array fite 1016 and a Phone Windows fite 1018. the end result is a Client Table that is a Caller Telephone Number to Service Location Telephone Number table 1022. Client Table Build process 1020 is similar to Client Table Build process 105 (Figure la, and further described in conjunction with Figures 3 and 12a), except for the different file names and field names used as the inputs to the process 1020, as identified herein. Fite 1010 is also used by two other Fite Build processes 1012 and 1014, described hereinbelow.<br>
The starting Telephone Number Latitude and Longitude Centroid file 1010 is created from a master list of<br>
• telephone numbers with addresses, ZIP+4 address standardization and coding software, such as AccuMail®w CODE 1®,<br>
available from Group 1 Software, and latitude and longitude coding software, such as MatchMakv[2000®, available from<br>
Geographic Data Technology. Inc. (GOT). The preferred process for creating the Telephone Number Latitude and Longitude<br>
fite is a two step process as described hereinbelow.<br>
Starting with the Telephone Number Address fite. step one processes the file with USPS address standardization AccuMaffw CODE-1 software from Group 1. standardizes the addresses, and assigns a ZIP+4 to each address in the file. The AccuMai software is used if the We creation process is run on a personal computer or other small machine, or alternatively, the CODE-1 software is used if the process is executed on a mainframe or other large machine. In step two, the address standardized and ZIP+4 coded resultant fite is processed with GDT's MatchMaker/2000 software. For each record, the software first looks up the address in GOT's Oynamap/2000® street address database. If it finds the current record's address, it assigns a street number latitude and longitude to the record. If it doesn't find the address, it assigns a latitude and longitude from GDT's ZIP+4 Latitude and Longitude Centroid file 100 (Figure la) to the record.<br>
Phone Array File Build process 1012 is smilar to the Zip Array File Build process 101 (Figure la), except that the resultant Phone Array file 1016 has a six digit (NPANXX) telephone number field instead of a 5-digit zip code field as in the Zip Array file 103. Thus, there are 999.999 possible entries m file 1016. but not all are used because not every numeric combination of area codes is currently assigned. Furthermore, the latitude/longitude mirrimums and maxrmums are for an area defined by the first six digits of the telephone number in fie 1016 rather than for the 5 digit zip code area of file 103.<br>
Phone Windows File Build process 1014 is smdar to the Zip Windows File Bufld process 102 (Figure 1 a), except that the resultant Phone Windows file 1018 has a six digit (NPANXX) telephone number field instead of a 5-digit zip code field as in the Zip Windows file 104. Off-line Merge Process<br>
Referring to Figure 23, a second method used in building the Caller Telephone Number to Dealer Telephone Number table involves the off-line merging of ZIP+4 records from the Master Table 107 and Client Table 106. The Master Table 107 and Client Table 106 are generated as previously described in conjunction with the Two Table system above. As shown in Figure 23. Master Table 107 and Client Table 106 are independently sorted in ascending ZIP+4 order by states 1030 and 1034 to create a sorted Master Table 1032 and a sorted Client Table 1036, respectively. These two sorted tables 1032 and 1036 are merged by a Match process 1040 to create a Caller Telephone Number to Service Location Telephone Number table 1022'. For each ZIP+4 record in the Master Table, the Match process 1040 preferably looks for matching ZIP+4 records in the Client Table and generates records in the Telephone Number to Telephone Number table 1022', as explained in the detailed description of process 1040 in conjunction with Figure 24 below. The Telephone Number to Telephone Number table 1022' is again identical to the original Client Table 106 in structure, but with more records and with telephone numbers substituted for zip+4s.<br>
Referring now to Figure 24, the Match and Append (or Merge) process 1040, identified in Figure 23, will be described. Process 1040 starts at state 1042 and proceeds to state 1044 that initializes the Master Table and Client Table End of File variables MT_f OF and CT_EOF to zero. Process 1040 then proceeds to state 1046 where it reads the first Master Table record containing a Master Table Telephone Number (MTPHONE) and a Master Table Spatial Key (MTSK). Process 1040 then proceeds to state 1048 where it reads the first Client Table record containing a Client Table Spatial Key (CTSK) and a Client Table Telephone Number (CTPHONE).<br>
Process 1040 then caHs function MTUST_BUIU) 1050 where it builds a memory resident fist of all Master Table records having the current Spatial Key. Function 1050 is described in more detail in conjunction with Figure 25 hereinbetow. Upon completion of function 1050. process 1040 calls function CTUST_BUILD 1052 where it builds a memory resident list of at Client Table records with the current Spatial Key. Function 1052 is described in more detail in conjunction with Figure 26. At the completion of function 1052. process 1040 proceeds to a decision state 1054 and compares the first Spatial Key (MTLJJSTID) in the Master Table list to the first Spatial Key (CTL_LIST{1)) in the Client Table list There are three possible results of this comparison:<br>
(1)	the Client Table Spatial Key is greater than the	Master Table Spatial Key;<br>
(2)	The Master Table Spatial Key is greater than Client Table Spatial Key; or<br>
(3) The Master Table Spatial Key and the Client Table        Spatial Key are equal. These three possible results are described as follows:<br>
(1)	When the Client Table Spatial Key is greater than the Master Table Spatial Key, as determined at decision<br>
state 1054. process 1040 proceeds to a decision state 1056. If the Master Table End of File condition MTJOF is equal<br>
to one, ue., the merging process has corrileted, the Merge process 1040 terminates at state 1060. If the Master Table<br>
End of File condition MT_EOF is not equal to one. process 1040 calls function MTLIST_BUILD 1050 (described in more<br>
detail in conjunction with Figure 25) which refreshes the Master Table List and then returns back to decision state 1054.<br>
(2)	When the Master Table Spatial Key is greater than the Client Table Spatial Key, as determined at decision<br>
state 1054, process 1040 proceeds to a decision state 1062. If the Client Table End of File condition CT_EOF is equal to<br>
one, i.e., the merging process has completed, the Merge process 1040 terminates at state 1066. If the Client Table End of<br>
File condition CT_EOF is not equal to one, process 1040 calls function CTUST_BUILD 1052 (described in more detail in<br>
conjunction with Figure 26) which refreshes the Client Table list and then returns back to decision state 1054.<br>
(3)	When the Master Table Spatial Key and the Client Table Spatial Key are equal, as determined at decision<br>
state 1054, process 1040 proceeds to Write Phone Number to Phone Number Record function 1068.  Function 1068<br>
writes out J times K records to the Phone to Phone Table 1022', wherein the value of J is obtained from function 1050<br>
(Figure 25) and the value of K is obtained from function 1052 (Figure 26). Function 1068 performs this operation by<br>
writing out each MTL_PHONE(I) and CTL_PHONEIU record combination by nesting a L - 1 to K loop for the Client Table<br>
list within an I - 1 to J loop for the Master Table List. At the completion of function 1068, process 1040 proceeds to<br>
function 1050 which refreshes the Master Table List and was previously described.  Process 1040 then proceeds to<br>
function 1052 which refreshes the Client Table list and was also previously described. After refreshing both the Master<br>
Table list and the Client Table list, process 1040 returns to decision state 1054 to continue the Merge process.<br>
Referring now to Figure 25, the Master Table List Build function 1050, identified in Figure 24, will be described. Function 1050 starts at state 1080 and proceeds to state 1082 where variable J is set to one. Function 1050 then proceeds to state 1084 where it moves the current Master Table record Spatial Key (MTSK) and Master Table Telephone Number (MTPHONE) to their corresponding elements: MTL_SK(J) and MTL_PHONE(J) in the Jth row of the memory resident Master Table fat.<br>
Function 1050 then proceeds to state 1086 where it reads the next Master Table record containing the Master Table Telephone Number (MTPHONE) and the Master Table Spatial Key (MTSK). Function 1050 then proceeds to a decision state 1088 where it determines if it has reached a Master Table End of File condition. If the End of File condition has been reached, function 1050 sets the Master Table End of File variable MT_EOF to one at state 1090 and returns control at state 1092 to process 1040 at function 1052 (Figure 24). If the End of File condition has not been reached, as determined at decision state 1088, function 1050 proceeds to a decision state 1094. At decision state 1094. function 1050 compares the current Master Table Spatial Key value (MTSK) to the first Spatial Key in the Master Table List (MTL LIS71D) to determine if the two Spatial Keys are equal. If they are not equal, function 1050 returns control at state<br>
1092 to process 1040 (Figure 24). If the two Spatial Keys are equal, function 1050 increments the value of J by one a: state 1096 and proceeds back to previously described state 1084.<br>
Referring now to Figure 26. the Client Table List Build function 105Z identified in Figure 24, will be described. Function CTLIST_BUILD 1052 performs the same process with the Client Table as Function 1050 (Figure 25) does with the Master Table. Function 1052 starts at state 1102 and proceeds to state 1104 where the variable K is set to one. Function 1052 then proceeds to state 1106 where it moves the current Client Table record's Spatial Key (CTSK) and Client Table Telephone Number (CTPHONE) to their corresponding elements: CTl_SK(K) and CTL_PHONE(K) in the Kth row of the memory resident Client Table fist Function 1052 then proceeds to state 1108 where rt reads the next Client Table record containing the Client Table Telephone Number (CTPHONE) and the Client Table Spatial Key (CTSK).<br>
Function 1052 then proceeds to a decision state 1110 where it determines rf it has reached a Client Table End of File condition. If the End of File condition has been reached, function 1052 sets the Client Table End of File variable CTJOF to one at state 1112 and returns control at state 1114 to process 1040 (Figure 24). If the End of FrTe condition has not been reached, as determined at decision state 1110. function 1052 proceeds to a decision state 1116. At decision state 1116. function 1052 compares the current Client Table Spatial Key value ICTSK) to the first Spatial Key in the Client Table List (CTL_UST(1)I to determine if the two Spatial Keys are equaL If they are not equal, function 1052 returns control at state 1114 to process 1040 (Figure 24). If the two Spatial Keys are equal, as determined at decision state 1116, function 1052 increments the value of K by one at state 1118 and proceeds to previously described state 1106.<br>
IX. Comouter-Teteohone Integration (CTI) Network Configuration for One Table System<br>
Referring to Figure 27, a preferred CTI network configuration tor the One Table system 1000 will be described.<br>
The network configuration utilizes the tables described in conjunction with Figures 22 or 23. A telephone call, placed from<br>
a calling telephone 110. is first processed by a switch (not shown) at a Local Exchange Carrier (LEC), such as Pacific Bell<br>
or Southwest BeH, near the caller.  The switch at the LEC assigns an Automatic Number Identification (AND that is<br>
independent of the type of telephone used. Caller ID techmlogy provides an alternate way of getting the caller's number.<br>
but the technology is presently state regulated as to availability, and the technology can be blocked under certain<br>
circumstances. According to AT&amp;T, over 98% of al switches currently assign and pass a 10-digit ANI. The caH, the ANI<br>
and Dialed Number Identification Service (DNIS) numbers an then passed through a national long distance network carrier,<br>
such as AT&amp;T. MCI or Sprint to a tang distance network (LDN) terminating switch 111. The LDN terminating switch<br>
111 can be connected to another switch (not shown) at the LEC servicing the terminating location or it can be a switch,<br>
such as an AT&amp;T MEGACOM 800 switch or an AT&amp;T MULTIQuest 900 switch connected directly to a call processing<br>
center interface point 1130. The preferred implementation in this Computer Telephone Integration network is a direct<br>
connect to the AT&amp;T long distance network using the AT&amp;T MEGACOM BOO service which employs an AT&amp;T 4 ESS<br>
digital switch 111.<br>
The terminating switch 111 passes the call, the ANI and the DNIS to the interface box 1130 between the network and the ca« center. The interface box 1130 is preferably a VRU or interactive voice response unit (IVRU), such as<br>
an AT&amp;T Conversant System, and ts the hub in providing CTI. An alternative embodiment utilizes an interlace box 1130 without voice/speech features. The interface box 1130 has the ability to control caH processing by accepting the voice signal, the ANI. and the DNIS from the telephone network switch 111. speaking recorded voice messages to the caller, accepting caller DTMF keypad input translating caller voice input and commands, e.g.. T. *2*. *3*. "A", B". *C". "Yes" and "No", to computer data codes, translating computer text into synthesized speech and speaking the synthesized speech to the caller. The interface box 1130 also communicates with other telephone and computer network systems via communications protocols, such as ISDN and TCP/IP, over a Local Area Network (LAN) 1132 to obtain additional information required for processing the call. The interface box 1130 optionally connects the caller to a servicing location telephone, e.g.. at a service location ISOa. or transfers the caller to the servicing location using an advanced network feature, such as AT&amp;T's Transfer Connect. The UN 1132 is dual wired for redundancy.<br>
The interface box 1130 first communicates with a Structured Query language (SQL) database server 1134 to update, validate and determine the type of the caller-provided telephone number. The type of telephone number refers to whether it is a U.S. POTS telephone number or not, e.g., a non POTS number may correspond to a pager, a cellular telephone or a personal communications service (PCS) telephone, and a non-U.S. number may be a Canadian telephone number. The caller-provided telephone number is either the result of a normal caller-initiated call (AM or caller ID), or the result of state 118 (Figure 28) where the caiier provides an alternate telephone number. The preferred SQL Server software provider is Oracle Corporation. The preferred server is an AT&amp;T 3600 UNIX box. Other servers or database software types may be used in other embodiments.<br>
The database server 1134 has two databases that provide the information to update, validate and classify the telephone number. The first is a Bellcore NPANXX Split file 1136. The 'NPANXX* represents the first six digits of the ten digit telephone number, corresponding to an area code and a telephone exchange. This file 1136 provides a list of NPANXXs that are in the process of being spin into new area codes and exchanges. II the caller provided NPANXX is in this list and the current date falls within a date range related to the split retrieved from the file, the caller-provided telephone number is updated according to the data in the Split fie 1136. Next the caller's NPANXX is compared against Bellcore's V&amp;H Coordinate file 1138 which lists an valid NPANXXs and the types of services supported by the NPANXX. Both the NPANXX Split fie 1136 and the V&amp;H Coordinate file 1138 are extracts from Bellcore's Local Exchange Routing Guide (LERG). The LEHG is the master database used by all common carriers for routing cad in the North American Dialing Plan telecommunications network. If the caller provided NPANXX is listed in the V&amp;H file 1138 as a U.S. Plain Old Telephone Service (POTS) number, the caller's time zone and daylight savings time indicator are returned. If on the other hand, the caller's NPANXX is invalid, the interface box 1130 requests the caller to provide another telephone number. If the NPANXX is valid, but a non-U.S. number, or a special purpose telephone number, such as 'NPA_555', a prerecorded message related to the caller's telephone number type will be played for the caller, and the caller will be asked to enter another telephone number or the caller will be connected to an exceptions cat! handling operator 1146.<br>
If the caller's NPANXX is determined to be a valid U.S. POTS number, the interface box 1130 sends an inter process communication request containing the caller-provided telephone number and DNIS to a routing processor 1150<br>
 (also referred to as a routing computer). In one embodiment, the routing processor 1150 is a UNIX-based computer, such as an AT&amp;T 3600. that has access to the Telephone Number to Telephone Number Table 1022 corresponding to the ONIS. Other computers may be used in other embodiments. The routing processor 1150 processes the request by retrieving the caller provided telephone number dependent data from the Client Telephone Number to Telephone Number Table and returns a status code, and if successful, a list of service location telephone numbers or IDs. If the return status code is an unsuccessful type, the interface box 1130 either plays a prerecorded message tor the caller or connects the caller to the exceptions call operator 1146.<br>
If the routing processor request is returned as successful, the interface box 1130 then makes inquiries to the database server 1134 which performs a database access function on the Client Service Locations table 1140 associated with the caller's ONIS and retrieves records associated with the service location IDs returned by the routing processor 1150. Table 1140 is an indexed and on-line version of Client Service Locations table 109 (Figure 22). These retrieved records contain information such as the service location telephone number, days and hours of operation, name, address and micro-area directions, time zone, daylight savings indicator and so forth. Next, the interface box 1130 determines which servicing locations are open to handle the cafler's request. Depending upon the client application, the interface box 1130 provides the caller, via recorded mce or synthesized text to speech, service location information and/or connects the caller directly with the closest or selected currently open servicing location.<br>
If the call requires operator exception handfing. the interface box 1130 connects the caller to the operator 1146, using a video display, through a CTI public branch exchange (PBXWautomatic call distributor (AGO) 1142 and host system 1144. The PBX/ACD 114Z such as a System 75 available from AT&amp;T, provides the caller's voice to the operator 1146. The host system is preferably a 3090 mainframe computer, available from IBM. The host system 1144 provides database data from the server 1134 on the operator's video display. The host system 1144 is supported by AT&amp;T American Transtech in Jacksonville, FL The operator 1146 handles the request and passes the information required to connect the caller to a servicing dealer or terminatts the cal with a pre-recorded message back at the interlace box 1130.<br>
There are two choices in coveting the cater to the servicing dealer. The interface box 1130 can generate a second call from the interface box 1130 to the servicing location, e.g., location 150a, and connect the caller to the servicing location through the interlace box 1130. Alternatively, the interlace box 1130 can use an advanced network feature Transfer Connect" marketed by AT&amp;T to transfer the call directly to the servicing dealer. The latter is the preferred implementation because it reduces telecommunications cost and interface box port capacity requirements.<br>
The Servicing location answers the cal using a conventional telephone 150a or other telephone cal receiving mechanisms. The servicing location can then handle the caller's request.<br>
X. One Table System Example<br>
Referring to Figure 28 (in combmation with Figure 27), the Call Processing process 1160 will be described. The One Table system 1000 executes the flow process shown by the flow diagram of Call Processing process 1160. The process is used to route a caller's telephone cal to a client's destination service location by use of a single routing table.<br>
The process 1160 utilizes the network configuration for the One Table system 1000 described in conjunction with Figure 27.<br>
Process 1160 starts with the caller dialing, for example, an *800" type telephone number using, for example, a conventional telephone 110. The cad is preferably routed by the national telecommunications network to a net wot k interface box 1130 (Figure 27) at the call processing center where it is answered. A call decoding module or component 112 of the network interface box 1130 decodes a network information packet 114. which contains the telephone number of the caller, provided by ANI, and the dialed number, i,e., the ONIS number.<br>
Process 1160 then proceeds to a decision state 116 and determines if the call application provides for optional caller input. If not. process 1160 proceeds to a decision state 1162. However, if the call application does provide for optional caller input, as determined at decision state 116, process 1160 moves to state 118, wherein the caller provides a telephone number of another person or business which is usually associated with a location different than the location associated with the ANI. The telephone number could also be the caller's home telephone number if, for example, the caller is making the telephone call at a location away from the home. The new telephone number can be entered by the caller using a OTMF keypad, e.g., on a touch tone telephone, by a computer or other device that can produce touch tone sounds, or by speaking the information to the interface box 1130 (Figure 27). State 118 also checks the cafier provided telephone number against the Bellcore NPANXX Split file 1136 (Figure 27) and the Valid Telephone Number file 1138 (Figure 27) and prompts the caller for another telephone number if the caller provided number is invalid.<br>
Once the input telephone number is determined to be valid, or if the number is still invalid after the caller has made a client-specified number of attempts at providing a valid number, process 1160 proceeds to decision state 1162. At decision state 1162. process 1160 determines rf the caller's telephone number or caller provided telephone number is a valid U.S. POTS number. If not, the process 1160 moves to state 128 for non-routable call exception handling, as previously described at state 128 in conjunction with Figure 1c. If the caller provided telephone number is a valid U.S. POTS number, as determined at decision state 116Z process 1160 moves to state 1164 wherein the caller provided number is used as an index for the Telephone Number to Telephone Number Table 1022 associated with the caller's DNIS.<br>
Moving to a decision state 1166, process 1160 determines if the caller's telephone number was found. If it was not found, process 1160 proceeds to state 128 for non-routable call exception handling, as described above. If the caller-provided telephone number is found, the corresponding telephone number's records) is retrieved and process 1160 proceeds to a decision state 1168 to determine if the retrieved record(s) contains a servicing location telephone number. If no servicing location telephone number is present, process 1160 proceeds to routed call exception handling state 144, as previously described at state 144 in conjunction with Figure 1c.<br>
If a servicing location telephone number is present, as determined at decision state 1168. process 1160 extracts the telephone number of the client's local service location at state 146 and moves to state 148 where it dials the retrieved service location's telephone number. The outbound calling module or hardware utilized at state 148 may be part of the network terminating point interface box 1130 (Figure 27). If the dialed number is busy, as determined in decision state 152, or there is no answer, as determined m decision state 154, then the call is routed to routed exception call handling<br><br>
144, as described above. If the call does not encounter a busy signal and there is an answer, the caller s connected to the servicing location 150 and the servicing location handles the caller's request.<br>
XI. Overview of Real-Time Process System<br>
In applications, where high call volumes and transaction processing speed are not an issue, where there is no requirement to fink to other Spatial Key coded databases, and/or where disk storage is a Emited resource, a chent may elect to perform the calculations required to associate precise locations corresponding to a caller-provided telephone number to servicing locations of any defined sue or shape during call processing. The general components and techniques required to perform real-tone caller-provided telephone number to servicing location association have been previously described above in conjunction with the Two Table system. Modifying these techniques n a real-time processing configuration provides further improvements in efficiency for the real-time association process. The fallowing description explains the real-time process which requires a Master 10-digit Telephone Number to Latitude and longitude Centroid file 1010 (Figure 29) and a Client Service Location file 109. Client servicing location service areas, pan of each record of ffle 109, are described as a precise latitude and longitude service location address with a radii-defined service area or as a service area polygon defined by a set of latitude and longitude vertices.<br>
In the Two Table system Client Table Build processes for radii and polygon Client Tables, the system reads a kst of service areas one by one. determines which ZIP+4s are within each service area, calculates the distance from each ZIP+4 to the service location, writes a record for each contained ZIP+4 to a file, and sorts and indexes the He by ZIP+4 and further, by ascending distance.<br>
Referring to Figure 29, the files and processes required in the Real Time Process system 1200 (figure 30) will be described. A Real-Time Processing module 1220 executes on one of a set of routing processors 1150 (Figure 30) of system 1200 (Figure 30) to route a telephone call in real-time. In addition to the Master 10-digit Telephone Number to Latitude and Longitude Centroid file 1010 and the Client Service Location file 109, Real-Time Processing module 1220 utilizes a Client Service Area Array file 1214, a Client Service Area Windows file 1216 and a caller or caller provided telephone number with a DNIS 1218. The output of module 1220 is a sorted list 1222 of service location telephone numbers or IDs. The module 1220 will be described in more detail in conjunction with Figure 35.<br>
The Master 10-digit Telephone Number to Latitude and Longitude Centroid Tile 1010 and the Client Service Location file 109 were previously described in conjunction with the One Table system above. The Client Service Area Array file 1214 and the Client Service Area Windows file 1216 are built using the latitude/longitude extremes of both the radii and polygon services areas in the Client Service Locations file 109 as explained below.<br>
Specifically, the Client Service Area Windows file 1216 is generated by an off-line Service Area Windows 1% Build process 1212. which utilizes the Client Service Locations file 109. Process 1212 will be described in more detail in conjunction with Figure 31 hereinbelow.<br>
The Client Service Area Array file 1214 is generated by an off-line Service Area File Build process 1210, which utilizes the Client Service Locations file 109. The Service Area File Build process 1210 is similar to the Zip Array File Build process 101 (Figure 1a) and the Phone Array File Build process 1012 (Figure 22), except that the resultant Client Service<br>
Area Array file 1214 has a client service location 10 field instead of a 5-digrt zip code field as in the Zip Array tile 103 or the six digit (NPANXX) telephone number field for the Phone Array file 1016. The byte offset field of file 1214 contains an offset into an indexed version (table 1140. Figure 30) of Client Service Locations file 109 rather than an offset into the Centroid file 100 (Figure la) or Centroid file 1010 (Figure 22). Furthermore, the latitude/longitude rmmmums and maxtmums are for a client service area lather than for the 5 digit zip code area of file 103 or the area defined by the first six digits of the telephone number of file 1016. The Client Service Area Array file 1214 is used to eliminate service locations whose latitude and longitude service area extremes do not encompass the latitude and longitude of the location corresponding to the caller provided telephone number. Since file 1214 only contains a byte offset index and latitude and longitude extremes, which are also created by process 1212 described hereinbelow. process 1210 is not described in further detail.<br>
In real-time processing, the system executes the Real-Time "during call process" module 1220 of building a list of service locations with telephone numbers whose service areas encompass the location of a caller provided telephone number. This Real-Time process 1220 is further described by reference to Figure 35 below. The Real-Time process 1220 determines the latitude/longitude of the location corresponding to the caller provided telephone number by retrieving the caller provided telephone number's record irom the Master Telephone Number to Latitude and Longitude Table 1010. Based on this latitude and longitude and the DNIS dependent Client Service Area Windows file 1216, the Real-Time process 1220 spatially determines a list of client locations that potentially service the caller's location. This list determination step is described by reference to Figure 35 and generally referenced to at 1344 and 1346, and is discussed in more detail in conjunction with Figure 36 hereinbelow.<br>
The Real-Tune process 1220 then performs a detailed spatial test on each potential location in the list to determine if the caller's latitude/longitude is inside the service location's service area. If it is inside, the system calculates the distance from the caller to the service location and adds it to the list of servicing locations. The detailed spatial test and distance steps are described by reference to Figure 35 and generally referenced to at 1348. and are further discussed in conjunction with Figures 37 and 38 hereinbelow. After all potential locations have been processed, the servicing list is sorted in ascending order based on distance and passed back to the call processing application job stream to be used in routing the telephone call<br>
Like for the Two Table system, real-time processing supports both polygon and radius service areas as was described in the Two Table system Client Table Build processes. For real-time processing, the Radii and Polygon "inside service area" processes are part of the same cad processing kernel system but each requires its own low level function (in Figure 38) to determine if the caller's location is inside or outside a service location's radii or polygon defined service area.<br>
Among the several embodiments, the Real-Time Process system is the simplest to update and requires the least storage. The spatial relationship of the caller-provided telephone number to a client's servicing locations is determined at the time of the call. The Master Table of telephone numbers with latitudes and longitudes and each client's Service Location files can be maintained independently and can reside on different machines.<br>
X1L Computer-Telephone Integration Network Configuration (or Real-Time Process System<br>
Referring to Figure 30, the real-tine determination system network configuration will be described. This network configuration and call processing logic are identical to that shown in Figure 27 for the One Table system, with the exception of the processing logic and databases accessed by the routing processor 1150. To avoid redundancy, only these differences wffl be discussed. In Figure 30, as in Figure 27. the routing processor 1150 accepts a caller provided telephone number and ONIS as input from the interface box 1130 and returns a processing status code and. if successful, a list of servicing locations associated with the DNIS whose service areas encompass the location of the caller provided telephone number.<br>
In performing this function, routing processor 1150 (Figure 30) first looks up the caller provided telephone number in the Master Telephone Number to Latitude and Longitude Table 1010. If the telephone number is not found, the status code is set to a value corresponding to 'unsuccessful, telephone number not in Master table* and this information is returned to the interlace box 1130. On the other hand, if the telephone number is found, the latitude and longitude are retrieved from table 1010.<br>
Next, processor 1150 converts the retrieved latitude and longitude into a lat/lon (latitude and longitude! window by the following equation: LatlLon Window - (integer of (caller location latitude multiplied by ten)) multiplied by 10.000 plus (integer of (caller location longitude multiplied by ten)). The processor 1150 then looks up the lat/lon window in the Service Area Windows file 1216 associated with the caller's DNIS. If the lat/lon window is not found, the status code is set to the value corresponding to "unsuccessful, no latflon window found* and this information is returned to the interface box 1130. If the lat/lon window is found, a list of potential servicing location IDs or telephone numbers is returned.<br>
For each service location 10 or telephone number m the potential list processor 1150 looks up the 10 in the Service Area Array file 1214 associated with the caller's DNIS and retrieves the latitude and longitude extremes tor the service area and the byte offset which indicates the start of the service location record in the Service Locations table 109. Next, processor 1150 determines if the latitude and longitude of the location corresponding to the caller provided telephone number lies inside latitude and longitude extremes of the current service area being tested. H not processor 1150 proceeds to the next location in the potential fist Otherwise, the caller provided telephone number's latitude and longitude fies inside the currently tested service area's extremes, and processor 1150 retrieves the detailed service area definition from the Client Service Locations Table 1140 associated with the caller's DNIS. The appropriate Client Service Locations Table 1140 associated with the DNIS dialed by the caller is selected from a plurality of Client Service Locations Tables for multiple DNISes and/or clients by utilizing a software selector, such as a case statement or a look-up table, on the processor 1150. Table 1140 is an indexed and on-line version of Client Service Locations Table 109. Based on the type of service area associated with the retrieved detailed record, i.e., radius or polygon, processor 1150 performs the appropriate low level function call to determine if the location of the caller provided telephone number is located within the service area currently being evaluated. If not, processor 1150 proceeds to the next location in the potential list. If the location is inside, processor 1150 calculates the distance from the caller location to the service location, adds the record to an "inside service area" list and proceeds to the next record on the potential list<br>
Aher processing all records in the potential Gst processor 1150 determines if the "inside service area" list is null. i.e_, contains no records. If the list is nufl. the status code value is set to correspond to the message, 'unsuccessful, no records in inside service area fist" and this information is returned to interface box 1130. If the "inside service area" list contains records, the fist is sorted by ascending distance, the status flag value is set to correspond to 'successful" and this information is returned to interface box 1130 where it is handled in exactly the same manner as was described lor the One Table system in Figure 27.<br>
XIII. Real-Tune Process: Off-line Cliem Service Area Windows File Build Process<br>
Figures 31-34 describe process 1212 that builds the Client Service Area Windows file 1216. This file contains an indexed latitude and longitude window list that includes a record for each latitude and longitude window and service location combination wherein the location's service area potentially overlaps the latitude and longitude window. File 1216 is used to quickly determine a potential 1st of servicing locations that overlap the location of the caller provided telephone number by looking up records with a latitude and longitude window equal to that of the caller provided telephone number. The Client Service Area Array file 1214 is used to eliminate service locations whose latitude and longitude service area extremes do not encompass the latitude and longitude of the location corresponding to the caller provided telephone number.<br>
Figure 31 shows an overview of the Client Service Area Windows File Build process 1211 Process 1212 begins at a stan state 1240 and proceeds to state 1242 where it reads a record from the Client Service Locations file 109. Moving to a decision state 1244, process 1212 checks for an End of File condition. If the End of File condition is "yes", i.e., all records in file 109 have been read, process 1212 proceeds to state 1258 to finish the process. If the End of File condition is 'no*, i.e., all records in file 109 have not been read and processed, process 1212 performs a test at decision state 1246 to determine if the record just read from file 109 has a radius or polygon defined service area. File 109 has a field that denotes the type of service area.<br>
If decision state 1246 determines that the service area type is radius, process 1212 proceeds to state 1248 where it calculates the number of miles per degree longitude at the latitude of the current service location. There are 68.9404 miles per degree latitude. The number of mites per degree longitude is a function of the latitude and is determined by the ioflowing function: Miles per degree longitude - 68.9404 * COSINE(Latitude). After performing this calculation, process 1212 calls a function 1250 to determine the latitude and longitude minimums and maximums for the radius type service area. Function 1250 is described in more detail in conjunction with Figure 32.<br>
If decision state 1246 determines the service area type is polygonal, process 1212 proceeds to call a function 1252. Function 1252 determines the latitude and longitude minimums and maximums for the polygonal type service area. Function 1252 is described in more detail m conjunction with Figure 33.<br>
At the completion of function 1250 for a radius service area or function 1252 for a polygonal service area, process 1212 continues to a Write Service Area Window Record function 1254. The Write Service Area Window Record function 1254 creates a record in a Raw Service Windows file 1256. Function 1254 will be described in more detail in<br>
conjunction with Figure 34. At the completion of function 1254. process 1212 loops back to state 1242 to read the next record in the Client Service Locations fle 109.<br>
Returning to decision state 1244, after reaching the End of File condition, process 1212 proceeds to state 1258. At state 1256. the Raw Service Windows file 1256 is sorted and indexed in ascending order by iatAon (latitude/longitude) window and location ID within latyioa window. The sorted and indexed results are written to the Client Service Area Windows tile 1216 and the process 1212 completes.<br>
Referring now to Figure 32. the Calculate Latitude and Longitude Minimum* and Maximums function 1250 for a radius type service area win be described. Function 1250 begins at a start state 1270 and proceeds to state 1272 where it calculates the latitude minimum ant* maximum of the service area for the current location. The current service area's minimum latitude is equal to the current location's latitude minus the service area radius in miles divided by miles per degree latitude. The current service area's maximum latitude is equal to the current location's latitude plus the service area radius in miles divided by miles per degree latitude. Function 1250 proceeds to state 1274 where rt calculates the longitude minimum and maximum of the service area for the current location. The current service area's minimum longitude is equal to the current location's longitude minus the service area radius in miles divided by miles per degree longitude. The service area's maximum longitude is equal to the current location's longitude plus the service area radius in miles divided by miles per degree longitude.<br>
Next, function 1250 moves to state 1276 where it builds the minimum and maximum latitude components o
Referring now to Figure 33, the Calculate Latitude and Longitude Minimums and Maximums function 1252 for a polygonal service area will be described. Function 1252 begins at a start state 1290 and proceeds to state 1292 to determines the latitude minimum and maximum of the service area for the current location. The current service area's minimum and maximum latitude is equal to the service area's minimum and maximum latitude for the current location as read from a polygon header for the polygonal service area from the Service Locations file 109 (Figures 29, 31). Advancing to state 1294. function 1252 determines the longitude minimum and maximum of the service area for the current location. Again this information is obtained from the polygon header portion of the file 109.<br>
Next function 1252 proceeds to state 1296 to build the minimum and maximum latitude components of the latflon windows association with the service location and its service area. The minimum latitude window component is<br>
equal to the integer of ten times the service area latitude minimum, where the latitude is expressed in degrees and decimal parts of degrees. The maximum latitude window component is equal to the integer of ten times the service area latitude maximum, where the latitude is expressed n degrees and decimal parts of degrees. Advancing to state 1298, function 1252 builds the minimum and maximum longitude components of the lat/lon windows associated with the current service location and its service area. The procedure for building the window longitude extremes is exactly the same as the procedure for building the latitude extremes, except that the latitude values are replaced with longitude values. At the completion of state 1298. function 1252 proceeds to return state 1300 and returns to process 1212 at function 1254 (Figure 31).<br>
Referring now to Figure 34, the Create Service Area File Records function 1254 will be described. Function 1254 uses the values determined in function 1250 (for a radius service area) or function 1252 (for a polygonal service area) to create a set of service area window records and write them to the Raw Service Area Windows file 1256 (Figure 31). The function 1254 utilizes an inner loop that traverses from a service area's minimum longitude window value to the maximum longitude window value nested within an outer loop that traverses from a service area's minimum latitude window value to the maximum latitude window value.<br>
Function 1254 begins at a start state 1310 and proceeds to state 1312 wherein a variable J is set equal to the current service area's minimum latitude window value. Function 1254 proceeds to state 1314 wherein a variable K is set equal to the current service area's minimum longitude window value. Moving to state 1316. function 1254 creates a window record by multiplying the value of J fay 10.000 and then adding the value of K. Next, function 1254 proceeds to state 1318 and writes out the window record to the Raw Service Area Windows (He 1256 (Figure 31).<br>
Function 1254 then proceeds to a decision state 1320 and tests to determine if the value of K is equal to the maximum longitude window component value of the service area for the current location. If they are not equal, function 1254 increments the value of K by one at state 1322 and moves back to state 1316 to generate another record. If the values are equal, as determined at decision state 1320, function 1254 continues at a decision state 1324. At decision state 1324, function 1254 compares the value of J to the maximum latitude window component value of the service area for the current location. If the values are not equal, the value of J is incremented by one at state 1326 and function 1254 moves back to state 1314 to start a new outer loop latitude value. If the values are equal, as determined at decision state 1324, function 1254 proceeds to return state 1328 and returns to process 1212 at state 1242 (Figure 31). XIV. Real-Time Process: "During Call Process" to Build List of Servicing Locations whose Service Areas Encompass the<br>
Location of Gaiter Provided Telephone Number<br>
Figures 35-38 describe the "during call process" 1220 of building a list of service locations whose service areas encompass the location of a caller provided telephone number. System 1200 (Figure 30) executes the flow process illustrated by the flow diagram of process 1220. Figure 35 provides an overview of the process 1220 previously introduced in Figure 29.<br>
Referring now to Figure 35. process 1220 begins at a start state 1340 and proceeds to state 1342 where n has memory access to the caller provided telephone number, the ONIS and the latitude and longitude of the location of the<br>
caller provided telephone number. The latitude and longitude are obtained by looking up the caller provided telephone number in the Master Telephone Number to Latitude and Longitude table 1010 (Figure 29). Moving to state 1344. process 1220 utilizes the latitude and longitude from state 1342 and determines the lat/lon (latitude and longitude) window containing the location of the caller provided telephone number. The window is determined by using the formula Lat/Lon Window - 10,000 times the integer of the caNer latitude multiplied by 10 plus the integer of the caller longitude multiplied by 10. For example, at 40 degrees latitude, the lat/lon window is represented by an X, V rectangle with dimensions of approximately 5.3 miles by 6.9 miles. Next, process 1220 calls function 1346 to buid an initial list of Potential service locations whose service areas potentially overlap the lat/lon window of the caller provided telephone number. Function 1346 is described in more detail in conjunction with Figure 36 hereinbelow.<br>
After completing function 1346. process 1220 continues at a function 1348 to process all service location records in the potential service location list and determine rf the service area overlaps the location of the caUei provided telephone number. Function 1348 is described in more detail in conjunction with Figure 37 below. Upon completion of function 1348, process 1220 continues at state 1349 wherein it sorts the final list of servicing locations by descending distance, if the value of K is two or greater. The value of K is determined in function 1348 (Figure 37) and represent! the final number of service locations in the final list whose service areas encompass the location of the caller provided telephone number. If the value of K is zero, process 1220 generates a flag indicating that there are no locations whose service areas encompass the location of the caller provided telephone number. Of course, if the value of K is one, no sorting is necessary. Finally, the list building process 1220 ends at state 1350.<br>
Referring now to Figure 36, the Initial Service Area List function 1346 will be described. Function 1346 begins at a start state 1351 and proceeds to state 1352 where it opens the Client Service Area flat/ton) Windows file 1216 related to the cafler's DNIS and has in memory the lat/lon window of the caller provided telephone number (from state 1344, Figure 35). Function 1346 then proceeds to state 1353 where it sets the value of K equal to zero. Moving to state 1354, function 1346 advances to the start of the first record in the open Client Service Area Windows file 1216 with a lat/lon window value equal to the lat/ton window value of the caller provided telephone number.<br>
Continuing at state 1355, function 1346 reads a lat/lon window record from the Client Service Area (lat/lon) Windows fite 1216. Moving to a decision state 1356, function 1346 determines if the record that was read at state 1355 has a lat/lon window value equal to the catter provided telephone number lat/lon window value. If the two values are equal function 1346 proceeds to state 1358 where it increments the value of K by one. Function 1346 then proceeds to state 1359 where it moves the service location 10 of the current record read from the Client Service Area (lat/lon) Window file 1216 into the Kth element in a "Potential service location list'. Function 1346 then proceeds back to state 1355 to continue reading records from the Client Service Area Windows file 1216. Returning to decision state 1356. if the latitude and longitude windows values from the Client Service Area Windows record and the caller provided telephone number are not equal, function 1346 returns to process 1220 (Figure 35) at state 1357.<br>
Referring now to Figure 37, the Caller Location Inside Service Area Extremes function 1348 wffl be described. Function 1348 begins at a start state 1360 and proceeds to state 1362 where it opens the Client Service Area Array file<br>
1214 and the Client Service Locations fie 109 associated with the caller ONIS. The Client Service Ariay file 1214 can be considered a specialized index into the Chent Locations file 109. The Potential service locations list created by function 1346 is available in memory for function 1348 at state 1362.<br>
Function 1346 then advances to state 1364 where it sets the value of variable J equal to one and the value of K equal to zero. Moving to state 1366. function 1348 reads the record from the Service Area Array file 1214 indexed by the 10 value in location(J) of the Potential service location list. Function 1348 gets the byte offset into the Client Service Locations file 109 and the latitude and longitude extremes of the service location from the Service Area Array file 1214 Function 1348 proceeds to a decision state 1368 and then to decision states 1370, 1372 and 1374 to determine if the caller provided telephone number latitude or longitude is less than the service area minimum latitude or longitude for the service location or greater than the service area maximum latitude or longitude for the service location. If the result of any of these tests in states 1368, 1370,1372 or 1374 is "yes*, the caller location is 'outside* the current service location's service area and function 1348 proceeds to state 1388. At state 1388, function 1348 increments the value of J by one and then proceeds back to state 1366 to advance to the next service location.<br>
If on the other hand, the results of all tests in decisions steles 1368, 1370, 1372 and 1374 are "no", then function 1348 proceeds to state 1376 where it advances to the byte offset in the Service Locations file 109 and reads the service location record containing the detailed definition of the service location's service area. The byte offset used to locate the proper record in the Service Locations File 109 was obtained from reading the Service Area Array file 1214 at state 1366.<br>
At the completion of state 1376. function 1348 calls function 1380 to perform a "caller inside service area test". Function 1380 is described in more detail m conjunction with Figure 38 hereinbelow. Upon completion of function 1380, a return flag indicating either "inside" or "outside" is set. If the return flag value is outside, function 1348 proceeds to state 1388 wherein the value of J is incremented by one, as previously described. If the return flag value is inside, function 1348 proceeds to state 1382 wherein the value of K is incremented by one. Proceeding to state 1384, function 1348 moves the current service location 10 or telephone number (obtained from the Service Locations file 109) and the calculated distance into the Ktti position of the final list of servicing locations. Proceeding to a decision state 1386. function 1348 tests to determine if all locations in the Potential list have been evaluated. If not, function 1348 proceeds to state 1388, increments the value of J by one and then proceeds to state 1366. If all locations in the Potential list have been evaluated, as determined at decision state 1386, function 1348 has built a final list of all servicing locations whose service area encompass the location of the calter provided telephone number. Function 1348 then proceeds to return state 1390 from where it returns to state 1349 in process 1220 (Figure 35).<br>
Referring now to Figure 38. the Caller Inside Service Area Test function 1380 will be described. Function 1380 begins at a start state 1402 and proceeds to a decision state 1404 where it determines rf the current service location has a radius or polygon defined service area. This information was previously retrieved from the Client Service Locations (tie 109.<br>
If rt is determined, at decision state 1404, that the service area is defined by a radius, function 1380 proceeds to state 1426 where it calculates the square of the distance from the caller provided telephone number location to the service location. The distance squared is used instead of the distance because of machine time required to take the square root of a number.<br>
Next the radius branch (as determined at state 1404) of function 1380 proceeds to a decision state 1428 to deterrmne if the current service area is radius defined. Since this is true for the radius branch, function 1380 proceeds 10 a decision state 1430 and compares the distance squared calculated at state 1426 to the service area radius squared for the service location. The service location's radius is obtained from the Service Location file 109. If the distance squared is greater than the radius squared, as determined at decision state 1430, function 1380 sets the return flag value to "outside" al return state 1424, and returns to function 1348 (Figure 37). However, H the distance squared is not greater than the radius squared, as determined at decision state 1430, function 1380 sets the return flag value to "inside" at return state 1432 and returns to function 1348 (Figure 37).<br>
Returning to decision state 1404 of Figure 38, if the service area is determined to be defined by a polygon, function 1380 proceeds to state 1406. The polygon branch portion of function 1380 is essentially the same process as function 930 (Figure 21) for the polygon portion of the Client Table Build process for the Two Table system. At state 1406, function 1380 calculates an integer relative value latitude for the location of the caller provided telephone number. The caller provided telephone number's latitude is translated into this form so it can be compared to the transformed service area latitudes in a Line Index file, which is described hereinbelow. Next, function 1380 proceeds to state 1408 where it performs the same transformation on the longitude for the location of the caller provided telephone number as it did with latitude in state 1406. After performing the longitude translation in state 1408, function 1380 proceeds to state 1410 where it sets the value of a variable 'count" equal to zero.<br>
Proceeding to state 1412. function 1380 gets the Line Index file. The Line Index file is built by function 618 used in the Polygon Service Area Build process in the Two Table system. Function 618 is shown hi detail in Figures 19a and 19b. After creating the Line Index fie it state 1412 above, or reading a pre-built version of the Line Index file stored in an enhanced version of the Client Locations file 109, such as Client Location file 1140 (shown in Figure 29), function 1380 moves to state 1414 and reads the first record from the Line Index fde.<br>
Proceeding to a decision state 1416, function 1380 tests if the transformed latitude point read from the Line Index file is greater than the transformed latitude point for the location of the caller provided telephone number (from state 1406). If the result from decision state 1416 is "no", function 1380 proceeds to a decision state 1418 and tests to determine if the transformed longitude point read from the Line Index file is less than the transformed longitude point for the location of the caller provided telephone number (from state 1408). If the result from decision state 1418 is "no", function 1360 moves back to state 1414 to read the next record from the Line Index file. If the result from decision state 1418 is "yes", function 1380 proceeds to state 1420 and increments the value of variable "count" by one and then moves back to state 1414.<br>
On the other hand, if the result of decision state 1416 rs "yes", function 1380 proceeds to a decision state 1422 and tests if the value of the variable 'count" tabulated in state 1420 is even or odd. If the result is "even", function 1380 sets the return flag value to "outside" at return state 1424 and returns to state 1388 of function 1348 (Figure 37). If the result of decision state 1422 in Figure 38 is "odd" (the caller provided telephone number's location is inside the current service area), function 1380 proceeds to state 1426 and calculates the square of the distance between the location of the caller provided telephone number and the current service location. Next, the polygon branch of function 1360 proceeds through decision state 1428 and follows the "no" branch to return state 1431 At state 1432. function 1380 sets the return flag value to "inside" and returns to state 1382 of function 1348 (Figure 37).<br>
XV. Real-Time Process System Example<br>
Referring to Figure 39 (in combination with Figure 30), a system level Real Time Call Processing process 1450 will be described. The Real-Time Process system 1200 executes the flow process shown by the flow diagram of the Real-Time Call Processing process 1450. The process is used to route a caller's telephone call to a client's destination service location by use of a real-time determination. Process 1450 utilizes the network configuration for the Real-Time Process system 1200 described in conjunction with Figure 30.<br>
In Figure 39, the beginning states (110 to 118. 1451) of Real-Time process 1450 are identical to the initial states (110 to 118,1162) in the One Table system process 1160 (Figure 28). In addition, the final states (1464 to 150) in the Real-Time Determination process 1450 are identical to the ending states (1168 to 150) of the One Table system process 1160. Since these identical states have already been described in the One Table system example, only states 1452 to 1462 will be described below.<br>
At state 1452 in Figure 39, process 1450 looks up the latitude and longitude for the location of the caller provided telephone number in the Master Telephone Number to Latitude and Longitude Table 1010. Moving to decision state 126, process 1450 determines if the lookup of the caller provided telephone number in the Master Table 1010 was successful. If not, process 1450 proceeds to state 128 for non-routable call exception handling, as described above at state 128 in conjunction with Figure Ic. If the caller provided number is in the Master Table 1010, as determined at decision state 126, process 1450 proceeds to a decision state 1454 and determines if a latitude and longitude were retrieved at state 1452. If no latitude and longitude were retrieved, process 1450 proceeds to state 128 for non-routable call exception handling, as previously described. If a latitude and longitude were retrieved at state 1452, process 1450 makes them available to process module 1220 in information packet 1456.<br>
Process module 1220, which may run on the routing processor 1150 (Figure 30), is conceptually described in conjunction with Figure 29 and is described in detail in conjunction with Figures 35 to 38. In summary, process 1220 translates the retrieved latitude and longitude (from state 1452) associated with the location ot the caller provided telephone number into a latflon Window Key. It then uses this key to retrieve a list of potential service location telephone numbers or IDs from a DNIS dependent Client Service Area Windows file 1216 (Figures 29 and 30, but not shown in Figure 39). Process 1220 uses these retrieved service location IDs to retneve a byte offset and service area latitude and longitude minimums and maximums from a DNIS dependent Client Service Area Array file 1214 (Figures 29 and 30, but<br>
not shown in Figure 39). For each potential service location where the caller provided telephone number's latitude and longitude are within the boundaries defined by a service location's minimum and maximum latitude and longitude rectangular boundary, process 1220 uses the byte offset to retrieve a detailed definition of the service area for the service location from the DNIS dependent Service Locations file 109. Each file 109, after indexing, is shown as one of the plurality of tables 1140 (Figure 30). A software selector selects one of a plurality of the Service Location Files 109 based on the DNIS. Process 1220 then performs a precise "within service area" test and builds a final list (shown at state 1460) of service location IDs or telephone numbers sorted by distance (from the location of the caller provided telephone number to the service location). The final list is also shown as list 1222 of Figure 29.<br>
Proceeding to state 14R2, process 1450 determines if the fist from state 1460 contains any records. If the list is null, i.e., contains no records, then process 1450 proceeds to state 128 for non-routable call exception handling, or else, if the list contains one or more records, process 1450 then proceeds to state 1464. Since states 1464 to 150 in Figure 39 are identical to states 1168 to 150 in Figure 28 which have already been described for process 1160. the description of the remaining states at the end of process 1450 is not repeated.<br>
XVI. Real-Time Process with Mobile Telephones<br>
Referring to Figure 40 (in combination with Figure 30), a system level Real-Time Call Processing process 1500 that supports mobile telephones will be described. The Real-Time Process system 1200 executes the flow process shown fay the flow diagram of the Real-Time Call Processing process 1500. The process 1500 is used to route a caller's telephone call, which may be from a mobile telephone, to a client's destination service location by use of a real-time determination. As used herein, a mobile telephone indicates a telephone that does not have a fixed location over time. The mobile telephone may be any of various types of telephone, including, but not limited to, cellular telephones, personal communications system (PCS) telephones, satellite telephones, marine telephones and emulated portable telephones. A computer, such as a personal digital assistant (PDA) or other portable computer, can be equipped with a microphone and speakers, or a headset, along with telephone emulation software, such as Microsoft Phone, and be connected to a telephone network via a wireless modem, for example. Process 1500 utilizes the network configuration for the Real-Tine Process system 1200 described in conjunction with Figure 30.<br>
In one embodiment of the Real T«ne Process system 1200. the telephone network provides a spatial coordinate of a caller's telephone location at predetermined intervals of time. Thus, at any particular time interval, an instantaneous location of the caller's telephone is obtained. Of course, since the caller may be traveling at a speed of 65 miles per hour, for example, the caller's location may rapidly change, and thus, the instantaneous location may be considered to be a good estimate of the location of the caller's telephone.<br>
As previously mentioned above, the present invention provides a method for routing telephone calls based on any geographic definition including postal geography, census geography, telecommunications geography, special grid coordinate geography, and custom geography. Depending on the type of geography used by the system 1200, various coordinate systems could be utilized. The caller spatial coordinate could be a single number such as the postal zip+4 code but there are other small geographic areas capable of having a unique spatial coordinate, such as zip + 6 code areas, census blocks,<br>
or very small latitude/longitude grids, ties, windows, or quad-trees. Alternatively, the caller spatial coordinate could be a number pair, such as latitude and longitude, or V &amp; H, or polar angle and radius vector, or even another way of identifying an instantaneous location of the caller. Other possible caller spatial coordinate systems include Ordnance coordinates and state-plane coordinates.<br>
When a mobile telephone spatial coordinate is obtained from the telephone network, process 1500 ts simplified in comparison to the process 1450 (Figure 39). Several steps (states 1451. 1452.126, and 1454) do not need to be performed and the Master table 1010 is not utilized in this situation.<br>
In Figure 40, the states 110.112,1451,1452,126,128,1454,1460-1464 and 144-154 of Real-Time process 1500 are identical to the corresponding states (110,112.1451,1451126.128.1454.1460-1464 and 144-154) in the Real-Time Process 1450 (Figure 39). Since these identical states have already been described m the prior Real-Time process 1450 example, only states 1502 to 1510 will be described below.<br>
At state 1502 in Figure 40. process 1500 obtains an information packet from the call decoding hardware module 112. In one embodiment of the invention, the information packet contains a calling telephone number and a dialed telephone number, while in another embodiment, the information packet contains the dialed telephone number and an instantaneous spatial coordinate of the caller's telephone. In yet another embodiment, the information packet may contain all three data items. Moving to decision state 116, process 1500 determines if the call application requires optional caller input. If not, process 1500 proceeds to a decision state 1504. However, if the can application does require optional caller input, as determined at decision state 116, process 1500 moves to state 116. wherein the caller provides a telephone number of another person or business which is usually associated with a location different than the location associated with the caller. The new telephone number can be entered by the caller using a DTMF keypad, e.g., on a touch tone telephone, by a computer or other device that can produce touch tone sounds, or by speaking the information to the interface box 1130 (Figure 30). State 118 also checks the caller provided telephone number against the Bellcore MPANXX Split file 1136 (Figure 30) and the Valid md Mobile Telephone Number file 1138 (Figure 30) and prompts the caller for another telephone number if the cater provided number is mvafid.<br>
Once the input telephone number is determined to be valid, or if the number is still invalid after the caller has made a client-specified number of attempts at providing a valid number, process 1500 proceeds to a decision state 1504 and determines if a caller spatial coordinate was obtained from the telephone network and no optional caller input was provided at state 118. If so, process 1500 continues at Real-Time Processing module 1510 wherein the caller spatial coordinate is made available in information packet 1506. hi one embodiment of the system 1200, the caller spatial coordinate is a latitude and longitude pair.<br>
In one embodiment, module 1510 is essentially similar to module 1220 which is conceptually described in conjunction with Figure 29 and is described in detail in conjunction with Figures 35 to 38. In summary, module 1220 Translates the caller spatial coordinate, e.g., latitude and longitude, (from information packet 1502) associated with the location of the caller telephone into a lat/lon Window Key. It then uses this key to retrieve a list of one or more potential service location telephone numbers or IDs from a DNIS dependent Client Service Area Windows file 1216 (Figures 29 and<br>
30, but not shown in Figure 40). Module 1220 uses these retrieved service location IDs to retrieve a byte offset and service area latitude and longitude mnmurns and maximum; from a ONIS dependent Client Service Area Array file 1214 (Figures 29 and 30, but not shown n Figure 40). For each potential service location where the latitude and longitude ol the caller's telephone are within the boundaries defined by a service location's minimum and maximum latitude and longitude rectangular boundary, module 1220 uses the byte offset to retrieve a detailed definition of the service area for the service location from the ONIS dependent Service Locations file 109. Module 1220 then performs a precise "within service area" test and builds a final ist (shown at state 1460) of service location IDs or telephone numbers sorted by distance (from the location of the catter provided telephone number to the service location). The final kst is also shown as fist 1222 of Figure 29.<br>
In another embodiment of the Real-Time Processing module 1510, a caller spatial coordinate other than latitude and longitude is utilized. The module 1510 and the files shown on Figure 29 are modified for the utilized coordinate system.<br>
Returning to state 1504 of Figure 40. if a caller spatial coordinate is not obtained from the telephone network, or if optional caller input is received at state 118, process 1500 advances to decision state 1451 as previously descnbed above. Process 1500 would advance to state 1451, for example, if a caller makes a telephone call from a cellular telephone from a vehicle and enters a home telephone number to have a pizza delivered to the caller's home. In an alternative example, if the caller used a mobile telephone to place an order with a pizza location closest to the current position of the vehicle for dining at the pizza restaurant or for pick-up, process 1500 would proceed from decision state 1504 directly to module 1510 with the coordinate information of packet 1506.<br>
In another embodiment of process 1500, instead of connecting the caller to the service location, information about the service location could be provided to the caller as described in conjunction with Figures 27 and 30 above. This information may include such items as the service location telephone number, days and hours of operation, name, address and micro-area directions, time zone, daylight savings indicator and so forth.<br>
Mobile telephones may be used with other embodiments of the automated call processing system. These embodiments may include use of noble telephones in a two table system having an alternative master table and use in a one table system having an alternative client table.<br>
In a two table system, a determiner function or a coordinate to spatial key module receives spatial coordinates corresponding to the instantaneous location of the caller and determines a corresponding spatial key. As previously described, the spatial key can be of various types, such as a zip+4 code. The determined spatial key can then be used to access one of a plurality of client tables, which is selected based on the dialed telephone number, as previously discussed above.<br>
The coordinate to spatial key module may include, in one embodiment a caller spatial coordinate to window code function. The window code is then used to access an alternative master table wherein a record includes the window code and a corresponding spatial key. The caller spatial coordinate may be a latitude and longitude provided by the telephone<br>
network, for example. If the caHer spatial coordinate o the latitude and longitude, the caller spatial coordinate to window code function multiplies the latitude in degrees tones one hundred, takes the integer portion (INT) of the product and multiplies the integer portion by 100.000. and then adds the integer portion of the product of the longitude m degrees times one hundred. In one embodiment, the result is a now digit window code. If other caller spatial coordinates are provided in other embodiments of the system, the caller spatial coordinate to window code function is modified for the coordinate type.<br>
In one embodiment, the alternative master table is generated using the GOT or Post Office Zip+4 Latitude and Longitude Centroid (He 100 using digitized zip code boundaries. The general concept is to divide the earth into one hundredth of one degree 10.01 °) latitude and longitude rectangles, which, for example, are approximately 0.7 miles by 0.5 miles in dimension at 40° latitude, and then tabulate all np+4 codes that overlap each rectangle. A rectangle of this size nay, for example, contain one zip+4 code in rural areas, twenty zip+4 codes in a medium-density residential city neighborhood and two hundred zip- 4 codes in a dense downtown area of a big city.<br>
The alternative master table is generated by a process that reads each record from the over 28 million record Zip+4 Centroid file 100 and writes a corresponding record that contains a latitude and longitude (lat/lon) window code and a zip+4 code. The (at/Ion window code field is created by multiplying -.ha iatiiuic in degree: (from the Zip+4 cantroid file 100) times one hundred, taking the integer portion (INT) of the product multiplying the integer portion by 100,000, and then adding the integer portion of the product of the longitude in degrees times one hundred.<br>
For example, if the input zip+4 record is 920141909, the latitude is 32.9862 North and the longitude is 117.2522 West, the output alternative master table record would be 329811725 as the latllon window code and the zip code of 920141909. After all records have been written to an initial or temporary file (not shown), the file is then sorted by the lat/lon window code value or key with the corresponding zip+4 code, and duplicate records are eliminated. The resultant final alternative master table is then written with each record composed of the lat/lon window key and the corresponding zip+4 code.<br>
The alternative master table may have multiple zip+4 codes associated with a particular lat/lon window, which leads to muttipte records in the alternative master table having the same lat/lon window (but different zip+4 codes). This state of the alternative master table allows the client flexibility in routing a telephone call A lat/lon window as described above may include portions of more than one service area (each having its own service location and associated telephone number), especially if overlapping service areas are used by a particular client In one embodiment of the system, if more than one service area is associated with a lat/lon window, the system software selects a service area and its associated telephone number for the service location by one of several possible schemes. For example, one scheme may assign telephone calls on a rotating basis, such as the least recently called service location of the locations servicing a particular lat/lon window. Another scheme may utilize knowledge of call volumes to equalize the call volume among the service locations servicing a particular lat/lon window. Another scheme first determines which of multiple service locations is open for business at the time of the call and then allocates the call using one of the previous schemes or yet anothei similar scheme.<br>
In another embodiment of the system, each lat/lon window m the alternative master table is further processed by selecting one of the zip+4 codes to represent the tat/km window. This further processing provides for efficiency, faster call routing, and reduced storage requirements for the alternative master table. Several steps are involved to further process the table for each lat/lon window. First, the center of the lat/lon window is calculated, such as, for example, by determining the intersection of the two diagonal fines connecting the opposite corners of the window. Next using the centroid for each of the zip+4 codes (available from the Zip+4 Centroid file 100) for a particular lat/lon window, the distance from the center of the lat/lon window to each of the centroids is calculated. This type of distance calculation is described above in conjunction with Figure 10, state 430. The zip+4 code associated with the shortest distance is then selected to be retained in the alternative master table, and the other records for the other zip+4 codes for the same window are deleted. These steps are then repeated for each latjlon window in the alternative master table. When these steps are completed, the further processed alternative master table has only one record for each lat/lon window, where the record includes the most central ap+4 code in the window.<br>
In operation, the two table system with mobile telephone capability receives the caller spatial coordinates, e,g., latitude and longitude, from the telephone network. The coordinates are converted to a window code as described above. The window code is used to access the alternative master table to obtain a spatial key, e.g., zip+4 code, from the table. The spatial key is then used to access one of the dient tables 106 (Figure 1), based on the dialed telephone number, so as to obtain a client service location telephone number or client service location ID.<br>
In a one table system, the alternative master table described above is merged with a client table 106 (Figure 1) using a process similar to that shown and described in conjunction with Figure 23. The master table and sorted master table use a window code field in place of the telephone number field so as to create a window code to client telephone number table. In operation, the one table system with mobile telephone capability receives the caller spatial coordinates, e.g., latitude and longitude, from the telephone network. The coordinates are converted to a window code as described above. The window code is used to access a window code to client telephone number table so as to obtain a client service location telephone number or client service location 10. One of a plurality of window code to dient telephone number tables is selected by the system based on the dialed telephone number.<br>
In a three table system, or for use with a supplemental table in a one table system, a retrieved client service location ID is used to index the third table or the supplemental table to provide client service location information, such as previously described above. The caller may be provided with the option of listening to the provided client service location information or to have the called routed to the client service location.<br>
The present invention utilizes telephone numbers as an mdex to a table containing partitions of a country into small geographic areas or points, such as postal service zip+4 codes, latitudes and longitudes, and so forth. These partitions are further utilized to access one of a plurality of service locations that may be anywhere within the country.<br>
The automated telephone routing system of the present invention provides the ability to reduce costs by routing a very high percentage of caHs made to a single national telephone number without any human intervention and the<br>
marketing advantage for a client of a single, easy to remember, tod free or nominal fee national telephone number. The system also provides geographically precise results due to the use of all ten digits of the caflmg and called telephone numbers which correspond with the zip+4 codes or latitudes and longitudes for the locations of these numbers. The automated routing system provides the ability for a business to choose among different types of service location service area definitions. Preferably, a client may define each location's service area as an area with a radius of any size or a polygon of any size and shape. A client can intermix radius and polygon definitions as well as have overlapping or non overlapping service areas.<br>
Flexibility is provided in defining how a particular client location is selected to terminate a call. A client is able to specify that a caller within a preselected radius ef any distance (to a tenth of a mile) about a particular location is to be connected; or that the closest servicing client location to the caller is to be connected; or that a caller within a preselected polygon about a particular client location is to be connected, wherein the polygon edges can be any length. The polygon area can represent either an exclusive territory, or can overlap with other polygons or radii of other client locations if the territory is non-exclusive. Additionally, each client location can have a different area type, with different radii or dimensions, if required. Added flexibility is provided in the non-exclusive polygon type or radius type areas, wherein a random or weighted selection from multiple locations within the area is possible.<br>
The present invention provides a method of routing calls originating from all published and unpublished telephone numbers, including unlisted numbers, secondary unpublished business Knes, mobile phones, and public pay phones. The present invention also provides a method for legally conforming to contracted franchise territory definitions executed between franchisers and franchisees by routing customer's calls precisely to the correct specific franchisee area. Additionally, the present invention provides a method for precisely routing telephone calls based on any geographic definition including postal geography, census geography, telecommunications geography, special grid coordinate geography, and all custom geography.<br>
The present invention provides a method for automatically routing and processing customer calls that do not meet the pre-set client protocols. This "exceptions handling" process routes the caN to a "live" operator who executes preset exceptions handling protocols. The present invention also provides for a method of integrating unrelated geographic information systems and database technology, telecommunications systems and database technology, postal systems and database technology, and computer technology into a common applications driven architecture. Additionally, the present invention provides methods for automatically and independently updating both the Client and Master Tables, and instantly and dynamically linking these two tables during call processing. Furthermore, the present invention provides a method for automating the processing of information that is input by a customer using a customer interlace that automatically routes telephone calls to customer requested destinations.<br>
The Two Table system provides a single updatable Master Table (telephone number to Spatial Key) to support multiple clients, where each Client Table is updated independently from other Client Tables and from the Master Table. This design maximizes transaction processing capacity in terms of calls per second that can be connected to a servicing location when the Client Table contains the service location telephone number as the service location ID.<br>
The Two Table system is one embodiment of the routing kernel that based on a dialed number, efficiently determines which geographically defined client service areas of substantially any size or shape encompass the location of the caller or caller-provided telephone number and determines the distance and direction from the eater's location to each of the servicing locations.<br>
Another embodiment of the routing kernel, the One Table system, provides many of the same benefits as the Two Table system plus it routes a cal faster. Since it only requires a single disk lookup to determine the telephone number of the servicing location, the One Table system is the fastest during the call routing process. From a network perspective, because of its simplicity of a being only a single table, it is the simplest to implement in a telecommunications network.<br>
Yet another embodiment of the routing kernel, the Real-Time Processing system, is the simplest embodiment to update and requires the least amount of storage. The spatial relationship of the caller or caller-provided telephone number to a client's servicing locations is determined at the time of the call. The Master Table of telephone numbers with latitudes and longitudes, and each client's Service Location files can be maintained independently and can reside on different machines. The system is streamlined and a Master Table look-up is not performed if the cater spatial coordinate is received in a information packet at the terminating switch. This situation occurs if the caller is calling from a mobile telephone.<br>
As an enhancement to the One Table system, the Two Table system and the Real-Time Processing system, an indexed Client Service Location table can be added to provide access to more information about the servicing location, ft is relatively straightforward to implement for the Real-Time system because the Client Service Location table is already utilized during call processing and can be readily further used to provide the additional information to the user. For the One Table system and the Two Table system, essentially the same Client Table Building processes as originally used for both the One Table system and the Two Table system are utilized to incorporate the indexed Client Service Location table, except that the ID of the client location is substituted for the telephone number of the cbent location.<br>
While the above detailed description has shown, described, and pointed out the fundamental novel features of the invention as applied to various embodiments, it win be understood that various omissions and substitutions and changes in the form and details of the system illustrated may be made by those skilled in the art without departing from the spirit of the invention.<br><br><br><br><br><br>
We claim:<br>
1.	A telephone network call processing system (1200) for real-time<br>
determination    of    client    service    areas    that    spatially    contain    an<br>
instantaneous location of a mobile caller telephone comprising:<br>
a file of client service areas (109, 1214, 1216) of a desired shape and size, wherein each service area is geographically indexed by spatial coordinate windows, and wherein each service areas is associated with a service location;<br>
call decoding hardware for obtaining a caller spatial coordinate corresponding to an instantaneous location of a mobile caller telephone;<br>
an initial service areas list function (1212) capable of indexing the caller spatial coordinate in a spatial coordinate window index of the client service areas file to generate a potential list of at least one service location whose service area potentially contains the location corresponding to the caller spatial coordinate; and<br>
a caller location inside service area extremes function (1216) for determining which client service areas include the location corresponding to the caller spatial coordinate and generating a list of service locations whose service areas contain the location corresponding to the caller spatial coordinate.<br>
2.	The system as claimed in claim 1, wherein the caller location inside<br>
service  area extremes  function  utilizes  the  spatial  coordinate  of the<br>
instantaneous location of the caller telephone and the spatial definition of<br>
the client service areas in the potential list.<br>
3.	The system as claimed in claim 1, additionally comprising a routing<br>
processor   (1150)   for   determining   a   distance  from   the   instantaneous<br>
location of the caller telephone to the service location.<br>
4.	The system as claimed in claim 3, wherein said processor (1150)<br>
sorts   the   list   of   service   locations   whose   service   areas   contain   the<br>
instantaneous location of the caller telephone by ascending distance.<br>
5.	A telephone network call processing system as claimed in any of<br>
claims 1-5 comprising:<br>
a call decoding module for receiving a dialed number and a caller spatial coordinate corresponding to an instantaneous location of a mobile caller telephone;<br>
a real-time processing module responsive to the dialed number and the caller spatial coordinate for providing client service information corresponding to a selected service location, wherein the service location is provided if the caller spatial coordinate is comprised in a service area having a client defined geographic configuration of any desired shape and size; and<br>
an outbound calling module for transmitting the provided client service information to the telephone network.<br>
6.	The   system   as   claimed   in  claim  5,   additionally  comprising  a<br>
plurality of client service location files.<br>
7.	The system as claimed in claim 6, wherein the real-time processing<br>
module utilizes the dialed number to select one of the client service<br>
location files corresponding to a client identified by the dialed number.<br>
8.	The system as claimed in claim 6, wherein one of the client service<br>
location files comprises a plurality of records, each record having a client<br>
service location identification (ID), a telephone number, and a boundary<br>
description of the service areas for the service location.<br>
9.	The system as claimed in claim 8, wherein the boundary description<br>
of a polygonal service area comprises each vertex of a polygon.<br>
10.	The system as claimed in claim 8, wherein the boundary description<br>
of a radius-defined service area comprises a center point and a radius.<br>
11.	The system as claimed in claim 5, wherein the caller telephone<br>
comprises a mobile cellular telephone.<br>
12.	The system as claimed in claim 5, wherein the caller telephone<br>
comprises a mobile personal communications system telephone.<br>
13.	The  system  as  claimed   in  claim  5,  wherein  the  client service<br>
information comprises routing information so as to allow the call to be<br>
routed to the selected client service location.<br>
14.	The system as claimed in claim 5, additionally comprising a voice<br>
response unit, wherein the voice response unit facilitates providing the<br>
client service information corresponding to the selected client service location to the telephone network.<br>
15.	The  system  as  claimed  in  claim  5,  wherein  the  client  service<br>
information comprises an identification (ID) corresponding to the selected<br>
client service location.<br>
16.	A real-time method of call processing for use in a mobile telephone<br>
network, the method comprising:<br>
receiving a dialed telephone number and a caller spatial coordinate corresponding to an instantaneous location of a mobile caller telephone;<br>
providing client service information corresponding to a selected service location in response to the dialed telephone number and the caller spatial coordinate, wherein the service location is selected if the caller spatial coordinate is include in a service area having a client-defined geographic configuration of substantially any desired shape and size; and<br>
transmitting the provided client service information to the telephone network.<br>
17.	The method as claimed in claim 16, comprising generating a list of<br>
service locations whose service area contains the location corresponding to<br>
the   caller   spatial   coordinate   and   determining   a   distance   from   the<br>
instantaneous location of caller telephone to service location.<br>
18.	The method as claimed in claim 16, wherein the client service<br>
information  corresponding   to   the   selected   client  service  location   is<br>
transmitted to the telephone network by a voice response unit.<br>
19.	The method as claimed in claim 16, wherein the client service<br>
information comprises an identification (ID) corresponding to the selected<br>
client service location.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QuanBn" target="_blank" style="word-wrap:break-word;">abstract.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWFzc2lnbm1lbnQucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWNvbXBsZXRlIHNwZWNpZmljYXRpb24gKGdyYW50ZWQpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-complete specification (granted).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWNvcnJlc3BvbmRlbmNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWZvcm0tMTMucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWZvcm0tMTkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWZvcm0tNi5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-form-6.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLWdwYS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLXBhLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-pa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLXBjdC0xMDEucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-pct-101.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLXBjdC0zMzEucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-pct-331.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLXBjdC00MDEucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-pct-401.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLXBjdC00MDkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-pct-409.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLXBjdC00MTUucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-pct-415.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLXBjdC00MTYucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-pct-416.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLXBldGl0aW9uLTEzNy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-petition-137.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDAtMDA0NDEtZGVsLXBldGl0aW9uLTEzOC5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2000-00441-del-petition-138.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="259610-a-method-for-authenticating-an-individual-at-an-authenticating-device.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="259612-hydrocracking-catalyst-composition.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>259611</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2000/00441/DEL</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>12/2014</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>21-Mar-2014</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>20-Mar-2014</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>20-Dec-2000</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>MUREX SECURITIES LTD.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>8 MYRTLE STREET, DOUGLAS, ISLE OF MAN, UNITED KINGDOM.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>SHAFFER JAMES D.,</td>
											<td>P.O.BOX 9543, RANCHO SANTA FE, CA 92067, U.S.A.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>MOORE GEORGE G.,</td>
											<td>9411 CORNWALL FARMS ROAD, GREAT FALLS, VA 22066-2701, U.S.A</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04Q 3/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US99/13775</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>1999-06-18</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/100,567</td>
									<td>1998-06-19</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/259611-a-telephone-network-call-processing-system-and-method-for-real-time-determination-of-client-service-areas by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:12:53 GMT -->
</html>
