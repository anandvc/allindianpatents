<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/257475-an-apparatus-for-constructing-a-predicted-picture-and-a-method-thereof by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:18:12 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 257475:&quot;AN APPARATUS FOR CONSTRUCTING A PREDICTED PICTURE AND A METHOD THEREOF&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;AN APPARATUS FOR CONSTRUCTING A PREDICTED PICTURE AND A METHOD THEREOF&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method for constructing a predicted picture by execution of program instructions by a computer communications system that comprises a pre-processor module (170), comprising modifying a first weight parameter (852) to conform to a bit configuration, modifying a second weight parameter (852) to conform to the bit configuration, calculating a first predicted component by applying the modified first weight parameter (845) to the region of the first frame, calculating a second predicted component by applying the modified second weight parameter (850) to the region of the second frame and calculating a combined weighted prediction by combining (865) the first predicted component and the second predicted component.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>The present invention relates to an apparatus for constructing a predicted picture and a method thereof.<br>
Claim of Priority under 35 U.S.C. ยง119<br>
[0001] The present Application for Patent claims priority to Provisional Application No. 60/568,154 entitled "Method and Apparatus for Weighted Prediction in Predictive Frames" filed May 4, 2004, and assigned to the assignee hereof and hereby expressly incorporated by reference herein.<br>
BACKGROUND<br>
Field<br>
[0002]   This invention relates to methods and apparatus for decoding compressed<br>
video data where various weighted prediction methods were used for encoding the video<br>
data.<br>
Background<br>
[0003] There are spatial, temporal and signal to noise ratio (SNR) scalabilities in hybrid coders like MPEG-1, MPEG-2, MPEG-4 (collectively designated MPEG-x), H.261, H.262, H.263, and H.264 (collectively designated H.26x). In hybrid coding, temporal redundancy is removed by motion-compensated prediction (MCP). A video is typically divided into a series of groups of pictures (GOP), where each GOP begins with an intra-coded frame (I) followed by an arrangement of forward or backward predictive-coded frames (P) and bi-directional predicted frames (B). Both P-frames and B-frames are inter-frames.<br>
[0004] B-frames provide significant reduction in bit-rate, and also provide capability of temporal scalability (i.e., bi-directional prediction could be introduced for frames in between I-frames and P-frames optionally, and the bit-stream would be playable even without the B-frames, but temporal smoothness and higher frame rate would be observed if B-frames were included in the decoding and playback). B-frames are predicted from multiple frames and can be computed from a simple average of the frames from which they are predicted. However, B-frames are also computed using weighted prediction such as a time based weighted average or a weighted average based on a parameter such as luminance. Weighted prediction places more emphasis on one of<br><br><br>
the frames or on certain characteristics of the frames and is used to more efficiently predict B-frames. Different codecs implement weighted prediction in different ways. Real Video 9 provides a 14-bit unsigned weighting factor to be multiplied by the individual forward and backward predictions, and also provides for a direct mode where temporal weights are derived based on relative temporal positions of the B-frame with respect to the two reference frames. MPEG-4, in the Simple Scalable Profile, provides for simple averaging of the past and future reference frames. Windows Media Video 9 also provides for simple averaging as in MPEG-4. H.264 weighted prediction provides for simple averaging of past and future frames, direct mode weighting based on temporal distance to past and future frames, and weighted prediction based on luminance (or other parameter) of past and future frames.<br>
[0005] As discussed above, the different video codec implementations can each have different weighting modes, such as direct mode, luminance weighting and simple averaging, as well as different bit allocations for weighting factors. A single decoder design to handle decoding multiple types of weighted bi-directional predictive video bitstreams is desired and would result in highly efficient and less costly design of software, firmware and hardware..<br>
SUMMARY<br>
[0006] A video decoding system that enables decoding of weighted bi-directional predicted encoded video through use of innovative digital signal processing is described. The efficient and innovative decoder design allows decoding of multiple weighted bi-directional encoding schemes with a single decoder. A pre-processor identifies weighting factors used in the particular encoding scheme and modifies the weight factors to conform to a universal bit configuration for decoding with a universal formula.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0007]   FIG. 1 is a block diagram of a general communications system for encoding<br>
and decoding streaming pictures,<br>
[0008]   FIG. 2A is a diagram illustrating a conventional MPEG-4 Simple Profile data<br>
stream,<br><br>
[0009]   FIG. 2B is a diagram illustrating a conventional encoded data stream including<br>
bi-directional predicted frames,<br>
[0010]   FIG. 3 is an illustration of an example of a P Frame construction process in<br>
MPEG-4,<br>
[0011]   FIG. 4 is an illustration of an example of a B Frame construction process in<br>
MPEG-4,<br>
[0012]   FIG. 5 is an illustration of an example of a weighted B Frame construction<br>
process,<br>
[0013]   FIG. 6 is an illustration of an example of temporal prediction of weights used<br>
in direct mode bi-directional prediction of H.264,<br>
[0014]   FIG. 7 is an illustration of an example of a P Frame construction process in<br>
H.264,<br>
[0015]   FIG. 8 is a flow chart of an example of a decoder process for decoding multiple<br>
encoder implementations of weighted bi-directional predicted video data,<br>
[0016]   FIG. 9 is an illustration of an example of half-pixel interpolation for use in<br>
motion compensation; and<br>
[0017]   Fig. 10 is a flow chart according to one embodiment.<br>
DETAILED DESCRIPTION<br>
[0018] It is noted that the examples may be described as a process, which is depicted as a flowchart, a flow diagram, a structure diagram, or a block diagram. Although a flowchart may describe the operations as a sequential process, many of the operations can be performed in parallel or concurrently and the process can be repeated. In addition, the order of the operations may be re-arranged. A process is terminated when its operations are completed. A process may correspond to a method, a function, a procedure, a subroutine, a subprogram, etc. When a process corresponds to a function, its termination corresponds to a return of the function to the calling function or the main function.<br>
[0019] A method, apparatus and system to reconstruct weighted bi-directional predicted video data are described. A single decoder can decode weighted bi-directional predicted video data that has been encoded with different implementations of weighted bi-directional prediction. Further, the decoder complexity is kept to a minimum to reduce cost by making maximum reuse of the decoder software, firmware or hardware<br><br>
for decoding the different implementations of weighted bi-directional predicted video data.<br>
[0020] A pair of video coding standards, known as MPEG-x and H.26x, describe data processing and manipulation techniques (referred to herein as hybrid coding) that are well suited to the compression and delivery of video, audio and other information using fixed or variable length source coding techniques. In particular, the above-referenced standards, and other hybrid coding standards and techniques, compress data such as video information using intra-frame coding techniques (such as, for example, run-length coding, Huffman coding and the like) and inter-frame coding techniques (such as, for example, forward and backward predictive coding, motion compensation and the like). Specifically, in the case of video processing systems, Hybrid video coding systems are characterized by prediction-based compression encoding of video frames with intra-and/or inter-frame motion compensation encoding.<br>
[0021] Intra-frame coding refers to encoding a picture (a field or a frame) without reference to any other picture, but the Intra-coded picture can be used as a reference for other pictures. The terms intra-frame, intra-coded frame and I Frame are all examples of video-objects formed with intra-coding that are used throughout this application. [0022] Inter or predictive coding refers to encoding a picture (a field or a frame) with reference to another picture. Compared to the Intra-coded picture, the Inter-coded or predicted picture may be coded with greater efficiency. Examples of inter-coded pictures that will be used throughout this application are predicted frames (either forward or backward predicted, also referred to as P frames), and bi-directional predicted frames (also referred to as B Frames). Other terms for inter-coding include high-pass coding, residual coding, motion compensated interpolation and others that are well known to those of ordinary skill in the art.<br>
[0023] FIG. 1 is a block diagram of a general communications system for encoding and decoding streaming pictures. The system 100 includes multiple types of encoder devices 105, 110 and 115 and a decoder device 155. The encoder devices each contain intra-coding and predictive coding modules 120, 125 and 130, respectively. These coding modules perform the various types of encoding including intra-coded and inter-coded pictures as discussed above. The encoder devices each contain a different type of weighted prediction module 135, 140 and 145, respectively. Each weighted prediction module performs weighted bi-directional prediction by one of a plurality of methods.<br><br>
These weighted prediction methods have differences in the way that the weights and other parameters are represented. The data that the encoder devices generate is transmitted over a network 150. Network 150 can be part of a wired system such as telephone, cable, and fiber optic, or a wireless system. In the case of wireless, communication systems, network 150 can comprise, for example, part of a code division multiple access (CDMA or CDMA2000) communication system or alternately, the system 100 can be a frequency division multiple access (FDMA) system, a time division multiple access (TDMA) system such as GSM/GPRS (General Packet Radio Service)/EDGE (enhanced data GSM environment) or TETRA (Terrestrial Trunked Radio) mobile telephone technology for the service industry, a wideband code division multiple access (WCDMA), a high data rate (IxEV-DO or IxEY-DO Gold Multicast) system, or in general any wireless communication system employing a combination of techniques.<br>
[0024] Decoder device 155 can receive the various encoded data directly over the network 150 or receive it from memory module 175 or external memory storage module 180 after the data has been stored there by an encoder or other intermediary device. Decoder device 155 includes intra-decoding module 160, predictive decoding module 165, preprocessor module 170, memory module 175 and communication component 190. Communications component 190 contains logic used for receiving encoded data in conjunction with network 150, as well as logic for receiving encoded data from external storage 180 or memory module 175. Intra-decoding module 160 and predictive decoding module 165 decode the received intra-coded and inter-coded data, respectively. Predictive decoding module 165 includes logic to decode all of the various types of weighted prediction encoded by weighted prediction modules 135, 140 and 145. Instead of having separate sections of code to decode the various types of weighted prediction, decoder device 155 utilizes a pre-processor module 170 to manipulate the weighted prediction parameters such that a single method of decoding can be used to decode all of the types of weighted prediction. After decoding, decoder device 155 can store the picture data on memory module 175 or external storage module 180, or display it on display 185. Display 185 can be integrated in the decoder device, as in a telephone or personal digital assistant (PDA) or can be a separate peripheral device. The encoding, decoding, pre-processing and weighted prediction processes performed by the encoder and decoder devices are more fully described below.<br><br>
[0025] In a typical MPEG decoder, predictive coded pixel blocks (i.e., blocks that comprise one or more motion vectors and a residual error component) are decoded with respect to a reference frame (where an mtra-frame or another predicted frame can serve as a reference frame). FIG. 2A is a diagram illustrating a conventional MPEG-4 Simple Profile data stream, which depicts frame dependencies for a GOP. GOP 10 is made up of initial I Frame 12, followed by several forward predicted P frames 14. FIG. 2B is a diagram illustrating a conventional encoded data stream including bidirectional predicted frames, which depicts the frame dependencies of a GOP. GOP 20 is made up of I frame 22A, forward predicted P frames 24, and bi-directional predicted B frames 26. Each B frame can combine forward and backward motion vectors and residual errors referenced to I frame 22A or predicted P frames 24 (backward predicted P frames could also be used but are not shown in this example). I frame 22B marks the beginning of the next GOP.<br>
[0026] FIGS. 3, 4, 5 and 7 illustrate various inter-coding processes including those used for constructing P Frames, B Frames, weighted B Frames and H.264 predicted frames. The encoder devices 105, 110 and 115 and the decoder device 155 depicted in FIG. 1 can perform these processes in whole or in part.<br>
[0027] P Frames (or any inter-coded sections) can exploit temporal redundancy between a region in a current picture and a best matching prediction region in a reference picture. The location of the best matching prediction region in the reference frame can be encoded in a motion vector. The difference between the current region and the best matching reference prediction region is known as residual error (or prediction error). FIG. 3 is an illustration of an example of a P Frame construction process in, for example, MPEG-4. Process 300 includes current picture 305 made up of 5x5 macroblocks, where the number of macroblocks in this example is arbitrary. A macroblock is made up of 16 x 16 pixels. Pixels can be defined by an 8-bit luminance value (Y) and two 8-bit chrominance values (Cr and Cb). In MPEG, Y, Cr and Cb components can be stored in a 4:2:0 format, where the Cr and Cb components are down-sampled by 2 in the X and the Y directions. Hence, each macroblock would consist of 256 Y components, 64 Cr components and 64 Cb components. Macroblock 315 of current picture 305 is predicted from reference picture 310 at a different time point than current picture 305. A search is made in reference picture 310 to locate best matching macroblock 320 that is closest, in terms of Y, Cr and Cb values to current macroblock<br><br>
315 being encoded. The location of best matching macroblock 320 in reference picture 310 is encoded in motion vector 325. Reference picture 310 can be an I Frame or P Frame that the decoder will have reconstructed prior to the construction of current picture 305. Best matching macroblock 320 is subtracted from current macroblock 315 (a difference for each of the Y, Cr and Cg components is calculated) resulting in residual error 330. Residual error 330 is encoded with 2D Discrete Cosine Transform (DCT) 335 and then quantized 340. Quantization 340 can be performed to provide spatial compression by, for example, allotting fewer bits to the high frequency coefficients while allotting more bits to the low frequency coefficients. The quantized coefficients of residual error 330, along with motion vector 325 and reference picture 310 identifying information, are encoded information representing current macroblock 315. The encoded information can be stored in memory for future use or operated on for purposes of, for example, error correction or image enhancement, or transmitted over network 345.<br>
[0028] The encoded quantized coefficients of residual error 330, along with encoded motion vector 325 can be used to reconstruct current macroblock 315 in the encoder for use as part of a reference frame for subsequent motion estimation and compensation. The encoder can emulate the procedures of a decoder for this P Frame reconstruction. The emulation of the decoder will result in both the encoder and decoder working with the same reference picture. The reconstruction process, whether done in an encoder, for further inter-coding, or in a decoder, is presented here. Reconstruction of a P Frame can be started after the reference frame (or a portion of a picture or frame that is being referenced) is reconstructed. The encoded quantized coefficients are dequantized 350 and then 2D Inverse DCT, or EDCT, 355 is performed resulting in decoded or reconstructed residual error 360. Encoded motion vector 325 is decoded and used to locate the already reconstructed best matching macroblock 365 in the already reconstructed reference picture 310. Reconstructed residual error 360 is then added to reconstructed best matching macroblock 365 to form reconstructed macroblock 370. Reconstructed macroblock 370 can be stored in memory, displayed independently or in a picture with other reconstructed macroblocks, or processed further for image enhancement.<br>
[0029] B Frames (or any section coded with bi-directional prediction) can exploit temporal redundancy between a region in a current picture and a best matching<br><br>
prediction region in a previous picture and a best matching prediction region in a subsequent picture. The subsequent best matching prediction region and the backward best matching prediction region are combined to form a combined bi-directional predicted region. The difference between the current picture region and the best matching combined bi-directional prediction region is a residual error (or prediction error). The locations of the best matching prediction region in the subsequent reference picture and the best matching prediction region in the previous reference picture can be encoded in two motion vectors. FIG. 4 is an illustration of an example of a B Frame construction process in, for example, MPEG-4. Process 400 includes current picture 405 made up of 5 x 5 macroblocks, where the number of macroblocks in this example is arbitrary. Encoding macroblock 415 of current picture 405 is predicted in reference to previous reference picture 410 at a previous time point than current picture 405 and in reference to subsequent reference picture 475 at a subsequent time point. A search is made in previous reference picture 410 to locate best matching macroblock 420 that is closest to current macroblock 415 being encoded. The location of best matching macroblock 420 is encoded in motion vector 425. Previous reference picture 410 can be an I Frame or P Frame that the decoder will have reconstructed prior to the construction of current picture 405. A search is made in subsequent reference picture 475 to locate best matching macroblock 480 that is closest to current macroblock 415. The location of best matching macroblock 480 is encoded in motion vector 485. Subsequent reference picture 475 can be an I Frame or P Frame that the decoder will have reconstructed prior to the construction of current picture 405. Best matching macroblock 420 and best matching macroblock 480 are averaged to form a combined bi-directional macroblock that is subtracted from current macroblock 415 resulting in residual error 430. Other methods of combining the best matching macroblocks are discussed below. Residual error 430 is encoded with, for example, DCT 435 (other 2D transforms include a Hadamard transform or an integer transform as in H.264) and then quantized 440. The quantized coefficients of residual error 430, along with motion vectors 425 and 485 and reference picture identifying information, are encoded information representing current macroblock 415. The encoded information can be stored in memory for future use or operated on for purposes of, for example, error correction or image enhancement, or transmitted over network 445.<br><br>
[0030] Since a B Frame is not used as a reference frame, in order to retain its temporal scaling property, macroblock reconstruction for B Frames may not be needed in an encoder. In a decoder, reconstruction of a B Frame section can be started after both the previous reference frame (or a portion of a picture or frame that is being referenced) and the subsequent reference frame (or a portion of a picture or frame that is being referenced) are reconstructed. The encoded quantized coefficients are dequantized 450 and then 2D IDCT 455 is performed resulting in decoded or reconstructed residual error 460. Encoded motion vectors 425 and 485 are decoded and used to locate the already reconstructed best matching macroblock 465 in the already reconstructed previous reference frame 410, and to locate the already reconstructed best matching forward macroblock 490 in subsequent reference frame 475. Reconstructed best matching macroblocks 465 and 490 are averaged to form a combined bi-directional macroblock. Reconstructed residual error 460 is then added to the combined bi-directional macroblock to form reconstructed macroblock 470. Reconstructed macroblock 470 can be stored in memory, displayed independently or in a picture with other reconstructed macroblocks, or processed further for image enhancement.<br>
[0031] B Frames (or any section coded with bi-directional prediction) can further exploit temporal redundancy by applying a weighting factor to one or both of the reference pictures before combining. The weighting factors can allow a better match to the section of the current picture, thereby reducing the residual error and, at the same time, reducing the bit-rate. In addition, weighting factors can be beneficial when one scene fades into another, or when a gradual variation in luminance exists such as fading to and/or from black or cross fades. FIG. 5 is an illustration of an example of a weighted B Frame construction process. Process 500 includes a current picture 505 made up of 5 x 5 macroblocks, where the number of macroblocks in this example is arbitrary. Encoding macroblock 515 of current picture 505 is predicted in reference to previous reference picture 510 at a previous time point than current picture 505 and in reference to subsequent reference picture 575 at a subsequent time point. A search is made in previous reference picture 510 to locate best matching macroblock 520 that is closest to current macroblock 515 being encoded. The location of best matching macroblock 520 is encoded in motion vector 525. Previous reference picture 510 can be an I Frame or P Frame that the decoder will have reconstructed prior to the construction of current picture 505. A search is made in subsequent reference picture 575 to locate<br><br>
best matching macroblock 580 that is closest to current macroblock 515. The location of best matching macroblock 580 is encoded in motion vector 585. The forward reference picture can be an I Frame or P Frame that the decoder will have reconstructed prior to the construction of current picture 505. Weighting factors wi and w2 can be chosen such that a weighted linear combination of the best matching subsequent and best matching previous macroblocks results in a smaller residual error than if equal weights were used as in FIG. 4. Weighting factor W] is multiplied by the Y, Cr and Cb values of best matching macroblock 520 to form a weighted best matching previous macroblock and weighting factor w2 is multiplied by the Y, Cr and Cb values of best matching macroblock 580 to form a weighted best matching subsequent macroblock. The weighted best matching forward macroblock and the weighted best matching backward macroblock are combined to form a weighted combined bi-directional macroblock that is subtracted from current macroblock 515 resulting in residual error 530. Other methods of choosing the weights for combining the best matching forward macroblock and the best matching backward macroblock are discussed below. Residual error 530 is encoded with DCT 535 and then quantized 540. The quantized coefficients of residual error 530, motion vectors 525 and 585, weights and reference frame identifying information, are encoded information representing current macroblock 515. The encoded information can be stored in memory for future use or operated on for purposes of, for example, error correction or image enhancement, or transmitted over network 545.<br>
[0032] Reconstruction of a B Frame section can be started after both the backward reference frame (or a portion of a picture or frame that is being referenced) and the forward reference frame (or a portion of a picture or frame that is being referenced) are reconstructed. The encoded quantized coefficients are dequantized 550 and then IDCT 555 is performed resulting in a decoded or reconstructed residual error 560. The encoded motion vectors 525 and 585 are decoded and used to locate the already reconstructed best matching macroblock 565 in previous reference picture 510, and to locate the already reconstructed best matching macroblock 590 in subsequent reference picture 575. The encoded weight wt is decoded and applied to reconstructed best matching previous macroblock 565 and the encoded weight W2 is decoded and applied to reconstructed best matching subsequent macroblock 590 to form a combined weighted prediction macroblock. The reconstructed residual error 560 is then added to<br><br>
the combined weighted prediction macroblock to form reconstructed macroblock 570. Reconstructed macroblock 570 can be stored in memory, displayed independently or in a picture with other reconstructed macroblocks, or processed further for image enhancement.<br>
[0033] The application of the weights wi and W2 in FIG. 5 is shown as first multiplying the best matching reference macroblocks (i.e., the luminance (Y), and chrominance Cr and Cb (parameters), adding the multiplied macroblocks and then dividing by the added weights (normalizing the combined weighted prediction). The weights can also be derived with the normalization factor included. For example, the weight W] could be derived as being equal to wi /(wi + wa) and wa could be derived as being equal to wa /( Wi + w2). These normalized weighting factors can then be used to modify the reference picture parameters and the modified parameters can then be added together and division by (wi + wa) is not needed. Normalizing means such as preprocessor module 170 of FIG. 1 or pre-processor 810 of FIG. 8 can perform the normalizing function.<br>
[0034] Deriving weights with the normalization factor included saves a division operation, and division is a complex operation in digital signal processing. Another way of normalizing without a division operation is by use of bit shifting. The weights can be derived with a common denominator and the division can be represented by a right shift of the combined weighted prediction a number of bits based on the base 2 logarithm of the denominator. For example, wi could be equal to 12 and W2 could be equal to 4 and the denominator could be 16. The denominator of 16 would translate to a right shift of 4 bits. A right shift of 4 bits is equivalent to dividing by 16, thus W] would translate to a normalized weight of 0.75 and W2 would translate to a normalized weight of 0.25.<br>
[0035] Another method of deriving the weights can be used to perform a bi-directional prediction technique known as "direct mode" in H.264. In direct mode, motion vectors are not transmitted for the macroblock (or any other region such as a submacroblock) that is being bi-directionally predicted. Instead, the motion vectors are derived from a motion vector of a co-located macroblock from one reference frame to the other reference frame. The derivation of the motion vectors and the weights can based on the temporal location of the current frame to both the reference frames. FIG. 6 is a depiction of an example of temporal prediction of motion vectors and weights used in<br><br>
direct mode bi-directional prediction of H.264. Current macroblock 605 located in current frame 630 is formed by a linear combination of two macroblocks, one macroblock located in subsequent reference frame 635 and another macroblock located in previous reference frame 640. Forward motion vector MV0 615 and backward motion vector MVt 620 are derived from motion vector MVC 625 that locates the best matching macroblock in the previous reference frame for co-located macroblock 610 in the subsequent reference frame. The forward and backward motion vectors are calculated as: <br>
Formula Removed<br><br><br>
[0036] where TB 645 is the temporal distance between the current frame and the previous reference frame and TD 650 is the temporal distance between the previous reference frame and the subsequent reference frame. In one example, the best matching previous macroblock is modified by the weight wi and the best matching subsequent macroblock is modified by the weight wa where wi and W2 are calculated as:<br>
Formula Removed <br>
[0037] The modified macroblocks are then combined as discussed above and shown in FIG. 5. This example used a co-located macroblock in subsequent reference frame 635, but as one of ordinary skill in the art would know, a co-located macroblock in previous reference frame 640 could be used along with the motion vector referencing subsequent reference frame 635.<br>
[0038] In addition, bi-directional construction could compute the combined bidirectional prediction based on either the forward or backward best matching macroblock alone (where one of the weights is set equal to zero), instead of the average macroblock technique as is depicted in FIG. 4 or the combined weighted prediction macroblock technique, where both weights are non-zero, as is depicted in FIG. 5. [0039] H.264 offers some options to the MPEG-4 examples of P Frame construction and B Frame construction discussed above. FIG. 7 is an illustration of an example of a P Frame construction process in H.264. Process 700 includes current picture 705 made up of 5 x 5 macroblocks, where the number of macroblocks in this example is arbitrary.<br><br>
Macroblock 715 of current picture 705 is predicted from reference picture 710 at a different time point than current picture 705. A macroblock can be divided into smaller sub-macroblock sections (for example, four sub-macroblocks are depicted in this example, but H.264 allows for sub-macroblock partitions as small as 4x4 pixels. Hence there can be 16 motion vectors for a single macroblock) and each sub-macroblock section can be exploited separately for temporal redundancy. A search is made in the reference picture to locate best matching sub-macroblocks for each sub-macroblock resulting in composite best matching macroblock 720 that is closest to current macroblock 715 being encoded. The location of the best matching macroblocks in the reference picture can be encoded in four motion vectors 725a-725d. The reference picture can be an I Frame or P Frame that the decoder will have reconstructed prior to the construction of current picture 705. The composite best matching macroblock 705 is subtracted from current macroblock 715 resulting in residual error 730. Residual error 730 can be encoded with slightly different forward 2D transform 735 than the DCT used in MPEG-4 and then quantized 740. The quantized coefficients of residual error 730, motion vectors 725a-725d and reference frame identifying information, are encoded information representing current macroblock 715. In the case of weighted bi-directional prediction frames with multiple sub-macroblock sections, the weights are also encoded. The encoded information can be stored in memory for future use or operated on for purposes of, for example, error correction or image enhancement, or transmitted over network 745.<br>
[0040] The encoded quantized coefficients, motion vector, weights and residual error can also be used to reconstruct the current macroblock in the encoder for use as part of a reference frame for subsequent motion estimation and compensation. The encoder can emulate the procedures of a decoder for this P Frame reconstruction. The emulation of the decoder will result in both the encoder and decoder working with the same reference picture. The reconstruction process, whether done in an encoder, for further inter-coding, or in a decoder, is presented here. Reconstruction of a P Frame can be started after the reference frame (or a portion of a picture or frame that is being referenced) is reconstructed. The encoded quantized coefficients are dequantized 750 and then 2D Inverse Transform 755 is performed resulting in a decoded or reconstructed residual error 760. The encoded motion vectors 725a-725d are decoded and used to locate the already reconstructed best matching sub-macroblocks that make up reconstructed best<br><br>
matching composite macroblock 765. Reconstructed residual error 760 is then added to reconstructed best matching composite macroblock 760 to form reconstructed macroblock 770. Deblocking filter 775 can also be used as part of the encoding or decoding process for pixel enhancement such as, along the edges of the macroblocks or sub-macroblocks. The reconstructed macroblock can be stored in memory, displayed independently or in a picture with other reconstructed macroblocks, or processed further for image enhancement. Those of ordinary skill in the art will recognize that B Frame construction in H.264, including weighted bi-directional prediction, can also utilize multiple sub-macroblocks using similar methods.<br>
[0041] Different encoders implement bi-directional prediction in different ways. As discussed above bi-directional prediction can be implemented as an average of two frames (a form of weighted bi-directional prediction where both weights equal one half), a weighted average of two frames or a temporally derived weighted average of two frames. In addition, different encoders can provide for weighted bi-directional prediction with different encoded bit configurations for the weight parameters. Weight parameter bit configurations can vary in ways such as, for example, the number of bits representing each weight and the use of signed or unsigned weight parameters. Some implementations also provide for an offset value added to the luminance or chrominance values. Bit configurations and offsets will be discussed in more detail below. [0042] A versatile decoder, such as decoder device 155 depicted in FIG. 1, should be able to decode video that was encoded by multiple implementations with various encoded bit configurations and various types of weighted/non-weighted prediction methods. One way of accomplishing this versatility is by having different decoder modules for different encoder implementations and simply identifying the input to the decoder as being of one type or another and then use the decoder module designed for the specified encoder. This method is not efficient or cost effective. A more efficient decoder will reuse a single module to decode multiple encoder implementations. This can be accomplished through innovative preprocessing and module design features of the disclosed methods, which are discussed below.<br>
[0043] The most prevalent weighted bi-directional prediction implementations will now be discussed. Digital signal processing functional symbols such as left bit shift (ยซ) and right bit shift (ยป) will be used extensively in this discussion. Such symbols are well known in the art. Those of ordinary skill in the art would understand that the bit<br><br>
shifting operations could be accomplished by other methods such as, for example, applying a scaling factor through multiplication or division. The implementations include an example of bi-directional averaging in the MPEG-4 Simple Scalable profile, an example of weighted bi-directional prediction in the Real Video 9.0 encoder, an example of weighted bi-directional averaging in the Windows Media Video 9.0 encoder, and an example of general weighted bi-directional prediction in H.264. These are only examples of implementations of weighted bi-directional prediction that can be decoded by utilizing the disclosed methods. As those of ordinary skill in the art can appreciate, other implementations of bi-directional prediction can be accommodated without departing from the spirit or scope of the disclosed methods.<br>
MPEG-4 Implementation<br>
[0044] There is no support for B Frames in the MPEG-4 Simple Profile. However, in order to support limited scalability, the MPEG-4 Simple Scalable Profile does support B Frames. The following averaging mechanism is used to combine predictions from two reference frames:<br>
predjj = (predl fl + pred2 โ +1)ยป1	(5)<br>
[0045] where predly and pred2ij, are 8-bit luminance and chrominance samples from prediction blocks from two reference frames (one past, one future) and predy is the resultant prediction which is used in picture reconstruction to add to the decoded inverse-transform of the residual error. As can be seen, there is no weighted prediction in the MPEG-4 Simple Scalable Profile implementation of B Frames.<br>
RV9 Implementation<br>
[0046] Real Video 9.0 (RV9) is a popular encoder that supports B Frames. The following equation is used in the RV9 implementation to compute the resultant prediction for use in B-frames:<br>
predy = ((((predly ยซl)wl)ยป16 + ((pred2y ยซ?)w2)ยป16)+16)ยป5	(6)<br>
[0047] where predly and pred2y, are 8-bit luminance and chrominance samples from prediction blocks from the two reference frames (one past, one future) and predy is the resultant prediction which will be used in picture reconstruction to add to the decoded inverse-transform of the residual error. In the RV9 implementation, the weights Wj and wa are 14-bit unsigned weights (with a range from 0 to 16383) to be multiplied to the individual predictions predly and pred2y.<br><br>
[0048] In direct mode bi-directional prediction, where the motion vectors are not transmitted for the macroblock, but can be derived from the motion vector of a co-located macroblock of the future reference frame, wi and w2 are computed as relative temporal positions of the B frame with respect to the two reference frames as discussed above. For direct mode as discussed above and depicted in FIG. 5, the weights used in (6) are computed as follows:<br>
Wl=(TBยซ14)/TD	(7)<br>
w2=((TD-TB)ยซ14)/TD	(8)<br>
[0049]   where TB is the temporal distance between the current frame and the previous<br>
reference frame and TD is the temporal distance between the previous reference frame<br>
and the subsequent reference frame.<br>
[0050] The simple averaging method of MPEG-4 (5) can be emulated with (6) by setting Wi and W2 both equal to 8192, which is equivalent to one half in 14-bit representation.<br>
WMV9 Implementation<br>
[0051] Windows Media Video 9.0 (WMV9) is another popular video encoder that supports B Frames. WMV9 implements B Frames similarly to MPEG-4 with (5) above, where predl y and pred2ij, are the 8-bit luminance and chrominance samples from prediction blocks from me two reference frames (one past, one future) and predy is the resultant prediction which will be used in picture reconstruction to add to the decoded inverse-transform of the residual error. Thus, the WMV9 averaging process is same as in MPEG-4.<br>
H.264 Implementation<br>
[0052] The H.264 video compression standard offers weighted and non-weighted prediction for both single directional and bi-directional predicted regions. Weighted prediction is invoked in H.264 by setting one or both variables "predFlagLO" and "predFlagLl" equal to 1. When weighted prediction is not invoked, or when "predFlagLO=0" and "predFlagLl=0", a simple averaging like MPEG-4 above is carried out as follows:<br>
FinaLpred = (predO + predl +1)ยป1	(8)<br>
[0053] where predO and predl, are 8-bit luminance and chrominance (also known as lurna and chroma) samples from prediction blocks from the two reference frames (one<br><br>
past, one future) and Final_pred is the resultant prediction which will be used in picture reconstruction to add to the decoded inverse-transform of the residual error. [0054]   If only one of the two reference partitions is to be weighted, the final predicted sample values are derived as follows:<br>
Case 1 : If predHagLO = 1 and predFlagLl = 0 if(logWD&gt;=l)<br><br>
FinaLpred = Clipl(predo)wO<br><br>
logWT&gt;)+ o<br><br>
(9a)<br><br>
else<br><br>
FinaLpred = Clipl [((predo)wo)+ o0 ]<br><br><br><br>
Case 2: If predFlagLO = 0 and predFlagLl = 1 if(logWD&gt;=l)<br><br>
FinaLpred = Clipl(((predl)wl<br><br>
logWD)+ o,<br><br><br><br>
else<br>
FinaLpred = Clipl [((predl)wl) + ol<br>
[0055] where descriptions, bit size and range of values for the variables are given in Table 1. Case 1 above results in weighted forward P Frame prediction and Case 2 results in weighted backward P Frame prediction. The additive offsets OQ and 01 are not offered in the other weighted prediction implementations listed above. The Clipl LI function is defined as follows:<br><br>
Clipl(x) = Clip3(0,255,x)<br><br>
(11)<br><br><br><br>
Clip3(x,y,z) =<br><br>
z<x z>y otherwise<br><br>
(12)<br><br>
[0056]   If both of the two reference partitions are to be weighted, the final predicted sample values are derived as follows:<br>
Case 3: If predFlagLO = 1 and predFlagLl = 1<br><br>
FinaLpred = Clipl [fpredo)wO + (predl)wl + 2logWD)ยป(logWD +1))<br><br>
(13)<br><br>
[0057]   where descriptions, bit size and range of values for the variables are given in Table 1<br>
Table Removed<br><br><br>
[0058] Both luma and chroma (both Q&gt; and Cr) sample values are evaluated using the above equations (9), (10) and (13). The weight variables wO, wl and logWD are derived separately for the luma parameters and separately for the chroma parameters.<br>
A Single Implementation Satisfying MPEG-4, RV9, WMV9 and H.264<br>
[0059] The four implementations presented above are all widely used and accepted forms of video compression. As shown, each one implements weighted prediction in its own way, some of which differ greatly. Equation (18), below, is an example of a universal formula that is used by embedded hardware, such as a microprocessor of a decoder device such as decoder 155 of Fig.l to decode weighted prediction frames encoded in any of the four implementations. Such a universal formula processes video compressed data in any of the standard formats with minimal pre-processing and maximum reuse of software, firmware or hardware. To implement the universal formula, universal weight prediction factors having a specific bit configuration must be derived from the different weight factors utilized by the different compression standards.<br>
[0060] In this example, an external DSP or other type of processor such as a preprocessor modifies the encoded weight parameters to the universal weight parameters. The calculations performed by the pre-processor to derive the universal weight parameters by modifying the encoded weight parameters are described below with respect to equation sets (19) - (21). What is presented below, in equations (14) - (17), is the derivation of a universal equation (18) for decoding predicted frames. [0061] The H.264 implementation is the most complicated and makes a good starting point. The three cases represented by equations (9), (10) and (13) above can be simplified to one equation, with proper manipulation of the weighting factor variables and offset variables, as follows<br>
FinaLpred = Clipl [(((predOJwO + (predl)wl + 2LWD-' )ยป (LWD))<br>
where the variables LWD, wO, wl, oO and ol are defined as follows for the three cases: For case 1:      wl = 0, and wO is determined by the encoder QI = 0, and OQ is determined by the encoder LWD = logWD<br><br>
For case 2:      wO = 0, and wl is determined by the encoder OQ = 0, and DI is determined by the encoder LWD = logWD<br>
For case 3:      LWD = logWD+1<br>
wO, wl, o0 and DI are determined by the encoder<br>
[0062]   Using the bit sizes listed in Table 1, the bitwidth deduction in Table 2 shows that equation (14) results in an 8 bit value for the weighted prediction samples.<br>
Table Removed<br><br><br>
TABLE 2<br>
[0063] Equation (14) can be modified to eliminate the variable bit shift of LWD bits. Modifying the weights wO and wl and having an external digital signal processor (DSP) or other type of processor program modified weight parameters wO' and wl'. Since LWD has a maximum value of 8, modifying the weights can be accomplished, while keeping the argument of all bit shift operations positive, by multiplying each of the<br><br>
8"LWD<br>
terms in Op. 3 of Table 2 by 2"      and increasing the right bit shift of Op. 4 in Table 2 by (8-LWD) bits as follows:<br>
Final ored =<br>
Clipl |(predo)wO * 28'LWD + (predl)wl * 28-LWD + 27 )ยป (8))	(15)<br>
Replacing the weights wO and wl with modified weights results in:<br><br><br>
l)]<br>
+<br>
FinaLpred = Ciipl |(predo)wO'+(predl)wr+27 )ยป 8J+ ((o0 + Oj where wO1 = wO ยซ (8 - LWD) and wl' - wl ยซ (8 - LWD)<br>
[0064]   Cases 1, 2 and 3, listed above in equations 9, 10 and 13, can be handled using equation (16) with the following variables defined by a DSP or other pre-processor.<br><br>
For Case 1:<br><br>
wr=wi=o<br>
Oj =0<br>
LWD = logWD<br><br>
wO' = wO =<br>
For Case 2:<br>
LWD = logWD<br>
For Case 3:  LWD = logWD + l<br>
[0065] In addition to the pre-processor performing a left-bit-shift on the modified weights, it can also increase the number of bits of the weights. This can be done to ensure compatibility with multiple implementations. The DSP or pre-processor can zero-extend the weights in the case of unsigned variables as in the RV9 implementation or sign-extend in the case of signed variables as in the H.264 implementation. Table 3 shows the resulting bitwidth deduction for the variables and operations of equation (16) using 8 bit signed weights, where the weights are sign extended to 9 bits. The offset operation number 4 in Table 3 can also be performed in a pre-processor.<br>
Table Removed<br><br><br><br><br>
TABLE 3<br>
[0066] Equation 16, with the bitwidths shown in Table 3 and the encoded variables shown in Table 1, can be implemented in a microprocessor and used to implement all of the weighted bi-directional prediction implementations presented above except the RV9 implementation. Further modifications to equation (16) are needed to support the 14 bit unsigned weights of RV9.<br>
[0067] The weights wO' and wl' in equation (16) can be left shifted 6 bits in order to match the 14 bit bitwidths of the RV9 weights, resulting in:<br><br>
FinaLpred = Clipl[((((predo)wO'ยซ 6Jยป 6 + ((predl)wrยซ 6)ยป 6 + 27)ยป 8J<br><br>
(17)<br><br>
which can be represented as follows:<br><br>
pred, =<br><br>
((predOJwA)ยป 6 + (predljwB ยป 6<br><br>
27<br><br>
ยป 8+Offset<br><br>
(18)<br><br>
where WA, WB and Offset can be calculated by the pre-processor based on what implementation was used to encode the weight parameters (see pre-processor calculations below). Table 4 shows an example of a bitwidth deduction for the variables and operations of equation (18) using 15 bit weights WA and WB and 8 bit offsets that can accommodate all of the examples of weighted prediction described above.<br><br>
Table Removed<br><br><br>
TABLE 4<br>
[0068] Implementing equation 18 in embedded hardware, such as a microprocessor, and using an external DSP or other type of processor as a pre-processor for modifying the encoded weight parameters is a cost effective and efficient method of handling multiple implementations of weighted prediction. A preprocessor such as pre-processor 170 depicted in FIG. 1 and pre-processor 810 depicted in FIG. 8 could be used for modifying the encoded weight parameters. The pre-processor will perform the following calculations when modifying the encoded weight parameters, for the various implementations listed, and supply the modified variables to the embedded microprocessor:<br>
Modified weighted prediction factors WA and WB based on H.264 encoded weighted prediction with 8 bit signed weights wO and wl, 8 bit signed offsets o0 and 01, and logWD are calculated using Equation Set (19) Below. Equation Set (19):<br>
w A = sign_extend((wO'ยซ 6115) WB =sign_extend((wl'ยซ6Jil5) Offset = (o0 + Oj +1)ยป1 wO' = wOยซ(8-LWD) wl' = wlยซ(8~LWD)<br>
where LWD, wO and wl depend on the 3 Cases as described above and listed in equations (9), (10) and (13): For case 1:      wl = 0, and wO is determined by the encoder QI = 0, and OQ is determined by the encoder LWD = logWD which is determined by the encoder The encoder determines predO.<br><br>
For case 2:      wO = 0, and w 1 is determined by the encoder OQ = 0, and QI is determined by the encoder LWD = logWD which is determined by the encoder The encoder determines predl.<br>
For case 3:      LWD = logWD+l<br>
The encoder determines predO, predl, LogWD, wO, wl, o0 and<br>
Oi.<br>
Modified weighted prediction factors WA and WB based on RV9 encoded weighted prediction with 14 bit unsigned weights wl and w2 calculated using Equation Set (20) below.<br>
Equation Set (20):<br>
WA = zero_extend(wl,15) WB = zero_extend(w2,15J Off set = 0<br>
predl = pred2y<br>
Modified weighted prediction factors WA and WB based on WMV9 or MPEG-4 encoded simple averaged prediction are calculated using Equation Set (21) below. Equation Set (21):<br>
WA = zero_extend(l6383,15) WB = zero_extend (16383, 15) Offset = 0 predO = predly predl = pred2y<br>
[0069] As one of ordinary skill in the art will recognize, other weighted prediction implementations could be implemented in a similar manner. The bit configuration of the weight variables WA and WB in Equation (18) could be chosen to be larger to accommodate more than 14 bit encoded weights. The bit configuration of the weight variables WA and WB in Equation (18) could be chosen to be smaller than 14 bits if loss<br><br>
of the lower bits is acceptable. Also, different sized offsets could be accommodated in a similar manner. As was shown above, both signed and unsigned variables can be accommodated as well. Bit configuration choosing means such as pre-processor module 170 of FIG, 1 can be used to choose the appropriate bit configuration necessary to accommodate weight variables and offsets with multiple encoded bit configurations. [0070] FIG. 8 is a flow chart of an example of a decoder process for decoding multiple encoder implementations of weighted bi-directional predicted video data. Process 800 could be carried out with a device such as decoder device 155 depicted in FIG. 1. The process is carried out by three main components including predictive decoding component 165, pre-processor component 170 such as a DSP that is external to the predictive decoding component 165 and at least one memory module 175 to store various data. The combination of a predictive decoding component 165 and external pre-processor component 175 allows for simple hardware design of the microprocessor that can perform several examples of weighted prediction with implementation specific calculations done in the pre-processor depending on the encoder implementation that is being decoded.<br>
[0071] The decoder device receives encoded video data over a network, such as network 150 of FIG. 1, or from external memory such as external storage component 180 of FIG. 1. Receiving means such as communications component 190 of FIG. 1 can perform the receiving task. Decoding of an inter-coded picture can start when the reference picture or pictures are already decoded and stored in memory such as memory module 175 in FIG. 1. There will be only one reference frame (either past or future) when doing Case 1 or Case 2 in the H.264 Implementation as presented above. When doing bi-directional predicted decoding, both past and future reference pictures are stored in memory. Retrieving steps 810 and 815 access the first reference picture (a past reference picture, for example) and the second reference picture (a future reference picture, for example), respectively, from memory. Padding the border edges of the decoded pictures with zeroes (reflection can also be used) is done in preparation for pixel interpolation. The act of padding in step 830 allows for multiple tapped filters to correctly interpolate between border area pixels where an insufficient number of pixels exist. Pixel interpolation, step 835, is used to achieve better matching reference regions for motion compensation. An encoder can perform pixel interpolation to locate the best matching reference macroblock (or any size section) and point to the pixel or<br><br>
interpolated pixel with a motion vector. In the case of bi-directional prediction, there are two motion vectors. Also, when utilizing the direct mode as discussed above, the decoder calculates the motion vectors through temporal interpolation of a motion vector of a co-located macroblock in the future reference picture. The decoder uses the motion vectors to perform motion compensation region location, step 840, to locate the best matching regions among the interpolated pixels. Pixel interpolation, step 835, will be discussed in more detail below. The luma and chroma values of the two best matching prediction regions, predO and predl, output at step 840, are multiplied, steps 845 and 850, by modified weights WA and WB respectively (weight modification is discussed below). After applying the weights, both weighted regions are right bit-shifted 6 bits, steps 855 and 860, and added, step 865, to the rounding factor 27 and then right bit shifted 8 bits, step 870, to form the combined weighted prediction. Calculating means such as predictive decoding module 165 of FIG. 1 can perform the multiplication steps 845 and 850, the bit shift steps 855, 860 and 870, and the addition step 865 for calculating the combined weighted prediction. The quantized residual error DCT coefficients corresponding to the weighted prediction regions is received over a network or from external storage, step 820. Performing inverse quantization, step 875, and performing the Inverse Transform, step 880, (such as, for example, an inverse DCT or an inverse wavelet transform) results in the decoded residual error, which is added, step 885, to the combined weighted prediction and the preprocessor modified offset (offset modification is discussed below) to form an output picture. Residual error and offset combining means such as predictive decoding module 165 of FIG. 1 can perform addition step 885. The output picture can be stored in memory and/or displayed on display means such as display component 185 in FIG. 1, step 825. [0072] Weight parameters corresponding to the weighted prediction regions are received, step 827. A pre-processor such as pre-processor component 170 in FIG. 1 is used to modify received encoded weights WA, and WB to match the bit configuration of the universal weight prediction factors that the embedded microprocessor code was designed for, step 852. The pre-processor is also used to modify any received offset(s), step 856, that the embedded microprocessor will use such that the offsets conform to the bit configuration that the embedded microprocessor code was designed for.. The modifications will be dependent on which form of weighted prediction was used to encode the data (example modifications listed in Equation Sets (19) - (21) above). The<br><br>
pre-processor can receive a flag from an input bit stream identifying the type of encoded data that it is receiving (such as, for example H.264, RV9, WMV9 or MPEG-4 encoded video data). The encoder dependent modifications to the weights and offsets are discussed above in relationship to equation 18 which is the example depicted in FIG. 8. Modifying means such as pre-processor module 170 of FIG. 1 can perform the modifications to the weights and offsets. When one of the weights is zero, such as in Case 1 or Case 2 in the H.264 Implementation as presented above, zero weight identifying means such as pre-processor module 170 of FIG. 1 sets the corresponding weight parameter to zero.<br>
[0073] In some circumstances, a video encoder might specify a null region for a macroblock during motion compensation analysis. A null region refers to the absence of a reference picture for the macroblock under consideration. Weighted prediction logic can check a reference list ID for the presence and relationship of the reference pictures. In the case of a null region, null region locating and identifying means such as pre-processor module 170 of FIG. 1 can set the corresponding weight to zero or perform other operations known to those of ordinary skill in the art to handle the null region scenario.<br>
[0074] Pixel interpolation can be used to improve the performance of motion compensated predictive coding. FIG. 9 is an illustration of an example of half-pixel interpolation for use in motion compensation. The example shown is half pixel interpolation where one interpolated pixel is located between each of the original integer pixels. Integer pixels 910 are depicted as circles labeled upper case "A" to "I" and the interpolated or half-pixels 920 are depicted as squares labeled lower case "a" to "o". Half pixel interpolation can be carried out with a bilinear filter such as, for example, a 2-tap FIR filter with weights [0.5 0.5]. For example, interpolated pixel 922 can be calculated as the average of integer pixel 912 and integer pixel 914, interpolated pixel 924 can be the average of integer pixel 912 and integer pixel 916, and interpolated pixel 926 can be the average of two interpolated pixels (for example, 922 and 928 or 924 and 930). Both the luminance (Y) and chrominance (Cr and Cb) components can be interpolated in this fashion. Other orders of pixel interpolation are supported by various standards. H.264 supports quarter pixel interpolation as well as eighth pixel interpolation. Those of ordinary skill in the art would understand these other pixel interpolation methods and they are not discussed in greater detail herein.<br><br>
[0075] Examples of the embodiments described above include: [0076] A method for constructing a predicted picture, that includes: modifying a first weight parameter associated with a region of a first frame to conform to a bit configuration, modifying a second weight parameter associated with a region of a second frame to conform to the bit configuration, calculating a first predicted component by applying the modified first weight parameter to the region of the first frame, calculating a second predicted component by applying the modified second weight parameter to the region of the second frame, and calculating a combined weighted prediction by combining the first predicted component and the second predicted component.<br>
[0077] An apparatus for constructing a predicted picture, that includes: means for modifying a first weight parameter associated with a region of a first frame to conform to a bit configuration, means for modifying a second weight parameter associated with a region of a second frame to conform to the bit configuration, means for calculating a first predicted component by applying the modified first weight parameter to the region of the first frame, means for calculating a second predicted component by applying the modified second weight parameter to the region of the second frame, and means for calculating a combined weighted prediction by combining the first predicted component and the second predicted component.<br>
[0078] An electronic device for constructing a predicted picture, the electronic device configured to modify a first weight parameter associated with a region of a first frame to conform to a bit configuration, to modify a second weight parameter associated with a region of a second frame to conform to the bit configuration, to calculate a first predicted component by applying the modified first weight parameter to the region of the first frame, to calculate a second predicted component by applying the modified second weight parameter to the region of the second frame, and to calculate a combined weighted prediction by combining the first predicted component and the second predicted component.<br>
[0079] A computer-readable medium embodying means for causing a computer to execute a method for constructing a predicted picture, the method includes: modifying a first weight parameter associated with a region of a first frame to conform to a bit configuration, modifying a second weight parameter associated with a region of a second frame to conform to the bit configuration, calculating a first predicted<br><br>
component by applying the modified first weight parameter to the region of the first frame, calculating a second predicted component by applying the modified second weight parameter to the region of the second frame, and calculating a combined weighted prediction by combining the first predicted component and the second predicted component.<br>
[0080] Those of ordinary skill in the art would understand that information and signals may be represented using any of a variety of different technologies and techniques. For example, data, instructions, commands, information, signals, bits, symbols, and chips that may be referenced throughout the above description may be represented by voltages, currents, electromagnetic waves, magnetic fields or particles, optical fields or particles, or any combination thereof.<br>
[0081] Those of ordinary skill would further appreciate that the various illustrative logical blocks, modules, and algorithm steps described in connection with the examples disclosed herein may be implemented as electronic hardware, computer software, or combinations of both. To clearly illustrate this interchangeability of hardware and software, various illustrative components, blocks, modules, circuits, and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application, but such implementation decisions should not be interpreted as causing a departure from the scope of the disclosed methods.<br>
[0082] The various illustrative logical blocks, modules, and circuits described in connection with the examples disclosed herein may be implemented or performed with a general purpose processor, a digital signal processor (DSP), an application specific integrated circuit (ASIC), a field programmable gate array (FPGA) or other programmable logic device, discrete gate or transistor logic, discrete hardware components, or any combination thereof designed to perform the functions described herein. A general purpose processor may be a microprocessor, but in the alternative, the processor may be any conventional processor, controller, microcontroller, or state machine. A processor may also be implemented as a combination of computing devices, e.g., a combination of a DSP and a microprocessor, a plurality of<br><br>
microprocessors, one or more microprocessors in conjunction with a DSP core, or any other such configuration.<br>
[0083] The steps of a method or algorithm described in connection with the examples disclosed herein may be embodied directly in hardware, in a software module executed by a processor, or in a combination of the two. A software module may reside in RAM memory, flash memory, ROM memory, EPROM memory, EEPROM memory, registers, hard disk, a removable disk, a CD-ROM, or any other form of storage medium known in the art. An exemplary storage medium is coupled to the processor such that the processor can read information from, and write information to, the storage medium. In the alternative, the storage medium may be integral to the processor. The processor and the storage medium may reside in an Application Specific Integrated Circuit (ASIC). The ASIC may reside in a wireless modem. In the alternative, the processor and the storage medium may reside as discrete components in the wireless modem. [0084] The previous description of the disclosed examples is provided to enable any person of ordinary skill in the art to make or use the disclosed examples. Various modifications to these examples will be readily apparent to those skilled in the art, and the principles defined herein may be applied to other examples without departing from the spirit or scope of the disclosed methods.<br>
[0085] Thus, a method, apparatus and system to reconstruct weighted bi-directional predicted video data that has been encoded with different implementations of weighted bi-directional prediction have been described. WHAT IS CLAIMED IS:<br><br><br><br>
We claim:<br>
1.	An apparatus for constructing a predicted picture, comprising a decoder (155) having an intra<br>
decoding module (160), a predictive decoding processor module (165), a pre processing module<br>
(170), a memory module (175) and a communication component (190), said pre processing module<br>
(170) itself comprising:<br>
a module for modifying a first weight parameter (852) to conform to a bit configuration;<br>
a module for modifying a second weight parameter (852) to conform to the bit configuration;<br>
a module for calculating a first predicted component by applying the modified first weight parameter (845) to the region of the first frame;<br>
a module for calculating a second predicted component by applying the modified second weight parameter (850) to the region of the second frame; and<br>
a module for calculating a combined weighted prediction by combining (865) the first predicted component and the second predicted component.<br>
2.	The apparatus as claimed in claim 1, wherein the bit configuration is chosen to accommodate a plurality of encoded bit configurations, wherein at least two of the plurality of encoded bit configurations have different numbers of bits.<br>
3.	The apparatus as claimed in claim 1, wherein the bit configuration is chosen to accommodate a plurality of encoded bit configurations, wherein at least one of the plurality of encoded bit configurations is signed and at least one of the plurality of encoded bit configurations is unsigned.<br>
4.	The apparatus as claimed in claim 1, wherein the region of the first frame is located by using a motion vector.<br><br>
5.	The apparatus as claimed in claim 1, wherein the region of the second frame is located by using a motion vector.<br>
6.	The apparatus as claimed in claim 1, wherein the region of the first frame and the region of the second frame are located by using direct mode temporal interpolation of a decoded motion vector between the first frame and the second frame.<br>
7.	The apparatus as claimed in claim 1, wherein the region of the first frame is located by identifying that the region of the first frame is a null region; and<br>
the first predicted component is calculated to be equal to zero.<br>
8.	The apparatus as claimed in claim 1, wherein the region of the second frame is located by<br>
identifying that the region of the second frame is a null region; and<br>
the second predicted component is calculated to be equal to zero.<br>
9.	The apparatus as claimed in claim 1, wherein the first weight parameter and the second weight parameter are a same encoded bit configuration.<br>
10.	The apparatus as claimed in claim 1, wherein the first weight parameter is identified to as zero; and<br>
the first predicted component is calculated to be equal to zero.<br>
11.	The apparatus as claimed in claim 1, wherein the second weight parameter is identified as<br>
zero; and<br>
the second predicted component is calculated to be equal to zero.<br>
12.	The apparatus as claimed in claim 1, wherein the first weight parameter and the second<br>
weight parameter are signed.<br>
13.	The apparatus as claimed in claim 1, wherein the combined weighted prediction is normalized.<br><br>
14.	The apparatus as claimed in claim 1, wherein the combined weighted prediction is normalized by bit shifting the combined weighted prediction a number of bits based on a base two logarithm of a denominator associated with the first weight parameter and the second weight parameter.<br>
15.	The apparatus as claimed in claim 1, wherein a first offset parameter is associated with the region of the first frame;<br>
a second offset parameter is associated with the region of the second frame; and the first offset parameter and the second offset parameter are combined with the combined weighted prediction.<br>
16.	The apparatus as claimed in claim 1, wherein a residual error is associated with the combined<br>
weighted prediction; and<br>
the residual error is combined with the combined weighted prediction.<br>
17.	The apparatus as claimed in claim 1, wherein the first weight parameter, the second weight parameter, the region of the first frame and the region of the second frame are represented by encoded video data transmitted over a network.<br>
18.	The apparatus as claimed in claim 1, wherein the combined weighted prediction is displayed.<br>
19.	The apparatus as claimed in claim 1, wherein the first weight parameter is modified by bit shifting; and<br>
the second weight parameter is modified by bit shifting.<br>
20.	The apparatus as claimed in claim 1, wherein the first weight parameter is modified by sign<br>
extending; and<br>
the second weight parameter is modified by sign extending.<br>
21.	The apparatus as claimed in claim 1, wherein the first weight parameter is modified by zero<br>
extending; and<br>
the second weight parameter is modified by zero extending.<br><br>
22.	The apparatus as claimed in claim 1, wherein the first weight parameter is modified by<br>
applying a scaling factor; and<br>
the second weight parameter is modified by applying a scaling factor.<br>
23.	A method for constructing a predicted picture by an apparatus comprising a decoder (155)<br>
having an intra decoder (160), a predictive decoding processor (165), a pre-processor (170), a<br>
memory (175) and a communication component (190), said method comprising the steps of:<br>
modifying a first weight parameter (852) to conform to a bit configuration by said preยฌprocessor (170);<br>
modifying a second weight parameter (852) to conform to the bit configuration by said pre processor (170);<br>
calculating a first predicted component by applying the modified first weight parameter (845) to the region of the first frame by said pre processor (170);<br>
calculating a second predicted component by applying the modified second weight parameter (850) to the region of the second frame by said pre processor (170); and<br>
calculating a combined weighted prediction by combining (865) the first predicted component and the second predicted component by said predictive decoding processor (165).<br>
24.	The method as claimed in claim 23, wherein the bit configuration is configured to accommodate a plurality of encoded bit configurations, wherein at least two of the plurality of encoded bit configurations have different numbers of bits.<br>
25.	The method as claimed in claim 23, wherein the bit configuration is configured to accommodate a plurality of encoded bit configurations, wherein at least one of the plurality of encoded bit configurations is signed and at least one of the plurality of encoded bit configurations is unsigned.<br>
26.	The method as claimed in claim 23, wherein the region of the first frame is located by using a first motion vector; and<br>
the region of the second frame is located by using a second motion vector.<br><br>
27.	The method as claimed in claim 23, wherein the region of the first frame and the region of the second frame are located by using direct mode temporal interpolation of a decoded motion vector between the first frame and the second frame.<br>
28.	The method as claimed in claim 23, wherein the region of the first frame is located by identifying that the region of the first frame is a null region; and<br>
the first predicted component is calculated to be equal to zero.<br>
29.	The method as claimed in claim 23, wherein the region of the second frame is located by<br>
identifying that the region of the second frame is a null region; and<br>
the second predicted component is calculated to be equal to zero.<br>
30.	The method as claimed in claim 23, wherein the first weight parameter and the second weight parameter are a same encoded bit configuration.<br>
31.	The method as claimed in claim 23, wherein the first weight parameter is identified as zero; and<br>
the first predicted component is calculated to be equal to zero.<br>
32.	The method as claimed in claim 23, wherein the second weight parameter is identified as<br>
zero; and<br>
the second predicted component is calculated to be equal to zero.<br>
33.	The method of claim 23, wherein the first weight parameter and the second weight parameter<br>
are signed.<br>
34.	The method as claimed in claim 23, wherein the combined weighted prediction is normalized by bit shifting the combined weighted prediction a number of bits based on a base two logarithm of a denominator associated with the first weight parameter and the second weight parameter.<br><br>
35.	The method as claimed in claim 23, wherein said combined weighted prediction is combined<br>
with<br>
a.	a first offset parameter associated with the region of the first frame;<br>
b.	a second offset parameter associated with the region of the second frame; and<br>
c.	a residual error associated with the combined weighted prediction;<br>
36.	The method as claimed in claim 23, wherein said communication component (190) receives an encoded video data representing the first weight parameter, the second weight parameter, the region of the first frame and the region of the second frame, over a network (150).<br>
37.	The method as claimed in claim 23, wherein said communication component (190) receives an encoded video data representing the first weight parameter, the second weight parameter, the region of the first frame and the region of the second frame, from said memory (175).<br>
38.	The method as claimed in claim 23, wherein the combined weighted prediction is displayed.<br>
39.	The method as claimed in claim 23, wherein the first weight parameter is modified by performing an operation selected from the group consisting of bit shifting, sign extending, zero extending and applying a scaling factor; and<br>
the second weight parameter is modified by performing an operation selected from the group consisting of bit shifting, sign extending, zero extending and applying a scaling factor, the second weight parameter is modified by applying a scaling factor.</x></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1ERUxOUC0yMDA2LUFic3RyYWN0LSgwOC0xMC0yMDA5KS5wZGY=" target="_blank" style="word-wrap:break-word;">6639-DELNP-2006-Abstract-(08-10-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1ERUxOUC0yMDA2LUNsYWltcy0oMDgtMTAtMjAwOSkucGRm" target="_blank" style="word-wrap:break-word;">6639-DELNP-2006-Claims-(08-10-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1ERUxOUC0yMDA2LUNsYWltcy0oMjYtMDYtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">6639-DELNP-2006-Claims-(26-06-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMjYtMDYtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">6639-DELNP-2006-Correspondence Others-(26-06-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlLU90aGVycy0oMDgtMTAtMjAwOSkucGRm" target="_blank" style="word-wrap:break-word;">6639-DELNP-2006-Correspondence-Others-(08-10-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1ERUxOUC0yMDA2LURlc2NyaXB0aW9uIChDb21wbGV0ZSktKDA4LTEwLTIwMDkpLnBkZg==" target="_blank" style="word-wrap:break-word;">6639-DELNP-2006-Description (Complete)-(08-10-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1ERUxOUC0yMDA2LURyYXdpbmdzLSgwOC0xMC0yMDA5KS5wZGY=" target="_blank" style="word-wrap:break-word;">6639-DELNP-2006-Drawings-(08-10-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1ERUxOUC0yMDA2LUZvcm0tMS0oMDgtMTAtMjAwOSkucGRm" target="_blank" style="word-wrap:break-word;">6639-DELNP-2006-Form-1-(08-10-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LWZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1ERUxOUC0yMDA2LUZvcm0tMi0oMDgtMTAtMjAwOSkucGRm" target="_blank" style="word-wrap:break-word;">6639-DELNP-2006-Form-2-(08-10-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1ERUxOUC0yMDA2LUdQQS0oMDgtMTAtMjAwOSkucGRm" target="_blank" style="word-wrap:break-word;">6639-DELNP-2006-GPA-(08-10-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LWdwYS5wZGY=" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LXBjdC0yMTAucGRm" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-pct-210.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LXBjdC0yMjAucGRm" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-pct-220.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LXBjdC0yMzcucGRm" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-pct-237.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjYzOS1kZWxucC0yMDA2LXBjdC0zMDQucGRm" target="_blank" style="word-wrap:break-word;">6639-delnp-2006-pct-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QuanBn" target="_blank" style="word-wrap:break-word;">abstract.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="257474-receiver-structures-for-spatial-spreading-with-space-time-or-space-frequence-transmit-diversity.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="257476-fluid-interface-level-measurement-device.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>257475</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>6639/DELNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>41/2013</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>11-Oct-2013</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>07-Oct-2013</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>09-Nov-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 MOREHOUSE DRIVE, SAN DIEGO, CALIFORNIA 92121-1714, USA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>KENT G. WALKER</td>
											<td>14484 HUNTINGTON GATE DRIVE, POWAY, CA 92064, USA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>VIJAYALAKSHMI RAVEENDRAN</td>
											<td>4272 CALLE MAR DE BALLENAS, SAN DIEGO, CA 92130, USA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04N 7/46</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2005/015449</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-05-04</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/568,154</td>
									<td>2004-05-04</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/257475-an-apparatus-for-constructing-a-predicted-picture-and-a-method-thereof by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:18:13 GMT -->
</html>
