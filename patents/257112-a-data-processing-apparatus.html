<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/257112-a-data-processing-apparatus by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:48:55 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 257112:&quot;A DATA PROCESSING APPARATUS&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;A DATA PROCESSING APPARATUS&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A data processing apparatus which comprises: decode control means (214) for determining whether an output of the video data is later than an output of the output data; command means (214) for causing a process for one access unit of the encoded video data to be skipped when the determined result of the first determination means (214) represents that the output of the video data is later than the output of the output data; decode control means (214) for determining whether the video data are referenced when other encoded video data are decoded corresponding to the reference information of the encoded video of the access unit whose process has been caused to be skipped by the command means; and video decoder control means (216) for skipping the process of the encoded video data of the access unit whose process has been caused to be skipped by the command means when the second determination means (214) has determined that video data corresponding to the encoded video data of the access unit whose process has been caused to be skipped by the command means are hot referenced when the other encoded data are decoded, encoded video data obtained by every predetermined unit that is an access unit, output data that are output in synchronization with the video data, and utilization information immediately followed by at least one decode startable point of the encoded video data and utilized for decoding the encoded video data, the utilization information containing reference information that represents whether video data corresponding to the encoded video data of at least one access unit that are present from the utilization information to the next utilization information are referenced when other encoded video data are decoded,</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>The present invention relates to a data processing apparatus<br>
In particular the present invention relates to those that allow data to be highly conveniently processed. Background Art<br>
In recent years, as a recording medium that has a large storage capacity and that can be randomly accessed, for example a digital versatile disc (DVD) has been outspread.  In addition, a DVD device that performs various processes with a DVD has been also outspread.<br>
As DVD devices, there are a DVD recorder that records and reproduces data of television broadcast programs and so forth to and from a DVD, a car navigation system that uses a DVD on which map information and so forth have been recorded, reproduces the map information therefrom, and displays it, a game device that uses a DVD on which a game program and so forth have been recorded, reads the program therefrom, and executes it, and other devices. <br>
The details of the DVD are described for example in Non-Patent Document 1, "DVD Specifications for Read-Only Disc Part 3; Version 1.1 December 1997".<br>
A recording medium such as a DVD on which a large amount of data is recorded and a DVD device that uses it need to allow such a large amount of data to be highly conveniently processed. Disclosure of the Invention<br>
The present invention is made from the foregoing point of view and an object of the present invention is to highly conveniently process data.<br>
The present invention is a data processing apparatus that processes encoded data, the encoded data containing encoded video data obtained by encoding video data every a predetermined unit that is an access unit, output data that are output in synchronization with the video data, and utilization information immediately followed by at least one decode startable point of the encoded video data and utilized for decoding the encoded video data, the utilization information containing reference information that represents whether video data corresponding to the encoded video data of at least one access unit that are present from the utilization information to the next utilization information are referenced when other encoded video data are decoded, the data processing apparatus comprising first determination means for<br><br>
determining whether an output of the video data is later than an output of the output data, command means for causing a process for one access unit of the encoded video data to be skipped when the determined result of the first determination means represents that the output of the video data is later than the output of the output data, second determination means for determining whether the video data are referenced when other encoded video data are decoded corresponding to the reference information of the encoded video of the access unit whose process has been caused to be skipped by the command means, and skip control means for skipping the process of the encoded video data of the access unit whose process has been caused to be skipped by the command means when the second determination means has determined that video data corresponding to the encoded video data of the access unit whose process has been caused to be skipped by the command means are not referenced when the other encoded data are decoded.<br>
The present invention is a data processing method of processing encoded data, the encoded data containing encoded video data obtained by encoding video data every a predetermined unit that is an access unit, output data that are output in synchronization with the video data, and utilization information immediately followed by at least one decode startable point of the encoded video data and utilized for<br><br>
decoding the encoded video data, the utilization information containing reference information that represents whether video data corresponding to the encoded video data of at least one access unit that are present from the utilization information to the next utilization information are referenced when other encoded video data are decoded, the data processing method comprising the steps of: determining whether an output of the video data is later than an output of the output data; causing a process for the encoded video data of one access unit to be skipped when the determined result at the first determination step represents that the output of the video data is later than the output of the output data; determining whether the video data are referenced when other encoded video data are decoded corresponding to the reference information of the encoded video of the access unit whose process has been caused to be skipped at the command step; and skipping the process of the encoded video data of the access unit whose process has been caused to be skipped at the command step when it has been determined at the second determination step that video data corresponding to the encoded video data of the access unit whose process has been caused to be skipped at the command step are not referenced when the other encoded video data are decoded.<br>
The present invention is a program that<br><br>
causes a computer to execute a data process of processing encoded data, the encoded data containing encoded video data obtained by encoding video data every a predetermined unit that is an access unit, output data that are output in synchronization with the video data, and utilization information immediately followed by at least one decode startable point of the encoded video data and utilized for decoding the encoded video data, the utilization information containing reference information that represents whether video data corresponding to the encoded video data of at least one access unit that are present from the utilization information to the next utilization information are referenced when other encoded video data are decoded, the program comprising the steps of: determining whether an output of the video data is later than an output of the output data; causing a process for the encoded video data of one access unit to be skipped when the determined result at the first determination step represents that the output of the video data is later than the output of the output data; determining whether the video data are referenced when other encoded video data are decoded corresponding to the reference information of the encoded video of the access unit whose process has been caused to be skipped at the command step; and skipping the process of the encoded video data of the access unit whose process has<br><br>
been caused to be skipped at the command step when it has been determined at the second determination step that video data corresponding to the encoded video data of the access unit whose process has been caused to be skipped at the command step are not referenced when the other encoded video data are decoded.<br>
The present invention is a program recording medium on which a program has been recorded, the program causing a computer to execute a data process of processing encoded data, the encoded data containing encoded video data obtained by encoding video data every a predetermined unit that is an access unit/ output data that are output in synchronization with the video data, and utilization information immediately followed by at least one decode startable point of the encoded video data and utilized for decoding the encoded video data, the utilization information containing reference information that represents whether video data corresponding to the encoded video data of at least one access unit that are present from the utilization information to the next utilization information are referenced when other encoded video data are decoded, the program comprising the steps of: determining whether an output of the video data is later than an output of the output data; causing a process for the encoded video data of one access unit to be skipped when the determined result at the first<br><br>
determination step represents that the output of the video data is later than the output of the output data/determining whether the video data are referenced when other encoded video data are decoded corresponding to the reference information of the encoded video of the access unit whose process has been caused to be skipped at the command step; and skipping the process of the encoded video data of the access unit whose process has been caused to be skipped at the command step when it has been determined at the second determination step that video data corresponding to the encoded video data of the access unit whose process has been caused to be skipped at the command step are not referenced when the other encoded video data are decoded.<br>
The present invention is a data recording medium on which encoded data have been recorded, the encoded data containing encoded video data obtained by encoding video data every a predetermined unit that is an access unit, output data that are output in synchronization with the video data, and utilization information immediately followed by at least one decode startable point of the encoded video data and utilized for decoding the encoded video data, the utilization information containing reference information that represents whether video data corresponding to the encoded video data of at least one access unit that are present from the utilization information to the next<br><br>
information are referenced when other encoded video data are decoded.<br>
The present invention is a data structure of an encoded data, the encoded data containing encoded video data obtained by encoding video data every a predetermined unit that is an access unit, output data that are output in synchronization with the video data, and utilization information immediately followed by at least one decode startable point of the encoded video data and utilized for decoding the encoded video data, the utilization information containing reference information that represents whether video data corresponding to the encoded video data of at least one access unit that are present from the utilization information to the next utilization information are referenced when other encoded video data are decoded.<br>
In a data processing apparatus, a data<br>
processing method, a program, and a program recorded on a program recording medium of the present invention, utilization information is immediately followed by at least one decode startable point of encoded video data, the utilization information containing reference information that represents whether video data corresponding to the encoded video data of at least one access unit that are present from the utilization information to the next utilization information are referenced when other encoded video data are decoded.<br><br>
It is determined whether an output of the video data is later than an output of the output data. A process for the encoded video data of one access unit is caused to be skipped when the determined result represents that the output of the video data is later than the output of the output data.  It is determined whether the video data are referenced when other encoded video data are decoded corresponding to the reference information of the encoded video of the access unit whose process has been caused to be skipped. The process of the encoded video data of the access unit whose process has been caused to be skipped is skipped when it has been determined that video data corresponding to the encoded video data of the access unit whose process has been caused to be skipped are not referenced when the other encoded video data are decoded.<br>
In a data recording medium and a data structure of the present invention, encoded data contains encoded video data obtained by encoding video data every a predetermined unit that is an access unit/ output data that are output in synchronization with the video data, and utilization information immediately followed by at least one decode startable point of the encoded video data and utilized for decoding the encoded video data, the utilization information containing reference information that represents whether video data corresponding to the encoded video<br><br>
data of at least one access unit that are present from the utilization information to the next utilization information are referenced when other encoded video data are decoded.<br>
According to the present invention, data can be highly conveniently processed.  In particular, video data and output data that need to be output in synchronization therewith can be easily synchronized. Brief Description of Drawings<br>
Fig. 1 is a block diagram showing an example of the structure of hardware of a disc device according to the present invention;<br>
Fig. 2A and Fig. 2B are block diagrams showing an example of the structure of a software module group that a CPU 112 executes;<br>
Fig. 3 is a block diagram showing an example of the structure of a buffer control module 215;<br>
Fig. 4 is a schematic diagram showing an example of the structure of directories of a disc 101;<br>
Fig. 5 is a schematic diagram showing the syntax of a file "PLAYLIST.DAT";<br>
Fig. 6 is a schematic diagram showing the syntax of PlayltemO;<br>
Fig. 7 is a schematic diagram showing the syntax of PlayListMark();<br>
Fig. 8 is a schematic diagram showing the relationship of the value of mark type and the type of<br><br>
Mark();<br>
Fig. 9 is a schematic diagram showing the relationship of PlayListO, Playltemf), clips, and program streams stored in a clip stream file;<br>
Fig. 10 is a schematic diagram showing the syntax of a clip information file ClipO;<br>
Fig. 11 is a schematic diagram showing the relationship of stream_id, private_stream_id, and elementary streams identified thereby;<br>
Fig. 12 is a schematic diagram showing the syntax of Staticlnfo();<br>
Fig. 13 is a schematic diagram showing the syntax of Dynamiclnfo();<br>
Fig. 14 is a schematic diagram showing the syntax of EP_map();<br>
Fig. ISA and Fig. 15B are schematic diagrams showing the syntax of a program stream, a program stream pack, and a program stream pack header of the MPEG-2 system;<br>
Fig. 16A and Fig. 16B are schematic diagrams showing the syntax of a PES packet of the MPEG-2 system;<br>
Fig. 17A, Fig. 17B and Fig. 17C are schematic diagrams showing the syntax of the PES packet of the MPEG-2 system;<br>
Fig. ISA and Fig. 18B are schematic diagrams showing the syntax of the PES packet of the MPEG-2<br><br>
system;<br>
Fig. 19A and Fig. 19B are schematic diagrams showing the relationship of the value of stream_id of PES_packet() and the attribute (type) of an elementary stream of the MPEG-2 system;<br>
Fig. 20 is a schematic diagram showing stream_id that the disc device uses;<br>
Fig. 21 is a schematic diagram showing the syntax of private_streaml_PES_payload();<br>
Fig. 22 is a schematic diagram showing the relationship of the value of private_stream_id and the attribute of an elementary stream stored in private_payload();<br>
Fig. 23 is a schematic diagram showing the syntax of private_stream2_PES_payload();<br>
Fig. 24 is a schematic diagram showing the syntax of au_information();<br>
Fig. 25 is a schematic diagram showing a specific example of a file "PLAYLIST.DAT";<br>
Fig. 26A and Fig. 26B are schematic diagrams showing specific examples of clip information files "00001.CLP," "00002.CLP," and "00003.CLP";<br>
Fig. 27 is a schematic diagram showing a specific example of EP_map() of a clip information file "00001.CLP";<br>
Fig. 28 is a schematic diagram showing specific examples of PlayListMark()'s of PlayList#0 and<br><br>
PlayList#l;<br>
Fig. 29 is a flow chart describing a pre-reproduction process;<br>
Fig. 30 is a flow chart describing a reproduction process;<br>
Fig. 31 is a flow chart describing a Playltem change process;<br>
Fig. 32 is a flow chart describing a time code display process;<br>
Fig. 33 is a flow chart describing a stream change process;<br>
Fig. 34 is a flow chart describing a process of a buffer control module 215;<br>
Fig. 35 is a flow chart describing the process of the buffer control module 215;<br>
Fig. 36 is a flow chart describing a video stream read process;<br>
Fig. 37 is a flow chart describing an audio stream read process;<br>
Fig. 38 is a flow chart describing a subtitle stream read process;<br>
Fig. 39 is a flow chart describing a re-synchronization process;<br>
Fig. 40 is a flow chart describing a mark process;<br>
Fig. 41 is a flow chart describing an output attribute control process;<br><br>
Fig. 42 is a schematic diagram showing a specific example of a set of pts_change_point and Dynamiclnfo() described in a clip information file "00003.CLP";<br>
Fig. 43 is a flow chart describing a subtitle display control process;<br>
Fig. 44 is a flow chart describing a capture control process and a background/screen saver process;<br>
Fig. 45 is a schematic diagram showing other syntax of private_stream2_PES_payload(); and<br>
Fig. 46 is a schematic diagram showing other syntax of au_information(). Best Modes for Carrying out the Invention<br>
Next, embodiments of the present invention will be described. The relationship between elements of claims and embodiments is as follows. The relationship represents that specific examples that support the invention set forth in claims are described in embodiments. Thus, even if some specific examples are not described in elements of claims, it is not implied that the specific examples do not correspond to the elements of the claims. Conversely, even if specific examples are described as counterparts of elements of claims in this section, it is not implied that these specific examples do not correspond to other than the elements of the claims.<br>
In this section, it is not implied that all<br><br>
aspects of the invention corresponding to specific examples described in the embodiments of the present invention are set forth in the claims.  In other words, the description in this section corresponds to specific examples described in the embodiments of the present invention. Thus, the description in this section does not deny that there are aspects of the present invention that are not set forth in the claims of the present patent application and that divisional patent applications may be made and/or additional aspects of the present invention may be added as amendments.<br>
A data processing apparatus as set forth in claim 1 is a data processing apparatus (for example, a disc device shown in Fig. 1) that processes encoded data,<br>
the encoded data containing:<br>
encoded video data obtained by encoding video data every a predetermined unit that is an access unit,<br>
output data that are output in synchronization with the video data, and<br>
utilization information (for example, private_stream_2_PES_payload() shown in Fig. 23) immediately followed by at least one decode startable point of the encoded video data and utilized for decoding the encoded video data,<br>
the utilization information containing reference information (for example, au ref flag shown<br><br>
in Fig. 24) that represents whether video data corresponding to the encoded video data of at least one access unit that are present from the utilization information to the next utilization information are referenced when other encoded video data are decoded, the data processing apparatus comprising: first determination means (for example, a decode control module 214, shown in Fig. 2A and Fig. 2B, that performs a process at step S272 shown in Fig. 39) for determining whether an output of the video data is later than an output of the output data;<br>
command means (for example, a decode control module 214, shown in Fig. 2A and Fig. 2B, that performs a process at step S273 shown in Fig. 39) for causing a process for the encoded video data of one access unit to be skipped when the determined result of the first determination means represents that the output of the video data is later than the output of the output data;<br>
second determination (for example, a decode control module 214, shown in Fig. 2A and Fig. 2B, that performs a process at step S275 shown in Fig. 39) means for determining whether the video data are referenced when other encoded video data are decoded corresponding to the reference information of the encoded video of the access unit whose process has been caused to be skipped by the command means; and<br>
skip control means (for example, a video<br><br>
decoder control module 216, shown in Fig. 2A and Fig. 2B, that performs a process at step S277 shown in Fig. 39) for skipping the process of the encoded video data of the access unit whose process has been caused to be skipped by the command means when the second determination means has determined that video data corresponding to the encoded video data of the access unit whose process has been caused to be skipped by the command means are not referenced when the other encoded data are decoded.<br>
The data processing apparatus as set forth in claim 2, further comprising:<br>
output control means (for example, a video decoder control module 216, shown in Fig. 2A and Fig. 2B, that performs a process at step S279 shown in Fig. 39) for continuously outputting the video data when the first determination means has determined that the output of the output data is later than the output of the video data.<br>
A data processing method as set forth in claim 3 is a data processing method of processing encoded data,<br>
the encoded data containing:<br>
encoded video data obtained by encoding video data every a predetermined unit that is an access unit,<br>
output data that are output in synchronization with the video data, and<br><br>
utilization information (for example, private_stream_2_PES_payload() shown in Fig. 23) immediately followed by at least one decode startable point of the encoded video data and utilized for decoding the encoded video data,<br>
the utilization information containing reference information (for example, au_ref_flag shown in Fig. 24) that represents whether video data corresponding to the encoded video data of at least one access unit that are present from the utilization information to the next utilization information are referenced when other encoded video data are decoded,<br>
the data processing method comprising the steps of:<br>
determining whether an output of the video data is later than an output of the output data (for example, step S272 shown in Fig. 39);<br>
causing a process for the encoded video data of one access unit to be skipped when the determined result at the first determination step represents that the output of the video data is later than the output of the output data (for example, step S273 shown in Fig. 39);<br>
determining whether the video data are referenced when other encoded video data are decoded corresponding to the reference information of the encoded video of the access unit whose process has been<br><br>
caused to be skipped at the command step (for example, step S275 shown in Fig. 39); and<br>
skipping the process of the encoded video data of the access unit whose process has been caused to be skipped at the command step when it has been determined at the second determination step that video data corresponding to the encoded video data of the access unit whose process has been caused to be skipped at the command step are not referenced when the other encoded video data are decoded (for example, step S277 shown in Fig. 39).<br>
A program as set forth in claim 4 and a program recorded on a program recording medium as set forth in claim 5 is a program that causes a computer to execute a data process of processing encoded data,<br>
the encoded data containing:<br>
encoded video data obtained by encoding video data every a predetermined unit that is an access unit,<br>
output data that are output in synchronization with the video data, and<br>
utilization information (for example, private_stream_2_PES_payload() shown in Fig. 23) immediately followed by at least one decode startable point of the encoded video data and utilized for decoding the encoded video data,<br>
the utilization information containing reference information (for example, au ref flag shown<br><br>
in Fig. 24) that represents whether video data corresponding to the encoded video data of at least one access unit that are present from the utilization information to the next information are referenced when other encoded video data are decoded,<br>
the program comprising the steps of:<br>
determining whether an output of the video data is later than an output of the output data (for example, step S272 shown in Fig. 39);<br>
causing a process for the encoded video data of one access unit to be skipped when the determined result at the first determination step represents that the output of the video data is later than the output of the output data (for example, step S273 shown in Fig. 39);<br>
determining whether the video data are referenced when other encoded video data are decoded corresponding to the reference information of the encoded video of the access unit whose process has been caused to be skipped at the command step (for example, step S275 shown in Fig. 39); and<br>
skipping the process of the encoded video data of the access unit whose process has been caused to be skipped at the command step when it has been determined at the second determination step that video data corresponding to the encoded video data of the access unit whose process has been caused to be skipped<br><br>
at the command step are not referenced when the other encoded video data are decoded (for example, step S277 shown in Fig. 39).<br>
A data recording medium as set forth in claim 6 is a data recording medium on which encoded data have been recorded, the encoded data containing:<br>
encoded video data obtained by encoding video data every a predetermined unit that is an access unit,<br>
output data that are output in synchronization with the video data, and<br>
utilization information (for example, private_stream_2_PES_payload() shown in Fig. 23) immediately followed by at least one decode startable point of the encoded video data and utilized for decoding the encoded video data,<br>
the utilization information containing reference information (for example, au_ref_flag shown in Fig. 24) that represents whether video data corresponding to the encoded video data of at least one access unit that are present from the utilization information to the next utilization information are referenced when other encoded video data are decoded.<br>
Next, with reference to the accompanying drawings, embodiments of the present invention will be described. [Hardware Structure]<br>
Fig. 1 is a block diagram showing an example<br><br>
of the structure of hardware of a disc device according to an embodiment of the present invention.<br>
The disc device shown in Fig. 1 can be<br>
applied to for example a disc player, a game device, a car navigation system, and so forth.<br>
In the disc device shown in Fig. 1, a disc 101 is an optical disc such as a DVD, a magneto-optical disc, a magnetic disc, or the like. Content data such as video data, audio data, and subtitle data and additional data necessary to reproduce those data are recorded on the disc 101.<br>
When necessary, data recorded on the disc 101 (referred to as record data) include a program that can be executed by a computer. According to the embodiment of the present invention, as a recording medium, the disc 101 that is a disc-shaped recording medium is used. Alternatively, the recording medium may be for example a semiconductor memory or a tape-shaped recording medium. Data that are read from the disc 101 at a remote location may be transmitted and input to the disc device shown in Fig. 1.  In other words, data can be read from the disc 101 by another device connected to the disc device. The data that are read by the other device can be received and processed by the disc device.  In addition, the disc device can receive data from a server or the like that stores data similar to those recorded on the disc 101 through a<br><br>
network such as the Internet and process the received data.  In addition, the disc device can also receive data from another device such as a server or the like, record the received data to the disc 101, and then process the data recorded to the disc 101.<br>
The disc 101 can be loaded and unloaded to and from a disc drive 102. The disc drive 102 has a build-in interface (not shown). The disc drive 102 is connected to a drive interface 114 through the built-in interface. The disc drive 102 drives the disc 101, reads data from the disc 101 in accordance with for example a read command, and supplies the data to the drive interface 114.<br>
Connected to a bus 111 are a central processing unit (CPU) 112, a memory 113, a drive interface 114, an input interface 115, a video decoder 116, an audio decoder 117, a video output interface 118, and an audio output interface 119.<br>
The CPU 112 and the memory 113 compose a computer system.  In other words, the CPU 112 executes a software module group that is a program stored in the memory 113 to control the entire disc device and perform various processes that will be described later. The memory 113 also stores the software module group that the CPU 112 executes.  In addition, the memory 113 temporarily stores data necessary to operate the CPU 112. The memory 113 can be composed of only a non-<br><br>
volatile memory or a combination of a volatile memory and a non-volatile memory. When the disc device shown in Fig. 1 has a hard disk to which the software module group is recorded (installed) that the CPU 112 executes, the memory 113 can be composed of only a nonvolatile memory.<br>
The program (software module group) that the CPU 112 executes can be pre-recorded (stored) in the memory 113 as a recording medium that is built in the disc device.<br>
Alternatively/ the program can be temporarily or permanently stored (recorded) to the disc 101 or a removable recording medium such as a flexible disc, a compact disc read-only memory (CD-ROM), a magneto-optical (MO) disc, a magnetic disc, or a memory card. The removable recording medium may be provided as so-called package software.<br>
The program can be pre-stored in the memory 113 or installed from an above-described removable recording medium to the disc device. Alternatively, the program may be wirelessly transferred from a download site to the disc device through a satellite for a digital satellite broadcast or non-wirelessly transferred to the disc device through a local area network (LAN) or a network such as the Internet.  The disc device receives the program through the input interface 115 and installs the program to the built-in<br><br>
memory 113.<br>
The program may be executed by one CPU or distributively executed by a plurality of CPUs.<br>
The drive interface 114 controls the disc drive 102 under the control of the CPU 112. The disc drive 102 supplies data that are read from the disc 101 to the CPU 112, the memory 113, the video decoder 116, and the audio decoder 117 through the bus 111.<br>
The input interface 115 receives signals corresponding to user's operations of keys (buttons) and a remote controller (not shown) and supplies the signals to the CPU 112 through the bus 111. The input interface 115 also functions as a communication interface for a modem (including an asymmetric digital subscriber line (ADSL) modem), a network interface card (NIC), or the like.<br>
The video decoder 116 decodes encoded video data (encoded audio data) that have been read from the disc 101 by the disc drive 102 and supplied to the video decoder 116 through the drive interface 114 and the bus 111 and supplies the decoded video data to the CPU 112 and the video output interface 118 through the bus 111.<br>
The audio decoder 117 decodes encoded audio data that have been read from the disc 101 by the disc drive 102 and supplied to the audio decoder 117 through the drive interface 114 and the bus 111 and supplies<br><br>
the encoded audio data to the CPU 112 and the audio output interface 119 through the bus 111.<br>
The video output interface 118 performs a predetermined process for the video data supplied through the bus 111 and outputs the processed video data from a video output terminal 120. The audio output interface 119 performs a predetermined process for the audio data supplied through the bus 111 and outputs the processed audio data from an audio output terminal 121.<br>
The video output terminal 120 is connected to a video output device such as a cathode ray tube (CRT) or a liquid crystal panel (not shown). Thus/ the video data that are output from the video output terminal 120 are supplied to the video output device and displayed thereby. The audio output terminal 121 is connected to audio output devices such as a speaker and an amplifier (not shown) . Thus/ the audio data that are output from the audio output terminal 121 are supplied to the audio output devices and output thereby.<br>
Video data and audio data can be wirelessly or non-wirelessly supplied from the disc device to the video output device and the audio output devices. [Structure of Software Module Group]<br>
Fig. 2A and Fig. 2B show an example of the structure of the software module group that the CPU 112 shown in Fig. 1 executes.<br><br>
The software module group that the CPU 112 executes is mainly categorized as an operating system (OS) 201 and a video content reproduction program 210 as an application program. [Operating System 201]<br>
When the disc device is turned on, the<br>
operating system 201 gets started (the CPU 112 executes the operating system 201), performs predetermined processes such as initial settings, and calls the video content reproduction program 210, which is an application program.<br>
The operating system 201 provides<br>
infrastructural services such as a file read service to the video content reproduction program 210.  In other words, the operating system 201 provides a service that operates the disc drive 102 through the drive interface 114 against a file read request received from the video content reproduction program 210, reads data from the disc 101, and provides services to the video content reproduction program 210.  In addition, the operating system 201 also interprets the file system.<br>
The operating system 201 has a function of a multitask process. In other words, the operating system 201 can simultaneously (apparently) operate a plurality of software modules on time sharing basis. In other words, although the video content reproduction program 210 is composed of several software modules,<br><br>
they can be operated in parallel. [Video Content Reproduction Program 210]<br>
The video content reproduction program 210 is composed of a script control module 211, a player control module 212, a content data supply module 213, a decode control module 214, a buffer control module 215, a video decoder control module 216, an audio decoder control module 217, a subtitle decoder control module 218, a graphics process module 219, a video output module 220, and an audio output module 221.<br>
The video content reproduction program 210 is software that performs a key role of the reproduction of data from the disc 101. When the disc 101 is loaded (inserted) into the disc drive 102, the video content reproduction program 210 checks whether the disc 101 is a disc on which a content has been recorded in a predetermined format (that will be described later). The video content reproduction program 210 reads a script file (that will be described later) from the disc 101, executes the script, reads a meta data (database information) file necessary to reproduce a content from the disc 101, and controls the reproduction of the content according to the meta data.<br>
Next, the software module that composes the video content reproduction program 210 shown in Fig. 2A and Fig. 2B will be described.  In Fig. 2A and Fig. 2B, in general, solid line arrow marks represent content<br><br>
data, whereas dotted line arrow marks represent control<br>
data.<br>
[Script Control Module 211]<br>
The script control module 211 interprets and executes a script program (script) recorded on the disc 101. A script program can describe operations such as "operate the graphics process module 219 to create an image such as a menu and display it," "change a menu display corresponding to a signal supplied from a user interface (UI) such as a remote controller (for example, to move a cursor on a menu)," and "to control the player control module 212." [Player Control Module 212]<br>
The player control module 212 references meta data (database information) and so forth recorded on the disc 101 to control the reproduction of a content recorded on the disc 101.  In other words, the player control module 212 analyzes PlayListO and ClipO recorded on the disc 101 and controls the content data supply module 213, the decode control module 214, and the buffer control module 215 corresponding to the analyzed results.  In addition, the player control module 212 performs a stream change control that changes a stream to be reproduced corresponding to commands received from the script control module 211 and the input interface 115 as will be described later. In addition, the decode control module 214 obtains a<br><br>
time from the decode control module 214, displays the time, and performs a process for a mark (Mark()) (that will be described later). [Content Data Supply Module 213]<br>
The content data supply module 213 requests the operating system 201 to read content data, meta data, and so forth from the disc 101 under the control of the player control module 212 or according to the amount of data stored in the buffer control module 215.<br>
The meta data and so forth that the operating system 201 has read from the disc 101 in accordance with the request received from the content data supply module 213 are supplied to predetermined modules. On the other hand, the content data that the operating system 201 has read from the disc 101 corresponding to the request received from the content data supply module 213 are supplied to the buffer control module 215. [Decode Control Module 214]<br>
The decode control module 214 controls the operations of the video decoder control module 216, the audio decoder control module 217, and the subtitle decoder control module 218 under the control of the play control module 212. The decode control module 214 has a time count portion 214A that counts a time.  The decode control module 214 manages the synchronization of an output of video data that are output under the<br><br>
control the video decoder control module 216 and an output of data that are synchronized with the video data.  In this case, an output of data to be synchronized with an output of video data is audio data that are output under the control of the audio decoder control module 217. [Buffer Control Module 215]<br>
The buffer control module 215 has a buffer 215A as a part of a storage area of the memory 113 shown in Fig. 1. The content data supply module 213 temporarily stores content data read from the disc 101 to the buffer 215A corresponding to a request received from the operating system 201.<br>
In addition, the buffer control module 215 supplies data stored in the buffer 215A to the video decoder control module 216, the audio decoder control module 217, or the subtitle decoder control module 218 in accordance with a request received from the video decoder control module 216, the audio decoder control module 217, or the subtitle decoder control module 218, respectively.<br>
In other words, the buffer control module 215 has a video read function portion 233, an audio read function portion 234, and a subtitle read function portion 235 that will be described later in Fig. 3. The video read function portion 233 of the buffer control module 215 processes a data request received<br><br>
from the video decoder control module 216 to supply data stored in the buffer 215A to the video decoder control module 216. Likewise, the audio read function portion 234 in the buffer control module 215 processes a request received from the audio decoder control module 217 to supply data stored in the buffer 215A to the audio decoder control module 217. The video read function portion 233 in the buffer control module 215 processes a request received from the subtitle decoder control module 218 to supply data stored in the buffer 215A to the subtitle decoder control module 218. [Video Decoder Control Module 216]<br>
The video decoder control module 216 operates the video read function portion 233 (Fig. 3) of the buffer control module 215 to read encoded video data one video access unit at a time from the buffer 215A of the buffer control module 215 and supply the video data to the video decoder 116 shown in Fig. 1.  In addition, the video decoder control module 216 controls the video decoder 116 to decode data one video access unit at a time.  In addition, the video decoder control module 216 supplies video data decoded by the video decoder 116 to the graphics process module 219.<br>
One video access unit is for example one picture (one frame or one field) of video data. [Audio Decoder Control Module 217]<br>
The audio decoder control module 217 operates<br><br>
an audio read function portion 234 (Fig. 3) of the buffer control module 215 to read encoded audio data one audio access unit at a time from the buffer 2ISA of the buffer control module 215 and supplies the encoded audio data to the audio decoder 117 shown in Fig. 1. The audio decoder control module 217 controls the audio decoder 117 to decode the encoded audio data one audio access unit at a time.  In addition, the audio decoder control module 217 supplies audio data decoded by the audio decoder 117 to the audio output module 221.<br>
One audio access unit is a predetermined amount of audio data (for example, an amount of data that are output in synchronization with one picture). According to this embodiment, it is assumed that one audio access unit is a predetermined fixed length. [Subtitle Decoder Control Module 218]<br>
The subtitle decoder control module 218 operates the subtitle read function portion 235 (Fig. 3) of the buffer control module 215 to read encoded subtitle data one subtitle access unit at a time from the buffer 215A of the buffer control module 215.  In addition, the subtitle decoder control module 218 has subtitle decode software (not shown). The subtitle decode software decodes data read from the buffer 215A. The subtitle decoder control module 218 supplies the decoded subtitle data (image data of a subtitle) to the graphics process module 219.<br><br>
One subtitle access unit is a predetermined amount of subtitle data (for example, an amount of data that are output in synchronization with one picture). According to this embodiment, it is assumed that the size of one subtitle access unit is described at the beginning thereof. [Graphics Process Module 219]<br>
The graphics process module 219 enlarges or reduces subtitle data received from the subtitle decoder control module 218 under the control (corresponding to a command) of the player control module 212 and adds (overlays) the enlarged or reduced subtitle data to video data received from the video decoder control module 216. The graphics process module 219 enlarges or reduces the size (image frame) of the video data that have been added to the subtitle data so that the frame size of the added (overlaid) video data matches the screen of the video output device connected to the video output terminal 120 shown in Fig. 1. The added (overlaid) video data are output to the video output module 220.<br>
In addition, the graphics process module 219 generates a menu, a message, and so forth corresponding to commands (under the control) of the script control module 211 and the player control module 212 and overlays the menu, message, and so forth with the output video data.<br><br>
In addition, the graphics process module 219 converts the aspect ratio of video data that are output to the video output module 220 corresponding to the aspect ratio of the video output device connected to the video output terminal 120 shown in Fig. 1 and information that represents the aspect ratio of the video data recorded on the disc 101.<br>
In other words, when the aspect ratio of the video output device is 16 : 9, if information that represents the aspect ratio of video data is 4 : 3, the graphics process module 219 performs a squeeze (reduction) process for video data that are output to the video output module 220 in the lateral (horizontal) direction, causes the left and right ends of the video data to be black, and outputs the resultant video data. When the aspect ratio of the video output device is 4 : 3, if information that represents the aspect ratio of video data is 16 : 9, the graphics process module 219 performs a squeeze (reduction) process for video data that are output to the video output module 220 in the longitudinal (vertical) direction, causes the upper and lower ends of the video data to be black, and outputs the resultant video data.<br>
When the aspect ratio of the video output device and the aspect ratio that the information represents for the video data are the same, for example 4 : 3 or 16 : 9, the graphics process module 219<br><br>
outputs non-squeezed video data to the video output<br>
module 220.<br>
In addition, the graphics process module 219<br>
captures video data that are being processed<br>
corresponding to a request received from for example<br>
the player control module 212. Moreover, the graphics<br>
process module 219 stores the captured video data or<br>
supplies the video data to the player control module<br>
212.<br>
[Video Output Module 220]<br>
The video output module 220 exclusively occupies a part of the memory 113 shown in Fig. 1 as a<br>
first-in first-out (FIFO) 220A (buffer) and temporarily stores video data received from the graphics process module 219. In addition, the video output module 220 frequently reads video data from the FIFO 220A and outputs the video data to the video output terminal 120<br>
(Fig. 1) .<br>
[Audio Output Module 221]<br>
The audio output module 221 exclusively occupies a part of the memory 113 shown in Fig. 1 as a FIFO 221A (buffer) and temporarily stores audio data received from the audio decoder control module 217<br>
(audio decoder 117).  In addition, the audio output module 221 frequently reads audio data from the FIFO 221A and outputs the audio data to the audio output terminal 121 (Fig. 1).<br><br>
In addition, when audio data received from the audio decoder control module 217 are dual (bilingual) mode audio data that have left and right channels of "main audio" data and "sub audio" data, the audio output module 221 outputs the audio data received from the audio decoder control module 217 to the audio output terminal 121 corresponding to a pre-designated audio output mode.<br>
In other words, if the "main sound" has been designated as an audio output mode, the audio output module 221 copies the left channel of audio data received from the audio decoder control module 217 as the right channel of audio data and outputs the left and right channel of audio data ("main audio" data) to the audio output terminal 121. If "sub audio" has been designated as an audio output mode, the audio output module 221 copies the right channel of audio data received from the audio decoder control module 217 as the left channel and outputs the left and right channel ("sub audio" data) to the audio output terminal 121. If both "main and sub audios" have been designated as an audio output mode, the audio output module 221 directly outputs audio data received from the audio decoder control module 217 to the audio output terminal 121.<br>
If audio data received from the audio decoder control module 217 are stereo mode audio data, the<br><br>
audio output module 221 directly outputs the audio data received from the audio decoder control module 217 to the audio output terminal 121 regardless of what audio output mode has been designated.<br>
The user can interactively designate an audio output mode on a screen for a menu generated by the video content reproduction program 210 with the remote controller. [Structure of Buffer Control Module 215]<br>
Fig. 3 shows an example of the structure of the buffer control module 215 shown in Fig. 2A and Fig. 2B.<br>
The buffer control module 215 exclusively uses a part of the memory 113 shown in Fig. 1 as the buffer 215A and temporarily stores data that are read from the disc 101 to the buffer 215A.  In addition, the buffer control module 215 reads data from the buffer 2ISA and supplies the data to the video decoder control module 216, the audio decoder control module 217, and the subtitle decoder control module 218 shown in Fig. 2A and Fig. 2B.<br>
Besides the buffer 215A, the buffer control module 215 has a data start pointer storage portion 231 and a data write pointer storage portion 232 that are part of the memory 113. In addition, the buffer control module 215 has a video read function portion 233, an audio read function portion 234, and a subtitle<br><br>
read function portion 235 as internal modules.<br>
The buffer 215A is for example a ring buffer that successively stores data that are read from the disc 101. After the buffer 215A reads data for the storage amount thereof, the buffer 215A stores data in so-called endless loop so that the buffer 215A overwrites the newest data on the oldest data.<br>
The data start pointer storage portion 231 stores a data start pointer that represents the position (address) of the oldest data that are not read from the buffer 215A in the data stored in the buffer 215A.<br>
The data write pointer storage portion 232 stores a pointer that represents the position of the newest data that are read from the disc 101 in the buffer 215A.<br>
Whenever data that are read from the disc 101 are stored to the buffer 215A, the position that the data write pointer represents is updated in the clockwise direction shown in Fig. 3. Whenever data are read from the buffer 2ISA/ the position that the data start pointer represents is updated in the clockwise direction shown in Fig. 3. Thus, valid data stored in the buffer 215A are from the position that the data start pointer represents to the position that the data write pointer represents in the clockwise direction shown in Fig. 3.<br><br>
The video read function portion 233 reads a video stream (an elementary stream of video data) from the buffer 215A corresponding to a request received from the video decoder control module 216 shown in Fig. 2A and Fig. 2B and supplies the video stream to the video decoder control module 216. The audio read function portion 234 reads an audio stream (an elementary stream of audio data) from the buffer 215A corresponding to a request received from the audio decoder control module 217 and supplies the audio stream to the audio decoder control module 217. Likewise, the subtitle read function portion 235 reads a subtitle stream (an elementary stream of subtitle data) from the buffer 215A corresponding to a request received from the subtitle decoder control module 218 and supplies the subtitle stream to the subtitle decoder control module 218.<br>
In other words, a program stream<br>
corresponding to for example the Moving Picture Experts Group (MPEG) 2 standard has been recorded on the disc 101, the program stream being referred to as MPEG2-system program stream.  In the program stream, at least one elementary stream of a video stream, an audio stream, and a subtitle stream has been multiplexed on time division basis. The video read function portion 233 has a demultiplexing function for the program stream. The video read function portion 233<br><br>
demultiplexes a video stream from a program stream stored in the buffer 215A and reads the video stream.<br>
Likewise, the audio read function portion 234 has a demultiplexing function for a program stream. The audio read function portion 234 demultiplexes an audio stream from a program stream stored in the buffer 215A and reads the audio stream. Likewise, the subtitle read function portion 235 has a demultiplexing function for a program stream. The subtitle read function portion 235 demultiplexes a subtitle stream from a program stream stored in the buffer 215A and reads the subtitle stream.<br>
The video read function portion 233 has a video read pointer storage portion 241, a stream_id register 242, and an au_information() register 243 that are part of the memory 113 shown in Fig. 1.<br>
The video read pointer storage portion 241 stores a video read pointer that represents the position (address) of a video stream in the buffer 215A. The video read function portion 233 reads data as a video stream from the position of the video read pointer in the buffer 215A. The stream_id register 242 stores stream_id that is used to analyze a program stream stored in the buffer 215A and to identify a video stream that is read from the program stream. The au_information() register 243 stores au_information() that is data necessary to read (that is used to read) a<br><br>
video stream from the buffer 215A.<br>
The audio read function portion 234 has an audio read pointer storage portion 251, a stream_id register 252, and a private_stream_id register 253 that are part of the memory 113 shown in Fig. 1.<br>
The audio read pointer storage portion 251 stores an audio read pointer that represents the position (address) of an audio stream stored in the buffer 215A. The audio read function portion 234 reads data as an audio stream from the position of the audio read pointer in the buffer 215A. The stream_id register 252 and the private_stream_id register 253 store stream_id and private_stream_id (that will be described later), respectively, used to analyze a program stream stored in the buffer 215A and identify an audio stream that is read from the program stream.<br>
The subtitle read function portion 235 has a subtitle read function flag storage portion 261, a subtitle read pointer storage portion 262, a stream_id register 263, and a private_stream_id register 264 that are part of the memory 113 shown in Fig. 1.<br>
The subtitle read function flag storage portion 261 stores a subtitle read function flag. When the subtitle read function flag stored in the subtitle read function flag storage portion 261 is for example "0," the subtitle read function portion 235 does not operate. When the subtitle read function flag stored<br><br>
in the subtitle read function flag storage portion 261 is for example "I," the subtitle read function portion 235 operates.<br>
The subtitle read pointer storage portion 262 stores a subtitle read pointer that represents the position (address) of a subtitle stream stored in the buffer 215A. The subtitle read function portion 235 reads data as a subtitle stream from the position of the subtitle read pointer in the buffer 215A. The stream_id register 263 and the private_stream_id register 264 stores stream_id and private_stream_id (that will be described later), respectively, used to analyze a program stream stored in the buffer 215A and identify a subtitle stream that is read from the program stream.<br>
[Description of Data Format of Data Recorded on Disc 101]<br>
Next, the data format of data recorded on the disc 101 will be described.<br>
Fig. 4 schematically shows the structure of directories of the disc 101.<br>
A file system used for the disc 101 is for example one of those defined in the International Organization for Standardization (ISO)-9660 and the Universal Disk Format (UDF)<br>
(http://www.osta.org/specs/).  Files of data recorded on the disc 101 are hierarchically managed in a<br><br>
directory structure. A file system that can be used for the disc 101 is not limited to these file systems.<br>
In Fig. 4, there is a "VIDEO" directory under a root directory that represents the base of the file system. There are two directories that are a "CLIP" directory and a "STREAM" directory under the "VIDEO" directory.<br>
Besides the two directories, which are the "CLIP" directory and the "STREAM" directory, there are two data files that are a "SCRIPT.DAT" file and a "PLAYLIST.DAT" file under the "VIDEO" directory.<br>
The "SCRIPT.DAT" file is a script file that describes a script program.  In other words, the "SCRIPT.DAT" file describes a script program that allows data on the disc 101 to be interactively reproduced. The script program stored in the "SCRIPT.DAT" file is interpreted and executed by the script control module 211 shown in Fig. 2A and Fig. 2B.<br>
The "PLAYLIST.DAT" file stores at least one play list (PlayList() that will be described later with reference to Fig. 5). A play list describes the reproduction procedure of a content such as video data recorded on the disc 101.<br>
There is at least one clip information file under the "CLIP" directory. There is at least one clip stream file under the "STREAM" directory.  In other words, there are three clip information files<br><br>
"00001.CLP," "00002.CLP," and "00003.CLP" under the "CLIP" directory. There are three clip stream files "00001.PS," "00002.PS," and "00003.PS" under the "STREAM" directory.<br>
A clip stream file stores a program stream of which at least one stream of video data, audio data, and subtitle data have been compressed and encoded is multiplexed on time division basis.<br>
A clip information file stores a (file) meta data about a clip stream for example characteristics thereof.<br>
In other words, a clip stream file and a clip information file are correlated in the relationship of 1 to 1.  In Fig. 4, a clip stream file is named corresponding to a naming rule of five-digit number + period + "PS," whereas a clip information file is named corresponding to a naming rule of the same five-digit number as the corresponding clip stream + period + "CLP."<br>
Thus, a clip stream file and a clip<br>
information file can be identified by the extension of the file name (the right side of period).  In addition, it can be determined whether a clip stream file and a clip information file are correlated with their file names other than their extensions (the left side portion of period).<br>
Next, files recorded on the disc 101 will be<br><br>
described in detail. [PLAYLIST.DAT]<br>
Fig. 5 shows the internal structure (syntax) of the "PLAYLIST.DAT" file under the "VIDEO" directory shown in Fig. 4.<br>
In Fig. 5, the "PLAYLIST.DAT" file has a "Syntax" field that describes the data structure of the "PLAYLIST.DAT" file; a "No. of bits" field that describes the bit length of each data entry in the "Syntax" field; and a "Mnemonic" field in which "bslbf" (bit string left bit first) and "uimsbf" (unsigned integer most significant bit first)" represent that a data entry in the "Syntax" field is shifted from the left bit and that a data entry in the "Syntax" field is an unsigned integer and shifted from the most significant bit. These conditions apply to other lists similar to Fig. 5.<br>
The "PLAYLIST.DAT" file starts with<br>
name_length (8 bits) and name_string (255 bytes) that describe information such as the name (file name).<br>
In other words, name_length represents the size of name_string immediately preceded thereby in bytes. name_string represents the name (file name) of the "PLAYLIST.DAT" file.<br>
Bytes for name_length from the beginning of name_string are used as a valid name. When the value of name length is 10, 10 bytes from the beginning of<br><br>
name_string are interpreted as a valid name.<br>
narae_string is followed by<br>
number_of_PlayLists (16 bits). number_of_PlayLists represents the number of PlayListO's preceded by name_string. number_of_PlayLists is followed by PlayListO's represented by number_of_PlayLists.<br>
PlayListO is a play list that describes the reproduction procedure of a clip stream file recorded on the disc 101. PlayListO has the following internal structure.<br>
PlayListO starts with PlayList_data_length (32 bits). PlayList_data_length represents the size of PlayListO .<br>
PlayList_data_length is followed by reserved_for_word_alignment (15 bits) and capture_enable_flag_PlayList (1 bit) in succession. reserved_for_word_alignment of 15 bits is followed by capture_enable_flag_PlayList of 1 bit for a word alignment at the position of<br>
capture_enable_flag_PlayList to place it at the position of 16 bits. capture_enable_flag_PlayList is a 1-bit flag that represents whether video data (video data that belong to PlayListO) of a video stream reproduced corresponding to PlayListO is permitted to be secondarily used in the disc device that reproduces data from the disc 101. When the value of capture enable flag PlayList is for example 1 (0 or 1),<br><br>
it represents that video data that belong to PlayListO are permitted to be secondarily used. When the value of capture_enable_flag_PlayList is for example 0 (0 or 1), it represents that video data that belong to PlayListO are not permitted to be secondarily used (namely, prohibited from being secondarily used).<br>
In Fig. 5, capture_enable_flag_PlayList is composed of one bit. Alternatively, capture_enable_flag_PlayList may be composed of a plurality of bits.  In this case, video data that belong to PlayListO may be gradually permitted to be secondarily used.  In other words,<br>
capture_enable_flag_PlayList may be composed of two bits. When the value of capture_enable_flag_PlayList is OOB (where B represents that the preceding number is a binary number), video data are prohibited from being secondarily used. When the value of<br>
capture_enable_flag_PlayList is 01B, video data that are reduced to a size of 64 x 64 pixels or smaller are permitted to be secondarily used. When the value of capture_enable_flag_PlayList is 10B, video data are permitted to be secondarily used without any size reduction.<br>
A secondary use of video data may be restricted with respect to applications rather than sizes.  In other words, when the value of capture enable flag PlayList is 01B, only the video<br><br>
content reproduction program 210 (Fig. 2A and Fig. 2B) may be permitted to secondarily use the video data. When the value of capture_enable_flag_PlayList is 10B, any application including the video content reproduction program 210 in the disc device shown in Fig. 1 may be permitted to secondarily use the video data.  In this example, an application other than the video content reproduction program 210 in the disc device shown in Fig. 1 that displays a wall paper (background) or a screen saver.<br>
When capture_enable_flag_PlayList is composed of 2 bits, reserved_for_word_alignment followed thereby is composed of 14 bits for a word alignment.<br>
Alternatively, with<br>
capture_enable_flag_PlayList, video data may be permitted to be secondarily used outside the disc device.  In the case that with<br>
capture_enable_flag_PlayList, video data are permitted to be secondarily used outside the disc device, the video data are recorded to for example a recording medium that can be loaded into the disc device or that can be connected to the disc device, or transmitted (distributed) to another device through a network such as the Internet.  In this case, information that represents the number of times video data can be recorded to the recording medium or the number of times video data can be transmitted (distributed) can be<br><br>
added to the video data.<br>
capture_enable_flag_PlayList is followed by PlayList_name_length (8 bits) and PlayList_name_string (255 bytes) in succession. PlayList_name_length represents the size of PlayList_name_string in bytes. PlayList_name_string represents the name of PlayListO.<br>
PlayList_name_string is followed by namber_of_Play!tems (16 bits). number_of_PlayItems represents that number of Playltem()'s.<br>
number_of_PlayItems is followed by Playltem()'s represented by number_of_PlayItems.<br>
One PlayListO can describe the reproduction procedure of a content in the unit of Playltem().<br>
Identification (ID) codes that are unique in PlayListO are added to Playltem()'s represented by number_of_PlayItems. In other words, the first Playltem{) of PlayListO is identified by number 0. The other PlayltemO's are successively identified by numbers 1, 2, ... , and so forth.<br>
PlayltemO's represented by<br>
number_of_PlayIterns are followed by one PlayListMark(). PlayListMark() is a set of MarkO's as marks on the time axis of the reproduction corresponding to PlayListO. PlayListMark() will be described later in detail with reference to Fig. 7. [Description of PlayltemO]<br>
Fig. 6 shows the internal structure of<br><br>
Playltem() contained in PlayListO shown in Fig. 5.<br>
PlayltemO starts with length (16 bits) . length represents the size of PlayltemO, including the size of length.<br>
length is followed by<br>
Clip_Information_file_name_length (16 bits) and Clip_Information_file_name (variable length) in succession. Clip__Inf ormation_f ile_name_length represents the size of Clip_Information_file_name in bytes. Clip_Information_file_name represents the file name of a clip information file (a file having an extension CLP shown in Fig. 4) corresponding to a clip stream file (a file having an extension PS shown in Fig. 4) reproduced by PlayltemO. Corresponding to the foregoing naming rules for clip stream files and clip information files, the file name of a clip information file reproduced by PlayltemO is recognized with Clip_Information_file_name and the clip stream file can be identified.<br>
Clip_Information_file_name is followed by IN_time (32 bits) and OUT_time (32 bits) in succession.<br>
IN_time and OUT_time are time information that represent the reproduction start position and the reproduction end position of a clip stream file identified by Clip_Information_file_name.<br>
IN_time can designate a middle position (including the beginning) of a clip stream file as a<br><br>
reproduction start position. OUT_time can designate a middle position (including the end) of a clip stream file as a reproduction end position.<br>
PlayltemO reproduces a content from IN_time to OUT_time of a clip stream file identified by Clip_Information_file_name. A content reproduced by PlayltemO is sometimes referred to as a clip. [Description of PlayListMark()]<br>
Fig. 7 shows the internal structure of PlayListMark() contained in PlayListO shown in Fig. 5.<br>
As described above, PlayListMark() is a set of Mark()'s that are marks on the time axis of the reproduction corresponding to PlayListO shown in Fig. 5. The number of Mark 0's is 0 or larger. One Mark 0 has at least time information that represents one time (position) on the time axis of the reproduction performed corresponding to PlayListO, type information that represents the type of Mark(), and argument information of an argument of an event when type information represents the type of an event that takes place.<br>
In other words, PlayListMark() starts with length (32 bits).  length represents the size of PlayListMarkO, including the size of length.<br>
length is followed by number_of_PlayList_marks (16 bits). number_of_PlayList_marks represents the number of<br><br>
MarkO's that are preceded by number_of_PlayList_marks. number_of_PlayList_marks is followed by Mark()'s represented by number_of_PlayList_marks.<br>
Mark() starts with mark_type (8 bits). mark_type is the foregoing type information and represents the type of Mark() to which mark_type belongs.<br>
According to this embodiment, Mark() has three types of for example chapter, index, and event.<br>
When the type of Mark() is chapter (sometimes referred to as a chapter mark), it is a mark of the start position of a chapter that is a searching unit as a division of PlayList(). When the type of Mark () is index (sometimes referred to as an index mark), it is a mark of the start position of an index that is a subdivide unit of a chapter. When the type of Mark() is event (sometimes referred to as an event mark), Mark() is a mark of a position at which an event takes place while a content is being reproduced corresponding to PlayListO. The script control module 211 is informed that an event corresponding to an event mark has taken place.<br>
Fig. 8 shows the relationship between the value of mark_type and the type of Mark().  In Fig. 8, mark_type of a chapter mark is 1; mark_type of an index mark is 2; and mark_type of an event mark is 3.  In Fig. 8, other values represented by 8 bits of<br><br>
mark_type, namely 0 and 4 to 255, are reserved for future extension.<br>
In Fig. 7, mark_type is followed by mark_name_length (8 bits). Mark() ends with mark_name_string (24 bytes). mark_name_length and mark_name_string are used to describe the name of Mark(). mark_name_length represents the valid size of mark_name_string. mark_name_string represents the name of Mark(). Thus, bytes for mark_name_length from the beginning of mark_name_string represent a valid name of Mark() .<br>
mark_name_length is followed by four elements ref_to_Play!tem_id (16 bits), mark_time_stamp (32 bits), entry_ES_stream_id (8 bits), and entry_ES_private_stream_id (8 bits) that correlate Mark() defined in PlayListO with a clip stream file.<br>
ref_to_Play!tem_id describes an ID as a sequential number assigned to PlayltemO to which Mark() belongs. ref_to_Play!tem_id identifies PlayltemO (Fig. 6) to which Mark() belongs. Thus, as was described in Fig. 6, a clip information file and a clip stream file are identified.<br>
mark_time_stamp represents the position (time) that Mark() represents in a clip stream file identified by ref_to_Play!tem_id.<br>
Fig. 9 shows the relationship of PlayListO, PlayltemO, clips, and program streams stored in a clip<br><br>
stream file.<br>
In Fig. 9, PlayList() is composed of three PlayltemO's that are sequentially numbered as ID#0, ID#1, and ID#2.  In the following description, PlayltemO numbered as ID#i is denoted by Playltem#i.<br>
In Fig. 9, clips as contents reproduced by Playltem#0, Playltem#l, and Playltem#2 are denoted by clip A, clip B, and clip C, respectively.<br>
An entity of a clip is from IN_time to OUT__time of a program stream stored in a clip stream file identified by Clip_Information_file_name of PlayltemO shown in Fig. 6 (also identified by a clip information file).  In Fig. 9, program streams as entities of clip A, clip B, and clip C are represented as program stream A, program stream B, and program stream C, respectively.<br>
In Fig. 9, in Mark() as a mark of position (time) tO on the time axis of the reproduction corresponding to PlayListO, ref_to_Play!tem_id and mark_time_stamp are described as follows.<br>
In Fig. 9, since time tO is a time at which Playltemttl is reproduced, ref_to_Play!tem_id describes 1 as the ID of Playltem#l. Since at time tO program stream B as the entity of clip B is reproduced, mark_time_stamp describes a time of a clip stream file that stores program stream B corresponding to time tO.<br>
In Fig. 7, when Mark() is correlated with a<br><br>
particular elementary stream, entry_ES_stream_id and entry_ES_private_stream_id are used to identify the elementary stream. In other words, entry_ES_stream_id describes stream_id of the elementary stream that is correlated with Mark() (PES_packet() that contains the elementary stream, PES_packet() will be described later with referenced to Fig. 16A and Fig. 16B to Fig. 18A and Fig. 18B). On the other hand,<br>
entry_ES_private_stream_id describes private_stream_id of the elementary stream correlated with Mark() (private_header() of private_streaml_PES_payload() that contains the elementary stream, private_header() will be described later with reference to Fig. 21).<br>
When video stream#l of a clip of which video stream#l and video stream#2 have been multiplexed is reproduced and when a chapter time needs to be changed while video stream#2 is being reproduced, stream_id and private_stream_id of video stream#l are described in entry_ES_stream_id and entry_ES_private_stream_id of Mark() at a chapter mark time while video stream#2 is being reproduced.<br>
entry_ES_stream_id and<br>
entry_ES_private_stream_id of Mark() that is not correlated with a particular elementary stream are for example 0.<br>
entry_ES_private_stream_id is followed by mark data (32 bits). When Mark() is an event mark,<br><br>
mark_data is argument information as an argument of an event that takes place with the event mark. When Mark() is a chapter mark or an index mark, mark_data can be used as a chapter number or an index number that the chapter mark or the index mark represents. [Description of ClipO]<br>
Next, the internal structure of a clip<br>
information file having an extension of CLP and that is stored in the "CLIP" directory shown in Fig. 4 will be described.<br>
In Fig. 4, there are three clip information files "00001.CLP," "00002.CLP," and "00003.CLP" under the "CLIP" directory. These clip information files contain meta data that represent characteristics of clip stream files "00001.PS," "00002.PS," and "00003.PS" stored in the "STREAM" directory.<br>
Fig. 10 shows the internal structure of the clip information file ClipO.<br>
The clip information file ClipO starts with presentation_start_time and presentation_end_time (32 bits each).  presentation_start_time and presentation_end_time represent the start time and end time of (a program stream stored in) a clip stream file corresponding to the clip information file ClipO. The time of the clip stream file is described as a multiple of 90 kHz used as the time of the MPEG2-System.<br>
presentation end time is followed by<br><br>
reserved_for_word_alignment (7 bits) and capture_enable_flag_Clip (1 bit).<br>
reserved_for_word_alignment of 7 bits is used for a word alignment. capture_enable_flag_Clip is a flag that represents whether video data are permitted to be secondarily used like capture_enable_flag_PlayList shown in Fig. 5.<br>
However, capture_enable_flag_PlayList shown in Fig. 5 represents whether video data (that belong to PlayListO) corresponding to a video stream reproduced corresponding to PlayListO is permitted to be secondarily used.  In contrast,<br>
capture_enable_flag_Clip shown in Fig. 10 represents whether video data corresponding to a video stream (an elementary stream of video data) stored in a clip stream file corresponding to the clip information file ClipO is permitted to be secondarily used. Thus, capture_enable_flag_PlayList shown in Fig. 5 is different from capture_enable_flag_Clip shown in Fig. 10 in the unit (range) of video data that are permitted to be secondarily used.<br>
Like capture_enable_flag_PlayList described in Fig. 5, capture_enable_flag_Clip described in Fig. 10 can be composed of a plurality of bits, not one bit.<br>
capture_enable_flag_Clip is followed by number_of_streams (8 bits). number_of_strearns describes the number of Streamlnfo()'s. Thus,<br><br>
number_of_streams is followed by Streamlnfo()'s represented by number_of_strearns.<br>
StreamlnfoO starts with length (16 bits), length represents the size of StreamlnfoO, including the size of length,  length is followed by stream_id (8 bits) and private_stream_id (8 bits).  stream_id and private_stream_id identify an elementary stream that is correlated with StreamlnfoO.<br>
Fig. 11 shows the relationship of stream_id, private_stream_id, and elementary streams identified thereby.<br>
stream_id is the same as that defined in the MPEG2-System standard. The MPEG2-System standard defines the value of stream_id for each attribute (type) of an elementary stream (data). Thus, an attribute of an elementary stream defined in the MPEG2-System standard can be identified by only stream_id.<br>
This embodiment can deal with attributes of elementary streams that are not defined in the MPEG2-System standard. private_stream_id is information that identifies an attribute of an elementary stream that is not defined in the MPEG2-System standard.<br>
Fig. 11 shows the relationship of stream_id's and private_stream_id's of elementary streams having four attributes that are a video elementary stream encoded corresponding to the encoding (decoding) system defined in the MPEG, an audio elementary stream<br><br>
encoded corresponding to the adaptive transform acoustic coding (ATARC) system (hereinafter sometimes referred to as an ATRAC audio stream), an audio elementary stream encoded corresponding to the linear pulse code modulation (LPCM) system (hereinafter sometimes referred to as an LPCM audio stream), and a subtitle elementary stream (hereinafter sometimes referred to as a subtitle stream).<br>
The MPEG2-System standard defines that a video elementary stream encoded corresponding to the encoding system defined in the MPEG is multiplexed with a value in the range from OxEO to OxEF (where Ox represents that the character string preceded thereby is represented in hexadecimal notation). Thus, 16 video elementary streams encoded corresponding to the encoding system defined in the MPEG and identified by stream_id in the range from OxEO to OxEF can be multiplexed with a program stream.<br>
Since video elementary streams encoded corresponding to the encoding system defined in the MPEG can be identified by stream_id in the range from OxEO to OxEF, private_stream_id is not required (can be ignored).<br>
On the other hand, in the MPEG2-System, stream_id is not defined for an ATRAC audio stream, an LPCM audio stream, and a subtitle stream.<br>
Thus, according to this embodiment, for<br><br>
elementary streams whose stream_id is not defined in the MPEG2-System, OxBD that is a value representing an attribute private_stream_l in the MPEG2-System is used. In addition, as shown in Fig. 11, these elementary streams are identified by private_stream_id.<br>
In other words, an ATRAC audio stream is identified by private_stream_id in the range from 0x00 to OxOF. Thus, 16 ATRAC audio streams can be multiplexed with a program stream. An LPCM audio stream is identified by private_stream_id in the range from 0x10 to OxlF. Thus, 16 LPCM audio streams can be multiplexed with a program stream. A subtitle stream is identified by private_stream_id in the range from 0x80 to Ox9F. Thus, 32 subtitle streams can be multiplexed with a program stream.<br>
stream_id and private_stream_id will be described later in detail.<br>
In Fig. 10, private_stream_id is followed by StaticInfoO and reserved_for_word_alignment (8 bits) in succession. StaticInfoO describes information that does vary while an elementary stream identified by stream_id and private_stream_id (described in Streamlnfo () including StaticInfoO) is being reproduced. Staticlnfo() will be described later with reference to Fig. 12.<br>
reserved_for_word_alignment is used for a word alignment.<br><br>
reserved_for_word_alignment is followed by number_of_DynamicInfo (8 bits). number_of_DynamicInfo represents the number of sets of pts_change_point's (32 bits each) and Dynamiclnfo()'s, which are preceded by number_of_Dynamic!nfo.<br>
Thus, number_of_Dynamic!nfo is followed by sets of pts_change_point's and Dynamiclnfo()'s represented by number__of_DynamicInfo.<br>
pts_change_point represents a time at which information of Dynamiclnfo() paired with pts_change_point becomes valid. pts_change_point that represents the start time of an elementary stream is equal to presentation_start__time described at the beginning of the clip information file ClipO corresponding to a clip stream file that stores the elementary stream.<br>
Dynamiclnfo() describes so-called dynamic information that changes while an elementary stream identified by stream_id and private_stream_id is being reproduced. Information described in Dynamiclnfo() becomes valid at a reproduction time represented by pts_change_point paired with Dynamiclnfo(). Dynamiclnfo() will be described later with reference to Fig. 13.<br>
Sets of pts__change_point' s and<br>
Dynamiclnfo()'s represented by number_of_DynamicInfo are followed by EP map(). EP map() will be described<br><br>
later with reference to Fig. 14. [Description of Staticlnfo()]<br>
Next, with reference to Fig. 12, Staticlnfo() shown in Fig. 10 will be described in detail.<br>
Fig. 12 shows the syntax of Staticlnfo().<br>
The content of Staticlnfo() varies depending on the attribute (type) of the corresponding elementary stream.  The attribute of an elementary stream corresponding to Staticlnfo() is determined by stream_id and private_stream_id contained in Streamlnfo() , shown in Fig. 10, including Staticlnfo().<br>
When an elementary stream corresponding to Staticlnfo() is a video stream (stream == VIDEO), StaticInfoO is composed of picture_size (4 bits), frame_rate (4 bits), cc_flag (1 bit), and reserved_for_word_alignment for a word alignment.<br>
picture_size represents the size of (an image displayed with) video data corresponding to a video stream.  frame_rate represents the frame frequency of video data corresponding to a video stream. cc_flag represents whether a video stream contains closed caption data. When a video stream contains closed caption data, cc_flag is 1. When a video stream does not contain closed caption data, cc_flag is 0.<br>
When an elementary stream corresponding to Staticlnfo() is an audio stream (stream == AUDIO), Staticlnfo() is composed of audio_language_code (16<br><br>
bits), channel_configuration (8 bits), lfe_existence (1 bit), sampling_frequency (4 bits), and reserved_for_word_alignment for a word alignment.<br>
audio_language_code describes a code that represents the language of audio data contained in an audio stream. channel_configuration represents an attribute such as monaural (mono), stereo, multichannels, and so forth of audio data contained in an audio stream. lfe_existence represents whether an audio stream contains a low frequency effect channel. When an audio stream contains a low frequency effect channel, lfe_existence is 1. When an audio stream does not contain a low frequency effect channel, lfe_existence is 0. sampling_frequency is information that represents a sampling frequency of audio data contained in an audio stream.<br>
When an elementary stream corresponding to Staticlnfo() is a subtitle stream (stream == SUBTITLE), Staticlnfo() is composed of subtitle_language_code (16 bits), configurable_flag (1 bit), and reserved_for_word_alignment for a word alignment.<br>
subtitle_language_code describes a code that represents the language of subtitle data contained in a subtitle stream. configurable_flag is information that represents whether a subtitle data display mode is permitted to be changed from a default display mode. When a display mode is permitted to be changed,<br><br>
configurable_flag is 1. When a display mode is not permitted to be changed, configurable_flag is 0.  The display mode of subtitle data includes display size of subtitle data, display position, display color, display pattern (for example, blinking), display direction (vertical or horizontal), and so forth. [Description of Dynamiclnfo()]<br>
Next, with reference to Fig. 13,<br>
Dynamiclnfo() shown in Fig. 10 will be described in detail.<br>
Fig. 13 shows the syntax of Dynamiclnfo().<br>
Dynamiclnfo() starts with<br>
reserved_for_word_alignment (8 bits) for a word alignment. Elements preceded by<br>
reserved_for_word_alignment depend on an attribute of an elementary stream corresponding to Dynamiclnfo(). An attribute of an elementary stream corresponding to Dynamiclnfo() is determined by stream_ID and private_stream_id contained in Streamlnfo(), shown in Fig. 12, that includes Dynamiclnfo().<br>
As described in Fig. 10, Dynamiclnfo() describes dynamic information that varies while an elementary stream is being reproduced. The dynamic information is not specific. However, in the embodiment shown in Fig. 13, data of an elementary stream corresponding to Dynamiclnfo(), namely an output attribute of data that is an output of a process for an<br><br>
elementary stream (an output attribute of data obtained from an elementary stream) is described in Dynamiclnfo().<br>
Specifically, when an elementary stream corresponding to Dynamiclnfo() is a video stream (stream == VIDEO), Dynamiclnfo() is composed of display_aspect_ratio (4 bits) and reserved_for_word_alignment for a word alignment. display_aspect_ratio describes an output attribute (display mode) of video data of a video stream, for example an aspect ratio of video data. In other words, display_aspect_ratio describes information that represents either 16 : 9 or 4 : 3 as an aspect ratio. Dynamiclnfo() of a video stream can describe such as the size of an image of video data (X pixels x Y pixels) as well as an aspect ratio.<br>
When an elementary stream corresponding to Dynamiclnfo() is an audio stream (stream == AUDIO), Dynamiclnfo() is composed of channel_assignment (4 bits) and reserved_for_word_alignment for a word alignment. When an audio stream contains two channels of audio data, channel_assignment describes output attributes of two channels (output mode).  In other words, channel_assignment describes information that represents a channel assignment of stereo or dual (bilingual).<br>
When an elementary stream corresponding to<br><br>
Dynamiclnfo() is a subtitle stream (stream == SUBTITLE), Dynamiclnfo() is composed of reserved_for_word_alignment for a word alignment.  In other words, according to the embodiment shown in Fig. 13, an output attribute as dynamic information is not defined for a subtitle stream. [Description of EP_map()]<br>
Next, with reference to Fig. 14, EP_map() shown in Fig. 10 will be described in detail.<br>
Fig. 14 shows the syntax of EP_map().<br>
EP_map() describes information of a decode startable point (entry point) from which each of elementary streams multiplexed with a program stream stored in a clip stream file corresponding to the clip information file Clip() that includes EP_map() can be decoded.<br>
A decode startable point of a stream having a fixed rate can be obtained by a calculation. However, for a stream whose size varies in each video access unit such as a video stream encoded corresponding to the MPEG standard, the decode startable point cannot be obtained by a calculation. The decode startable point cannot be obtained unless the stream is analyzed. To randomly access data, it is necessary to quickly recognize the decode startable point. With EP_map(), a decode startable point can be quickly recognized.<br>
In the MPEG2-Video, the beginning of an intra<br><br>
picture including Sequence_header() and so forth is a decode startable point.<br>
EP_map() starts with<br>
reserved_for_word_alignment (8 bits) for a word alignment. reserved_for_word_alignment is followed by number_of_stream_id_entries (8 bits). number_of_stream_id_entries represents the number of elementary streams that describe information of decode startable points in EP_map().<br>
number_of_stream_id_entries is followed by sets of information that identifies an elementary stream and information of a decode startable point of the elementary stream represented by number_of_stream_id_entries.<br>
In other words, number_of_stream_id_entries is followed by stream_id (8 bits) and private_stream_id (8 bits) as information that identifies an elementary stream. private_stream_id is followed by number_of_EP_entries (32 bits). number_of_EP_entries represents the number of decode startable points identified by stream_id and private_stream_id followed by number_of_EP_entries.<br>
number_of_EP_entries is followed by sets of PTS_EP_start's (32 bits each) and RPN_EP_start's (32 bits each) represented by number_of_EP_entries as information of decode startable points of an elementary stream identified by stream__id and private_stream_id.<br><br>
PTS_EP_start as one element of information of decode startable points represents a time (reproduction time) of a decode startable point in a clip stream file that stores a program stream multiplexed with an elementary stream identified by stream_id and private_stream_id.<br>
RPN_EP_start that is another element of information of decode startable points describes the position of a decode startable point in a clip stream file that stores a program stream multiplexed with an elementary stream identified by stream_id and private_stream_id as a value as the number of pack()'s of a program stream. According to this embodiment, the size of pack () is 2048 bytes/ fixed.  In addition, according to this embodiment, one sector of the disc 101 (Fig. 1) is 2048 bytes.<br>
A decode startable point (entry point) of a video stream is immediately preceded by a private_stream_2 packet (PES_packet() as an attribute of private_stream_2). A private_stream_2 packet stores information used to decode video stream stored between two adjacent private_stream_2 packets. Thus, for a video stream, RPN_EP_start as information of a decode startable point describes the start position of a private_stream_2 packet immediately followed by a real decode startable point.<br>
Sets of PTS EP start's and RPN EP start's as<br><br>
information of decode startable points are pre-sorted in the ascending order for each elementary stream identified by stream_id and private_stream_id in EP_map(). Thus, sets of PTS_EP_start's and RPN_EP_start's as information of decode startable points can be binary-searched.<br>
A random access method for variable rate streams and streams whose sizes differ in video access units is described in for example Japanese Patent Laid-Open Publication No. 2000-341640 (Japanese Patent Application No. HEI 11-317738). [Description of Clip Stream File]<br>
Next, the internal structure of clip stream files having an extension of PS and stored in the "STREAM" directory shown in Fig. 4 ("00001.PS," "00002.PS," and "00003.PS" in Fig. 4) will be described.<br>
A clip stream file is composed on the basis of MPEG2_Program_Stream() defined in the MPEG-2 System (ISO/IEC 13818-1).<br>
Fig. 15A and Fig. 15B show Table 2-31, Table 2-32, and Table 2-33 described in the MPEG-2 System (ISO/IEC 13818-1: 20000) standard.<br>
A program stream stored in a clip stream file is MPEG2_Program_Stream() defined in Table 2-31 of the MPEG2-System standard. The program stream is composed of at least one pack() and one MPEG_program_end_code.<br><br>
MPEG2_Program_Stream() is described in Japanese Patent No. 2785220.<br>
One pack() is composed of one Pack_header() and any number of PES_packet()'s as defined in Table 2-32 of the MPEG-2 System standard. Pack_header() is described in Table 2-33 of the MPEG2-System standard in detail.<br>
In the MPEG2-System standard, pack() has a size of variable length. However, as described in Fig. 14, it is assumed that the size of pack() is 2048 bytes, fixed.  In this example, the number of PES_packet()'s of one pack() is 1, 2, or 3. When Pack() starts with a private_stream_2 packet, it is always followed by PES_packet() of the corresponding video stream (in the same PackO).  In addition, as the third PES_packet(), there may be padding_packet. A private_stream_2 packet is always present at the beginning of Pack().<br>
When Packet() does not start with a private_stream_2 packet, Pack() starts with PES_packet() that contains content data of video data, audio data, subtitle data, or the like. The second PES_packet() may be padding_packet.<br>
Fig. 16A and Fig. 16B to Fig. 18A and Fig. 18B show PES_packet() defined in Table 2-17 of the MPEG2-System standard.<br>
PES packet() is mainly composed of<br><br>
packet_start_code_prefix, stream_id, PES_packet_length (they are shown in Fig. 16A and Fig. 16B), header portions (including stuffing_byte) that vary corresponding to stream_id or the like (these portions are shown in Fig. 16A and Fig. 16B to Fig. ISA and Fig. 18B), and PES_packet_data_byte (shown in Fig. 18A and Fig. 18B) . When PES_packet() is padding_packet (stream_id == padding_stream), a required number of padding_byte's (OxFF) (Fig. ISA and Fig. 18B) are repeated instead of PES_packet_data_byte.<br>
As shown in Fig. 16A, Fig. 16B, Fig. 17A, Fig. 17B and Fig. 17C, the header portions of PES_packet() can describe information that represents a display timing called a presentation time stamp (PTS) and information that represents a decode timing called a decoding time stamp. According to this embodiment, a PTS is added to each of all access units (decode units that compose an elementary stream defined in the MPEG2-System). When specified in the MPEG2-System, a DTS is added.<br>
An elementary stream multiplexed with a program stream is stored in PES_packet_data_byte (Fig. ISA and Fig. 18B) of PES_packet(). stream_id of PES_packet() describes a value corresponding to an attribute of an elementary stream to identify the elementary stream stored in PES_packet_data_byte.<br>
The relationship of values described in<br><br>
stream_id of PES_packet() and attributes (types) of elementary streams is defined in Table 2-18 of the MPEG2-System standard.  Fig. 19A and Fig. 19B show Table 2-18 of the MPEG-2 System standard.<br>
According to the embodiment of the present invention, values shown in Fig. 20 are used as stream_id defined in the MPEG2-System standard shown in Fig. 19A and Fig. 19B.<br>
In other words, according to this embodiment, five patterns 10111101B, 10111110B, 10111111B, HOxxxxxB, and HlOxxxxB are used as values of stream_id where "x" represents any one of 0 and 1.<br>
Corresponding to the table shown in Fig. 20, stream__id of PES_packet() of an elementary stream having an attribute of private_stream_l is 10111101B. Corresponding to the table shown in Fig. 20, stream_id of PES_packet() of padding_packet is 10111110B. According to the table shown in Fig. 20, stream_id of PES_packet() of an elementary stream having an attribute of private_stream_2 is 10111111B.<br>
stream_id of PES_packet() of an audio stream (audio elementary stream) defined in the MPEG is HOxxxxxB. The low order five bits xxxxx of HOxxxxxB is an audio stream byte that identifies an audio stream. 32 (= 25) audio streams (audio streams defined in the MPEG) that can be identified by the audio stream number can be multiplexed with a program stream.<br><br>
stream_id of PES_packet() of a video stream (video elementary stream) defined in the MPEG is HlOxxxxB. The low order four bits xxxx of HOxxxxB is a video stream number that identifies a video stream. 16 (= 24) video streams (video streams defined in the MPEG) can be multiplexed with a program stream.<br>
PES_packet() whose stream_id is HOxxxxB is used to store a video stream defined in the MPEG. PES_packet() whose stream_id is HOxxxxxB is used to store an audio stream defined in the MPEG. On the other hand, stream_id of PES_packet() for an elementary stream corresponding to an encoding system (for example, the ATRAC system) is not defined in the MPEG. Thus, like a video stream and an audio stream defined in the MPEG, an elementary stream corresponding to an encoding system that is not defined in the MPEG cannot be stored in PES_packet() with stream_id.<br>
Thus, according to this embodiment, PES_packet_data_byte of PES_packet() of private_stream_l is extended to store an elementary stream corresponding to an encoding system that is not defined in the MPEG.<br>
Extended PES_packet_data_byte of PES_packet() of private_stream_l is described as private_streaml_PES_payload(). [Description of private_streaml_PES_payload()]<br>
Fig. 21 shows the syntax of<br><br>
private_streaml_PES__payload () .<br>
private_streaml_PES_payload() is composed of private_header() and private_payload(). private_payload() stores an elementary stream such as an ATRAC audio stream, an LPCM audio stream, a subtitle stream, or the like encoded corresponding to an encoding system not defined in the MPEG system.<br>
private_header() starts with<br>
private_stream_id (8 bits).  private_stream_id is identification information that identifies an elementary stream stored in private_payload(}. private_stream_id has the following value corresponding to the attribute (type) of an elementary stream.<br>
Fig. 22 shows the relationship of the value of private_stream_id and the attribute of an elementary stream stored in private_payload().<br>
Fig. 22 shows three patterns OOOOxxxxB, OOOlxxxxB, and lOOxxxxxB as the value of private_stream_id where "x" is any value of 0 and 1 like the case shown in Fig. 20.<br>
According to the table shown in Fig. 22, private_stream_id of private_streaml_PES_payload() of private_payload() of an ATRAC audio stream is OOOOxxxxB. The low order four bits xxxx of OOOOxxxxB is an audio stream number that identifies an ATRAC audio stream.  16 (= 24) ATRAC audio streams that can be identified by the audio stream number can be<br><br>
multiplexed with a program stream (MPEG2_Program_Stream()).<br>
According to the table shown in Fig. 22, private_stream_id of private_streaml_PES_payload() of private_payload() of an LPCM audio stream is OOOlxxxxB. The low order four bits xxxx of OOOlxxxxB is an audio stream number that identifies an LPCM audio stream.  16 (= 24) that can be identified by the audio stream number can be multiplexed with a program stream.<br>
According to the table shown in Fig. 22, private_stream_id of private_streaml_PES_payload() of private_payload() of a subtitle stream is lOOxxxxB. The low order five bits xxxxx of lOOxxxxxB is a subtitle stream number that identifies a subtitle stream.  32 ( = 25) subtitle streams can be multiplexed with a program stream.<br>
Fig. 11 shows the relationship of Fig. 20 and Fig. 22.<br>
In Fig. 21, elements preceded by<br>
private_stream_id of private_streaml_PES_payload() vary depending on the attribute of an elementary stream stored in private_payload(). The attribute of an elementary stream stored in private_payload() is determined by private_stream_id at the beginning of private_header().<br>
When an elementary stream stored in private payload() is an ATRAC audio stream<br><br>
(private_stream_id == ATRAC), reserved_for_future_use (8 bits) is described for a future extension. reserved_for_future_use is followed by AU_locator (16 bits). AU_locator represents the start position of an audio access unit (ATRAC audio access unit) (audio frame) of an ATRAC audio stream stored in private_payload() on the basis of the position immediately preceded by AU_locator. When private_payload() does not store an audio access unit, for example OxFFFF is described in AU_locator. When an elementary stream stored in private_payload() is an LPCM audio stream (private_stream_id == LPCM), fs_flag (I bit), reserved_for_future_use (3 bits), ch_flag (4 bits), and AU_locator (16 bits) are described in succession.<br>
fs_flag represents a sampling frequency of an LPCM audio stream stored in private_payload(). When the sampling frequency of an LPCM audio stream is 48 kHz, fs_flag is 0. When the sampling frequency of an LPCM audio stream is 44.1 kHz, fs_flag is 1.<br>
ch_flag represents the number of channels of an LPCM audio stream stored in private_payload(). When an LPCM audio stream is monaural, ch_flag is 1. When an LPCM audio stream is stereo, ch_flag is 2.<br>
AU_locator represents the start position of an audio access unit (LPCM audio access unit) (audio frame) of an LPCM audio stream stored in<br><br>
private_payload() on the basis of the position immediately preceded by AU_locator. When private_payload() does not store an audio access unit, for example OxFFFF is described in AU_locator.<br>
When an elementary stream stored in private_payload() is a subtitle stream (private_stream_id == SUBTITLE),<br>
reserved_for_future_use (8 bits) is described for a future extension.  reserved_for_future_use is immediately followed by AU_locator (16 bits). AU_locator represents the start position of a subtitle access unit of a subtitle stream stored in private_payload() on the basis of the position immediately after AU_locator. When private_payload() does not store a subtitle access unit, for example OxFFFF is described in AU_locator. [Description of private_stream2_PES_payload()]<br>
Fig. 23 shows the syntax of private_stream2_PES_payload().<br>
private_stream2_PES_payload() is an extension of PES_packet_data_byte (Fig. ISA and Fig. 18B) of private_payload() of private_stream_2, namely an extension of PES_packet_data_byte of PES_packet() of private_stream_2. private_stream2_PES_payload() describes information used to decode a video stream.<br>
According to this embodiment, PES_packet() of private stream 2 is immediately preceded by a decode<br><br>
startable point of a video stream. Thus, according to this embodiment, when PES_packet() of private_stream_2 is detected from a program stream, video streams immediately preceded by PES_packet() can be decoded.<br>
RPN_EP_start of EP_map() shown in Fig. 14 represents the start position of PES_packet() of private_stream_2 for a video stream.<br>
private_stream2_PES_payload() starts with reserved_for_future_use (8 bits) for a future extension. reserved_for_future_use is followed by video_stream_id (8 bits), lstRef_picture (16 bits), 2ndRef_picture (16 bits), 3rdRef_picture (16 bits), 4thRef_picture (16 bits), au_information(), and VBI() in succession.<br>
video_stream_id describes stream_id (the same value as stream-id) of PES_packet() of a video stream immediately preceded by PES_packet() of private_stream_2. video_stream_id identifies a video stream (PES_packet() that stores a video stream) that is decoded with information stored in PES_packet() (private_stream2_PES_payload() of PES_packet()) of private_stream_2.<br>
lstRef_picture, 2ndRef_picture,<br>
3rdRef_picture, and 4thRef_picture represent relative values of positions of the last pack()'s including first, second, third, and fourth reference images from PES packet() of private stream 2 to PES packet() of the<br><br>
next private_stream_2 of a video stream identified by video_stream_id/ respectively. The details of lstRef_picture, 2ndRef_picture, 3rdRef_picture, and 4thRef_picture are disclosed as bytes_to_first_P_pic and bytes_to_second_P_pic in Japanese Patent Laid-Open Publication No. HEI 09-46712 (Japanese Patent Application No. HEI 07-211420).<br>
au_information() describes information about a video access unit of a. video stream from PES_packet() of private_stream_2 to PES_packet() of the private_stream_2. au_information() will be described in detail with reference to Fig. 24.<br>
VBI() is used to describe information about a closed caption.<br>
PES_packet() of private_stream_2 that has private_stream2_PES_payload() is described for the decode startable point of each video stream.<br>
Fig. 24 shows the syntax of au_information() shown in Fig. 23.<br>
au_information() starts with length (16 bits), length represents the size of au_information() including the size of length,  length is followed by reserved_for_word_alignment (8 bits) and number_of_access_unit (8 bits) in succession. reserved_for_word_alignment is used for a word alignment.<br>
number of access unit represents the number<br><br>
of access units (pictures) stored from PES_packet() of private_stream2 to PES_packet() of the next private_stream2.<br>
In other words, number_of_access_unit represents the number of access units (pictures) contained in a video stream represented by video_stream_id from au_information() to the next au_information (or the end of the clip stream file when au_information() is the last au_information() thereof) in PES_packet()'s of private_stream_2's whose video_stream_id in private_stream2_PES_payload() is the same.<br>
number_of_access_unit is followed by the contents of a for loop corresponding to number_of_access_unit.  In other words, information about at least one video access unit from PES_packet() of private_stream_2 including number_of_access_unit to PES_packet() of the next private_stream_2 is described.<br>
Information described in the for loop (information about video access units) is as follows.<br>
The for loop contains pic_struct_copy (4 bits), au_ref_flag (1 bit), AU_length (21 bits), and reserved.<br>
pic_struct_copy describes a copy of<br>
pic_struct() defined in ISO/IEC 14496-10, D.2.2. for a video access unit corresponding to the MPEG4-AVC (ISO/IEC 14496-10). pic struct!) is information that<br><br>
represents that for example a picture frame is displayed or after a top field of a picture is displayed, a bottom field is displayed.<br>
au_ref_flag represents whether a<br>
corresponding access unit is a reference picture that is referenced when (a picture of) another access unit is decoded. When the corresponding access unit is a reference picture, au_ref_flag is 1. When the corresponding access unit is not a reference picture, au_ref_flag is 0.<br>
AU_length represents the size of a corresponding access unit in bytes. [Specific Example of Data Recorded on Disc 101]<br>
Fig. 25 to Fig. 28 show specific examples of data that have the foregoing format and that have been recorded on the disc 101 shown in Fig. 1.<br>
In Fig. 25 to Fig. 28, a video stream corresponding to the MPEG2-Video and an audio stream corresponding to the ATRAC are used. However, a video stream and an audio stream used in the present invention are not limited to these streams.  In other words, a video stream corresponding to the MPEG4-Visual, a video stream corresponding to the MPEG4-AVC, or the like may be used. On the other hand, an audio stream corresponding to the MPEGl/2/4 audio, an audio stream corresponding to the LPCM audio, or the like may be used.<br><br>
Unlike a video stream and an audio stream, a subtitle stream may not be successively decoded and displayed (output) at the same intervals. In other words, a subtitle stream is sometimes supplied from the buffer control module 215 shown in Fig. 2A and Fig. 2B to the subtitle decoder control module 218. The subtitle decoder control module 218 decodes the subtitle stream.<br>
Fig. 25 to Fig. 28 show specific examples of "PLAYLIST.DAT" file, three clip information files "00001.CLP," "00002.CLP," and "00003.CLP," and so forth in the case that the three clip information files "00001.CLP," "00002.CLP," and "00003.CLP" are stored in the "CLIP" directory and three clip stream files "00001.PS," "00002.PS," and "00003.PS" corresponding to the three clip information files "00001.CLP," "00002.CLP," and "00003.CLP" are stored in the "STREAM" directory. However, in Fig. 25 to Fig. 28, a part of data such as the "PLAYLIST.DAT" file and so forth are omitted.<br>
Fig. 25 shows a specific example of the "PLAYLIST.DAT" file shown in Fig. 5.<br>
In Fig. 25, number_of_PlayLists is 2. Thus, the number of PlayList()'s stored in the "PLAYLIST.DAT" file is 2.  In Fig. 25, the two PlayList()'s are PlayListttO and PlayListttl.<br>
capture_enable_flag_PlayList of the first<br><br>
PlayList()/ namely PlayList#0, is 1. Thus, video data reproduced according to PlayList#0 are permitted to be secondarily used. On the other hand, number_of_Play!tems of PlayList#0 is 2. Thus, the number of PlayltemO's contained in PlayListttO is 2. Specific examples of Playltem#0 and Playltem#l as two PlayltemO's are described below a "PlayList#0" field shown in Fig. 25.<br>
In Playltem#0 as the first Playltem() contained in PlayList#0, Clip_Information_file_name described in Fig. 6 is "00001.CLP", IN_time being 180,090, OUT_time being 27,180,090. Thus, a clip reproduced by Playltem#0 of PlayList#0 is from time 180,090 to time 27,180,090 of the clip stream file "00001.CLP" corresponding to the clip information file "00001.CLP."<br>
In Playltem#l as the second Playltem() contained in PlayList#0, Clip_Information_file_name described in Fig. 6 is "00002.CLP, " In-time being 90,000, OUT_time being 27,090,000. Thus, a clip reproduced by Playltem#l of PlayList#0 is from time 90,000 to time 27,090,000 of the clip stream file "00002.PS" corresponding to the clip information file "00002.CLP."<br>
In Fig. 25, in PlayList#l as the second PlayList(), capture_enable_flag_PlayList is 0. Thus, video data reproduced according to PlayList#l are not<br><br>
permitted to be secondarily used (prohibited from being secondarily used).  In PlayListttl, number_of_PlayItems is 1. Thus, the number of PlayltemO's contained in PlayList#l is 1.  In Fig. 25, a specific example of Playltem#0 as one PlayltemO is described below a "PlayListttl" field.<br>
In Playltem#0 as one PlayltemO contained in PlayListttl, Clip_Information_file_name described in Fig. 6 is "00003.CLP," IN_time being 90,000, OUT_time being 81,090,000. Thus, a clip reproduced by PlayltemtfO of PlayListttl is from time 90,000 to time 81,090,000 of the clip stream file "00003.PS" corresponding to the clip information file "00003.CLP."<br>
Fig. 26A and Fig. 26B show a specific example of the clip information file ClipO described in Fig. 10. Thus, Fig. 26A and Fig. 26B show specific examples of the clip information files "00001.CLP," "00002.CLP," and "00003.CLP."<br>
In the clip information file "00001.CLP," presentation_start_time is 90,000 and presentation_end_time is 27,990,000. Thus, a program stream stored in the clip stream file "00001.CLP" corresponding to the clip information file "00001.CLP" can use a content for 310 seconds (27,990,000 - 90,000 / 90 kHz).<br>
In the clip information file "00001.CLP," capture_enable flag_Clip is 1. Thus, a video stream<br><br>
(video data corresponding thereto) multiplexed with a program stream stored in the clip stream file "00001.CLP" corresponding to the clip information file "00001.CLP" is permitted to be secondarily used.<br>
In Fig. 26A and Fig. 26B, in the clip information file "00001.CLP," number_of_streams is 4. Thus, four elementary streams are multiplexed with a program stream stored in the clip stream file "00001.PS."<br>
Assuming that the four elementary streams are denoted by streamttO, stream#l, stream#2, and stream#3, specific examples of Streamlnfo()'s (Fig. 10) of the four elementary streams, which are stream#0, stream#l, stream#2, and stream#3 are described below a "00001.CLP" field shown in Fig. 26A and Fig. 26B.<br>
In the first elementary stream stream#0 of the clip stream file "00001.PS," stream_id is OxEO. Thus, as described in Fig. 20 and Fig. 22 (or Fig. 11), the elementary stream stream#0 is a video stream. According to this embodiment, private_stream_id is not correlated with a video stream. In Fig. 26A and Fig. 26B, private_stream_id is 0x00.<br>
In the video stream streamttO as the first elementary stream of the clip stream file "00001.PS," picture_size of StaticInfoO (Fig. 12) contained in Streamlnfo() is "720 x 480", frame_rate being "29.97 Hz," cc flag being "Yes." Thus, the video stream<br><br>
stream#0 is video data having 720 x 480 pixels and a frame period of 29.97 Hz.  In addition, the video stream stream#0 contains closed caption data.<br>
In the video stream stream#0 as the first elementary stream of the clip stream file "00001.PS," number_of_DynamicInfo of Streamlnfo() (Fig. 10) is 0. There is no pair of pts_change_point and Dynamiclnfo().<br>
In the second elementary stream stream#l of the clip stream file "00001.PS," stream_id is OxBD, private_stream_id being 0x00. Thus, as described in Fig. 20 and Fig. 22, the elementary stream stream#l is an ATRAC audio stream.<br>
In the ATRAC audio stream stream#l as the second elementary stream of the clip stream file "00001.PS," audio_language_code of Staticlnfo() (Fig. 12) contained in Streamlnfo() is "Japanese," channel_configuration being "STEREO," lfe_existence being "NO," sampling_frequency being "48 kHz." Thus, the ATRAC audio stream stream#l is Japanese and stereo audio data.  In addition, the ATRAC audio stream streamttl does not contain a low frequency effect channel and the sampling frequency is 48 kHz.<br>
In addition, in the ATRAC audio stream stream#l as the second elementary stream of the clip stream file "00001.PS," number_of_Dynamic!nfo of Streamlnfo() (Fig. 10) is 0. There is no pair of pts change_point and Dynamiclnfo().<br><br>
In the third elementary stream stream#2 of the clip stream file "00001.PS," stream_id is OxBD, private_stream_id being 0x80. Thus, as described in Fig. 20 and Fig. 22, the elementary stream stream#2 is a subtitle stream.<br>
In the subtitle stream stream#2 as the third elementary stream of the clip stream file "00001.PS," subtitle_language_code of StaticInfoO (Fig. 12) contained in Streamlnfo() is "Japanese," configurable_flag being 0. Thus, the subtitle stream stream#2 is Japanese subtitle data. In addition, this display mode is not permitted to be changed (prohibited from being changed).<br>
In the subtitle stream stream#2 as the third elementary stream of the clip stream file "00001.PS," number_of_DynamicInfo of Streamlnfo() (Fig. 10) is 0. There is no pair of pts_change_point and Dynamiclnfo(),<br>
In the fourth elementary stream stream#3 of the clip stream file "00001.PS," stream_id is OxBD, private_stream_id being 0x81. Thus, as described in Fig. 20 and 22, the elementary stream stream#3 is a subtitle stream.<br>
To distinguish the subtitle stream stream#2 as the third elementary stream of the clip stream file "00001.PS" from the subtitle stream stream#3 as the fourth elementary stream, their private_stream_id's are 0x80 and 0x81, respectively.<br><br>
In the subtitle stream stream#2 as the fourth elementary stream of the clip stream file "00001. PS," subtitle_language_code of StaticInfoO (Fig. 12) contained in Streamlnfo() is "Japanese," configurable_flag being 1. Thus, the subtitle stream stream#3 is Japanese subtitle data. The display mode of the subtitle stream stream#3 is permitted to be changed.<br>
In the subtitle stream stream#3 as the fourth elementary stream of the clip stream file "00001.PS," number_of_DynamicInfo of Streamlnfo() (Fig. 10) is 0. There is no pair of pts_change_point and Dynamiclnfo().<br>
In Fig. 26A and Fig. 26B, in the clip<br>
information file "00002.CLP," presentation_start_time is 90,000, presentation_end_time being 27,090,000. Thus, a program stream stored in the clip stream file "00002.PS" corresponding to the clip information file "00002.CLP" can use a content for 300 seconds ((27,090,000 - 90,000 / 90 kHz).<br>
In the clip information file "00002.CLP," capture_enable_flag_Clip is 0. Thus, a video stream (video data corresponding thereto) multiplexed with a program stream stored in the clip stream file "00002.PS" corresponding to the clip information file "00002.CLP" is not permitted to be secondarily used (prohibited from being secondarily used).<br>
In Fig. 26A and Fig. 26B, in the clip<br><br>
information file "00002.CLP," number_of_streams is 4. Thus, like the foregoing clip stream file "00001.CLP," four elementary streams are multiplexed with a program stream stored in the corresponding clip stream file "00002.PS."<br>
Assuming that the four elementary streams are denoted by stream#0, stream#l, stream#2, and stream#3, specific examples of Streamlnfo()'s (Fig. 10) of the four elementary streams, which are stream#0, stream#l, stream#2, and stream#3, are described below a "00002.CLP" field shown in Fig. 26A and Fig. 26B.<br>
In Fig. 26A and Fig. 26B, the contents of Streamlnfo()'s of the first to fourth elementary streams of the clip stream file "00002.PS" are the same as those of the first to fourth elementary streams of the clip stream file "00001.PS."  Thus, their description will be omitted.<br>
As described above, the contents of Streamlnfo()'s of the first to fourth elementary streams, stream#0 to stream#3, of the clip stream file "00002.PS" are the same as those of the first to fourth elementary streams, stream#0 to stream#3, of the clip stream file "00001.CLP." Thus, the first elementary stream streamttO of the clip stream file "00002.PS" is a video stream.  The second elementary stream stream#l is an ATRAC audio stream. The third and fourth elementary streams, stream#2 and stream#3, are subtitle streams.<br><br>
In Fig. 26A and Fig. 26B, in the clip<br>
information file "00003.CLP," presentation_start_time is 90,000, presentation_end_time being 81,090,000. Thus, a program stream stored in the clip stream file "00003.PS" corresponding to the clip information file "00003.CLP" can use a content for 900 seconds ((81,090,000 - 90,000) / 90 kHz).<br>
In the clip information file "00003.CLP," capture_enable_flag_Clip is 1. Thus, a video stream multiplexed with a program stream stored in the clip stream file "00003.PS" corresponding to the clip information file "00003.CLP" is permitted to be secondarily used.<br>
In Fig. 26A and Fig. 26B, in the clip information file "00003.CLP," number_of_strearns is 3. Thus, three elementary streams are multiplexed with a program stream stored in the clip stream file "00003.PS."<br>
Assuming that the three elementary streams are denoted by stream#0, streamttl, and stream#2, specific examples of Streamlnfo()'s (Fig. 10) of the three streams, which are stream#0, stream#l, and stream#2, are described below a "00003.CLP" field shown in Fig. 26A and Fig. 26B.<br>
In the first elementary stream streamttO of the clip stream file "00003.PS," stream_id is OxEO. Thus, as described in Fig. 20 and Fig. 22 (or Fig. 11),<br><br>
the elementary stream stream#0 is a video stream. Like the first elementary stream stream#0 of the clip stream file "00001.CLP," private_stream_id is 0x00.<br>
In the video stream stream#0 as the first elementary stream of the clip stream file "00003.PS," picture_size of StaticInfoO (Fig. 12) contained in Streamlnfo() is "720 x 480", frame_rate being "29.97 Hz," cc_flag being "No." Thus, the video stream stream#0 is video data having 720 x 480 pixels and a frame period of 29.97 Hz. The video stream stream#0 does not contain closed caption data.<br>
In the video stream streamttO as the first elementary stream of the clip stream file "00003.PS," number_of_Dynamic!nfo of Streamlnfo() (Fig. 10) is 2. Thus, two sets of pts_change_point's and Dynamiclnfo()'s are described in Streamlnfo().<br>
In the second elementary stream streamttl of the clip stream file "00003.PS," stream_id is OxEl. Thus, as described in Fig. 20 and Fig. 21 (or Fig. 11), the elementary stream stream#l is a video stream.  To distinguish the video stream streamttO as the first elementary stream of the clip stream file "00003.PS" from the video stream streamttl as the second elementary stream, their stream_id's are OxEO and OxEl, respectively. Like the first elementary stream streamttO of the clip stream file "00001.CLP," private stream_id is 0x00.<br><br>
In the video stream streamttl as the second elementary stream of the clip stream file "00003.PS," picture_size, frame_rate, and cc_flag of Staticlnfo() (Fig. 12) contained in StreamlnfoO are the same as those of the video stream stream#0 as the first elementary stream. Thus, the video stream stream#l as the second elementary stream of the clip stream file "00003.PS" is video data having 720 x 480 pixels and a frame period of 29.97 Hz. The video stream stream#l does not contain closed caption data.<br>
In the video stream stream#l as the second elementary stream of the clip stream file "00003.PS," number_of_DynamicInfo of StreamlnfoO (Fig. 10) is 0. Thus, there is no pair of pts_change_point and Dynamiclnfo().<br>
In the third elementary stream stream#2 of the clip stream file "00003.PS," stream_id is OxBD, private_stream_id being 0x00. Thus, as described in Fig. 20 and Fig. 22, the elementary stream stream#2 is an ATRAC audio stream.<br>
In the ATRAC audio stream stream#2 as the third elementary stream of the clip stream file "00003.PS," audio_language_code, channel_configuration, lfe_existence, and sampling_frequency of Staticlnfo() (Fig. 12) contained in StreamlnfoO are the same as those of the ATRAC audio stream stream#l as the second elementary stream of the clip stream file "00001.CLP."<br><br>
Thus, the ATRAC audio stream stream#2 as the third elementary stream of the clip stream file "00003.PS" is Japanese and stereo audio data.  In addition, the ATRAC audio stream stream#2 does not contain a low frequency effect channel. The ATRAC audio stream stream#2 has a sampling frequency of 48 kHz.<br>
In the ATRAC audio stream stream#2 as the third elementary stream of the clip stream file "00003.PS," number_of_Dynamic!nfo of Streamlnfo() (Fig. 10) is 3. Thus, Streamlnfo() describes three sets of pts_change_point's and Dynamiclnfo()'s.<br>
Fig. 27 shows a specific example of EP_map() of the clip information file ClipO described in Fig. 10. Fig. 27 shows a specific example of EP_map(), shown in Fig. 14, of the clip information file "00001.CLP" shown in Fig. 4.<br>
In Fig. 27, in EP_map(),<br>
number_of_stream_id_entries is 1. Thus/ EP_map() describes information of a decode startable point of one elementary stream.<br>
In EP_map() shown in Fig. 27, stream_id is OxEO. Thus, as described in Fig. 20 and Fig. 22, EP__map() describes information (PTS_EP_start and RPN_EP_start (Fig. 14)) of a decode startable point of a video stream identified by stream_id that is OxEO. In Fig. 27, EP_map() is the clip information file "00001.CLP." As described in Fig. 26A and Fig. 26B, in<br><br>
the clip stream file "00001.PS" corresponding to the clip information file "00001.CLP," an elementary stream whose stream_id is OxEO is the first video stream of the clip stream file "00001.PS." Thus, information described in EP_map() shown in Fig. 27 is PTS_EP_start and RPN_EP_start of a decode startable point of the video stream stream#0.<br>
In Fig. 27, the first five PTS_EP_start's and RPN_EP_start's of decode startable points of the first video stream stream#0 of the clip stream file "00001.PS" are described, but sixth and later PTS_EP_start's and RPN_EP_start's are omitted.<br>
In EP_map() shown in Fig. 27,<br>
private_stream_id is 0x00. When stream_id represents a video stream, private_stream_id is ignored.<br>
Fig. 28 shows specific examples of<br>
PlayListMarkO 's of PlayListttO and PlayList#l described in Fig. 25 (PlayListO shown in Fig. 5).<br>
An upper table shown in Fig. 28 represents PlayListMarkO (Fig. 7) of PlayListttO.<br>
In the upper table shown in Fig. 28, number_of_PlayList_marks of PlayListMarkO of PlayList#0 is 7. Thus, the number of Mark()'s contained in PlayList#0 (PlayListMarkO thereof) is 7.<br>
In the upper table shown in Fig. 28, mark_type (Fig. 7) of Mark#0 as the first Mark() of seven Mark()'s contained in PlayList#0 is "Chapter."<br><br>
Thus, Mark#0 is a chapter mark.  In addition, since ref_to_Play!tem_id (Fig. 7) is 0, Mark#0 belongs to PlayltemttO of two Playltem#0 and #1 shown in Fig. 25. In addition, mark_time_stamp of Mark#0 is 180,090. Thus, Mark#0 is a mark of time (reproduction time) 180,090 of a clip stream file reproduced by Playltem#0 contained in PlayListttO. Both entry_ES_stream_id and entry_ES_private_stream_id of Mark#0 are 0. Thus, Mark#0 is not correlated with any elementary stream. In addition, mark_data of Mark#0 is 1. Thus, Mark#0 represents a chapter whose number is 1.<br>
A clip stream file reproduced by Playltem#0 contained in PlayList#0 is the clip stream file "00001.PS" identified by "00001.CLP" described in Clip_Information_file_name of Playltem#0 (Fig. 25). Thus, time 180,090 represented by mark_time_stamp of MarkttO is the time of the clip stream file "00001.PS."<br>
In the upper table shown in Fig. 28, Mark#4 as the fifth Mark() of seven MarkO's contained in PlayListftO is a chapter mark that is the same as the first MarkttO.<br>
In other words, mark_type (Fig. 7) of Mark#4 as the fifth Mark() is "Chapter." Thus, Mark#4 is a chapter mark.  In addition, ref_to_PlayItem_id (Fig. 7) of Mark#4 is 1. Thus, Mark#4 belongs to Playltem#l of two Playltem#0 and #1, shown in Fig. 25, contained in PlayList#0. mark time stamp of Mark#4 is 90,000.<br><br>
Thus, Mark#4 is a mark of time 90,000 of a clip stream file reproduced by Playltem#l contained in PlayList#0. In addition, both entry_ES_stream_id and entry_ES_private_stream_id of Mark#4 are 0. Thus/ Mark#4 is not correlated with any elementary stream. In addition, mark_data of Mark#4 is 2. Thus, Mark#4 represents a chapter whose number is 2.<br>
In this example, a clip stream file<br>
reproduced by Playltem#l contained in PlayList#0 is the clip stream file "00002.PS" identified by "00002.CLP" described in Clip_Information_file_name of Playltem#l (Fig. 25). Thus, time 90,000 represented by mark_time_stamp of Mark#4 is time of the clip stream file "00002.PS."<br>
In the upper table shown in Fig. 28,<br>
mark_type (Fig. 7) of Mark#l as the second Mark() of seven MarkO's contained in PlayList#0 is "Index." Thus, Mark#l is an index mark.  In addition, ref_to_Play!tem_id (Fig. 7} of Markttl is 0. Thus, Mark#l belongs to PlayltemttO of two Playltem#0 and #1, shown in Fig. 25, contained in PlayList#0.  In addition, mark_time_stamp of Markttl is 5,580,090. Thus, Mark#l is a mark of time 5,580,090 of a clip stream file reproduced by Playltem#0 contained in PlayList#0.  In addition, both entry_ES_stream_id and entry_ES_private_stream_id of Mark#l are 0. Thus, Mark#l is not correlated with any elementary stream.<br><br>
In addition, mark_data of Mark#l is 1. Thus, Mark#l represents an index whose number is 1.<br>
In this example, a script stream file<br>
reproduced by Playltem#0 contained in PlayListttO is the clip stream file "00001.PS" as described above. Thus, time 5,580,090 represented by mark_time_stamp of Markttl is the time of the clip stream file "00001.PS."<br>
In the upper table shown in Fig. 28, Mark#2, Mark#5, and Mark#6 as the third, sixth, and seventh Mark()'s of the seven MarkO's contained in PlayList#0 are index marks like the second Mark#l.<br>
In the upper table shown in Fig. 28,<br>
mark_type (Fig. 7) of Mark#3 as the fourth Mark{) of the seven MarkO's contained in PlayList#0 is "Event." Thus, Mark#3 is an event mark.  In addition, ref_to_PlayItem_id (Fig. 7) of Mark#3 is 0. Thus, Mark#3 belongs to Playltem#0 of two Playltem#0 and #1, shown in Fig. 25, contained in PlayList#0.  In addition, mark_time_stamp of Mark#3 is 16,380,090. Thus, Mark#3 is a mark of time 16,380,090 of a clip stream file reproduced by Playltem#0 contained in PlayList#0. entry_ES_stream_id and entry_ES_private_stream_id of Mark#3 are 0. Thus, Mark#3 is not correlated with any elementary stream. In addition, mark_data of Mark#3 is 0. Thus, Mark#3 causes an event with an argument of 0 to take place. As described above, a clip stream file<br><br>
reproduced by Playltem#0 contained in PlayListttO is the clip stream file "00001.PS." Time 16,380,090 represented by mark_time_stamp of Mark#3 is the time of the clip stream file "00001.PS."<br>
In the upper table shown in Fig. 28, cumulative times of PlayltemO' to which Mark()'s belong are described in a left field on the right side of the table of PlayListMark() of PlayList#0. Cumulative times of PlayList#0 are described in a right field on the right side of the table.<br>
A lower table shown in Fig. 28 represents PlayListMarkO of PlayListtfl (Fig. 7).<br>
In the lower table shown in Fig. 28, number_of_Playlist_marks of PlayListMarkO of PlayListttl is 3. Thus, the number of MarkO's contained in PlayListttl (PlayListMarkO thereof) is 3.<br>
In the lower table shown in Fig. 28, mark_type (Fig. 7) of Mark#0 as the first Mark() of three MarkO's contained in PlayList#l is "Chapter." Thus, MarkttO is a chapter mark. In addition, ref_to_Play!tem_id (Fig. 7) of Mark#0 is 0. Thus, MarkttO belongs to one PlayltemttO, shown in Fig. 25, contained in PlayListftl. mark_time_stamp of Mark#0 is 90,000. Thus, MarkttO is a mark of time 90,000 of a clip stream file reproduced by PlayltemttO contained in PlayListttl. Both entry_ES_stream_id and entry ES private stream id of Mark#0 are 0.  Thus,<br><br>
MarkttO is not correlated with any elementary stream. In addition, mark_data of MarkttO is 0. Thus, MarkttO represents a chapter whose number is 0.<br>
A clip stream file reproduced by PlayltemttO contained in PlayListttl is the clip stream file "00003.PS" identified by "00003.CLP" described in Clip_Information_file_name of Playltem#0 (Fig. 25). Thus, time 90,000 represented by mark_time_stamp of MarkttO is the time of the clip stream file "00003.PS."<br>
In the lower table shown in Fig. 28,<br>
mark_type (Fig. 7) of Markttl as the second Mark() of three Mark()'s contained in PlayListttl is "Event." Thus, Mark#l is an event mark.  In addition, ref_to_Play!tem_id (Fig. 7) of Markttl is 0. Thus, Mark#l belongs to Playltem#0, shown in Fig. 25, which contained in PlayList#l.  In addition, mark__time_stamp of Markttl is 27,090,000. Thus, Markttl is a mark of time 27,090,000 of a clip stream file reproduced by PlayltemttO contained in PlayListttl.  In addition, in Markttl, entry_ES_stream_id is OxEO and entry_ES_private_stream_id is 0. Thus, Markttl is correlated with an elementary stream whose stream_id is OxEO, namely Markttl is correlated with a video stream as described in Fig. 20 and Fig. 22.  In addition, mark_data of Markttl is 1.  Markttl causes an event with an attribute of 1 to take place.<br>
As described above, a clip stream file<br><br>
reproduced by Playltem#0 contained in PlayList#l is "00003.PS." Thus, time 27,090,000 represented by mark_time_stamp of Mark#l is the time of the clip stream file "00003.PS."<br>
A video stream, whose stream_id is OxEO, correlated with Mark#l is the first elementary stream (video stream) stream#0 of three elementary streams stream#0 to #2 multiplexed with the clip stream file "00003.PS" identified by the clip information file "00003.CLP" shown in Fig. 26A and Fig. 26B.<br>
In the lower table shown in Fig. 28, mark_type of Mark#2 as the third Mark() of three Mark()'s contained in PlayListttl is "Event." Thus, Mark#2 is an event mark.  In addition, ref_to_PlayItem_id (Fig. 7) of Mark#2 is 0. Thus, Mark#2 belongs to Playltem#0, which is one of Playltem's, shown in Fig. 25, contained in PlayListttl. In addition, mark_time_stamp of Mark#2 is 27,540,000. Thus, Mark#l is a mark of time 27,540,000 of a clip stream file reproduced by Playltem#0 contained in PlayList#l.  In addition, in Mark#2, entry_ES_stream_id is OxEl and entry_ES_private_stream_id is 0. Thus, Mark#2 is an element stream whose stream_id is OxEl, namely correlated with a video stream as described in Fig. 20 and Fig. 22.  In addition, mark_data of Mark#2 is 2. Thus, Mark#2 causes an event with an argument of 2 to take place.<br><br>
In this example, as described above, a clip stream file reproduced by PlayltemttO contained in PlayListttl is the clip stream file "00003.PS." Thus, time 27,540.000 represented by Mark#2 is a time of the clip stream file "00003.PS."<br>
A video stream, whose stream_id is OxEl, correlated with Mark#2, is a video stream described in "00003.CLP" described in Clip_Information_file_name of PlayltemttO contained in PlayListttl shown in Fig. 25, namely the second elementary stream (video stream) streamttl of three elementary streams stream#0 to #2 multiplexed with the clip stream file "00003.PS" recognized from the clip information file "00003.CLP" shown in Fig. 26A and Fig. 26B.<br>
In the lower table shown in Fig. 28, cumulative times of Playltem()'s to which Mark()'s belong are described on the right side of the table of PlayListMarko of PlayListttl.<br>
In Fig. 28, although mark_data describes chapter and index numbers that chapter and index marks represent, they may not been described in mark_data. Instead, by counting chapter and index marks of PlayListMarko, chapter and index numbers can be recognized. [Description of Operation of Disc Device]<br>
Next, the operation of the disc device shown in Fig. 1 will be described assuming that data (files)<br><br>
described in Fig. 25 to Fig. 28 have been recorded on the disc 101 shown in Fig. 1.<br>
When the disc 101 is loaded into the disc drive 102, a corresponding message is sent through the drive interface 114 and the operating system 201 shown in Fig. 2A and Fig, 2B to the video content reproduction program 210. When the video content reproduction program 210 has received from the operating system 201 the message that represents that the disc 101 had been loaded into the disc drive 102, the video content reproduction program 210 starts a pre-reproduction process shown in Fig. 29. [Pre-reproduction Process]<br>
Fig. 29 is a flow chart describing the pre-reproduction process that the video content reproduction program 210 executes.<br>
It should be noted that the disc device does not need to perform operations or processes in the time sequence of the flow chart. Alternatively, the disc device may perform the operations or processes in parallel or discretely. However, in the specification, for convenience, the operations or processes of the disc device will be described corresponding to the flow chart.<br>
In the pre-reproduction process, at step S101, the video content reproduction program 210 checks the disc 101 with a file system function of the<br><br>
operating system 201 and determines whether the disc 101 is a normal disc for the video content reproduction program 210.<br>
As described above, although the disc 101 is accessed (files are read therefrom) with the file system function of the operating system 201, the description thereof will be omitted.<br>
When the determined result at step S101 represents that the disc 101 is not a normal disc, namely the file system used in the disc 101 does not comply with the operating system 201 or the root directory of the disc 101 does not contain the "VIDEO" directory, the video content reproduction program 210 determines that the video content reproduction program 210 do not comply with the disc 101, the flow advances to step S102. At step S102, the graphics process module 219 performs an error process and completes the pre-reproduction process.<br>
In other words, the graphics process module 219 generates an error message (video data thereof) that represents that the disc 101 is not normal as an error process and causes the video output module 220 to output the error message so that the error message is displayed. The error process may be performed for example by outputting an alarm sound from the audio output module 221 or unloading the disc 101 from the disc drive 102.<br><br>
When the determined result at step S101<br>
represents that the disc 101 is a normal disc, the flow advances to step S103. At step S103, the video content reproduction program 210 causes the content data supply module 213 to request the operating system 201 to read the two data files, "SCRIPT.DAT" and "PLAYLIST.DAT," stored in the "VIDEO" directory of the disc 101 (Fig. 4). Thereafter, the flow advances to step S104. At step S104, the "SCRIPT.DAT" file is supplied to the script control module 211.  In addition, the "PLAYLIST.DAT" file is supplied to the player control module 212.<br>
Thereafter, the flow advances from step S104 to steps S105 through S107. At steps S105 through S107, the player control module 212 performs an initialization process. The script control module 211 waits until the player control module 212 has completed the initialization process. [Initialization Process of Player Control Module 212]<br>
In the initialization process, at step S105, the player control module 212 analyzes the "PLAYLIST.DAT" file and checks the number of clip information files described in the "PLAYLIST.DAT" file and their file names.<br>
In other words, since the "PLAYLIST.DAT" file is as shown in Fig. 25 and number_of_PlayLists of the "PLAYLIST.DAT" file shown in Fig. 25 is 2, the player<br><br>
control module 212 recognizes that there are two PlayListO's that are PlayListttO and PlayListttl.  In addition, since number_of_PlayItems of the first PlayListttO of the "PLAYLIST.DAT" file shown in Fig. 25 is 2, the player control module 212 recognizes that PlayListttO contains two PlayltemO's that are Playltem#0 and Playltemttl. Thereafter, the player control module 212 references<br>
Clip_Information_file_name's of the first Playltem#0 and the second Playltem#l contained in PlayListttO of the "PLAYLIST.DAT" file shown in Fig. 25 and recognizes that the clip information file (the file name thereof) of the first Playltem#0 contained in PlayList#0 is "00001.CLP" and the clip information file of the second Playltemttl is "00002.CLP."<br>
Likewise, the player control module 212 recognizes that the second PlayListttl contains one PlayltemO (PlayltemttO) because number_of_PlayItems is 1 and that the clip information file of Playltem#0 is "00003.CLP" because of Clip_Information_file_name of Playltem#0.<br>
Thereafter, the flow advances from step S105 to step S106. At step S106, the player control module 212 reads clip information files recognized at step S105, namely three clip information files "00001.CLP," "00002.CLP," and "00003.CLP" from the "CLIP" directory under the "VIDEO" directory of the disc 101.<br><br>
A clip information file of Playltem of PlayListO that is needed to be read at step S106 is only a clip information of Playltem of PlayListO that is first reproduced. According to this embodiment, however, as described above, all clip information files of Playltem() of PlayListO are pre-read.<br>
After step S106, the flow advances to step S107. At step S107, the player control module 212 determines whether clip information files recognized at step S105 have been successfully read.  In addition, the player control module 212 determines (checks) whether clip stream files corresponding to the clip information files are present on the disc 101.  In other words, at step S107, the player control module 212 determines whether the clip information files "00001.CLP," "00002.CLP," and "00003.CLP" have been successfully read and the clip stream files "00001.PS," "00002.PS," and "00003.PS" corresponding to the clip information files "00001.CLP," "00002.CLP," and "00003.CLP" are present in the "STREAM" directory under the "VIDEO" directory of the disc 101.<br>
When the determined result at step S107 represents that the clip information files recognized at step S105 have not been successfully read or that the clip stream files corresponding to the clip information files are not present on the disc 101, namely clip information files and clip stream files<br><br>
corresponding to the "PLAYLIST.DAT" file have not been recorded on the disc 101, the video content reproduction program 210 determines that the disc 101 is not correct. Thereafter, the flow returns to step S102. At step S102, the video content reproduction program 210 performs the foregoing error process and completes the pre-reproduction process.<br>
On the other hand, when the determined result at step S107 represents that clip information files recognized at step S105 have been successfully read and that the clip stream files corresponding to the clip information files are present on the disc 101, the player control module 212 completes the initialization process. Thereafter, the flow advances to step S108.<br>
At step S108, the script control module 211 interprets and execute the "SCRIPT.DAT" file.<br>
When the script control module 211 executes the "SCRIPT.DAT" file, assuming that the player control module 212 has caused the first PlayListO (PlayListttO) to be reproduced, a reproduction process shown in Fig. 30 is performed. [Reproduction Process]<br>
Fig. 30 is a flow chart of the reproduction process that the video content reproduction program 210 performs. [Reproduction Preparation Process]<br>
At steps S121 and S122, the player control<br><br>
module 212 performs a reproduction preparation process for PlayListO that the script control module 211 has caused to be reproduced, namely the first PlayListO (PlayListttO).<br>
In other words, at step S121, the player control module 212 checks IN_time (Fig. 6) of the first PlayltemttO contained in the first PlayListttO. Thereafter, the flow advances to step S122. At step S122, the player control module 212 checks the reproduction start position corresponding to IN_time of Playltem#0 of the clip stream file "00001.CLP" reproduced by the first Playltem#0 contained in the first PlayListttO.<br>
When IN_time (Fig. 6) of Playltem() represents the beginning of a clip stream file, a program stream is read from the beginning of the clip stream file. However, when IN_time represents other than the beginning of a clip stream file, the player control module 211 needs to search (check) for the position corresponding to IN_time and read the clip stream file from the position.<br>
Specifically, in Fig. 25, IN_time of the first Playltem#0 contained in the first PlayList#0 is 180,090. The player control module 212 searches EP_map(), shown in Fig. 27, of the clip stream file "00001.CLP" reproduced by the first Playltem#0 contained in the first PlayList#0, for the reproduction<br><br>
start position where IN_time of Playltem#0 is 180,090.<br>
In other words, the player control module 212 searches for the maximum PTS_EP_start that satisfies PTS_EP_start 
In this case, as described above, IN_time is 180,090.  In addition, in EP_map() shown in Fig. 27 of the clip stream file "00001.CLP" reproduced by the first Playltem#0 contained in the first PlayListtO, the maximum value of PTS_EP_start that satisfies PTS_EP_start ^ IN_time is 180,090. Thus, the player control module 212 searches EP_map() shown in Fig. 27 for PTS_EP_start that is 180,090.<br>
In addition, the player control module 212 reads 305 (sectors) searched for RPN_EP_start and decides a position represented by RPN_EP_start in the clip stream file "00001.CLP" as the reproducing start position.<br>
After the player control module 212 has decided the reproduction start position, the flow advances from S122 to step S123. At step S123, the player control module 212 controls the graphics process module 219 to display a time code. The graphics process module 219 generates a time code (video data<br><br>
thereof) under the control of the player control module 212 and outputs the time code to the video output module 220. Thus, the time code is displayed.<br>
The time code displayed at step S123 is for example a value of which the beginning of PlayListO is converted into 00:00:00 (hour: minute: second).  In addition to or instead of the time code, a chapter number and an index number may be displayed. [Analysis Process of PlayListMark()]<br>
After the time code has been displayed at step S123, the flow advances to step S124. At step S124, the player control module 212 performs an analysis process that analyzes PlayListO that the script control module 211 has caused to be reproduced, namely PlayListMark() (Fig. 7) described in the first PlayListO (PlayList#0) .<br>
Specifically, in the upper table shown in Fig. 28, number_of_PlayList_marks of PlayListMark() of the first PlayList#0 of the "PLAYLIST.DAT" file that has been pre-read is 7. Thus, the player control module 212 recognizes that the number of MarkO's contained in PlayListttO is 7.<br>
In addition, the player control module 212 analyzes seven MarkO's of the upper table shown in Fig. 28 and recognizes that four MarkO's of the first to fourth Mark()'s of seven Mark()'s belong to the first PlayltemO (PlayltemttO) of PlayListttO.<br><br>
Thereafter, the player control module 212 obtains mark_time_stampfs in four Mark()'s that belong to the first Playltem#0 of PlayList#0 and supplies them as a four-element matrix to the decode control module 214. Thus, four times {180,090}, {5,580,090}, {10,980,090}, and {16,380,090} as mark_time_stamp's of four Mark()'s of the first to fourth Mark()'s of the seven Mark()'s in the upper table shown in Fig. 28 are sent from the player control module 212 to the decode control module 214. At this point, an attribute of "mark process" of these times is sent from the player control module 212 to the decode control module 214. When the time counted by the time count portion 214A matches a time having an attribute of "mark process," the decode control module 214 sends a corresponding message, the time matched with the time having an attribute of "mark process," and an attribute of "mark process" to the player control module 212. [Decision Process of Elementary Stream to be Reproduced]<br>
Thereafter/ the flow advances from step S124 to step S125. At step S125, the player control module 212 decides an elementary stream to be reproduced.<br>
In other words, in the clip information file "00001.CLP," shown in Fig. 26A and Fig. 26B, described in Clip_Information_file_name of the first Playltem#0 (Fig. 25) of the first PlayList#0 as PlayListO that<br><br>
the script control module 211 has caused to be reproduced, number_of_strearns is 4. Thus, the player control module 212 recognizes that four elementary streams have been multiplexed with the corresponding clip stream file "00001.PS." In addition, the player control module 212 checks stream_id and private_stream_id of Staticlnfo(} of the clip information file "00001.CLP", shown in Fig. 26A and Fig. 26B, of the four elementary streams and recognizes that the four elementary streams are one video stream, one ATRAC audio stream, and two subtitle streams.  In other words, the player control module 212 recognizes the number of elementary streams having individual attributes multiplexed with the clip stream file "00001.PS."<br>
Information about the number of elementary streams having individual attributes multiplexed with a clip stream file is used to change one elementary stream to another elementary stream to be reproduced (from one audio mode to another audio mode or from one subtitle mode to another subtitle mode). When a clip stream file does not contain a subtitle stream file, namely, a content does not include subtitle data, it is determined whether there is a subtitle stream with the information about the number of elementary streams having an attribute of "subtitle stream."<br>
The player control module 212 selects and<br><br>
decides an elementary stream to be reproduced corresponding to the check result of Staticlnfo().  In this case, four elementary streams multiplexed with the clip stream file "00001.PS" contain one elementary stream having an attribute of "video stream" and one elementary stream having an attribute of "audio stream." Thus, the elementary stream having an attribute of "video stream" and the elementary stream having an attribute of "audio stream" (ATRAC audio stream) are individually decided as elementary streams to be reproduced.<br>
On the other hand, four elementary streams multiplexed with the clip stream file "00001.PS" contain two elementary streams having an attribute of "subtitle stream." Thus, one of these two subtitle streams is selected and decided.  In this example, a subtitle stream that first appears in the two subtitle streams in the clip information file "00001.CLP" is selected.<br>
When the attributes and the number of elementary streams multiplexed with the clip stream file "00001.PS" are recognized, four elementary streams need to be identified. The player control module 212 identifies the four elementary streams multiplexed with the clip stream file "00001.PS" with stream_id and private_stream_id.<br>
In other words, the player control module 212<br><br>
identifies an elementary stream having an attribute of "video stream" from the four elementary streams multiplexed with the clip stream file "00001.PS" with stream_id that is OxEO as described in the clip information file "00001.CLP" shown in Fig. 26A and Fig. 26B.<br>
In addition, the player control module 212 identifies an ATRAC audio stream, which is an elementary stream having an attribute of "audio stream", from the four elementary streams multiplexed with the clip stream file "00001.PS" with stream_id that is OxBD and private_stream_id that is 0x00 as described in the clip information file "00001.CLP" shown in Fig. 26A and Fig. 26B.<br>
In addition, the player control module 212 identifies two subtitle streams, which are elementary streams having an attribute of "subtitle stream," from the four elementary streams multiplexed with the clip stream file "00001.PS" with stream_id that is OxBD and private_stream_id that is 0x80 and with stream_id that is OxBD and private_stream_id that is 0x81.<br>
As described above, an elementary stream multiplexed with a clip stream file can be identified by stream_id and private_stream_id described as meta data of a clip information file corresponding to the clip stream file.<br>
A combination of stream id and<br><br>
private_stream_id is a mechanism provided to extend the multiplexing of the MPEG2-System. When a combination of stream_id and private_stream_id is used as meta data that are a database, an elementary stream can be securely identified.  In addition, when private_stream_id is extended for increases of the number and types of corresponding elementary streams, the current mechanism can be used without any change. Thus, a combination of stream_id and private_stream_id has high extensibility.<br>
In other words, for example the blu-ray disc (BD) standard uses a packet ID (PID) of a transport stream of the MPEG2 standard to identify data. Thus, the BD standard is restricted by the MPEG2 standard. On the other hand, the DVD-Video standard defines sub_stream_id that is similar to private_stream_id. However, sub_stream_id cannot be described in a database to identify a stream. sub_stream_id is described in a fixed region for information of only eight to 32 streams (see VI4-49, Table 4.2.1-2 (VTS_AST_ATRT) and VI4-52, Table 4.2.1-3 (VTS_SPST_ATRT)).  Thus, sub_stream_id does not have high extensibility.<br>
On the other hand, a combination of stream_id and private_stream_id can be described with meta data. For example, clip information files ClipO shown in Fig. 10 can describe a combination of stream_id and<br><br>
private_stream_id corresponding to a value represented by number_of_streams. Thus, elementary streams multiplexed with a clip stream file can be identified by a combination of stream_id and private_stream_id as meta data described in the clip information file ClipO regardless of the number of elementary streams (in the range represented by number_of_strearns).<br>
According to this embodiment, a combination of stream_id and private_stream_id is used to identify an elementary stream multiplexed with a clip stream file corresponding to a clip information file shown in Fig. 10.  In addition, this combination can be used to identify an elementary stream that correlates Mark() as a combination of entry_ES_stream_id and entry_ES_private_stream_id of PlayListMark() shown in Fig. 7.  In addition, a combination of stream_id and private_stream_id is used to identify an elementary stream that describes information of a decode startable point in EP_map() shown in Fig. 14. [Output Attribute Control Process]<br>
Thereafter, the flow advances from step S125 to step S126. At step 5126, the player control module 212 performs an output attribute control process for an elementary stream decided at step S125 as that to be reproduced at step S125.<br>
Specifically, the player control module 212 checks number of Dynamiclnfo (Fig. 10), which<br><br>
represents the number of Dynamiclnfo()'s (Fig. 13), which describe output attributes of a video stream, an ATRAC audio stream, and an subtitle stream decided at step S125 as those to be reproduced.<br>
In this case, a video stream, an ATRAC audio stream, and a subtitle stream to be reproduced are elementary streams multiplexed with the clip stream file "00001.PS".  In the clip information file "00001.CLP" shown in Fig. 26A and Fig. 26B, number_of_Dynamic!nfo's are all 0. When number_of_Dynamic!nfo's are all 0, the player control module 212 does not perform the output attribute control process for output attributes of elementary streams to be reproduced.<br>
When number_of_Dynamic!nfo of elementary streams to be reproduced is not 0, the output attribute control process for the elementary streams is performed. The output attribute control process will be described later. [Reproduction Start Preparation Process]<br>
After step S126, the flow advances to step S127. At step S127, the player control module 212 performs the reproduction start preparation process for elementary streams to be reproduced.<br>
In other words, the player control module 212 supplies the file name of the clip stream file "00001.PS" with which an elementary stream to be<br><br>
reproduced has been multiplexed and RPN_EP_start (= 305) described in EP_map() as the reproduction start position decided at step 5122 to the content data supply module 213.<br>
In addition, the player control module 212 initializes the buffer control module 215 before the program stream stored in the clip stream file "00001.PS" with which the elementary stream to be reproduced has been multiplexed is supplied to the buffer control module 215.<br>
Specifically, the buffer control module 215 (Fig. 3) sets the same value to the data start pointer stored in the data start pointer storage portion 231, the data write pointer stored in the data write pointer storage portion 232, the video read pointer stored in the video read pointer storage portion 241, the audio read pointer stored in the audio read pointer storage portion 251, and the subtitle read pointer stored in the subtitle read pointer storage portion 262.<br>
Thus, the data start pointer stored in the data start pointer storage portion 231 and the data write pointer stored in the data write pointer storage portion 232 hold the same position of the buffer 215A of the buffer control module 215. This represents that no valid data have been stored in the buffer 215A.<br>
In addition, the player control module 212 supplies stream_id and if necessary private_stream_id<br><br>
as identification information for an elementary stream to be reproduced to the buffer control module 215.<br>
In other words, as described above, a video stream having an attribute of "video stream" in elementary streams to be reproduced is identified by stream_id that is OxEO. An ATRAC audio stream having an attribute of "audio stream" is identified by stream_id that is OxBD and private_stream_id that is 0x00. A subtitle stream having an attribute of "subtitle stream" is identified by stream_id that is OxBD and private_stream_id that is 0x80. The player control module 212 supplies these stream_id's and private_stream_id's to the buffer control module 215.<br>
In the buffer control module 215 (Fig. 3), the video read function portion 233 stores stream_id that is OxEO for a video stream, received from the player control module 212, to the stream_id register 242.  In addition, the audio read function portion 234 stores stream_id that is OxBD and private_stream_id that is 0x00, received from the player control module 212, to the stream_id register 252 and the private_stream_id register 253, respectively.  In addition, the subtitle read function portion 235 stores stream_id that is OxBD and private_stream_id that is 0x80, received from the player control module 212, to the stream_id register 263 and the private_stream_id register 264, respectively.<br><br>
The player control module 212 stores stream_id and private_stream_id for an elementary stream to be reproduced, supplied to the buffer control module 215, for a later process. The player control module 212 uses stream_id and private_stream_id when a stream change request message takes place or a stream that is being reproduced in a mark process, that will be described later, is identified.<br>
To initialize the buffer control module 215 (Fig. 3), the player control module 212 sets the subtitle read function flag having a value corresponding to the clip stream file multiplexed with an elementary stream to be reproduced to the subtitle read function flag storage portion 261.<br>
In other words, in this case, since the clip stream file "00001.PS" with which elementary streams to be reproduced have been multiplexed contains a subtitle stream, the subtitle read function flag whose value is 1 is set to the subtitle read function flag storage portion 261 to activate the subtitle read function portion 235. When a clip stream file with which an elementary stream to be reproduced has not been multiplexed does not contain a subtitle stream, the subtitle read function flag whose value is 0 is set to the subtitle read function flag storage portion 261. In this case, the subtitle read function portion 235 is not activated (the subtitle read function portion 235<br><br>
does not perform any process).<br>
In addition, the player control module 212 supplies IN_time that is 180,090 and OUT_time that is 27,180,090, of the first PlayltemttO (Fig. 25) contained in the first PlayList#0 that the script control module 211 has caused the player control module 212 to reproduce to the decode control module 214. The decode control module 214 uses IN_time to start decoding a clip reproduced by Playltem() and OUT_time to stop decoding the clip and to control a Playltem change process, that will be described later.<br>
The player control module 212 initializes a subtitle stream display mode in which the graphics process module 219 displays a subtitle stream.  In other words, the player control module 212 controls the graphics process module 219 to display a subtitle stream in a default display mode. [Start Reading Data]<br>
Thereafter, the flow advances from step S127 to step S128. The player control module 212 controls the content data supply module 213 to read a clip stream file that contains a program stream with which an elementary stream to be reproduced has been multiplexed using the function of the operating system 201.  In other words, the content data supply module 213 designates the clip stream file "00001.PS" of the "STREAM" directory under the "VIDEO" directory of the<br><br>
disc 101 (Fig. 4), designates sector 305, which is the reproduction start position, which has been decided at step S122, and causes the operating system 201 to read the file. The content data supply module 213 causes the operating system 201 to supply data that have been read from the disc 101 to the buffer control module 215.<br>
Thus, the program stream of the clip stream file "00001.PS" is read from the disc 101. The program stream is supplied to the buffer control module 215.<br>
The buffer control module 215 (Fig. 3) writes the program stream that has been read from the disc 101 to the position represented by the data write pointer of the data write pointer storage portion 232 of the buffer 215A and increments the data write pointer by the size of the write data.<br>
Unless otherwise specified, when the buffer 215A of the buffer control module 215 has a free space, the content data supply module 213 reads data from the disc 101, supplies and stores the data to the buffer 215A of the buffer control module 215. Thus, the buffer 215A always stores sufficient amount of data. [Start of Controlling Decoder]<br>
When data are read from the disc 101 and the data are stored to the buffer 215A of the buffer control module 215, the flow advances from step S128 to step S129. At step S129, the decode control module 214<br><br>
controls the video decoder control module 216, the audio decoder control module 217, and the subtitle decoder control module 218 to start reading data from the buffer 215A as a pre-decode operation.<br>
Thus, the video decoder control module 216 requests the video read function portion 233 of the buffer control module 215 (Fig. 3) to send data. The video decoder control module 216 obtains one video access unit stored in the buffer 215A, the PTS and DTS (sometimes referred to as time stamps) added to the video access unit, pic_struct_copy, au_ref_flag, and AU_length that are information (sometimes referred to as additional information) described in PES_packet() of private_stream_2 immediately preceded by a decode startable point, and so forth from the buffer control module 215 corresponding to the request. The time stamps are supplied from the video decoder control module 216 to the decode control module 214 whenever the video decoder control module 216 obtains a video access unit.<br>
On the other hand, the audio decoder control module 217 requests the audio read function portion 234 of the buffer control module 215 (Fig. 3) to send data. The audio decoder control module 217 obtains one (ATRAC) audio access unit stored in the buffer 215A and the time stamps (PTS and DTS) added to the audio access unit from the buffer control module 215 corresponding<br><br>
to the request. The time stamps are supplied from the audio decoder control module 217 to the decode control module 214 whenever the audio decoder control module 217 obtains an audio access unit.<br>
In addition, the subtitle decoder control module 218 requests the subtitle read function portion 235 of the buffer control module 215 (Fig. 3) to send data. The subtitle decoder control module 218 obtains one subtitle access unit stored in the buffer 215A and the time stamps added to the subtitle access unit from the buffer control module 215 corresponding to the request. The time stamps are supplied from the subtitle decoder control module 218 to the decode control module 214 whenever the subtitle decoder control module 218 obtains a subtitle access unit. When an elementary stream to be reproduced does not contain a subtitle stream or the buffer 215A does not store a subtitle access unit, data are not supplied from the buffer control module 215 to the subtitle decoder control module 218.<br>
Whenever the video decoder control module 216, the audio decoder control module 217, and the subtitle decoder control module 218 request the buffer control module 215 to send data, they send the results to the decode control module 214.<br>
Details of data that are read from the buffer 215A when the buffer control module 215 sends the data<br><br>
to the video decoder control module 216, the audio decoder control module 217, and the subtitle decoder control module 218 will be described later. [Start of Decoding Data]<br>
When the video decoder control module 216, the audio decoder control module 217, and the subtitle decoder control module 218 start reading data from the buffer 215A of the buffer control module 215, the flow advances from step S129 to step S130. At step S130, these modules start decoding the data that have been read.<br>
In other words, the decode control module 214 causes the video decoder control module 216, the audio decoder control module 217, and the subtitle decoder control module 218 to start decoding corresponding to IN_time, which is 180,090, of the first Playltem#0 contained in PlayList#0, supplied from the player control module 212 at step S127 and corresponding to the time stamps supplied from the video decoder control module 216, the audio decoder control module 217, and the subtitle decoder control module 218 at step S129 or if necessary at changed timing so that data that are decoded are securely synchronized.<br>
A method for starting decoding data at changed timing so that the data are securely synchronized is described in for example Japanese Patent No. 3496725.  In short, the minimum value of<br><br>
time stamps supplied from the video decoder control module 216, the audio decoder control module 217, and the subtitle decoder control module 218 is set as an initial value of the time count portion 214A. The time count portion 214A starts counting a time from this set time. When the time counted by the time count portion 214A matches a time stamp, the decode control module 214 causes these modules to start decoding data.<br>
The video decoder control module 216 receives a decode start command from the decode control module 214, supplies one video access unit obtained from the video read function portion 233 of the buffer control module 215 (Fig. 3) to the video decoder 116 (Fig. 1), and causes the video decoder 116 to decode the video access unit.  In addition, the video decoder control module 216 supplies video data decoded by the video decoder 116 to the graphics process module 219.<br>
Thereafter, the video decoder control module 216 causes the video decoder 116 to successively decode video access units obtained from the video read function portion 233 of the buffer control module 215 one at a time and supplies the decoded video access unit as video data to the graphics process module 219.<br>
The audio decoder control module 217 receives a decode start command from the decode control module 214, supplies one audio access unit obtained from the audio read function portion 234 of the buffer control<br><br>
module 215 (Fig. 3) to the audio decoder 117 (Fig. 1), and causes the audio decoder 117 to decode the audio access unit. The audio decoder control module 217 supplies audio data decoded by the audio decoder 117 to the audio output module 221.<br>
Thereafter, the audio decoder control module 217 causes the audio decoder 117 to successively decode audio access units obtained from the audio read function portion 234 of the buffer control module 215 one at a time and supplies the decoded audio access unit as audio data to the audio output module 221.<br>
In addition, the subtitle decoder control module 218 receives a decode start command from the decode control module 214, causes the internal subtitle decode software to .decode one subtitle access unit obtained from the subtitle read function portion 235 of the buffer control module 215 (Fig. 3) according to the command, and supplies the decoded subtitle access unit as subtitle data (image data of a subtitle) to the graphics process module 219.<br>
Thereafter, the subtitle decoder control module 218 causes the internal decode software to successively decode subtitle access units obtained from the subtitle read function portion 235 of the buffer control module 215 one at a time and supplies the decoded subtitle access unit as subtitle data to the graphics process module 219.<br><br>
[Graphics Process]<br>
Thereafter, the flow advances from step S130<br>
to step S131. At step S131, the graphics process module 219 performs a graphics process for video data supplied from the video decoder control module 216 and if necessary for subtitle data supplied from the subtitle decoder control module 218.<br>
In other words, the graphics process module 219 performs a subtitle process that for example enlarges or reduces subtitle data supplied from the subtitle decoder control module 218 corresponding to a display mode command received from the player control module 212. When the graphics process module 219 has not received a display mode command from the player control module 212 or there is a default display mode, the graphics process module 219 stores subtitle data received from the subtitle decoder control module 218. In addition, the graphics process module 219 adds video data received from the video decoder control module 216 and subtitle data received from the subtitle decoder control module 218 or subtitle data that have been processed, obtains output video data with which subtitle data have been overlaid, and supplies the overlaid video data to the video output module 220.<br>
When the graphics process module 219 receives an information display command for a menu, a message, a time code, a chapter number, or an index number from<br><br>
the script control module 211 or the player control module 212, the graphics process module 219 generates the information, overlays it with output video data, and supplies the overlaid data to the video output module 220. [Output Process]<br>
After step S131, the flow advances to step S132. At step S132, the video output module 220 successively stores output video data supplied from the graphics process module 219 to the FIFO 220A and outputs video data stored in the FIFO 220A at a predetermined output rate.<br>
As long as the FIFO 220A has a sufficient storage capacity (free space), the video output module 220 receives output video data from the graphics process module 219. When the FIFO 220A does not have a sufficient storage capacity, the video output module 220 causes the graphics process module 219 to stop receiving the output video data. Thus, the graphics process module stops receiving the output data.  In addition, the video output module 220 causes the video decoder control module 216 and the subtitle decoder control module 218 to stop their processes. Thus, the video decoder control module 216 and the subtitle decoder control module 218 stop their processes.<br>
After the video output module 220 has caused the graphics process module 219 to stop receiving<br><br>
output video data and the FIFO 220A has output video data, when the FIFO 220A has a sufficient storage capacity, the video output module 220 causes the graphics process module 219 to receive output video data. Like output video data, the graphics process module 219 causes the video decoder control module 216 and the graphics process module 219 to stop receiving data. Thus, the graphics process module 219, the video decoder control module 216, and the subtitle decoder control module 218 resume the stopped processes.<br>
On the other hand, the audio output module 221 also causes the FIFO 221A to successively store audio data supplied from the audio decoder control module 217 at step S130 and to output audio data at a predetermined output rate (sampling frequency).<br>
As long as the FIFO 221A has a sufficient storage capacity (blank space), the audio output module 221 receives audio data from the audio decoder control module 217. However, when the FIFO 221A does not have a sufficient storage capacity, the audio output module 221 causes the audio decoder control module 217 to stop receiving audio data. Thus, the audio decoder control module 217 stops its process.<br>
After the audio output module 221 has caused the audio decoder control module 217 to stop receiving audio data and the FIFO 221A has output audio data, when the FIFO 221A has a sufficient storage capacity,<br><br>
the audio output module 221 causes the audio decoder control module 217 to receive audio data. Thus, the audio decoder control module 217 resumes the stopped process.<br>
In the foregoing manner, as the video output module 220 and the audio output module 221 output data, elementary streams are decoded.<br>
The disc device shown in Fig. 1 reproduces data from the disc 101 corresponding to the flow charts shown in Fig. 29 and Fig. 30. Next, other processes or operations of the disc device that performs while it is reproducing data from the disc 101 will be described. [Changing Playltem's]<br>
As described in Fig. 29 and Fig. 30, the first PlayltemttO of the first PlayList#0 shown in Fig. 25 is reproduced. Corresponding to PlayList#0, after the first PlayltemttO is reproduced, the second Playltemttl is reproduced.  In other words, a Playltem change process that changes Playltem's from PlayltemttO to Playltem#l is performed.<br>
Next, with reference to a flow chart shown in Fig. 31, the Playltem change process will be described.<br>
As described in Fig. 29 and Fig. 30, after the first Playltem#0 (a clip thereof) of PlayListttO shown in Fig. 25 is reproduced, while the first PlayltemttO is being reproduced, the decode control module 214 (Fig. 2A and Fig. 2B) checks time that a<br><br>
time count portion 214A is counting. [End of Reproduction of Playltem#0]<br>
When the time that time count portion 214A has counted became 27,180,090 (Fig. 25) that is the same as OUT_time of the first PlayltemttO supplied from the player control module 212 at step S127 shown in Fig. 30, the decode control module 214 performs a decode stop control to stop reproducing Playltem#0 at step S151.<br>
In other words, the decode control module 214 operates the video decoder control module 216, the audio decoder control module 217, and the subtitle decoder control module 218 to stop their decode operations. The decode control module 214 controls the video output module 220 to successively output video data.<br>
In addition, the decode control module 214 sends a message that represents that the first Playltem#0 has been reproduced to the player control module 212. [Start of Reproduction of Playltem#l]<br>
As described above, the player control module 212 has recognized that the first PlayListftO contains the first Playltem#0 and the second Playltemttl at step S105 shown in Fig. 29. When the decode control module 214 has informed the player control module 212 that the first Playltem#0 had been reproduced, the flow advances<br><br>
from step S151 to step S152. At step S152, in the same manner as the first PlayltemttO, the player control module 212 starts reproducing the second Playltemttl.<br>
Like step S122 shown in Fig. 30, the player control module 212 decides one of RPN_EP_start's described in EP_map() as the reproduction start position of the second Playltemttl.<br>
In addition, the player control module 212 recognizes Mark()'s that belong to the second Playltemttl described at step S124 shown in Fig. 30 and the number of elementary streams having attributes multiplexed with the clip stream file "00002.PS" reproduced by Playltemttl described at step S125 Fig. 30 and decides an elementary stream to be reproduced.<br>
The player control module 212 performs the same process as that at step S127 shown in Fig. 30.<br>
In other words, the player control module 212 supplies RPN_EP_start of EP_map() decided as the reproduction start position and the file name of a clip stream file multiplexed with an elementary stream to be reproduced, namely the file name of the clip stream file "00002.PS" corresponding to "00002.CLP" described in Clip_Information_file_name of the second Playltemttl (Fig. 25) to the content data supply module 213.<br>
In addition, before a program stream stored in the clip stream file "00002.PS" multiplexed with an elementary stream to be reproduced is supplied to the<br><br>
buffer control module 215, the player control module 212 initializes the buffer control module 215.<br>
In other words, the buffer control module 215 (Fig. 3) sets the same value to the data start pointer stored in the data start pointer storage portion 231, the data write pointer stored in the data write pointer storage portion 232, the video read pointer stored in the video read pointer storage portion 241, the audio read pointer stored in the audio read pointer storage portion 251, and the subtitle read pointer stored in the subtitle read pointer storage portion 262.<br>
In addition, the player control module 212 supplies stream_id and if necessary private_stream_id as identification information that identifies an elementary stream to be reproduced to the buffer control module 215.<br>
The video read function portion 233 of the buffer control module 215 (Fig. 3) receives stream_id of a video stream of elementary streams to be reproduced from the player control module 212 and stores it to the stream_id register 242.  In addition, the audio read function portion 234 receives stream_id and private_stream_id of an audio stream of elementary streams to be reproduced from the player control module 212 and stores them to the stream_id register 252 and the private_stream_id register 253.<br>
Since the clip stream file "00002.PS"<br><br>
multiplexed with an elementary stream to be reproduced contains a subtitle stream, stream_id and private_stream_id of the subtitle stream of elementary streams to be reproduced are supplied from the player control module 212 to the subtitle read function portion 235. The subtitle read function portion 235 stores stream_id and private_stream_id to the stream_id register 263 and the private_stream_id register 264, respectively.<br>
The player control module 212 sets a subtitle read function flag that has a value corresponding to a clip stream file multiplexed with an elementary stream to be reproduced to the subtitle read function flag storage portion 261 to initialize the buffer control module 215 (Fig. 3).<br>
In this case, since the clip stream file "00002.PS" multiplexed with elementary streams to be reproduced contains a subtitle stream, the subtitle read function flag having a value of 1 is set to the subtitle read function flag storage portion 261 to activate the subtitle read function portion 235.<br>
The player control module 212 supplies 90,000 as IN_time and 27,090,000 as OUT_time of the second Playltemttl to be reproduced (Fig. 25) to the decode control module 214.<br>
In addition, the player control module 212 initializes a subtitle stream display mode command for<br><br>
the graphics process module 219.  In other words, the player control module 212 controls the graphics process module 219 to display subtitle data in the default display mode.<br>
When configurable_flag (Fig. 12) of a<br>
subtitle stream to be reproduced is 1, which represents that the display mode is permitted to be changed, the subtitle stream display mode command that the player control module 212 sends to the graphics process module 219 may be the current display mode command.<br>
In the same manner as the first Playltem#0, the second Playltem#l is reproduced. While the second Playltemttl is being reproduced, the decode control module 214 monitors the time that the time count portion 214A is counting. When the time that the time count portion 214A has counted became 27,090,000 (Fig. 25) that is the same as OUT_time of the second Playltem#l supplied from the player control module 212 at step S152 (Fig. 31), the decode control module 214 performs the same decode stop control as that at step S151 to stop reproducing Playltem#l. [Display of Time Code]<br>
Next, as described above, at step S123 shown in Fig. 30, a time code is displayed. The time code is successively updated.<br>
Next, with reference to a flow chart shown in Fig. 32, a time code display process will be described.<br><br>
When the time count portion 214A of the decode control module 214 (Fig. 2A and Fig. 2B) has counted one second, the flow advances to step S171. At step S171, the decode control module 214 supplies a message that represents that one second has elapsed and the current time that the time count portion 214A has counted to the player control module 212. Thereafter, the flow advances to step S172. At step S172, the player control module 212 receives the message and the current time from the decode control module 214 and converts the current time into a time code. Thereafter, the flow advances to step S173.<br>
At step S173, the player control module 212 controls the graphics process module 219 to display the time code obtained at step S172. Thereafter, the flow returns to step S171.<br>
Thus, the time code is updated at intervals of one second. The update intervals of the time code are not limited to one second. [Changing Streams]<br>
The clip stream file "00001.PS" reproduced by the first Playltem#0, which composes the first PlayListttO described in Fig. 25, and the clip stream file "00002.PS" reproduced by the second Playltemttl are multiplexed with two subtitle streams as described in Fig. 26A and Fig. 26B.<br>
When a plurality of elementary streams having<br><br>
the same attribute are multiplexed with a clip stream file, elementary streams to be reproduced can be changed from one elementary stream to another elementary stream.<br>
Next, with reference to a flow chart shown in Fig. 33, a stream change process will be described.<br>
When a stream change command is described as a script program in for example the "SCRIPT.DAT" file (Fig. 4) and the script control module 211 executes the script program or the user operates the remote controller to change streams, a stream change command is supplied to the player control module 212.<br>
When the script control module 211 executes a script program that describes the stream change request, the script control module 211 supplies a stream change request message to the player control module 212. When the user inputs a stream change command with the remote controller, the input interface 115 receives the stream change command signal from the remote controller and supplies the stream change request message to the player control module 212.<br>
When the subtitle stream change request message, which causes the player control module 212 to change subtitle streams, is supplied to the player control module 212, it checks the number of subtitle streams of elementary streams to be reproduced, which has been recognized at step S125 shown in Fig. 30.<br><br>
When the number of subtitle streams that the player control module 212 has checked is 1 or less, the player control module 212 ignores the subtitle stream change request message. Thus, the player control module 212 does not perform the process from step S192 to step S194.<br>
In contrast, when the number of subtitle streams is two or more, the flow advances to step S192 to S194. At these steps, the player control module 212 changes a subtitle stream that is being reproduced to another subtitle stream.<br>
In other words, at step S192, the player control module 212 identifies a subtitle stream, which is being reproduced, on a clip information file. Specifically, assuming that a subtitle stream whose stream_id is OxBD and private_stream_id is 0x80 and that is multiplexed with the clip stream file "00002.PS" is being reproduced corresponding to the second Playltemttl, which composes the first PlayList#0 described in Fig. 25, the player control module 212 identifies a subtitle stream that is being reproduced as stream#2, which is the third subtitle stream of the clip information file "00002.CLP" shown in Fig. 26A and Fig. 26B, of two subtitle streams multiplexed with the clip stream file "00002.PS" at step S192.<br>
Thereafter, the flow advances to step S193. At step S193, the player control module 212 recognizes<br><br>
(identifies) the next subtitle stream of the clip information file identified at step S192 as a subtitle stream to be reproduced next.  In Fig. 26A and Fig. 26B, the next subtitle stream of the third subtitle stream stream#2 is the fourth subtitle stream stream#3. Thus, at step S193, the player control module 212 recognizes the fourth subtitle stream stream#3 as a subtitle stream to be reproduced next.<br>
When a subtitle stream that is being reproduced is identified as stream#3, which is the fourth subtitle stream in the clip information file "00002.CLP" shown in Fig. 26A and Fig. 26B, of two subtitle streams multiplexed with the clip stream file "00002.PS," the player control module 212 recognizes for example the third subtitle stream stream#2 as a subtitle stream to be reproduced next.<br>
Thereafter, the flow advances to step S194. At step S194, the player control module 212 supplies stream_id and private_stream_id of the subtitle recognized at step S193 as a subtitle stream to be reproduced next to the subtitle read function portion 235 of the buffer control module 215 (Fig. 3) so that the subtitle read function portion 235 reads the next subtitle access unit identified by stream_id and private_stream_id from the buffer 215A.<br>
The subtitle read function portion 235 of the buffer control module 215 (Fig. 3) newly sets stream_id<br><br>
and private_stream_id supplied from the player control module 212 at step S194 to the stream_id register 263 and the private_stream_id register 264, respectively. The subtitle read function portion 235 reads the next subtitle access unit identified by stream_id and private_stream_id newly set to the stream_id register 263 and the private_stream_id register 264, respectively.<br>
In the foregoing manner, a subtitle stream that is being reproduced is changed to another subtitle stream that is reproduced next. [Processes of Buffer Control Module 215]<br>
Next, with reference to Fig. 34 to Fig. 38, processes of the buffer control module 215 (Fig. 3), data write process and data read process to and from the buffer 215A, will be described.<br>
As described in Fig. 3, the buffer control module 215 has five pointers that are used to read and write data from and to the buffer 215A.<br>
In other words, as shown in Fig. 34 and Fig. 35, the buffer control module 215 has the data start pointer stored in the data start pointer storage portion 231, the data write pointer stored in the data write pointer storage portion 232, the video read pointer stored in the video read pointer storage portion 241, the audio read pointer stored in the audio read pointer storage portion 251, and the subtitle read<br><br>
pointer stored in the subtitle read pointer storage portion 262.<br>
In Fig. 34 and Fig. 35, the stream_id<br>
register 242 and the au_information() register 243 of the video read function portion 233 shown in Fig. 3, the stream_id register 252 and the private_stream_id register 253 of the audio read function portion 234, and the subtitle read function flag storage portion 261, the stream_id register 263, and the private_stream_id register 264 of the subtitle read function portion 235 are omitted.<br>
The data start pointer stored in the data start pointer storage portion 231 represents the position of the oldest data (that need to be read and have not been read) stored in the buffer 215A. The data write pointer stored in the data write pointer storage portion 232 represents the write position of data in the buffer 215A. This position is the position to which the newest data are written.<br>
The video read pointer stored in the video read pointer storage portion 241 represents the position of a video stream that is read from the buffer 215A. The audio read pointer stored in the audio read pointer storage portion 251 represents the position of an audio stream read from the buffer 215A. The subtitle read pointer stored in the subtitle read pointer storage portion 262 represents the position of<br><br>
a subtitle stream read from the buffer 215A.<br>
As described in Fig. 3, the data start pointer, the data write pointer, the video read pointer, the audio read pointer, and the subtitle read pointer are moved in the clockwise direction in the buffer 215A.<br>
As shown in Fig. 35, according to this<br>
embodiment, the data start pointer is always updated so that it represents the same position as the oldest data position of the video read pointer, the audio read pointer, and the subtitle read pointer.  In Fig. 35, the audio read pointer represents the position of the oldest data in the video read pointer, the audio read pointer, or the subtitle read pointer. The data start pointer matches the audio read pointer.<br>
In the buffer control module 215, which has the data start pointer, the data write pointer, the video read pointer, the audio read pointer, and the subtitle read pointer, when new data are read from the disc 101 and written to the buffer 2ISA, the data write pointer is updated in the clockwise direction so that the data write pointer represents the position immediately after the newly written data.<br>
When a video stream, an audio stream, or a subtitle stream is read from the buffer 215A, the video read pointer, the audio read pointer, or the subtitle read pointer is updated in the clockwise direction for<br><br>
the amount of data that are read. The amount of data that are read is the sum of video data, audio data, or subtitle data that are actually read and a data portion of another stream intervened in the data that are read and that are omitted when they are read.<br>
When the video read pointer, the audio read pointer, or the subtitle read pointer is updated, the data start pointer is updated so that it represents the position of the oldest data represented by the video read pointer, the audio read pointer, or the subtitle read pointer.<br>
The buffer control module 215 controls the data write operation of the buffer 215A so that the data write pointer does not get ahead of the data start pointer.<br>
Unless the data write pointer gets ahead of the data start pointer, the buffer control module 215 writes data read from the disc 101 to the position of the buffer 215A represented by the data write pointer and updates the data write pointer. On the other hand, if the data write pointer is going to get ahead of the data start pointer, the buffer control module 215 causes the content data supply module 213 to stop reading data from the disc 101 and stops writing data to the buffer 215A. Thus, the buffer 215A can be prevented from overflowing.<br>
As described above, data that are read from<br><br>
the disc 101 are written to the buffer 215A corresponding to the relationship of the positions of the two pointers, the data start pointer and the data write pointer.<br>
On the other hand, the buffer control module 215 controls the data read operation of the buffer 215A so that the video read pointer, the audio read pointer, and the subtitle read pointer, and the data start pointer do not get ahead of the data write pointer.<br>
In other words, unless the video read<br>
pointer, the audio read pointer, or the subtitle read pointer gets ahead of the data write pointer, the buffer control module 215 reads data from the position of the buffer 215A represented by the video read pointer, the audio read pointer, or the subtitle read pointer corresponding to a request received from the video decoder control module 216, the audio decoder control module 217, or the subtitle decoder control module 218 and updates the video read pointer, the audio read pointer, or the subtitle read pointer and if necessary the data start pointer. On the other hand, if the video read pointer, the audio read pointer, or the subtitle read pointer is going to get ahead of the data write pointer, the buffer control module 215 causes the video decoder control module 216, the audio decoder control module 217, or the subtitle decoder control module 218 to stop sending the request or wait<br><br>
until the buffer 215A stores enough data. As a result, the buffer 215A can be prevented from under-flowing.<br>
Thus, the buffer 215A stores data to be supplied to the video decoder control module 216, the audio decoder control module 217, and the subtitle decoder control module 218 in a region (shaded in Fig. 34 and Fig. 35) in the clockwise direction from the position represented by the data start pointer to the position represented by the data write pointer.  In addition, the video read pointer, the audio read pointer, and the subtitle read pointer are present in the region.<br>
In the foregoing case, the data start pointer is updated so that it represents the position of the oldest data represented by the video read pointer, the audio read pointer, and the subtitle read pointer represent. Alternatively, the data start pointer may be updated so that it represents the position of data that are earlier by a predetermined time (for example, one second) than the position of the oldest data.<br>
It can be assumed that the video read pointer and the audio read pointer in the video read pointer, the audio read pointer, and the subtitle read pointer represent the position of the oldest data.<br>
Thus, when the data start pointer is updated so that it represents the position of data that are earlier by for example one second than the position of<br><br>
the oldest data that the video read pointer or the audio read pointer represents, as shown in Fig. 34, earlier data by one second than the oldest data that the video read pointer or the audio read pointer represents can be stored in the buffer 215A.  In Fig. 34, the audio read pointer represents the position of the oldest data, whereas the data start pointer represents the position of data that are earlier by one second than the oldest data.<br>
When the data start pointer is updated so that it represents the position of data that are earlier by one second than the position of the oldest data, the response of the disc device can be improved.<br>
In other words, as shown in Fig. 35, when the data start pointer is updated so that it represents the position of the oldest data that the audio read pointer represents, if a special reproduction command for example a reverse reproduction command is issued, data that have been read from the buffer 215A need to be reread from the disc 101. Thus, after the special reproduction command is issued until the special reproduction operation is performed, it takes a time to some extent.<br>
In contrast, as shown in Fig. 34, when the data start pointer is updated so that it represents the position of data that are earlier by one second than the position of the oldest data that the audio read<br><br>
pointer represents, if a special reproduction command for example a reverse reproduction command is issued and data necessary for starting the special reproduction operation are data earlier by one second than the oldest data and stored in the buffer 2ISA, the special reproduction operation can be quickly started without need to re-read the data from the disc 101.<br>
When the data start pointer is updated so that it represents the position of data that are earlier by one second than the position of the oldest data that the audio read pointer represents, data necessary for starting the special reproduction operation may not be stored in the buffer 215A.  In this case, the data necessary for starting the special reproduction operation are re-read from the disc 101.<br>
Next, the read operations for a video stream, an audio stream, and a subtitle stream from the buffer 215A will be described in detail.<br>
As described at step S127 shown in Fig. 30, when the reproduction operation of a clip stream file is started, the buffer control module 215 initializes the data start pointer, the data write pointer, the video read pointer, the audio read pointer, and the subtitle read pointer so that they represent the same position in the buffer 215A.<br>
When a program stream (MPEG2-system program stream) stored in a clip stream file is read from the<br><br>
disc 101 and supplied to the buffer control module 215, it stores the program stream at the position that the data write pointer of the buffer 215A represents.  In addition, the data write pointer is updated in the clockwise direction.<br>
In addition, the video read function portion 233 of the buffer control module 215 (Fig. 3) parses the program stream stored in the buffer 2ISA, extracts (separates) a video stream (a video access unit) from the program stream stored in the buffer 215A corresponding to a request received from the video decoder control module 216, and supplies the extracted video stream to the video decoder control module 216.<br>
Likewise, the audio read function portion 234 parses a program stream stored in the buffer 215A, extracts an audio stream (an audio access unit) from the program stream stored in the buffer 215A corresponding to a request received from the audio decoder control module 217, and supplies the audio stream to the audio decoder control module 217. The subtitle read function portion 235 parses a program stream stored in the buffer 2ISA, extracts a subtitle stream (a subtitle access unit) from the program stream stored in the buffer 215A corresponding to a request received from the subtitle decoder control module 218, and supplies the subtitle stream to the subtitle decoder control module 218.<br><br>
[Reading Video Stream]<br>
Next, with reference to a flow chart shown in Fig. 36, a video stream read process for the buffer 215 of the video read function portion 233 (Fig. 3) will be described in detail.<br>
At step S211, the video read function portion 233 searches a program stream stored in the buffer 215A for PES_packet() of private_stream_2. As described in Fig. 20, in PES_packet() of private_stream_2, stream_id is 10111111B (== OxBF) . The video read function portion 233 searches for PES_packet() whose stream_id is 10111111B.<br>
Assuming that an elementary stream<br>
multiplexed with a program stream stored in the clip stream file "00001.PS" is an elementary stream to be reproduced, when the program stream is read from the disc 101 and stored in the buffer 215A, sector 305 is decided as the reproduction start position with information about a decode startable point described in EP_map() (Fig. 27) of the clip stream file "00001.PS." At step S128 shown in Fig. 30, sector 305, which is the reproduction start point, is designated.  The video read function portion 233 causes the operating system 201 to read the program stream from the clip stream file "00001.PS."<br>
Information about the decode startable point described in EP map() of the video stream represents<br><br>
the position of PES_packet() of private_stream_2 immediately preceded by the real decode startable point.<br>
Thus, immediately after the program stream stored in the clip stream file "00001.PS" is read from the disc 101 and stored in the buffer 215A, PES_packet() of private_stream_2 is stored at a position represented by the data start pointer and the video read pointer in the buffer 215A.<br>
When the video read function portion 233 has found PES_packet() of private_stream_2 at step S211, the flow advances to step S212. At step S212, the video read function portion 233 extracts video_stream_id from private_stream2_PES_payload() (Fig. 23), which is PES_packet_data_byte of PES_packet() of private_stream_2. At step S127 shown in Fig. 30, the video read function portion 233 determines whether video_stream_id matches stream_id of the video stream to be reproduced, which is stored in the stream_id register 242 (Fig. 3).<br>
When the determined result at step S212 represents that video_stream_id described in private_stream2_PES_payload() does not match stream_id stored in the stream_id register 242, namely PES_packet() of private_stream_2, found at step S211, is not at the decode startable point of the video stream to be reproduced, the flow returns to step S211.<br><br>
At step S211, the video read function portion 233 searches the program stream stored in the buffer 215A for PES_packet() of private_stream_2 and repeats the same process.<br>
In contrast, when the determined result at step S212 represents that video_stream_id described in private_stream2_PES_payload() matches stream_id stored in the stream_id register 242, namely PES_packet() of private_stream_2 found at step S211 is at the decode startable point of the video stream to be reproduced, the flow advances to step S213. At step S213, the video read function portion 233 reads au_information() described in private_stream2_PES_payload() of PES_packet() of private_stream_2 from the buffer 215A and stores au_information() to the au_information() register 243 (Fig. 3). Thereafter, the flow advances to step S214.<br>
At step S214, the video read function portion 233 updates the video read pointer stored in the video read pointer storage portion 231 for the size of PES_packet() of private_stream_2 (that video_stream_id (Fig. 23) matches stream_id stored in the stream_id register 242 (Fig. 3)) found at step S211.<br>
In other words, in a clip stream file, PES_packet() of private_stream_2 is immediately followed by a video stream (PES_packet()) whose stream id matches video stream id. Thus, at step S214,<br><br>
the video read function portion 233 updates the video read pointer so that it represents the position of the decode startable point of the video stream.<br>
Thereafter, the flow advances from S214 to step S215. The video read function portion 233 determines whether the video decoder control module 216 has issued a data request. When the determined result at step S215 represents that the video read function portion 233 has not issued a data request, the flow returns to step S215. At step S215, the video decoder control module 216 repeats the same process.<br>
In contrast, when the determined result at step S215 represents that the video decoder control module 216 has issued a data request, the flow advances to step S216. At step S216, the video read function portion 233 parses the program stream from the position represented by the video read pointer in the buffer 215A, reads data of bytes described in AU__length of au_information() stored in the au_information() register 243, namely one video access unit, from the buffer 215A, supplies the data to the video decoder control module 216, and updates the video read pointer for the size of one video access unit that has been read from the buffer 215A.<br>
In other words, as described in Fig. 24, au_information() describes number_of_access_unit that represents the number of video access units (pictures)<br><br>
contained from PES_packet() of private_stream_2, containing au_information(), to PES_packet() of the next private_stream_2.<br>
In addition, as shown in Fig. 24, au_information() describes pic_struct_copy, au_ref_flag, and AU_length as information about each of video access units represented by number_of_access_unit.<br>
As described in Fig. 24, since each of<br>
AU_length's described in au_information() corresponding to number_of_access_unit represents the size of each of video access units represented by number_of_access_unit from PES_packet() of private_stream_2 to PES_packet() of the next private_stream_2, the video read function portion 233 can extract access units with AU_length's without need to parse the video stream.<br>
In other words, when MPEG2-Video or MPEG4-AVC access units are extracted, it is necessary to know the structure of the video stream and then parse it. However, a program stream stored in a clip stream file recorded on the disc 101 contains PES_packet() of private_stream_2, which describes AU_length that represents the size of a video access unit, and which is immediately followed by at least one decode startable point of the video stream. Thus, the video read function portion 233 can read video access units (a video stream as video access units) from the buffer<br><br>
215A and supply the video access units to the video decoder control module 216 corresponding to AU_length described in PES_packet() of private_stream_2 without need to parse the video stream.<br>
At step S216, when the video read function portion 233 supplies video access units to the video decoder control module 216, the video read function portion 233 also supplies pic_struct_copy, au_ref_flag, and AU_length described in au_information() and time stamps (PTS and DTS) added for each of the video access units as information about the video access units to the video decoder control module 216.<br>
After the video read function portion 233 has read one video access unit from the buffer 2ISA and supplied it to the video decoder control module 216, the flow advances to step S217. At step S217, the video read function portion 233 determines whether it has processed access units represented by number_of_access_unit of au_information() (Fig. 24) stored in the au_information() register 243.<br>
When the determined result at step S217<br>
represents that the video read function portion 233 has not yet processed access units represented by number_of_access_unit, namely the video read function portion 233 has not yet read access units represented by number_of_access_unit from the buffer 215A and supplied them to the video decoder control module 216,<br><br>
the flow returns to step S215. At step S215, the video read function portion 233 repeats the same process.<br>
In contrast, when the determined result at step S217 represents that the video read function portion 233 has already processed access units represented by number_of_access__unit, namely the video read function portion 233 has already read access units represented by number_of_access_unit from the buffer 215A and supplied them to the video decoder control module 216, the flow returns to step S211. A step S211, the video read function portion 233 searches for PES_packet() of private_stream_2 and repeats the same process. [Reading Audio Stream]<br>
Next, with reference to a flow chart shown in Fig. 37, an audio stream read process for the buffer 215A of the audio read function portion 234 (Fig. 3) will be described.<br>
At step S230, the audio read function portion 234 determines whether stream_id of an audio stream to be reproduced, which has been stored in the stream_id register 252 (Fig. 3) at step S127 shown in Fig. 30, represents PES_packet() of private_stream_l.<br>
When the determined result at step S230 represents that stream_id stored in the stream_id register 252 does not represent PES_packet() of private stream 1, namely as described in Fig. 20,<br><br>
stream_id stored in the stream_id register 252 is HOxxxxxB assigned to an audio stream that has been encoded corresponding to the MPEG standard, the flow advances to step S231. At step S231, the audio read function portion 234 searches a program stream stored in the buffer 2ISA for a synchronous code that represents the beginning of an audio frame defined in the MPEG Audio. Since the position of the synchronous code is at the beginning of an audio frame, the audio read function portion 234 updates the audio read pointer so that it represents the position of the beginning of an audio frame. Thereafter, the flow advances from step S231 to step S232. At step S232, the audio read function portion 234 searches the program stream stored in the buffer 215A for PES_packet() that matches stream_id stored in the stream_id register 252 corresponding to the position represented by the audio read pointer and obtains PES_packet(). Thereafter, the flow advances to step S233.<br>
At step S233, the audio read function portion 234 updates the audio read pointer stored in the audio read pointer storage portion 251 so that the audio read pointer represents the beginning of<br>
PES_packet_data_byte of PES_packet() (Fig. 16A and Fig. 16B to Fig. ISA and Fig. 18B), which has been found at step S232. Thereafter, the flow advances to step S237.<br><br>
At step 5231, the audio read function portion 234 determines whether the audio decoder control module 217 has issued a data request. When the determined result at step S237 represents that audio decoder control module 217 has not issued a data request, the flow returns to step S237. At step S237, the audio read function portion 234 repeats the same process.<br>
In contrast, when the determined result at step S237 represents that the audio decoder control module 217 has issued a data request, the flow advances to step S238. At step S238, the audio read function portion 234 parses the program stream from the position represented by the audio read pointer in the buffer 2ISA, reads one audio access unit having a predetermined fixed length from the buffer 2ISA, and supplies the audio access unit together with time stamps (PTS and DTS) added to the audio access unit to the audio decoder control module 217.<br>
The audio read function portion 234 updates the audio read pointer for the size of one audio access unit read from the buffer 215A. Thereafter, the flow returns to step S237. At step S237, the audio read function portion 234 repeats the same process.<br>
In contrast, when the determined result at step S230 represents that stream_id stored in the stream_id register 252 represents PES_packet() of private_stream_l, namely stream_id stored in the<br><br>
stream_id register 252 is 10111101B (= OxBD) and represents PES_packet() of private_stream_l as described in Fig. 20, the flow advances to step S234. At step S234, the audio read function portion 234 searches the program stream stored in the buffer 215A for PES_packet() of private_stream_l and obtains PES_packet().  In other words, the audio read function portion 234 searches for PES_packet() whose stream_id is 101111101B and obtains PES_packet().<br>
When the audio read function portion 234 has found PES_packet() of private_stream_l at step S234, the flow advances to step S235. At step S235, the audio read function portion 234 extracts private_stream_id from private_streaml_PES_payload() (Fig. 21), which is PES_packet_data_byte of PES_packet() of private_stream_l and determines whether private_stream_id matches private_stream_id of an audio stream to be reproduced, which has been stored in the private_stream_id register 253 (Fig. 3) at step S127 shown in Fig. 30.<br>
When the determined result at step S235 represents that private_stream_id described in private_streaml_PES_payload() does not match private_stream_id stored in the private_stream_id register 253, namely PES_packet() of private_stream_l found at step S234 is not an audio stream to be reproduced, the flow returns to step S234. At step<br><br>
S234, the audio read function portion 234 searches the program stream stored in the buffer 215A for PES_packet() of private_stream_l. Thereafter, the audio read function portion 234 repeats the same process.<br>
On the other hand, when the determined result at step S235 represents that private_stream_id described in program_stream_PES_payload() matches private_stream_id stored in the private_stream_id register 253, namely PES_packet() of private_stream_l found at step S234 is an audio stream to be reproduced, the flow advances to step S236. At step S236, the audio read function portion 234 reads AU_locator described in private_streaml_PES_payload() (Fig. 21) of PES_packet() of private_stream_l from the buffer 215A, adds the position immediately after AU_locator and the value that AU_locator represents, and obtains the start position of the audio access unit.<br>
In other words, as described in Fig. 21, AU_locator represents the start position of an audio access unit (or a subtitle access unit) stored in private_payload() of private_streaml_PES_payload() based on the position immediately after AU_locator. Thus, by adding the value of AU_locator and the position immediately after AU_locator, the (absolute) start position of the audio access unit can be obtained.<br><br>
At step S236, the audio read function portion 234 updates the audio read pointer stored in the audio read pointer storage portion 251 so that the audio read pointer represents the start position of the audio access unit that has been obtained. Thereafter, the flow advances to step S237.<br>
At step 3237, the audio read function portion 234 determines whether the audio decoder control module 217 has issued a data request. When the determined result at step S237 represents that the audio decoder control module 217 has not issued a data request, the flow returns to step S237. At step S237, the audio read function portion 234 repeats the same process.<br>
In contrast, when the determined result at step S237 represents that the audio decoder control module 217 has issued a data request, the flow advances to step S238. At step S238, the audio read function portion 234 parses the program stream from the position represented by the audio read pointer in the buffer 215A, reads one audio access unit having a predetermined length from the buffer 215A, and supplies the audio access unit together with time stamps added to the audio access unit to the audio decoder control module 217.<br>
The audio read function portion 234 updates the audio read pointer for the size of one audio access unit read from the buffer 215A. Thereafter, the flow<br><br>
returns to step S237. At step S237, the audio read function portion 234 repeats the same process. [Reading Subtitle Stream]<br>
Next, with reference to a flow chart shown in Fig. 38, a subtitle stream read process for the buffer 215A of the subtitle read function portion 235 (Fig. 3) will be described.<br>
At step S251, the subtitle read function portion 235 determines the subtitle read function flag, which has been stored in the video decoder control module 216 at step S127 shown in Fig. 30. When the determined result at step S251 represents that the subtitle read function flag is 0, namely a clip stream file multiplexed with an elementary stream to be reproduced does not contain a subtitle stream and 0 has been set to the subtitle read function flag storage portion 261 at step S127 shown in Fig. 30, the subtitle read function portion 235 does not perform any process.<br>
In contrast, when the determined result at step S251 represents that the subtitle read function flag is 1, namely a clip stream file multiplexed with an elementary stream to be reproduced contains a subtitle stream and 1 has been set to the subtitle read function flag storage portion 261 at step S127 shown in Fig. 30, the flow advances to step S252. At step S252, the subtitle read function portion 235 searches the program stream stored in the buffer 215A for<br><br>
PES_packet() that matches stream_id of the subtitle stream to be reproduced, which has been stored in the stream_id register 263 (Fig. 3).<br>
As described at step S127 shown in Fig. 30, stream_id of the subtitle stream to be reproduced is stored in the stream_id register 263 (Fig. 3). On the other hand, as described in Fig. 20, stream_id of the subtitle stream is 10111101B (= OxBD), which represents PES_packet() of private_stream_l.<br>
Thus, at step S252, the subtitle read<br>
function portion 235 searches the program stream stored in the buffer 215A for PES_packet() of private_stream_l.<br>
When the subtitle read function portion 235 has searched for PES_packet() of private_stream_l and obtained it, the flow advances to step S253. The subtitle read function portion 235 extracts private_stream_id from private_stream_PES_payload() (Fig. 21), which is PES_packet_data_byte of PES_packet() of private_stream__l and determines whether private_stream_id matches private_stream_id of the subtitle stream to be reproduced, which has been stored in the private_stream_id register 264 (Fig. 3) at step S127 shown in Fig. 30.<br>
When the determined result at step S253 represents that private_stream_id described in private stream PES payloadO does not match<br><br>
private_stream_id stored in the private_stream_id register 264, namely PES_packet() of private_stream_l, which has been obtained at step S252, is not the subtitle stream to be reproduced, the flow returns to step 5252. At step S252, the subtitle read function portion 235 searches the program stream stored in the buffer 215A for PES_packet() of another private_stream_l. Thereafter, the subtitle read function portion 235 repeats the same process.<br>
In contrast, when the determined result at step S253 represents that private_stream_id described in private_streaml_PES_payload() matches private_stream_id stored in the private_stream_id register 264, namely PES_packet() of private_stream_l, which has been obtained at step S252, is the subtitle stream to be reproduced, the flow advances to step S254. At step S254, the subtitle read function portion 235 reads AU_locator described in<br>
private_streaml_PES_payload() (Fig. 21) of PES_packet() of private_stream_l from the buffer 215A, adds the position immediately after AU_locator and the value that AU_locator represents, and obtains the start position of the subtitle access unit.<br>
As described in Fig. 21, AU_locator<br>
represents the start position of a subtitle access unit (or an audio access unit) stored in private_payload() of private streaml PES payloadO based on the position<br><br>
immediately after AU_locator. Thus, by adding the value that AU_locator represents and the position immediately after AU_locator, the (absolute) start position of the subtitle access unit can be obtained.<br>
In addition, at step S254, the subtitle read function portion 235 updates the subtitle read pointer stored in the subtitle read pointer storage portion 262 so that the subtitle read pointer represents the start position of the obtained subtitle access unit. Thereafter, the flow advances to step S255.<br>
At step S255, the subtitle read function portion 235 determines whether the subtitle decoder control module 218 has issued a data request. When the determined result at step S255 represents that the subtitle read function portion 235 has not issued a data request, the flow returns to step S255. At step S255, the subtitle read function portion 235 repeats the same process.<br>
In contrast, when the determined result at step S255 represents that the subtitle decoder control module 218 has issued a data request, the flow advances to step S256. At step S256, the subtitle read function portion 235 parses the program stream from the position represented by the subtitle read pointer in the buffer 215A, reads one subtitle access unit for the size described at the beginning of the subtitle access unit from the buffer 215A, and supplies the subtitle access<br><br>
unit together with time stamps added to the subtitle access unit to the subtitle decoder control module 218. As described in Fig. 2A and Fig. 2B, the size of a subtitle access unit is described at the beginning thereof. The subtitle read function portion 235 reads data for the size from the position represented by the subtitle read pointer in the buffer 215A and supplies the subtitle access unit together with time stamps added to the subtitle access unit to the subtitle decoder control module 218.<br>
The subtitle read function portion 235 updates the subtitle read pointer for the size of one subtitle access unit read from the buffer 215A. Thereafter, the flow returns to step S255. At step S255, the subtitle read function portion 235 repeats the same process. [Re-synchronization Process]<br>
Next, a synchronization control for video data and audio data of the decode control module 214 shown in Fig. 2A and Fig. 2B will be described.<br>
As described at step S130 shown in Fig. 30, the decode control module 214 causes the video decoder control module 216, the audio decoder control module 217, and the subtitle decoder control module 218 to start decoding their data.  If necessary, the decode control module 214 causes these modules to start decoding their data at different timings to synchronize<br><br>
them. For example, when the video decoder 116 and the audio decoder 117 perform their decode processes, depending on their progress degrees, they may output video data and audio data at different timings.<br>
Thus, the decode control module 214 performs a re-synchronization process that compensates the difference of the output timings for video data and audio data and causes the video decoder 116 and the audio decoder 117 to synchronously output video data and audio data.<br>
Next, with reference to a flow chart shown in Fig. 39, the re-synchronization process will be described.<br>
In the re-synchronization process, at step 3271, the decode control module 214 determines the difference between the time stamp of a video access unit that is output from the video decoder control module 216 and the time stamp of an audio access unit that is output from the audio decoder control module 217 is large.<br>
As described at step S129 shown in Fig. 30, whenever the video decoder control module 216 receives a video access unit from the buffer control module 215, the video decoder control module 216 supplies the time stamp of the video access unit to the decode control module 214. Likewise, whenever the audio decoder control module 217 receives an audio access unit from<br><br>
the buffer control module 215, the audio decoder control module 217 supplies the time stamp of the audio access unit to the decode control module 214.<br>
At step S271, the decode control module 214 compares the time stamps received from the video decoder control module 216 and the audio decoder control module 217 at the same timing (in a predetermined time period considered to be the same timing) and determines whether the difference of the time stamps is large.<br>
When the determined result at step S271 represents that the difference between the time stamp of the video access unit received from the video decoder control module 216 and the time stamp of the audio access unit received from the audio decoder control module 217 is not large, namely the difference between the time stamp of the video access unit and the time stamp of the audio access unit is in a predetermined range of which the access units can be considered to be synchronized, for example two video frames (around 66 milliseconds), the flow returns to step S271. At step S271, the decode control module 214 determines (monitors) the difference of the time stamps.<br>
In contrast, when the determined result at step S271 represents that the difference between the time stamp of the video access unit received from the<br><br>
video decoder control module 216 and the time stamp of the audio access unit received from the audio decoder control module 217 is large, namely the difference is not in a predetermined range of which the access units cannot be considered to be synchronized, the flow advances to step S272. At step S272, the decode control module 214 compares the time stamp of the video access unit received from the video decoder control module 216 and the time stamp of the audio access unit received from the audio decoder control module 217 so as to determine which of the output of the video data and the output of the audio data is later than the other.<br>
When the determined result at step S272 represents that the output of the video data is later than the output of the audio data, the flow advances to step S273. At step S273, the decode control module 214 causes the video decoder control module 216 to stop decoding and outputting (displaying) a video access unit, namely skip the process for a video access unit, to advance the process for one video access unit. Thereafter, the flow advances to step S274.<br>
At step S274, the video decoder control module 216 receives a skip request from the decode control module 214 and checks au_ref_flag (Fig. 24) supplied together with the video access unit from the buffer control module 215.<br><br>
In other words, au_information() (Fig. 24) stored in private_stream2_PES_payload() (Fig. 23) of PES_packet() of private_stream_2 contains au_ref_flag as information about an access unit. As described at step S129 shown in Fig. 30 and step S216 shown in Fig. 36, together with the video access unit, the buffer control module 215 supplies au_ref_flag thereof to the video decoder control module 216.<br>
At step S274, the video decoder control module 216 checks au_ref_flag of the access unit supplied together with the access unit.<br>
Thereafter, the flow advances from step S274 to step S275. At the step S275, the video decoder control module 216 determines whether the video access unit is a non-reference image that is not referenced when another picture is decoded corresponding to the check result of au_ref_flag of the video access unit, which has been supplied from the buffer control module 215.<br>
As described in Fig. 24, au_ref_flag of a video access unit represents whether the access unit is a reference image. When the access unit is a reference image, au_ref_flag is 1.  In contrast, when the access unit is not a reference image, au_ref_flag is 0.<br>
When the determined result at step S275<br>
represents that the video access unit supplied from the buffer control module 215 is not a non-reference image<br><br>
(a video access unit thereof), namely the video access unit supplied from the buffer control module 215 is a reference image, the flow advances to step S276. At step 5216, the video decoder control module 216 causes the video decoder 116 to normally process the video access unit. After the video decoder control module 216 has received the next video access unit from the buffer control module 215, the flow returns to step S274.<br>
In contrast, when the determined result at step S275 represents that the video access unit supplied from the buffer control module 215 is a non-reference image, the flow advances to step 5211, At step 5211, the video decoder control module 216 causes the video decoder 116 to skip the process for the video access unit. After the buffer control module 215 has supplied the next video access unit, the flow returns to step S271.<br>
Since the process for a video access unit is skipped, the process is advanced for almost one video access unit (the process time is decreased). As a result, the output of video data that is later than the output of audio data is advanced.<br>
In contrast, when the determined result at step S272 represents that the output of video data is not later than the output of audio data, namely the output of audio data is later than the output of video<br><br>
data, the flow advances to step S278. At step S278, the decode control module 214 outputs a continuous output command to the video decoder control module 216 to continuously output video data corresponding to the video access unit that is being decoded to keep the video decoder control module 216 waiting for the process for the next video access unit. Thereafter, the flow advances to step S279.<br>
At step S279, the video decoder control module 216 receives the continuous output request from the decode control module 214 and continuously outputs video data of the video access unit that is being decoded to the graphics process module 219 corresponding to the continuous output request. After the buffer control module 215 has supplied the next video access unit, the flow advances to step S271.<br>
As described above, the decode control module 214 determines whether the output of video data is later than the output of audio data. When the output of video data is later than the output of audio data, the decode control module 214 causes the video decoder control module 216 to skip the process for one access unit. The video decoder control module 216 determines whether the access unit to be skipped is a reference image or a non-reference image corresponding to au_ref_flag of the access unit. When the access unit is a non-reference image, the decode control module 214<br><br>
causes the video decoder 116 to skip the process for the access unit. Thus, the output of video data and the output of audio data can be easily synchronized.<br>
In other words, when an access unit to be skipped is a reference image, video data of the access unit need to be decoded so that the video data are referenced when another access unit is decoded. Thus, when the output of video data and the output of audio data are synchronized, if the process for an access unit of a reference image is skipped, another access unit that references the reference image cannot be decoded. As a result, when video data synchronized with audio data are displayed, noise appears.<br>
Thus, it is preferred that an access unit that is not a non-reference image be skipped.<br>
On the other hand, to search a conventional elementary stream for an access unit that is a non-reference image, the elementary stream needs to be parsed. An elementary stream encoded corresponding to for example the MPEG4-AVC system is very complicated. Thus, when the elementary stream is parsed, very high cost is required.<br>
In contrast, a program stream stored in a clip stream file recorded on the disc 101 is multiplexed with PES_packet() of private_stream_2 that contains private_stream2_PES_payload() (Fig. 23), which is an extension of PES packet data byte, besides<br><br>
PES_packet() (Fig. 16A and Fig. 16B to Fig. 18A and Fig. 18B) having PES_packet_data_byte, which contains a video access unit. au_information() (Fig. 24) of private_stream2_PES_payload() describes au_ref_flag, which represents whether the video access unit is a reference image or a non-reference image. au_ref_flag and the corresponding video access unit are supplied from the buffer control module 215 to the video decoder control module 216. Thus, the video decoder control module 216 can determine whether a video access unit is a reference image or a non-reference image by checking au_ref_flag of the video access unit almost without extra cost. [Mark Process]<br>
Next, with reference to a flow chart shown in Fig. 40, a mark process based on Mark() described in PlayListMarkO (Fig. 7) will be described.<br>
The decode control module 214 always checks the current time counted by the built-in time count portion 214A. At step S301, the decode control module 214 determines whether the current time matches mark_time_stamp of any Mark() described in PlayListMarkO (Fig. 7).<br>
As described at step S124 shown in Fig. 30, when the player control module 212 reproduces the first Playltem#0 of the first PlayList#0 shown in Fig. 25, the player control module 212 recognizes that four<br><br>
MarkO 's, which are the first to fourth Mark()'s, of seven Mark()'s contained in PlayListMark() in the upper table shown in Fig. 28 belong to the first Playltem#0 of PlayListtfO and supplies {180,090}, {5,580,090}, {10,980,090}, and {16,380,090}, which are mark_time_stamp's of the four Mark()'s together with information that represents that an attribute of times that mark_time_stampls represent is "mark process" to the decode control module 214.<br>
At step S301, the decode control module 214 determines which of the four times (mark_time_stampls) having an attribute of "mark process," which have been supplied from the player control module 212, matches the current time.<br>
When the determined result at step S301 represents that the current time does not match any of the times having an attribute of "mark process," the flow returns to step S301. At step S301, the decode control module 214 repeats the same process.<br>
In contrast, when the determined result at step S301 represents that the current time matches one of the four times having an attribute of "mark process," the decode control module 214 supplies a message that represents that the current time became a time having an attribute of "mark process" together with the matched time having an attribute of "mark process" to the player control module 212. Thereafter,<br><br>
the flow advances to step S302.<br>
At step S302, the player control module 212 receives the message, which represents that the current time became a time having an attribute of "mark process," together with the matched time, which has an attribute of "mark process," from the decode control module 214 and recognizes Mark() whose mark_time_stamp matches the current time as Mark() to be processed for the mark process (hereinafter, this Mark() is sometimes referred to as a target mark).<br>
In other words, the player control module 212 has recognized PlayltemO of PlayListO that is being reproduced. By referencing PlayListMark() (Fig. 7) of the "PLAYLIST.DAT" file (Fig. 5) with PlayListO, PlayltemO, and the matched time (mark_time_stamp), which an attribute of "mark process" (hereinafter this time is sometimes referred to as a mark time), the player control module 212 recognizes a target mark.<br>
Specifically, assuming that the first<br>
PlayltemttO of the first PlayListttO shown in Fig. 25 is being reproduced, the player control module 212 recognizes a mark time is mark_time_stamp of any one of the four Mark()'s, which are the first to fourth Mark()'s of seven Mark()'s contained in PlayListMark() in the upper table shown in Fig. 28.<br>
When the mark time supplied from the decode control module 214 to the player control module 212 is<br><br>
for example 16,380,090, the player control module 212 recognizes the fourth Mark() whose mark_time_stamp matches 16,380,090, which is the mark time, of four Mark()'s, which are the first to fourth MarkO's, contained in PlayListMark() in the upper table shown in Fig. 28 as the target mark.<br>
When the player control module 212 has<br>
recognized the target mark, the flow advances from step S302 to step S303. At step S303, the player control module 212 determines whether the target mark describes entry_ES_stream_id and entry_ES_private_stream_id (Fig. 7), which identify an elementary stream.<br>
When the determined result at step S303 represents that the target mark does not describe entry_ES_stream_id and entry_ES_private_stream_id (Fig. 7), which identify an elementary stream, namely both entry_ES_stream_id and entry_ES_private_stream_id are 0x00, the flow advances to step S305, skipping step S304. At step S305, the decode control module 214 performs the process for the target mark.<br>
In contrast, when the determined result at step S303 represents that the target mark describes entry_ES_stream_id and entry_ES_private_stream_id (Fig. 7), which identify an elementary stream, the flow advances to step S304. At step S304, the player control module 212 determines whether the elementary stream that is being reproduced contains an elementary<br><br>
stream identified by entry_ES_stream_id and if necessary entry_ES_private_stream_id.<br>
When the determined result at step S304 represents that the elementary stream that is being reproduced does not contain an elementary stream identified by entry_ES_stream_id and<br>
entry_ES_private_stream_id of the target mark, the flow returns to step S301. In other words, when the elementary stream identified by entry_ES_stream_id and entry_ES_private_stream_id of the target mark is not being reproduced, the target mark is ignored.<br>
In contrast, when the determined result at step S304 represents that the elementary stream that is being reproduced contains an elementary stream identified by entry_ES_stream_id and<br>
entry_ES_private_stream_id of the target mark, namely an elementary stream identified by entry_ES_stream_id and entry_ES_private_stream_id of the target mark is being reproduced, it is determined that the target mark be valid. Thereafter, the flow advances to step S305. At step S305, the player control module 212 performs the process for the target mark.<br>
In other words, at step S305, by referencing mark_type of a target mark (Fig. 7), the player control module 212 determines the target mark.<br>
When the determined result at step S305 represents that the target mark is a chapter mark or an<br><br>
index mark, namely mark_type of the target mark is "Chapter" or "Index," the flow advances to step S306. At step S306, the player control module 212 causes the graphics process module 219 to update the chapter number or index number with that of the target mark. Thereafter, the flow returns to step S301.<br>
When the determined result at step S305 represents that the target mark is an event mark, namely mark_type of the target mark is "Event," the flow advances to step S307. At step S307, the player control module 212 informs the script control module 211 of both an event message that represents that an event has taken place and mark_data of the target mark. Thereafter, the flow advances to step S308.<br>
At step S308, the script control module 211 receives an event message and mark_data from the player control module 212 and performs a sequence of processes described in the "SCRIPT.DAT" file with an argument of mark_data corresponding to an interrupt request of the event message. Thereafter, the flow returns to step S301.<br>
In other words, the script control module 211 performs a process corresponding to mark_data.<br>
Specifically, in PlayListMark() of PlayList#l in the lower table shown in Fig. 28, mark_type of each of the second Mark() (Mark#l) and the third Mark() (Mark#2) is "Event" and mark data of Mark#l is<br><br>
different from mark_data of Mark#2.<br>
When the script control module 211 receives an event message corresponding to the second Mark() and an event message corresponding to the third Mark(), the script control module 211 performs a process corresponding to the received event message with the same event handler (interrupt process routine). The script control module 211 checks mark_data supplied together with the event message and performs a process corresponding to mark_data.<br>
Specifically, when mark_data is for example 1, the script control module 211 controls the graphics process module 219 to display a first type icon. When mark_data is for example 2, the script control module 211 controls the graphics process module 219 to display a second type icon.<br>
mark_data is not limited to 1 and 2.  In addition, the process corresponding to mark_data is not limited to the display of simple icons.<br>
In other words, when mark_data is in the range from 3 to 18, the script control module 211 controls the graphics process module 219 to display the first type icon with intensity corresponding to a value of which 2 is subtracted from mark_data (a value in the range from 1 to 16) . On the other hand, when mark_data is in the range from 19 to 34, the script control module 211 controls the graphics process module 219 to<br><br>
display the second type icon with intensity corresponding to a value of which 18 is subtracted from mark_data (a value in the range from 1 to 16).<br>
When a controller that the user operates is connected to the input interface 115 (Fig. 1) and the controller has a vibration motor that is a direct current (DC) motor with an eccentric weight mounted on the motor shaft and that vibrates when the motor is driven, if the value of mark_data is in the range from 35 to 42, the vibration motor can be driven for an operation time period corresponding to a value of which 34 is subtracted from mark_data (a value in the range from 1 to 8) .<br>
mark_data is a numeric value. The use and algorithm of mark_data can be described with a script program that the script control module 211 executes. Thus, mark_data can be used corresponding to a predetermined rule or an original rule designated by the manufacturer of the disc 101 or a content provider that provides data recorded on the disc 101.<br>
When the current time matches a time having an attribute of "mark process," a target mark is recognized from the mark time, which is the time having an attribute of "mark process." When a target mark does not describe entry_ES_stream_id and entry_ES_private_stream_id that identify an elementary stream, a process corresponding to mark_type of the<br><br>
target mark is preformed. Even if a target mark describes entry_ES_stream_id and<br>
entry_ES_private_stream_id that identify an elementary stream, while the elementary stream identified by entry_ES_stream_id and entry_ES_private_stream_id is being reproduced, a process corresponding to mark_type of the target mark is performed.<br>
While the second PlayList#l shown in Fig. 25 is being reproduced, the following mark process is performed.<br>
In other words, as shown in the lower table shown in Fig. 28, PlayListMark() of the second PlayList#l describes first Mark() (Mark#0), second MarkO (Mark#l), and third Mark() (Mark#2), whose mark_time_stamp's are 90,000, 27,090,000, and 27,540,000, respectively.<br>
In addition, since entry_ES_stream_id's of the second MarkO and the third MarkO of PlayListMark() in the lower table shown in Fig. 28 describe OxEO and OxEl, the second MarkO and the third MarkO are correlated with elementary streams identified by stream_id's that are OxEO and OxEl, respectively.<br>
As described in Fig. 25, the second<br>
PlayList#l describes only one PlayltemO (PlayltemttO). With PlayltemttO, the clip stream file "00003.PS" is reproduced. As described in the clip information file<br><br>
"00003.CLP" shown in Fig. 26A and Fig. 26B, which corresponds to the clip stream file "00003.PS," the clip stream file "00003.PS" is multiplexed with three elementary streams, which are the video stream stream#0 identified by stream_id that is OxEO, the video stream streamftl identified by stream_id that is OxEl, and the audio stream#2 identified by private_stream_id that is 0x00.<br>
Thus, the second Mark() of PlayListMark () in the lower table shown in Fig. 28 is correlated with the video stream file stream#0 whose stream_id is OxEO, which is multiplexed with the clip stream file "00003.PS." The third Mark() is correlated with the video stream streamttl whose stream_id is OxEl, which is multiplexed with the clip stream file "00003.PS."<br>
When Playltem#0 of the second Playltem#l shown in Fig. 25 is reproduced, as described at step S124 shown in Fig. 30, the player control module 212 recognizes that three Mark()'s contained in PlayListMark() in the lower table shown in Fig. 28 belong to PlayltemttO of PlayListttl and supplies {90,000}, {27,090,000}, and {27,540,000}, which are mark_time_stamp's of three Mark()'s, together with information that represents that the times have an attribute of "mark process" to the decode control module 214.<br>
In the mark process, while PlayltemttO of<br><br>
PlayList#l is being reproduced, the decode control module 214 always determines which of times {90,000}, {27,090,000}, and {27,540,000} matches the current time counted by the time count portion 214A (at step S301) . When the current time matches a time having an attribute of "mark process," the decode control module 214 supplies a mark time that is a time having an attribute of "mark process," matches the current time, together with a message that represents that the current time became a time having an attribute of "mark process" to the player control module 212.<br>
When the current time matches 27,090,000 of times {90,000}, {27,090,000}, and {27,540,000} having an attribute of "mark process," the decode control module 214 supplies a mark time having an attribute of "mark process," 27,090,000, together with the message that represents that the current time became a time having an attribute of "mark process" to the player control module 212.<br>
The player control module 212 has recognized that PlayltemttO of PlayList#l is being reproduced. The player control module 212 compares 90,000, 27,090,000, and 27,540,000, which are mark_time_stamp1s of three MarkO's that belong to Playltem#0 of Mark()'s described in PlayListMark() in the lower table shown in Fig. 28 with 27,090,000, which is the mark time supplied from the decode control module 214 and<br><br>
recognizes that Mark() whose mark_time_stamp matches 27,090,000, which is a mark time, namely the second Mark() (Markttl) described in PlayListMark() in the lower table shown in Fig. 28 is a target mark (at step S302).<br>
In the second Mark(), which is a target mark, described in PlayListMark() in the lower table shown in Fig. 28, entry_ES_stream_id is OxEO. As described above, entry_ES_stream_id, which is OxEO, represents the video stream stream#0 (Fig. 26A and Fig. 26B) whose stream_id is OxEO, multiplexed with the clip stream file "00003.PS." The player control module 212 determines whether an elementary stream that is being reproduced contains the video stream stream#0 (at steps S303 and S304).<br>
When an elementary stream that is being reproduced does not contain the video stream stream#0, the player control module 212 ignores the target mark (at step S304) .<br>
In contrast, when an elementary stream that is being reproduced contains the video stream stream#0, the player control module 212 treats the target mark to be valid and performs a process corresponding to the target mark (at steps S305 to S308).<br>
In this case, in the second Mark(}, which is a target mark, described in PlayListMark() in the lower table shown in Fig. 28, mark type is "Event." Thus,<br><br>
the second Mark() is an event mark. The player control module 212 supplies an event message that represents that an event has taken place and mark_data of the target mark to the script control module 211 (at steps S305 and S307). The script control module 211 performs a sequence of processes described in the "SCRIPT.DAT" with an argument of mark_data corresponding to an interrupt request of the event message received from the player control module 212 (at step S308) .<br>
As described above, in the mark process, the player control modules determines whether the current time that is a reproduction time of a clip stream file reproduced corresponding to mark_time_stamp that represents one reproduction time on the time axis of PlayList(), mark_type that represents the type of Mark(), and PlayListO (Fig. 5) that contains PlayListMark() (Fig. 7) that has no Mark() or more than one Mark() that contains mark_data as an argument of an event mark matches mark_time_stamp. When the current time matches mark_time_stamp, the player control module 212 recognizes Mark() that has mark_time_stamp equal to a mark time, which is the current time, as a target mark. When mark_type that has a target mark represents a type of which an event takes place, namely the target mark is an event mark, mark_type that the target mark has and the event message are supplied. The player control module 212 executes a process corresponding to<br><br>
mark_data. Thus, the player control module 212 can execute a process corresponding to mark_data for the reproduction time of the clip stream file. [Output Attribute Control Process]<br>
Next, with reference to a flow chart shown in Fig. 41, an output attribute control process performed at step S126 shown in Fig. 30 will be described in detail.<br>
As described at step S126 shown in Fig. 30, the player control module 212 checks<br>
number_of_DynamicInfo (Fig. 10), which represents the number of Dynamiclnfo()'s (Fig. 13), which describe an output attribute for at least one elementary stream to be reproduced, namely at least one elementary stream to be reproduced, which has been decided at step S125.<br>
When number_of_DynamicInfo of each of at least one elementary stream to be reproduced is 0, the player control module 212 does not perform any process.<br>
In contrast, when number_of_DynamicInfo of an elementary stream to be reproduced is not 0, the player control module 212 performs an output attribute control process corresponding to a flow chart shown in Fig. 41.<br>
Thus, when three clip information files "00001.CLP," "00002.CLP," and "00003.CLP" recorded on the disc 101 are as shown in Fig. 26A and Fig. 26B and the clip stream file "00001.PS" (the first PlayltemttO of the first PlayList#0 that reproduces the clip stream<br><br>
file "00001.PS") corresponding to the clip information file "00001.CLP" is reproduced, since number_of_DynamicInfo's of all the four elementary streams, which are streamttO to stream#3, are 0, the player control module 212 does not perform the output attribute control process.<br>
Likewise, when the clip stream file "00002.PS" (the second Playltemtfl of the first PlayList#0 that reproduces the clip stream file "00002.PS) corresponding to the clip information file "00002.CLP" is reproduced, since all number_of_Dynamic!nfo's of four elementary streams, which are stream#0 to stream#3, multiplexed with the clip stream file "00002.PS" are 0, the player control module 212 does not perform the output attribute control process.<br>
In contrast, when the clip stream file "00003.PS" (PlayltemttO of the second PlayListttl that reproduces the clip stream file "00003.PS") corresponding to the clip information file "00003.CLP" is reproduced, since number_of_DynamicInfo's of the video stream stream#0, which is the first elementary stream, and the audio stream stream#2, which is the third elementary stream, are 2 and 3, respectively, the player control module 212 performs the output attribute control process.<br>
In other words, in the output attribute<br><br>
control process, at step S320, the player control module 212 supplies pts_change_point described in the clip information file ClipO (Fig. 10) corresponding to the clip stream file to be reproduced together with information that represents a time having an attribute of "Dynamiclnfo() process" to the decode control module 214. The decode control module 214 receives pts_change_point, which is a time having an attribute of "Dynamiclnfo() process" from the player control module 212. Thereafter, the flow advances to step S321.<br>
At step S321, the decode control module 214 determines whether the current time counted by the time count portion 214A matches one of pts_change_point's, which are times having an attribute of "Dynamiclnfo() process." When the determined result at step S321 represents that the current time does not match any one of pts_change_point's, the flow returns to step S321.<br>
In contrast, when the determined result at step S321 represents that the current time matches any one of times having an attribute of "Dynamiclnfo() process," the decode control module 214 supplies a message that represents that the current time became a time having an attribute of "Dynamiclnfo() process" and the matched time, which has an attribute of "Dynamiclnfo() process" (hereinafter sometimes referred to as Dynamiclnfo time), to the player control module<br><br>
212. Thereafter, the flow advances to step S322.<br>
At step S332, the player control module 212 receives the message, which represents that the current time became a time having an attribute of "Dynamiclnfo() process," and a Dynamiclnfo time from the decode control module 214 and recognizes Dynamiclnfo() paired with pts_change_point (Fig. 10) that matches the Dynamiclnfo time as a target Dynamiclnfo(). Thereafter, the flow advances to step S323.<br>
At step S323, the player control module 212 supplies an output attribute described in Dynamiclnfo() (Fig. 13) that is the target Dynamiclnfo() to the graphics process module 219 or the audio output module 221. Thereafter, the flow advances to step S324.<br>
At step S324, the graphics process module 219 or the audio output module 221 starts controlling an output of video data or audio data corresponding to the output attribute, which has been supplied from the player control module 212 at step S323. Thereafter, the flow returns to step S321.<br>
Thus, video data are output corresponding to for example an aspect ratio described as the output attribute (display mode). Alternatively, audio data are output corresponding to for example stereo mode or dual (bilingual) mode described as the output attribute.<br><br>
Next, with reference to Fig. 42, the output attribute control process will be described in detail.<br>
Fig. 42 shows a pair of pts_change_point and Dynamiclnfo() (Fig. 10) described in the clip information file "00003.CLP" shown in Fig. 26A and Fig. 26B.<br>
As described above, number_of_DynamicInfo's of the video stream streamttO and the audio stream stream#2, which are the first elementary stream and the third elementary stream of the three elementary streams, stream#0 to stream#2 multiplexed with the clip stream file "00003.PS," are 2 and 3, respectively/ in the clip information file "00003.CLP" shown in Fig. 26A and Fig. 26B. Thus, the clip information file "00003.CLP" describes two sets of pts_change_point's and Dynamiclnfo()'s for the first video stream stream#0 of the clip stream file "00003.PS" and three sets of pts_change_point's and Dynamiclnfo()'s for the third audio stream stream#2 of the clip stream file "00003.PS."<br>
An upper table shown in Fig. 42 shows two sets of pts_change_point's and Dynamiclnfo()'s of the first video stream streamttO of the clip stream file "00003.PS." A lower table shown in Fig. 42 shows three sets of pts_change_point's and Dynamiclnfo()'s of the third audio stream stream#2 of the clip stream file "00003.PS."<br><br>
In addition to the two sets of<br>
pts_change_point's and Dynamiclnfo()'s of the first video stream stream#0, the upper table shown in Fig. 42 also represents stream_id (= OxEO), private_stream_id (= 0x00), and number_of_DynamicInfo (=2) of the clip information file "00003.CLP," shown in Fig. 26A and Fig. 26B, of the first video stream#0. Likewise, in addition to the three sets of pts_change_point's and Dynamiclnfo()'s of the third audio stream stream#2, the lower table shown in Fig. 42 also represents stream_id (= OxBD), private_stream_id (= 0x00), and number_of_DynamicInfo (= 3) of the clip information file "00003.CLP," shown in Fig. 26A and Fig. 26B, of the audio stream stream#2.<br>
In the upper table shown in Fig. 42, pts_change_point of the first set of two sets of pts_change_point's and Dynamiclnfo()'s of the video stream stream#0 is 90,000 and display_aspect_ratio (Fig. 13) of Dynamiclnfo() thereof is "4 : 3." pts_change_point of the second set is 54,090,000 and display_aspect_ratio of Dynamiclnfo() thereof is "16 : 9."<br>
In the lower table shown in Fig. 42,<br>
pts_change_point of the first set of the three sets of pts_change_point's and Dynamiclnfo()'s of the audio stream stream#2 is 90,000 and channel_assignment (Fig. 13) of Dynamiclnfo() thereof is "Dual."<br><br>
pts_change_point of the second set is 27,090,000 and channel_assignment of Dynamiclnfo() thereof is "Stereo." pts__change_point of the third set is 32,490,000 and channel_assignment of Dynamiclnfo() thereof is "Dual."<br>
Now, it is assumed that at step S125 shown in Fig. 30, the first video stream stream#0, identified by stream_id that is OxEO, and the third audio stream stream#2, identified by stream_id that is OxBD and private_stream_id that is 0x00, have been decided as streams to be reproduced from the clip stream file "00003.PS."<br>
In this case, the player control module 212 checks the two sets of pts_change_point's and Dynamiclnfo()!s in the upper table shown in Fig. 42 for the video stream stream#0, identified by stream_id that is OxEO, and three sets of pts_change_point's and Dynamiclnfo()'s in the lower table shown in Fig. 42 for the audio stream stream#2, identified by stream_id that is OxBD and private_stream_id that is 0x00, and recognizes an initial value.<br>
In other words, pts_change_point of the first set of the two sets of pts_change_point's and Dynamiclnfo()'s in the upper table shown in Fig. 42 for the video stream stream#0, identified by stream_id that is OxEO, is 90,000. 90,000 matches 90,000 described in presentation start time, which represents the start<br><br>
time of the clip stream file "00003.PS" in the clip information file "00003.CLP" shown in Fig. 26A and Fig. 26B corresponding to the clip stream file "00003.PS" with which the video stream stream#0 has been multiplexed.<br>
Likewise, pts_change_point of the first set of the three sets of pts_change_point's and Dynamiclnfo()' in the lower table shown in Fig. 42 for the audio stream stream#2, identified by stream_id that is OxBD and private_stream_id that is 0x00, is 90,000. 90,000 matches 90,000 described in<br>
presentation_start_time, which represents the start time of the clip stream file "00003.PS" in the clip information file "00003.CLP" shown in Fig. 26A and Fig. 26B corresponding to the clip stream file "00003.PS" with which the audio stream stream#2 has been multiplexed.<br>
The player control module 212 recognizes pts_change_point that matches 90,000 described in presentation_start_time, which represents the start time of the clip stream file "00003.PS" as an initial value. Thus, the player control module 212 recognizes pts_change_point of the first set of the two sets of pts_change_point's and Dynamiclnfo()'s in the upper table shown in Fig. 42 and pts_change_point of the first set of the three sets of pts_change_point's and Dynamiclnfo()'s in the lower table shown in Fig. 42 as<br><br>
initial values.<br>
The player control module 212 designates an output attribute of an elementary stream corresponding to Dynamiclnfo() paired with pts_change_point recognized as an initial value before the clip stream file "00003.PS" is reproduced (at step S126 shown in Fig. 30).<br>
For the video stream stream#0, identified by stream_id that is OxEO, in the upper table shown in Fig. 42, display_aspect_ratio of Dynamiclnfo() paired with pts_change_point, which is 90,000 as an initial value, is "4 : 3." In this case, the player control module 212 controls the graphics process module 219 with information that represents that display_aspect_ratio is "4 : 3," namely information about an output attribute that represents that the video stream streamttO is video data whose aspect ratio is 4 : 3.<br>
For the audio stream stream#2, identified by stream_id that is OxBD and private_stream_id that is 0x00, in the lower table shown in Fig. 42, channel_assignment of Dynamiclnfo() paired with pts_change_point, which is 90,000 as an initial value, is "Dual." In this case, the player control module 212 supplies information that represents that channel_assignment is "Dual," namely information about an output attribute that represents that the audio<br><br>
stream stream#2 is dual audio data to the audio output module 221.<br>
At step S126 shown in Fig. 30, the player control module 212 performs the output attribute control process for pts_change_point's as initial values.<br>
Thereafter, the player control module 212 supplies 90,000 and 54,090,000, which are two pts_change_point's, for the video stream stream#0 in the upper table shown in Fig. 42 and {27,090,000}, and {32,490,000} of 90,000, 27,090,000, and 32,490,000, which are times of three pts_change_point's except for 90,000, which is an initial value, for the audio stream stream#2 in the lower table shown in Fig. 42 together with information that represents that these times have an attribute of "Dynamiclnfo() process" to the decode control module 214 (at step S320) .<br>
The decode control module 214 receives times {27,090,000}, {32,490,000}, and {54,090,000} having an attribute of "Dynamiclnfo() process" from the player control module 212. After starting reproducing the video stream stream#0 and the audio stream stream#2 (PlayltemttO of the second PlayList#l that reproduces the clip stream file "00003.PS"), the decode control module starts monitoring the current time counted by the time count portion 214A.<br>
When the current time matches one of times<br><br>
{27,090,000}, {32,490,000}, and {54,090,000}, which have an attribute of "DynamicInfo() process," the decode control module 214 supplies a Dynamiclnfo time, which is a time that has an attribute of "Dynamiclnfo() process" and that matches the current time, to the player control module 212 (at step S321) .<br>
When the current time became for example 27,090,000, the decode control module 214 supplies 27,090,000, which matches the current time and is one of times having an attribute of "Dynamiclnfo() process" as a Dynamiclnfo time, to the player control module 212.<br>
The player control module 212 receives 27,090,000, which is a Dynamiclnfo time, from the decode control module 214, checks pts_change_point that matches 27,090,000 as a Dynamiclnfo time from two pts_change_point's for the video stream#0 in the upper table shown in Fig. 42 and three pts_change_point's for the audio stream#2 in the lower table shown in Fig. 42, and recognizes Dynamiclnfo() paired with pts_change_point that matches 27,090,000, namely the second Dynamiclnfo() for the audio stream stream#2 in the lower table shown in Fig. 42 as a target Dynamiclnfo() (at step S322) .<br>
When the target Dynamiclnfo() is<br>
Dynamiclnfo() of a video stream, the player control module 212 supplies an output attribute described in<br><br>
the target Dynamiclnfo() to the graphics process module 219 (at step 5323) . When the target Dynamiclnfo() is Dynamiclnfo() of an audio stream, the player control module 212 supplies an output attribute described in the target Dynamiclnfo() to the audio output module 221 (at step S323).<br>
When the graphics process module 219 has received an output attribute from the player control module 212, the graphics process module 219 starts controlling an output of video data corresponding to the output attribute (at step S324).<br>
In other words, the graphics process module 219 converts an aspect ratio of video data that are output to the video output module 220 corresponding to an aspect ratio of video data (display_aspect_ratio (Fig. 13)) represented by an output attribute received from for example the player control module 212 and an aspect ratio of a video output device connected to the video output terminal 120 shown in Fig. 1.<br>
Specifically, when the aspect ratio of the video output device is for example 16 : 9 and the aspect ratio of video data represented by the output attribute is 4 : 3, the graphics process module 219 performs a squeeze process for video data that are output to the video output module 220 in the horizontal direction and causes the left and right ends of the video data to be black. When the aspect ratio of video<br><br>
data of the video output device is for example 4 : 3 and the aspect ratio of video data represented by the output attribute is 16 : 9, the graphics process module 219 performs a squeeze process for the video data that are output to the video output module 220 in the vertical direction and causes the upper and lower ends of the video data to be black. When the aspect ratio of the video output device and the aspect ratio of video data as an output attribute are the same, for example 4 : 3 or 16 : 9, the graphics process module<br>
219	outputs the video data to the video output module<br>
220	without performing a squeeze process for the video<br>
data.<br>
With two sets of pts_change_point's and Dynamiclnfo()'s for the video stream stream#0, identified by stream_id that is OxEO, in the upper table shown in Fig. 42, video data having an aspect ratio of 4 : 3 are obtained after time 90,000, which is a reproduction start time of the video stream streamttO, before time 54,090,000. After time 54,090,000, video data having an aspect ratio of 16 : 9 are obtained.<br>
Thus, assuming that the aspect ratio of the video output device connected to the video output terminal 120 shown in Fig. 1 is 4 : 3, the graphics process module 219 supplies video data having an aspect ratio of 4 : 3 obtained from the video stream stream#0 to the video output device whose aspect ratio is 4 : 3<br><br>
after time 90,000 before time 54,090,000. The video output device displays the received video data.<br>
After time 54,090,000, the graphics process module 219 performs a squeeze process for video data having an aspect ratio of 16 : 9 in the vertical direction and causes upper and lower ends of the video data to be black to convert the video data having an aspect ratio of 16 : 9 into a video signal having an aspect ratio of 4 : 3. The converted video signal is supplied to the video output device.  The video output device displays the converted video data.<br>
When the audio output module 221 receives an output attribute from the player control module 212, the audio output module 221 starts controlling an output of audio data corresponding to the output attribute (at step S324).<br>
In other words, the audio output module 221 processes audio data received from the audio decoder control module 217 corresponding to a channel assignment for audio data (channel_assignment (Fig. 13)) represented by an output attribute received from the player control module 212 and corresponding to an audio output mode supplied from the player control module 212 through the input interface 115 (Fig. 1) that the user operates with the remote controller and outputs the processed audio data to the audio output terminal 121 (Fig. 1).<br><br>
Specifically, when the channel assignment for audio data represented by the output attribute is a dual (bilingual) mode of which the left channel is "main audio" data and the right channel is "sub audio" data, the audio output module 221 processes the audio data supplied from the audio decoder control module 217 corresponding to the audio output mode supplied from the player control module 212 and outputs the processed audio data to the audio output terminal 121.<br>
In other words, if the "main sound" has been designated as an audio output mode, the audio output module 221 copies the left channel of audio data received from the audio decoder control module 217 as the right channel of audio data and outputs the left and right channel of audio data ("main audio" data) to the audio output terminal 121.  If "sub audio" has been designated as an audio output mode, the audio output module 221 copies the right channel of audio data received from the audio decoder control module 217 as the left channel and outputs the left and right channel ("sub audio" data) to the audio output terminal 121. If both "main and sub audios" have been designated as an audio output mode, the audio output module 221 directly outputs audio data received from the audio decoder control module 217 to the audio output terminal 121.<br>
If the channel assignment of audio data<br><br>
represented by the output attribute is for example stereo mode, the audio output module 221 directly outputs the audio data received from the audio decoder control module 217 to the audio output terminal 121 regardless of what audio output mode has been designated.<br>
With the three sets of pts_change_point's and Dynamiclnfo()'s for the audio stream stream#2, identified by stream_id that is OxBD and private_stream_id that is 0x00, in the lower table shown in Fig. 42, dual audio data are obtained from the audio stream stream#2 after time 90,000 as the reproduction start time before time 27,090,000.  In addition, stereo audio data are obtained from the audio stream stream#2 after time 27,090,000 before time 32,490,000.  In addition, dual audio data are obtained from the audio stream stream#2 after time 32,490,000.<br>
Thus, when "main audio" has been designated as an audio output mode, the audio output module 221 copies audio data of the left channel of the dual audio data that are obtained from the audio stream stream#2 after time 90,000 before time 27,090,000 as the right channel of audio data. The left channel and right channel of audio data are output to the audio output terminal 121.<br>
Stereo audio data obtained from the audio stream stream#2 after time 27,090,000 before time<br><br>
32,490,000 are output to the audio output terminal 121.<br>
The left channel of the dual audio data obtained from the audio stream stream#2 after time 32,490,000 are copied as the right channel of audio data. The left channel and right channel of audio data are output to the audio output terminal 121.<br>
As described above, in the output attribute control process, it is determined whether a reproduction time of an elementary stream that is being reproduced matches pts_change_point corresponding to the clip information file ClipO (Fig. 10) that contains n sets of pts_change_point's that represent a reproduction time of each elementary stream multiplexed with a clip stream file and Dynamiclnfo()'s that represents an output attribute of the elementary stream (where n is 0 or larger any integer). When the reproduction time of an elementary stream that is being reproduced matches pts_change_point, Dynamiclnfo() paired with pts__change_point is recognized. The output of the elementary stream that is being reproduced is controlled corresponding to the output attribute described in Dynamiclnfo(). Thus, the output of the elementary stream can be controlled corresponding to the reproduction time of the elementary stream and the output attribute. [Subtitle Display Control Process]<br>
Next, with reference to a flow chart shown in<br><br>
Fig. 43, a subtitle display control process that controls the display of subtitle data corresponding to a subtitle stream will be described.<br>
When the reproduction of PlayListO (Fig. 5) (PlayListO thereof) is started, the player control module 212 initializes a subtitle data display mode for the graphics process module 219 at step S341.  In other words, the player control module 212 controls the graphics process module 219 to change the subtitle data display mode to the default display mode. The initialization of the display mode performed at step S341 corresponds to the initialization of the display mode performed at step S127 shown in Fig. 30.<br>
After step S341, the flow advances to step S342. At step S342, the player control module 212 determines whether the user has input a new subtitle data display mode command to the input interface 115 through the remote controller.<br>
When the determined result at step S342 represents that a new display mode command has been input, the flow advances to step S343. At step S343, the player control module 212 determines whether a subtitle stream (subtitle data corresponding thereto) is being reproduced.<br>
When the determined result at step S343 represents that a subtitle stream is not being reproduced, the flow returns to step S342.<br><br>
In contrast, when the determined result at step S343 represents that a subtitle stream is being reproduced, the flow advances to step S345. At step<br>
5345,	the player control module 212 determines whether<br>
the new display mode command is the default display<br>
mode command. When the determined result at step S343<br>
represents that the new display mode command is the<br>
default display mode command, the flow returns to step<br>
S341. At step S341, as described above, the player<br>
control module 212 controls the graphics process module<br>
219 to change the subtitle data display mode to the<br>
default display mode.<br>
In contrast, when the determined result at step S345 represents that the new display mode command is not the default display mode command, namely the new display mode command is a non-default display mode command for example a subtitle data enlargement command, a subtitle data reduction command, or a brightness increase command, the flow advances to step<br>
5346.	At step S346, the player control module 212<br>
obtains StaticInfoO of the subtitle stream, which is<br>
being reproduced, of Staticlnfo()'s (Fig. 12) of the<br>
clip information file ClipO (Fig. 10) corresponding to<br>
the clip stream file with which the subtitle stream<br>
that is being reproduced is multiplexed. Thereafter,<br>
the flow advances to step S347.<br>
At step S347, the player control module 212<br><br>
determines configurable_flag of Staticlnfo() obtained at step S346.<br>
When the determined result at step S347 represents that configurable_flag is 0, which represents that the subtitle data display mode is not permitted to be changed, the flow advances to step<br>
5348.	At step S348, the player control module 212<br>
controls the graphics process module 219 to overlay<br>
output video data with a message that represents that<br>
the subtitle data display mode cannot be changed.<br>
Thereafter, the flow returns to step S342. At step<br>
S342, the error message is displayed.<br>
In contrast, when the determined result at step S347 represents that configurable_flag is 1, which represents that the subtitle data display mode is permitted to be changed, the flow advances to step<br>
5349.	At step S349, the player control module 212<br>
supplies the new display mode command, which has been<br>
input from the remote controller by the user through<br>
the input interface 115, to the graphics process module<br>
219. Thereafter, the flow advance to step S350.<br>
At step S350, the graphics process module 219 starts performing an enlargement process, a reduction process, or a brightness change process for the subtitle data supplied from the subtitle decoder control module 218 corresponding to the display mode command, which has been supplied from the player<br><br>
control module 212 at step S349. Thereafter, the flow returns to step S342. Thus, the subtitle data are displayed in the display size, at the display position, or in the display colors corresponding to the display mode command that has been input by the user through the remote controller.<br>
In contrast, when the determined result at step S342 represents that the new display mode command has not been input, the flow advances to step S351. At step S351, the player control module 212 determines whether Playltem()'s have been changed as described in Fig. 31. When the determined result at step S342 represents that Playltem()'s have not been changed, the flow returns to step S342.<br>
In contrast, when the determined result at step S351 represents that PlayltemO's have been changed, the flow returns to step S341. At step S341, as was described above, the player control module 212 controls the graphics process module 219 to change the subtitle data display mode to the default display mode. In other words, when PlayltemO's have been changed, the subtitle data display mode is restored to the default display mode.<br>
As was described above, only when<br>
configurable_flag of the subtitle stream is 1, which represents that the display mode is permitted to be changed, the subtitle data display mode for the<br><br>
subtitle stream can be changed corresponding to a display mode command that is input by the user through the remote controller.<br>
Thus, for example in the clip information file "00001.CLP" shown in Fig. 26A and Fig. 26B, since configurable_flag of the subtitle stream stream#2, which is the third elementary stream of four elementary streams multiplexed with the clip stream file "00001.PS," is 0, which represents that the display mode is not permitted to be changed, while the subtitle stream stream#2 is being displayed, even if the user operates the remote controller to change the subtitle display mode, the display mode is not changed.<br>
In contrast, since configurable_flag of the subtitle stream stream#3, which is the fourth elementary stream of four elementary streams multiplexed with the clip stream file "00001.PS," is 1, which represents that the display mode is permitted to be changed, while the subtitle stream stream#3 is being displayed, when the user operates the remote controller to change the subtitle display mode, the display size of the subtitle is changed.<br>
Now, it is assumed that the clip stream file "00001.PS" is being reproduced corresponding to the first Playltem#l of the first PlayList#l shown in Fig. 25.  In addition, in the clip information file "00001.CLP" described in Fig. 26A and Fig. 26B, it is<br><br>
assumed that the third and fourth elementary streams of four elementary streams multiplexed with the clip stream file "00001.PS" are subtitle streams and that the third subtitle stream stream#2 of the third and fourth subtitle streams stream#2 and stream#3 is being reproduced.<br>
When the user operates the remote controller to input a subtitle display mode command (at step S342), the display mode command is supplied from the input interface 115 (Fig. 1) to the player control module 212. When the player control module 212 receives the display mode command, the player control module 212 searches the clip information file for StaticInfoO (Fig. 10) corresponding to the subtitle stream that is being reproduced (at step S346).<br>
In other words, the subtitle stream that is being reproduced is the third subtitle stream stream#2 multiplexed with the clip stream file "00001.PS." The player control module 212 searches the corresponding clip information file "00001.CLP" for StaticInfoO of the third subtitle stream stream#2.<br>
In addition, the player control module 212 determines configurable_flag, which is 0, described in StaticInfoO of the third subtitle stream stream#2 shown in Fig. 26A and Fig. 26B (at step S347) . Thus, the player control module 212 recognizes that the display mode of the third subtitle stream stream#2 is<br><br>
not permitted to be changed.<br>
In this case, the player control module 212 determines that the subtitle stream (subtitle data corresponding thereto) that is being reproduced does not correspond to enlargement and reduction modes and controls the graphics process module 219 to generate a corresponding error message (at step S348), overlays the error message with video data, and outputs the overlaid video data.<br>
While the fourth subtitle stream stream#3 of the third and fourth subtitle streams stream#2 and stream#3 of the four elementary streams multiplexed with the clip stream file "00001.PS" is being reproduced, when the player control module 212 receives a display mode command that has been input by the user through the remote controller, the player control module 212 searches the corresponding clip information file "00001.CLP" for StaticInfoO of the fourth subtitle stream stream#3.<br>
The player control module 212 determines configurable_flag, which is 1, described in StaticInfoO of the fourth subtitle stream stream#3 shown in Fig. 26A and Fig. 26B (at step S347). Thus, the player control module 212 recognizes that the display mode of the fourth subtitle stream stream#3 has been permitted to be changed.<br>
In this case, the player control module 212<br><br>
determines that subtitle stream (subtitle data corresponding thereto) that is being reproduced corresponds to an enlargement mode or a reduction mode and supplies the display mode command that has been input by the user through the remote controller to the graphics process module 219 (at step S349).<br>
Thus, the graphics process module 219 for example enlarges or reduces subtitle data received from the subtitle decoder control module 218 corresponding to the display mode command received from the player control module 212, overlays the resultant subtitle data with video data supplied from the video decoder control module 212, and outputs the overlaid data.<br>
When the player control module 212 starts reproducing the first PlayltemO of PlayListO, the player control module 212 initializes the subtitle data display mode for the graphics process module 219 (at step S341).  In other words, the player control module 212 controls the graphics process module 219 to change the subtitle data display mode to the default display mode.<br>
When PlayltemO 's are changed, the player control module 212 initializes the subtitle data display mode for the graphics process module 219 (at steps S341 and S351).<br>
When PlayltemO 's are changed, the player control module 212 checks configurable flag for a new<br><br>
subtitle stream to be reproduced corresponding to PlayltemO that is newly reproduced. When configurable_flag is 0, the player control module 212 initializes the subtitle data display mode for the graphics process module 219. When configurable_flag is 1, the player control module 212 causes the graphics process module 219 to keep the display mode for PlayltemO .<br>
In the subtitle display control process shown in Fig. 43, when a new display mode command is input by the user through the remote controller, the new display mode command is supplied to the graphics process module 219 (at step S349) . The display mode command may be stored in for example a non-volatile memory that composes the memory 113 (Fig. 1). The display mode command stored in the non-volatile memory may be supplied to the graphics process module 219.<br>
Assuming that a display mode command that the user has set is stored in the non-volatile memory as an initial setting of the disc device shown in Fig. 1, when the user inputs a new display mode command with the remote controller, the display mode command stored in the non-volatile memory is replaced with the new display mode command and the new display mode command stored in the non-volatile memory is supplied to the graphics process module 219.  In this case, since the non-volatile memory stores the display mode command<br><br>
that has been set upon completion of the last reproduction, when the next PlayListO is reproduced, the subtitle data are displayed with the display mode command without need to input the display command through the remote controller.<br>
In this case, it is assumed that the display mode command stored in the non-volatile memory includes for example an enlargement rate or a reduction rate at which a subtitle stream is enlarged or reduced.<br>
As was described above, in the subtitle display control process, it is determined whether the subtitle data display mode is permitted to be changed from the default display mode corresponding to configurable_flag contained in Staticlnfo() for subtitle data that are not changed while elementary streams contained in the clip information file ClipO (Fig. 10) are being reproduced. When the default display mode of the subtitle data that are being reproduced is permitted to be changed, a display process for example an enlargement process, a reduction process, or a color change process for subtitle data is performed. Thus, the subtitle data display mode can be controlled. [Capture Control Process]<br>
Next, with reference to a flow chart shown in Fig. 44, a capture control process that controls capturing of video data corresponding to a video stream<br><br>
will be described.  Fig. 44 also shows a flow chart that describes a background/screen saver process that secondarily uses video data that have been captured in the capture control process.<br>
When a video data capture command is input by the user from the remote controller through the input interface 115 (Fig. 1) to the player control module 212, the capture control process is started.<br>
In other words, in the capture control process, at step S371, the player control module 212 determines whether a video stream is being reproduced. When the determined result at step S371 represents that a video stream is not being reproduced, the player control module 212 completes the capture control process.<br>
In contrast, when .the determined result at step S371 represents that a video stream is being reproduced, the flow advances to step S372. The player control module 212 obtains capture_enable_flag_PlayList from PlayListO (Fig. 5) corresponding to the video stream that is being reproduced and<br>
capture_enable_flag_Clip from the clip information file ClipO (Fig. 10) corresponding to the video stream that is being reproduced.<br>
As was described in Fig. 5,<br>
capture_enable_flag_PlayList of PlayListO represents whether video data (video data contained in PlayListO)<br><br>
corresponding to a video stream reproduced corresponding to PlayList().is permitted to be secondarily used. On the other hand, as was described in Fig. 10, capture_enable_flag_Clip of the clip information file ClipO represents whether video data corresponding to the video stream stored in a clip stream file corresponding to the clip information file ClipO is permitted to be secondarily used.<br>
After step S372, the flow advances to step S373. The player control module 212 determines whether a picture of video data that are being reproduced when the capture command is input from the input interface 115 (Fig. 1) is permitted to be captured corresponding to capture_enable_flag_PlayList and<br>
capture_enable_flag_Clip, which have been obtained at step S373.<br>
When the determined result at step S373 represents that a picture of video data that is being reproduced when the capture command is input from the input interface 115 is not permitted to be captured, namely at least one of capture_enable_flag_PlayList and capture_enable_flag_Clip obtained at step S373 is 0, which represents that video data are not permitted to be secondarily used, the flow advances to step S374. At step S374, the player control module 212 controls the graphics process module 219 to overlay an error message that represents that video data are not<br><br>
permitted to be captured with video data and completes the capture control process. As a result, the error message is displayed.<br>
In contrast, when the determined result at step S373 represents that a picture of video data that is being reproduced when the capture command is input from the input interface 115 is permitted to be captured, namely both capture_enable_flag_PlayList and capture_enable_flag_Clip that have been obtained at step S373 are 1, which represents that video data are permitted to be secondarily used, the flow advances to step S375. At step S375, the player control module 212 supplies the capture command for the video data that are being reproduced when the capture command is input from the input interface 115 to the graphics process module 219. Thereafter, the flow advances to step S376.<br>
At step S376, the graphics process module 219 captures a picture of video data from the video decoder control module 216 corresponding to the capture command received from the player control module 212, stores the picture in the memory 113 (Fig. 1), and completes the capture control process. When capture_enable_flag is composed of a plurality of bits and their use conditions are designated, at this point, a corresponding operation is performed.  In other words, when the size of a capture picture is restricted, a<br><br>
picture whose size is reduced is captured. When an application that is used is restricted, a flag that represents the restriction is also recorded.<br>
As described above, in the capture control process, capture_enable_flag_PlayList's and capture_enable_flag_Clip's of PlayListO (Fig. 5) and the clip information file ClipO (Fig. 10) corresponding to a video stream that is being reproduced when the user inputs the capture command and are ANDed. When the ANDed result is 1, namely both capture_enable_flag_PlayList's and<br>
capture_enable_flag_Clip's are 1, which represents that video data are permitted to be secondarily used, it is determined that video data can be secondarily used. As a result, the video data are captured.<br>
When a video stream is reproduced<br>
corresponding to the first PlayltemttO of the first PlayListttO shown in Fig. 25, namely a video stream multiplexed with the clip stream file "00001.PS" is being reproduced, if the user inputs the capture command, since capture_enable_flag_PlayList of the first PlayListttO is 1 and capture_enable_flag_Clip of the clip information file "00001.CLP," shown in Fig. 26A and Fig. 26B, corresponding to the clip stream file "00001.PS" reproduced by the first PlayltemttO is 1, it is determined that video data that are being reproduced (video data corresponding to a video stream multiplexed<br><br>
with the clip stream file "00001.PS") can be secondarily used and the video data are captured.<br>
While a video stream is being reproduced corresponding to the second Playltem#l of the first PlayList#0 shown in Fig. 25, namely a video stream multiplexed with the clip stream file "00002.PS" is being reproduced, when the user inputs the capture command, since capture_enable_flag_PlayList of the first PlayList#0 is 1 and capture_enable_flag_Clip of the clip information file "00002.CLP," shown in Fig. 26A and Fig. 26B, corresponding to the clip stream file "00002.PS" represented corresponding to the second Playltem#l is 0, it is determined that video data that are being reproduced (video data corresponding to a video stream multiplexed with the clip stream file "00002.PS") cannot be secondarily used and the video data are not captured.<br>
While a video stream is being reproduced corresponding to Playltem#0 of the second PlayList#l shown in Fig. 25, namely a video stream multiplexed with the clip stream file "00003.PS" is being reproduced, when the user inputs the capture command, since capture_enable_flag_PlayList of the second PlayList#l is 0 and capture_enable_flag_Clip of the clip information file "00003.CLP" shown in Fig. 26A and Fig. 26B corresponding to the clip stream file "00003.PS" reproduced corresponding to Playltem#0 of<br><br>
the second PlayListttl is 1, it is determined that video data that are being reproduced (video data corresponding to a video stream multiplexed with the clip stream file "00003.PS") is not permitted to be secondarily used. Thus, the video data are not captured.<br>
In this case, when it has been checked that capture_enable_flag_PlayList of the second PlayListftl is 0, it can be determined that the video data are not permitted to be secondarily used. Thus, checking of capture_enable_flag_Clip of the clip information file "00003.CLP," shown in Fig. 26A and Fig. 26B, corresponding to the clip stream file "00003.PS" reproduced corresponding to Playltem#0 of the second PlayList#l can be omitted.<br>
A picture captured in the capture control process and stored in the memory 113 can be secondarily used in the background/screen saver process.<br>
The background/screen saver process is performed for example while the player control module 212 is operating, but an elementary stream is not being reproduced, namely the disc 101 has not been inserted into the disc drive 102 (Fig. 1) or an elementary stream has been already reproduced.<br>
In the background/screen saver process, at step S381, the player control module 212 controls the graphics process module 219 to display a picture that<br><br>
has been stored in the memory 113 in the capture control process. The graphics process module 219 displays a picture that has been stored in the memory 113 in the capture control process under the control of the player control module 212.<br>
When the graphics process module 219 displays a picture stored in the memory 113 as a still picture, so-called wall paper (background) is accomplished. When a picture is displayed while it is being enlarged, reduced, and moved, a screen saver is accomplished. The background/screen saver process that displays a picture stored in the memory 113 in the capture control process can be performed by another independent application rather than the player control module 212.<br>
When a flag that represents a restriction is added to a picture stored in the memory 113, the picture that is displayed is restricted corresponding to the flag.<br>
As described above, capture_enable_flag_PlayList and<br>
capture_enable_flag_Clip, which represent whether video data being reproduced are permitted to be secondarily used, are obtained corresponding to for example PlayListO or Playltem(), which is larger than a video access unit. Corresponding to capture_enable_flag_PlayList and capture enable flag Clip, it is determined whether<br><br>
video data that are being reproduced are permitted to be secondarily used. When the determined result represents that video data that are being reproduced are permitted to be secondarily used, the video data that are being reproduced are captured and the background/screen saver process using the captured video data is executed. Thus, the secondary use of the video data can be controlled.<br>
In the capture control process shown in Fig. 44, PlayListO (Fig. 5) contains<br>
capture_enable_flag_PlayList and clip information file (Fig. 10) corresponding to a clip stream file reproduced by Playltem() contains capture_enable_flag_Clip. With both capture_enable_flag_PlayList and<br>
capture_enable_flag_Clip, it is determined whether video data are permitted to be secondarily used. Alternatively, when PlayListO (Fig. 5) that contains capture_enable_flag_PlayList and the clip information file ClipO (Fig. 10) corresponding to a clip stream file reproduced by Playltem() that contains capture_enable_flag_Clip, with either capture_enable_flag_PlayList or<br>
capture_enable_flag_Clip, it can be determined whether video data are permitted to be secondarily used.<br>
In the capture control process shown in Fig. 44, at step S376, the graphics process module 219<br><br>
captures only one picture of video data from the video decoder control module 216 corresponding to a capture command received from the player control module 212. Alternatively, the graphics process module 219 may capture a plurality of pictures from the video decoder control module 216.  In other words, a plurality of pictures (a series of a plurality of pictures as a moving picture) that the video decoder control module 216 outputs can be captured.  In this case, the number of pictures captured at a time can be pre-designated. Alternatively, bits of capture_enable_flag_PlayList and capture_enable_flag__Clip can be extended for information that represents the number of pictures that can be captured at a time.<br>
In the foregoing case, use permission information that represents whether video data are permitted to be secondarily used, which are capture_enable_f lag__PlayList and<br>
capture_enable_flag_Clip, is described in PlayListO and clip information file ClipO. With the use permission information, it is determined whether entire video data reproduced corresponding to PlayListO and entire video data corresponding to a video stream multiplexed with a clip stream file corresponding to the clip information file ClipO are permitted to be secondarily used. The use permission information can describe video data of any unit. With the use<br><br>
permission information, it can be determined whether video data in any unit are permitted to be secondarily used.<br>
Fig. 45 shows the syntax of<br>
private_stream2_PES_payload() that contains use permission information. Fig. 46 shows the syntax of au_information() that contains use permission information.<br>
private_stream2_PES_payload() shown in Fig. 45 is the same as that shown in Fig. 23 except that the video_stream_id is immediately preceded by capture_enable_flag_ps2 as use permission information. Likewise, au_information() shown in Fig. 46 is the same as that shown in Fig. 24 except that pic_struct_copy is immediately preceded by capture_enable_flag_AU as use permission information.<br>
capture_enable_fIag_ps2 contained in private_stream2_PES_payload() shown in Fig. 45 represents whether video data of a video stream after PES_packet(} of private_stream_2 that contains private_stream2_PES_payload() before PES_packet() of the next private_straem_2 are permitted to be secondarily used. Thus, with capture_enable_flag_ps2 contained in private_stream2_PES_payload() shown in Fig. 45, it can be determined whether video data after a particular decode startable point before the next decode startable point are permitted to be secondarily<br><br>
used.<br>
In addition, capture_enable_flag_AU contained in au_information() shown in Fig. 46 represents whether video data in each video access unit corresponding to capture_enable_flag_AU are permitted to be secondarily used. Thus, with capture_enable_flag_AU contained in au_information() shown in Fig. 46, it can be determined whether video data in each video access unit, namely in each picture, are permitted to be secondarily used.<br>
At least two of capture_enable_flag_PlayList as use permission information of PlayListO (Fig. 5), capture_enable_flag_Clip as use permission information of the clip information file ClipO (Fig. 10), capture_enable_fIag_ps2 as use permission information of private_stream2_PES_payload() (Fig. 45), and capture_enable_flag_AU as use permission information of au_information() (Fig. 46) can be simultaneously used. In this case, with the result of which at least two of them as use permission information are ANDed, it can be determined whether a picture of video data is permitted to be secondarily used.<br>
As described at step S211 shown in Fig. 36, the video read function portion 233 of the buffer control module 215 (Fig. 3) searches a program stream stored in the buffer 215A for PES_packet() of private_stream_2 that contains private_stream2_PES_payload(), shown in Fig. 23 or Fig.<br><br>
45, which contains au_information() shown in Fig. 46. Thus, when private_stream2_PES_payload(), shown in Fig. 45, which contains capture_enable_fIag_ps2, and au_information(), shown in Fig. 46, which contains capture_enable_flag_AU, are used, the player control module 212 needs to ask the video read function portion 233 for capture_enable_flag_ps2 and<br>
capture_enable_flag_AU to determine whether video data are permitted to be secondarily used.<br>
According to the foregoing embodiment, the sequence of processes are performed by software. Alternatively, these processes may be performed by dedicated hardware.<br>
In addition, according to the embodiment, the video decoder 116 (Fig. 1) is a hardware decoder. Alternatively, the video decoder 116 may be a software decoder. This relation applies to the audio decoder 117 (Fig. 1) .<br>
In addition, according to the embodiment, the subtitle decoder is a software decoder. Alternatively, the subtitle decoder may be a hardware decoder.<br><br><br><br><br>
We claim:<br>
1.	A data processing apparatus which comprises:<br>
decode control means (214) for determining whether an output of the video data is later than an output of the output data;<br>
command means (214) for causing a process for one access unit of the encoded video data to be skipped when the determined result of the first determination means (214) represents that the output of the video data is later than the output of the output data;<br>
decode control means (214) for determining whether the video data are referenced when other encoded video data are decoded corresponding to the reference information of the encoded video of the access unit whose process has been caused to be skipped by the command means; and<br>
video decoder control means (216) for skipping the process of the encoded video data of the access unit whose process has been caused to be skipped by the command means when the second determination means (214) has determined that video data corresponding to the encoded video data of the access unit whose process has been caused to be skipped by the command means are hot referenced when the other encoded data are decoded.<br>
encoded video data obtained by every predetermined unit that is an access unit,<br>
output data that are output in synchronization with the video data, and utilization information immediately followed by at least one decode startable point of the encoded video data and utilized for decoding the encoded video data,<br>
the utilization information containing reference information that represents whether video data corresponding to the encoded video data of at least one access unit that are present from the utilization information to the next utilization information are referenced when other encoded video data are decoded,<br>
2.	The data processing apparatus as claimed in claim 1, wherein<br>
output control means (216) for continuously outputting the video data when the first<br>
determination means (214) has determined that the output of the output data is later than the output of the video data.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LSBhYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">7209-delnp-2006- abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LSBjbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">7209-delnp-2006- claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LSBkZXNjcmlwdGlvbihjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">7209-delnp-2006- description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LSBkcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">7209-delnp-2006- drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LSBmb3JtLTEucGRm" target="_blank" style="word-wrap:break-word;">7209-delnp-2006- form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LSBmb3JtLTE4LnBkZg==" target="_blank" style="word-wrap:break-word;">7209-delnp-2006- form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LSBmb3JtLTIucGRm" target="_blank" style="word-wrap:break-word;">7209-delnp-2006- form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LSBmb3JtLTUucGRm" target="_blank" style="word-wrap:break-word;">7209-delnp-2006- form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LSBwY3QtIHJlcXVlc3QgZm9ybS5wZGY=" target="_blank" style="word-wrap:break-word;">7209-delnp-2006- pct- request form.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LSBwY3QtIHNlYXJjaCByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">7209-delnp-2006- pct- search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LSBwY3QtMzA0LnBkZg==" target="_blank" style="word-wrap:break-word;">7209-delnp-2006- pct-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUFic3RyYWN0LSgwMy0wNS0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Abstract-(03-05-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUFic3RyYWN0LSgyNC0xMS0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Abstract-(24-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUNsYWltcy0oMjAtMDQtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Claims-(20-04-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUNsYWltcy0oMjQtMTEtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Claims-(24-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMDItMTEtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Correspondence Others-(02-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMDMtMDUtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Correspondence Others-(03-05-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMjAtMDQtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Correspondence Others-(20-04-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMjQtMTEtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Correspondence Others-(24-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMjgtMTEtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Correspondence Others-(28-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">7209-delnp-2006-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LURlc2NyaXB0aW9uIChDb21wbGV0ZSktKDAzLTA1LTIwMTIpLnBkZg==" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Description (Complete)-(03-05-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LURyYXdpbmdzLSgyNC0xMS0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Drawings-(24-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUZvcm0tMS0oMDMtMDUtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Form-1-(03-05-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUZvcm0tMS0oMjQtMTEtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Form-1-(24-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUZvcm0tMi0oMDMtMDUtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Form-2-(03-05-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUZvcm0tMi0oMjQtMTEtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Form-2-(24-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUZvcm0tMy0oMjAtMDQtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Form-3-(20-04-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUZvcm0tMy0oMjQtMTEtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Form-3-(24-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LUdQQS0oMjQtMTEtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-GPA-(24-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LWdwYS5wZGY=" target="_blank" style="word-wrap:break-word;">7209-delnp-2006-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LXBjdC0yMzcucGRm" target="_blank" style="word-wrap:break-word;">7209-delnp-2006-pct-237.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LXBjdC0zMzgucGRm" target="_blank" style="word-wrap:break-word;">7209-delnp-2006-pct-338.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1kZWxucC0yMDA2LXBjdC0zNzMucGRm" target="_blank" style="word-wrap:break-word;">7209-delnp-2006-pct-373.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzIwOS1ERUxOUC0yMDA2LVBldGl0aW9uLTEzNy0oMjQtMTEtMjAxMSkucGRm" target="_blank" style="word-wrap:break-word;">7209-DELNP-2006-Petition-137-(24-11-2011).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="257111-a-lyocell-thermoregulatory-fiber-and-a-method-of-making-thereof.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="257113-a-lyocell-perfumed-fiber-and-a-method-of-making-thereof.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>257112</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>7209/DELNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>36/2013</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>06-Sep-2013</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>03-Sep-2013</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>30-Nov-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SONY CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>7-35, KITASHINAGAWA 6-CHOME, SHINAGAWA-KU, TOKYO 1410001, JAPAN</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>YASUSHI FUJINAMI</td>
											<td>C/O SONY CORPORATION 7-35, KITASHINAGAWA 6-CHOME, SHINAGAWA-KU, TOKYO 1410001, JAPAN</td>
										</tr>
										<tr>
											<td>2</td>
											<td>KUNIAKI TAKAHASHI</td>
											<td>C/O SONY COMPUTER ENTERTAINMENT INC., 2-6-21, MINAMI-AOYAMA, MINATO-KU, TOKYO 1070062, JAPAN</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G11B 20/10</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/JP2005/010627</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-06-03</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>2004-174570</td>
									<td>2004-06-11</td>
								    <td>Japan</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/257112-a-data-processing-apparatus by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:48:56 GMT -->
</html>
