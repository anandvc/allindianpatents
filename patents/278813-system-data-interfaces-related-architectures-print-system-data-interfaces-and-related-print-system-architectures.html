<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/278813-system-data-interfaces-related-architectures-print-system-data-interfaces-and-related-print-system-architectures by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:33:17 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 278813:&quot;SYSTEM DATA INTERFACES, RELATED ARCHITECTURES, PRINT SYSTEM DATA INTERFACES AND RELATED PRINT SYSTEM ARCHITECTURES&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;SYSTEM DATA INTERFACES, RELATED ARCHITECTURES, PRINT SYSTEM DATA INTERFACES AND RELATED PRINT SYSTEM ARCHITECTURES&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A system data interface and related architectures are described, Various embodiments can provide one or more of the following capabilities: a generic data model, asynchronous client and server dispatch, cancellation, batching, transactional invocation, parallel invocation, interception or reflection. In one embodiment, the sys&#x27;tem data interface is employed in the context of a print system.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>TECHNICAL FIELD<br>
This invention pertains to system data interfaces and related architectures<br>
and, in particular embodiments, to print system data interfaces and related<br>
architectures.<br>
BACKGROUND<br>
Some systems can include servers that process data and communicate with<br>
various types of clients. One particular type of system is a print system which can<br>
include print servers that provide access to job, device, logical server and forms<br>
data from various clients. Many current systems, such as print systems, have an<br>
inflexible underlying network interface that must be modified whenever new<br>
classes of data need to be supported. In addition, some interfaces require much<br>
more communication than may be necessary and can create context on the server,<br>
both of which can limit server performance in whatever context in which the<br>
server is employed, such as print systems and others.<br>
Other problems that plague many systems can lead to inflexibility,<br>
difficulty in extensibility and limitations insofar as being protocol specific.<br>
Accordingly, this invention arose out of concerns associated with providing<br>
improved systems, including improved data interfaces and related architectures.<br>
SUMMARY<br>
A system data interface and related architectures are described. Various<br>
embodiments can provide one or more of the following capabilities: a generic data<br>
model, asynchronous client and server dispatch, cancellation, batching,<br>
transactional invocation, parallel invocation, interception or reflection.<br>
In one embodiment, the system data interface is employed in the context of<br>
a print system.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
Fig. 1 is a high level block diagram that illustrates various components of a<br>
data interface in accordance with one embodiment.<br>
Fig. 2 is a high level block diagram of a printing data access interface in<br>
accordance with one embodiment<br>
Fig. 3 is a block diagram that illustrates aspects of out of process<br>
communication in accordance with one embodiment.<br>
Fig. 4 is a high level block diagram that illustrates an overview of a security<br>
model in accordance with one embodiment.<br>
Fig. 5 is a block diagram that illustrates a type.mapping mechanism in<br>
accordance with one embodiment.<br>
Fig. 6 is a block diagram of common data interface object access interface<br>
in accordance with one embodiment.<br>
Fig. 7 is a block diagram of a dynamic type map in accordance with one<br>
embodiment.<br>
Fig. 8 is a block diagram that illustrates object creation and cloning in<br>
accordance with one embodiment.<br>
Fig. 9 is a block diagram that illustrates an abstract hierarchy in accordance<br>
with one embodiment.<br>
Fig. 10 is a block diagram that illustrates a class hierarchy and security in<br>
accordance with one embodiment.<br>
Fig. 11 is a block diagram that illustrates metadata that is retrieved from an<br>
object in accordance with one embodiment.<br>
Fig. 12 is a block diagram of exemplary components of a common data<br>
interface in accordance with one embodiment.<br>
Fig. 13 is a block diagram of a plug-in model in accordance with one<br>
embodiment.<br>
Fig. 14 is a block diagram of an object model that is used by a collection<br>
adapter service in accordance with one embodiment.<br>
Fig. 15 is a block diagram that illustrates framework-provided collections<br>
in accordance with one embodiment.<br>
Fig. 16 is block diagram that illustrates interoperability of managed and<br>
unmanaged objects in accordance with one embodiment.<br>
Fig. 17 is a block diagram that illustrates exemplary components of a<br>
computing device that can be utilized to implement one or more embodiments.<br>
DETAILED DESCRIPTION<br>
Overview<br>
In the discussion that follows, a novel system is provided that addresses<br>
many of the shortcomings of current systems. In one embodiment, the system, its<br>
data interfaces and related architectures are described in the context of a print<br>
system. It is to be appreciated and understood, however, that the inventive<br>
features described below can be employed in systems other than print systems,<br>
without departing from the spirit and scope of the claimed subject matter.<br>
While the described print system does many things, fundamentally the<br>
described print system accomplishes a couple of primary tasks. First, the print<br>
system manages data including a set of objects and their properties. Second, the<br>
print system schedules print jobs first for rendering, and then sends the print jobs<br>
to the appropriate print device for printing. The process of rendering a document<br>
can be accomplished by retrieving configuration information from a data interface<br>
which specifies which components to invoke to process the job. Thus, the way the<br>
print system represents data can be fundamental to its operation.<br>
To accomplish these primary tasks, the inventive print system utilizes a<br>
specific interface and related components. This interface and print systems of<br>
which it is a part can provide a number of advantages over current print systems.<br>
In the discussion that follows, various advantages are described to provide a<br>
preliminary appreciation of the print system and interface. Following this<br>
discussion, a section entitled "Exemplary Embodiment" discusses a specific<br>
implementation example of the print system and, in particular, the data interface.<br>
The data interface described below supports the following capabilities, each<br>
of which is discussed and appears under its own heading: a generic data model,<br>
asynchronous client dispatch, asynchronous server dispatch, cancellation,<br>
batching, transactional invocation, parallel invocation, interception and reflection.<br>
Generic Data Model<br>
The described data interface supports and can be used in connection with<br>
what can be considered as a generic data model. The data model can support<br>
classes of objects with the following capabilities:<br>
• Properties - any object can have an arbitrary set of properties. The<br>
client can specify any set of properties to retrieve from any object.<br>
Only the properties the client is interested in will be retrieved.<br>
• Commands' - any object can support a set of commands with an<br>
arbitrary set of parameters.<br>
• The wire format does not need to be modified in order to arbitrarily<br>
extend the class, commands and properties available from the server<br>
to the client.<br>
Asynchronous Client Dispatch<br>
Asynchronous client dispatch refers to the ability of the data interface<br>
application program interface (API) to allow a client or client application to begin<br>
a data request which immediately returns control to the client thread, as will be<br>
appreciated by the skilled artisan. When the result of the operation is complete,<br>
the client is informed via a call-back or a system event being signaled and it can<br>
the retrieve the result of the data. In the illustrated and described embodiment, this<br>
capability is not provided as a trivial wrapper that spins a thread which blocks<br>
synchronously and allows the client to proceed. Rather, the asynchronous dispatch<br>
is extended down to the device level. At a low level, the result of the call is<br>
interrupt driven by the network card. Utilizing this model simplifies designing<br>
client user interfaces that remain responsive while retrieving data from the server.<br>
It also reduces the number of threads required on a client. This is particularly<br>
advantageous when the client system is a print system acting as a bridge to another<br>
print system.<br>
Asynchronous Server Dispatch<br>
Coupled with the ability of a client to dispatch requests asynchronously to<br>
the server, the server can service requests asynchronously from the client. If an<br>
action that a client requests the server perform is IO bound (e.g., it needs to write<br>
data to a disk, or request data from another server), a plug-in component can issue<br>
another asynchronous call, return control to the server side data interface, and then<br>
complete the call when the IO completes. This mechanism can dramatically<br>
reduce the number of threads running on the server and can ensure that all threads<br>
are fully utilizing the system CPU.<br>
Every thread executing on a system takes a large amount of "non-paged<br>
pool" from the system (non-paged pool is memory mat cannot be written out to<br>
disk when physical memory become limited). Each thread running in the system<br>
that acquires system locks also creates a large amount of "contention" in the<br>
system (this is the amount of time and CPU resource required to switch between<br>
threads of execution). Thus, reducing the number of threads running in the system<br>
is an important mechanism to improve system performance.<br>
Cancellation<br>
In the embodiment described below, calls which are in progress on the<br>
server can be cancelled by the client at any time. This helps a client provide an<br>
interactive user interface to a caller.<br>
Batching<br>
Batching refers to a client's ability to use the data interface to build up an<br>
arbitrary sequence of actions and have the sequence of actions sent to the server as<br>
a unit This sequence is then processed and returned to the client in a single<br>
transfer response. The actions can include any type of action such as getting and<br>
setting properties, querying for a set of properties, issuing commands against<br>
server objects, and registering for notifications about server object properly<br>
changes.<br>
Transactional Invocation<br>
Transactional invocation refers to a batch being assigned the semantics that<br>
it must execute entirely, or not change the state of the server.<br>
Parallel Invocation<br>
Parallel invocation refers to a batch being assigned the semantics that all<br>
items in the batch must execute in parallel. This allows the server to execute longrunning<br>
actions in parallel, and it also provides the semantics that the batch will<br>
execute all actions regardless of what other actions fail.<br>
Interception<br>
Since the operations and properties that the system can support are<br>
represented by pure data transfers, other components can be inserted in the system<br>
that can monitor, synchronously respond to and modify the behavior of the system<br>
- referred to as interception. This allows monitoring software to be plugged into<br>
and removed from the system. It also allows an independent hardware vendor<br>
(IHV) to extend system behavior. For example, if a queue is stopped, an<br>
associated service might also need to be stopped. The "stop" command on the<br>
queue can be intercepted by the IHV and they can then ensure that the service is<br>
stopped before allowing the stop operation to complete. The interception<br>
mechanism can also provide transactional semantics.<br>
Reflection<br>
Reflection refers to the system's provision of a mechanism to retrieve<br>
which -properties are supported by a given class of object, as well as other<br>
information associated with the object. Information that can be retrieved using<br>
this mechanism can include, without limitation:<br>
• the type name, field name and data-type of each property;<br>
• a human-readable description of the properties usage;<br>
• commands supported by an object, and the input and output<br>
parameters supported by the command. Each command has a<br>
human-readable description of the command's usage. For each<br>
parameter, the following data can be retrieved: the name and type of<br>
the parameter and a human-readable description of the parameter.<br>
In the illustrated and described embodiment, the reflection capabilities of<br>
the system are protocol agnostic. In addition, the reflection capabilities can be<br>
used to and from both native code and managed code implementations of server<br>
plug-ins. Further, the reflection capabilities provide the ability to perform<br>
reflection over a network interface, and do not require the implementation of the<br>
server-side objects to be present on the client.<br>
These and other capabilities will become apparent from the description<br>
below.<br>
Exemplary Embodiment<br>
In the discussion that follows, a high level discussion of the inventive<br>
interface is provided in connection with Fig. 1. Following this discussion, an<br>
implementation example is provided and contains implementation-specific<br>
information. It is to be appreciated and understood that the implementationspecific<br>
example is provided as but one example of how one might implement a<br>
print system that includes the capabilities described above. As such, other<br>
implementations can be utilized without departing from the spirit and scope of the<br>
claimed subject matter. The other implementations may or may not be employed<br>
in the context of print systems, as noted above.<br>
Fig. 1 shows a system generally at 100 that includes a common data<br>
interface 102, a batching router 104 that includes a plug-in table 106 and an<br>
interception table 108. System 100 also includes a message plug-in 110, message<br>
services 112, a collection 114, various objects 116, system extensions 118 and socalled<br>
"other collaborations" 120, each of which is discussed below.<br>
Common Data Interface (GDI)<br>
The Common Data Interface (GDI) is the interface to the batching router<br>
104 and allows messages to be built up and dispatched to the batching router. The<br>
GDI is also responsible for sending responses to the client.<br>
Batching Router<br>
Batching router 104 receives messages that are packaged and passed into<br>
the system by the GDI 102. Each message can include a number of operations that<br>
can be destined to a number of plug-ins. These messages are dispatched<br>
asynchronously and the results are retrieved by the batching router 104 in turn.<br>
Messages are routed based on an unambiguous path (hat identifies which<br>
collection the message should be sent to. A single message from the client's<br>
perspective might have multiple destinations.<br>
Plug-In Table<br>
The plug-in table 106 keeps track of all of message handling plug-ins which<br>
are responsible for a given collection of objects. Each collection is identified by a<br>
Globally Unique Identifier (GUID). A path to the object is inspected and looked<br>
up in the plug in table before the messages are passed down to it.<br>
Message Plug-In<br>
Once the appropriate collection has been identified, the set of messages are<br>
passed to the message plug-in 110. The message plug-in 110 might simply send<br>
these messages out remotely over the wire to another machine. More typically,<br>
however, the message plug-in 110 will interpret the messages and respond<br>
appropriately, hi the illustrated and described embodiment, third parties can<br>
provide message plug-ins. However, when they do so, the services provided by<br>
the message services are not available to them. This will make plugging in at this<br>
layer much more difficult. A primary advantage of being a message plug-in is that<br>
the form of the original message is made available. This can be useful for<br>
10<br>
allowing the entire message to be relayed to a remote machine by a plug-in<br>
collection. This could, in addition, be an advantage for an independent hardware<br>
vendor if they also had a remote system that supported batching and they wanted<br>
to be able to translate between the received message format and their own message<br>
format<br>
Message Services<br>
Since one of the main problems in a message based system is the difficulty<br>
in maintaining state over message calls, a component - the message services<br>
112—is provided to break down messages and translate them into a simpler<br>
sequence of calls on a collection interface. By way of example and not limitation,<br>
in the illustrated and described embodiment, the message services can perform the<br>
following tasks:<br>
Assign messages to threads;<br>
Allow messages to be responded to in multiple, deferred calls;<br>
Retrieve the appropriate data from the objects in the collection to<br>
populate the message;<br>
Handle operation cancellation correctly;<br>
Caching of object instances over time;<br>
Transparent locking of objects; and<br>
Reflection services for the objects maintained in the collections.<br>
Collections<br>
Collections 114 maintain a homogenous set of objects. The system will<br>
provide a collection that allows objects to persist themselves easily. One<br>
advantage of using collections is that it allows independent hardware vendors to<br>
easily extend the system with arbitrary objects. In the illustrated and described<br>
embodiment, a collection is implemented as a COM interface that is retrieved<br>
from a dynamic link library (DLL). The DLL is looked up in a Global Assembly<br>
Cache and a direct call is made to DllGetClassObject, which allows one to avoid<br>
COM registration, as will be appreciated by the skilled artisan.<br>
Objects<br>
One goal of the system described above and below is to allow independent<br>
hardware vendors and other developers to largely be able to code at the level of<br>
classes, with direct support for their implementation language. The goal is to<br>
consolidate as much code as possible into the collections to reduce the total<br>
amount of code that independent hardware vendors and other developers have to<br>
write. An object 116 is a logical construct maintained by a collection. The<br>
message services 112 provide a layer where these objects correspond directly to<br>
C++ classes.<br>
Interception Table<br>
The interception table 108 provides a general, universal, extension<br>
mechanism to the print system. The goal here is to allow extensions to be able to<br>
intercept and modify messages targeted to any object in the system, to objects of a<br>
particular class or to a particular obj ect instance.<br>
System Extensions<br>
As most everything in the system originates from a central message system<br>
and is represented by messages, system extensions 118 permit the system to be<br>
extended, and most especially monitored by third parties, in any way they see fit.<br>
These extensions also provide for useful monitoring extension by the spooler team<br>
itself.<br>
Other collaborations<br>
It will be appreciated that not all of the system behavior can be expressed as<br>
a data-driven messaging system. As such, there are and will be other<br>
collaborations 120 between objects that create other sub-systems in the machine.<br>
These can include, for example, pipelines and the scheduler. The goal here is to<br>
make all of the collaborations as flexible as possible to allow other parties to plug<br>
into the system.<br>
The way that these other sub-systems maintain coherency with the GDI<br>
view of the system is by invoking factory objects through the GDI that either<br>
create the object directly, or return the appropriate data to allow the object to be<br>
instantiated. Using this pattern has the result that system extensions can intercept<br>
these calls to the factory objects and they can implement the factory and wrap the<br>
original interface. This means that system extensions can monitor or modify any<br>
aspect of the system. This is very useful to allow plug-able monitoring<br>
components to be inserted in the system at arbitrary points.<br>
Having now provided a high level discussion of the inventive interface, the<br>
following section describes an implementation example contains implementationspecific<br>
information. As noted above, it is to be appreciated and understood that<br>
the implementation-specific example is provided as but one example of how one<br>
might implement a print system in accordance with the inventive principles<br>
described herein. As such, other implementations can be utilized without<br>
departing from the spirit and scope of the claimed subject matter.<br>
Implementation Example<br>
Preliminarily, the following glossary of terms and acronyms will be used<br>
throughout the discussion that follows:<br>
• Action - See Batch.<br>
• Access Adapter - See Data Access Adapter.<br>
• Accessor - A method used to retrieve data from an object. A .Net<br>
property is an example of an accessor.<br>
• Batch - A sequence of Actions that are executed at one point after<br>
being accumulated. A batch will typically result in one network call.<br>
Actions can be Gets, Sets, Queries, Commands and Notification<br>
requests.<br>
• Batching Collection - The highest level interface that plugs into the<br>
Batching Router. It receives an appropriately routed Batch of<br>
Actions to perform.<br>
• Batching Router - The element in the GDI that selects which of a<br>
set of Collections to pass Actions in a batch to.<br>
• Canonical Name - A name that uniquely identifies an object<br>
instance in time and space. In the GDI this will be a collection GUID<br>
and an object GUID. The GDI routes based on Canonical name only.<br>
Applications should use canonical names where-ever possible when<br>
communicating with the system. See Friendly Name.<br>
• CDI - See Common Data Interface.<br>
• Class — In the GDI, a kind of object. A class could be a printer, a job<br>
or a server or any other logical division. A class consists of Types.<br>
• Client Collection - A collection of objects maintained on the client.<br>
The CDI populates the objects in the client collection based on their<br>
Type Maps.<br>
14<br>
• Collection - A heterogeneous set of objects provided by one logical<br>
piece of code. The GDI routes requests to multiple collections based<br>
on canonical name.<br>
• Collection Adapter Service - A service that exposes a Batching<br>
Collection interface to the Batching Router and implements<br>
services to allow a set of objects to be exposed with less effort.<br>
• Command - A kind of Batch action that causes a Method on an<br>
object to be executed when the batch is finally sent to the server.<br>
• Common Data Interface - A component that allows access to<br>
objects via a canonical name. It also provides support for batching<br>
calls together and asynchronous or synchronous access to the<br>
objects.<br>
• Data Access Adapter - A data access adapter plugs into the GDI<br>
and translates its capabilities in some way. This could be to<br>
transform the interface exposed by the GDI to another one (an Inproc<br>
Adapter), or it could be to remote the GDI, in which case it is<br>
a Remote Access Adapter.<br>
• Display Name - See Friendly Name.<br>
• Embedded Types - An object in a Collection that is used to<br>
dynamically extend the properties supported by another object in<br>
another collection.<br>
• Field — A named piece of data.<br>
• Friendly Name - Also known as Display Name. A Friendly Name<br>
is the name that a user associates with an object (Fred's Printer) as<br>
opposed to the Canonical Name that is used by the system to identify<br>
the object instance, hi order to allow Friendly Names to be<br>
converted to canonical names, the GDI provides a Name Resolution<br>
Pipeline.<br>
• Hierarchy - In the GDI it is an arbitrary relationship between parent<br>
and child objects that can be obtained by querying for Links from<br>
the parent object.<br>
• In-proc Adapter - A form of Data Access Adapter that runs inproc<br>
with a GDI instance running in the application. These will<br>
typically just transform the data in some way. For example, by<br>
providing APIs to access the data.<br>
• Link ~ A special reserved Class that is used for querying for<br>
hierarchical relationship between objects.<br>
• Metadata - Not to be confused with reflection in the CLR.<br>
Metadata can be queried from any object to discover the Types,<br>
Fields and Commands it supports. It can be retrieved whether a<br>
corresponding assembly is available on the client or not.<br>
• Method — An actual piece of code on an object that gets executed<br>
when you call that object. See Command for a slightly different<br>
concept.<br>
• Name Resolution Pipeline - A sequence of elements called<br>
Resolvers that run in the application space to convert a friendly<br>
name to a canonical name.<br>
• Optimized Type Map - A sequence of gets and sets to be<br>
performed against two objects to transfer a set of fields from one<br>
object to the other. This is built be combining the fields of a client<br>
object's Type Map and a server object's Type Map.<br>
• Persistent Object Collection Service - A service that plugs into the<br>
Collection Adapter Service that allows objects to be persisted to a<br>
database.<br>
• Query — Jh the context of the GDI, a request for a set of objects of a<br>
given class with an optional filter and an optional Query Base.<br>
• Query Base — The conceptual point at which a query begins. For<br>
example, a base might be the local machine or a given server.<br>
• Remote Access Adapter - A remote access adapter allows the<br>
interface exposed by the GDI to be remoted between machines. It<br>
does this by appearing as a collection of objects to one GDI and a<br>
Data Adapter to the GDI being remoted.<br>
• Resolver - An element in the Name Resolution Pipeline. Each<br>
resolver is associated with a Collection and knows how to identify<br>
elements inside it.<br>
• Type Map - A table of fields and their correlated Accessors that<br>
describes how to retrieve data from an object or apply it to an object.<br>
Type maps can be dynamic or static. Two type maps are combined<br>
by comparing fields to produce an Optimized Type Map.<br>
• Type - Analogous to an interface. A type is a logical group of<br>
Fields and Commands that must always be implemented<br>
completely.<br>
Common Data Interface<br>
The common data interface (CD!) provides functions that include locating<br>
an object by name (friendly or preferably canonical), obtaining data from the<br>
object or applying data to the object, supporting notifications on object changes<br>
and issuing a command to an object. The GDI address and overcomes many<br>
limitations of contemporary architectures including, without limitation, the use of<br>
synchronous interfaces, the lack of extensibility, name based routing and lack of<br>
batching, to name just a few.<br>
The GDI does this by allowing an arbitrary number of uniquely identifiable<br>
collections to be plugged into the system. These collections can support any kind<br>
of object that they wish, The interface itself is reasonably complex in order to<br>
support asynchronous operations and batching, but services are provided and<br>
allow plugged in collections to be written more easily.<br>
Router Re-architecture<br>
A large number of the fundamental problems in current spooler<br>
architectures derive from the router. This includes the use of a synchronous API<br>
•&gt;.<br>
set, the necessity to load all of its providers (and monitors) at start up, the inability<br>
to rename objects, the inability to unload any of the spooler components and the<br>
inability to shut down the system. This section describes a replacement<br>
architecture for routers in the inventive print system.<br>
The following discussion is based on the overview diagram shown in Fig.<br>
2. In this example, the router is replaced by a much more flexible data access<br>
mechanism, the Common Data Interface (GDI). The GDI fundamentally is a<br>
routing and service layer between an Access Adapter and a Collection. It provides<br>
for the ability to locate print objects on any system via multiple protocols and it<br>
also provides a set of services to allow all objects to have the same semantics.<br>
These semantics are the ability to retrieve and set a subset of the objects data, the<br>
ability to query all objects for their status, the ability to issue commands to the<br>
object and the ability to send change notifications consistently from all objects in<br>
the system. The data access Adapters are divided into in-proc Adapters and<br>
remote access Adapters.<br>
In the illustrated and described embodiment, all internal components and<br>
applications (except for Collection Providers and Access Adapters) interface only<br>
with the In-proc Adapters. For communication across process boundaries and<br>
client-server communication the COM/DCOM remote access adapter is used. For<br>
web-service based scenarios, a SOAP adapter is used. Adapters appear in turn as<br>
collections in other process spaces, or on other machines. This allows any access<br>
Adapter that can fully support the Common Data Interface to always be accessible<br>
through an in proc Adapter. The overview of this connectivity scheme is shown in<br>
Fig. 3.<br>
Down-level and up-level Protocol Access<br>
An up-level Adapter is any Adapter that can entirely encapsulate the full<br>
Common Data Interface — the only full in-proc Adapter will be the attribute based<br>
managed code Adapter. The Managed APIs to the system will only represent a<br>
useful application subset of the system capabilities. There will be two types of full<br>
remote access Adapters including the out of proc COM Adapter used for<br>
communication on the local machine and in client-server based scenarios and the<br>
SOAP remote access Adapter which will provide access to the data via a web<br>
service.<br>
Other candidates for Adapters are Adapters that can use the full power of<br>
the Common Data Interface, themselves only expose limited data types, but where<br>
these can be mapped in an entirely data driven way. For example, the mapping<br>
between a MOF file data-type and a Common Data Interface data-type could be<br>
made entirely data driven. MOF files are used by the Windows© Management<br>
Instrumentation (WMI) system to describe system objects.<br>
Other, less flexible, protocols would most likely use the in-proc Adapter to<br>
communicate with the print system components, for example, RFC clients would<br>
communicate with the new print system via the OH- template library,<br>
Support for down-level providers will be simplified by providing an inmemory<br>
collection and allowing a user to write a managed class and object<br>
adapter to provide data to the system. A down-level provider will have to support<br>
a certain limited subset of types to be useable by the system.<br>
Common Data Interface Object Model<br>
In the illustrated and described embodiment, the common data interface<br>
(GDI) has properties as follows. The GDI supports getting and setting individual<br>
properties on an object. It also supports querying for groups of objects based on a<br>
query filter and a set of properties to retrieve from each object. The GDI supports<br>
asking an object to execute a command, passing a set of parameters to it and<br>
receiving a set of return parameters from it. Further, the GDI supports requesting<br>
notifications for object changes. The notification includes a filter and a set of<br>
properties that the caller wishes to be notified about. In addition, the GDI is inproc<br>
only, and the ability to remote the interface is provided by the appropriate<br>
plug-in Adapters. The GDI uses callbacks for notifications; notifications provide<br>
for some difficult trade offs since connections maintained by clients dramatically<br>
reduce server scalability. To solve this problem, two classes of notification can be<br>
used: first, management notifications can maintain a connection to the server<br>
using an asynchronous interface. These notifications will be used for frequently<br>
changing data that tend to have a management purposes, for example a view of the<br>
jobs in a logical queue; second, status change notifications can use a TTL scheme<br>
and a messaging system (e.g. MSMQ) to send less frequent notifications with<br>
delivery guarantees. Since the notification mechanism will support server side<br>
queries, commonly needed user notifications will be implemented by specifying a<br>
server side query and using a guaranteed delivery mechanism.<br>
Further, the GDI is. based on Accessors. It does not expose a dictionary<br>
interface. Rather, query mechanisms are provided to obtain data and the ability to<br>
retrieve object metadata to emulate a dictionary interface. The GDI also<br>
aggregates a number of collections of objects together. Up-level collections are<br>
used to provide foil query support. Down-level collections are used to provide<br>
enumeration support, since all print collections should look alike; a query is built<br>
by enumerating all objects and applying a filter to them. Any method that is not<br>
CPU bound, can be called asynchronously.<br>
The common data interface allows access to collections of objects. All GDI<br>
objects are accessed through a collection. Every collection allows access to a set<br>
of object classes. An object class identifies the class of object, for example, a<br>
logical device, a protocol adapter, a logical server. An object class is identified by<br>
a programmatic name. The programmatic name must be of the form<br>
<company>.<class>[.<version>]. This name can be used in any locale to identify<br>
the object. The string can be implemented as a Unicode string, although in other<br>
implementations it can comprise an English identifier.<br>
In the illustrated and described embodiment, a particular class of object will<br>
always be identified by the same programmatic name over the entire lifespan of<br>
the system, including any previous versions of the server, or any collections<br>
representing a down-level server.<br>
A given object class consists of a number of types. A type is identified by a<br>
Programmatic Name in the same way that an object class is. A type consists of a<br>
number of fields - each field is identified by a programmatic field name and a field<br>
type. The fields in a type must be invariant across all versions of the operating<br>
system and on any platform. A type also encapsulates commands as well as fields.<br>
A command is identified by a string and it takes a number of ordered input and<br>
output arguments.<br>
The GDI will allow the interception and extension of the messages sent<br>
through the GDI by third parties. This will allow these parties to monitor and<br>
extend the object capabilities. Objects will also be allowed to redirect certain calls<br>
to contained objects.<br>
Object Naming<br>
In the illustrated and described embodiment, objects always have a unique<br>
canonical name that identifies precisely that instance of the object - the only<br>
exception to this rale will be for collections that represent objects on a down-level<br>
server.<br>
An object is identified by an object path. The object path always begins<br>
with the GUID of the collection instance in which it is contained, so:<br>
{XXXXXXX}\{YYYYYY} refers to the object with GUID {YYYYY} in<br>
collection {XXXXX}. For objects on an up-level server, the path would be:<br>
{WWWWW}\<server>\{XXXXX}\{YYYYY} where {WWWW} is the remote<br>
collection GUID, and {XXXXX} is the remote collection in which the object<br>
{YYYYY} is located.<br>
Every GDI instance supports the concept of a default collection which is<br>
analogous to the current path in the file system. Thus, a GDI hosted in the<br>
application space can have its default collection set to the spooler on the local<br>
machine, as could all of the satellite sandbox processes and app-domains. Any<br>
object canonical name without a folly qualified path will automatically be<br>
searched for in the default collection. If a collection implemented in. the<br>
application space (for example, direct network access to a server bypassing the<br>
local service) is to be accessed, then a fully qualified path (i.e. one beginning with<br>
a *V) should be used.<br>
In the illustrated and described embodiment, the following are reserved<br>
characters in an object path: '\'t, ':y"VA' and V.<br>
The caret character (A) is used to escape a succeeding character and allows<br>
any character to be represent-able in a string. Valid escapes are shown in the table<br>
just below.<br>
Character Escape<br>
Thus, in order to separate an object name that must contain a 'V in the path,<br>
the 'V could be escaped by 'AV.<br>
Friendly names and name resolution pipelines<br>
Objects can also optionally be given a friendly name (or display name).<br>
Objects should always be located using the following mechanism:<br>
For display purposes, a baseless query for the object class should be<br>
made against the service. All local objects matching this class will<br>
be returned. The UJ from then should use the canonical name of the<br>
returned objects and show the class display name.<br>
For names that might be directly typed into the user interface<br>
(including remote server UNC names), a sequence of pluggable<br>
components called name resolvers can be provided. The application<br>
calls these in order to resolve a "friendly name" to a canonical name.<br>
Existing APIs will use the name resolver to convert friendly name<br>
based calls such as OpenPrinter and ClosePrinter into the canonical<br>
name form (since name resolution is likely to be slow, a caching<br>
layer will have to be introduced).<br>
The sequence of name resolvers will imply the priority of a given<br>
name mapping. For example, when a remote UNC name is upgraded<br>
to a connection, the same name will resolve to the logical queue<br>
object in the local collection rather than the queue object<br>
representing the remote queue.<br>
The application can choose to only have the most full featured name<br>
binding returned to it or to have all the name bindings for a friendly<br>
name returned to it. It will be more expensive to return all the<br>
possible name binding since it might require loading many<br>
collections to resolve.<br>
Having the name resolution elements prevents the entire collection<br>
being loaded unnecessarily, unlike hi the current router architecture.<br>
Every collection wanting to support a friendly name for their objects<br>
will have to implement a name resolving element too.<br>
The application will also be allowed to specify intent when it<br>
performs the name resolution. For example, a management<br>
application might specify that it only wants non-cached information.<br>
In this case, a non-cached object will be returned even if it is less<br>
capable that the cached version.<br>
Security<br>
In the illustrated and described embodiment, security is intimately tied into<br>
the service layer that will be provided by the system. But an overview of how<br>
security will work is presented here because it is an important topic and a global<br>
overview of the model is desirable before the implementation is discussed.<br>
Fig. 4 shows a conceptual diagram of a new spooler security model in<br>
accordance with one embodiment. One goal of the new spooler security model is<br>
to keep the GDI as a lightweight internal interface to objects, so it does not<br>
perform any authentication function. 3h addition, the GDI can route data via a<br>
remote collection to a server. Authorization is then performed by the seryer. So,<br>
in accordance with this embodiment, the GDI routing layer will not provide an<br>
authorization function. Finally, the GDI will also execute in the application space<br>
where neither authentication nor authorization are required.<br>
Thus, authentication is performed by a remote access adapter in a way that<br>
is consistent with the access transport and protocol and authorization is performed<br>
by the appropriate collection service (or deferred to the remote server). One<br>
consequence of this approach is that the GDI and all of the collections can be<br>
access by an un-authorized user. To help alleviate this, a Logical System object<br>
provides an access control list (ACL) that controls access to the entire print system<br>
for the machine. When a batch of commands is received by the remote access<br>
Adapter it performs an access check on the logical system object. The commands<br>
(as well as gets, sets and queries) are only allowed to execute if the access check<br>
succeeds. This operation is performed once for any batch command received by<br>
the remote access Adapter. In the illustrated and described embodiment, the<br>
logical system ACL defaults to "Everyone" (but not "Anonymous"). The<br>
administrator is allowed to change the logical system permissions to restrict access<br>
to the entire print sub-system.<br>
In the illustrated and described embodiment, there is a special reserved<br>
system reset command on the logical system object that the remote access adapter<br>
is required to pass through without authorization to the Logical Machine object.<br>
The Logical Machine Object allows only Administrators to execute this command<br>
and it adds Administrators back to the Logical Machine ACL. This mechanism<br>
prevents an Administrator from denying him or herself permission to the Logical<br>
Machine object which would result in the Administrator never being able to access<br>
the subsystem again.<br>
In the illustrated and described embodiment, every object in the local<br>
collections has an ACL associated with it. An access check on an object consists<br>
precisely in checking access against its ACL. Each object instance has a class<br>
object that will provide a default inheritable ACL for a new object of that class,<br>
and the GDI maintains a collection of the class objects. The administrator is free to<br>
modify the class ACL which will provide a default ACL for any new object of the<br>
given class. This allows the administrator to delegate creation rights to an object to<br>
another user, but still apply a default ACL to the object when created.<br>
In the illustrated and described embodiment, the GDI provides a service<br>
layer to allow a local collection of objects to be written as easily as possible. The<br>
service layer provides the security infrastructure to any object implementation that<br>
uses it for free.<br>
Not shown in Fig. 4 is a permissions agent which recursively applies a new<br>
ACL to all participating classes when a permission changes. This agent is<br>
responsible for propagating changes to the class object to instances of the class<br>
and it is also responsible for propagating any administrative hierarchy changes to<br>
the object instances.<br>
The GDI Accessor Model<br>
One of the more fundamental aspects of this interface is the Accessor<br>
model. This mechanism allows the Common Data Interface and a collection to<br>
populate the caller's data structures. In the illustrated and described embodiment,<br>
the GDI accessor model is unmanaged since the print spooler with which it is<br>
intended to operate consists of an unmanaged core service. Since some<br>
components of the print system will be managed and will want full access to the<br>
data in the print system, there is also a managed code access layer.<br>
The idea behind the GDI Accessor model is that the GDI is a broker<br>
between a collection of client objects and multiple collections of server objects. It<br>
provides an efficient mechanism for the client and the server to exchange this<br>
information using only fields that each party wants to transfer.<br>
As an example, consider Fig. 5 which shows aspects of how this<br>
functionality can be implemented, in accordance with one embodiment, in the<br>
context of a server collection, a client collection and the GDI.<br>
In this example, the server and the client both describe the data they wish to<br>
expose or retrieve via the same mechanism—a type map. A type map describes the<br>
various subtypes and fields that each object supports. For each field, an interface is<br>
provided that knows how to get or set the given property for every instance of the<br>
class that it describes. So, given a type map, all of the properties of a class<br>
instance can be accessed.<br>
Given a description of a client and a server class, the GDI can perform an<br>
elegant optimization. Specifically, the GDI can match each field and type from<br>
the client type map and server type map and create an optimized type map which<br>
consists only of the access interfaces. When this optimized type map is executed<br>
on two object instances, all of the requested data is transferred between the two<br>
objects without any intermediate storage, or any look up of data. The goal of the<br>
optimized type map is to take advantage of the fact that the target objects have a<br>
regular structure. For a given collection, the server side objects have a regular<br>
structure. And, for a given query, the same data is generally desired from all of the<br>
objects in the system. Thus, the binding between a particular class of a source<br>
object and a particular class of destination object is always the same. In addition,<br>
since the source and destination objects are ultimately system components and are<br>
themselves regular structures, each object instance can be stored in a lightweight<br>
way.<br>
Consider further that this would be sufficient if there were only one server<br>
object that data could be retrieved from. In practice however, there could be a<br>
number of implementations of a compatible server object and each will have a<br>
type map. Thus, when the client registers its type map with the GDI, the GDI<br>
creates a storage space for optimized type maps that can be looked up by GUID.<br>
The server side then stores each optimized map as necessary. The goal is that the<br>
client registers its maps at application start up time. The system then builds up a<br>
set of optimizations around that particular client type as the client starts retrieving<br>
data.<br>
Template derived type maps<br>
Creating the access objects for a class instance can result in a lot of code<br>
being written because each instance behind each interface knows how to access<br>
only one property. A good deal of work can be saved by allowing each instance to<br>
access properties in the server and client using data (for example, field offsets can<br>
be used to access fields genetically across many objects). Doing this dramatically<br>
reduces the number of access object implementations that must be coded.<br>
In the illustrated and described embodiment, the GDI also provides a<br>
template library that allows a user to define a class, create a number of methods or<br>
fields and then write a table exposing any fields or methods they want defined.<br>
The template mechanism extracts the type information directly from the class field<br>
types or method signatures and builds the access object instances automatically.<br>
This allows a client (or server) to expose an object without having to write DDLs.<br>
The object can then be supported across any transport supported by the print<br>
system and will automatically receive the benefits of asynchronous invocation.<br>
The code excerpt just below shows the simplest mechanism to define a<br>
structure that the client wants to retrieve from the server, error handling is omitted.<br>
In the illustrated and described embodiment, the template library supports a<br>
core set of mappings from GDI types to C++ types. The library is extendable by<br>
third parties, so new types can be introduced or refined at any tune without<br>
changing any part of the template library at all.<br>
Using the Common Data Interface<br>
The material presented in this section expands upon the material described<br>
above, but does so at a much lower level. The remainder of the document is<br>
devoted to a low level description of the use and implementation of the GDI in<br>
accordance with one embodiment<br>
GDI Types<br>
The GDI type system is designed to support a number of standard types that<br>
the system provides guarantees for (for example, they will work over any protocol<br>
supported by the system and most can be used for queries). The GDI type system<br>
also provides mechanisms to create new types at design time and use them in the<br>
system at run time.<br>
To this end, an ImgVariant type is defined as shown in the code excerpt just<br>
below. Liie the system variant, it has a type and an unnamed union. However it<br>
supports a very different set of basic types to a system variant, as shown by the<br>
table that follows.<br>
(Figure Removed)<br>
Another difference is that the ImgVariant type is extensible. This is<br>
accomplished by defining the LngType not as a union, but as a pointer. This<br>
declaration is shown in the code excerpt just below.<br>
(Figure Removed)<br>
In order to reserve ah enumeration for a new type, one defines an<br>
ImgTypeReservation global variable, and its address becomes a guaranteed unique<br>
identifier for the defined type. Similarly the system will define its own types as<br>
globally unique pointers. This uses the loader to guarantee that the types do not<br>
collide across any address space.<br>
In the illustrated and described embodiment, the print system provides the<br>
following methods to manipulate variants.<br>
(Figure Removed)<br>
New GDI Primitive types<br>
The GDI ImgVariant type itself can contain some new types defined by the<br>
GDI. These are, in order:<br>
IlmglmutableString<br>
This is a ref-counted string. This type will be freely converted to or from a<br>
B STR by the GDI and it provides for efficient manipulation of strings. Its interface<br>
and creation function is shown in the code excerpt just below.<br>
(Figure Removed)<br>
The Value method returns a pointer to the string maintained inside the<br>
immutable string. The caller must not modify the value, but is free to read it. Its<br>
address will not change and it will not be freed or modified while the string<br>
reference is maintained.<br>
The Newlnterface method allows the caller to request a new interface to the<br>
same string. This is useful to isolate reference counting problems. The caller can<br>
request a single threaded interface to the string, hi this case, the reference counting<br>
on the new interface will not be interlocked. If a caller knows that it will be doing<br>
a lot of manipulation of the string in a single threaded context, this can allow them<br>
to improve their performance. The initial string created by ImgCreateString is<br>
always free threaded.<br>
IlmgCanonicalName<br>
This type is used internally and by plug-ins to provide a canonical name<br>
reference to other types. This type is illustrated in the code excerpt just below.<br>
(Figure Removed)<br>
A canonical name consists of the parsed elements of an object path. Each<br>
element is stored as an immutable string. The canonical name can be created either<br>
from a path, or it can be directly constructed from a set of immutable strings. For<br>
example, for the path "\{GUTD}\abcA\def', the canonical name will consist of the<br>
two strings: "{QUID}" and "abc\def". The interface also allows a caller to<br>
construct a path from the substrings of a canonical name, for example, they could<br>
create the canonical name with the strings "ab\\cd", "efg" and then get the path<br>
Like the immutable string, a canonical name is immutable, and you can<br>
obtain new aliased interfaces from it, for threading or reference counting purposes.<br>
IlmgMuItiValuedName<br>
The multi-valued name is used to return a reference by canonical name to a<br>
number of different objects. It is used to represent a 1-N or an N-N relationship<br>
between two object classes. Its interface is shown in the code excerpt just below.<br>
(Figure Removed)<br>
A multi-valued name can be constructed from a set of canonical names and<br>
each canonical name can be retrieved. Like the immutable string and the canonical<br>
name interfaces, it is immutable, and you can obtain a new interface to it for<br>
reference counting or threading reasons.<br>
Since navigating these interfaces could be somewhat complex to a caller,<br>
the multi-valued name provides a mechanism to get the entire enclosed canonical<br>
name as an array of BSTR paths through the GetNamesAsStrings interface. In<br>
order to free the returned multi-string, the ImgFreeMultiString call is used. In<br>
addition, the caller can go straight from a multi-string of paths to a Multi-name.<br>
This could be especially useful for constructing a multi-valued name from a set of<br>
static paths.<br>
Registering new variant types<br>
The standard variants will always marshal correctly over the wire and all<br>
have support in the query language used by the system. However, especially for<br>
the inproc-case, it can be very useful to extend the variant types. This allows one<br>
to create new value types, such as points, or printable areas that do not need to be<br>
converted to strings. Alternately, it allows one to define an interface that can be<br>
retrieved and manipulated as part of a command. To this end, the GDI provides a<br>
mechanism for extending the variants that can be handled by VariantCopy,<br>
VariantClear and VariantConvert.<br>
This interface is shown in the code excerpt below.<br>
(Figure Removed)<br>
Here, one needs to supply in IlmgVariantExtender interface that knows<br>
how to perform all the operations on the types that are registered. One then also<br>
supplies the set of types supported by the interface and the set of conversions the<br>
interface will perform. The system will then extend its handling of variant types to<br>
include calling these interfaces for the types that have been specified.<br>
If conversions are provided to and from the standard variant types, then the<br>
remoting layer will also correctly marshal that appropriate data across the wire.<br>
This allows for use of the type transparently within the same process as the server<br>
object or across the wire.<br>
Registering Type Maps<br>
Once a client type map is constructed, it is registered with the GDI and an<br>
interface is returned to the client representing that type map registration. This<br>
object accumulates the optimized type maps used to bind to various collection<br>
classes. The intent is to allow a process to register all of the types that it intends to<br>
use up front and then to be able to use the given type map from then on. As the<br>
optimized type maps are built, the time required to query data from an object<br>
becomes very small since no fields have to be compared. The full interface for<br>
registering a type map is shown in the code excerpt just below.<br>
(Figure Removed)<br>
Since there are a number of types used for this interface, each one is<br>
explored below.<br>
ElmgCopyFlags<br>
These flags are associated with a copy operation and let the client know<br>
about any issues that were encountered when copying data. Most of the flags are<br>
self-explanatory. Some of (he more interesting flags are:<br>
Private - The data should not be copied outside of the system. Other<br>
processes considered part of the system could receive the data. The data<br>
will never be sent across the wire.<br>
NotModified - Indicates that the data hasn't been modified from that on the<br>
server. This can be useful for optimizing a set operation.<br>
CollectHistory - This indicates to the GDI that the history of the changes to<br>
this field should be collected. The default behavior is to collapse the history<br>
of a field.<br>
ImgExtraCopyData<br>
This is passed to the accessor to allow flags to be modified or inserted by<br>
the accessor. It is also used to pass a change handler to the accessor when a set is<br>
being performed, which allows the change handler to send changes if the property<br>
value changes.<br>
ImgFieldAccess<br>
This specifies a field. Most of the structure fields are self-explanatory. The<br>
description does not have to be specified on the client. On the server, this field can<br>
be used for reflection. The tag is used on the server to allow a particular field to be<br>
referenced cheaply. It is the responsibility of whoever propagates the structure to<br>
keep the tag unique.<br>
ImgFieldAccessors<br>
This specifies a set of field accessors.<br>
ImgClassDescription<br>
This describes a class, specifies the get accessors and the set accessors.<br>
IlmgAccessor<br>
This interface allows access to a particular field. The ImgVariant stores the<br>
data temporarily, and allows many different types of data to be passed,<br>
HrngTypeMaps<br>
This interface can be released by the client. In turn, all of the accessor<br>
interfaces passed in at registration time will be released.<br>
IlnigCommonData<br>
This is the central interface that can be used to register a type map. This<br>
interface can be released and the type map registration will remain valid.<br>
Batching Interface<br>
The remaining sub-sections (i.e. Object Queries, Object Commands and<br>
Notifications) deal with the data access interface in a large amount of detail. This<br>
section deals with what an object is and how the client gets, sets and queries<br>
objects.<br>
The interface used by the client to access these objects, is shown in the code<br>
excerpt just below.<br>
(Figure Removed)<br>
This access interface exposes new concepts which, by way of example and<br>
not limitation, include:<br>
• A batching interface (IlmgBatch)<br>
• An asynchronous programming mechanism (HmgAsyncResult).<br>
• A client collection interface (HmgClientCollection).<br>
Each of these interfaces will be discussed in abstract first and then an<br>
example of a potential call sequence will be shown in order to make these ideas<br>
more concrete.<br>
All actions issued to the data access interface are batched. The batching<br>
interface is returned from a call to HmgCommonData::GetDataBatchO, then a set<br>
of actions are issued to the batching interface, and lastly the batch is executed. If<br>
the caller wants to issue a single action, they just create a batch request of one<br>
action.<br>
None of the actions are executed until the Execute method is called.<br>
Execute can either be called synchronously or asynchronously (depending on<br>
whether Execute or BeginExecute is called). The caller can pass in a completion<br>
interface, or they can use a wait handle returned from the HmgAsyncResult<br>
interface. The rule is that if the caller does pass in a completion interface, then<br>
they cannot retrieve a wait handle. The caller can associate extra data with the call<br>
through the cookie interface. The GDI guarantees that the Done method will be<br>
called in the call completion interface to allow the cookie to be freed if necessary.<br>
The caller must call the EndExecute call to retrieve the result of the batching call.<br>
The caller can open the batch either as a serial, a parallel or a transactional<br>
batch. A non-transactional batch might have a partial success return while a<br>
transactional batch will not. Unfortunately, not all collections will support<br>
transactions (they might communicate to a down-level system that does not<br>
support transactions), and if any of the batch's actions cross to a non-transactional<br>
collection, the entire batch will fail. Thus, in accordance with one embodiment,<br>
transactional batching can be mainly performed inside the system or only once the<br>
server version has been positively identified.<br>
For some batch-able actions like "Pause all printers" it does not make sense<br>
to be transactional since one would rather have half the queues paused than none<br>
because one queue failed to pause. If the semantics of the batch are serial, then the<br>
actions in the batch are guaranteed to be executed sequentially. If the semantics of<br>
the batch are parallel, then the system might execute the actions in parallel, if there<br>
are sufficient resources or if it is otherwise optimal to do so. This means that for<br>
parallel batch semantics any of the actions could fail in any order. Transactional<br>
batches also imply sequential semantics.<br>
Each action in the batch returns an incrementing index. The caller can<br>
ignore the index if they do not need to retrieve the result of the batch call. (It could<br>
be a transactional batch and the status of the batch is the status of the action). The<br>
result of each call can be retrieved by calling the corresponding "Result" method<br>
of the batch interface. If the call reports an error, extended error information can<br>
be returned from the batch.<br>
The synchronous and asynchronous forms of execute are the same except<br>
that in the asynchronous case, the return status is returned from the EndExecute<br>
call. Since batch commands could execute in parallel, a batch can have a partial<br>
failure result. Each index can then be queried to determine precisely which call<br>
failed, and why, if the caller desired,<br>
In accordance with one embodiment, the methods on the batching interface<br>
are summarized below:<br>
GetObjectData - this retrieves data from the given object name using the<br>
given type map and caller specified object<br>
SetObjectData - this writes data to the given object using the given type<br>
map to make the write (the Accessors between the client collection and the<br>
server collection are reversed) and the object to retrieve the data from. Note<br>
that if the data is being sent to a remote destination, the contents will be<br>
copied out early from the object. If the data is being set against a local<br>
object, the contents will be copied out later when the actual set occurs.<br>
QueryObjectData - This issues a query against a certain object class.<br>
Queries are discussed in more detail below. A query is conceptually very<br>
much like a Get command except that many objects will be allocated from a<br>
collection in order to satisfy the query rather than just a single object.<br>
IssueCommandToObject —This issues a command against an object.<br>
Commands are discussed in more detail below. A command is issued to a<br>
particular type on a given object. The command itself is a Unicode string<br>
and it receives an ordered list of input arguments. The output parameters<br>
can be retrieved by the caller through the ResultlssueCommand call.<br>
Execute - This causes all of the commands to be batched thus far to be<br>
executed.<br>
Cancel - This cancels any actions that are currently in progress after the<br>
execute call. It also flushes any commands from the batching interface<br>
before the call was executed.<br>
A batching interface can only be re-used after a Cancel call returns, or after<br>
the synchronous Execute call completes or the asynchronous EndExecute call<br>
returns.<br>
Fig. 6 illustrates a diagram of a batch call command. This assumes that the<br>
HmgDataBatch interface builds up a list of commands to be executed.<br>
Queries, Commands and Notifications are covered in detail in subsequent<br>
sections. Accordingly, a sample code snippet that gets the state of an object and<br>
then changes the name and comment of the object and applies the changes again is<br>
shown below. The code is written in the asynchronous callback form to illustrate<br>
the asynchronous batching interface, but it really does not need this complexity.<br>
(Figure Removed)<br>
Object Queries<br>
This section describes object queries. The interface exposed by<br>
IDataAccessBatch is shown just below.<br>
The typeMap and clientCollection parameters have already been discussed.<br>
The queryString parameter controls the query. If it is null, then the query requests<br>
all objects of the given type as specified by the query base. If it is not null, then it<br>
specifies the filter for the query. A query consists of a query base, a query class<br>
and a query string, The query string is dealt with a little later. The query base is<br>
the root object for the query, i.e. it is the object under which the other objects can<br>
be thought to exist (the query base for a job enumeration could be a printer or a<br>
server object). The query base relationship is not typically hierarchical but<br>
relational (i.e. you cannot enumerate objects two levels below a query base).<br>
However, unlike a strict hierarchy, an object can be located under many different<br>
query bases. This reflects the fact that the underlying store is relational. The main<br>
reason for supporting query bases is to allow down-level enumeration based<br>
implementation of a query to easily find the root object for the enumeration. Query<br>
bases complicate the parsing of a query for the up-level case, however.<br>
A sample list of queries and types is shown in the table just below. Note<br>
that objects in a collection may not use the programmatic name of a collection.<br>
They should use the name resolution mechanism for friendly names and then<br>
internally use the numeric object name to refer to the object The collection is<br>
allowed to be specified using the programmatic name for queries since the string is<br>
more likely to be assembled by a human.<br>
Query Object<br>
{XXXXX}<br>
Note that remote collections are not required to return any objects for a<br>
query against the local machine. It would be too inefficient for them to query all<br>
servers. The query string is a filter that specifies the attributes that the given<br>
object must have. A field takes Hie form:<br>
Programmatic.Type.Name.Version:FieldName.<br>
Future queries might be allowed to access data within an XML document<br>
embedded in the data. These queries would have the form:<br>
Progranmtic.Type.Name.Version:FieldName\Node\Node\Properry.<br>
The valid operators and their precedence are shown in the table just below.<br>
Operator<br>
(Figure Removed)<br>
Fields can only be compared against constants. The following are valid<br>
constants:<br>
• Any integer. Integers may be expressed in decimal or hexadecimal form.<br>
• Any floating point number.<br>
• Any string literal demarcated with quotes. If a quote needs to be a part of<br>
the string, then a BASIC style "" is used.<br>
Valid queries are shown in the table just below. To simplify the semantics<br>
of some commonly accessed objects, there can be well defined query bases that<br>
allow easier interoperability with down-level servers. These will include —<br>
• Print queue queries - Query Base should be the server object that contains<br>
the print queue.<br>
• Job Object queries — Query base should be the queue or server object that<br>
contains the jobs.<br>
Query String<br>
The following constraints apply to a query in accordance with one<br>
embodiment:<br>
If the query compares the field against a numeric type (either integer or<br>
floating point) then the actual field must "be numeric (32 bit integer, 64 bit<br>
integer or double).<br>
If the query compares the field against a string type and the comparison<br>
operator is not CONTAINS then the only valid field types are a BSTR or an<br>
lunglmutableString.<br>
The CONTAINS operator only works on string types. For single valued<br>
strings, it amounts to checking for equality. For a canonical name, it<br>
amounts to checking that the path is the same. For a multi-string, it<br>
evaluates the checking if any of the strings in the multi-string are equal. For<br>
a Multi- Valued Name, it is equivalent to checking if any of the paths<br>
expressed by any of the canonical names in the multi-valued name are<br>
equal to the string the contains operator refers to.<br>
The bitwise AND operation only applies to integral types.<br>
To make this discussion more concrete, the code excerpt just below<br>
presents a sample. This queries for a set of print objects and then enumerates<br>
them. This sample uses the waitable form of the lAsyncResult interface. Again, in<br>
this case this is not needed, but it shows another usage of the interface. Note that<br>
we use a feature of the template library that automatically builds an<br>
HmgCHentCollection and enumerator for the caller. Error handling is omitted for<br>
brevity.<br>
Object Commands<br>
As well as querying for a collection of objects, commands can be issued to<br>
a given object<br>
A command on an object is tied to the type, including any embedded types<br>
from other collections that the object might have. This allows the command set of<br>
an object to be extended or a per-instance basis.<br>
In accordance with one embodiment, commands have the following<br>
properties:<br>
• Commands are never cached, data can be cached.<br>
• Commands can return parameters to the caller beyond a failure exception.<br>
• A command has a fixed set of ordered input and output parameters.<br>
Commands can not be overloaded or extended. The semantics of a<br>
command can never change across new versions of the system. (Commands<br>
might be made obsolete and eventually support maybe discontinued.)<br>
Commands will be used for object construction and for object deletion. For<br>
object deletion, a predefined type and method is defined<br>
"Microsoft.GenericObjectl", command "Delete". The delete command takes no<br>
parameters and returns no parameters. All delete-able objects are required to<br>
expose this command. All embedded objects are also required to expose this<br>
command. When the containing object of an embedded object is deleted, it will<br>
request all of the embedded objects to delete themselves.<br>
Another command that all securable objects will be required to expose is<br>
"MicrosoftGenericObject.l" command "AccessCheck", this will take a single<br>
parameter - a permission object and return true or false. This command is used by<br>
embedded types to ensure that they enforce the same security semantics as their<br>
embedding object when they are accessed through their own collection.<br>
The lifetime of the parameters returned from a command call result is the<br>
same as that of the batch. When the batch is Released, Canceled or another action<br>
is performed on the batch then the command parameters will be cleared up.<br>
Finally, a sample usage of the command interface is presented just below.<br>
This requests a stream object from an already discovered print queue.<br>
Notifications<br>
Notifications can also be received from an object, an object class, a server,<br>
or a collection. This interface is also batched from the client. The interface is<br>
shown just below.<br>
This interface exposes a number of new concepts among which are<br>
included, by way of example and not limitation, a notification collection, a<br>
notification object, notification filters and a notification channel. This interface<br>
60<br>
extends the batch interface with another two other actions<br>
RegisterNotificationCollection and ResultNotificationCollection.<br>
A notification collection is a client collection with slightly richer semantics.<br>
It is a collection of homogenous client objects. Each object can be described with<br>
a type map. When a notification for a particular object change occurs or if an<br>
object is added, the object is retrieved, and then populated. When the new data for<br>
the object has been placed in it, the EndNotifyChanges method on the object is<br>
called allowing the implementer to perform any processing necessary once the<br>
obj ect has been updated.<br>
The notification collection specified by the caller will always be updated<br>
serially (i.e., it could be called by multiple threads, but only one thread will call it<br>
at a time). The notification collection will only be updated when the Populate or<br>
Update calls are made on the channel. Thus, the caller can protect their objects by<br>
placing the appropriate locks around the Populate or Update calls, if they are<br>
performing multi-threaded access on their objects. If the caller specified a callback<br>
for the notifications, then only a single thread is guaranteed to execute in the<br>
callback at a time.<br>
Notifications work in the following way. When the Populate call is made<br>
on the channel, the objects will be allocated from the specified collection through<br>
the Add method. Then the objects will be called with the BeginNotifyChanges<br>
call, and whether this is an update cycle or a populate cycle at this time will be<br>
passed into the object.<br>
Then, notifications are received through the notification channel. If the<br>
caller specified a callback, then the callback will be called when new updates are<br>
received (or when the channel develops an error). If the caller did not specify a<br>
callback, then a wait handle will be available or the channel can be polled for the<br>
IsCompleted method. The notifications are received by the subsystem, but are not<br>
applied to the client objects until the Update method is called on the channel. If the<br>
channel broke down for some reason, then an update will return an appropriate<br>
error.<br>
During the call to Update, 'the client objects will be updated with whatever<br>
properties have changed on the server. If any new objects are either created on the<br>
server or if they now match the notification filter, then the collection will receive a<br>
call to the Add method and will be told if the reason for the notification is that the<br>
object now matched a filter or if the object is new.<br>
Similarly if any object now does not match the filter, or if they have been<br>
deleted then the Remove method on the collection is called.<br>
The objects are updated through direct calls to their properties. The updates<br>
will be bracketed by calls to the BeginNotifyChanges and EndNotifyChanges<br>
methods.<br>
When the caller wants to stop receiving notifications, they release the<br>
INotificationChannel interface that they received.<br>
Sample code that receives notifications for two fields from all local objects<br>
in a collection is shown just below. This sample code receives the changes for the<br>
Status and Name fields for all of the printers in the local collection. It is assumed<br>
that the printers are updated on the screen as a result of the query. Error Handling<br>
is omitted for readability.<br>
Client Collections<br>
One aspect of the GDI interface, namely, the choice to populate a client<br>
collection and client object rather than write the data into some sort of<br>
intermediate data object and propagate the data set carries with it some<br>
advantages.<br>
For example, doing so allows notifications and data population to be treated<br>
very similarly. What this means from a client perspective is that client objects can<br>
be re-used very easily between these two cases. Further, doing so allows the client<br>
code to be extremely efficient. Specifically, once the data has been collected into<br>
a client object, it is referenced natively as an offset within a structure. If the data is<br>
stored in an intermediate collection, then either the client has to in turn copy the<br>
data into some client objects to manipulate it, or the data has to be retrieved each<br>
time from the collection.<br>
Further, populating a client collection and client object limits failure<br>
conditions in the client code to when the data is populated, not when it is copied<br>
from the collection. This has the potential to substantially decrease the complexity<br>
of the client code. When an intermediary collection is useds there is a potential for<br>
failure whenever the data in the collection is accessed.<br>
65<br>
In addition, populating a client collection and client object allows multiple<br>
kinds of intermediate collections to be used. Essentially, -this mechanism<br>
encapsulates a completely flexible builder pattern. This means that a generic<br>
"client" can build a type map dynamically and map it to any sort of intermediate<br>
collection it likes. This could be used to build a Data Set object for a managed data<br>
provider. Alternately, it could be used to build an XML view of the data. This can<br>
be done without any loss of fidelity or performance caused by the interjection of<br>
an intermediate dataset. Further, a related property is that populating a client<br>
collection and client object allows a client collection to actually be an access<br>
Adapter that prepares the data in a form that can easily be remoted. On the<br>
negative side, however, it can force the client object to expose accessors for each<br>
property that it wishes to retrieve.<br>
Dynamic Type Maps<br>
The illustrated and described embodiment can be utilized to address the<br>
situation when a user wants to have one object instance, but wants to be able to<br>
retrieve different fields dynamically from the server objects depending on the<br>
calling conditions. There are two cases where this could occur—one, when there<br>
is a concrete object with many properties, but the actual properties the caller wants<br>
propagated in a given call are dynamic; and, the other is when the caller truly<br>
wants to treat the data completely dynamically. Each has a solution in the<br>
illustrated and described architecture.<br>
To solve the first problem, the illustrated and described embodiment uses<br>
the tags that are associated with each property to build a subset dynamic type map<br>
from the class. These tags can also be specified as part of the template library. The<br>
template library will retrieve a partial type map matching only the tags specified.<br>
This solution is shown in the code excerpt shown just below.<br>
(Figure Removed)<br>
Allowing a completely random set of completely run-time determined<br>
properties to be retrieved from a remote server can also be accomplished through<br>
the type map interface. In this case though, one cannot have just a set of properties<br>
bound to a class. It is in this case that the power and flexibility of the low level<br>
type map interface really comes into play. In this case, the caller can take<br>
advantage of the fact that every interface is also an object instance and use the<br>
variant type directly. This notion is shown in Fig. 7.<br>
There, each interface actually points to an object, rather than to a static<br>
method or field. Each object maintains some sort of state about how it should<br>
manipulate the final destination object. In this case it maintains the index into the<br>
objects array that the destination objects maintain. The size of the destinations<br>
object's array is variable and both the delegate objects and type maps can be built<br>
dynamically. Thus, this mechanism allows to caller to bind to any source object,<br>
and allows any source object to be built on the fly.<br>
In the illustrated and described embodiment, this mechanism is actually<br>
completely generic. There is no particular reason why the interfaces cannot<br>
participate in building an XML document, creating a dataset or writing data to the<br>
screen. It can also be used to build collections of objects in any form. This is<br>
extremely useful when bridging to the longhorn APIs or other data access APIs.<br>
The code to implement this scheme is shown just below, including<br>
accessing one object through the batch interface (error handling omitted).<br>
(Figure Removed)<br>
Attribute Template Library and Inheritance<br>
One of the interesting aspects of the template library is that it supports<br>
inheritance (including multiple inheritance) between objects. This is less useful on<br>
the client than it is in the server. On the server, this allows common functionality<br>
and the corresponding fields and methods to be stored in a base class and pulled<br>
into the derived class as necessary.<br>
In addition to supporting inheritance, the library also correctly handles<br>
virtual methods. That is, virtual methods in the base class can be referenced in a<br>
base class type map and then will correctly call the derived class in the derived<br>
type map. An example of a working set of types is shown in the code excerpt just<br>
below. This code just shows the structure of the classes—any implementation is<br>
omitted for brevity.<br>
In this example, the derived class overrides one virtual method and<br>
implements two pure methods. All of the other fields and methods are pulled in<br>
from the base classes. The derived class's methods are still called even though the<br>
definition of the table is actually pulled in from the table defined in the base class.<br>
The derived table pulls in the -definitions of the base class tables with an<br>
"Inherits" field in its table. Any extensions to the base classes and base class tables<br>
will be immediately reflected in the derived class's tables. Thus the tables can be<br>
shown to implement true multiple inheritance.<br>
Cursors<br>
A cursor is an interface that allows a caller to retrieve data from the server a<br>
chunk at a time, rather than as a single request. This is especially useful when<br>
there are a large number of objects on the server that need to be enumerated. This<br>
reduces the amount of data that must be returned across the network in one call<br>
and it reduces the working set on the server side. For very large collections of<br>
objects, it can also allow the client to avoid having to store all of the objects in<br>
memory. Instead, the client can maintain a cursor into the table and retrieve more<br>
rows as required. In this particular implementation example, cursors are not<br>
currently implemented in the GDI for a number of reasons:<br>
The number of objects maintained on the server isn't nearly the same order<br>
of magnitude as that stored in a typical database. It is extremely unlikely<br>
that a client will not have sufficient memory to store its copy of the data.<br>
Many objects on the server are by necessity active because most queues<br>
will receive jobs. Thus, working set is less of a consideration than in a<br>
database.<br>
The network traffic can be arbitrarily reduced by doing the query in two<br>
passes, an initial query which retrieves'the canonical name for each object<br>
and then a second set of GetObjectData calls to retrieve the data for each<br>
object. Since the GetObjectData calls can be chunked together arbitrarily<br>
you don't need a network round trip to retrieve data from each object.<br>
Since the caller can specify an accurate query filter, the size of the data sets<br>
can be made much smaller. For example, the client spooler can enumerate<br>
on jobs belonging to the given user, rather than having to enumerate all jobs<br>
and then filter out those that don't belong to the given user.<br>
Since the caller can specify precisely what fields they want to retrieve, the<br>
amount of data can be much reduced over the current system with its<br>
inflexible info level system. For example, currently to retrieve the number<br>
of jobs in a queue, the caller must specify a PRINTER__INFO_2, which also<br>
contains the default DEVMODE and the security descriptor.<br>
The interface is currently stateless at the wire level except for notifications.<br>
Cursors tend to result in more server state. It might be that the overhead of<br>
rnaintaining the state necessary for a cursor exceeds the benefit derived<br>
from it, especially given the number of mitigations.<br>
Nonetheless, it might become desirable to implement cursors at some point<br>
in the system, especially if the print system is scaled to do document archival, or if<br>
a very large print server can be made to handle a very large number of queues<br>
where a small number are active (avoiding pulling objects into memory<br>
unnecessarily becomes very important in this scenario). This section describes a<br>
mechanism that would result in a fairly cheap forward only cursor for queries.<br>
With regard to notifications, consider that notifications would require no<br>
change to the client interface. The wire interface would send the populated data to<br>
the client in chunks and then would start updating the client objects. For optimal<br>
performance, the updates might be interleaved with the original populate.<br>
With regard to a client cursor, consider the following. One goal of the<br>
illustrated and described system is to maintain a stateless wire protocol to<br>
whatever extent possible. Hence, we define what set of objects are retrieved by a<br>
cursor and then provide an implementation that fulfills these goals. Reasonable<br>
semantics for a cursor are as follows:<br>
• The cursor moves forward only.<br>
• The set of objects that will be retrieved by the cursor is the number of<br>
objects matching the query when the cursor is created, less the objects that<br>
are deleted subsequently. It does not include any objects that are created<br>
after the cursor is first created. This is to prevent a slow client from never<br>
terminating against a server with a rapidly changing set of objects.<br>
The described solution is to keep an ever increasing sequence count with<br>
each object. When the cursor is established, the current maximum sequence count<br>
number is remembered by the client. The set of objects are returned and the<br>
maximum sequence count of the last object is remembered. When the next set of<br>
objects is retrieved it amounts to this query: retrieve the next CHUNKSIZE<br>
objects where Timestamp &gt; lastjmax and Timestamp 
It might turn out that the overhead of executing this query for each request<br>
on the server exceeds the average overhead of maintaining the necessary<br>
connectivity to maintain the cursor context on the server. A compromise solution<br>
is to keep a cache of cursors on the server identified by a GUTD. The client<br>
submits the timestamps and the QUID to the server. If the server side cursor still<br>
exists in cache, that state is just used. Otherwise, it is recovered by executing the<br>
timestamp query and re-inserted in the cache. This allows the server to discard the<br>
state cheaply for slow clients.<br>
If one assumes that the main goal is to reduce the size of the individual<br>
network requests and to reduce the working set required on the server for queries,<br>
then the GDI interface would not necessarily require any changes, the Remote<br>
Access Adapter and the Local Access Adaptor would just use a cursor to the<br>
server side transparently when the client issues a query.<br>
./For very large datasets, the client might want to manipulate the cursor itself<br>
so that it does not have to keep all of its state in memory at once. In this case, an<br>
interface representing the cursor would be retrieved from the GDI interface. It<br>
would not be necessary to make this call batched since by implication a single<br>
cursor retrieves a large amount of data.<br>
Friendly name resolution<br>
At various points the notion of converting a friendly name to a canonical<br>
name has been discussed. The friendly name is a human readable version of an<br>
object instance, for example, the notion that there is a server called<br>
server.mydomain.org is a friendly name. The canonical name is a completely<br>
unambiguous name that identifies the protocol use to communicate with the<br>
server, the physical server on which the logical server is hosted and a completely<br>
unambiguous reference to the logical server object instance. For example, the<br>
above friendly name might correspond to the following canonical name:<br>
"{63315ca9-bef6-4cc5-9152-05e369d3d691}\www.realhostnet\{a4b6e956-deeO-<br>
46dO-b82c-7ffc8f814e95}\{ fD91b5al-ad2a-4dfe-9d37-9592blae2512}". The<br>
canonical name has the advantage of being completely unambiguous, which is<br>
excellent for a computer. However, it is not readily input by a human.<br>
Given a canonical name, it is easy to determine the friendly name of the<br>
object if this is relevant. The object will simply have a property such as<br>
"ObjectName" that can be retrieved from the object. However if the system has<br>
only the friendly name then it must be able to determine the canonical name. The<br>
application callable side of this interface is discussed in this section. Implementing<br>
a name resolver is discussed below in the section entitled "Friendly Name<br>
Resolution Plug Ins.". The client friendly name resolution interface is shown, in<br>
accordance with one embodiment, just below.<br>
When a caller wishes to obtain a friendly name resolver, they call the<br>
GetFriendlyNameResolver method on the nmgComrnonData interface. The<br>
friendly name exposes only two logical methods (and an asynchronous calling<br>
pattern for one of them):<br>
ResolveName<br>
Given the name to be resolved, e.g. "server.mydomain.org" and the class of<br>
the name, e.g. "Server", the name resolution interface calls the friendly name<br>
resolver plug-ins and returns all the valid results returned by the plug-ins as an<br>
IlmgCanonicalNamelterator interface. The name iterator allows the caller to<br>
retrieve all the canonical names that correspond to the friendly name. The reason<br>
for allowing multiple canonical name returns is that the same object might be<br>
visible via different paths. For example, the same server might be accessible via<br>
both SOAP and RFC.<br>
The ResolveName method can take a long period of time since it might<br>
have to query multiple protocols to see how a particular object can be accessed.<br>
Thus, the interface also provides an asynchronous invocation pattern in the form<br>
of the BeginResolveName and EndResolveName methods. These use the same<br>
asynchronous calling pattern as used by the batch BeginExecute and EndExecute<br>
methods. The caller can either specify a callback interface or can get a system<br>
wait-able handle returned via the HmgAsyncResult return. They will be notified<br>
when all of the corresponding canonical names have been resolved.<br>
RemoveName<br>
The name resolver maintains a cache of resolved names to friendly names<br>
since name resolution is potentially very slow and expensive. The cache will<br>
automatically be flushed over tune. And if any name resolution subsequently fails<br>
to resolve the same names as are in the cache those name associations will be<br>
removed. The behavior is that after a certain amount of time, a name is considered<br>
stale. If the caller requests the name again, the stale name is returned by the name<br>
resolver, but it issues another round of name resolution to the name resolver plugins,<br>
if none of them return the name, the name will then be removed from the<br>
cache. This provides a very fast resolution on names, but it could result in a stale<br>
name binding being returned for a period of time.<br>
The caller might resolve a friendly name and then independently determine<br>
that the name is stale since the canonical name fails when it is accessed via GDI. If<br>
they were to request the same friendly name again, they might get the same stale<br>
name back. In order to prevent this, the stale name can be explicitly removed from<br>
the cache through the RemoveName method. If the caller doesn't do this, the name<br>
will eventually be cleared, it is an optional optimization.<br>
Extended Object Behavior<br>
The goal of the previous section is to present the interface and basic<br>
concepts of the GDI. The goal of the presentation was to expose it mainly from a<br>
usage stand point The interface as presented in the previous sections is powerful<br>
enough to allow any application writer to get, set, query and receive notifications<br>
for objects in the print system. The focus of this section is to present the extra<br>
behavior that can be exposed by objects to enable new security and discovery<br>
capabilities.<br>
Object Factories, Object Cloning<br>
This section deals with the mechanism that can be used to create new<br>
objects in the system, transfer these objects (if applicable) to another system and<br>
allow a new object creation user interface (UI) to be inserted. All objects in the<br>
system except factory objects should support this mechanism. The mechanism is<br>
shown in Fig. 8 and serves as the basis for the discussion below.<br>
The object creation and cloning mechanism assumes that there is a driver<br>
store that can:<br>
1. Provide a UI assembly to the client or the server based on the UI assembly<br>
strong name.<br>
2. Provide a collection assembly to the server side based on the collection<br>
assembly strong name.<br>
The precise definition of a strong name and how it relates to versioning is<br>
another discussion. But, for contextual purposes, consider the following.<br>
A strong name is a name which both uniquely identifies the actual instance<br>
of the assembly which is in use and the publisher of the assembly in one moniker.<br>
One implementation of this is to sign the contents of the assembly using Public<br>
Key Cryptography and then take a cryptographic hash of the signature (typically<br>
an MD5 hash) and embed the hash (or a part of the hash) into the name. Not only<br>
is this name actually tied to the contents of the assembly, but it is also tied to the<br>
publisher of the assembly. There is no known technique whereby someone could<br>
create another assembly with different functionality and use nay assembly's strong<br>
name without creating a very large number (103B for a 128 bit hash) of assemblies<br>
and attempting the entire process on each one.<br>
The essential idea is that each collection provides a well know object<br>
instance that acts as the factory object for a set of object instances. Since the<br>
construction parameters for a new object cannot be known in advance, the object<br>
implements a custom type (Company.Type. 1 in this example) with a command<br>
called CreateQ that creates a new object instance. If the caller knows the factory<br>
object and the factory type, they can create an object of that class in the new<br>
spooler.<br>
Cloning is supported by the object supporting the Microsoft.Object.l type.<br>
The fields supported by the object include the Collection SN, the factory object<br>
instance used for its creation and three commands, GetStream, Delete and<br>
UpdateFromStream. GetStream retrieves the contents of the object into a stream,<br>
Delete deletes the object, and UpdateFromStream updates the object's state based<br>
on the stream passed to it. The object can support any type of stream, but for<br>
interoperability reasons, the stream should ideally be XML.<br>
When an object is to be cloned, the object instance is queried for its<br>
collection SN and Factory object instance. These are stored in a stream, and<br>
subsequently the state of the object as represented by a stream is stored.<br>
To restore an object, the collection is retrieved from the Driver Store and<br>
the factory object is located. The factory object is the passed the remainder of the<br>
stream through the CreateClone Command. This causes the factory to create an<br>
identical object instance.<br>
Note, that all objects in the system should support decoupled UI creation<br>
and cloning. However, for brevity the factory objects and cloning interface are not<br>
shown in the remaining sections to simplify the discussion and diagrams.<br>
Hierarchy<br>
Hierarchy typically accomplishes two goals. First, it subdivides a search<br>
space to allow for efficient location of objects. The division of the GDI into<br>
multiple collections, the ability to only load a collection if it supports the given<br>
class and the ability to direct a set of actions to a given server already<br>
accomplishes this goal. Second, it provides for manageability and discovery of<br>
heterogeneous objects by allowing the system or an administrator to group objects<br>
in a logical hierarchy. Hierarchy enables discovery since every object is located<br>
somewhere in the hierarchy. Thus a browser can be built that allows a user to drill<br>
down into each object in turn until all objects in the system have been discovered.<br>
The hierarchy can also provide a view of the security of the system by allowing<br>
security changes to be applied to a sub-tree of objects by one administrative<br>
action. This mechanism is analogous to how the file system implements security.<br>
Hierarchy is typically not useful for showing the relationship between<br>
objects. A pure hierarchy only allows an object to be located under precisely one<br>
other object. Thus, a job .cannot belong to both a printer and a server. Hierarchy<br>
also cannot efficiently show a many to one relationship between objects. A<br>
relational model is much more powerful for indicating object relationship. The<br>
GDI effectively allows this through the QueryBase mechanism of the Query action<br>
on the batching interface (which returns the objects mat can logically be<br>
considered to be contained by another object).<br>
Since the first goal of hierarchy is already accomplished by the GDI and<br>
remote access adapter routing mechanism and since the relational mechanisms of<br>
the GDI are more powerful anyway for representing object relationships, we only<br>
require a method to support administration and discovery of heterogeneous objects<br>
in the system. Note that since the existing model is powerful enough for a large<br>
proportion of cases, not all objects will necessarily support hierarchy. The default<br>
persistable store provided by the service layer will support hierarchy<br>
automatically. Thus, the simplest implementation for local objects will<br>
automatically support hierarchy. There will be cases where we will support<br>
discoverable hierarchy, but not modifiable hierarchy. For example, a remote<br>
Adapter supporting the current spooler RFC interface might allow a client to<br>
discover printers under servers and jobs under printers, but won't allow the<br>
organization to be changed.<br>
Hierarchy can be expressed by introducing a new Class called the Link<br>
class which has one type, the link type with one property Object which is the<br>
canonical name of an object which can be considered "beneath" the current object<br>
in some way. When one wants to rind out which object instances can be traversed<br>
to hierarchically from the current class, one queries for the Links class with the<br>
object instance that is being traversed from as the query base. An example of a<br>
number of objects set up in a hierarchy is shown in Fig. 9. This excludes the<br>
logical system object, which will be the root object on each and every machine.<br>
The implementation of the links class query will be provided automatically<br>
by the persistent object collection service. But, any collection that wants to expose<br>
a discoverable hierarchy can populate the links query. For example, a collection<br>
that exposes DS objects could enumerate the children of each DS object and then<br>
populate the Distinguished Names of each object into the links tab when the parent<br>
object is enumerated.<br>
Security and Hierarchy<br>
Hierarchy provides for discoverability and security. The GDI provides a<br>
security agent which, when the security descriptor of an object is changed, will run<br>
through child objects to enforce security inheritance rules. Security will<br>
automatically be handled by the persistent object collection service and the<br>
security agent will run automatically on objects in this collection.<br>
A special object called a logical group will be provided that an<br>
administrator can place any set of objects under. This allows the administrator to<br>
change the ACLs on a logical group and have them automatically apply to all<br>
objects under that logical group. This allows an administrator to apply an<br>
administrative hierarchy on their server that they find useful and then apply the<br>
security rules to that hierarchy.<br>
Security and Class Mix-ins<br>
As well as controlling security by hierarchy, the system will also allow<br>
security to be controlled by class. This allows features such as providing<br>
Creator/Owner administrative access to all jobs created on the system. In the<br>
current system, the class rules are hard coded into the system, in the future; mixins<br>
will be available for any class.<br>
As shown in Fig. 10, class inheritance is accomplished by exposing editable<br>
class objects in the security hierarchy. These will each contain initially a default<br>
Security Descriptor that will apply to each class on creation. Like all other objects<br>
they will inherit their descriptor from the logical system object that is used as the<br>
base object for the entire system. When an object of the appropriate class is<br>
created, both the parent object and the class object are used to derive its security<br>
descriptor. Fig. 10 also shows the effect of logical groups on the hierarchy. Here<br>
the administrator has created two logical groups, one to be able to control the<br>
access to any cluster server and another to control the access to a printer on the<br>
local server object. Although only one object is shown in each case here, any<br>
number of objects could be placed under each logical group.<br>
Metadata<br>
In the illustrated and described embodiment, the GDI provides the ability to<br>
bind any object to a remote object, but the caller must know the fields and<br>
commands that the object supports before it binds to it. Most of the time, the client<br>
knows the server objects and the interfaces that they support. If the client did not,<br>
then it would not be able to function correctly since it requires a-priori knowledge<br>
of the server object to function. The interface is geared towards optimizing this<br>
behavior, and classes that precisely know the context in which they will be called<br>
do not need to implement any metadata mechanism.<br>
However, there are also cases where the client does not have a-priori<br>
knowledge about the class it is manipulating. For example, the client might be an<br>
access adaptor that translates the GDI calls into a Managed Data Provider<br>
interface. In this case, the data requested by its client cannot be known a-priori and<br>
the server objects that it is communicating with also cannot be know a-priori. Or,<br>
the client might be a generic administrative UI that allows all of the objects on the<br>
client or the server to be browsed and manipulated regardless of the object types.<br>
To this end, the illustrated and described embodiment provides standard<br>
system types that allow a caller to query an object instance for its metadata. These<br>
types are the Type, Property, Command and Parameter types. Classes<br>
implemented using the collection adaptor service will automatically gain full<br>
metadata support for free. This will be retrieved from the server object type map<br>
that they will supply for each of their classes.<br>
The types that can be queried with the object as a base to retrieve metadata<br>
are shown in Fig. 11.<br>
Metadata is retrieved by first querying for the Types type with the object as<br>
the base of the query. The Types type provides a list of all of the types supported<br>
by the logical object instance. Since it is possible that in the future the system will<br>
allow objects to be embedded in or extend other objects, the types will include all<br>
of the aggregated types for that object instance, not just the underlying basic<br>
object. Each Type type can then, in turn, be queried for the commands or<br>
properties it supports. And, then each command can be queried for the parameters<br>
that it supports.<br>
Query Bases<br>
Query bases are an unusual design aspect in an otherwise un-hierarchical<br>
system. This section discusses why they are implemented at all and how they map<br>
to relational queries.<br>
A query base specifies a source object, which the instances of the class<br>
being queried can be considered "Under" by some measure. This is provided for a<br>
number of reasons. First, it allows an enumeration of sub-elements to be<br>
constructed by someone who otherwise does not know how to express the<br>
86<br>
relationship as part of a query. Second, it maps very well to down-level systems<br>
that are based on enumerations. The base of the query becomes very naturally the<br>
parent object in the enumeration. Thus, for down-level objects, a query base and a<br>
filter on the object state is a natural way to implement queries. Third, for objects<br>
that have highly variable composition (for example the metadata stored by an<br>
object), it is more logical to treat the query as a sequence of enumerations from a<br>
parent object.<br>
However, query bases need some manipulation to map to a relational query.<br>
Fortunately, this is relatively easy to accomplish.<br>
For illustrative purposes, the table just above illustrates a number of jobs in<br>
a print queue. There are two fields (implemented as foreign keys in the underlying<br>
database) that store the canonical name of the object with which the job is<br>
associated. Each column that references a remote object knows the remote object<br>
class.<br>
When a query comes in for a particular base object, the class of Hie object is<br>
correlated to a logical field in the object and then the query is extended to include<br>
this field having the correct value.<br>
87<br>
For example, if a query came in for Base = "{SSSS}", Base Class =<br>
"Server", with the query string "Jobs:Size 
to the following query:<br>
Jobs-Server = "{SSSS}" AND (Jobs:Size 
This would return the correct result, Fred's Job. This translation will be<br>
performed automatically in the collection adapter service. It will require slightly<br>
more metadata in the server object type map since we will need to know what<br>
fields can serve as query bases and what classes they correspond to.<br>
GDI Implementation<br>
The previous section describes the behavior that is expected from objects<br>
and describes the interface exposed to clients. This section describes the<br>
implementation of the server side of the GDI. It describes the services provided by<br>
the GDI, and the plug in model.<br>
Fig. 12 shows the major components of the GDI, as well as various plug-ins<br>
that are inserted into the system. Preliminarily, a description of each of the major<br>
components will be provided and then, a detailed description of the components in<br>
the GDI box itself will be provided. The collection adapter service is provided by<br>
the system, but it is considered a separate service hosted by the plug-in and is not<br>
part of the GDI per-se. The collection adapter service is discussed in the next<br>
section.<br>
The Application<br>
The interface to the application has been the primary focus of the previous<br>
sections. The application requests a batch interface from the GDI, records a<br>
number of actions and then executes them. When the execution is complete, the<br>
application can get the results.<br>
The Router<br>
Executing the actions results in the batch being routed by the router and<br>
passed to the plug-ins. The router finds contiguous ranges of the batch that are<br>
addressed to the same plug-in and passes those ranges to the plug-in in one call.<br>
Thus, the plug-in can still preserve batching behavior itself. Depending on the<br>
semantics invoked by the application, the sections can be passed to the plug-ins in<br>
parallej, sequentially or a transaction object can be associated the batch to allow<br>
the plug-ins to coordinate a transaction.<br>
The Plug-Ins<br>
The plug-ins are the interface exposed by a DLL in conjunction with the<br>
DLL manifest and configuration information. A single DLL can expose one or<br>
more plug-in interfaces. In me illustrated and described embodiment, the plug in<br>
interface consists of one factory interface with one method, and the plug in<br>
interface (IlmgBatchCollection) with only two methods - AsyncProcessRequest<br>
and Shutdown. The plug-in interface still receives its operations as a batch. It is<br>
thus the logical interface to use for remoting to other systems that also support<br>
batches. To this end, in the illustrated and described embodiment, the following<br>
plug-ins are provided: a Local Access Adapter, a Remote Access Adapter, a<br>
Sandbox Adapter, and an Adapted Plug-in, each of which is discussed separately<br>
below.<br>
The Local Access Adapter provides access to the local service or a per-user<br>
service. Currently this uses asynchronous COM, but there is no particular reason<br>
why any other rernoting mechanism could not be used.<br>
The Remote Access Adapter provides access to a remote machine and will<br>
largely use the same mechanisms as the Local Access Adaptor, with some<br>
differences to reduce per-client state on the server.<br>
The Sandbox Adapter is used to preserve the work of the application insofar<br>
as grouping the requests into batches. This also means that the same universal<br>
plug-in model can be used in-proc or out-of-proc components, and even that we<br>
can sandbox system components if we wish. All parts of the system aside from the<br>
GDI will be exposed as plug-ins.<br>
The Adapted Plug In is extremely simple in form, but it requires the plug-in<br>
to interpret the queued up batch operations, in an asynchronous call, which can be<br>
complex. For this reason, the Collection Adapter Service (CAS) is provided. The<br>
Collection Adapter Service allows multiple object collections<br>
(HmgObjectCollection) of objects (HmgObject) to be plugged into it and it, in<br>
turn, interprets the batched calls and translates these into calls on the supplied<br>
collections and objects. The Collection Adapter Service provides efficient<br>
handling of both synchronous and asynchronous implementation of these<br>
interfaces. The collection interface is broad enough that it can be used to access<br>
down-level protocols. There is no loss of performance in these cases since they<br>
typically do not support batching.<br>
The Services<br>
hi the illustrated and described embodiment, the GDI provides a set of<br>
services. Most of these are only accessible from plug-ins. These services are<br>
public and are equally exposed to the CAS and any other plug-in. This allows<br>
independent software vendors or independent hardware vendors who find the CAS<br>
too limited to attain the same functionality themselves. An explicit goal is to allow<br>
the CAS to solve most scenarios and, all of the system supplied objects will use it.<br>
The services provided by the GDI include a query compiler, work flow,<br>
transaction, change scope, variants and type maps, each of which is separately<br>
discussed below.<br>
The query compiler is capable of compiling the queries supplied by the<br>
application into one of two forms, a parse tree and filter. The parse tree is useful if<br>
the plug-in wants to translate the query into a query of another form—which is<br>
easier than trying to re-parse the query yourself because brackets and operator<br>
precedence will have been resolved and some basic well-formed-ness checks will<br>
have already been performed by the parser. The filter can be bound to an object<br>
and provides a method - "DoesMatch" that allows a caller to check whether a<br>
given object's state matches the query that was passed in.<br>
The workflow is an interface that is instantiated whenever the application<br>
executes a call into the GDI. It corresponds to the logical execution of a user<br>
action. A work flow can schedule work, and will notify work items associated<br>
with it when the work flow is cancelled (typically because the original call from<br>
the user is cancelled). A work flow can keep track of a set of tokens to detect and<br>
prevent recursion. When a plug-in wants to make a call into the system as a result<br>
of a call from the GDI, it must use the same work flow as in the originating <br>
does this through a special server-side only call<br>
(HmgCommonDataServer::RecurseDataBatch).<br>
When performing a recursion, it must insert a token into the flow that it can<br>
use later to check if the same operation re-occurs on the same flow, and hence<br>
back out of the recursion. The work flow will also keep track of the original<br>
caller's token. When a plug-in asynchronously and independently calls into the<br>
GDI, it can do so either through the client interface, or it can create its own work<br>
flow and call RecurseDataBatch.<br>
If the caller requests a transaction, this object is created and associated with<br>
the batch. The transaction provides a mechanism to associate one transactional<br>
collection and a set of dependent items with the transaction. It provides both a<br>
synchronous and an asynchronous interface to the transaction. When the batch<br>
finishes executing, the transaction is committed. The results are sent to the store<br>
and if the store updates correctly, the dependent items are run. hi order to qualify<br>
as a dependent item, an item must not be able to fail the commit request. This is<br>
used to make live in-memory objects dependent on a state change being<br>
propagated to the store. If the plug-in wants to extend the transaction to include<br>
other objects (for example, in order to implement a "Delete" command that deletes<br>
other objects in turn), then it can specify the same transaction when calling back<br>
into the GDI via RecurseDataBatch. All the changes through each recursion will<br>
be held pending until the outermost batch completes successfully.<br>
A change scope pertains to server side change handler that represents each<br>
channel. Change scopes can be inserted on transactions.<br>
Variants have been covered in previous sections. Variants may be used by<br>
either the client or the server side.<br>
Type Maps have also been covered in previous sections. The optimized<br>
maps are only visible to the server side.<br>
Plug-in interface<br>
In the illustrated and described embodiment, plug-in interfaces are<br>
instantiated using a COM-like object instantiation model. It does not require the<br>
plug-in to register its class ids in the registry. The process of instantiating a plug-in<br>
is shown in Fig. 13.<br>
In the illustrated and described embodiment, all of the plug-ins are stored in<br>
WMLConfig as part of the GDI configuration. Some of the plug-in data will be<br>
synthesized by WMLConfig from the plug-in DLL's XML configuration files (this<br>
is useful for a XCOPY based solution). The GDI configuration consists of a list of<br>
Plug-In DLLs. For each DLL, we list the collections GUIDs that each supports, as<br>
well as the classes supported in each logical collection. Each also has some<br>
associated initialization data. This will typically represent the location that the<br>
objects supported by the DLL will be persisted in and retrieved from. When the<br>
router wishes to instantiate the plug in interface, it retrieves the collection QUID,<br>
finds the corresponding DLL and then calls DllGetClass Object:<br>
HRESULT<br>
DllQetClaBsObject(<br>
We then request CLSID_IImgBatchCollection and<br>
HD_nmgBatchCollectionFactory. The DLL then returns a class factory that can<br>
return the various instances of IlmgBatchCollection supported by the plug-in.<br>
IlmgBatchCollectionFactory supports the following interface:<br>
The factory is passed the following information during Createlnstance:<br>
An nmgCommonDataServer interface. This interface inherits from<br>
HmgCommonData and also includes some plug-in specific methods that<br>
access server side services. Note: The plug-in should not call<br>
CoCreateInstance(CLSro_IImgCornmonData)} since this creates a client<br>
interface. The system shuts down when the last client interface is released,<br>
it will not shut down if a server side plug-in holds a client interface.<br>
A collectionGUTD. This is the same GUID that is present in the GDI<br>
configuration. The factory could choose to instantiate different<br>
IlmgBatchCollection interface depending on this GUID.<br>
Initialization Data- This data will be retrieved from WMI.Config.<br>
Currently this is represented by a string. The Plug-In uses this initialization<br>
data to choose where to obtain its objects from.<br>
Riid - This is the interface requested by the GDI. Currently only<br>
nD_IhugBatchCollection is requested, but future interfaces could be<br>
requested here.<br>
The interface returned by the plug-in is the following:<br>
The AsyncProcessRequest interface is called if any data is destined to the<br>
plug-in from the batch. The collection is passed:<br>
A nmgServerltemCompletion interface. This interface supports a single<br>
method - "Done" that is called when the request has been completely<br>
processed. The caller can immediately return from AsyncProcessRequest.<br>
The caller must call "Done" unless they fail the AsyncProcessRequest call.<br>
Failing to call "Done" results in the client's Execute call not completing.<br>
A Batch-Array, this interface provides access to the actions requested by the<br>
client.<br>
A start and end index for the batch array. This allows the router to create<br>
one batch which is then shared by the various plug-ins. The plug-ins may<br>
be executing in parallel if the client requests parallel execution semantics.<br>
The batch array has the following interface:<br>
The batch semantics, any associated transaction and the work flow can be<br>
retrieved from the batch array. The interfaces are not returned with an increased<br>
reference count since they are aliased to the batch array. The ItetnAt method<br>
returns the batch action at a given index. This contains an enumeration giving the<br>
type of item. It also contains fields that the plug-in can set to indicate whether the<br>
item completed and any error information. It contains a union which contains the<br>
parameters passed in by the caller for the corresponding action.<br>
Interception<br>
Now that the plug-in interface and router have been defined, a discussion of<br>
the implementation of interception follows. Interception is implemented, in the<br>
illustrated and described embodiment, as another plug-in interface to which the<br>
batching router can send data. However, unlike the configuration information<br>
stored for a normal plug-in, which only requires the collection id (or class for<br>
queries) for routing, an intercepting plug-in specifies the following pieces of<br>
information:<br>
• The intercepting action. The interceptor can specify whether it wants to trap<br>
Gets, Sets, Queries, Commands or Notification.<br>
• The intercepting class. The interceptor specifies what class of object it<br>
wants to be invoked for. The class can be specified as '*' in which can it<br>
will be registered for all classes.<br>
• The intercepting collection. The interceptor specifies the unique QUID of<br>
the collection whose objects it wishes to intercept. This collection can be<br>
specified as '*' in which case it will be registered for all collections.<br>
• The intercepting object, The interceptor can specify the unique object id of<br>
the object it wants to monitor (if it does this it should intercept the object's<br>
Delete command to remove the interception). If '*' is specified, then the<br>
interceptor is invoked for all classes.<br>
Each registration in the interception table is assigned a GUID. The<br>
interception mechanism will utilize the "Chain of command" pattern. The actions<br>
taken by the batching router are as follows:<br>
1. Before routing a given item in the batch to a collection, the router first<br>
checks to see whether there is an interceptor registered for the call using the<br>
fields described above.<br>
2. If there is, a contiguous set of actions is found that are destined to the same<br>
interceptor on the same rule.<br>
3. The GUID associated with the interception registration is inserted onto the<br>
work flow and the interceptor is invoked.<br>
The interceptor at this point is passed the batch actions, like any other plugin<br>
would be. It changes the execution of the action in one of two ways:<br>
1. It calls RecurseBatchActionsQ against the router and passes in the work<br>
flow again, plus the original batch actions. This does not result in any of the<br>
actions being modified, but it allows the interceptor to read them and<br>
perform additional actions itself (for instance, if it is a synchronizer, it will<br>
use this to trigger a synchronization action if the cached data is stale).<br>
2. It interprets each batch action and then modifies them by calling<br>
RecurseDataBatch and passing in the work flow again. This option allows<br>
the interceptor to change the outcome of an action, but it is (intentionally)<br>
much more difficult to implement For example, to change the outcome of a<br>
'Get", a temporary proxy object would have to be instantiated to hold the<br>
result of the real objects get, and a new type map would have to be<br>
registered to write to this temporary object.<br>
Either of these calls will result in a call back into the batching router. The<br>
batching router performs exactly the same lookup as before, except, it will not call<br>
into any interceptor that has its GUID token listed in the work flow. Thus, each<br>
interception in turn will be exhausted until the action is routed to the destination<br>
object. This same mechanism prevents a well behaved set of interceptors and<br>
objects from exhibiting recursion since the router will automatically ignore<br>
interceptors that have already been called if the call becomes recursive.<br>
Because the interceptor is responsible for chaining the call, it can choose to<br>
execute actions before or after chaining. It can change the semantics of a batch.<br>
Typically, if the batch isn't transactional, it might want to ensure that the<br>
interception is transactional. Since it is invoked asynchronously, it could even<br>
execute its interception in parallel with the intercepted action.<br>
Uses of interception<br>
Interception is useful for two purposes—system extension or aspect<br>
extension. Interception can be used by IHVs to extend the behavior of a batch<br>
action. For example, when a queue is paused, another action might need to be<br>
taken by the driver. These extensions are reasonably safe as long as they do not<br>
attempt to change the outcome of the original action. For this reason, the<br>
RecurseBatchActions method is made much simpler to implement. Changing the<br>
outcome of a batch action will be much more difficult since it requires interception<br>
and modifying all of the parameters, including some sticky ones like type maps,<br>
client objects and client object collections. Interceptions could also be conceivable<br>
used as mechanism for maintaining compatibility and for patching systems. For<br>
example, if a revision of the system results in a plug-in misbehaving, an<br>
interceptor could be created that changes the calls into it to ones that it<br>
understands. A system could, then, be serviced by supplying interceptors that, for<br>
example, patch a security hole by intercepting a call with a string that is too large<br>
before it reaches the target object. This could even be done quite generically, e.g.,<br>
an interceptor could be written that rejects all strings that are larger than<br>
MAX_PATH, or, a table of appropriate string lengths per field could be provided.<br>
Where interception is most useful is in implementing an aspect of the<br>
system that cross/cuts a large number of objects. For example, an interceptor could<br>
be written that logs all of the actions in the system that follow a particular pattern<br>
(for example, they fail with "Access Denied").<br>
Object Commands<br>
Object commands are different from object properties in that object<br>
commands are only invoked on the server side. This is because the command<br>
invocation is performed by passing an array of variants from the client to the<br>
server and back. There is no notion of a client side proxy object that is invoked.<br>
The data representation is shown just below.<br>
As can be seen above, a server class description is the same as a client class<br>
description, but also includes a description of a set of commands. A command has<br>
a type, a command and a description. It contains a pointer to a command interface.<br>
The command interface works analogously to an accessor interface used in<br>
accessing properties. The command interface is passed the object to which it must<br>
apply the command and an array of ImgVariant's that contain the input parameters<br>
for the command. Every command can be asynchronously executed, which is why<br>
the interface has both a BeginCommand and EndCommand method.<br>
Each command also defines the type of all of its parameters and also has a<br>
list of all the descriptions for each command.<br>
Like property accessors, commands can be built on top of dynamic types.<br>
However, since at a fundamental level they correspond to performing an action (as<br>
opposed to retrieving data) and since dynamic proxy objects don't have to be<br>
constructed for wire marshalling purposes when invoking commands this is not<br>
likely to be as useful as for properties. It might have utility if a command were<br>
extended via interception.<br>
IATL Commands<br>
IATL provides a mechanism to map GDI commands directly to C++ class<br>
method invocations, exactly like it provides a mechanism to map CDI type map<br>
properties directly to C++ fields and methods.<br>
IATL allows the caller to implement the command as a single method in<br>
which as the asynchronous BeginCommand, EndCommand pair is automatically<br>
built for the implementer. This is useful if the implementer wants to implement a<br>
command which does not do any IO. Alternately, IATL lets the class provide two<br>
methods and implement the command asynchronously. The mechanism used to<br>
huild IATL commands is summarized in the code excerpt just below.<br>
This excerpt shows a. number of different ways that methods from a class<br>
can be exposed as a GDI command.<br>
The Print command is implemented in ServerPrinterCommandBase and is<br>
implemented as a single synchronous method. All synchronous methods receive a<br>
Img::iatl::CommandParams parameter as their first argument. This structure holds<br>
the workflow and common data interface associated with the command. The<br>
second parameter maps to the first command argument and so on. In order to<br>
disambiguate which parameters are input and which are output parameters, the<br>
caller must supply a parameter to the Command function to indicate how many<br>
input and output functions the method has. For example, when the print command<br>
—/<br>
is referenced:<br>
Command(glln, IMQ_ATTR_METHOD(ServerPrinter::Print), L"Print",<br>
L"This prints out something"),<br>
The glln parameter indicates that this is command that has one input<br>
parameter. The input parameters must precede the output parameters in any<br>
method that can be invoked as a command.<br>
Just like a property type map, a command type map can be inherited from a<br>
base type into a derived type. This is accomplished with the Inherits function:<br>
Inherits (IMQ_ATTR_INHERIT_TABLE (ServerPrinterOommandBaBe)) ,<br>
The types of the command parameters will automatically be deduced from<br>
the method arguments. However, the optional description field must be supplied in<br>
the table. This is done via the InDescrip and OutDescrip functions. For example:<br>
Command (gllnlOut, IMG_ATTR_HETjflOD (ServerPrinter: iPrintAndRandom)) ,<br>
InDeBaripdi" Something that will be output to the debugger"),<br>
OutDeBcrip (Ii"A fractional random number"),<br>
Here the Command Function provides the basic definition of the command,<br>
and the InDescrip and OutDescrip functions describe the first input and parameters<br>
respectively. If more that one parameter is described, multiple calls to InDescrip<br>
and OutDescrip can be made.<br>
The other noteworthy feature shown by the IATL command map is the<br>
ability to implement an asynchronous command. This is illustrated by the<br>
BeginNothing and EndNothing methods on the ServerPrinter class:<br>
This is referenced by the following in the command description:<br>
The Command function in this case does not need to be told which are<br>
input and output parameters since input parameters are by definition taken by the<br>
Begin method and the output parameters are by definition returned by the End<br>
method, hi this case, the Begin method and End methods also take different<br>
structures to a synchronous (single method) command, namely:<br>
Img::iatl::InCommandParams and Img::iatl::OutCommandParams. The<br>
InCommandParams contain the callback interface to indicate that the operation is<br>
complete and the context information that can be saved and associated with the<br>
operation. The End method is passed back the context information and can return<br>
the result of the command as an error code or a set of return parameters.<br>
Query compiler<br>
The query compiler provides a mechanism to compile a GDI query into<br>
either a filter that can be applied against any object that has a class description or a<br>
parse tree. The interface exposed by the query compiler is shown in the code<br>
excerpt just below.<br>
A server side GDI instance provides the mechanisms to compile a query. If<br>
a query filter is desired, then the CompileQuery method of the nmgCommonData<br>
server interface is used. If a parse tree is required, then the CompileQueryTree<br>
method is called.<br>
The query filter is returned as a factory. When a particular class description<br>
is passed to the query filter factory then a query filter is returned. The query filter<br>
under the covers builds a type map against a class that is dynamically generated by<br>
the query. When it is bound to the server object is builds an optimized map against<br>
the server object. This optimized map is used to populate the query object against<br>
which the query is then applied.<br>
The query filter that is returned from the query filter factory is bound by<br>
definition to a particular server class. It can be applied against multiple server<br>
class object instances. It is not thread safe. If the caller wants to use the same<br>
query from a different thread then, they can obtain a different query filter instance<br>
from the same query filter factory and use that in a different thread.<br>
A query filter has the advantage that it can be applied against any class that<br>
supports a class description. However, for a filter to be applied against a class the<br>
class must be instantiated and all instances that could potentially be matched by<br>
the filter must be .evaluated. This is fine for a reasonably small set of objects<br>
(possibly on the order of 10,000 for a modern computer), but it performs<br>
extremely poorly for a large set of objects. For a large set of objects, a query<br>
mechanism such as used by SQL should be used. However, the GDI query syntax<br>
is not identical to the SQL syntax. To solve this problem, a query tree can instead<br>
be compiled and then translated to a SQL query. Allowing the GDI query compiler<br>
to run allows issues such as operator precedence and parentheses to be evaluated<br>
by the GDI compiler consistently with how it would handle the same query for a<br>
query filter.<br>
The returned interface from the CompileQueryTree method returns an alias<br>
to a compiled query tree through the Root method. The memory occupied by the<br>
returned parse tree will be returned to the system when the IlmgQueryTree<br>
interface is released.<br>
hi one embodiment, a parse tree starts with a query node; the query node<br>
can either be a comparison, or it could be a Boolean node. If it is a Boolean node,<br>
then the node has an operator and in turn consists of two query nodes. This is the<br>
construct that allows a parse tree to be built. If it is a comparison node, then the<br>
comparison consists of a parse identifier and a constant. If the identifier has<br>
appeared twice in the same expression, as would be found in the following query:<br>
"Printer.cJobs &gt; 10 AND Printer.cJobs 
instance will appear twice in the parse tree. The pCookie field is a placeholder in<br>
the tree that allows a caller to store their notion of an identifier in the cookie. For<br>
example, if Printer, cJobs translated to the NuniberOfJobs column in a database,<br>
this could be stored in the cookie. Aside from providing an extensibility point, the<br>
cookie is ignored.<br>
Transactions<br>
Transactions are the mechanism that the GDI uses to ensure that an<br>
operation either succeeds completely, and that if it fails, no intermediate state is<br>
stored on the machine. The actual mechanism to handle transactions is distributed<br>
between the GDI and the CAS. The GDI provides the interfaces to handle<br>
transactions and work flows. The CAS provides the mechanisms required to<br>
ensure transactional correctness and to provide for deadlock-free locking<br>
strategies.<br>
Each transaction is controlled by precisely one transaction object. Each<br>
transaction object has one logical store object. Each logical store in the system is<br>
referenced by a QUID. The store object coordinates handling any persistent state<br>
that the transaction needs to coordinate. The restriction of only one store is<br>
reasonable if one considers that the system cannot guarantee that two commits to<br>
two transactional stores can be guaranteed to succeed if the stores are not<br>
distributed resource managers (DRMs). In the case that they are DRMs, then the<br>
transaction will be coordinately across one logical store, namely that provided by a<br>
distributed transaction coordinator (DTC), like that found in COM+.<br>
Each transaction also holds a number of dependent actions. The rule is that<br>
a dependent action cannot fail to either Commit or Revert its operations. The<br>
dependent actions are generally used to couple cached state (or locks) to the state<br>
of the persistent store. For example, the CAS clones each object before applying<br>
the transaction to the store, if the store successfully commits the changes, then the<br>
cloned objects are swapped into the cache. The transaction interfaces are shown<br>
just below.<br>
Note that all of the interfaces use the COM asynchronous calling pattern if<br>
the caller or the implementer desires to use an asynchronous calling mechanism. If<br>
they do not, they can still make synchronous calls to the interface or implement<br>
synchronous transaction dependent actions.<br>
Anyone wishing either to implement a store or a transaction dependent item<br>
must implement the IlmgTransactionDependentltem, interface. This interface has<br>
two methods, Commit or Revert. A store may fail a commit (but not a revert) any<br>
other dependent item must always succeed its Commit and Revert methods.<br>
Each transaction can have precisely one store. The current store and its<br>
store GUID can be retrieved with the GetTransactionalCollection method.<br>
If the caller wants to set a transactional store, the<br>
SetTransactionalCollection call is used. Since transactions are a multi-threaded<br>
interface, the SetTransactionalCollection takes both a GUID, the collection to be<br>
set, and it returns the existing collection, if it is there. There are three cases (as<br>
indicated by the ETransactionSetResult return parameter).<br>
• The transaction currently does not have an associated store object. In this<br>
case, the return will be TransactionCollectionSet and the passed in<br>
collection will become the store associated with the transaction.<br>
• The transaction currently has a store object, but it has the same GUID as<br>
the one you are specifying. In this case, the transaction object will return<br>
the existing collection to the caller. The caller should release their previous<br>
collection and continue the call with the persistent store currently hi the<br>
transaction.<br>
• The transaction currently has a store object, and it is a different store (it has<br>
a different store GUJD). In this case, the transaction object will return<br>
TransactionCoUectionlncompatible. The caller will typically fail the<br>
operation at this point. (This will cause the transaction to revert).<br>
Since the transaction coordinator cannot know the interface to the store<br>
object (it could be anything from a transactional file system to a SQL database),<br>
this is returned to the caller as an lUnknown from which they can retrieve the real<br>
store interface via Querylnterface. The store must implement the<br>
IlmgTransactionDependentltem so that the transaction object can correctly<br>
Commit or Revert the changes to the store.<br>
Transaction dependent items are committed or reverted in two phases. This<br>
is specified via the TransactionOrderFirst and TransactionOrderLast parameter to<br>
InsertDependentAction. Transactions that rely on the CAS for locking should only<br>
use TransactionOrderFirst since the CAS uses dependent items of<br>
TransactionOrderLast to ensure that object locks are released after the<br>
coordination transaction is committed or reverted.<br>
Work Flow<br>
The GDI interfaces are largely asynchronous. Thus, a single operation can<br>
be completed on one thread, or it could be completed on multiple threads. Systems<br>
that use less asynchronous programming often can associate state with a thread,<br>
for example, a thread could have an associated transaction that is always implied<br>
on any methods issues from the thread once the transaction is started. The notion<br>
of a work flow replaces this general concept of thread in the GDI. A work-flow<br>
always corresponds precisely to a batch that is submitted by the user. The user<br>
does not create a work flow. It is created automatically by the GDI when a new<br>
batch is issued. A server plug in can-create a work flow from scratch if it wants to<br>
for its own purposes.<br>
A work flow also provides support for creating new asynchronous work<br>
items and associating it with the work flow and hence the origination batch. When<br>
the batch is cancelled, the work flow is cancelled and hence, all items on the work<br>
flow are requested to cancel. Using this mechanism results in the GDI not having<br>
to support an explicit cancellation method on every interface, the method just<br>
receives a work flow instead.<br>
The work flow interface is shown just below.<br>
We will focus the discussion on the following services provided by the<br>
work flow: work items, tokens, scopes and transactions. Transactions are covered<br>
independently above, but the work flow has some special handling for them.<br>
Work Items<br>
In order to implement a work item, the caller must implement the<br>
IlmgWorkltem interface. The Run method is called on the interface when the<br>
work item executes and the Cancel method is called if the work flow is canceled.<br>
There are three basic types of work item:<br>
A normal work item, created with "AddWorkltem". This sort of work item<br>
will run as soon as sufficient resources are available. Like all work items,<br>
the caller can specify what sort of work item is running through the work<br>
item flags.<br>
A wait-able work item, created with "AddWaitableltem". A wait-able work<br>
item will run when its associated event is signaled.<br>
A dependent work item, created with "AddDependentltem". A dependent<br>
work item isn't run, but its "Cancel" method is called if the work flow is<br>
cancelled. This allows the caller to use a different asynchronous method<br>
(for example, they might call ReadFile with an overlapped structure), but<br>
still receive cancellation notifications from the original work flow.<br>
The IlmgWorkltemControl interface fulfills two purposes - it allows a waitable<br>
work item to return an event handle that can be set to trigger the work item. It<br>
also allows the caller to cancel a particular work item by releasing the interface.<br>
The cancel call in this case is always asynchronous, i.e. the work item is informed<br>
of cancellation but the Release call on the interface does not wait for the<br>
cancellation to complete.<br>
This is unlike the behavior of the Shutdown method on a work flow. The<br>
shutdown method synchronously waits for all of the work items in the work flow<br>
to be cancelled.<br>
Tokens<br>
Tokens are used for marking particular state on the work flow. They are<br>
intended to be used to prevent infinite recursion when implementing interception.<br>
Namely, a particular type of interception can add a token to the work flow and<br>
then prevent that sort of interception from occurring again.<br>
A token is a GUID - tokens can be added to a work flow, found in a work<br>
flow and removed from a work flow.<br>
Transactions<br>
A work flow can have precisely one transaction. The work flow is the only<br>
interface" from which transactions can be created. The work flow provides a<br>
number of helper methods for dealing with the current transaction.<br>
• CreateTransaction creates a transaction and associates it with the current<br>
work flow. If the transaction already exists, this is considered benign, the<br>
current transaction is returned. (The caller can deduce that this occurred<br>
through the ElmgBatchTransactionCreation return).<br>
GetBatchTransaction returns the batch transaction currently associated with<br>
the work flow, if it exists. It returns NULL if it does not.<br>
InsertTransactionalCollection inserts a collection into the transaction<br>
associated with the work flow. The inserted collection or the existing<br>
collection is returned via the ppISetTransCollection returned. If the<br>
collections are incompatible (they use different GUIDs), the call will fail.<br>
GerTransactionalCollection retrieves the transactional collection associated<br>
with the transaction associated with the work flow.<br>
Scoped work flows<br>
A work flow can contain other work flows. When a work flow is scoped<br>
within another work-flow, it automatically inherits all work items and tokens from<br>
its parent. It also inherits any transaction that is in progress from the parent work<br>
flow. Scoping work-flows allows two main types of functionality:<br>
Tokens in parent work flows cannot be deleted. This allows the set of<br>
tokens in a work-flow to be "locked" until the work flow invocation<br>
recurses back out to the caller. This is useful in that it can prevent an<br>
interceptor from inadvertently removing tokens that it shouldn't.<br>
A non-transactional request from a user might require a transaction in order<br>
to be executed as an implementation detail. For example, a deletion request<br>
might require a number of sub-objects to also be deleted. Since the original<br>
batch might contain other items that should not or can not be made<br>
transactional, we wouldn't want to add a transaction to the work flow<br>
created by the caller. The solution is to produce a work flow scoped inside<br>
the first work flow and then associate the transaction with the inner work<br>
flow. This allows any cancellation requests on any work-items to be<br>
maintained and also allows any tokens on the original work flow to be<br>
preserved without making the original work flow transactional.<br>
Server Side Notifications<br>
The GDI supplies support for plug in collections wishing to support<br>
notifications. This allows a notification channel to retrieve data from a remote<br>
collection and a local (in-proc or sandboxed) collection at the same time and still<br>
consistently handle the notification channel on behalf of the client. The CAS<br>
provides additional support for notifications on particular objects (such as ensuring<br>
that notifications are correctly serialized through its locking infrastructure).<br>
Each batch collection is given a IlmgNotificationDataServer interface that<br>
is used to push data through to the client collection for each notification channel.<br>
The GDI itself maintains the client collection and other infrastructure for the<br>
notifications.<br>
The notification data server interface exposes three methods:<br>
RegisterShutdown - This allows the caller to register an interest in the<br>
channel being shut down. For example, a remote access adapter might need<br>
to know to pull down its own notification channel when the client<br>
notification channel is pulled down.<br>
CreateNotificationObject - This create a new notification interface that<br>
must be used to push data through the notification channel. Each<br>
nnagPushNotifyDataThroughChannel instance is not thread safe. The<br>
system provides the guarantee that any changes sent through an<br>
IlmgPushNotiryDataThroughChannel instance are sent as a group or not af<br>
all.<br>
SendFailure - It is possible that a fatal error occurs that prevents<br>
notifications being sent through the channel. In this case, the SendFailure<br>
method can be called. It is guaranteed to tear down the channel. It will also<br>
send the error information to the caller in a best effort manner.<br>
The push notify data through channel interface has the following methods:<br>
• SendAddObj ectNotify - This tells the channel that a new notification obj ect<br>
has been added. The object could either have been added because the object<br>
really has just been created, or it might instead have changed state to match<br>
a query filter.<br>
• SendRemoveObjectNotify - This tell the channel that either an object has<br>
really been deleted, or that it no longer matches fhe query filter and hence<br>
has logically been removed from the client collection.<br>
• SendChangeDataNotify - This sends individual field infbnnation down the<br>
channel to the client. The map index is the index of the field in the client's<br>
registered class description. Each change sent can have one of two<br>
behaviors. If the change is buffered somewhere in the system and another<br>
change to the same field occurs, then the new field value takes its place.<br>
This has the advantage of minimizing the storage required for any buffered<br>
notification data. Alternately, every change might be significant, in which<br>
case the caller can request that the history of every change is kept.<br>
• SendDone - This finishes the changes the have been sent to the<br>
nmgPushNotifyData interface. Either the initial data for the notification is<br>
being sent, in which case NotifyUpdatePopulate variation can be used, or<br>
this is a notification about a subsequent change in object state in which case<br>
NotifyUpdate can be specified.<br>
Friendly name resolution plug-ins<br>
The mechanism that a plug-in batch collection uses to plug into the<br>
canonical name-space is described in section entitled "Plug-In Interface" above.<br>
Basically, each collection is identified by a QUID. If the batch collection also<br>
wants to support friendly names it must register a friendly name resolution<br>
handler. This translates a friendly name of the requested class to the canonical<br>
name if possible. Friendly name resolvers are registered with the GDI in the same<br>
way that normal plug-ins are registered, except that the friendly name class is used<br>
instead of a collection GUID and a different class factory and interface are used<br>
instead. The class factory and plug in interface are shown just below.<br>
When the client requests a name resolution, if the friendly name resolver<br>
cannot find the name in the cache, the name resolving handler for each registeredplug-<br>
in for that class is called (in a parallel invocation). Each name resolver<br>
attempts to resolve the name, when the name resolution is finished, the resolver<br>
calls Done on the IlmgServerltemCompletion interface. The name resolver will<br>
then call EndResolveName with the same context returned by BeginResolvaName.<br>
The name resolver then returns an IlmgCanonicalName iterator that contains any<br>
canonical names that the name resolver has determined to correspond to the<br>
friendly name.<br>
Note that the name resolver plug-in will typically perform its name<br>
resolution by using Gets, Queries or Commands against the. GDI interface. Thus,<br>
implementing an asynchronous interface will typically not be too problematic<br>
since it will in turn be calling another asynchronous interface.<br>
In order to prevent the caller from having to implement an<br>
IlmgCanonicalName iterator for every query collection, a collection interface is<br>
provided that accumulates canonical names and from which an iterator instance<br>
can be returned. This interface is shown just below.<br>
Collection Adapter Service<br>
In the illustrated and described embodiment, the nmgBatchCollection<br>
interface is deceptively complex to implement. The caller must run through each<br>
batch item, decode it, and decide how to respond to it. Generally, the only reason<br>
why a collection would want access to the batch is to preserve the batch for<br>
transmission across machine or process boundaries. In the case where the batch<br>
actually interacts with a group of objects that are loaded to and from a persistent<br>
store, this is a great deal of complexity for the plug-in to handle. For this reason<br>
the Collection Adapter Service is provided. The Collection Adapter Service<br>
provides the following functionality:<br>
• It retrieves objects from a set of plug-in collections.<br>
• It caches instantiated objects and flushes them when not in use.<br>
• It manages the "binding of the client objects to the server objects through the<br>
type map.<br>
• It coordinates transactions between compatible collections.<br>
• It manages object locking in conjunction with transactions.<br>
• It manages both synchronous and asynchronous objects.<br>
• It interacts with the query compiler to implement the object.filters.<br>
• It makes best use of resources by dynamically choosing to execute calls in<br>
serial or in parallel.<br>
• It maintains object concurrency through an optimistic locking scheme.<br>
• It handles object change notifications.<br>
If the basic GDI is the glue that holds the various plug-ins together, then the<br>
Collection Adapter Service is responsible for ensuring that a smart, asynchronous,<br>
high performance plug-in is as simple to implement as possible. The collection<br>
adapter service model is shown in Fig. 14 in accordance with one embodiment.<br>
A given CAS instance can have multiple object collections plugged into it.<br>
Each object collection supports a single class name, for example, "Printers" and all<br>
the objects in a given object collection are homogenous. Thus, they can be<br>
described by a single class description which expresses all of the properties and<br>
commands that a given server object implements. The collection adapter service<br>
uses the server class description to transfer data between the client and the server<br>
objects and execute object commands. Each object in the server implements some<br>
basic functionality via its HmgObject interface. The HmgCollectionAdapter has<br>
the following interface:<br>
The client instantiates a collection adapter by calling "CoCreatelnstance" in<br>
its IImgBatchCollectionFactory::CreateInstance method. It calls<br>
HmgCollectionAdapter:.'Initialize and passes it the IlmgCornmonDataServer<br>
interface that it was passed. It then instantiates and registers each of its object<br>
collections through the RegisterObjectCollection call.<br>
An nmgObjectCollection has the following methods:<br>
The GetTransactionCollectionData call returns how the collection supports<br>
transactions, a collection can support no transactions, transactions as dependent<br>
item (this can be supported by transient collections) or it can support transactions<br>
by returning a custom transaction interface that depends on the underlying storage<br>
system and an ID that uniquely identifies the scope over which a transaction can<br>
be successful.<br>
The GetCollectionData call returns the object class name, the Objectld used<br>
in the optimized type map binding and the server class description that describes<br>
each object. The remaining calls, BeginGet and EndGet and<br>
BeginEnum/EndEnum allow objects to be retrieved from the collection. The<br>
shutdown method is called by the CAS when the IImgBatchColIection::Shutdown<br>
method is called.<br>
Any call that the CAS executes that is likely to be time consuming will take<br>
the form of a Begin/End pair. Each Begin call takes an nhigServerltemCompletion<br>
interface and allows a context to be returned through the ppContext parameter.<br>
The CAS provides the following guarantees to the implernenter of the interface:<br>
• If the Begin call fails, the End call will not be called.<br>
• If the Begin call succeeds, the End call is guaranteed to be called.<br>
• The End call will not be called until the HmgServerItemCompletion::Done<br>
method is called.<br>
• The End call will not be made until the Begin method returns.<br>
• The End call will be passed the context returned in the Begin call.<br>
These guarantees allow the Begin method to implement a synchronous call<br>
by calling Done within the Begin method. Any IO bound operation it performs<br>
should be executed either in another thread (preferably consolidated with other<br>
operations), or it should be implemented in turn as an asynchronous call. When the<br>
asynchronous item completes, then the nmgServerItemCompletion::Done method<br>
should be called. If the begin method needs to keep track of any state specific to<br>
the call, then it can be returned in the ppContext parameter. Since the CAS<br>
guarantees that the End call Vill be made, the context can always be freed. The<br>
CAS uses the following mechanism for scheduling calls:<br>
If the call is synchronous (Done is called inside the Begin method), and the<br>
caller requests parallel execution, the execution of the method is assumed to<br>
be CPU bound. Thus, the next call will be serialized on the first. If a call<br>
fails, the result is recorded, but all subsequent calls are still made.<br>
If the call is asynchronous and the client request parallel execution, then the<br>
next "Begin" method is called immediately in the origination thread.<br>
If the call is asynchronous and the client requests sequential or transactional<br>
semantics, then the remainder of the work will be performed in the same<br>
thread as the HmgSeriverItemCompletion::Done method is called on.<br>
These rules mean that a client collection or object of the CAS must ensure<br>
that IO bound operations are executed in the asynchronous calling pattern,<br>
otherwise it can prevent parallel execution of other work items.<br>
Objects have the following interface:<br>
The methods to be implemented are as follows:<br>
Initialize call is called by the CAS when the object is first returned to it<br>
from a collection. It passes the object a handler interface that allows the<br>
object to delete itself, lock itself, interact with transactions and send change<br>
notifications to the rest of the system. It can also return a call filter. The call<br>
filter indicates whether the object supports partial instantiation (in which<br>
case the BeginGet/EndGet methods will be called on it before reading any<br>
data from it). It also indicates whether it supports persisting the object by<br>
only writing out certain fields. In this case the BeginSet/EndSet methods<br>
will be called specifying precisely which properties the caller specified in<br>
the set.<br>
GetRealObjectAddress returns the object address that the<br>
ImgServerClassDescription accessors are relative to. This is necessary<br>
because if the object is implemented using multiple inheritance the<br>
IlmgObject interface address is not necessarily the same as the real object<br>
address.<br>
BeginGet/EndGet — These methods are only called if the object indicates it<br>
supports a partial object in its call filter. The object will be passed the tags<br>
that indicate which fields the optimized map is about to read. The object<br>
can use this to fetch heavy fields after its first instantiation from a persistent<br>
store. If the object does this and the call is IO bound (which it almost<br>
invariably will be), then it must use an asynchronous calling pattern.<br>
CloneObject — The CAS assumes that the object is implemented in an<br>
immutable fashion. This allows the object to remain unlocked while data is<br>
being read from it. It simplifies transactions since the object can be held in<br>
its duplicated state until the transaction commits. Thus, the object will be<br>
asked to Clone itself before a set occurs. Object must be coded in an<br>
immutable fashion to be compatible with the CAS.<br>
BeginSet/EndSet - This pair of methods is called in a set after the object<br>
has been cloned and its accessors have been used to change its state. The<br>
object can validate that its new state is valid in this call. If it requests it in<br>
the call filter, it will be told which fields were specified by the client when<br>
the set occurred.<br>
Object Handler<br>
The object handler is the interface that is passed to each object by the CAS<br>
to allow the object to interact with the CAS in various ways. There is precisely one<br>
instance of an object handler for each object that is held cached in the CAS. The<br>
IJmgObjectHandler also exposes an asynchronous lock for each object. This lock<br>
is used by the CAS to logically serialize access to the object for state changes<br>
which includes both transactions and change notifications. Several actions on the<br>
object require the object to be locked. The object handler interface enforces this<br>
semantic. The object handler interface is shown just below.<br>
Object Asynchronous Lock<br>
An important method is GetObjectLock, which allows the caller to retrieve<br>
the lock associated with the object. The lock returned is an asynchronous lock with<br>
support for transactional locking. The lock and the associated semantics are used<br>
by the CAS and the same semantics should be used by other callers. The interfaces<br>
are shown just below.<br>
The lock is asynchronous, i.e. it calls you back when you can acquire the<br>
lock. This is an intentional design choice that provides for the following<br>
capabilities:<br>
• A work flow attempting to acquire a lock can be cancelled. Since the lock<br>
interface is asynchronous, the caller can be notified that the lock acquisition<br>
attempt was cancelled.<br>
• Since locks are used for serializing object access across transactions and<br>
since transactions might have to acquire many objects and will have to<br>
typically write the state to a store, an object lock could potentially be held<br>
for a long period of time. Thus, any lock access could potentially be<br>
waiting on an operation which is IO bound. Using an asynchronous lock<br>
allows the thread to be reused for other CPU bound operations, rather than<br>
having to wait for the IO to complete.<br>
Note that the CAS does not use the object lock for Gets/Queries and<br>
Commands. This means that although a transaction might be logically holding an<br>
operation, it only serializes sets and notifications. If the caller wishes a command<br>
to be transactional, they must create the transaction themselves and acquire the<br>
object lock.<br>
A caller wishing to acquire the lock must implement the HjngLockEntry<br>
interface. This interface has two methods, EnterLock and Notify Cancel.<br>
EnterLock is called when the caller has acquired the lock. An<br>
ImgLockContext is passed • to the EnterLock function. This lock context is<br>
precisely associated with that particular acquisition of the lock and must be handed<br>
to the lock interface when the lock is released. This fulfills two purposes:<br>
• If another caller erroneously tries to release the lock without acquiring it,<br>
the release has no effect.<br>
• The fact that a lock must be held can be expressed semantically by other<br>
interfaces by requiring the lock context to be presented. This can also check<br>
that the lock is indeed held before doing the associated action.<br>
In addition, if the workflow on which the caller acquired the lock is<br>
cancelled, then the NotifyCancel method on their interface will be called. They<br>
can then decide whether they still must acquire the lock, or whether to abort their<br>
access to the lock. They can cancel their acquisition of the lock by releasing the<br>
returned lock sequence interface on which they called AcquireLock.<br>
It would be undesirable if the caller couldn't guarantee that a lock could be<br>
acquired. For example, they might wish to acquire a lock, increment a reference<br>
count and then release the lock. Then they might perform some actions on the<br>
object, acquire the lock again and decrement a reference count. If they couldn't<br>
acquire the lock for the second operation, then the reference count would never be<br>
correctly decremented.<br>
The ability for the caller to guarantee access to the lock is provided by the<br>
HmgLockSequence interface. Once a lock sequence is returned from the lock any<br>
sequential acquisitions and releases of the lock are guaranteed to succeed. This<br>
works because as an implementation detail, the HmgLockSequence interface is<br>
implemented by an object that reserves enough storage to always be able to<br>
acquire the lock.<br>
Locks and Transactions<br>
A transaction might need to lock many objects in sequence. This provides<br>
an opportunity for the system to deadlock if there is any cyclical acquisition of<br>
locks between more than one transaction. It is semantically illogical for two<br>
transactions to be holding the same lock, so the lock provides special support for<br>
transactions. This is automatically utilized by the CAS when locking the object<br>
before setting properties and it should be used by any objects that wish to<br>
implement transactional semantics.<br>
A lock can be held by precisely one transaction at a time. A transaction<br>
wishing to acquire a lock uses the AddTransactionToLock call. If there is already<br>
a transaction holding the lock, the call will return FALSE in the<br>
pbTransactionAdded parameter. The transaction should then be reverted (which<br>
frees any locks or resources currently held by the transaction) and wait for the<br>
existing transaction to complete before returning a failure to the caller. The caller<br>
calls WaitForTransactionToFinish to wait for any transaction holding the lock to<br>
complete (they will be notified asynchronously). If there is no transaction holding<br>
the lock, they will be called back immediately. The lock will automatically be<br>
disassociated with the transaction if the transaction is committed or reverted.<br>
The reason that the caller should wait for the existing transaction to finish is<br>
to guarantee that if the caller retries the operation they will not simply retrieve the<br>
old (unchanged) object state again and "spin" against the transaction holding the<br>
lock.<br>
CDI/CAS optimistic locking model<br>
The GDI intentionally does not expose any locking constructs to clients.<br>
There are a number of reasons for this:<br>
• Each lock would have to add additional context overhead to the server that<br>
could be maintained by a client.<br>
• If a client went into an error state and held onto a lock, it could cripple the<br>
operation of the server.<br>
• In order to handle clients not releasing locks, a manual lock-breaking<br>
mechanism would have to be added to the server. This is additional UI and<br>
maintenance that is otherwise simply avoided.<br>
However, it is desirable that the server state is maintained correctly and that<br>
the "dueling administrators" problem is avoided. If two administrators<br>
simultaneously tried to rename a printer, we would want to ensure that one rename<br>
succeeded and the other failed.<br>
The system maintains these semantics partly by the mechanism that<br>
transactions use to acquire object locks. It is also maintained by giving every<br>
object an "ObjectLockld" property. Simply put, in order to change an object state,<br>
you must also supply a lock id that matches the current object lock id. This<br>
indicates that you were aware of the last object state before attempting to change<br>
the object. If you supply an object id that does not match, the attempt to change<br>
state will fail. In response the caller must re-get the properties that they wish to<br>
change and hence re-get the lock id. A well written client would then check the<br>
properties to ensure that the change they wish to effect is still meaningful and then<br>
attempt the operation again.<br>
Object change handler<br>
In order to retrieve a change handler for an object, the object lock must be<br>
acquired and then the GetChangeHander method on the object handler must be<br>
called. The GetChangeHandler method requires the lock context. The other<br>
mechanism that an object can use to acquire a change handler is that it is passed in<br>
to the property accessor as a parameter during a set. (The CAS in this case<br>
acquires the object lock before setting any object properties for you). The object<br>
change handler interface is shown just below.<br>
The GDI change handler interface is discussed in section above. That<br>
interface provides the capability to send changes down a particular channel. The<br>
CAS adds the capability to correctly scope queries and handle all of the channels<br>
that might be interested in a particular object. All that the object has to do is<br>
indicate which properties have changed. The simplest mechanism is to call<br>
NotifyChange and pass the tag for the field which has changed. The CAS will then<br>
retrieve the data for that field via the property accessor and send the property<br>
change notification to all channels that are interested in the change.<br>
In order the save the CAS the effort of retrieving the properly, the caller can<br>
also directly specify the data via the NotifyChangeData call.<br>
Finally when all of the changes have been accumulated into the change<br>
handler, they can be sent via the SendChanges method. If any of the changes<br>
cannot be sent, the CAS will tear down all notification channels that might target<br>
that object.<br>
IATL support for change notifications<br>
Change notifications are not difficult for an object to implement. To make<br>
it even easier, if a property of your object is only modified by through a GDI<br>
property get or set and that property is implemented as a data member, then IATL<br>
will automatically generate the change notification code for you. When specifying<br>
the field, the gNotify modifier need only be passed to the Field function in the type<br>
map. This is shown just below.<br>
This will automatically build a get and set accessor for the property. If the<br>
property changes, the change will be sent to the change handler supplied to the<br>
property accessor by the CAS.<br>
Remaining Object handler functions<br>
Delete Object<br>
This function deletes the object from the CAS's cache. This will also send a<br>
change notification to the clients. The object must be locked and the lock context<br>
presented in order to delete the object.<br>
Current Object<br>
The CAS uses an immutable object model. When an object is modified, it is<br>
cloned and then inserted into the cache if its state is changed. If an error occurs,<br>
the new object is discarded. An interesting implication of this design is that if the<br>
object wishes to send change notifications as a result of an asynchronous event or,<br>
if it otherwise needs the latest version of the object during a property get or during<br>
a command, it cannot know that the instance of the object it currently holds is the<br>
correct one. To handle this case, the object handler can retrieve the current object<br>
instance. Since object state changes are protected by the object lock, the lock must<br>
be acquired before the current object can be meaningfully retrieved.<br>
HoldObjectlnCache and ReleaseObjectFomCache<br>
The CAS normally caches an object in memory for about ten seconds<br>
before it is discarded. An object might decide instead to remain permanently in the<br>
cache or to remain cached while another object is cached. To handle this<br>
requirement, the HoldObjectlnCache method can be called on the object handler.<br>
When called, the object will be held in the cache until the corresponding<br>
ReleaseObjectFromCache call is made. HoldObjectlnCache can be called any<br>
number of times the object will only be released when the same number of calls to<br>
ReleaseObjectFromCache is made.<br>
You can only safely call HoldObjectlnCache in cases where the object is<br>
actively held in the cache already because of some other operations. Otherwise,<br>
there is a potential race condition where the object is being released from the<br>
cache while the call to HoldObjectlnCache is being made. This will not result in a<br>
crash, but, obviously, the HoldObjectlnCache call cannot be honored in this case.<br>
The points at which HoldObjectlnCache are guaranteed to succeed are:<br>
• During the Initialize call to the HmgObject interface supported by the<br>
object.<br>
• During any property get or set or command invocation.<br>
• When the caller otherwise knows that they have issued a<br>
HoldObjectlnCache call in the past.<br>
Framework Provided Collections<br>
The nmgObjectCollection and EmgObject interfaces are not particularly<br>
difficult to implement, and there will be cases when a plug-in using the CAS will<br>
want to or need to implement both. For example, when writing an adaptor that<br>
represents objects on a down-level server via the new data model, you will want to<br>
provide your own HtngObjectCollection. However, there are many cases where<br>
standard framework provided object collections can be used. These are shown in<br>
Fig. 15.<br>
The framework provided collections, and their function are as follows.<br>
The/n Memory Collection provides a dynamic collection of objects that are<br>
not persisted. This collection can be useful when supplied by plug-ins with a few<br>
real immutable objects to expose (such as filter factories). It could also be useful<br>
in providing a store for light-weight non-persist-able objects in such scenarios as<br>
TS printing.<br>
The Persistent Object Collection Service is the collection that provides the<br>
ability to persist objects in a persistent store. There might be many stores in which<br>
objects can be persisted including the registry, SQL databases or WinFS. Each<br>
store will have its own Persistent Object Collection Service instance. The<br>
persistent object collection service will provide support for the persistence of the<br>
object state into the appropriate store. It will use the server type map<br>
(ImgServerClassDescription) to retrieve the necessary object state for storage. In<br>
addition, it will where it is able to, map queries directly into the query support<br>
provided by the underlying store.<br>
The Notification Shim Collection works as follows. In many cases the<br>
system will be bridging to down-level systems that provide limited or no support<br>
for notifications. In this case, the caller needs to enumerate all of the objects,<br>
check to see when a new object arrives or leaves and fire the appropriate<br>
notifications if any fields change. Because the IlmgObjectCollection interface is<br>
public and the ImgServerClassDescription allows the caller to access all of the<br>
fields on an object, a generic shim object collection will be supplied that<br>
automates this behavior. This could also be used for callers that just don't want to<br>
add the couple of extra lines of code to support notifications. However, a default<br>
implementation can be provided for fields that will automatically generate<br>
notifications when they change.<br>
In summary, the framework will supply a number of canned object<br>
collections that will result in most people never having to implement their own<br>
collection interface. An adapter collection interface is the likely exception. A shim<br>
collection is provided to automate the generation of events from a down-level<br>
adapter.<br>
IATL Implementation of DjngObj ect<br>
IlmgObject is also not a particularly difficult interface to implement. In<br>
order to make it as simple as possible to write a standard object, IATL provides a<br>
standard implementation of IlmgObject that supports non-partial object<br>
implementations. The classes it implements are as follows:<br>
TServerObjectBase - Provides a default implementation of lUnknown,<br>
Initialize, BegiuGet/EndGet and BeginSet/EndSet. The get and set<br>
functions don't do anything.<br>
TServerObject - This template adds the GetRealObjectAddress<br>
implementation through base class templatization.<br>
TServerDefaultCloneableObject - This template addes the CloneObject<br>
method. The caller must supply a copy constructor in their derived class<br>
and must either not throw exceptions, throw exceptions if in error, or return<br>
an error from their IsValidQ method after the object has been copied.<br>
TIMCServerObject - This object implements the BeginSet/EndSet method<br>
pair for the In Memory Collection.<br>
Managed Objects<br>
IATL is designed to supply automated support for unmanaged C++ classes<br>
by providing a template library that allows methods and fields to be expressed as<br>
properties and allows methods to be expressed as commands through the GDI.<br>
There are many advantages to remaining in the unmanaged space, however, the<br>
system will also want to provide data driven support for managed objects,<br>
especially as managed code improves in performance, robustness and design<br>
stability.<br>
Since the CAS encapsulates a lot of important functionality, it would be illadvised<br>
to have a parallel managed implementation that does the same thing. The<br>
solution is to use managed metadata to create an ImgServerClassDescription in the<br>
unmanaged space and use it to populate and maintain a shadow unmanaged object.<br>
The solution, in accordance with one embodiment, is shown in Fig. 16.<br>
Here, the class meta-data from the managed object is mapped to an<br>
ImgServerClassDescription in the unmanaged space. This class description uses<br>
accessors that can manipulate a shadow unmanaged object. Each property in the<br>
unmanaged object can be indexed and will correspond to a property in the<br>
managed object. The managed object will use a change notification mechanism to<br>
propagate asynchronous changes to the shadow unmanaged object. Whenever a set<br>
occurs on the unmanaged object, the properties will first be applied to the<br>
managed object and then the state of the managed object will be replicated back to<br>
the unmanaged object. Commands with be directly mapped to method calls on the<br>
managed object.<br>
The advantage of this mechanism is that the most common operations on an<br>
object, Gets and Queries, will be executed entirely on the unmanaged shadow<br>
object. In addition, the unmanaged shadow object can be stored by the unmanaged<br>
Persistent Object Collection Service and can be placed in the In Memory<br>
Collection. This also bypasses the slow reflection mechanisms that would<br>
otherwise be needed to perform a property get. Changes to the managed object can<br>
be constrained to one interop thunk per batch action. Since this occurs after the<br>
CAS, we cannot marshal the entire batch over before it is interpreted. This<br>
limitation should be offset by avoiding the managed path at all in the query and<br>
get cases.<br>
Exemplary Client Device/Print Server Components<br>
Fig. 17 shows an exemplary computing device having components that can<br>
be employed in both a client device and a print system to implement the<br>
embodiments described above.<br>
Computing device 1742 comprises one or more processors or processing<br>
units 1744, a system memory 1746, and a bus 1748 that couples various system<br>
components including the system memory 1746 to processors 1744. The bus 1748<br>
represents one or more of any of several types of bus structures, including a<br>
memory bus or memory controller, a peripheral bus, an accelerated graphics port,<br>
and a processor or local bus using any of a variety of bus architectures. The<br>
system memory 1746 comprises read only memory (ROM) 1750 and random<br>
access memory (RAM) 1752. A basic input/output system (BIOS) 1754,<br>
containing the basic routines that help to transfer information between elements<br>
within computing device 1742S such as during start-up, is stored in ROM 1750.<br>
Computing device 1742 can further comprise a hard disk drive 1756 for<br>
reading from and writing to a hard disk (not shown), a magnetic disk drive 1758<br>
for reading from and writing to a removable magnetic disk 1760, and an optical<br>
disk drive 1762 for reading from or writing to a removable optical disk 1764 such<br>
as a CD ROM or other optical media. The hard disk drive 1756, magnetic disk<br>
drive 1758, and optical disk drive 1762 are connected to the bus 1748 by an SCSI<br>
interface 1766 or some other appropriate interface. The drives and their associated<br>
computer-readable media provide nonvolatile storage of computer-readable<br>
instructions, data structures, program modules and other data for computer 1742.<br>
Although the exemplary environment described herein employs a hard disk, a<br>
removable magnetic disk 1760 and a removable optical disk 1764, it should be<br>
appreciated by those skilled in the art that other types of computer-readable media<br>
which can store data that is accessible by a computer, such as magnetic cassettes,<br>
flash memory cards, digital video disks, random access memories (RAMs), read<br>
only memories (ROMs), and the like, may also be used in the exemplary operating<br>
environment.<br>
A number of program modules may be stored on the hard disk 1756,<br>
magnetic disk 1760, optical disk 1764, ROM 1750, or RAM 1752, including an<br>
operating system 1770, one or more application programs 1772 (such as a user<br>
agent or browser), other program modules 1774, and program data 1776. A user<br>
may enter commands and information into computer 1742 through input devices<br>
such as a keyboard 1778 and a pointing device 1780. Other input devices (not<br>
shown) may comprise a microphone, joystick, game pad, satellite dish, scanner, or<br>
the like. These and other input devices are connected to the processing unit 1744<br>
through an interface 1782 that is coupled to the bus 1748. A monitor 1784 or other<br>
type of display device is also connected to the bus 1748 via an interface, such as a<br>
video adapter 1786. In addition to the monitor, personal computers typically<br>
comprise other peripheral output devices (not shown) such as speakers and<br>
printers.<br>
144<br>
Computer 1742 commonly operates in a networked environment using<br>
logical connections to one or more remote computers, such as a print server 1788<br>
which, in turn, is connected to one or more printers. The print server 1788 may be<br>
another personal computer, a server, a router, a network PC, a peer device or other<br>
common network node, and typically comprises many or all of the elements<br>
described above relative to computer 1742. The logical connections depicted in<br>
Fig. 17 comprise a local area network (LAN) 1790 and a wide area network<br>
(WAN) 1792. Such networking environments are commonplace in offices,<br>
enterprise-wide computer networks, intranets, and the Internet.<br>
When used in a LAN networking environment, computer 1742 is connected<br>
to the local network through a network interface or adapter 1794. When used in a<br>
WAN networking environment, computer 1742 typically comprises a modem 1796<br>
or other means for establishing communications over the wide area network 1792,<br>
such as the Internet. The modem 1796, which may be internal or external, is<br>
connected to the bus 1748 via a serial port interface 1768. In a networked<br>
environment, program modules depicted relative to the personal computer 1742, or<br>
portions thereof, may be stored in the remote memory storage device. It will be<br>
appreciated that the network connections shown are exemplary and other means of<br>
establishing a communications link between the computers may be used.<br>
Generally, the data processors of computer 1742 are programmed by means<br>
of instructions stored at different times in the various computer-readable storage<br>
media of Hie computer. Programs and operating systems are typically distributed,<br>
for example, on floppy disks or CD-ROMs. From there, they are installed or<br>
loaded into the secondary memory of a computer. At execution, they are loaded at<br>
least partially into the computer's primary electronic memory. The system<br>
described herein comprises these and other various types of computer-readable<br>
storage media when such media contain instructions or programs for implementing<br>
the blocks described, in conjunction with a microprocessor or other data processor.<br>
The system described can also comprise the computer itself when programmed<br>
according to the methods and techniques described herein.<br>
For purposes of illustration, programs and other executable program<br>
components such as the operating system are illustrated herein as discrete blocks,<br>
although it is recognized that such programs and components reside at various<br>
times in different storage components of the computer, and are executed by the<br>
data processor(s) of the computer.<br>
Conclusion<br>
The various embodiments described above provide a pluggable architecture<br>
that can allow third party component writers to insert new classes easily into the<br>
system. A routing system is provided that allows data to be retrieved from<br>
multiple data providers. In addition, a name resolution pipeline resolves human<br>
supplied names to internal canonical names. Further, the various embodiments<br>
provide the ability for a client to precisely specify the data that it wants to retrieve<br>
from an object. An extremely efficient mechanism for retrieving data from an<br>
object uses optimized type maps. Once the type map has been built, no further<br>
string comparisons or searches need to be performed. A single pluggable interface<br>
is also provided that that can support any data. This means that as far as setup is<br>
concerned, there need be only one type of installable object. Other object types<br>
can be obtained from a factory object through the collection. This can be used, for<br>
example, to build the pipeline elements.<br>
In addition, a set of services is provided that can allow any object in the<br>
system to easily support queries, support notifications—including filtered<br>
notifications, support caching and work scheduling.<br>
The described embodiments can also provide the ability to tunnel over any<br>
protocol or transport that can handle a set of fundamental types through the access<br>
Adapters. Various embodiments also support the ability to provide collections of<br>
objects that are transported over down4evel protocols, and to allow down-level<br>
(and up-level) protocols to be dynamically added to the system.<br>
In addition, an asynchronous data interface is provided. This is important<br>
because synchronous interfaces choke the server whenever a large number of<br>
ultimately IO bound data writes occur. It also simplifies UI programming since a<br>
single UI thread can execute and not stall against the operations it is performing.<br>
In addition, a batching interface allows arbitrary grouping of object<br>
commands, gets, sets, queries and notification requests. This is important because<br>
it enables clients to support operations such as deleting a collection of printers. It<br>
is also advantageous in that it allows the effects of network latency to be reduced.<br>
For example, when the UI wants to retrieve a number of properties about a<br>
particular queue, it can batch all of its requests in one message which results in<br>
one network round trip, rather than the many network round trips that are required<br>
if the data is retrieved sequentially.<br>
Further, the various embodiments can provide an almost completely<br>
stateless interface, with the exception of notifications.<br>
In addition, the programming model is simplified by making use of a<br>
collection of client objects. Once the objects are populated by a successful batch<br>
execution, all subsequent operations on the retrieved data are guaranteed to<br>
succeed since they are stored in the object state. The programming model also<br>
neatly makes the notification and query client semantics almost identical.<br>
In addition, the GDI enables the following in subsequent iterations, or in<br>
certain collections. First, the GDI enables the ability to dynamically discover new<br>
data types through a standard type metadata system. It allows certain features such<br>
as generic debugging interfaces and data query interfaces. Second, since all<br>
collections have the same interface, they can easily be sandboxed in another<br>
process or App-domain. Third, since all collections have the same interface, it<br>
allows the system to put any collection in a maintenance mode and unload it by<br>
implementing a call counting shim. This is extremely useful for setup when it<br>
upgrades an existing component. Fourth, transactional support can be added quite<br>
easily by allowing batches to also be transactional. Lastly, since all objects use the<br>
same interface, patterns such a decorators can be added easily to the system. This<br>
provides the potential to have the system be extended by third parties in a very<br>
flexible manner.<br>
Although the invention has been described in language specific to structural<br>
features and/or methodological steps, it is to be understood that the invention<br>
defined in the appended claims is not necessarily limited to the specific features or<br>
steps described. Rather, the specific features and steps are disclosed as preferred<br>
forms of implementing the claimed invention.<br>
<br>
<br>
<br>
CLAIMS<br>
1. One or more computer-readable media having computer-readable<br>
instructions thereon which, when executed, provide a software architecture<br>
configured to:<br>
provide an interface configured to provide a generic data model;<br>
provide asynchronous client dispatch which allows a client or client<br>
application to begin a data request which immediately returns control to a client<br>
thread; and<br>
provide asynchronous server dispatch hi which a server can service requests<br>
from the client asynchronously.<br>
2. The one or more computer-readable media of claim 1, wherein the<br>
software architecture is configured to provide cancellation in which calls which<br>
are in progress on the server can be cancelled by the client at any time.<br>
3. The one or more computer-readable media of claim 1, wherein the<br>
software architecture is configured to provide batching in which a client can build<br>
up an arbitrary sequence of actions and have the actions sent to the server as a<br>
unit.<br>
4. The one or more computer-readable media of claim 1, wherein the<br>
software architecture is configured to provide transactional invocation in which a<br>
batch of actions can be assigned semantics that it must execute entirely or not<br>
change the state of the server.<br>
5. The one or more computer-readable media of claim 1, wherein the<br>
software architecture is configured to provide parallel invocation in which a batch<br>
of actions can be assigned semantics that all items may execute in parallel.<br>
6. The one or more computer-readable media of claim 1, wherein the<br>
software architecture is configured to provide interception in which components<br>
can be inserted into the architecture that can perform one or more of the following:<br>
monitor an associated system, synchronously respond to the system or modify the<br>
behavior of the system.<br>
7. The one or more computer-readable media of claim 1, wherein the<br>
software architecture is configured to provide reflection through which properties<br>
that are supported by a given class of object can be retrieved.<br>
8. The one or more computer-readable media of claim 1, wherein the<br>
software architecture is configured to provide:<br>
batching in which a client can build up an arbitrary sequence of actions and<br>
have the actions sent to the server as a unit; and<br>
transactional invocation in which a batch of actions can be assigned<br>
semantics that it must execute entirely or not change the state of the server.<br>
9. The one or more computer-readable media of claim 1, wherein the<br>
software architecture is configured to provide:<br>
batching in which a client can build up an arbitrary sequence of actions and<br>
have the actions sent to the server as a unit; and<br>
parallel invocation in which a batch of actions can be assigned semantics<br>
that all items must execute in parallel.<br>
10. The one or more computer-readable media of claim 1, wherein the<br>
software architecture is configured to provide:<br>
batching in which a client can build up an arbitrary sequence of actions and<br>
have the actions sent to the server as a unit;<br>
transactional invocation in which a batch of actions can be assigned<br>
semantics that it must execute entirely or not change the state of the server; and<br>
parallel invocation in which a batch of actions can be assigned semantics<br>
that all items must execute in parallel.<br>
11. The one or more computer-readable media of claim 1, wherein the<br>
software architecture is configured to provide:<br>
batching in which a client can build up an arbitrary sequence of actions and<br>
have the actions sent to the server as a unit; and<br>
interception in which components can be inserted into the architecture that<br>
can perform one or more of the following: monitor an associated system,<br>
synchronously respond to the system or modify the behavior of the system.<br>
12. The one or more computer-readable media of claim 1, wherein the<br>
software architecture is configured to provide:<br>
batching in which a client can build up an arbitrary sequence of actions and<br>
have the actions sent to the server as a unit; and<br>
reflection through which properties that are supported by a given class of<br>
object can be retrieved.<br>
13. The one or more computer-readable media of claim 1, wherein the<br>
software architecture is configured to provide:<br>
batching in which a client can build up an arbitrary sequence of actions and<br>
have the actions sent to the server as a unit;<br>
reflection through which properties that are supported by a given class of<br>
object can be retrieved; and<br>
interception in which components can be inserted into the architecture that<br>
can perform one or more of the following: monitor an associated system,<br>
synchronously respond to the system or modify the behavior of the system.<br>
14. One or more computer-readable media having computer-readable<br>
instructions thereon which, when executed, provide a software architecture<br>
comprising:<br>
a printing system having:<br>
a common data interface that serves as an interface to a batching<br>
router, the .common data interface being configured to allow messages from<br>
a client to be built up and dispatched to the batching router, and to send<br>
responses to the client;<br>
a batching router communicatively linked with the common data<br>
interface and configured to receive messages that are passed in by the<br>
common data interface and asynchronously dispatch the messages to one or<br>
more collections;<br>
a plug-in table that is configured to keep track of message handling<br>
plug-ins that are configured to receive and process messages intended for<br>
one or more collections; and<br>
an interception table configured for use hi intercepting and<br>
modifying messages targeted to one or more objects.<br>
15. The one or more computer-readable media of claim 14, wherein the<br>
messages can contain one or more operations that are destined to one or more<br>
plug-ins.<br>
16. The one or more computer-readable media of claim 14 further<br>
comprising a message plug-in communicatively associated with the batching<br>
router and configured to receive sets of messages from the batching router and,<br>
where appropriate, send the messages to another device.<br>
17. The one or more computer-readable media of claim 14 farther<br>
comprising a message service communicatively associated with the batching<br>
router and configured to receive messages and break the messages down into a<br>
sequence of calls on a collection interface.<br>
18. The one or more computer-readable media of claim 14 further<br>
comprising a message service communicatively associated with the batching<br>
router and configured to receive messages and break the messages down into a<br>
sequence of calls on a collection interface, and wherein the message service is<br>
configured to perform one or more of the following tasks:<br>
assign messages to threads;<br>
allow messages to be responded to in multiple, deferred calls;<br>
retrieve appropriate data from objects in a collection to populate a message;<br>
handle cancellation operations;<br>
cache object instances;<br>
transparently lock objects; or<br>
perform reflection services for objects maintained in collections.<br>
19. The one or more computer-readable media of claim 14 further<br>
comprising one or more collections of objects, individual collections maintaining a<br>
homogeneous set of objects,<br>
20. The one or more computer-readable media of claim 14 further<br>
comprising one or more collections of objects, individual collections maintaining a<br>
homogeneous set of objects, wherein individual collections are implemented as a<br>
COM interface that is retrieved from a DLL.<br>
</server></version></class></company></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=+MEw8sdyuZmsPx5bkNBwng==&amp;amp;loc=+mN2fYxnTC4l0fUd8W4CAA==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=+MEw8sdyuZmsPx5bkNBwng==&amp;amp;loc=+mN2fYxnTC4l0fUd8W4CAA==</a></p>
		<br>
		<div class="pull-left">
			<a href="278751-a-method-and-apparatus-for-tandem-submerged-arc-welding-using-one-wire-feeder.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="278814-low-water-loss-battery.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>278813</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>226/DEL/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>01/2017</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>06-Jan-2017</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>30-Dec-2016</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>27-Jan-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>MICROSOFT CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>ONE MICROSOFT WAY, REDMOND, WASHINGTON 98052, U.S.A.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>ADRIAN F. MAXA</td>
											<td>ONE MICROSOFT WAY, REDMOND, WASHINGTON 98052, U.S.A.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>MARK. A. LAWRENCE</td>
											<td>ONE MICROSOFT WAY, REDMOND, WASHINGTON 98052, U.S.A.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 3/12</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>11/077,514</td>
									<td>2005-03-10</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/278813-system-data-interfaces-related-architectures-print-system-data-interfaces-and-related-print-system-architectures by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:33:18 GMT -->
</html>
