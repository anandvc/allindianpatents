<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/215423-a-apparatus-for-reducing-ram-size-while-maintaining-fast-data-access by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:31:43 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 215423:A APPARATUS FOR REDUCING RAM SIZE WHILE MAINTAINING FAST DATA ACCESS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A APPARATUS FOR REDUCING RAM SIZE WHILE MAINTAINING FAST DATA ACCESS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The present invention relates to a method and apparatus for reducing the amount of RAM required while maintaining fast data access. Data records are often saved in nonvolatile memory in order to maintain the contents of the data records even when the circuit is powered down. In the present invention each record in the nonvolatile RAM collection of data records is input to a function H(x) that outputs a tag value. The calculated tag value is saved in predetermined memory locations in RAM. Each calculated tag is shorter in length than the record saved in nonvolatile RAM. Therefore less RAM is required to save one tag value for each data record than is required to save the entire collection of data records in RAM. The value of H(y) is calculated when a data record entry corresponding to y is desired. Then the value of H(y) is compared to all the values in the tag value table. If a match is found, the corresponding record from its location in non-volatile RAM is retrieved and compared to y. If the values do not match the tag value table is searched for another location matching H(y). The result is a very fast comparison with the contents of nonvolatile RAM requiring only a minimal amount of RAM.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>I. Field to the inventor<br>
The present invention relates to electronic circuits. More particularly, the present invention relates to a novel and improved method and apparatus for reducing the RAM requirement in a device while maintaining fast look up and retrieval of data from slow non-volatile memory.<br>
n. Description of the Related Art<br>
Electronic memory of some type is used in almost all modern electrohtic devices. Electronic memory can take the form of floppy discs, magnetic tape, hard discs and integrated circuits (IC). Each form of memory has its advantages and disadvantages. Floppy discs allow numerous data updates on a portable medium but have limited capacity and extremely long read and write access times. Both magnetic tape and hard discs have the capability for enormous capacity but are not portable, require large amounts of support hardware, and have slow read and write access times. Data saved in floppy disc, hard disc, and magnetic tape is often first formatted in software to a file format prior to saving on the medium. When data is recovered from the storage medium the software file routine must be run to locate and extract the requested data. This further slows the data access process because it adds a software layer on top of the already slow hardware access.<br>
IC memory is typically used where memory needs to be integrated into a portable device. Varying the type and number of ICs can scale the amount of memory. ICs require minimum support hardware, are extremely small, and can provide fast read and write access times. Some IC   can easily support direct access without the need for a software layer.<br>
Numerous different types of IC memory are available to provide solutions to various design requirements. Each type of memory is able to satisfy a number of design requirements, but no one memory ‘‘ is able to provide a complete design solution.   The type of memory chosen for any<br><br>
particular application will depend on planned usage and performance design trade-offs.<br>
The most common type of IC memory is Read Only Memory (ROM). As the name implies, the memory is only read accessible. A ROM device cannot be rewritten once it has been programmed. Embedded software applications use ROM to store ohbedded code and data records. The processor in an embedded software application retrieves each instruction from ROM and executes it Different types  mask programmed ROM.<br>
Programmable Read Only Memory (PROM) allows the device manufacturer to program tiie embedded code. This allows for revisions in the code but still does not allow for modification car erasure of the ROM once it has been programmed. Devices that have been programmed with an out of date code revision will either need to be tz erasure and reprogramming.  This limitation, along with the requirement for a UV<br><br>
light for erasure confine the task of updating EPROMs to original equipment manufactures (OEMs).<br>
A device that allows for selective content erasure and reprograinining is the Electrically Erasable Programmable Read Only Memory (EEPROM). Conventional EEPROM allows for data to be updated in place. That is, a particular data location can be erased and new data overwritten in the same location. Data can be read from an EEPROM quicidy but the write cyde of the conventional EEPROM can be orders of magnitude longer fan the read time. Another disadvantage of using a conventional EEPRC’ arises from die inherent structure of the conventional EEPROM cell. The structure of a conventional EEPROM cell requires more transistors than in a standard PROM. The increased structure results in reduced memc’ capacity and increased cost. These disadvantages irate usage of conventional EEPROM prohibitive in most consumer electronics applications.<br>
Random Access Memory (RAM) represents another alliterate means for storage. RAM allows for selective data reads and writes. Read and write can be performed on a byte basis. No erase cydo is required before writing new data to a previously written byte. Moreover, tmlike the EEPROM, the read and write cyde times of the RAM are nearly identical. The density and capadty of RAM is comparable to ROM. The major disadvantage in using RAM is the volatile nature of the stored data- Information stored in RAM is lost whenever the RAM powers down. This is in contrast to ROM, which is nonvolatile memory, where the contents of memory remain even after the IC has been power cyded. In order to retein Ihe contents of RAM, power must be maintained on the chip at all times. This requires a battery back up to the normal power supply. If the battery bade up fails wrhen the power supply is de-CTiergized the contents of RAM will be lost For this reason RAM is not used for embedded code and is used only for dynamic memory. RAM used for embedded code would be susceptQjle to loss of battery power and power supply glitches. Furthermore, if RAM were used for embedded code, battery operated devices such as cdlular tdephones would have diminished battery life due to the constant power requirements of the RAM. When RAM is used for dynamic memory the system does not care if the contents are lost after a power cyde. This alleviates the need for battery back up. However, the cost of RAM is higher than the cost of ROM.<br>
Anotfier storage alternative is sectored EEPROM commor\Iy referred to as FLASH memory. Sectored EEPROM is a nonvolatile storage device that allows read and write on a byte basis.    Unlike RAM, in sectored<br><br>
EEPROM an erase ope-ation must be p&gt;erformed before rewriting over a previously written byte However, data erasure cannot be performed on a byte basis. Erasure can tmly be performed on a sector basis, where dte size of liie sector is defined by the particular memory device chosen. The size of an erasable sector is always larger than one byte and can be on die order of 64 Kbytes. Howev’, the number of erase cydes is not unlimited, but is bounded by a maximum cyde life. A typical recommended erase cyde life for sectored EEPROM is 100,000 cycles. Therefore, cffie would not use sectored EEPROM for applications requiring greater than lOO’KX) erase cycks over the anticipated device lifetime. Sectored ££FROhd has advantages over the other types of rewriteable memory in applicatkms that require fewer than 100,000 erase and rewrite cydes. Sectored EEPROM is preferred over any type of RAM for embedded code applications becaxise sectored EEPROM is nonvolatile. Sectored EEPROM is preferable over EHWDM because of sectored EEPROM"s ability to rewrite portjcms erf memory in drcmt. Sectored EEPROM also does not require the UV Ug’ for chip erasure. Sectored EEPROM is preferable over conventional EEPROM, which has comparable rewrite limitations, because of the lower wst and higher density of sectored EEPROM devices. Sectored EEPROMs are used in portable electronic devices for the nonvolatile storage of user configurable data.<br>
Data stored in sectored EEPROM is often formatted to conform to a file system. The file format convention is parBally driven by ttie sector sized erase cyde. Data is not memory mapped to a particular location siiKe data in sectored EEPROM cannot be rewritten in place. The additional software overhead results in dramatically increased memory access times. The access time is further increased in multi-tasking systems- Nonvolatile memory access in a multi-tasking S5"stem may be preen’rtKi by a hitter priority task. Preemption requires tiie lower priority task to wait few the oompleticm of the higher priority task before proceeding. When tf*e software overhead is induded in the calculation of access times, the time to access data from sedored EEPROM may be more than 1000 to 10,000 times slower than the access time to data stored in RAM devices-Long acce’ times present user interfo’ problems- In a portable electronic device sudi as a wireless phone, nonvolatile user configurable data is often stored in sectored EEPROM. The user interface is enhanced if access to the phone book data appears to occur instantaneously. Data retrieval &amp;:om sectored EEPROM results in a slow user respor\se when a user enters a phone number to com.pare against the entries in tiie phone book.<br><br>
This is due to the software overhead in dealing lA’ith the file system that must be initiated in order to retrieve any data from sectored EEPROM. The long access time delay presenls a serious problem in real time systems where data retrieval must occur within some predefined window of time.<br>
One solution to the slow access times of sectored EEPROM, or any other nonvolatile memory, is to transfer all data from iKmvolatile data records to RAM. The data records could be transferred from nonvolatile RAM upon device power up. Then all tfie data can quickly be retrieved from RAM. This greatly enhances the user interfece. However, this solution presents considerable cost and space disad’"antages. Additional RAM is required that redundantly stores die contents of the nonvolatile memory merely to enhance the user interface. What is required is a method and apparatus for reducing the amount of RAM retjuired to maintain a fast usffl" interface when accessing data stored in nonvolatLle memory.<br>
SUMMARY OF THE INVENTION<br>
The prMenl invention is a novel and improved method and apparatus for reducing the amoimt of RAM required to support fast data retrieval from slower non-volatile memory. The use of RAM instead of nonvolatile memory greatly decreases data search time. RAM access is orders of magnitude faster than nonvolatile memory access due to software overhead that must be performed each time nonvolatile memory is accessed.<br>
A collection of data records can be saved in nonvolatile memory. Access to the nonvolatile data records is slowed because of the software overhead associated with nonvolatile monory access. The present invention can be used to greatly eniiance seardies of data records saved in nonvolatile memory. When data records saved in nonvolatile memory must be searched, nim\erous accesses to the lumvolatile memory are typically required. The present invention reduces the number of accesses to the nonvolatile data records by saving a series of calculated tag values in predetermined locations in RAM. Seardies for data records saved in nonvolatile memory are then performed by searching through the predetermined RAM locations for corresponding tag values then looking up the nonvolatile data record if a matching tag value is found. Searching for matching tag values in RAM reduces to one the typical number of nonvolatile memory accesses required to search for a matching data record.<br><br>
This contrasts with the numerous nonvolatile record retrievals and compariscffis required in a conventional search of nonvolatile data records.<br>
A predetermined number of memory locations are allocated in RAM corresponding to the number of data records saved in the nonvolatile memory. Each memory location allocated in RAM need not be large enough to hold the data record saved in ncmvolatile memory. In the preferred embodiment two bytes of RAM are allocated for eacii data record location in nonvolatile memory. The nonvolatile data rectwd may be arbitrarily long. A tag function H(x) is defined to map each nonvolatile record into a corresponding tag value. The tag functicm H(x) need not provide a 1:1 mapping of data records to tag values. A 1:1 m’jping of data records to tag values minimizes the number of nonvcdatile memory accesses to one nonvolatile record access per data reord seardi.<br>
The predetermined RAM locations hold tag vahtes determined from contents of the corresponding nonvolatile data records. Whei a search for a particular data record is required a tag value is calculated for the seardted record. If the searched record is designated y, the tag value H(y) is calculated. The tag value H(y) is then compared to all tag values stored in the predetermined RAM locations. This step is performed very quickly due to the fast access capabilities of RAM. If a matching tag value in RAM is found the corresponding nonvola tile men\ory location is identified as tha t location tiiat corre’onds to the particular RAM location. The ojntenis of the nonvolatile data record are retrieved arul ccaapared to the seard’ record. If the two match then the search is con’lete. If the retrieved nonvolatile memory record and the searched record are not identical nvatches the remaining tag values in RAM are seardied for additiona! matches to the tag value calculated for the searched record. The search continues until an identical match is found or Ae end of the RAM tag values is reached.<br>
The present invention provides an enortnous decrease in the amount of time ttiat it takes to search the data records sincx the majority of the search is performed using the RAM tag taibles. The nonvolatile memory records are only accessed when a tag value match is found. For the majority of the searches only one nonvolatile memory access will be required. The time savings allow for an enhanced user interface while the reduction in RAM provides reduced hardware cost.<br><br>
BRIEF DESCRIFHON OF THE DRAWINGS<br>
The features’ objects, and advantages of the present invention will become more apparent from the detailed description set faih below when taken in conjianction with the drawings in which like reference character identify correspondingly throughout and whereiiu<br>
FIG. 1 is a block diagram of a laya-ed Taeraory in’lemcntation;<br>
FIG. 2A-2B are block diagrams showing implementabcms of RAM based look up of NV memory tables; and<br>
FIG. 3A-3B are flow charts oi the RAM imptenaitation of the present invention.<br>
DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS<br>
Memory and storage devices in any electronjc device are allocated according to expected needs. In an electronic device such as a wireless phone memory is typically in the form of nonvolatile memory and RAM. The nonvolatile memory may be a combination of PROM and nonvolatile sectored EEPROM. A type of nonvolatile sectored EEPROM commonly known in the industry is FLASH memory.<br>
One of the advantages in using FLASH memory is its ability to be erased and rewrittHi electronically. One of the disadvantages of FLASH memory, as discussed earlier, is the inability to update data in place. Whoie sectors must be erased at the same time. To maximize efficient use of the FLASH memory space d’e data saved in FLASH is not mariory mapped to a particular location, rather, it is saved using a file b’ed stwage system. In contrast, data stored in RAM can be updated in place and because of this can be assigned to a memory map.<br>
FIG. 1 illustrates a block diagram of the memory 20 structure of an electronic device such as a wireless phone 10. All data saved in memory 20 is managed witiiin a database 110. Data tiiat is volatile or transient in nature is saved in RAM 120. RAM 120 data can be assigned a memory map since RAM 120 data can be updated in place. However, other pieces of data that have varying lengths or locations are managed using a file system 130. The file system 130 is a software routine that determines tiie format, location, and size of file based data. One of the devices Hat utilize file based structure for its data is nonvolatile  memory 140.    All  data saved in nonvolatile<br><br>
memory 140 must first be formatted in the file system 130. Layering nonvolatile memory 14(t beneath the file system 130 creates further delay in accessing any data saved in nonvolatile memory 140. The delay in accessing data stored in nonvolatile memory 140 can create undesirable ddaj’ where data must be retrieved from nonvolatile memory as part of a user interface. An example using data commcmly available in a wirdess phone is seanh of a user generated phone book.<br>
Wireless phones typically have the ability to save user generated phone book entries. A user can typically have over one hundred phone numbers and correspcmding names in an dectranic phone book saved within nonvolatile memory. The actual number of entries is only limited by the amount of memory ‘ace a deagner is willing to aDocate to the phone book. The phone numbers and names each constitute data records ‘t are saved in nonvolatile memory. Eadi phorte number can be up to thirty-two characters long. This length allows for area codes, internal phone extensiorts, access codes, and personal identification numbers to be automatically dialed for designated numbers. Any number of characters can be allocated for a name but for convenience a thirty-two character length will be assumed. If we assxmie that 512 combined phone nimiber and name entries are allowed then 16K of nonvolatile memOTy mi2St be allocated. When a user enters a phone number or name and wishes to search the phone book for the corresponding saved infonnation tt\e data reonrds saved within nonvolatile memory must be searched.<br>
Data records saved in nonvolatile memory can only be read through the file system 130. The file system 130 is a layer ber«alh the database 110. The multiple layers on top of nonvolatile memory access create a large delay for any access to data records stored in nonvolatile memory. CXuing a conventional search routine a data record is retrieved fiom nonvolatile memory and compared to the input data. If the two mabii the data Tecards corresponding to the match are found. If the two do not match the first retrieved data record is discarded and the next data record is retrieved from nonvolatile memory. Retrieval of data records from nonvolatile memory and comparison to the input data is continued until a matdi is found or all records in the nonvolatile memory are searched. The multiple layers that must be traversed before retrieving data records from nonvolatile memory contribute to delays. When input data must be compared to a large number of contents saved in nonvolatile memory the delay is excessive for a user interface.    A user that inputs a name or phone number  and wishes  to<br><br>
retrieve the stored information relating to that entry cannot be expected to wait for long periods of time. The user interface needs to appear seamless and instantaneous to the user.<br>
One way of increasing ttie speed associated with searching nonvolatile memory data records is to have the search perfonned in RAM. Access times to data records saved in RAM are orders ctf magnitude faster than tJie access times to retrieve the equivalent data record from nonvolatile memory. The difference in access times is attributable to the file system. RAM does not require data records be formatted and accessed under the file system. In order to perform the seardi in RAM instead of nonvolatile memory all of the nonvolatile memory data records can be transferred to RAM. Then when a search is required, all erf the data records are available in RAM. This implementation has the disadvantage of using a lar’ amoimt of RAM merely to redundancy store data records available in nonvolatile memory. The increased axt and the phyacal size of additional RAM make this solution less than ideal for implementation in a portable electronic device such as a wireless phone.<br>
One altenutive implementation that improves search times of data records stored in nonvolatile mentory but does not entail saving the entire nonvolatile memory contents in RAM is illustrated in FIG. 2A. In FIG. 2A RAM is not used to hold the data records saved in nonvolatile memory. Instead, RAM hash bins 220 are defined in RAM. Eadt of the original nonvolatile (NV) records 210 is input to a hash function. A pointer to the input NV record 210 is stored in the RAM hash bin 220 corresponding to the output hash nimiber. The hash function does not need to provide a 1:1 mapping of NV record 210 to RAM ha’ bin 220. However, the choice of a hash function trades off the number of RAM hash bins 2’) against access speed. The more tmique the hash functicm maj’«ng the larger the required space for the RAM hash bin 220. The advantage in imique hash function mapping is the reduced number of accedes to nonvolatile memory when searching the NV records 210 for a match.<br>
The implementation shown in FIG. 2A performs as follows. Upon initialization of the dectroruc device each of tfie NV records 210 is input to a hash fimction. Initialization could be defined as any event for an electronic device. Initialization in a wireless phone is defined as power up. An example of a hash function is shown bdow.<br>
&gt;".v=(S50"‘,) + i,.)/(6552I)<br><br>
In the equation x’ represent the ith byte in the particular NV data record input to the hash function. The y. represent the output of the hash function after processing i bytes in the particular NV data record. The number N represents tfie number of bytes comprising each NV data record entry. Each NV data record is thirty-two bytes long in the exan’le described above. For the data record length described in the above exaxx’le N=32. The calculation is performed using integer math SOT an actual implementation. It can be seen that the mapping from input to output is not 1:3 \*.iien integer mad) is used.<br>
The hash function output falls widun a ‘&amp;ied RAM hadi bin 220. A pointer 222 to the NV reoird that was used as the inpui to the hash function is saved in d’e RAM hash bin 2M. The pointer uses less memory space to store tt\an does the data record. Typically, four bytes are allocated to tine pointer. For a nonvolatile data record having 512 entries 2K of memory is required to house all of the pointers. This provides a possible coriservation of RAM memory space.<br>
Each hash bin must have the ability to save more than one pointer 222. This is necessary since the hash function does not provide a 1:1 mapping of input to output. The lack of a 1:1 mapping in the hash function creates problems with RAM memory allocation. A large number of hash bins need to be defined in order to ensure that each ha’ bin will likely have only one pointer. If a fewer number of hash bins are defined there is likelihood that each hash bin will need to store a number of pointers.<br>
A designer could ensure tiiat each hash fam only has one pcHnter within it if 64K of hash bins are defined. Snce only 2K of pointers are required to identify all of the data records it is evident that the majority of hash bins will contain null pointers. AUocatmg 64K hash bins dearly requires a greater amount of RAM space than does loading all of the nonvolatile data records into RAM. Therefore feis solution is not viable. To reduce \he RAM requirement a design aBocates less 64K hash bins. However, a reduction in the number of hash bins necessarily increases the probability that any one hash bin will contain more than one pointer value.<br>
In order to find a data record match to some input data, the input data is first passed through the hash function. The output of the hash function thKi directs the seardi routine to a specific hash bin. If no pointer is stored in the hash bin then there is no match to be found in the nonvolatile data records. This greatiy reduces the search time if there is no match to be found,    in the conventional   search all the data records in nonvolatile<br><br>
memory would need to be retrieved and conr’ared against the input before determining that no match existed. Using die hash bin method accesses to nonvolatile memory do not need to occur prior to determining that no matches exist<br>
If tfiere are pointers stored in die hash bin d\e first pointer is retrieved from the hash bin and the NV reconi that the poinlEr refers to is retrieved. Then a full comparison is perfc’med between the input and the retrieved data recOTd. If the two are identical a mateh is found and the remaining associated data records can be retrieved. If the retrieved data record does not match then the next pointer, if any, in the Hach bin must be retrieved. The con’arison is performed and retrieral of pomters from the ha’ bin is repeated until either a match is found or there has been a comparison of all of die nonvolatile data reccnds referred to by die hash bin pointers.<br>
In the previous implementation there is the possiMity of numerous accesses to nonvolatile memory. The number of accesses to nonvolatile memory depends on the number of pointers stored in eacfi hash fain. The number of hash bins required is related to tiie hash function. Increasing the number of unique hash bins reduces the number of nonvolatile memory accesses. The reduction in the number of nonvolatile memory accesses comes at a cost of inaeased RAM required.<br>
The present invention utilizes an im.pleiKffintation that provides reduced data record search times and decreased RAM requirements. A block diagram of the present invention is shown in FIG- 2B. In die present invention NV records 210 comprise a crflection of data records as previously described. However, instead of defining hash bins in RAM a block of memory is allocated in RAM for tag vahies 230. As described in the earlier exan’le, each data record saved in nonvolatile memory is thirty-two characters long. There are 512 available records allocated in nonvolatile memory. This corresponds to 16K of memory. The present invention allocates two bytes of RAM space for each data record in nonvolatile memory. To accommodate 512 data records IK bytes of RAM needs to be allocated. Since the number of bytes of RAM allocated to eadi nonvolatile memory record is constant die RAM address locations can be assigned to corresponding nonvolatile data records. As an example, the first nonvolatile data record would correspond to the first two bytes allocated in RAM.<br><br>
The two bytes oj RAM allocated to each nonvolatile data record axe not sufficient to hold the entire data record. Instead, ttie two bytes hold a tag value corresponding to the data record. The tag value is generated using the same hash function described above. The tag value ran’sporuiing to each data record in nonvolatile memory is calculated and saved in a predetermined location in RAM. The present invention therefore minimizes the amount of RAM allocated. Two bytes in RAM are allocated for each nonvolatile data record and there are 512 data records. Therefore only IK of RAM needs to be allocated.<br>
When an input value needs to be con’iared to the contents of the nonvolatile memory data records the input vahie is first pased &amp;rou’ the hadi function. Then the output hash value is compared against \he tag values saved in RAM. When a matching tag value is located the contents of nonvolatile memory corresponding to that lag value location is retrieved and con’ared against the original input value If the two are identical then a match is found. Otherwise, the search ccmtinues down the RAM tag values until either another tag value produces a matdiing data record or the end of the tag value list is reached. In this manner the majority of the search is performed in RAM and the only time rronvolatile memory is accessed is when the calculated input tag value matches one of the previously saved tag values. If the hash function does not produce a large number of duplicate tag values, tiie number of accesses to nonvolatile memory is minimized. Using the hash function previoudy described, the number of accesses to nonvolatile memory is miimnized to one for 99% of data searches.<br>
FIG. 3A shows a flow chart of the present inventiOTu The routine starts at state 301. The routine is initialized anytime the device is turned powered up. In a wireless phone, whenever the user powers up the phone the routine starts 301. The routine next proceeds to state 304 where all of the entries in the nonvolatile (NV) memory data recOTds are read. Next at state 308 tt\e tag values for the NV memory entries are calculated. The tag value for each NV memory entry is calculated using a function such as tiie hash function previously described. Each tag value requires two bytes.<br>
The routine then proceeds to state 310 where the calculated tag values are stored in predetermined RAM locations. Eadi RAM location correspjonds to an entry in the NV memory data record collection. As an example, the sixth entry in the RAM tag value table is an absolute address<br><br>
tiiat corresponds to the sixth entry in the NV memory data record regardless of where in NV memory the entry actually resides.<br>
After die tag values have been saved in RAM any search of the data records can be performed primarily in RAM. State 320 assumes an entry "y" needs to be compared to the contents of the data records. In an electronic device such as a wireless phone the entry "y" could corre’xjnd to a phone number input by the user. The data record contents correspond to names and information associated with a partJcular phor*e number. A user may input a phone number and wish to retrieve all prevknisly stored information relating to that number.<br>
The first step of the search is accomplished in state 322 where the tag value corresponding to the input "y" is calculated. At state 324 an index coimter used in the search is initialized. The flow tiiart itext proceeds to point 330. Point 330 is not a functional element of the flow chart and is merely included to link ttie states of the flow chart of FIG. 3A to the states of the flow chart of FIG. 3B.<br>
FIG. 3B begins with point 330 that links the flow chart of FIG. 3A to that of FIG. 3B. From point 330 the routine proceeds to state 340. At state 340 the routine retrieves from RAM the previously saved tag value corresponding to ttie location identified by the index counter. The routine next proceeds to state 344 where the tag value corresponding to the entry "y" is compared to the retrieved RAM tag value. The retrieval sad comparison operation occurs very quickly since the tag values are cffdy two bytes long and all values reside in RAM. If the routine determines that tiie two tag values do not match the routine proceeds to state 354 to check to see if there are any more tag entries in RAM that have yet to be compared to the input tag value. If at state 354 the routine identifies more tag values in RAM that have not beoi compared the routine proceeds to state 358 to increment the index counter. After the index counter is incrcnented the routine loops bade to state 340 to retrieve the next tag value identified by the index counter.<br>
If instead, at state 354 the routine determines that Acre are no further tag values in RAM that have not been compared to the entry tag value the routine proceeds to state 362 where the routine concludes that no data record exists in memory that matches the ir’ut entry. The routine is then finished. Where no tag values match the tag value ftw the input eitry there necessarily is no data record stored in nonvolatile memory that matches the input entry.    In the present invention   there is no access to nonvolatile<br><br>
memory for this condition. Thus, the search is able to determine that no nonvolatile data records match without ever accesang &amp;\e nonvolatile memory.<br>
If at state 344 tfie routine iixstead determines feat the retrieved tag value matches the input entry tag value the routine proceeds to state 348. At state 348 ttie routine retrieves from nonvolatile nttmory the data record that corresponds to the matching tag value previously retrieved from RAM. Thus, the data records saved in nonvolatile memory are onlv acrsssed if the tag value for feat data record mabfees fee tag value of an input entry.<br>
Once fee actual data record is retrieved form nonvolatite memorv fee routine proceeds to state 350 to perform a coniparison of the faH recOT-ds. The comparison of fee full records is required because the hash function does not provide a 1:1 mapping from data record to tag vahie. Althou’ fee input entry and fee nonvolatile data record may generate fee same tag values fee actual data records must be compared to actuaDy confirm a match.<br>
If fee retrieved nonvolatile memory data record matdtes fee input entry a successful search has been performed. There is no further reason to continue fee search routine so fee routine ends and awaits a new input entry to search.<br>
If at state 350 fee routine determines that fee retrieved nonvolatile memory data record does not match fee input o’ry the routine proceeds to state 354 as described above to determine whefeer or not all RAM tag values have been searched.<br>
The flow charts in FIG-s 3A and 3B illustrate IKJW a minimal amount of RAM can be utilized to aid in fast search of data records stored in slow nonvolatile memory. Rafeer than loading fee entire contente of fee nonvolatile memory data records into RAM only a set of t’ values are loaded into RAM. When the data records need to be seardted for an input entry first fee input entry is used to generate a t’ value using fee same hash function previously used to generate fee tag vahies saved in RAM. Then fee input entry tag value is successively compared against fee tag values saved in RAM. If a matching tag value is found fee corresponding data record is retrieved from nonvolatile memory. Therefore nonvolatile mentory is only accessed when feere is a hi’ probability of retrieving a matching data record. The data record retrieved from nonvolatile memory is feen compared against fee input entry. There is a higji likelihood of obtaining a match since fee two records generate fee same  tag value.<br><br>
However, if the retrieved data record and the input entry do not match, the remainder of the RAM tag value table is searched for any oAer tag values that match the input entry tag value. Because the hash function provides nearly a 1:1 mapping of input to tag value nonvolatile memory is typically only accessed once per search. Therefore the number of accesses to nonvolatile memory is minimized while minimizing the amount of RAM required to inclement the invention.<br>
The previous description of the preferred embodimCTits is provided to enable any person skilled in the art to make or xise the present invention. The various modifications to these embodiments will be readily apparent to those skilled in tiie art, and the generic princif’es defined herein may be applied to other embodiments without the use of the inventive faculty. Thus, the present invention is not intended to be limited to the embodiments shown herein but is to be accorded the widest scape consistent with tiie principles and novel features discicsed herein.<br><br><br>
WE CLAIM :<br>
1.	An apparatus for fast data access that minimizes the required amount of fast<br>
memory comprising:<br>
a first memory for storage of a purity of data records that define a collection of data records <br>
a digital processor; and<br>
a second memory for storage of tag values calculated by the digital processor corresponding to each of the data records stored in the first memory; wherein the digital processor, in response to a request to search the collection of data records for an input entry, computes an input entry tag value nonexpanding to the input entry, compares the input entry tag value to each of the tag values stored in the second memory, retrieves the data record corresponding to the tag value that matches the input entry tag value, and compares the input entry to the retrieved data record.<br>
2.	The apparatus as claimed in  claim 1 wherein the first memory is nonvolatile memory.<br>
3.	The apparatus as claimed in   claim 1 wherein the second memory is RAM.<br>
4.	The apparatus as claimed in claim 1 wherein the data records comprise entries in an electronic phone book.<br>
5.	The apparatus as claimed in  claim 1 wherein the tag values are calculated as the outputs of a hash function using the data records as inputs to the hash function.<br>
6.	The apparatus as claimed in claim 5 wherein the input entry tag value is<br><br>
calculated using the same hash function as was used for the calculation of the tag values.<br>
7.	The apparatus as claimed in   claim 1 wherein two bytes are allocated in the second    memory    for    each    data    record    stored    in    the    first    memory.<br>
8.	A phone configured for fast data access with reduced RAM requirements comprising:<br>
a first memory for storage of a plurality of data records that define a collection of data records;<br>
a digital processor; and<br>
a second memory for storage of tag values calculated by the digital processor corresponding to each of the data records stored in the first memory; wherein the digital processor, in response to a request to search the collection of data records for an input entry, computes an input entry tag value corresponding to the input entry, compares the input entry tag value to each of the tag values stored in the second memory, retrieves the data record nonexpanding to the tag value that matches the input entry tag value, and compares the input entry to the retrieved data record.<br>
9.	The phone as claimed in  claim 8 wherein the collection of data records is an electronic phone book.<br>
10.	The phone as claimed in   claim 8 wherein the first memory is nonvolatile memory.<br>
11.	The phone as claimed in claim 8 wherein the second memory is RAM.<br><br>
12.	The phone as claimed in claim 8 wherein the tag values are calculated as the outputs of a hash function using the data records as inputs to the hash function.<br>
13.	The phone as claimed in claim 12 wherein the input entry tag value is calculated using the same hash function as was used for the calculation of the tag values.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgICBvdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che   others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgICBwY3QucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che   pct.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgICBwZXRpdGlvbi5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che   petition.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGFic3RyYWN0LWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  abstract-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGFic3RyYWN0LmpwZw==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  abstract.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGFzc2lnbm1lbnQucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGNsYWltcy1kdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  claims-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGNvcnJlc3BvbmRlbmNlcy1vdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  correspondences-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGNvcnJlc3BvbmRlbmNlcy1wby5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  correspondences-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGZvcm0tMTkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGZvcm0tMjYucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgIGZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che  form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgZGVzY3JpcHRpb24gKGNvbXBsZXRlKS1kdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che description (complete)-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMTExMS1jaGUgZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-1111-che description (complete).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="215422-process-for-producing-carboxylic-acids.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="215424-a-method-for-controlling-an-internal-combustion-engine-having-an-air-system.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>215423</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2002/1111/CHE</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>31-Mar-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>26-Feb-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>18-Jul-2002</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 Morehouse Drive, San Diego, California 92121</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>MEI, Yousong</td>
											<td>5653 Arbor Grove Court, San Diego, California 92121,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>LEKVEN, Eric, John</td>
											<td>7961 Via Orilla, Calsbad, California 92009,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 12/02</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US01/01892</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2001-01-19</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/487,948</td>
									<td>2000-01-19</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/215423-a-apparatus-for-reducing-ram-size-while-maintaining-fast-data-access by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:31:44 GMT -->
</html>
