<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/235140-a-method-of-maintainig-cache-coherency-a-cache-and-a-data-processing-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:37:58 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 235140:A METHOD OF MAINTAINIG CACHE COHERENCY, A CACHE AND A DATA PROCESSING SYSTEM</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD OF MAINTAINIG CACHE COHERENCY, A CACHE AND A DATA PROCESSING SYSTEM</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A first data item is stored in a first cache in association with an address tag indicating an address of the data item. A coherency indicator in the first cache is set to a first state that indicates that the first data item is valid. In response to another cache indicating an intent to store to the address indicated by the address tag while the coherency indicator is set to the first state, the coherency indicator is updated to a second state that indicates that the address tag is valid and that the first data item is invalid. Thereafter, in response to detection of a remotely-sourced data transfer that is associated with the address indicated by the address tag and that includes a second data item, a determination is made, in response to a mode of operation of the first cache, whether or not to update the first cache. In response to a determination to make an update to the first cache, the first data item is replaced by storing the second data item in association with the address tag and the coherency indicator is updated to a third state that indicates that the second data item is valid. In one embodiment, the operating modes of the first cache include a precise mode in which cache updates are always performed and an imprecise mode in which cache updates are selectively performed. The operating mode of the first cache may be set by either hardware or software.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>The present invention relates to a method of maintaining cache coherency in a data processing system. Still more particularly, the present invention relates to a cache coherency protocol for a multiprocessor data processing system, which includes a hovering (H) state that permits a first cache to be updated with valid data in response to a second cache independently transmitting the valid data on an interconnect coupling the first and second caches.<br>
In a conventional symmetric multiprocessor (SMP) data<br>
processing system, all of the processors are generally identical, that is, the<br>
processors all utilize common instruction sets and communication<br>
protocols, have similar hardware architectures, and are generally provided<br>
with similar memory hierarchies. For example, a conventional SMP data<br>
processing system may comprise a system memory, a plurality of<br>
processing elements that each include a processor and one or more levels<br>
of cache memory, and a system bus coupling the processing elements to<br>
each other and to the system memory. To obtain valid execution results in<br>
an SMP data processing system, it is important to maintain a coherent<br>
memory hierarchy, that is, to provide a single view of the contents of<br>
memory to 	<br><br>
all of the processors.<br>
A coherent memory hierarchy is maintained through the use of a selected memory coherency protocol, such as the MESI protocol.  In the MESI protocol, an indication of a coherency state is stored in association with each coherency granule (e.g., cache line or sector) of at least all upper level (cache) memories.  Each coherency granule can have one of four states, modified (M), exclusive (E), shared (S), or invalid (I), which is indicated by two bits in the cache directory.  The modified state indicates that a coherency granule is valid only in the cache storing the modified coherency granule and that the value of the modified coherency granule has not been written to system memory.  When a coherency granule is indicated as exclusive, the coherency granule is resident in, of all caches at that level of the memory hierarchy, only the cache having the coherency granule in the exclusive state.  The data in the exclusive state is consistent with system memory, however.  If a coherency granule is marked as shared in a cache directory, the coherency granule is resident in the associated cache and in at least one other cache at the same level of the memory hierarchy, all of the copies of the coherency granule being consistent with system memory.  Finally, the invalid state indicates that the data and address tag associated with a coherency granule are both invalid.<br>
The state to which each coherency granule (e.g., cache line) is set is dependent upon both a previous state of the cache line and the type of memory access sought by a requesting processor.  Accordingly, maintaining memory coherency in the multiprocessor data<br><br>
processing system requires that the processors communicate messages across the system bus indicating their intention to read or write memory locations.  For example, when a processor desires to write data to a memory location, the processor must first inform all other processing elements of its intention to write data to the memory location and receive permission from all other processing elements to carry out the write operation.  The permission messages received by the requesting processor indicate that all other cached copies of the contents of the memory location have been invalidated, thereby guaranteeing that the other processors will not access stale local data.  This exchange of messages is known as cross-invalidation (XI) .<br>
The present invention includes a recognition that while cross-invalidation of cache entries serves to maintain memory coherency in a SMP data processing system, the invalidation of cache entries by remote processors adversely affects data processing system performance by decreasing hit ratios in local caches. Thus, even if equipped with large local caches, a processing element can incur long access latencies when retrieving data that were once resident in a local cache from either a remote cache in another processing element or from system memory.  As should thus be apparent, it would be desirable to provide a method and system for maintaining memory coherency in a SMP data processing system that reduces the performance penalty incurred as a result of the cross-invalidation of cache entries.<br><br>
SUMMARY OP THE INVENTION<br>
It is therefore one object of the present invention to provide an improved method and system for data processing.<br>
It is another object of the present invention to provide an improved method and system for maintaining cache coherency in a multiprocessor data processing system.<br>
It is yet another object of the present invention to provide a cache coherency protocol for a multiprocessor data processing system, which includes a hovering (H) state that permits a first cache to be updated with valid data in response to a second cache independently transmitting the valid data on an interconnect coupling the first and second caches.<br>
The foregoing objects are achieved as is now described.  A data processing system is provided that includes a plurality of processors which are each associated with a respective one of a plurality of caches.  According to the method of the present invention, a first data item is stored in a first cache in association with an address tag indicating an address of the data item.  A coherency indicator in the first cache is set to a first state that indicates that the first data item is valid.  In response to another cache indicating an intent to store to the address indicated by the address tag while the coherency indicator is set to the first state, the coherency indicator in the first cache is updated to a second state that indicates that the address tag is valid and that the first data item is<br><br>
invalid.  Thereafter, in response to detection of a remotely-sourced data transfer that is associated with the address indicated by the address tag and includes a second data item, a determination is made, in response to a mode of operation of the first cache, whether or not to update the first cache.  In response to a determination to make an update to the first cache, the first data item is replaced by storing the second data item in association with the address tag, and the coherency indicator is updated to a third state that indicates that the second data item is valid.  In one embodiment, the operating modes of the first cache include a precise mode in which cache updates are always performed and an imprecise mode in which cache updates are selectively performed.  The mode in which the first cache operates may be set by hardware or software.<br>
The above as well as additional objects, features, and advantages of the present invention will become apparent in the following detailed written description.<br><br>
Accordingly the present invention provides a method of maintaining cache coherency in a data processing system including a cache having multiple modes of operation, said method comprising: in a cache, storing a first data item in association with an address tag indicating an address of said first data item and setting a coherency indicator in said cache to a data-invalid state that indicates that said address tag is valid and that said first data item is invalid; in response to said cache detecting a data transfer on said interconnect initiated by a read request of another device in said data processing system, said data transfer including a second data item, determining whether or not to update said cache based upon a mode of operation of said cache, whether said coherency indicator indicates said data-invalid state, and whether said address tag matches an address associated with said data transfer; and in response to a determination to update said cache, storing said second data item in said cache in association with said address tag and updating said coherency indicator to a state that indicates that said second data item is valid in said cache.<br><br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
The novel features believed characteristic of the invention are set forth in the appended claims.  The invention itself however, as well as a preferred mode of use, further objects and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:<br>
Figure 1 depicts an illustrative embodiment of a multiprocessor data processing system in accordance with the present invention;<br>
Figure 2 is a block diagram depicting an illustrative embodiment of a cache in accordance with the present invent ion; and<br>
Figure 3 is a state diagram depicting an illustrative embodiment of the H-MESI memory coherency protocol of the present invention.<br><br>
DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENT<br>
With reference now to the figures, and in particular with reference to Figure 1, there is illustrated a high level block diagram of a multiprocessor data processing system in accordance with the present invention.  As depicted, data processing system 8 includes a number of processors lOa-lOn, which each preferably comprise one of the PowerPC™ line of processors available from Internal Business Machines Corporation.  In addition to the conventional registers, instruction flow logic and execution units utilized to execute program instructions, each of processors lOa-lOn also includes an associated one of on-board level one (LI) caches 12a-12n, which temporarily stores instructions and data that are likely to be accessed by the associated processor.  Although LI caches 12a-12n are illustrated in Figure 1 as unified caches that store both instruction and data (both referred to hereinafter simply as data), those skilled in the art will appreciate that each of LI caches 12a-12n could alternatively be implemented as bifurcated instruction and data caches.<br>
In order to minimize access latency, data processing system 8 also includes one or more additional levels of cache memory, such as level two (L2) caches 14a-14n, which are utilized to stage data to LI caches 12a-12n.  In other words, L2 caches 14a-14n function as intermediate storage between system memory 18 and LI caches 12a-12n, and can typically store a much larger amount of data than LI caches 12a-12n, but at a longer access latency.  For example, L2 caches 14a-14n may have a storage capacity of 256 or 512 kilobytes, while LI caches 12a-12n may have a storage capacity of 64 or 128<br><br>
kilobytes.  As noted above, although Figure 1 depicts only two levels of cache, the memory hierarchy of data processing system 8 could be expanded to include additional levels (L3, L4, etc.) of serially-connected or lookaside caches.<br>
As illustrated, data processing system 8 further includes I/O devices 20, system memory 18, and non-volatile storage 22, which are each coupled to interconnect 16.  I/O devices 20 comprise conventional peripheral devices, such as a display device, keyboard, and graphical pointer, which are interfaced to interconnect 16 via conventional adapters.  Non-volatile storage 22 stores an operating system and other software, which are loaded into volatile system memory 18 in response to data processing system 8 being powered on. Of course, those skilled in the art will appreciate that data processing system 8 can include many additional components that are not shown in Figure 1, such as serial and parallel ports for connection to networks or attached devices, a memory controller that regulates access to system memory 18, etc.<br>
Interconnect 16, which can comprise one or more buses or a cross-point switch, serves as a conduit for communication transactions between L2 caches 14a-14n, system memory 18, input/output (I/O) devices 20, and nonvolatile storage 22.  A typical communication transaction on interconnect 16 includes a source tag indicating the source of the transaction, a destination tag specifying the intended recipient of the transaction, an address and/or data.  Each device coupled to interconnect 16 preferably snoops all communication transactions on interconnect 16.<br><br>
With reference now to Figure 2, there is depicted a more detailed block diagram of an illustrative embodiment of an L2 cache 14 in accordance with the present invention.  In the illustrative embodiment, L2 cache 14 is a four-way set associative cache that utilizes 32-bit addresses.  Accordingly, data array 34 of L2 cache 14 comprises a number of congruence classes that each contain 4 ways for storing cache lines.  As in conventional set- associative caches, memory locations in system memory 18 are mapped to particular congruence classes within data array 34 utilizing index bits within the address of the memory location (e.g., bits 20-26 of a 32-bit address).<br>
The cache lines stored within data array 34 are recorded in cache directory 32, which contains one directory entry for each way in data array 34.  Each directory entry comprises a tag field 40, coherency status field 42, least recently used (LRU) field 44, and inclusion field 46.  Tag field 40 specifies which cache line is stored in the corresponding way of data array 34 by storing the tag bits (e.g., bits 0-19) of the system memory address of the cache line.  As discussed in detail below with reference to Figure 3, coherency status field 42 indicates the coherency status of the data stored in the corresponding way of data array 34 utilizing predefined bit combinations.  LRU field 44 indicates how recently the corresponding way of data array 34 has been accessed relative to the other ways of its congruence class, thereby indicating which cache line should be cast out of the congruence class in response to a cache miss. Finally, inclusion field 46 indicates whether or not the cache line stored in the corresponding way of data array 34 is also stored in the associated LI cache 12.<br><br>
Still referring to Figure 2, L2 cache 14 further includes cache controller 36, which manages storage and retrieval of data within data array 34 and updates to cache directory 32 in response to signals received from the. associated LI cache 12 and transactions snooped on interconnect 16.  As illustrated, cache controller 36 contains a read queue 50 and a write queue 52 from which cache controller 36 performs updates to cache directory 32 and accesses to data array 34.  For example, in response to receiving a read request from the associated LI cache 12, cache controller 36 places the read request in an entry within read queue 50.  Cache controller 36 services the read request by supplying the requested data to the associated LI cache 12 and thereafter removes the read request from read queue 50. As another example, cache controller 36 may snoop a transaction initiated by another of L2 caches 14a-14n indicating that a remote processor 10 intends to modify its local copy of a specified cache line.  In response to snooping this transaction, cache controller 36 places a request to read cache directory 32 in read queue 50 in order to determine if the specified cache line is resident in data array 34.  If so, cache controller 36 places an appropriate response on interconnect 16 and, if necessary, inserts a directory write request in write queue 52, that when serviced, updates the coherency status field associated with the specified cache line. Although Figure 2 illustrates an embodiment in which only one read queue and one write queue are utilized, it should be understood that the number of queues employed by cache controller 36 is a matter of design choice and that cache controller 36 may employ separate queues for cache directory accesses and data array accesses.<br><br>
Cache controller 36 further includes mode register 60, which, as described in greater detail below, comprises one or more bits whose settings control the operation of cache controller 36.  In addition, cache controller 36 includes performance monitor 70. Performance monitor 70 is equipped with a number of performance monitor counters (PMCO-PMCn) 72 that, when enabled, increment in response to each occurrence of an event or combination of events specified by one or more control registers (CRO-CRm) 74",  The events that may be counted by PMCs 72 in response to the settings of CRs 74 include cache hits, cache misses, the number of entries in a specified queue, access latency for L2 cache hits, access latency for L2 cache misses, etc.  Each of PMCs 72 and CRs 74 are preferably memory mapped registers that may be read and written by the associated processor 10 via load and store instructions.<br>
With reference now to Figure 3, there is depicted an illustrative embodiment of the H-MESI memory coherency protocol of the present invention.  The H-MESI protocol is preferably implemented only by the lowest level of cache in the memory hierarchy (e.g., L2 caches 14a-14n in the embodiment of data processing system 8 illustrated in Figure 1}, while higher level caches preferably implement the conventional MESI protocol. However, in alternative embodiments of data processing system 8, the H-MESI protocol may be implemented at each level of cache in the memory hierarchy at the expense of additional inter-cache communication traffic.<br>
As shown in Figure 3, the H-MESI memory coherency protocol includes the conventional modified (M) , exclusive (E) , shared (S) , and invalid (I) states of<br><br>
the MESI protocol, which are respectively identified by reference numerals 80, 82, 84, and 86.  In addition, the H-MESI memory coherency protocol of the present invention includes hovering (H) state 90, which indicates that the address tag stored in the associated tag field 40 is valid but that the data item (e.g., cache line or cache sector) stored in the corresponding way of data array 34 is invalid.<br>
In a preferred embodiment, coherency status field 42 of each entry of each L2 cache directory 32 is initialized to I state 86 at power-on to indicate that both tag field 40 and the data stored in the corresponding way of data array 34 are invalid.  LI cache directory entries are similarly initialized to the invalid state according to the conventional MESI protocol.  Thereafter, the coherency status of a cache line (or cache sector) stored in one of L2 caches 14a-14n in invalid state 86 can be updated to one of M state 80, E state 82, or S state 84, depending upon both the types of memory requests made by processors 10a-lOn and the response of the memory hierarchy to those requests.<br>
For example, if processor 10a makes a read request in response to a load instruction, LI cache 12a makes a determination of whether or not the requested data is resident in LI cache 12a.  In response to a hit in LI cache 12a, LI cache 12a simply supplies the requested data to processor 10a.  However, in response to miss in LI cache 12a, LI cache 12a forwards the read request to L2 cache 14a via inter-cache connections.  In response to a hit in L2 cache 14a, the requested data is supplied by L2 cache 14a to LI cache 12a, which stores the requested data in association with the appropriate .<br><br>
MESI coherency status and forwards the requested data to processor 10a.  If, however, the read request misses in both LI cache 12a and L2 cache 14a, cache controller 36 of L2 cache 14a presents the read request as a transaction on interconnect 16, which is snooped by each of L2 caches 14b-14n.<br>
In response to snooping the read request on interconnect 16, cache' controller 36 in each of L2 caches 14b-14n determines if the requested data is resident in its data array 34 or the associated one of LI caches 12b-12n.  If none of L2 caches 14b-14n or LI caches 12b-12n stores the requested data, each of L2 caches 14a-14n returns a null response to L2 cache 14a, which then requests the data from system memory 18.  When the requested data is returned to L2 cache 14a from system memory 18, cache controller 36 forwards the requested data to LI cache 12a, stores the requested data in its data array 34, and updates the coherency status field 42 associated with the way storing the requested data from I state 86 to E state 82, as indicated by reference numeral 100.  As in the conventional MESI protocol, E state 82 indicates that the associated cache line is valid and is not resident in any other cache at the second level of the memory hierarchy.<br>
Similarly, if any of LI cache 12b-12n or L2 caches 14b-14n stores the requested data in E state 82 or S state 84 and so indicates in a "shared" response to the read request placed on interconnect 16 by L2 cache 14a, L2 cache 14a retrieves the requested data from system memory 18.  In this case, however, the coherency status of the way in L2 cache 14a that stores the requested data makes a transition from I state 86 to S state 84, as<br><br>
ndicated by reference numeral 102.  Others of L2 caches 4 storing the requested data in E state 82 are also pdated to S state 84, as indicated by reference numeral 04.<br>
If the data requested by processor 10a is not esident in LI cache 12a and L2 cache 14a but is stored, or example, in LI cache 12n in M state 80, cache ontroller 36 of L2 cache 14n responds to the read equest with a retry and signals LI cache 12n to push the equested data to memory.  The coherency status of the equested data in LI cache 12n and L2 cache 14n is then pdated to S state 84 as indicated by reference numeral 06.  Thereafter, when L2 cache 14a retries the read equest on interconnect 16, L2 cache 14n replies with a hared response and L2 cache 14a obtains the requested ata from system memory 18 as discussed above.  In an lternative embodiment that supports so-called modified ntervention, the requested data is sourced by cache :ontroller 36 of L2 cache 14n rather than by system lemory 18, thereby reducing access latency.<br>
If instead of a read request LI cache 12a ssues a "read with intent to modify" request indicating hat processor 10a desires to acquire exclusive use of a lemory location for the purpose of modifying it, the Lbove-described process of obtaining the cache line :ontaining the specified memory location is followed. Eowever, when the requested cache line is obtained, LI :ache 12a stores the requested cache line in modified itate.  In addition, because the "read with intent to lodify" transaction indicates that other copies of the requested cache line will become stale, the other LI and J2 caches must indicate that their copies of the<br><br>
requested cache line are invalid.  In LI caches 12b-12n, any copies of the requested cache line are simply marked as invalid.  However, the coherency status of copies of the requested cache line stored in L2 caches 14b-14n are not updated to I state 86 as in conventional multiprocessor data processing systems that utilize cross-invalidation (XI).  Instead, in accordance with an important aspect of the present invention, each of L2 caches 14b-14n storing' a copy of the requested cache line updates the coherency status field 42 associated with its copy from any of S state 84, M state 80, or E state 82 to H state 90, as indicated by reference numerals 110, 112, and 114, respectively.  As noted above, H state 90 indicates that the tag stored in tag field 40 remains valid, but that the associated cache line within data array 34 is invalid.  Entries in a cache directory 32 are similarly updated to H state 90 in response to other snooped transactions that require data to be invalidated, including kills (i.e., transactions that explicitly invalidate a specified data block), flushes (i.e., transactions that invalidate a specified data block and copy any modified data to system memory), dclaims (i.e., transactions that invalidate copies of a cache line marked as shared in remote caches in response to a local copy of the cache line becoming modified in response to a store), etc.<br>
As indicated by reference numerals 116, 118, and 120, a cache directory entry can make a transition from H state 90 to E state 82, M state 80, or S state 84, depending upon what type of transactions are received by the cache.  For example, a directory entry of L2 cache 14a that is in H state 90 makes a transition to E state 82 (as indicated by reference numeral 86) in response to<br><br>
processor 10a making a read request that (after missing in both LI cache 12a and L2 cache 14a) receives a null response from L2 caches 14b-14n since the data retrieved from system memory 18 will, of all L2 caches 14a-14n, be stored only in L2 cache 14a.  If, on the other hand, processor 10a indicates an intent to store data to a way of LI cache 12a that is in H state 90, LI cache 12a indicates that intent to L2 cache 14a, which then issues a "read with intent to- modify" transaction on interconnect 16.  As discussed above, copies of the requested cache line stored in L2 caches 14b-14n are updated to H state 90 in response to snooping the "read with intent to modify" transaction, and copies of the requested cache line stored in LI caches 12b-12n are marked as invalid.  Once the requested cache line is returned to LI cache 12a and processor 10a updates the cache line, the cache line is marked as modified in LI cache 12a to signify that the cache line is valid, but is not coherent with system memory 18.  Depending on the implementation, the modified cache line may subsequently be stored in L2 cache 14a (e.g., in response to an LI castout) without the modified cache line being written back to system memory 18.  If so, the coherency status field 42 in L2 cache 14a associated with the modified cache line is updated to M state 80, as indicated by reference numeral 118.  Finally, an L2 cache directory entry in H state 90 is updated to S state 84 in response to a number of different request/response scenarios.<br>
First, an L2 directory entry in H state 90 transitions to S state 84 when the associated processor 10 issues a read request to the address indicated by the (valid) address tag in tag field 40 and at least one L2 cache 14 replies with a shared response.  More<br><br>
importantly, an L2 directory entry in H state 90 can be updated to S state 84 without the associated processor 10 issuing a data request or the L2 cache 14 initiating a transaction on interconnect 16.  As described above/ each of L2 caches 14a-14n snoops all transactions issued on interconnect 16.  If one of L2 caches 14a-14n, for example, L2 cache 14a, snoops a transaction issued by another of L2 caches 14b-14n that includes an updated (i.e., valid) copy of data that is stored in L2 cache 14a in H state 90, cache controller 36 of L2 cache 14a samples the data from interconnect 16, stores the snooped data in data array 34, and updates the associated coherency status field 42 from H state 90 to S state 84. Of course, L2 cache 14a also provides a response to the snooped transaction, if a response is required to maintain coherency.  For example, if the snooped transaction is a read request, L2 cache 14a must provide a shared response indicating its intention to sample the requested data so that the requesting L2 cache stores the requested data in S state 84 rather than E state 82. Transactions on interconnect 16 that can be snooped in this way to refresh invalid data associated with a valid address tag include read transactions, write transactions, data writebacks to system memory 18 due to cache line castouts, etc.<br>
State transitions that may be made in the illustrative embodiment of the H-MESI memory coherency protocol depicted in Figure 3 are summarized below in Table I.<br><br><br>
According to an important aspect of the present invention, the H-MESI protocol can be implemented either precisely or imprecisely. A precise implementation of the H-MESI protocol requires that L2 caches 14a-14n always sample data available on interconnect 16 to refresh invalid cache lines in H state 90.  In contrast, an imprecise implementation permits L2 caches 14a-14n to selectively sample data on interconnect 16 to refresh cache lines in H state 90.  In the illustrative<br><br>
embodiment depicted in Figure 2, each L2 cache 14 can, independently of the other L2 caches, operate in either a precise mode or an imprecise mode based upon the state of mode bit 62 in its mode register 60.<br>
Operating L2 caches 14a-14n in precise mode is particularly advantageous when debugging or performance-tuning software because the precise mode of operation promotes more predictable software behavior and consistent software timing.  In addition, in the precise mode, data requests that miss at both levels of local cache (and require the local L2 cache 14 to issue a transaction on interconnect 16) are typically rare and can therefore serve as indications of possible "bugs" in the software.  Moreover, in embodiments of the present invention that support modified intervention, the precise H-MESI protocol guarantees that data that is requested by a processor 10 and is stored in the local L2 cache 14 in H state 90 will always be sourced by modified intervention (i.e., fast).  A chief disadvantage of operating an L2 cache 14 in the precise mode is that snooped transactions capable of updating an L2 cache line in H state 90 must be retried if the update cannot be performed, for example, due to write queue 52 of the L2 cache 14 being full (i.e., busy).<br>
Because it is desirable not to retry necessary operations, for example, read requests, in order to perform optional updates of cache lines in H state 90, it is typically preferable for L2 caches 14a-14n to be in the imprecise mode during normal operation.  As noted above, the imprecise mode of operation permits updates to cache lines in H state 90 to be performed selectively. In a preferred embodiment, when an L2 cache 14 is in<br><br>
imprecise mode, updates to cache lines in H state 90 are performed only if write queue 52 (or a dedicated directory write queue, if implemented) has less than a threshold number of entries.  Thus, either hardware within the L2 cache 14 or software executed by the associated processor 10 can be used to set mode bit 62 to the state corresponding to the imprecise mode in response to the number of entries in write queue 52 exceeding a predetermined threshold.  However, other embodiments of the present invention may selectively perform' updates to L2 cache lines in H state 90 based on other criteria, as described in detail below.<br>
In the illustrative embodiment of data processing system 8 shown in Figure 2, each of L2 caches 14a-14n can independently be set to precise mode or imprecise mode by either software or hardware or both. For example, if software control of the mode in which L2 cache 14a operates is desired, processor 10a can simply set mode bit 62 by executing a store instruction that targets mode register 60.  Alternatively, software can store values to CRs 74 that cause PMCs 72 to count occurrences of events of interest, such as the insertion and removal of entries in write queue 52, L2 accesses, L2 cache misses, access latency on L2 cache misses, etc. The software can then access the values in the PMCs 72 of interest by executing load instructions.  In response to one or a combination of the values of PMCs 72 exceeding software-determined thresholds, the software can set mode bit 62 to select the appropriate one of the precise and imprecise modes.  For example, if L2 cache 14a is operating in the imprecise mode and the number of L2 cache misses is greater than a predetermined percentage of the total number of L2 accesses, software can set mode<br><br>
bit 62 to the state corresponding to the precise mode.<br>
Hardware control of the mode of operation of L2 caches 14a-14n can similarly be implemented by performance monitor 70.  In an illustrative embodiment, each performance monitor 70 includes logic for generating a signal that sets mode bit 62 to a specified state in response to the number of occurrences of a selected event or combination of events accumulated in one or more of PMCs 72 exceeding a predetermined threshold.  The selection of the event or events of interest and the enablement of PMCs 72 can be determined either by default settings of performance monitor 70 or by software executed by the associated processor 10.  In yet another embodiment, performance monitor 70 can be set to generate a performance monitor interrupt (PMI) in response to the number of occurrences of a selected event or combination of events exceeding a predetermined threshold.  The PMI is serviced by the associated processor 10, which executes an interrupt handler that changes the state of mode bit 62,<br>
As has been described, the present invention provides an improved method and system for maintaining memory coherency in a multiprocessor data processing system. The improved memory coherency protocol provided by the present invention permits an invalid data item stored within a cache in association with a valid address tag to be automatically updated with valid data without the associated processor issuing an explicit read or write request.  In this manner, data invalidated by the activity of remote processors can be refreshed prior to the data being accessed by the local processor, thereby substantially reducing access latency by eliminating the<br><br>
need to retrieve the data from a remote cache or system memory.  Contention for memory access and system-wide locks is also substantially reduced since cache lines are updated without accessing memory or requesting a lock.<br>
While the invention has been particularly shown and described with reference to an illustrative embodiment, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention.  For example, the illustrative embodiment of a memory coherency protocol depicted in Figure 3 could<br>
be modified by eliminating I state 86 because that state<br>
*<br>
is only utilized to initialize directory entries at power-on and is never re-entered from another state.  If I state 86 were eliminated, at power-on the coherency status field of each L2 directory entry would be initialized to H state 90, and the tag field of each L2 directory entry would be initialized to a tag value that is unique at least within the same congruence class.  In addition, it should be understood that performance monitor 70 of Figure 2 could alternatively be implemented as a single system-wide performance monitor coupled to interconnect 16 rather than as multiple separate performance monitors internal to each L2 cache 14.<br><br><br><br><br>
WE CLAIM :<br>
1.	A method of maintaining cache coherency in a data processing system including a cache having multiple modes of operation, said method comprising: in a cache, storing a first data item in association with an address tag indicating an address of said first data item and setting a coherency indicator in said cache to a data-invalid state that indicates that said address tag is valid and that said first data item is invalid; in response to said cache detecting a data transfer on said interconnect initiated by a read request of another device in said data processing system, said data transfer including a second data item, determining whether or not to update said cache based upon (1) a mode of operation of said cache, (2) whether said coherency indicator indicates said data-invalid state, and (3) whether said address tag matches an address associated with said data transfer; and in response to a determination to update said cache, storing said second data item in said cache in association with said address tag and updating said coherency indicator to a state that indicates that said second data item is valid in said cache.<br>
2.	The method of claim 1, wherein determining whether or not to update said cache comprises: if said cache is operating in a first mode, always deciding to update said cache if said coherency indicator indicates said data-invalid state and said address tag matches said address associated with said data transfer; and if said cache is operating in a second mode, deciding to update said cache only if said cache is not busy.<br>
3.	The method of claim 2, said cache including a queue from which<br>
updates are made, wherein deciding to update said cache only if said<br><br>
cache is not busy comprises deciding to update said cache only if said queue    contains    less    than    a    threshold    number    of    entries.<br>
4.	The method of claim 1, and further comprising setting said mode of<br>
operation of said cache to one of a first mode and a second mode in<br>
response to an instruction executed by a processor in said data processing<br>
system.<br>
5.	The method of claim 1, wherein said data processing system includes<br>
performance monitor hardware that monitors one or more selected events,<br>
said method further comprising setting said mode of operation of said<br>
cache        utilizing        said       performance        monitor        hardware.<br>
6.	The method of claim 1, wherein updating said coherency indicator<br>
comprises updating said coherency indicator to a shared state that<br>
indicates that said second data item is stored in both said cache and<br>
another       cache       within       said       data       processing       system.<br>
7.	A cache for supporting cache coherency in a data processing system<br>
including an interconnect, said cache comprising: data storage; tag<br>
storage that stores an address tag indicating an address of a data item<br>
contained in said data storage; a coherency indicator having at least a<br>
valid state that indicates that said data item is valid a data-invalid state<br>
that indicates that said address tag is valid and that a data item in said<br>
data storage is invalid; and a cache controller coupled to said coherency<br>
indicator, said tag storage and said data storage, wherein responsive to<br>
detection of a data transfer on the interconnect initiated by a read request<br>
of another device in the data processing system, said data transfer<br>
including a second data item, said cache controller determines whether or<br><br>
not to update said data storage based upon (1) a mode of operation of said cache, (2) whether said coherency indicator indicates said data-invalid state, and (3) whether said address tag matches an address associated with said data transfer, and wherein, responsive to a determination to update to said data storage, said cache controller stores said second data item in said data storage in association with said address tag and updates said coherency indicator to said valid state.<br>
8.	The cache of claim 7, wherein said cache controller comprises: means, responsive to said cache operating in a first mode, for always deciding to update said data storage if said coherency indicator indicates said data-invalid state and said address tag matches said address associated with said data transfer; and means, responsive to said cache operating in a second mode, for deciding to update said data storage only if said cache is not busy.<br>
9.	The cache of claim 8, said cache including a queue from which updates to said are made, wherein said means for deciding to update said data storage comprises means for deciding to update said data storage only if said queue contains less than a threshold number of entries.<br>
10.	The cache of claim 7, and further comprising means for setting said mode of operation of said cache to one of a first mode and a second mode in response to an instruction executed by a processor in the data processing system.<br>
11.	The cache of claim 7, wherein said valid state is a shared state.<br><br>
12.	A data processing system, comprising: an interconnect and a<br>
plurality of processors coupled to said interconnect; a plurality of caches<br>
that are each associated with a respective one of said plurality of<br>
processors, wherein a cache among said plurality of caches includes: data<br>
storage; tag storage that stores an address tag indicating an address of a<br>
data item contained in said data storage; a coherency indicator having at<br>
least a valid state that indicates that said data item is valid a data-invalid<br>
state that indicates that said address tag is valid and that a data item in<br>
said data storage is invalid; and a cache controller coupled to said<br>
coherency indicator, said tag storage and said data storage, wherein<br>
responsive to detection of a data transfer on the interconnect initiated by a<br>
read request of another device in the data processing system, said data<br>
transfer including a second data item, said cache controller determines<br>
whether or not to update said data storage based upon (1) a mode of<br>
operation of said cache, (2) whether said coherency indicator indicates<br>
said data-invalid state, and (3) whether said address tag matches an<br>
address associated with said data transfer, and wherein, responsive to a<br>
determination to update to said data storage, said cache controller stores<br>
said second data item in said data storage in association with said address<br>
tag and updates said coherency indicator to said valid state.<br>
13.	The data processing system of claim 12, wherein said cache<br>
controller comprises: means, responsive to said cache operating in a first<br>
mode, for always deciding to update said data storage if said coherency<br>
indicator indicates said data-invalid state and said address tag matches<br>
said address associated with said data transfer; and<br>
means, responsive to said cache operating in a second mode, for deciding<br>
to   update   said   data   storage   only   if   said   cache   is   not   busy.<br><br>
14.	 The data processing system of claim 13, said cache including a<br>
queue from which updates are made, wherein said means for deciding to<br>
update said data storage comprises means for deciding to update said data<br>
storage only if said queue contains less than a threshold number of<br>
entries.<br>
15.	The data processing system of claim 12, and further comprising means for setting said mode of operation of said cache to one of a first mode and a second mode in response to an instruction executed by an associated     processor     among     said     plurality     of     processors.<br>
16.	The data processing system of claim 12, and further comprising performance monitor hardware that monitors one or more selected events and sets said mode of operation of said cache in response to an occurrence  of at  least  one  of said  one  or more  selected  events.<br>
17.	The data processing system of claim 12, wherein said valid state is a<br>
shared state.<br>
18.	A method of maintaining cache coherency in a data processing<br>
system substantially as hereinabove described and illustrated with<br>
reference to the accompanying drawings.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTM3LW1hcy0xOTk5LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">137-mas-1999-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTM3LW1hcy0xOTk5LWFzc2lnbm1lbnQucGRm" target="_blank" style="word-wrap:break-word;">137-mas-1999-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTM3LW1hcy0xOTk5LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">137-mas-1999-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTM3LW1hcy0xOTk5LWNvcnJlc3BvbmRlbmNlIG90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">137-mas-1999-correspondence others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTM3LW1hcy0xOTk5LWNvcnJlc3BvbmRlbmNlIHBvLnBkZg==" target="_blank" style="word-wrap:break-word;">137-mas-1999-correspondence po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTM3LW1hcy0xOTk5LWRlc2NyaXB0aW9uIGNvbXBsZXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">137-mas-1999-description complete.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTM3LW1hcy0xOTk5LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">137-mas-1999-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTM3LW1hcy0xOTk5LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">137-mas-1999-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTM3LW1hcy0xOTk5LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">137-mas-1999-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTM3LW1hcy0xOTk5LWZvcm0gNC5wZGY=" target="_blank" style="word-wrap:break-word;">137-mas-1999-form 4.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="235139-a-record-carrier-a-recording-device-and-a-method-of-manufacturing-a-record-carrier.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="235141-photo-cured-and-stabilized-coatings.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>235140</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>137/MAS/1999</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>29/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>17-Jul-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>25-Jun-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>03-Feb-1999</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTERNATIONAL BUSINESS MACHINE CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>NEW YORK 10504.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>RAVI KUMAR ARIMILLI</td>
											<td>NEW YORK 10504.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>JOHN STEVEN DODSON</td>
											<td>NEW YORK 10504.</td>
										</tr>
										<tr>
											<td>3</td>
											<td>JERRY DON LEWIS</td>
											<td>NEW YORK 10504.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F012/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/024,612</td>
									<td>1998-02-17</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/235140-a-method-of-maintainig-cache-coherency-a-cache-and-a-data-processing-system by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:37:59 GMT -->
</html>
