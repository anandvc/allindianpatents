<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/233770-method-for-optimising-compiler-generated-program-code-intended-for-a-portable-data-carrier-and-portable-data-carrier-therefor by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:53:20 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 233770:METHOD FOR OPTIMISING COMPILER-GENERATED PROGRAM CODE INTENDED FOR A PORTABLE DATA CARRIER AND PORTABLE DATA CARRIER THEREFOR</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD FOR OPTIMISING COMPILER-GENERATED PROGRAM CODE INTENDED FOR A PORTABLE DATA CARRIER AND PORTABLE DATA CARRIER THEREFOR</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The present invention relates to a method for the optimisation of compiler-generated program code, wherein the compiler-generated program code 38 is searched for program code fragments 42 which correspond, at least in their effect, to respectively one library code fragment 30x contained in a predefined library 28. The program code fragments 42 found thereby are replaced by respectively one call of the corresponding library code fragment 30x. A portable data carrier 10 contains both the program code 44 optimised according to this method and the library 28. The invention renders possible a good utilisation of the memory available in the portable data carrier 10, and a high flexibility for program changes and/or for the production of data carriers 10 in smaller production volumes.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>METHOD FOR OPTIMISING COMPILER-GENERATED PROGRAM<br>
CODE INTENDED FOR A PORTABLE DATA CARRIER<br>
AND PORTABLE DATA CARRIER THEREFOR<br>
The invention relates to method for optimising compiler-generated program code<br>
intended for a portable data carrier and portable data carrier therefor. A portable data<br>
carrier within the meaning of the present document may be, in particular, a chip card<br>
(smart card), in various designs, or a chip module.<br>
Portable data carriers, as they are in common use today, have a processor core and a<br>
plurality of memories produced in different technologies. In a typical configuration, for<br>
example, a mask-programmed ROM, an electrically erasable and programmable<br>
EEPROM and a writeable RAM are provided. The RAM serves as a working memory<br>
during the running of the program, while the program code to be executed by the<br>
processor core can be stored in the ROM and / or in the EEPROM. These and similar<br>
designs of data carriers are described in section 3.4 of the book "Handbuch der<br>
Chipkarten" by W. Rankl and W. Effing, Hanser Verlag, third edition 1999.<br>
Typically, a memory cell in the EEPROM occupies approximately four times the chip<br>
area of a ROM memory cell. In order to save chip area, or to achieve greater available<br>
memory capacity with the same area, it is therefore desirable for the executable program<br>
code to be accommodated as extensively as possible in the ROM. However, it is<br>
necessary that the content of the mask-programmed ROM is unalterably defined for large<br>
numbers of data carriers as early as during the production stage of the mask-programmed<br>
ROM. Writing into the EEPROM, by contrast, is performed only upon the completion<br>
and initialisation of a series of data carriers, or when the individual data carriers are<br>
personalised. Due to the greater flexibility, therefore, it is advantageous for the<br>
executable program code to be stored as extensively as possible in the EEPROM. This<br>
applies both to the programming of smaller production volumes of data carriers and to the<br>
correction of faults and the introduction of additional functions in the case of large-<br>
volume production.<br>
In the programming of portable carriers, there is therefore the problem of, on the one<br>
hand, using the mask-programmed ROM or a comparable memory as extensively as<br>
possible and, on the other hand, achieving as great a flexibility as possible for program<br>
changes and / or for the production of data carriers in smaller production volumes.<br>
This problem is wholly or partially solved, according to the invention, by a method for<br>
optimising compiler-generated program code intended for a portable data carrier having<br>
both a processor core and a first and second memory area, the method comprising the<br>
steps of : providing the data carrier with a predefined library that is stored in the second<br>
memory area, the predefined library having a multiplicity of library code fragments;<br>
searching the compiler-generated program code for program code fragments which<br>
correspond, at least in respect of their effect, to respectively one library code fragment,<br>
and replacing the program code fragments as found, by respectively one call of the<br>
corresponding library code fragment; and loading the optimised program code into the<br>
first memory area. The invention also provides a portable data carrier having a processor<br>
core, a first memory area and a second memory area, the first memory area containing<br>
optimised program code generated by the above method, and the second memory area<br>
containing a library which is predefined independently of the optimised program code and<br>
has a multiplicity of library code fragments. Preferred developments of the invention are<br>
described hereinafter. The sequence in which the steps are itemised in the claims relating<br>
to the method is not to be understood as a limitation of the extent of protection. Rather,<br>
developments of the invention are provided for in which these steps are performed in a<br>
different sequence, or wholly or partially in parallel, or wholly or partially interleaved<br>
with one another.<br>
The invention proceeds from the basic idea of using a predefined library containing a<br>
multiplicity of library code fragments for the purpose of optimising the program code. In<br>
the optimisation method according to the invention, the program code to be optimised, for<br>
its part, is searched for program code fragments which correspond in their effect or<br>
function to respectively one library code fragment. Such program code fragments are<br>
replaced by respectively one call of the corresponding library code fragment. The<br>
optimised program code is stored in a first memory area of the data carrier (e.g., in the<br>
EEPROM), while the library is provided for storage in a second memory area (e.g., in the<br>
ROM).<br>
In tests performed by the inventors, the optimisation procedure according to<br>
the invention resulted in a marked reduction of the size of the program code<br>
provided for the first memory area. This result is unexpected, since one<br>
would intuitively assume that, with a library of realistic extent, only few<br>
parts of the program code would be found to correspond to the library code<br>
fragments.<br>
The reduction of the code size brought about by the invention has the result<br>
that, in the case of a data carrier with a predefined amount of memory,<br>
program code for additional functions can be included in the first memory<br>
area. If the first memory area is designed as an EEPROM or in a comparable<br>
technology, this program code need only be loaded upon the completion or<br>
initialisation or personalisation of the data carrier. The program code which,<br>
due to its compactness, implements a multiplicity of functions, can therefore<br>
be changed or newly written both rapidly and even for small production<br>
volumes of data carriers, or even for single data carriers.<br>
According to the invention, the predefined library is located in the second<br>
memory area, i.e., for example, in the mask-programmed ROM. Normally,<br>
the saving of program code achieved by the optimisation according to the<br>
invention is less than the size of the library. Even in this case, however, the<br>
application of the invention is advantageous, due to the better utilisation of<br>
the valuable first memory area. If in the compiler-generated program code<br>
there are many code fragments, groups of which in each case can be replaced<br>
by respectively one single code fragment of the library, and if the library<br>
contains only few code fragments which are not required, the optimisation<br>
can result in the program code shrinking by even more than the length of the<br>
library. In this case, use of the invention is advantageous even if the first and<br>
second memory areas are only conceptual sections of one and the same<br>
physical memory field.<br>
According to the invention, for the purpose of optimisation a search is<br>
performed for program code fragments, i.e., for sections in the compiler-<br>
generated program code which can be replaced by corresponding library<br>
code fragments. This subsequent optimisation procedure need not be taken<br>
into account by the programmer during program generation; in particular,<br>
the programmer need not make provision in the program for calls of library<br>
routines. Thus, programming is not in any way rendered more difficult by<br>
the invention.<br>
In the choice of words used here, the terms "program code" or "code<br>
fragment" are intended to denote both executable machine code, before or<br>
after linkage, and the corresponding assembler source code. In other words,<br>
in different developments of the invention the optimisation procedure<br>
according to the invention can be performed both on the basis of the<br>
compiler-generated assembler source code and on the basis of the already<br>
assembled machine code. In the case of the former, the assembling and, if<br>
necessary, the linkage are performed only after optimisation. The library,<br>
likewise, can be available during optimisation as assembler source code<br>
and/or as already assembled machine code.<br>
In general, a replacement of a program code fragment by a library code<br>
fragment is possible whenever both code fragments perform mutually<br>
corresponding functions. In this connection, complex calculations can be<br>
performed in respect of the exact effects of code fragments in order, for<br>
example, to initiate a replacement procedure even if individual instructions<br>
in the code fragments are commuted in an innocuous manner. In<br>
particularly simple exemplary embodiments, by contrast, a replacement is<br>
performed only if the code fragments are identical in respect of the machine<br>
code defined by them. Even in the case of this simple development,<br>
however, a certain analysis of the code fragments is required, due to the fact<br>
that, for example, a code fragment having a jump with a jump destination<br>
which is not in the code fragment may not generally be replaced.<br>
Additional replacement possibilities ensue if parameterised code fragments<br>
are used which, in a manner similar to a procedure call, contain one or more<br>
parameters (e.g., memory addresses or numerical values).<br>
Preferably, a library code fragment is normally called through a subroutine<br>
call instruction inserted in the program code. A return instruction,<br>
immediately following the library code fragment, is then provided in the<br>
library. Exceptions from this rule may apply in some embodiments if the<br>
code fragment to be replaced interferes with the program flow. If, for<br>
example, the code fragment ends with a subroutine return instruction, the<br>
call can normally be effected by means of a jump instruction.<br>
According to the invention, the library used is predefined, i.e., not<br>
dependent on the program code processed in the current optimisation run.<br>
In order to achieve the best possible optimisation results, however, the<br>
library is preferably designed so that it contains appropriate entries for<br>
frequently occurring structures of the program code. Such frequently<br>
occurring code sections may depend, in particular, on the hardware and/or<br>
an operating system of the data carrier and/or on a compiler used in the<br>
generation of the compiler-generated program code.<br>
The computer program product provided according to the invention may be, in particular,<br>
a computer-readable data carrier such as, for example, an electronic or magnetic or<br>
optical memory medium, but it is not limited to physical data carriers. Electrical or<br>
optical signals (e.g., voltage levels of a communication link) are also to be understood as<br>
computer program product in the sense used here. The computer program product<br>
contains program code which executes the optimisation steps according to the invention.<br>
Preferably, the computer program product additionally includes a compiler and/or an<br>
assembler and / or a linker and / or a loader program.<br>
The computer program product according to the invention and the portable data carrier<br>
according to the invention are preferably developed with features which correspond to the<br>
features described above.<br>
Further features, objects and advantages of the invention are disclosed by the following<br>
description of an exemplary embodiment and a plurality of alternative embodiments.<br>
Reference is made to the accompanying schematic drawing, in which the sole figure (Fig.<br>
1) shows a representation of a portable data carrier and of different versions of the<br>
program code in an exemplary embodiment of the invention.<br>
The invention is used in the programming of a portable data carrier 10 which, in the<br>
exemplary embodiment described here, is designed as a chip card. The data carrier 10<br>
contains, in a manner known per se, a semiconductor chip having a processor core 12, a<br>
mask-programmed ROM 14, an EEPROM 16, a RAM 18, and an interface 20 for<br>
contactless or contact-bound communication. The said components are connected to one<br>
another via a bus 22. In alternative embodiments, the three memory fields 14, 16, 18<br>
may be designed in other technologies; in particular, FLASH technology may<br>
be used for the ROM 14 and/or the EEPROM16.<br>
A first and a second memory area 24,26 are conceptually provided in the<br>
memory fields 14,16,18. The first memory area 24 serves to receive the<br>
optimised program code in the form of executable machine code. A<br>
predefined library 28, likewise in the form of executable machine code, is<br>
stored in the second memory area 26. In the exemplary embodiment<br>
described here, the first memory area 24 is located in the EEPROM 16, and<br>
the second memory area 26 is located in the ROM 14. In a manner known<br>
per se, the ROM 14 contains, in addition to the second memory area 26,<br>
further, fixedly predefined routines which constitute, for example, an<br>
operating system of the data carrier 10. The EEPROM 16 additionally<br>
includes a file system for data which are to be stored as non-volatile data in<br>
the data carrier 10.<br>
The library 28 has a multiplicity of predefined library code fragments 30A,<br>
30B, 30C,..., which are denoted generally in the following by 30x. In Fig. 1,<br>
for reasons of clearer representation, the library code fragments 30x are<br>
shown as assembler source code. Normally, each library code fragment 30x<br>
is followed immediately by a subroutine return instruction 32A, 32B,...<br>
(denoted generally in the following by 32x). The subroutine return<br>
instruction 32x may be omitted, however, if it cannot be reached in the<br>
execution of the library code fragment 30x due to the fact that, for example,<br>
each program flow of the library code fragment 30x ends in an exit or in a<br>
subroutine return instruction contained in the library code fragment 30x.<br>
The program development for the portable data carrier 10 proceeds from a<br>
high-level language source code 34, which is represented exemplarily in<br>
Fig. 1 in the programming language C. The section shown in Fig. 1 waits<br>
until the third bit of the input register INPORT out from the unit position<br>
attains the value "0", and then sets the output register OUTPORT to the<br>
hexadecimal value "FF". A compiler 36 known per se converts the high-level,<br>
language source code 34 into compiler-generated program code 38, which in<br>
Fig. 1 is represented in the form of assembler source code for the 6805<br>
instruction set. Other instruction sets, respectively in accordance with the<br>
processor core 12, are provided for in alternative embodiments.<br>
An optimisation program 40 executes the optimisation steps that are<br>
essential for the present exemplary embodiment. The optimisation program<br>
40 processes the compiler-generated program code 38 and, moreover,<br>
accesses information about the library code fragments 30x contained in the<br>
library 28. In different embodiment variants, this information can contain,<br>
for example, a copy of the library 28 in the assembler source code and/or a<br>
copy of the library 28 in the executable machine code and/or a specification<br>
of the effect of the individual library code fragments 30x in an appropriate<br>
description language. Furthermore, additional information such as, for<br>
example, indexes or hash tables can be provided in order to accelerate the<br>
search procedures performed by the optimisation program 40.<br>
The optimisation program 40 identifies program code fragments 42<br>
contained in the compiler-generated program code 38 which, in execution by<br>
the processor core 12, have a function which is identical to that of library<br>
code fragments 30x contained in the library 28. Used for this purpose in the<br>
present exemplary embodiment is a relatively simple procedure, in which<br>
the compiler-generated program code 38 is compared, at assembler source text level, with the individual entries in the library 28. With regard to the<br>
instructions in short form and the address and value information, a textual<br>
comparison can be performed in this case. Symbolic jump destinations, by<br>
contrast, must be converted, prior to comparison, into a standardised form or<br>
into a numeric relative value. In alternative embodiments, by contrast, the<br>
optimisation can be performed on the basis of a compiler-generated program<br>
code 38 already present in the form of assembled machine code.<br>
A program code fragment 42 for which a corresponding library code<br>
fragment 30x has been found in the comparison procedure is replaced, in the<br>
optimisation procedure, by a call of this library code fragment 30x. In Fig. 1,<br>
for example, the program code fragment 42 and the library code fragment<br>
30B are identical apart from the symbolic designation of the jump<br>
destination. In the optimised program code 44, therefore, the optimisation<br>
program 40 replaces this program code fragment 42 by a call of the library<br>
code fragment 30B. In the present example, this call is designed as a<br>
subroutine call instruction 46. Since, in the present example, the program<br>
code fragment 42 corresponds to a machine code of seven bytes in length<br>
and the subroutine call instruction 46 requires only three bytes, the memory<br>
space required for the optimised program code 44 has been substantially<br>
reduced by the replacement.<br>
Following completion of the optimisation, the optimised program code 44 is<br>
converted by an assembler 48 into machine code that can be executed by the<br>
processor core 12. Following a possibly necessary linking operation with<br>
further program parts, the code is loaded into the first memory area 24 upon<br>
completion or initialisation or personalisation of the data carrier 10. The<br>
library 28 has already been present in the second memory area 26 since the<br>
time at which the chip for the data carrier 10 was produced. The data carrier<br>
10 is therefore ready for use. The translation, optimisation and assembling<br>
steps described above are performed by a general-purpose computer (not<br>
shown in Fig. 1) which executes the compiler 36, the optimisation program<br>
40 and the assembler 48.<br>
When, in the operation of the data carrier 10, the program execution by the<br>
processor core 12 reaches the location of the subroutine call instruction 46 in<br>
the first memory area 24, the library code fragment 30B in the second<br>
memory area 26 is executed as a subroutine. In their effect, the executed<br>
instructions correspond exactly to the program code fragment 42 removed<br>
during the optimisation. Following execution of these instructions, the<br>
processor core 12 executes a return, triggered by the subroutine return<br>
command 32B, to that instruction in the first memory area 24 which<br>
immediately follows the subroutine call instruction 46.<br>
It must be ensured during the optimisation that the program functions are<br>
not altered. Thus, for example, program code fragments 42 having jump<br>
instructions which might have a jump destination located outside the<br>
program code fragment 42 should only be replaced following precise<br>
analysis. A replacement is allowable if each possible flow of the program<br>
code fragment 42 ends with an exit or a subroutine return. In such cases,<br>
however, the corresponding library code fragment 30x is called by means of<br>
a normal jump instruction rather than by means of a subroutine call<br>
instruction. These considerations may also be included even at the time of<br>
generation of the library 28, so that the latter contains only such library code<br>
fragments 30x that may be used without further constraints.<br>
The library 28 should be of such construction that it provides appropriate<br>
library code fragments 30x as often as possible and thus offers as may<br>
optimisation possibilities as possible. Thus, for example, the library code<br>
fragment 30B of Fig. 1 is matched to the hardware characteristics of the data<br>
carrier 10. If the input bit requested in this library code fragment 30B<br>
corresponds to a frequently required signal value, it is to be assumed that<br>
corresponding program code fragments 42 occur time and again in the<br>
compiler-generated program code 38 even for greatly differing applications<br>
of the data carrier 10. Similarly, frequent operating system calls can be<br>
covered by corresponding library code fragments 30x. A further source for<br>
repeating code fragments in the compiler-generated program code 38 results<br>
from the fact that the code generation in the compiler 36 is performed<br>
according to certain schemas, and recurring code structures are generated as<br>
a consequence.<br>
Overall, therefore, it is advantageous, for the purpose of generating the<br>
library 28, to statistically evaluate the program code 38 generated by the<br>
compiler 36 for a multiplicity of applications designated for the hardware<br>
and the operating system of the data carrier 10.<br>
WE CLAIM :<br>
1. Method for optimising compiler-generated program code (38) intended for a portable data<br>
carrier (10) having both a processor core (12) and a first and second memory area (24, 26), said method<br>
comprising the steps of:<br>
- providing the data carrier (10) with a predefined library (28) that is stored in the second<br>
memory area (26), the predefined library (28) having a multiplicity of library code fragments (30x) ;<br>
- searching the compiler-generated program code (38) for program code fragments (42) which<br>
correspond, at least in respect of their effect, to respectively one library code fragment (30x), and<br>
replacing the program code fragments (42) as found, by respectively one call of the corresponding<br>
library code fragment (30x) ; and<br>
- loading the optimised program code (44) into the first memory area (24).<br>
2. Method as claimed in claim 1, wherein a program code fragment (42) is replaced by a library<br>
code fragment (30x) only if both code fragments (42, 30x) are identical in their form as executable<br>
machine code.<br>
3. Method as claimed in claim 1, wherein at least some library code fragments (30x) are<br>
parameterised.<br>
4. Method as claimed in any one of claims 1 to 3, wherein a program code fragment (42) to be<br>
replaced is replaced, at least if the program code fragment (42) does not interfere with the program<br>
flow, by a subroutine call instruction (46) to the corresponding library code fragment (30x).<br>
5. Method as claimed in any one of claims 1 to 4, wherein the compiler-generated program code<br>
(38) exists in the form of assembler source code, and the optimisation procedure is performed on a<br>
source code level.<br>
6. Method as claimed in any one of claims 1 to 5, wherein the predefined library (28) is matched to<br>
the hardware of the portable data carrier (10) and / or to an operating system of the portable data carrier<br>
(10) and / or to a compiler (36) used in the generation of the compiler-generated program code (38).<br>
7. Method as claimed in any one of claims 1 to 6, wherein the first memory area (24) is electrically<br>
programmable, and / or the second memory area (26) is mask-programmable, and / or the first memory<br>
area (24) occupies more chip area per memory cell in the portable data carrier (10) than is occupied by<br>
the second memory area (26).<br>
8. Portable data carrier (10) having a processor core (12), a first memory area (24) and a second<br>
memory area (26), the first memory area (24) containing optimised program code (44) generated by a<br>
method as claimed in any one of claims 1 to 7, and the second memory area (26) containing a library<br>
(28) which is predefined independently of the optimised program code (44) and has a multiplicity of<br>
library code fragments (30x).<br>
The present invention relates to a method for the optimisation of compiler-generated <br>
program code, wherein the compiler-generated program code 38 is searched<br>
for program code fragments 42 which correspond, at least in their effect, to respectively<br>
one library code fragment 30x contained in a predefined library 28. The program code<br>
fragments 42 found thereby are replaced by respectively one call of the corresponding<br>
library code fragment 30x. A portable data carrier 10 contains both the program code 44<br>
optimised according to this method and the library 28. The invention renders possible a<br>
good utilisation of the memory available in the portable data carrier 10, and a high<br>
flexibility for program changes and/or for the production of data carriers 10 in smaller<br>
production volumes.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1LT0xOUC0yMDA0LUNPUlJFU1BPTkRFTkNFLnBkZg==" target="_blank" style="word-wrap:break-word;">1403-KOLNP-2004-CORRESPONDENCE.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1LT0xOUC0yMDA0LUZPUk0gMjcucGRm" target="_blank" style="word-wrap:break-word;">1403-KOLNP-2004-FORM 27.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1LT0xOUC0yMDA0LUZPUk0tMjcucGRm" target="_blank" style="word-wrap:break-word;">1403-KOLNP-2004-FORM-27.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtYXNzaWdubWVudC5wZGY=" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtY29ycmVzcG9uZGVuY2UucGRm" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtZXhhbWluYXRpb24gcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtZm9ybSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtZm9ybSAxOC5wZGY=" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtZm9ybSAzLnBkZg==" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtZm9ybSA1LnBkZg==" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtZ3BhLnBkZg==" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtcmVwbHkgdG8gZXhhbWluYXRpb24gcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTQwMy1rb2xucC0yMDA0LWdyYW50ZWQtc3BlY2lmaWNhdGlvbi5wZGY=" target="_blank" style="word-wrap:break-word;">1403-kolnp-2004-granted-specification.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="233769-an-applier-10-for-a-surgical-procedure.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="233771-security-device-process-for-preparing-a-security-device-and-security-document-having-one-or-more-security-devices.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>233770</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1403/KOLNP/2004</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>15/2099</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>10-Apr-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>08-Apr-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>22-Sep-2004</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>GIESECKE &amp; DEVRIENT GMBH</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>PRINZREGENTENSTRASSE 159, 81677 MUNCHEN</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>BALDISCHWEILER MICHAEL</td>
											<td>HANS-JAKOB-STR. 99, 81825, MUNCHEN</td>
										</tr>
										<tr>
											<td>2</td>
											<td>NESS WERNER</td>
											<td>RINGHOFFERSTR. 76, 85716 UNTERSCHLEISSHEIM</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 9/45</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/EP2003/03803</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2003-04-11</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>102 16 602.1</td>
									<td>2002-04-15</td>
								    <td>Germany</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/233770-method-for-optimising-compiler-generated-program-code-intended-for-a-portable-data-carrier-and-portable-data-carrier-therefor by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:53:21 GMT -->
</html>
