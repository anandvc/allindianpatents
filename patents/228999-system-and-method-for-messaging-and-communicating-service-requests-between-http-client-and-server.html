<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/228999-system-and-method-for-messaging-and-communicating-service-requests-between-http-client-and-server by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:38:50 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 228999:SYSTEM AND METHOD FOR MESSAGING AND COMMUNICATING SERVICE REQUESTS BETWEEN HTTP CLIENT AND SERVER</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">SYSTEM AND METHOD FOR MESSAGING AND COMMUNICATING SERVICE REQUESTS BETWEEN HTTP CLIENT AND SERVER</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Abstract: In a traditional application server that uses when a request is dispatched !o a thread the service method of the appropriate is called. When the service method returns, the response is sent. This is sub-optimal in the case that an asynchronous event must occur before the response can be sent, because the thread running the singlet must block until the event occurs. The invention provides for asynchronous processing of such requests (510). In one embodiment, the invention provides an extension to the API which allows the service method (514) to return (516), and thus the thread to be freed, before the response is rainy to be sent. Then when the asynchronous event later (520) occurs the response may be completed and sent (518, 522, 524),</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
SYSTEM FOR INTEGRATING JAVA SERVLETS WITH ASYNCHRONOUS MESSAGES<br>
COPYRIGHT NOTICE<br>
A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.<br>
Claim of Priority:<br>
[0001]	This application claims priority from provisional application<br>
"SYSTEM    FOR    APPLICATION    SERVER    MESSAGING    WITH<br>
ASYNCHRONOUS   QUEUES",   Application   No.   60/327,530,   filed<br>
October 5, 2001, and which application is incorporated herein by<br>
reference.<br>
Field of the Invention:<br>
[OO02]	The   Invention   relates   generally   to   application   and<br>
transaction sen/ers and panicularly to a system for supporting message queuing and threads with multiple execute queues.<br>
Cross References:<br>
[0003]	This  application  is  related  to  provisional  application<br>
"SYSTEM FOR APPLICATION SERVER MESSAGING WITH MULTIPLE DISPATCH POOLS", Application No. 60/327,543, filed October  5,   2001.  and   Utility  Patent Application   "SYSTEM   FOR<br><br>
APPLICATION SERVER MESSAGING WITH MULTIPLE DISPATCH<br>
POOLS", Application Number	, inventors; Adam Messinger<br>
and Don Ferguson, filed October 3, 2002 both applications are incorporated herein by reference.<br>
Background of the Invention:<br>
[00041	The   Java   2    Platform,    Enterprise    Edition   (J2EE)<br>
specification defines one of the current standards for developing multi-tier enterprise applications, J2EE provides a component-based approach to the design, development, assembly, and deployment of enterprise applications, which both reduces the cost and enables fasten design and implementation. The J2EE platform gives the developer a multi-tiered distributed application model, the ability to reuse components, a unified security model, and flexible transaction control. Not only can they deliver innovative customer solutions to market faster than ever, but the resultant platform-independent J2EE component-based solutions are not tied to the products and application program interfaces (APIs) of any one vendor.<br>
[0005]	The J2EE specification defines the following kinds of<br>
components: application client components; Enterprise JavaBeans (EJB); servlets and Java Server Pages (JSP) (also called Web components); and applets. A multi-tiered distributed application model implies that the application logic is divided into components according to function, and different application components may make up a J2EE application on the same or different servers. Where an application component is actually installed depends on which tier in the multi-tiered J2EE environment the application component belongs. These tiers are<br><br>
depicted in Figure 1. As stiown therein an application ser/ertier 104 is used to develop EJB containers and/or presentation containers such as senyiets, JSP, and html pages 114. These in turn are used as an interface between a client tier 102, where the clients 108 and client applications are deployed, and a backend tier 106, used for hosting enterprise or legacy applications such Enterprise Resource Planning (ERP) systems.<br>
[0006]	Client tier-These can be browsers, Java-based programs,<br>
or other Web-enabled programming environments running within the<br>
client tier, both inside and outside of corporate firewalls.<br>
[0007]	Application   Server tier -   Normally  this  tier  hosts  a<br>
combination of presentation logic and business logic to support client requests. Presentation logic is supported via JSP pages and servlets that display HTML pages, while business logic is supported via Remote Method Invocation (RMI) objects and EJBs 112. EJBs rely upon the container environment for transactions, lifecycle and state management, resource pooling, security, etc., which together make up the run time environment in which the beans are executed.<br>
[0008]	Back-end tier - This is generally a combination of existing<br>
applications and data stores, it is also referred to as the Enterprise<br>
Information Systems (EIS) tier, since it may include such systems as<br>
Enterprise Resource Planning (ERP), mainframe transaction<br>
processing, database systems, and other legacy information systems.<br>
[0009]	Since   the   components   of  a   J2EE   application   run<br>
separately, and often on different devices, there needs to be a way for client and application server tier code to look up and reference other code and resources. Client and application code can, for example, use<br><br>
the Java Naming and Directory Interface (JNDI) 116 to look up user-defined objects such as enterprise beans, and environment entries such as the location of the Java Database Connector (JDBC) DataSource objects, which in turn are used for looking up resources in backend tier, and message connections.<br>
[0010]	Application behavior such as security and transaction<br>
management can be configured at deployment time on Web and<br>
enterprise bean components. This deployment time feature decouples<br>
application logic from the configuration settings that might vary with the<br>
assembly. The J2EE security model lets a developer configure a Web<br>
or enterprise bean component so that system resources are accessed<br>
only by authorized users. For example, a Web component can be<br>
configured to prompt for a user name and password. An Enterprise<br>
Bean component can be configured so that only persons in specific<br>
groups can invoke certain kinds of its methods. Alternatively, a servlet<br>
component might be configured to have some of its methods accessible<br>
to everyone, and a few methods accessible to only certain privileged<br>
persons in an organization. The same servlet component can be<br>
configured for another environment to have all methods available to<br>
everyone, or all methods available to only a select few.<br>
[0011]	Some application senders, such as the WebLogtc Server<br>
product from BEA Systems, Inc., San Jose, California, use an Access Control List (ACL) mechanism that allows for fine-grained control of the usage of components running on the server. Using an ACL, a developer can define at the Java Method level what can, or cannot, be executed by which user or group of users. This ACL mechanism covers anything that runs on the application server except for EJBs, which have their<br><br>
own access control mechanism defined in the EJB specification. Security realms allow the administrator to import information from existing authorization or authentication systems into the ACL.<br>
Java Servlets<br>
[0012]	A sen/let is a program that extends the functionality of a<br>
Web sewer. A servlet receives a request from a client, dynamically generates the response (possibly querying databases to fulfill the request), and then sends the response containing an HTML or XML document to the client. Servlets are similar to CGi but are typically easier to write, since servlets use Java classes and streams. They execute faster because servlets are compiled to Java byte code and at run time the servlet instance is kept in memory, each client request spawning a new thread. Servlets make it easy to generate data to an HTTP response stream in a dynamic fashion. Each client request is performed as a new connection, so flow control does not come naturally between requests. To allow for this session management maintains the state of specific clients bet^/zeen requests. In some application servers, servlets make use of the HTTP session object to save their state between method requests. This object can be replicated in a clustered environment for failover purposes,<br>
Java Server Pages<br>
[0013]	JSP pages are a text-based, presentation-centric way to<br>
develop servlets, JSP pages offer all the benefits of servlets, and when combined with a JavaBeans class, provide an easy way to keep content and display logic separate. Both JSP pages and servlets are more<br><br>
desirable than Common Gateway Interface (CGI), because they are platform-independent, and use less overhead. JSP pages can be used with JavaBeans classes to define Web templates for building a Web site made up of pages with a similar look and feel. The JavaBeans class performs the data rendering, so the templates have no Java code. This means they can be maintained by an HTML editor. Simple Web-based application using a JSP page can be used to bind content to application logic using custom tags or scriptlels instead of a JavaBeans class. Custom tags are bundled into tag libraries that are imported into a JSP page. Scriptlets are small Java code segments embedded directly in the JSP page.<br>
Java Messaging Services (JMS)<br>
[0014]	JMS  is the  J2EE  mechanism  used  to  support the<br>
exchange of messages between Java programs. This is how Java<br>
supports  asynchronous  communication,  wherein   the  sender and<br>
receiver don't need to be aware of each other and thus can operate<br>
independently. JMS supports two messaging models:<br>
[0015]	Point to point - which is based on message queues. In this<br>
model message producer sends a message to a queue. A message<br>
consumer can attach itself to a queue to listen for messages. When a<br>
message arrives on the queue, the consumer takes it off the queue and<br>
responds to it. Messages can besenttojustonequeueand will be used<br>
by just one consumer. Consumers have the option to filter messages to<br>
specify the exact message types they want.<br>
[0016]	Publish and subscribe - which allows producers to send<br>
messages to a topic and for al! the registered consumers for that topic<br><br>
to retrieve those messages, in this case, many consumers can receive the same message.<br>
[0017]	One problem with current Servlet APIs is the completely<br>
synchronous programming model. After a request is dispatched to a particular thread the sen/ice() method of the appropriate sen/let is called. When the service{) method returns, the response is sent. This Is a simple programming model which is suitable for many types of work, but is sub-optimal in the case that a asynchronous event must occur before the response can be sent, because the thread running the servlet must block until the event occurs.<br>
Summary of the Invention:<br>
[QQ18]	The   invention   provides   a   system   and   method   tor<br>
asynchronous threading which allows the service{) method to return<br>
(and thus allowing the thread to be freed up) before the response is<br>
ready to be sent. Then when the asynchronous event later occurs the<br>
response may be completed and sent. An example use of this<br>
mechanism is the use of JMS in conjunction with sen/fets.<br>
[0019]	In accordance with the invention, the process begins when<br>
a servlet is executed. The sen/let builds a portion of a response, but typically needs more data to complete the response. While it's waiting it queues a JMS message requesting the data and sets the response object aside in a place where it may be found when a JMS message containing the needed data arrives. At this point the serviet may return, but the response will not yet be sent. At a later point in time, when the data arrives via JMS for example, the corresponding response object is<br><br>
retrieved.   The remainder of the response can then be generated.<br>
When the response is completed it can be explicitly sent to the client.<br>
[0020]	This feature is also available through the use of a JSP tag<br>
library. Using the tags the JSP page author specifies what work should be done before the asynchronous event and which work should be done after the asynchronous event. This feature integrates with the JSP context mechanisms to ensure that they are restored after the asynchronous event and that processing can continue uninlernjpted.<br>
Brief Description of the Figures:<br>
[0021]	Figure 1 shows an illustration of a J2EE compatible<br>
architecture that can utilize the present invention.<br>
[0022]	Figure 2 shows an illustration of a threading policy with<br>
asynchronous thread pool in accordance with an embodiment of the<br>
invention.<br>
[0023]	Figure 3 shows a diagram of a synchronous threading<br>
process.<br>
[0024]	Figure 4 shows a lifecycle of a single HTTP request that<br>
is processed using traditional methods.<br>
[0025]	Figure 5 shows a lifecycle of a single HTTP request<br>
processed using asynchronous messaging.<br>
[0026]	Figure 6 shows a lifecycle of a plurality of HTTP requests<br>
processed using traditional methods.<br>
[0027]	Figure 7 shows a lifecycle of a plurality of HTTP requests<br>
processed using asynchronous messaging.<br><br>
Detailed Description:<br>
(0028]	Broadly described, the invention provides a system and<br>
method to allow asynchronous threading. The invention can be incorporated into application sen/er systems that allow access to a sen/letviaanApplicalion Program Interface (API), or into other systems that benefit from asynchronous threading.<br>
[0029]	The typical Servlet APIs are completely synchronous.<br>
After a request is dispatched to a thread, the service() method of the appropriate sen/let is called. When the sen/ice() method returns, the response is sent. This simple programming model is suitable for many types of work, but is sub-oplimal in those instances that an asynchronous event must occur before the response can be sent, because the thread running the servlet must block until the event occurs.<br>
[0030]	In one embodiment, the invention provides an extension<br>
to the Servlet API which allows the sen/ice() method to return (and thus allowing the thread to be freed up) before the response is ready to be sent. Then when the asynchronous event later occurs the response may be completed and sent. One example use of this mechanism is the use of JMS in conjunction with servlets.<br>
[0031]	In this embodiment, when a serviet is executed, it builds<br>
a portion of a response, but then typically needs more data to complete the response. It queues a JMS message requesting the data, and sets the response object aside in a place where it may be found when a JMS message containing the needed data arrives. At this point the sen^let may return, but the response will not yet be sent. Later on, when the required data arrives via JMS, the response object is retrieved.   The<br><br>
remainder of the response can then be generated, and when completed can be explicitly sent to the client.<br>
[0032]	The invention is phmahiy designed for use with application,<br>
transaction, and messaging servers, such as the WebLogic family of products from BEA Systems, Inc. At the core of the typical server's design is the threading model, the policy by which threads are assigned to perform work requests. As sen/let requests arrive at the server they are dispatched to a thread. This thread is responsible for executing the requested servlet. The server employs a threading model which uses two thread pools an asynchronous pool (often referred to as reader threads} and asynchronous poof (referred to as execute threads). This combination of pools allows a developer or administration to effectively prioritize requests while tolerating user code that performs blocking operations.<br>
[0033]	Figure 2 shows a threading policy mechanism 206 in<br>
accordance with an embodiment of the invention. The asynchronous thread pool 208 waits on an asynchronous input mechanism 202 (muxer) for asynchronous read results to become available. Once a result is available a thread from the pool looks at the message and dispatches it by making the appropriate callbacks. The dispatch callbacks usually queue the request for later processing by the synchronous thread pool. However certain non-blocking, priority requests are services directly in the callback. By aggressively accepting input high priority requests 214 do not wait to be read while low priority requests 212 njn. Since these threads should never block there are usually a low number of them, perhaps one per processor (CPU).<br><br>
[0034]	The synchronous thread pool 210 waits on a queue of<br>
requests 204. Once a request is available a thread from the pool processes takes the request from the queue, processes it, and sends out the result 216. While processing the request the thread may execute code, such as sending out the result, which causes the thread to block. The number of threads should therefore be tuned so that there is always one thread per CPU that is in the runnable state. The dispatch policies are described in more detail in provisional application entitled, "SYSTEM FOR APPLICATION SERVER MESSAGING WITH MULTIPLE DISPATCH POOLS", Application Number 60/327,543. Inventor: Adam Messinger, filed October 5, 2001 and copending utility application entitled, "SYSTEM FOR APPLICATION SERVER MESSAGING WITH<br>
MULTIPLE   DISPATCH   POOLS",   Application   Number 	,<br>
Inventors: Adam Messinger and Don Ferguson, filed October 3, 2002,<br>
[0035]	Figure 3  shows a  traditional  synchronous  message<br>
response mechanism. As shown therein, a request from the client application 302, such as for example a Web browser application, is transmitted to the application server via a servlet 304. The request may be in the forn:! of a hypertext transmission protocol (http) request 306, for which the client will typically expect a hypertext markup language (html) response 308. In the synchronous model the thread executes the servlet and then immediately sends the response to the client when execution of the sen/let completes. The problem with this approach is that the executing thread is consumed for the entire execution of the servlet. If the sen/let is performing tasks which block, perhaps waiting for other data, then this can represent a waste of server resources.<br><br>
[0036]	Figure 4 illustrates a typical system iifecycle wherein a<br>
client access a resource at a server. As shown in Figure 4, an HTTP client 402 accesses a servlet 408, which typically runs on a remote web server. It will be evident to one skilled in the art that while HTTP clients are shown herein for purposes of illustration, the invention is not so limited, but may be used with other types of client application. As shown in the Iifecycle diagram in Figure 4, the HTTP client accesses the servlet via a servlet container 404. The servlet container is responsible for receiving the HTTP request 410, and passing it to the sen/let 408 for processing. Much of the operation of processing this HTTP request takes place at the servlet response ievei 406. As illustrated in Figure 4, with time increasing vertically down the page, the process continues with an :inic call 412 to the sen/let, which is handled by the response handler 406. The sen/let container then passes a : service request 414 to the servlet, to retrieve or to update data for example. A typical use of such a system is in an e-commerce environment,'wherein the client application is designed to retrieve catalog listings, such as the results of a search for flight times, etc. The servlet typically responds to the request by writing output 416 to the servlet response handler. This step is often required for buffering, and for optimization purposes. When the servlet container then requests that the response be returned to the client, it sends a :send request 418 to the response handler, and the response handler returns the :send response 420 to the servlet container. The response is then sent as an HTTP response 422 to the client.<br>
[0037]	Figure 5 illustrates a similar life cycle that may be used in<br>
accordance with an embodiment of the invention. As shown in Figure<br><br>
5, again an HTTP client 502 is used to access a remote server, server<br>
resource or servlet 508. The HTTP request 510 is handled by a sen;let<br>
container 504 which issues an :init request 512 to the servlet<br>
response handler 506- This time however, when the :service<br>
request 514 is transmitted to the servlet for processing, the servlet<br>
returns 516 immediately to the response handler. This immediate return<br>
frees up the response handler for handling subsequent requests, in that<br>
it does not need to wait for the sen/let to actively return data in order to<br>
handle those requests. After a period of time t 520, when the servlet<br>
has the appropriate data to return to the requests, it sends a -. send<br>
signal 518 to the response handler, which then sends the .-send<br>
response 522 to the servlet container. The subsequent HTTP<br>
response 524 is transmitted to the client as before.<br>
[0038]	As part of the process described above, the sen/let sets a<br>
response code until it has something else to transmit, effectively taking the responsibility for responding away from the container level and placing it at the servlet level. In practice the amount of time that the servlet waits to issue the :send response can be defined as some arbitrary amount, or can be performed as the result of an asynchronous message, for example as the result of receiving a JMS message indicating that the information is available to be transmitted to the client. This type of processing is useful in, for example, e-commerce sites where a user typically experiences a delay time in awaiting search results. When processing is performed according to the invention, instead of merely having a frozen screen, the user may receive some items of information, while other items are returned piecemeal as the sen/let finds the appropriate data and returns it. At the same time the<br><br>
servlet response handler is available to handle other client requests.<br>
The type of data that is returned immediately, and the type that is<br>
returned later, can be specified by the developer.<br>
[0039]	Figures 6 and 7 illustrate in more detail the operation of<br>
the invention, as it may be applied to service multiple requests. As<br>
shown in Figure 6, when asynchronous messaging is not used,<br>
subsequent requests from clients must be handled in a sequential<br>
manner. So, for example, in Figure 6, a first HTTP request 410 from<br>
client A Is handled by the servlet container 404 and servlet response<br>
handler 406 and completely processed, prior to a second HTTP request<br>
430 from client B 403 being handled. The overall result is one of taking<br>
twice as much time to process HTTP requests from the two clients. If<br>
the requests were not handled in this sequential manner, it is very likely<br>
that one or more requests would create a backlog for other requests<br>
such that the user would experience a delay in processing.<br>
[0040]	Figure 7  illustrates  a  life cycle of a  mechanism in<br>
accordance with an embodiment of the invention In which asynchronous messaging is used to process multiple requests from a single client, and/or requests from multiple clients, in an asynchronous manner, such that the processing can be run in different threads. As shown in Figure 7, a first HTTP client A 502 and a second HTTP client B 503 access a servlet resource 508 using the mechanisms described above. In accordance with this embodiment, when a first HTTP request A 510 is received at the servlet container, it is handled by the response handler using an :ir.-t A call 512, and then passed as a :service request 514 to the servlet 508. The sen/let returns 516 immediately to the servlet response handler, which then frees up the response handler<br><br>
for handling other requesls. As shown in Figure 7, a second HTTP request B is handled immediately as an :init B call 532 by the servlet response handier, and passed to the serviet as a : service request 534 for processing. Again, the serviet returns immediately 536, Interleaving the messages in this manner reduces the overall time for processing both requests, and allows the serviet to return information to the client when and if it becomes available. For example, as shown in Figure 7, when the serviet finds the information necessary to respond to request A it returns that : send response A signal 522 to the serviet container for sending on to the client as HTTP response A 524. A second :send rsspcr.se B signal 542, and HTTP response B 544 is similarly handled in the same way.<br>
Implementation<br>
[0041]	The file sen/let can be replaced by a fast file serviet on<br>
platforms that support the asynchronous sending of files over the network. The implementation of this type of sen/let requires the addition of asynchronous responses for servlets, which is discussed below.<br>
Synchronous and Asynchronous Responses<br>
[0042]	When a sen/let request from a remote client is serviced a<br>
response is often required. This response can either be synchronous, in that it is sent by the same thread that processed the request, or asynchronous in that it is sent later in a different thread. This analysis is from the server's perspective. From the clients perspective eithertype of response may or may not block waiting for it depending upon how the remote request was made.<br><br>
[0043]	Currently most requests are handled in a synchronous<br>
manner. When a sen/let request is serviced all processing must be<br>
completed before the servicing thread can move on to another request.<br>
This synchronous model is the one specified by the RMl and servlet<br>
specifications. The traditional reason for this is that writing<br>
asynchronous code is very difficult and thus prone to error,<br>
[0044]	There are certain situations where the ability to respond to<br>
requests in an asynchronous manner would be very helpful for conserving threads. This is typically true in cases where the server needs to make one or more long ainning requests of external resources or where the server needs to wait on some condition while processing the request. An example of this is a client request to dequeue from a JMS queue that is currently empty. In a synchronous model the thread servicing the request blocks until there is a message in the queue to return to the client. In an asynchronous model the thread can set the request aside and continue servicing other requests. When a message is placed in the queue the request can be found and a response sent to the client. The invention allows servers to support asynchronous responses to RMl and servlet requests.<br>
Servlets<br>
[00451	Particular sen/lets can be declared as asynchronous in<br>
their deployment descriptor. When the service method of an asynchronous sen;let returns, no further action will be taken on that request. The sen/let is responsible for storing the request someplace such that after some other action takes place it can be retrieved and the response sent. At this point a special sendQ method must be called on<br><br>
the request which will flush the streams, log the request, and, if it is a keep alive connection then register the socket with the muxer to receive more data. It is important to create imptementations that ensure resources are appropriately freed by timing out long running requests, thus freeing resources for garbage collection and other cleanup.<br>
JSP<br>
[0046]	An asynchronous model may also be supported in a<br>
similar manner through the use of JSP tag libraries. These tag libraries are used by the http developer/page author to designate which portion of the web page should be executed prior to the asynchronous event and which portion should be executed after the asynchronous event. The tag libraries allow the author to gain access to an object which should be notified when the asynchronous event occurs and JSP page execution should resume.<br>
[0047]	When using the tag libraries the execution context of the<br>
page may be automatically stored before registering for the<br>
asynchronous event. In this way it is possible to hide many of the<br>
details of asynchronous programming from the JSP author. The JSP<br>
need not be concerned about state maintenance. State stored in any<br>
of the standard scopes (page, request, session or application) will<br>
continue to work as they would using a synchronous JSP.<br>
[0048]	The foregoing description of the present invention has<br>
been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Obviously, many modifications and variations will be apparent to the practitioner skilled in the art. The embodiments were<br><br>
chosen and described in order to best explain the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention for various embodiments and with various modifications that are suited to the particular use contemplated. It is Intended that the scope of the invention be defined by the following claims and their equivalence.<br><br><br>
WE CLAIM:<br>
1.	A system for messaging and/or communicating service requests between an<br>
HTTP client and a server, wherein the server comprises a servlet container and<br>
servtets, a means of providing asynchronous threading which allows a service method<br>
to return and the thread to be freed up, before the response is ready to be sent to the<br>
client, comprising;<br>
a server that has a servlet container process, a servlet process, and a servlet response handler process executing on the server;<br>
an HTTP software interface provided by the servlet container that receives requests from an HTTP client, wherein a request from the HTTP client is transmitted by the servlet container to the servlet; and<br>
wherein the servlet upon receiving the request from the servlet container immediately<br>
sets a response code to be used with a subsequent response, releases the response handier to interleave the processing of subsequent requests from the HTTP client or from other HTTP clients, and then<br>
processes the original request by locating the required information, resetting the response code, and sending the information to the HTTP client using the servlet response handler.<br>
2.	The system as claimed in claim 1 wherein the subsequent response is triggered by a response command from the HTTP client to send additional response data.<br>
3.	The system as claimed in claim I wherein the system comprises an extension to the HTTP interface that allows a sex-vice method to return, and the thread handling that service method to be released before the response is ready to be sent.<br>
4.	The system as claimed in claim I comprising a Java Messaging Service (JMS), wherein the servlet builds a portion of a response, queues a JMS message requesting the data, and creates a response object as the response code, which is later retrieved when another JMS message containing the requested data arrives.<br>
9n<br><br>
The system as claimed in claim 1 wherein the system sets a period of time for which to send the subsequent response, after which period of time the servlet sends a send signal to the response handler, which then signals the servlet container to send the subsequent response to the client.<br>
6.	The system as claimed in claim I wherein the system is used to provide information within a search function to a user of a web page, and wherein the system provides partial items of information to the user's screen, while other items of information are returned as subsequent responses to the user's screen as the servlet finds the appropriate data.<br>
7.	A system for messaging and/or communicating service requests between an HTTP client and a server, wherein the server includes a servlet container and servlets, a method of providing asynchronous threading which allows a service method to return and the thread to be freed up, before the response is ready to be sent to the client the method comprising the steps of:<br>
receiving at a server that comprises a servlet container process, a servlet process, a servlet response handler process and an HTTP software interface executing thereon, a request from an HTTP client to access the servlet within the servlet container; and immediately<br>
setting a response code to be used with a subsequent response, releasing the servlet response handler to interleave the processing of subsequent requests from the HTTP client or from other HTTP clients,<br>
processing the original request by locating the required information, resetting the response code, and sending the information to the HTTP client using the servlet response handler.<br>
8.	The method as claimed in claim 7 wherein the subsequent response is triggered by a response command from the HTTP client to send additional response data.<br>
9.	The method as claimed in claim 7 wherein the system comprises an extension to the HTTP interface that allows a service method to return, arid the thread handling that service method to be released before the response is ready to be sent.<br><br>
10.	The method as claimed in claim 7 comprising a Java Messaging Service (JMS), wherein the servlet builds a portion of a response, queues a JMS message requesting the data, and creates a response object as the response code, which is later retrieved when another JMS message containing the requested data arrives.<br>
11.	The method as claimed in claim 7 wherein the system sets a period of time for which to send the subsequent response, after which period of time the servlet sends a send signal to the response handler, which then signal the servlet container to send the subsequent response to the client,<br>
12.	The method as claimed in claim 7 wherein the system is used to provide information within a search function to a user of a web page, and wherein the system provides partial items of information to the users screen, while other items of information are returned as subsequent responses to the user's screen as the servlet finds the appropriate data.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDk1NC1jaGVucC0yMDA0IGFic3RyYWN0LWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">0954-chenp-2004 abstract-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDk1NC1jaGVucC0yMDA0IGNsYWltcy1kdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">0954-chenp-2004 claims-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDk1NC1jaGVucC0yMDA0IGRlc2NyaXB0aW9uIChjb21wbGV0ZSktZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">0954-chenp-2004 description (complete)-duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDk1NC1jaGVucC0yMDA0IGRyYXdpbmdzLWR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">0954-chenp-2004 drawings-duplicate.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="228998-3-substituted-4-pyrimidone-compound.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="229000-method-for-information-content-distribution-based-on-privacy-and-personal-information.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>228999</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>954/CHENP/2004</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>12/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>20-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>13-Feb-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>05-May-2004</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>BEA SYSTEMS, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2315 NORTH FIRST STREET, SAN JOSE, CALLIFORNIA 95131,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>MESSINGER, ADAM</td>
											<td>317 29TH STREET-APT. 306, SAN FRANCISCO, CALIFORNIA 94131,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>PULLARA, SAM</td>
											<td>2030 3RD STREET, #14 SAN FRANCISO, CA 94107,</td>
										</tr>
										<tr>
											<td>3</td>
											<td>BROWN, DAVE</td>
											<td>1441 MONTGOMERY STREET, APARTMENT 3, SAN FRANCISCO, CA 94133,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>GO6F 15/16</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US02/31727</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-10-04</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/264,973</td>
									<td>2002-10-03</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/327,530</td>
									<td>2001-10-05</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/228999-system-and-method-for-messaging-and-communicating-service-requests-between-http-client-and-server by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:38:51 GMT -->
</html>
