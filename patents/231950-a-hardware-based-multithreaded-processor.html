<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/231950-a-hardware-based-multithreaded-processor by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:52:57 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 231950:&quot;A HARDWARE-BASED MULTITHREADED PROCESSOR&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;A HARDWARE-BASED MULTITHREADED PROCESSOR&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A processor such as a multithreaded hardware based processor (12) is described. The pocessor (12) includes a computer instruction (20) that is a branch instruction that causes a branch in execution of an instruction stream based on any specified value being true or false. The instruction also includes a token that specifies the number of instruction of instructions foUowing the branch instruction to execute before performing the branch operation.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>The present invention relates to a method of operating a hardware-based multithreaded<br>
processor.<br>
Parallel processing is an efficient form of information processing of concurrent events in a computing process. Parallel processing demands concurrent execution of many programs in a computer. Sequential processing or serial processing has all tasks performed sequentially at a single station whereas, pipelined processing has tasks performed at specialized stationsj Computer code whether executed in parallel processing, pipelined or sequential processing machines involves branches in which an instruction stream may execute in a sequence and branch from the sequence to a different sequence of instructions.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
FIG. 1 is a block diagram of a communication system employing a processor.<br>
FIG. 2 is a detailed block diagram of the.<br>
FIG. 3 is a block diagram of a microengine used in the processor of FIGS. 1 and 2.<br>
FIG. 4 is a block diagram of a pipeline in the microengine of FIG. 3.<br>
FIGS. 5A-5C show exemplary formats for branch instructions.<br>
FIG. 6 is a block diagram of general purpose registers.<br>
DESCRIPTION<br>
Referring to FIG. 1, a communication system 10 includes a processor 12. In one embodiment, the processor is a hardware-based multithreaded processor 12. The processor 12 is coupled to a bus such as a PCI bus 14, a memory system 16 and a second bus 18. The system 10 is especially useful for tasks that can be broken into parallel sub-tasks or functions. Specifically hardware-based multithreaded processor 12 is useful for tasks that are bandwidth oriented rather than latency oriented. The hardware-based multithreaded processor 12 has multiple microengines 22 each with multiple hardware controlled threads that can be simultaneously active and independently work on a task.<br>
The hardware-based multithreaded processor 12 also includes a central controller 20 that assists in loading microcode control for other resources of the hardware-based multithreaded processor 12 and performs other general purpose computer type functions such as handling protocols, exceptions, extra support for packet processing where the microengines pass the packets off for more detailed processing such as in boundary conditions.   In one embodiment, the processor 20 is a Strong Arm® (Arm is a trademark of ARM Limited, United Kingdom) based architecture. The general purpose microprocessor 20 has an operating system. Through the operating system the processor 20 can call functions to operate on microengines 22a-22f. The processor 20 can use any supported operating system preferably a real time operating system. For the core processor implemented as a Strong Arm architecture, operating systems such as, MicrosoftNT® real-time, VXWorks and DCUS, a freeware operating system available over the Internet, can be used.<br>
The hardware-based multithreaded processor 12 also includes a plurality of function microengines 22a-22f. Functional microengines (microengines) 22a-22f each maintain a plurality of program counters in hardware and states associated with the program counters. Effectively, a corresponding plurality of sets of threads can be simultaneously active on each of the microengines 22a-22f while only one is actually operating at any one time.<br>
Microengines 22a-22f each have capabilities for processing four hardware threads. The microengines 22a-22f operate with shared resources including memory system 16 and bus interfaces 24 and 28. The memory system 16 includes a Synchronous Dynamic Random Access Memory (SDRAM) controller 26a and a Static Random Access Memory (SRAM) controller 26b. SDRAM memory 16a and SDRAM controller 26a are typically used for processing large volumes of data, e.g., processing of network pay loads from network packets. The SRAM controller 26b and SRAM memory 16b are used in, e.g., networking packet processing, postscript processor, or as a processor for a storage subsystem, i.e., RAID disk storage, or for low latency, fast access tasks, e.g., accessing look-up tables, memory for the core processor 20, and so forth.<br>
The processor 12 includes a bus interface 28 that couples the processor to the second bus 18. Bus interface 28 in one embodiment couples the processor 12 to the so-called FBUS 18 (FIFO bus). The processor 12 includes a second interface e.g., a PCI bus interface 24 that couples other system components that reside on the PCI 14 bus to<br>
the processor 12. The PCI bus interface 24, provides a high speed data path 24a to the SDRAM memory 16a. Through that path data can be moved quickly from the SDRAM 16a through the PCI bus 14, via direct memory access (DMA) transfers.<br>
Each of the functional units are coupled to one or more internal buses. The internal buses are dual, 32 bit buses (i.e., one bus for read and one for write). The hardware-based multithreaded processor 12 also is constructed such that the sum of the bandwidths of the internal buses in the processor 12 exceed the bandwidth of external buses coupled to the processor 12. The processor 12 includes an internal core processor bus 32, e.jg., an ASB bus (Advanced System Bus) that couples the processor core 20 to the memory controller 26a, 26c and to an ASB translator 30 described below. The ASB bus is a subset of the so called AMBA bus that is used with the Strong Arm processor core. The processor 12 also includes a private bus 34 that couples the niicroengine units to SRAM controller 26b, ASB translator 30 and FBUS interface 28. A memory bus 38 couples the memory controller 26a, 26b to the bus interfaces 24 and 28 and memory system 16 including flashrom 16c used for boot operations and so forth.<br>
Referring to FIG. 2, each of the microengines 22a-22f includes an arbiter that examines flags to determine the available threads to be operated upon. Any thread from any of the microengines 22a-22f can access the SDRAM controller 26a, SDRAM controller 26b or FBUS interface 28. The memory controllers 26a and 26b each include a plurality of queues to store outstanding memory reference requests. The FBUS interface 28 supports Transmit and Receive flags for each port that a MAC device supports, along with an Interrupt flag indicating when service is warranted. The FBUS interface 28 also includes a controller 28a that performs header processing of incoming packets from the FBUS 18. The controller 28a extracts the packet headers and performs a microprogrammable source/destination/protocol hashed lookup (used for address smoothing) in SRAM.<br>
The core processor 20 accesses the shared resources. The core processor 20 has a direct communication to the SDRAM controller 26a to the bus interface 24 and to SRAM controller 26b via bus 32. However, to access the microengines 22a-22f and transfer registers located at any of the microengines 22a-22f, the core processor 20 access the microengines 22a-22f via the ASB Translator 30 over bus 34. The ASB translator 30 can physically reside in the FBUS interface 28, but logically is distinct. The ASB Translator 30 performs an address translation between FBUS microengine transfer<br>
register locations and core processor addresses (i.e., ASB bus) so that the core processor 20 can access registers belonging to the microengines 22a-22c.<br>
Although microengines 22 can use the register set to exchange data as described below, a scratchpad memory 27 is also provided to permit microengines to write data out to the memory for other microengines to read. The scratchpad 27 is coupled to bus 34.<br>
The processor core 20 includes a RISC core 50 implemented in a five stage pipeline performing a single cycle shift of one operand or two operands in a single cycle, provides multiplication support and 32 bit barrel shift support. This RISC core 50 is a standard Strong Arm® architecture but it is implemented with a five stage pipeline for performance reasons. The processor core 20 also includes a 16 kilobyte instruction cache 52, an 8 kilobyte data cache 54 and a prefetch stream buffer 56. The core processor 20 performs arithmetic operations in parallel with memory writes and instruction fetches. The core processor 20 interfaces with other functional units via the ARM defined ASB bus. The ASB bus is a 32-bit bi-directional bus 32.<br>
Referring to FIG. 3, an exemplary microengine 22f includes a control store 70 that includes a RAM which stores a microprogram. The microprogram is loadable by the core processor 20. The microengine 22f also includes controller logic 72. The controller logic includes an instruction decoder 73 and program counter (PC) units 72a-72d. The four micro program counters 72a-72d are maintained in hardware. The microengine 22f also includes context event switching logic 74. Context event logic 74 receives messages (e.g., SEQ_#_EVENT_RESPONSE; FBIJEVENT_RESPONSE; SRAM_EVENT_RESPONSE; SDRAM _EVENT_RESPONSE; and ASB _EVENT_RESPONSE) from each one of the shared resources, e.g., SRAM 26a, SDRAM 26b, or processor core 20, control and status registers, and so forth. These messages provide information on whether a requested function has completed. Based on whether or not a function requested by a thread has completed and signaled completion, the thread needs to wait for that completion signal, and if the thread is enabled to operate, then the thread is placed on an available thread list (not shown). The microengine 22f can have a maximum of e.g., 4 threads available.<br>
In addition to event signals that are local to an executing thread, the microengines 22 employ signaling states that are global. With signaling states, an executing thread can broadcast a signal state to all microengines 22. Receive Request<br><br>
Available signal, Any and all threads in the microengines can branch on these signaling states. These signaling states can be used to determine availability of a resource or whether a resource is due for servicing.<br>
The context event logic 74 has arbitration for the four (4) threads. In one embodiment, the arbitration is a round robin mechanism. Other techniques could be used including priority queuing or weighted fair queuing. The microengine 22f also includes an execution box (EBOX) data path 76 that includes an arithmetic logic unit 76a and general purpose register set 76b. The arithmetic logic unit 76a performs arithmetic and logical functions as well as shift functions. The arithmetic logic unit includes condition code bits that are used by instructions described below. The registers set 76b has a relatively large number of general purpose registers that are windowed as will be described so that they are relatively and absolutely addressable.      The microengine 22f also includes a write transfer register stack 78 and a read transfer stack 80. These registers are also windowed so that they are relatively and absolutely addressable. Write transfer register stack 78 is where write data to a resource is located. Similarly, read register stack 80 is for return data from a shared resource. Subsequent to or concurrent with data arrival, an event signal from the respective shared resource e.g., the SRAM controller 26a, SDRAM controller 26b or core processor 20 will be provided to context event arbiter 74 which will then alert the thread that the data is available or has been sent. Both transfer register banks 78 and 80 are connected to the execution box (EBOX) 76 through a data path.<br>
Referring to FIG. 4, the microengine datapath maintains a 5-stage micro-pipeline 82. This pipeline includes lookup of microinstructioruKords 82a, formation of the register file addresses 82b, read of operands from register file 82c, ALU, shift or compare operations 82d, and write-back of results to registers 82e. By providing a write-back data bypass into the ALU/shifter units, and by assuming the registers are implemented as a register file (rather than a RAM), the microengine can perform a simultaneous register file read and write, which completely hides the write operation.<br>
The instruction set supported in the microengines 22a-22f support conditional branches. The worst case conditional branch latency (not including jumps) occurs when the branch decision is a result of condition codes being set by the previous microcontrol instruction. The latency is shown below in Table 1:<br>
TABLE 1<br>
(Table Removed)<br>
where nx is pre-branch microword (nl sets cc's) cb is conditional branch bx is post-branch microword XX is aborted microword<br>
As shown in Table 1, it is not until cycle 4 that the condition codes of nl are set, and the branch decision can be made (which in this case causes the branch path to be looked up in cycle 5). The microengme 22f incurs a 2-cycle branch latency penalty r because it must abort operations n2 and n3 (the 2 microwords directly after the branch) in the pipe, before the branch path begins to fill the pipe with operation bl. If the branch is not taken, no microwords are aborted and execution continues normally. The microengines have several mechanisms to reduce or eliminate the effective branch latency.<br>
The microengines support selectable deferred branches. Selectable 4eferring branches are when a microengine allows 1 or 2 rnicip instructions after the branch to execute before the branch takes effect (i.e. the effect of the branch is "deferred" in time). Thus, if useful work can be found to fill the wasted cycles after the branch microword, then the branch latency can be bidden. A 1-cycle deferred branch is shown below in Table 2 where n2 is allowed to execute after cb, but before bl:<br>
TABLE 2<br>
(Table Removed)<br>
A 2-cycle deferred branch is shown in TABLE 3 where n2 and n3 are both allowed to complete before the branch to bl occurs. Note that a 2-cycle branch deferment is only allowed when the condition codes are set on the microword preceding the branch.<br>
TABLE 3<br>
(Table Removed)<br>
The microengines also support condition code evaluation.   If the condition codes upon which a branch decision are made are set 2 or more microwords before the branch, then 1 cycle of branch latency can be eliminated because the branch decision can be made 1 cycle earlier as in Table 4.<br>
TABLE 4<br>
(Table Removed)<br>
example, nl sets the condition codes and n2 does not set the conditions codes. Therefore, the branch decision can be made at cycle 4 (rather than 5), to eliminate 1 cycle of branch latency. In the example in Table 5 the 1-cycle branch deferment and early setting of condition codes are combined to completely hide the branch latency. That is, the condition codes (cc's) are set 2 cycles before a 1-cycle deferred branch.<br>
TABLES<br>
(Table Removed)<br>
In the case where the condition codes cannot be set early (i.e. they are set iri the microword preceding the branch), the microengine supports branch guessing which attempts to reduce the 1 cycle of exposed branch latency that remains. By "guessing" the branch path or the sequential path, the microsequencer pre-fetches the guessed path 1 cycle before it definitely knows what path to execute. If it guessed correctly, 1 cycle of branch latency is eliminated as shown in Table 6.<br>
TABLE 6<br>
guess branch taken /branch is taken<br>
(Table Removed)<br>
If the microcode guessed a branch taken incorrectly, the microengine still only wastes 1 cycle as in TABLE 7<br>
TABLE?<br>
guess branch taken /branch is NOT taken<br>
(Table Removed)<br>
However, the latency penalty is distributed differently when microcode guesses a branch is not taken. For guess branch NOT taken / branch is NOT taken there are no wasted cycles as in Table 8.<br>
Table 8<br>
(Table Removed)<br>
However for guess branch NOT taken /branch is taken there are 2 wasted cycles as in Table 9.<br>
Table 9<br>
(Table Removed)<br>
The microengine can combine branch guessing with 1-cycle branch deferment to improve the result further. For guess branch taken with 1-cycle deferred branch/branch is taken is in Table 10.<br>
Table 10<br>
(Table Removed)<br>
In the case above, the 2 cycles of branch latency are hidden by the execution of n2, and by correctly guessing the branch direction.<br>
If microcode guesses incorrectly, 1 cycle of branch latency remains exposed as in Table 11 (guess branch taken with 1-cycle deferred branch/branch is NOT taken).<br>
Table 11<br>
(Table Removed)<br>
If microcode correctly guesses a branch NOT taken, then the pipeline flows sequentially in the normal unperturbed case. If microcode incorrectly guesses branch NOT taken, the microengine again exposes 1 cycle of unproductive execution as shown in Table 12.<br>
Table 12<br>
guess branch NOT taken/branch is taken<br>
(Table Removed)<br>
where nx is pre-branch microword (nl sets cc's) cb is conditional branch bx is post-branch microword XX is aborted microword<br>
In the case of a jump instruction, 3 extra cycles of latency are incurred because the branch address is not known until the end of the cycle in which the jump is in the ALU stage (Table 13).<br>
Table 13<br>
(Table Removed)<br>
Conditional branches that operate on ALU condition codes which are set on the microword before the branch can select 0, 1 or 2 or 3 cycle branch deferment modes. Condition codes set 2 or more microwords before the conditional branch that operates on them can select 0 or 1-cycle branch deferment modes. All other branches<br>
 (including context rearbitrations) can select either 0 or 1-cycle branch deferment modes. The architecture could be designed to make a context arbitration microword within a branch deferment window of a preceding branch, jump or context arbitration microword, an illegal option. That is, ill some embodiments, a context switch would not be allowed to occur during a branch transition in the pipeline because it could unduly complicate saving of the old context PC. The architecture could also be designed to make branching within the branch deferment window of a preceding branch, jump or context arbitration microword illegal to avoid complicated and possible unpredictable branch behaviors.<br>
Referring to FIG. 5 A, general formats for branch instructions are shown. Branch Instructions BR BR<o br="0" brx>=0<br>
One set of branch instructions are branch unconditionally BR or branch to an instruction at a specified label based on an ALU condition code. Exemplary ALU condition codes are Sign, Zero, and Carryout (cout). Formats: br[label#], optional_token br=0[label#], optional token br!=0[label#], optional_token br&gt;0[label#], optionaljoken br&gt;=0[label#], optional_token br
The parameterjabel# is a symbolic label corresponding to the address of an instruction. This class ofvbranch instructions can have the following optional tokens; defer one instruction, defer two instructions, and defer three instructions. These optional tokens cause the processor to execute one, two, or three instructions following this instruction before performing the branch operation. The ALU operation that sets the condition codes may occur several instructions before the branch instruction. The defer two and defer three are not used with branch guess as described below<br>
A fourth optional token is the guess branch token which causes the processor to prefetch the instruction for the "branch taken" condition rather than the next<br>
sequential instruction. The ALU operation that sets the condition codes occurs immediately before the branch instruction.<br>
; BR_BSET<br>
A second set of branch instructions is the branch to a specific label when a specified bit is set or cleared. These instructions set condition codes in the processor status register. The instruction formats are br_bclr[reg, bit_position, Iabel#j, optional_token; br_bset[reg, bit_position, label#], optional_token<br>
The operand field Reg A is a context-relative transfer register or general-purpose register that holds the operand. Bit_position A is a number specifying a bit position in a longword. Bit 0 is the least significant bit. Valid bitjposition values are 0 through 3 1 . Label# is the symbolic label corresponding to the address of a target instruction.<br>
This set of branch instructions also has the optional_tokens; defer one instruction, defer two instructions, and defer three instructions branch guess, as described above. Example: br_bclr[reg, bit_position, label#], defer [1] Branch if bit is clear.<br>
BR=BYTE; BR!=BYTE<br>
A third set of branch instructions are instructions that cause the processor to branch to the instruction at a specified label if a specified byte in a longword matches or mismatches a byte_compare_value. The br=byte instruction prefetches the instruction for the "branch taken" condition rather than the next sequential instruction. The brNbyte instruction prefetches the next sequential instruction. These instructions set the condition codes. Format br=byte[reg, byte_spec, byte_compare_value, label#], optional_token<br>
br!=byte[reg, byte_spec, byte_compare_value, label#J, optional_token Reg A is the context-relative transfer register or general-purpose register that holds the operand. Byte_spec Number is a number specifying a byte in register to be compared with byte_compare_ value. Valid byte_spec values are 0 through 3. A value of 0 refers to the rightmost byte. Byte_compare_value is a parameter used for comparison.<br>
In this implementation, valid byte_compare_yalues are 0 to 255. Label# is the symbolic label corresponding to the address of an instruction.<br>
This set of branch instructions also has the optional_tokens; defer one instruction, defer two instructions, defer three instructions, and branch guess. Also deter two and three are only used with the BR!=BYTE. Example: br!=byte[reg, byte_spec, byte_compare_value, label #], defer[3]<br>
This microword instruction provides a technique for comparing an aligned byte of a register operand to an immediate specified byte value, where byte_spec represents the aligned byte to compare (0 is right-most byte, 3 is leftmost byte). The ALU condition codes are set by subtracting the specified byte value from the specified register byte. If the values match, the specified branch is taken. There is a 3 cycle branch latency associated with this instruction therefore, branch deferments of 0,1, 2 or 3 are allowed in order to fill the latency with useful work. The register can be an A or B bank register. CTX_ARB<br>
Referring to FIG. 5B, the context swap instruction CTX_ARB swaps a currently running context in a specified microengine out to memory to let another context execute in that microengine. The context swap instruction CTX_ARB also wakes up the swapped out context when a specified signal is activated. The format for the context swap instruction is:<br>
ctx_arb[parameter], optional_token<br>
The "parameter" field can have one of several values. If the parameter is specified as "sram Swap", the context swap instruction will swap out the current context and wake it up when the thread's SRAM signal is received. If the parameter is specified as "sram Swap", the context swap instruction will swap out the current context and wake it up when the thread's SDRAM signal is received. The parameter can also be specified as "FBI" and swap out the current context and wake it up when the thread's FBI signal is received. The FBI signal indicates that an FBI CSR, Scratchpad, TFIFO, or RFIFO operation has completed.<br>
The parameter can also be specified as<br>
"seq_numl_change/seq_num2_change", which swaps out the current context and wakes it up when the value of the sequence number changes. The parameter can be specified as "inter_thread" which swaps out the current context and wakes it up when the threads<br>
interthread signal is received, or "voluntary" which will swap out the current context if another thread is ready to run, otherwise do not swap. If the thread is swapped, it is automatically re-enabled to run at some subsequent context arbitration point. The parameter can be "auto_push" which swaps out the current context and wakes it up when SRAM transfer read register data has been automatically pushed by the FBus interface, or a "startjreceive" that swaps out the current context and wake it up when new packet data in the receive FIFO is available for this thread to process.<br>
The parameter can also be "kill" which prevents the current context or thread from executing again until the appropriate enable bit for the thread is set in a CTX_ENABLES register, "pci" which swaps out the current context and wake it up when the PCI unit signals that a DMA transfer has been completed.<br>
The context swap instruction CTX_ARB can have the following optional_token, defer one which specifies that one instruction will be executed after this reference before the context is swapped. BR=CTX, BR!=CTX<br>
Referring to FIG. 5C, context branch instructions BR=CTX, BR!=CTX are shown. The context branch instruction causes a processor, e.g., microengine 22f to branch to an instruction at a specified label based on whether or not the current executing context is the specified context number.  As shown in FIG. 5C, the context branch instruction is determined from the branch mask fields when equal to "8" or "9." The context branch instruction can have the following format: Format: br=ctx[ctx, label#], optional_token br!=ctx[ctx, label#], optional_ token<br>
Label# is a symbolic label corresponding to the address of an instruction. Ctx Context number is the number of a context (thread). In this example, valid ctx values areO, 1,2, or 3.<br>
This instruction has an optional token "defer one" instruction which causes the processor to execute the instruction following this instruction before performing the branch operation. BR_INP_STATE<br>
Referring back to FIG. 5 A, another class of branch instructions causes the processor to branch if the state of a specified state name is set to 1. A state is set to 1 or 0 by a microengine in the processor and indicates the currently processing state. It is<br>
available to all microengines. A format as shown in FIG. 5 uses br_mask field is used to<br>
specify	branch. For branch mask = 15, the extended field is used to specify the<br>
various signal and state signals as listed below. Format: br_inp_state[state_name, label#], optional_token<br>
Label# is a symbolic label corresponding to the address of an instruction. State_name is the state name, if rec_req_avail when set, it indicates that the RCV_REQ FIFO has room available for another receive request. If push_protect, when set, it indicates that the FBI unit is currently writing to the SRAM transfer registers. This instruction can also have an optional_token "defer one" which executes the instruction following this instruction before performing the branch operation.<br>
BRJ.SIGNAL<br>
Another class of branch instruction causes the processor to branch if a specified signal is deasserted. If the signal is asserted, the instruction clears the signal and does not take the branch. The SRAM and SDRAM signals are presented to the microengine two cycles after the last Long word is written to the transfer register. The second from last Long word is written 1 cycle after the signal. All other Long words are valid when the signal is submitted. With this instruction, the programmer times the reading of transfer registers appropriately to ensure that the proper data is read. Format: br_signal[signal_name, label#], optional_token<br>
Label# is a symbolic label corresponding to the address of an instruction. Signal_name can be sram, sdram, fbi, pci, inter_thread, auto_push start_receive, seq_numl, seq_num2.<br>
This set of branch instructions has the following optional_tokens defer one instruction, defer two instructions, and defer three instructions. These optional tokens cause the processor to execute one, two, or three instructions following this instruction before performing the branch operation. The ALU operation that sets the condition codes may occur several instructions before the branch instruction. The defer two and defer three are not used with branch guess.<br>
A fourth optional token is the guess branch Prefetch. The guess branch prefetch token prefetches the instruction for the "branch taken" condition rather than the next sequential instruction. This token is used with defer one instruction to improve performance.<br>
Example: .xfer_order SxferO Sxferl Sxfer2 $xfer3 sramfread, SxferO, opl, 0, 2], sig_done wait#:<br>
br_!signal[sram, wait#], guess_branch nop;delay 1 cycle before reading SxferO alu[gpr0,0,b,$xfer0];valid data is written to gprO alu[gprl,0,b,$xferl];valid data is written to gprO selfB: brfselff].<br>
Referring to FIG. 6, the two register address spaces that exist are Locally accessibly registers, and Globally accessible registers accessible by all microengines. The General Purpose Registers (GPRs) are implemented as two separate banks (A bank and B bank) whose addresses are interleaved on a word-by-word basis such that A bank registers have lsb=0, and B bank registers have lsb-1. Each bank is capable of performing a simultaneous read and write to two different words within its bank.<br>
Across banks A and B, the register set 76b is also organized into four windows 76bo-76ba of 32 registers that are relatively addressable per thread. Thus, thread_0 will find its register 0 at 77a (register 0), the thread_l will find its register_0 at 77b (register 32), thread_2 will find its register_0 at 77c (register 64), and thread_3 at 77d (register 96). Relative addressing is supported so that multiple threads can use the exact same control store and locations but access different windows of register and perform different functions. The use of register window addressing and bank addressing provide the requisite read bandwidth while using only dual ported RAMS in the microengine 22f.<br>
These windowed registers do not have to save data from context switch to context switch so that the normal push and pop of a context swap file or stack is eliminated. Context switching here has a 0 cycle overhead for changing from one context to another. Relative register addressing divides the register banks into windows across the address width of the general purpose register set. Relative addressing allows access any of the windows relative to the starting point of the window. Absolute addressing is also supported in this architecture where any one of the absolute registers may be accessed by any of the threads by providing the exact address of the register.<br>
Addressing of general purpose registers 78 can occur in 2 modes depending on the microword format. The two modes are absolute and relative. In<br>
absolute mode, addressing of a register address is directly specified in 7-bit source field (a6-aO or b6-bO), as shown in Table 14:<br>
Table 14<br>
(Table Removed)<br>
register address directly specified in 8-bit dest field (d7-dO) Table 15:<br>
Table 15<br>
(Table Removed)<br>
then the lower bits are interpreted as a context-relative address field (described below). When a non-relative A or B source address is specified in the A, B absolute field, only the lower half of the SRAM/ASB and SDRAM address spaces can be addressed.   Effectively, reading absolute SRAM/SDRAM devices has the effective address space; however, since this restriction does not apply to the dest field, writing the SRAM/SDRAM still uses the full address space.<br>
In relative mode, addresses a specified address is offset within context space as defined by a 5-bit source field    (a4-aO or b4-bO)Table 16:<br>
Table 16<br>
(Table Removed)<br>
or as defined by the 6-bit dest field (d5-dO) Table 17:<br>
Table 17<br>
(Table Removed)<br>
 then the destination address does not address a valid register, thus, no dest operand is written back.<br>
Other embodiments are within the scope of the following claims. What is claimed is:<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
We Claim<br>
1.	A hardware-based multithreaded processor (12) comprising:<br>
a plurality of micro engines (22), each of the micro engines comprising:<br>
a control store;<br>
a controller logic;<br>
context event switching logic;  and<br>
an execution box data path including an arithmetic logic unit (ALU) and a general purpose register set, the ALU configure in response to instructions, one of the instructions causing the ALU:<br>
to branch in execution of an instruction stream based on a specified value being true or false and including an optional token that specifies the number of instructions to execute in the instruction stream following the one of the instructions before performing the branch operation.<br>
2.	The processor as claimed in claim 1, wherein in the said processor<br>
the one of the instructions further causing the ALU to branch based on a<br>
second token that specifies a branch guess operation.<br>
3.	The processor as claimed in claim 1 wherein   the optional token<br>
includes defer-i which causes the processor to execute the ith instruction<br>
following the one of the instruction causing the ALU to branch before<br>
performing the branch operation.<br>
4.	The processor as claimed in claim 1 wherein   the optional token<br>
can  specify,  one,  two  or three  instructions  following the  one  of the<br>
instructions before performing the branch operation,<br>
5.	The processor as claimed in claim 1 wherein the optional token is<br>
specified by a programmer or assembler program to enable variable cycle<br>
deferred branching.<br>
6.	The processor as claimed in claim 1 wherein the optional token is<br>
specified to assist an assembler program to produce more efficient code.<br>
7.	The processor as claimed in  claim   1  wherein the one  of the<br>
instructions is a branch unconditionally or branch to an instruction at a<br>
specified label based on an ALU condition code.<br>
8.	The processor as claimed in claim  1 wherein the one of the<br>
instructions is a branch to a specific label when a specified bit is set or<br>
cleared.<br>
9.	The processor as claimed in claim 1 wherein in the processor said<br>
one of the instructions is a branch instruction that causes the processor<br>
to branch to the instruction at a specified label if a specified byte in a<br>
longword matches or mismatches a byte_compare_value.<br>
10.	The  processor  as  claimed  in  claim  I  wherein  the  one  of the<br>
instructions is a branch instruction that causes the processor to branch<br>
to the instruction at a specified label based on whether or not a current<br>
context is a specified context in the branch instruction.<br>
11.	The  processor  as   claimed  in   claim   1   wherein  the   one   of the<br>
instructions is a branch instruction that causes the processor to branch<br>
if the state of a specified state name is a selected value.<br>
12.	The  processor as  claimed  in  claim   1  wherein  the  one  of the<br>
instructions is a branch instruction that causes the processor to branch<br>
if a specified signal is deasserted.<br>
13.	The processor as claimed in claim  1  wherein the one of the<br>
instructions further includes an additional token, a guess branch token<br>
which causes the processor to prefetch the instruction for the "branch<br>
taken" condition rather than the next sequential instruction.<br></o></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QuanBn" target="_blank" style="word-wrap:break-word;">abstract.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWNvbXBsZXRlIHNwZWNpZmljYXRpb24gKGdyYW50ZWQpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-complete specification (granted).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWNvcnJlc3BvbmRlbmNlLXBvLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWZvcm0tMTkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWZvcm0tNC5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-form-4.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLWdwYS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLXBjdC0xMDEucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-pct-101.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLXBjdC0yMTAucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-pct-210.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLXBjdC0zMDQucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-pct-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLXBjdC00MDEucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-pct-401.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLXBjdC00MDkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-pct-409.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLXBjdC00MTYucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-pct-416.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLXBldGl0aW9uLTEzNy5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-petition-137.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDAyNjUtZGVsLXBldGl0aW9uLTEzOC5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-00265-del-petition-138.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="231949-method-of-recovering-of-elemental-phosphorus-from-phosphorus-sludge.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="231951-continuous-inkjet-printer.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>231950</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2002/00265/DEL</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>27-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>13-Mar-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>01-Mar-2002</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTEL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2200 MISSION COLLEGE BOULEVARD, SANTA CLARA, CALIFORNIA 95052, U.S.A.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>MATTHEW J. ADILETTA</td>
											<td>20 MONTICELLO DRIVE, WORCESTER, MA 01603, USA.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>WILLIAM WHEELER,</td>
											<td>745 SCHOOL STREET, WEBSTER, MA 01570, USA.</td>
										</tr>
										<tr>
											<td>3</td>
											<td>DEBRA BERNSTEIN,</td>
											<td>38 HELEN STREET, WALTHAM, MA 02452, USA.</td>
										</tr>
										<tr>
											<td>4</td>
											<td>DONALD HOOPER</td>
											<td>19 MAIN CIRCLE, SHREWSBURY, MA 01545, USA.</td>
										</tr>
										<tr>
											<td>5</td>
											<td>GILBERT WOLRICH</td>
											<td>4 CIDER MILL ROAD, FRAMINGHAM, MA 01701, USA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 9/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US00/24006</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-08-31</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/151961</td>
									<td>1999-09-01</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/231950-a-hardware-based-multithreaded-processor by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:52:58 GMT -->
</html>
