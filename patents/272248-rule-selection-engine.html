<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/272248-rule-selection-engine by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 22:40:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 272248:RULE SELECTION ENGINE</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">RULE SELECTION ENGINE</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Abstract A rules-based system makes use of a specification that is similar to those used in earlier systems, such as on OPS5, but does not require the computational complexity of implementations such as Rete. In some such implementations, matching of the applicable rules given a set of facts is simplified by providing preallocated storage locations for the Boolean values of the condition elements for each rule. The Boolean values are set by direct processing of each of the facts. These preallocated storage locations are arranged to allow efficient evaluation of the overall condition of each of the rules in a manner that is significantly more efficient than implementations of earlier rule-based systems.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br>
<br>
RULE SELECTION ENGINE Background<br>
[01]	This invention relates to rules-based software systems.<br>
[02]	One approach to the design of artificial intelligence systems has been to<br>
use a rules-based approach.  In rules-based systems, a set of rules (or "productions") defines the behavior of the system. Rules are selected based on specifications of the rules and the state of information that is known to the system about a particular problem. Selected rules are applied. Application of the rules in general changes the state of information, thereby potentially allowing further rules to be selected. Generally, rules-based systems in which information is repeatedly added to the state of information, thereby allowing further rules to be applied until a desired result is achieved or until there are no remaining applicable rules, are referred to as "forward-chaining" rules-based systems.<br>
[03]	One well-known rules-based system is the OPS5 system, which was<br>
developed at Carnegie Mellon University in the early 19805s and later commercialized by a number of companies. In OPS5, the state of information is represented as a set of facts (or "working memory elements," "WMEs"). Facts belong to identified classes, and each fact (an instance of a class) assigns values to a number (zero or more) attributes for that class. In general, a fact takes the form "(identifier Aattributel valuel Aattribute2 value2 ...)" where "identifier" is the name of a class, and "attributel, ccattribute2", etc. are names of attributes for that class. An example of a fact could be "(person Aheight 6.0 Aweight 210)" for a person (an instance of a class named person) whose height is 6.0 feet and weight is 210 pounds.<br>
[04]	Each rule (production) has the form "LHS condition -&gt; RHS action",<br>
where the left-hand-side (LHS) condition on the state of information under which the rule is applicable and the right-hand-side (RHS) action specifies the operations to perform when applying the rule. This condition is a Boolean expression that. combines a number of terms with logical operators. The logical operators are AND and ANDNOT, and each of the terms is referred to as a condition element. Each condition element is a logical function of the value or values of specified attributes for an identifier, for example, the attribute having a particular value or belonging to a specified set of values, not having a particular value, not belonging to a specified<br>
 <br>
set, etc. A condition element is represented as "(identifier Aattribute value)" if the identifier/attribute must have the specified value, and as "(identifier Attribute «valuel value2...»)M if the identifier/attribute must belong to the specified set of values. A condition element can be a logical function or a combination of multiple attributes. For example such a combination can be represented as "(person Aweight &gt; 200 Aheight 
[05]	An action of a rule can include one or more separate actions, each of<br>
which can modify the state of information, for example, by adding a fact with particular attributes, or by removing or modifying an existing fact. Execution proceeds in a loop where first one or more applicable rules are identified along with the facts that make them applicable, then one of these rules is selected, and then the action of that selected rule is performed.<br>
[06]	The task of identifying applicable rules and the facts that make them<br>
applicable can be quite computationally expensive. One particular algorithm that is used in many implementations of forward-chaining rules-based systems, such as OPS5, is the Rete algorithm, originally developed by C.L. Forgy. The Rete algorithm uses a data flow network to represent the conditions of the rules. The network has two parts, one part performs the tests required to evaluate the individual condition elements, and a second part combines the condition elements to form the overall conditions for the rules. The outputs of the first part (and the input to the second part) are a set of memories each associated with a different condition element for holding the set of facts that satisfy (or may satisfy for some values of the variables) that condition element. The second part includes storage elements associated with different combinations of condition elements, each identifying the possible corresponding combinations of facts that satisfy that combination of condition elements. Some of these storage elements are associated with overall conditions that particular rule must satisfy, and the presence of any combination of<br>
 <br>
facts in these storage elements indicate that the corresponding rules are applicable given those facts.<br>
Summary<br>
[07]	In a general aspect, the invention features a rules-based system that<br>
makes use of a specification that is similar to those used in earlier systems, such as in OPS5, but does not require the computational complexity of implementations such as Rete. Some implementations of the invention do not necessarily perform the same processing as earlier systems. For example, they may not require that a rule be repeatedly applied if the condition is satisfied for multiple different sets of facts, the action of each rule are independent of the facts that enabled the rule, and/or variables axe not used in the rule conditions. In some such implementations, matching of the applicable rules given a set of facts is simplified by providing preallocated storage locations for the Boolean values of the condition elements for each rule. The Boolean values are set by direct processing of each of the facts. These preallocated storage locations are arranged to allow efficient evaluation of the overall condition of each of the rules in a manner that is significantly more efficient than implementations of earlier rule-based systems such as Rete implementations of OPS5.<br>
[08]	In one aspect, in general, the invention features a method, and a related<br>
system and software for processing rules. A rules base that includes a set of rules is accepted by the system. Each rule includes a condition for application of the rule. The condition for a rule includes one or more condition element, and at least some of the conditions include multiple condition elements. The rule base is processed to form a data structure. The data structure includes, for each of the rules, storage locations for holding Boolean values of the condition elements of the conditions for that rule.<br>
[09]	Implementations of the invention can include one or more of the<br>
following features.<br>
[010]         A set of facts is processed by the system. This processing includes evaluating condition elements that depend on the facts, and storing results of evaluating the condition elements in the storage locations in the data structure for holding the values of the condition elements.<br>
 <br>
[Oil]         The data structure links each fact to corresponding condition elements that depend on that fact.<br>
[012] Processing the facts includes determining applicable rules based on the accepted facts by identifying condition elements that depend on the accepted facts using the data structure.<br>
[013]         The data structure includes, for each of the rules, data values corresponding to the storage locations for the values of the condition elements. These data values represent a logical combination of condition elements.<br>
[014]         Applicable ones of the rules are identified using the data values representing the logical combination of the condition elements and values stored in the storage locations for storing values of the condition elements.<br>
[015]         Implementations of the invention can have one or more of the following advantages.<br>
[016]         Representation of the values of condition elements in a compact data structure, such as a bit vector, can enable efficient evaluation of the conditions for rules making use of the condition element. Using a corresponding compact data structure to represent the logical combination for the condition elements can further increase efficiency in the evaluation.<br>
[017]         Compiling multiple rule bases into data structures that can be loaded into memory, for example, using stored memory images, enables efficient selection and/or switching of rule sets for processing different sets of facts.<br>
[018]         The storage requirements for the approach do not necessarily grow as more facts are processed.<br>
[019]         The links in the data structure provide an efficient mechanism for identifying applicable rules without requiring searching.<br>
[020]         Other features and advantages of the invention will be apparent from the following description, drawings, and claims.<br>
Description of Drawings<br>
[021]         FIG. 1 is a block diagram of a rules-based system. [022]         FIG. 2 is a data structure diagram.<br>
 <br>
[023]         FIG, 3 is a flowchart of overall operation of the system. [024]         FIG. 4 is a flowchart of processing of an added fact<br>
Description<br>
[025]         There are a great many possible implementations of the invention, too many to describe herein. Some possible implementations that are presently preferred are described below. It cannot be emphasized too strongly, however, that these are descriptions of implementations of the invention, and not descriptions of the invention, which is not limited to the detailed implementations described in this section but is described in broader terms in the claims.<br>
[026]         Referring to FIG. 1, a rules-based system 100 accepts one or more external facts 102 and produces results 104 based on processing of the facts according to .a rule base 115. The accepted facts 102 are maintained in a fact base 110, and rules base and fact base are processed by a rules processing engine 160. The rules base 115 includes a number of separate rules. Each of these rules specifies a condition that determines whether the rule is applicable based on the contents of the fact base 110. Each rule also specifies actions to take when the rule is applied. These actions can include modification of the fact base 110 and providing results 104 from the system 100.<br>
[027]         Prior to processing the external facts 102, the rules-based system 100 processes the rules base 115 using a rules compiler 120 to produce a compiled rules base 125. The compiled rules base includes a static data structure representing the rules in the rules base 115, as well as corresponding dynamic rules data 135 that includes storage locations for working data that is produced by the rules processing engine when it processes the external facts 102.<br>
[028]         As facts are added to the fact base, or as the fact base is modified based on the application of rules, rules may become applicable, and previously applicable rules may cease to be applicable. The rules processing engine 160 identifies applicable rules and performs the specified actions of those rules. To the extent that external facts 102 do not continue to be added to the system, the process in general terminates when all the applicable rules have been applied.<br>
[029]         Each fact 102 is represented by an identifier and one or more attribute-value pairs, which are denoted "(identifier "attribute! valuel Aattribute2 value2 ...),"<br>
 <br>
using a notation that is related to that used in the OPS 5 system. The combination of an identifier and an attribute is referred to as a "feature."<br>
[030]         Each rule in the rule base 115 is specified in a manner that is similar to that used in the OPS5 system, and includes a specification of a condition under which the rule is applicable. This condition is a Boolean expression that combines a number of terms with logical operators. The logical operators are AND and ANDNOT, and each of the terms is referred to as a condition element. Each condition element is a logical function (i.e., a function producing a Boolean value of TRUE or FALSE) of the value or values of specified attributes for an identifier, for example, the attribute having a particular value or belonging to a specified set of values, not having a particular value, not belonging to a specified set, etc. A condition element is represented as "(identifier Aattribute value)" if the identifier/attribute must have the specified value, and as "(identifier Attribute «valuel value2...»)"if the identifier/attribute must belong to the specified set of values. A condition element can be a logical function or a combination of multiple attributes. For example such a combination can be represented as "(person Aweight &gt; 200 Aheight 
[031]         The number of rules in the rule base 115 may be quite large, for example several hundred thousand in number. As introduced above, the rules processing engine 160 makes use of data structures in the compiled rules base 125 and the dynamic rules data 135 and procedures that access these data structures. These data structures enable efficiently searching for applicable rules.<br>
[032]         Referring to FIG. 2, the rules processing engine 160 uses the compiled rules base 125 and the dynamic rules data 135 to determine which rules are applicable given a particular fact. A rules table 250 includes one entry (row) 252 for each rule in the niles base 115. A condition element (CE) table 230 includes one entry for each condition element that is used in a condition of some rule. Note that in general the same condition element can be used in multiple rules, and a common condition element can be combined with an AND in one rule's condition and with an ANDNOT in another rule's condition. A feature table 220 includes one entry<br>
 <br>
222 for each unique attribute/identifier pair upon whose value at least some condition elements depend. A feature hash table 210 maps a hash of an identifier/attribute pair to an entry 222 (if any) in the feature table 220 for that identifier/attribute pair. Finally, a selection table 240 includes one entry 242 corresponding to each of the entries in the rules table 250. Note that as described below, given a particular rule base 115, the rules table 250, the CE table 230, and the feature table 220 do not necessarily depend on the contents of the fact base 110, while the selection table 240 depends on the contents of the fact base 110 according to the processing performed by the rules processing engine 160 based on the rule base.<br>
[033J         The data structure links features to condition elements that depend on values of these features using pointers that link the tables shown in FIG. 2. Each entry 122 of the feature table 120 includes a pointer 126 to the condition element entries 132 in the condition element table 130 for each condition element that depends on the value of the identifier/attribute value. Each condition element entry 132 of the condition element table 130 includes pointers 136 to storage locations 243 in the selection table 140 each of which is associated with a particular use of that condition element in a particular rule.<br>
[034]         The data structure includes bit vectors that are used to determine if a rule's condition is satisfied. Each rule entry 252 of the rules table 250 includes a bit vector 156 that includes one bit for each of the condition elements in the condition for that rule. That is, if there are four condition elements that make up the condition for the rule, there are four bits in the bit vector 256. Each bit 242 of the bit vector indicates whether the condition element associated with that bit position is combined with an AND or and ANDNOT operation, with a 1 signifying AND and a 0 signifying ANDNOT. Each entry of the selection table 240 also includes a bit vector where each bit position 243 corresponds to a bit position in the bit vector 256 for the corresponding rule entry 152. That is, the first bit 243 of the bit vector 242 corresponds to the first bit 257 of the bit vector 256. The bits of the selection table provide storage locations that are set by the rules processing engine 160 with a 0 initial value and 1 indicating that the condition element evaluates to TRUE based on a fact 102 received by the system. The rules processing engine determines which rules are applicable by combining the bit vector 256 in the rule entry 252 with the corresponding bit vector in the entry 242 of the selection table 240. Specifically, the rules processing engine determines whether the bits are all equal in the bit vector<br>
i<br>
 <br>
256 of a rule entry 252 to the bits in the selection bit vector 242 of the corresponding entry of the selection table 240.<br>
[035]         Referring to FIG. 3, prior to processing the external facts 102 that are presented to the system, the system processes the rules base 115 with the rules compiler 120 to produce the data structures for the rules table 250, the CE table 230, the feature table 220, and the feature hash table 210, and the associated pointers that link the tables, as well as the empty (i.e., initialized to 0) storage bit vectors 242 of the selection table 240 (step 310). These data structures can be stored for later use in processing new streams of facts. That is, the compilation of the rule base 115 can be performed significantly earlier than processing of the facts 102, and compilation of different rule sets can allow selection of the particular rule set to apply for each of a series of different sets of facts 102.<br>
[036]         Processing of a set of external facts 102 proceeds as follows (steps 330-360). Initially, an applicable rule list 290 is set to be empty. For each fact 102, that fact is added to the fact base 110, and the fact being processed by the rules processing engine 160 is stored in a storage element for the current fact 200. The engine determines whether to add or remove rules from the applicable rule list 290 according to the effect of the attribute values in the current fact.<br>
[037]         Referring to FIG. 4, for each identifier/attribute represented in that fact, the engine determines if there is a corresponding entry 222 in the feature table 220 using the feature hash table 210 (step 410). If there is such a feature entry 222, the condition element entries 232 that depend on the value of the identifier/attribute are identified using the pointers 226 from the feature table 220 to the CE table 230 (step 420). This is repeated to identify all the condition elements that depend on some identifier/attribute of the current fact 200. For each of the condition elements that depends on the current fact, the condition element is evaluated using the condition element specification 234 and the attribute values of the current fact 200. Note that the condition element may depend on multiple ones of the attributes of the current fact. The result of evaluating the condition element is then entered in the corresponding bit locations of the selection table 240 that are determined by the pointers 236 linking the CE table with the selection table (step 430). Each time a bit is updated in one of the bit vectors 242 of the selection table 240 the bit vector is compared with the bit vector 256 of the corresponding rule entry 252 (step 440). If the bit vectors are equal, then an entry 292 is added to the applicable rule list 290,<br>
 <br>
unless an entry for that rule is already in the list (step 450). If the bit vectors are not equal, then if the applicable rule list includes an entry for that rule, it is removed from the applicable rule list.<br>
[038]         Referring back to FIG. 3, having constructed the applicable rule list 290 based on the facts 102 that were provided to the system 100, if the applicable rules list is not empty (step 330) the rules processing engine then selects one (e.g., in sequence or in an arbitrary order) of the applicable rules from the set of applicable rules, removes the rule entry 292 for that rule from the applicable rule list 290 and performs the actions specified by the rule specification 254 of that rule (step 340). An action of the rule can result in a fact being added to the fact base 110. If such a fact or facts are added (step 350) further processed by the rules processing engine 160 following the same process as described above for added external facts (step 360). That is, the rules processing engine determines which identifier/attribute pairs of the added fact are represented in the features table, and for each of these identifier/attributes, it locates the condition element entry that makes use of that identifier/attribute and evaluates that condition element If the condition for a rule whose condition uses that condition element evaluates to true, the rule is added to the applicable rule list 290 if not already present and if the condition evaluates to false, the rule is removed from the applicable rule list if it is present Having processed the actions for the rule selected from the applicable rule.list 290, the rules processing engine repeats the procedure by selecting another rule from the list until the list is empty (step 330).<br>
[039]         In the description above, the bit vectors 256 in the rules table 250 and the bit vector entries 242 in the selection table 240 are described as using single bits associated with each of the condition elements that are used in the condition of the corresponding rule. Use of single bits enables an efficient comparison of the two bit vectors, for example, using a single machine instruction for bit vectors with the number of bits being less than or equal to the word-length of the instruction set architecture being using to implement the engine. Alternatively, other efficient encodings of the information in the bit vector 256 and selection vector 242 can be used, for example, using a single byte, word, or other size of data element associated with each condition element In such alternatives, the comparison may not be accomplished using a single machine instruction but may nevertheless be very efficient, for example, using an efficiently implemented loop of instructions.<br>
 <br>
[040]         The various "tables" shown in FIG. 2 are not necessarily implemented as arrays of fixed-length records. For example, each entry of each of the tables can be stored as one or more data items linked by pointers. This enables different sizes of bit vectors 256 and 242 for different rules.<br>
[041]         Various pointers of the data structure, for example pointers 226 and 236, are not necessarily stored as memory addresses into a memory in which the data structure is stored. For example, these pointers may be relative memory addresses, record offsets, record indexes, or other forms of data that enable efficient access to the destination of the pointer.<br>
[042]         The bit vector 256 of each rule entry 252 is not necessarily required, for example, if condition elements must be combined with a single operator, such as with an AND operator. Furthermore, more complex logical combinations of condition elements may be supported while maintaining efficient representation of the required combinations of the condition elements and the evaluated values of those condition elements.<br>
[043]         The storage locations of the selection table 240 are not necessarily preallocated. For example, the storage locations in a bit vector 242 for an entry for a condition element may be allocated on the first occurrence of a feature upon which the condition element depends.<br>
[044]         In one application of this approach, multiple sets of facts 102 are to be processed, each set with a corresponding rules base from a variety of different rules bases. For each of the rules bases, the rules compiler is used ahead of time to form the compiled rules base 125 and corresponding initialized dynamic rules data 135. The compiled rules base and the initialized dynamic rules data are then stored for later use. For each set of facts, the system loads the corresponding compiled rules base 125 and initialized dynamic rules data 135. For example, the compiled rules base and the initialized dynamic rules data are stored as memory images that can be loaded efficiently into memory of the computer hosting the rules processing engine. If successive sets of facts use the same rules base, only the initialized dynamic rules data 135 needs to be reloaded before processing the facts because the compiled rules base does not change with processing of facts.   '<br>
[045]         The rules base is not necessarily represented explicitly. For example, a rules base may itself result from the compilation of another form of information<br>
 <br>
structure, which may be other forms of rules or constraints applicable to a particular application domain. In such a case, this other form of information structure may be compiled directly into the data structures of the compiled rules base and dynamic rules data without necessarily explicitly representing the rules base. The formation of the data structures may not require a rules compiler. For example, a text representation of the rules can be loaded into the system and an in-memory representation of the data structures built during that load<br>
(046]         Alternative versions of the system can be implemented in software, in<br>
firmware, in digital electronic circuitry, or in computer hardware, or in<br>
combinations of them. The system can include a computer program product<br>
tangibly embodied in a machine-readable storage device for execution by a<br>
programmable processor, and method steps can be performed by a programmable<br>
processor executing a program of instructions to perform functions by operating on<br>
input data and generating output. The system can be implemented in one or more<br>
computer programs that are executable on a programmable system including at least<br>
one programmable processor coupled to receive data and instructions from, and to<br>
.   transmit data and instructions to, a data storage system, at least one input device,<br>
and at least one output device. Each computer program can be implemented in a<br>
high-level procedural or object-oriented programming language, or in assembly or<br>
machine language if desired; and in any case, the language can be a compiled or<br>
interpreted language. Suitable processors include, by way of example, both general<br>
and special purpose microprocessors. Generally, a processor will receive<br>
instructions and data from a read-only memory and/or a random access memory.<br>
Generally, a computer will include one or more mass storage devices for storing<br>
data files; such devices include magnetic disks, such as internal hard disks and<br>
removable disks; magneto-optical disks; and optical disks. Storage devices suitable<br>
for tangibly embodying computer program instructions and data include all forms of<br>
non-volatile memory, including by way of example semiconductor memory devices,<br>
such as EPROM, EEPROM, and flash memory devices; magnetic disks such as.,<br>
internal hard disks and removable disks; magneto-optical disks; and CD-ROM<br>
disks. Any of the foregoing can be supplemented by, or incorporated in, ASICs<br>
(application-specific integrated circuits).	*'   .<br>
[047]         Many other implementations of the invention other than those described above are within the invention, which is defined by the following claims.<br>
<br>
<br>
 What is claimed is:<br>
- 1.        A method for processing rules comprising:<br>
accepting a rules base comprising a plurality of rules, each rule including a condition that includes one or more condition element for application of the rule, at least some of the conditions including multiple condition elements; and<br>
processing the rules base to form a data structure, wherein the data structure includes for each of the plurality of rules storage locations for holding Boolean values of the condition elements of the conditions for said rule.<br>
2.	The method of claim 1 wherein the storage locations for holding values of<br>
the condition elements comprise bits of a bit vector with each condition element<br>
being associated with a different bit position in the bit vector.<br>
3.	The method of claim 1 further comprising:<br>
processing a plurality of facts, including evaluating condition elements that depend on the facts, and storing results of evaluating the condition elements in the storage locations for holding the values of the condition elements.<br>
4.	-    The method of claim 1 wherein the data structure links each fact to<br>
corresponding condition elements that depend on that fact.<br>
5.	The method of claim 4 further comprising processing a plurality of facts,<br>
including determining applicable rules of the plurality of rules based on the accepted<br>
facts by identifying condition elements that depend on the accepted facts using the<br>
data structure.<br>
 <br>
6.	The method of claim 1 wherein the data structure includes for each of the<br>
plurality of rules data values corresponding to the storage locations for the values of<br>
the condition elements, said data values representing a logical combination of<br>
condition elements.<br>
7.	The method of claim 6 further comprising:<br>
identifying applicable ones of the plurality of rules using the data values representing the logical combination of the condition elements and values stored in the storage locations for storing values of the condition elements.<br>
8.	A system for processing a rules base comprising:<br>
a data structure formed using a rules base that includes a plurality of rules, each rule including a condition that includes one or more condition element for application of the rule, at least some of the conditions including multiple condition elements, wherein the data structure includes for each of a plurality of rules of the rules base storage locations for holding Boolean values of condition elements of the conditions for said rule; and<br>
a compiler for processing the rules base, the rules base comprising a<br>
plurality of rules, each rule including a condition that includes one or more condition element for application of the rule, at least some of the conditions including multiple condition elements.<br>
9.	A rules processing system comprising:<br>
a data structure formed using a rules base that includes a plurality of rules, each rule including a condition that includes one or more condition element for application of the rule, at least some of the conditions including multiple condition elements, wherein the data structure includes for each of a plurality of rules of the rules base storage locations for holding Boolean values of condition elements of the conditions for said rule; and<br>
 <br>
a rules processing engine coupled to the data structure for operation according to the rules base.<br>
10.	A data structure embodied in a computer-readable medium for use in rules<br>
processing comprising:<br>
storage locations for values associated with conditions for a plurality of rules in a rules base, wherein the rules base comprises a plurality of rules, each rule including a condition that includes one or more condition element for application of the rule, at least some of the conditions including multiple condition elements;<br>
wherein the storage locations include for each of the plurality of rules<br>
locations for holding Boolean values of the condition elements of the ' conditions for said rule.<br>
11.	Software comprising instructions embodied in a computer-readable medium<br>
for causing a computer system to:<br>
accept a rules base comprising a plurality of rules, each rule including a<br>
condition that includes one or more condition element for application of the rule, at least some of the conditions including multiple condition elements; and<br>
process the rules base to form a data structure, wherein the data structure includes for each of the plurality of rules storage locations for holding Boolean values of the condition elements of the conditions for said rule.<br>
 <br>
</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=bCpAeQ/lwatk7GjCM2JsSw==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=bCpAeQ/lwatk7GjCM2JsSw==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==</a></p>
		<br>
		<div class="pull-left">
			<a href="272247-mobile-communications-terminal-having-key-input-error-prevention-function-and-method-thereof.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="272249-novel-timed-release-multicarotenoid-composition-and-a-process-for-its-preparation.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>272248</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2750/CHENP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>14/2016</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>01-Apr-2016</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>23-Mar-2016</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>26-Jul-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>TRIGENT SOFTWARE</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>1 Apple Hill, Suite 204, Natick, MA 01760</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>REHBERG, Charles, Patrick</td>
											<td>15 Stevens Street, Nashua, NH 03060</td>
										</tr>
										<tr>
											<td>2</td>
											<td>PORTER, Steve, Sherwood</td>
											<td>32 Lakeshore Drive, Sterling, MA 01564</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>GO6F</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2005/002396</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-01-25</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/765,461</td>
									<td>2004-01-26</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/272248-rule-selection-engine by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 22:40:40 GMT -->
</html>
