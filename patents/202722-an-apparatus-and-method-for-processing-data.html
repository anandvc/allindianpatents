<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/202722-an-apparatus-and-method-for-processing-data by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:33:47 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 202722:AN APPARATUS AND METHOD FOR PROCESSING DATA</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">AN APPARATUS AND METHOD FOR PROCESSING DATA</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Apparatus for processing data, said apparatus comprising: a processor core (104) having a register bank (106) containing a plurality of registers and being operable to execute operations upon register operands held in said registers as specified within instructions of a first instruction set; and an instruction translator (108) operable to translate instructions of a second instruction set into translator output signals corresponding to instructions of said first instruction set, instructions of said second instruction set specifying operations to be executed upon stack operands held in a stack; wherein said instruction translator (108) is operable to allocate a set of registers within said register bank (106) to hold stack operands from a portion of said stack; said instruction translator, (108) has a plurality of mapping states in which different registers within said set of registers hold respective stack operands from different positions within said portion of said stack; and said instruction translator (108) is operable to change between mapping states in dependence upon operations that add or remove stack operands held within said set of registers; and wherein said instruction translator (108) uses a plurality of instruction templates for translating instructions from said second instruction set to instructions from said first instruction set; and an instruction from said second set comprising one or more stack operands has an instruction template comprising one or more instructions from said first instruction set in which register operands are mapped to said stack operands in dependence upon a currently adopted mapping state of said instruction translator.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT 1970<br>
[39 OF 1970]<br>
COMPLETE SPECIFICATION<br>
[See Section 10]<br><br>
ARM LIMITED, a British company of 110 Fulbourn Road, Cherry Hinton, Cambridge CB1 9NJ, United Kingdom,<br>
The following specification particularly describes the nature of the<br>
invention and the manner in which it is to be performed:-<br><br><br>
The present invention relates to an apparatus and method for processing data.<br>
This invention relates to the field of data processing systems. More particularly, this invention relates to data processing systems having a processor core with a register bank executing instructions of a first instruction set being used in conjunction with an instruction translator operable to translate instructions of a second instruction set into instructions of the first instruction set<br>
It is known to provide data processing systems supporting multiple instruction sets.   An example of such systems are the Thumb enabled processors produced by ARM Limited of Cambridge,  England that may execute  both  16-bit Thumb instructions and 32-bit ARM instructions. Both the Thumb instructions and the ARM     instructions execute operations (such as mathematical manipulations, loads, stores etc)    upon operands stored within register of the processor core specified by register fields    within the instructions. Considerable effort is expended in developing compilers that    are able to efficiently use the register resources of the processor core to produce     instruction streams that execute rapidly.<br><br>
Another class of instruction sets are those that use a stack approach to storing<br>
and manipulating the operands upon which they act. The stack within such a system<br>
   may store a sequence of operand values which are placed into the stack in a particular<br>
order and then removed from the stack in the reverse of that order.   Thus, thejast<br>
operand to be placed into the stack will also typically be the first operand to be<br>
removed from the stack.   Stack based processors may provide a block of storage<br>
elements to which stack operands may be written and from which stack operands may<br>
be read in conjunction with a stack pointer which indicates the current "top" position<br>
within the stack. The stack pointer specifies a reference point within the' stack memory<br>
which is the latest stack operand to be stored into the stack and from which other<br>
   accesses to the stack may be referenced.   Considerable effort is also expended in<br>
  producing compilers that are able to efficiently utilise the stack hardware resources<br><br>
  within such stack based processor systems.<br><br>
A specific example of a stack based instruction set is the Java Virtual Machine instruction set as specified by Sun Microsystems Inc. The Java programming language seeks to provide an environment in which computer software written in Java can be executed upon many different processing hardware platforms without having to alter the Java software.<br>
It is a constant aim within data processing systems that they should be able to execute the computer software controlling them as rapidly as possible. Measures that can increase the speed with which computer software may be executed are strongly desirable.<br>
Examples of known systems for translation between instruction sets and other background information may be found in the following:   US-A-5,805,895; US-A-3,955,180; US-A-5,970,242; US-A-5,619,665; US-A-5,826,089; US-A-5,925,123; US-A-5,875,336; US-A-5,937,193; US-A-5,953,520; US-A-6,021,469; US-A-5,568,646; US-A-5,758,115; US-A-5,367,685; IBM Technical Disclosure Bulletin, March 1988, pp308-309, "System/370 Emulator Assist Processor For a Reduced Instruction Set Computer"; IBM Technical Disclosure Bulletin, July 1986, pp,548-549, "Full Function Series/1 Instruction Set Emulator"; IBM Technical Disclosure Bulletin, March 1994, pp605-606, "Real-Time CISC Architecture HW Emulator On A RISC Processor"; IBM Technical Disclosure Bulletin, March 1998, p272, "Performance Improvement Using An EMULATION Control Block"; IBM Technical Disclosure Bulletin, January 1995,    pp537-540, "Fast Instruction Decode For Code Emulation on Reduced Instruction Set Computer/Cycles Systems"; IBM Technical Disclosure Bulletin, February 1993, pp231-234, "High Performance Dual Architecture Processor"; IBM Technical Disclosure Bulletin, August 1989, pp40-43, "System/370 170 Channel Program Channel Command Word Prefetch"; IBM Technical Disclosure Bulletin, June 1985,  pp305-306, "Fully Microcode-Controlled  Emulation  Architecture";   IBM Technical Disclosure Bulletin, March 1972,   pp3074-3076, "Op Code and Status Handling For Emulation"; IBM Technical Disclosure Bulletin, August 1982, pp954-956, "On-Chip Microcoding of a Microprocessor With Most Frequently Used Instructions  of Large  System  and  Primitives   Suitable  for  Coding  Remaining Instructions";   IBM   Technical   Disclosure   Bulletin,   April   1983,   pp5576-5577,<br><br>
"Emulation Instruction"; the book ARM System Architecture by S Furber; the book Computer Architecture: A Quantitative Approach by Hennessy and Patterson; and the book The Java Virtual Machine Specification by Tim Lindholm and Frank Yellin 1st and 2nd Editions.<br>
Viewed from one aspect the present invention provides apparatus for processing data, said apparatus comprising:<br>
a processor core having a register bank containing a plurality of registers and being operable to execute operations upon register operands held in said registers as specified within instructions of a first instruction set; and<br>
an instruction translator operable to translate instructions of a second instruction set into translator output signals corresponding to instructions of said first instruction set, instructions of said second instruction set specifying operations to be executed upon stack operands held in a stack; wherein<br>
said instruction translator's operable to allocate a set of registers within said register bank to hold stack operands from a portion of said stack;<br>
said instruction translator has a plurality of mapping states in which different registers within said set of registers hold respective stack operands from different positions within said portion of said stack; and<br>
said instruction translator is operable to change between mapping states in dependence upon operations that add or remove stack operands held within said set of registers.<br>
The invention provides for the execution of instructions of a second, stack based instruction set by translating these to instructions of a first, register based instruction set for execution upon a processor core. The invention provides a set of registers within the register bank to hold stack operands from a portion of the stack. This effectively caches stack operands within the processor core to speed execution. Furthermore, in order to more efficiently use the registers allocated to stack operands, the instruction translator has a plurality of different mapping states in which different registers hold respective stack operands from different positions within the portion of the stack cached. The mapping state is changed in dependence upon operations that add or remove stack operands held within the set of registers used for the stack in a<br><br>
manner that provides a function similar to that of a stack pointer within a stack. This approach reduces the processing overhead required to provide stack-like storage within the registers of a register based processor.<br>
In preferred embodiments of the invention said instruction translator provides mapping states such that stack operands are added to or removed from said set of registers without moving stack operands between registers within said set of registers.<br>
This preferred feature is such that the mapping states are used to avoid the need to move any stack operands between registers once they have been stored into those registers thereby avoiding a significant processing overhead that would otherwise be incurred in seeking to provide a system in which stack operands having a particular position within the stack were always found in predetermined registers.<br>
Whilst it will be appreciated that the set of registers could hold stack operands from any position within the stack, it is strongly desirable that the set of registers store a top portion of the stack including a top of stack operand. Stack based processing systems most often access stack operands that were only recently stored to the stack and accordingly keeping these stack operands within the registers where they may be rapidly accessed is strongly advantageous. Furthermore, having the top of stack operand held within the registers makes the ability of the instruction translator to move between different mapping states highly advantageous as the top of stack operand will often change as stack operands are pushed to the stack or popped from the stack.<br>
Whilst it is possible that the portion of the stack not held within the registers could be provided with various different hardware arrangements, in preferred embodiments of the invention the stack includes a plurality of addressable memory locations holding stack operands.<br>
An addressable memory is frequently found within processing systems together with mechanisms such as sophisticated cache memories for enabling high speed access to the data within such an addressable memory.<br><br>
It will be appreciated that the registers of the processor core that may be devoted to the storage of stack operands is limited by the need to provide other registers for functions such as the management of the translation of instructions from the second instruction set to the first instruction set and the emulation of other control values, such as a variables pointer or a constant pool pointer, that may be found in a stack based processing system. In this context, stack operands that overflow from the set 0f registers provided ifor stack operand storage may be held within the addressable memory.<br>
In a complementary manner, many high speed register based processing systems are arranged to provide data processing manipulations only upon data values held within registers in order to avoid problems that can occur due to relatively long memory access latency and the like. In this context, the invention provides that stack operands are always loaded into the set of registers prior to use.<br>
The instruction translator may conveniently be arranged to use instruction templates for translating between the second instruction set and the first instruction set Such instruction templates provide an advantageous degree of flexibility in the nature of the mapping that may be achieved between instructions of the second instruction set and typically several instructions of the first instruction set.<br>
It will be appreciated that the instruction translator could take a wide variety of forms. In particular, the instruction translator could be provided as special purpose hardware for translating or compiling the second instmction set or as software controlling the processor core to perform similar translatidh orcompilation functions. A mix of approacSes may also be usefully employed. In the case of a software; interpreter, the translator output signals may be translated instructions of the first instruction set produced by the software interpreter.<br>
In particular, a hardware translator may be provided to achieve high speed translation of simple frequently occurring instructions within the second instruction set whilst software translation, may be used for complex or infrequently occurring<br><br>
instructions of the second instruction set which are such that the hardware overhead of providing such translation would not be practical or efficient.<br>
A particularly preferred way in which the mapping states of the instruction translator may be controlled is to provide a plurality of state bits indicating the number of stack operands held within the set of registers and a plurality of state bits indicating which register is holding the top of stack operand.<br>
Whilst it will be appreciated that the second instruction set could take many different forms, the invention is particularly useful in embodiments in which the second instruction set is a Java Virtual Machine instruction set.<br>
Viewed from another aspect the present invention provides a method of processing data using a processor core having a register bank containing a plurality of registers and being operable to execute operations upon register operands held in said registers as specified within instructions of a first instruction set, said method comprising the steps of:<br>
translating instructions of a second instruction set into translator output signals corresponding to instructions of said first instruction set, instructions of said second instruction set specifying operations to be executed upon stack operands held in a stack;<br>
allocating a jjet_ of registers within said register bank to hold stack operands from a portion of said stack;<br>
adopting one of a plurality of mapping states in which different registers within said set of registers hold respective stack operands from different positions within said portion of said stack; and<br>
changing between mapping states in dependence upon operations that add or remove stack operands held within said set of registers.<br>
The present invention also provides a computer program product storing a computer program for controlling a general purpose computer in accordance with the above described techniques.   The computer program product could take a variety of<br><br>
forms, such as a floppy disk, a compact disk or a computer file downloaded from a computer network.<br>
Embodiments of the invention will now be described, by way of example only, with reference to the accompanying drawings in which:<br>
Figures 1 and 2 schematically represent example instruction pipeline arrangements;<br>
Figure 3 illustrates in more detail a fetch stage arrangement;<br>
Figure 4 schematically illustrates the reading of variable length non-native instructions from within buffered instruction words within the fetch stage;<br>
Figure 5 schematically illustrates a data processing system for executing both processor core native instructions and instructions requiring translation;<br>
Figure 6 schematically illustrates, for a sequence of example instructions and states the contents of the registers used for stack operand storage, the mapping states and the relationship between instructions requiring translation and native instructions;<br>
/        Figure 7 schematically illustrates the execution of a non-native instruction as a sequence of native instructions;<br>
  Figure 8 is a flow diagram illustrating the way in which the instruction translator may operate in a manner that preserves interrupt latency for translated instructions;.<br>
     Figure 9 schematically illustrates the translation of Java bytecodes into ARM opcodes using hardware and software techniques;<br>
Figure 10 schematically illustrates the flow of control between a hardware based translator, a software based interpreter and software based scheduling;<br><br>
Figures 11 and 12 illustrate another way of controlling scheduling operations using a.timer based approach; and<br>
Figure 13 is a signal diagram illustrating the signals controlling the operation of the circuit of Figure 12.<br>
Figure 1 shows a first example instruction pipeline 30 of a type suitable for use in an ARM processor based system. The instruction pipeline 30 includes a fetch stage 32, a native instruction (ARM/Thumb instructions) decode stage 34, an execute stage 36, a memory access stage 38 and a write back stage 40.  The execute stage 36, the memory access stage 38 and the write back stage 40 are substantially conventional. Downstream of the fetch stage 32, and upstream of the native instruction decode stage 34, there is provided an instruction translator stage 42. The instruction translator stage 42 is a finite state machine that translates Java bytecode instructions of a variable length into native ARM instructions. The instruction translator stage 42 is capable of multi-step operation whereby a single Java bytecode instruction may generate a sequence of ARM instructions that are fed along the remainder of the instruction pipeline 30 to perform the operation specified by the Java bytecode instruction. Simple Java bytecode instructions may required only a single ARM instruction to perform their operation, whereas more complicated Java bytecode instructions, or in circumstances  where the  surrounding system  state  so  dictates,  several ARM instructions may be needed to provide the operation specified by the Java bytecode instruction.   This multi-step operation takes place downstream of the fetch stage 32 and accordingly power is not expended upon fetching multiple translated ARM instructions or Java bytecodes from a memory system. The Java bytecode instructions are stored within the memory system in a conventional manner such that additional constraints are not provided upon the memory system in order to support the Java bytecode translation operation.<br>
As illustrated, the instruction translator stage 42 is provided with a bypass path. When not operating in an instruction translating mode, the instruction pipeline 30 may<br><br>
bypass the instruction translator stage 42 and operate in an essentially unaltered manner to provide decoding of native instructions.<br>
In the instruction pipeline 30, the instruction translator stage 42 is illustrated as generating translator output signals that fully represent corresponding ARM instructions and are passed via a multiplexer to the native instruction decoder 34. The instruction translator 42 also generates some extra control signals that may be passed to the native instruction decoder 34. Bit space constraints within the native instruction encoding may impose limitations upon the range of operands that may be specified by native instructions. These limitations are not necessarily shared by the non-native instructions. Extra control signals are provided to pass additional instruction specifying signals derived from the nori-native instructions that would not be possible to specify within native instructions stored within memory. As an example, .a native instruction may only provide a relatively low number of bits for use as an immediate operand field within a native instruction, whereas the non-native instruction may allow an extended range and this can be exploited by using the extra control signals to pass the extended portion of the immediate operand to the native instruction decoder 34 outside of the translated native instruction that is also passed to the native instruction decoder 34.<br>
Figure 2 illustrates a further instruction pipeline 44. In this example, the system is provided with two native instruction decoders 46, 48 as well as a non-native instruction decoder 50. The non-native instruction decoder 50 is constrained in the operations it can specify by the execute stage 52, the memory stage 54 and the write back stage 56 that are provided to support the native instructions. Accordingly, the non-native instruction decoder 50 must effectively translate the non-native instructions into native operations (which may be a single native operation or a sequence of native operations) and then supply appropriate control signals to the execute stage 52 to carry out these one or more native operations. It will be appreciated that in this example the non-native instruction decoder does not produce signals that form a native instruction, but rather provides control signals that specify native instruction (or extended native instruction) operations. The control signals generated may not match the control signals generated by the native instruction decoders 46, 48.<br><br>
In operation, an instruction fetched by the fetch stage 58 is selectively supplied to one of the instruction decoders 46, 48 or 50 in dependence upon the particular processing mode using the illustrated demultiplexer.<br>
Figure 3 schematically illustrates the fetch stage of an instruction pipeline in more detail. Fetching logic 60 fetches fixed length instruction words from a memory system and supplies these to an instruction word buffer 62. The instruction word buffer 62 is a swing buffer having two sides such that it may store both a current instruction word and a next instruction word. Whenever the current instruction word has been fully decoded and decoding has progressed onto the next instruction word, then the fetch logic 60 serves to replace the previous current instruction word with the next instruction word to be fetched from memory, i.e. each side of the swing buffer will increment by two in an interleaved fashion the instruction words that they successively store.<br>
In the example illustrated, the maximum instruction length of a Java bytecode instruction is three bytes. Accordingly, three multiplexers are provided that enable any three neighbouring bytes within either side of the word buffer 62 to be selected and supplied to the instruction translator 64. The word buffer 62 and the instruction translator 64 are also provided with a bypass path 66 for use when native instructions are being fetched and decoded.<br>
It will be seen that each instruction word is fetched from memory once and stored within the word buffer 62. A single instruction word may have multiple Java bytecodes read from it as the instruction translator 64 performs the translation of Java bytecodes into ARM instructions. Variable length translated sequences of native instructions may be generated without requiring multiple memory system reads and without consuming memory resource or imposing other constraints upon the memory system as the instruction translation operations are confined within the instruction pipeline.<br><br>
A program counter value is associated with each Java bytecode currently being translated. This program counter value is passed along the stages of the pipeline such that each stage is able, if necessary, to use the information regarding the particular Java bytecode it is processing. The program counter value for a Java bytecode that translates into a sequence of a plurality of ARM instruction operations is not incremented until the final ARM instruction operation within that sequence starts to be executed. Keeping the program counter value in a manner that continues to directly point to the instruction within the memory that is being executed advantageously simplifies other aspects of the system, such as debugging and branch target calculation.<br>
Figure 4 schematically illustrates the reading of variable length Java bytecode instructions from the instruction buffer 62. At the first stage a Java bytecode instruction having a length of one is read and decoded. The next stage is a Java bytecode instruction that is three bytes in length and spans between two adjacent instruction words that have been fetched from the memory. Both of these instruction words are present within the instruction buffer 62 and so instruction decoding and processing is not delayed by this spanning of a variable length instruction between instruction words fetched. Once the three Java bytecodes have been read from the instruction buffer 62, the refill of the earlier fetched of the instruction words may commence as subsequent processing will continue with decoding of Java bytecodes from the following instruction word which is already present.<br>
The final stage illustrated in Figure 4 illustrates a second three bytecode instruction being read. This again spans between instruction words. If the preceding instruction word has not yet completed its refill, then reading of the instruction may be delayed by a pipeline stall until the appropriate instruction word has been stored into the instruction buffer 62. In some embodiments the timings may be such that the pipeline never stalls due to this type of behaviour. It will be appreciated that the particular example is a relatively infrequent occurrence as most Java bytecodes are shorter than the examples illustrated and accordingly two successive decodes that both span between instruction words is relatively uncommon. A valid signal may be associated with each of the instruction words within the instruction buffer 62 in a<br><br>
manner that is able to signal whether or not the instruction word has appropriately been refilled before a Java bytecode has been read from it.<br>
Figure 5 shows a data processing system 102 including a processor core 104 and a register bank 106.    An instruction translator 108 is provided within the instruction path to translate Java Virtual Machine instructions to native ARM instructions (or control signals corresponding thereto) that may then be supplied to the processor core 104. The instruction translator 108 may be bypassed when native ARM instructions are being fetched from the addressable memory. The addressable memory may be a memory system such as a cache memory with further off-chip RAM memory. Providing the instruction translator 108 downstream of the memory system, and particularly the cache memory, allows efficient use to be made of the storage capacity of the memory system since dense instructions that require translation may be stored within the memory system and only expanded into native instructions S     immediately prior to being passed to the processor core 104.<br>
The register bank 106 in this example contains sixteen general purpose 32-bit registers, of which four are allocated for use in storing stack operands, i.e. the set of registers for storing stack operands is registers R0, Rl, R2 and R3. i<br>
The set of registers may be empty, partly filled with stack operands or completely filled with stack operands. The particular register that currently holds the top of stack operand may be any of the registers within the set of registers. It will thus be appreciated that the instruction translator may be in any one of seventeen different mapping states corresponding to one state when all of the registers are empty and four groups of four states each corresponding to a respective different number of stack operands being held within the set of registers and with a different register holding the top of stack operand. Table 1 illustrates the seventeen different states of the state mapping for the instruction translator 108. It will be appreciated that with a different number of registers allocated for stack operand storage, or as a result of constraints that a particular processor core may have in the way it can manipulate data values held within registers, the mapping states can very considerably depending upon the<br><br>
particular implementation and Table 1 is only given as an example of one particular implementation.<br><br>
Within Table 1 it may be observed that the first three bits of the state value indicate the number of non-empty registers within the set of registers. The final two bits of the state value indicate the register number of the register holding the top of stack operand. In this way, the state value may be readily used to control the operation of a hardware translator or a software translator to take account of the currently occupancy of the set of registers and the current position of the top of stack operand.<br><br>
As illustrated in Figure 5 a stream of Java bytecodes Jl, J2, J3 is fed to the instruction translator 108 from the addressable memory system.    The instruction translator 108 then outputs a stream of ARM instructions (or equivalent control signals, possibly extended) dependent upon the input Java bytecodes and the instantaneous mapping state of the instruction translator 8, as well as other variables. The example illustrated shows Java bytecode Jl being mapped to ARM instructions A'l and Ar2. Java bytecode J2 maps to ARM instructions A21, A22 and A23. Finally, Java bytecode J3 maps to ARM instruction A31.   Each of the Java bytecodes may require one or more stack operands as inputs and may produce one or more stack operands as an output. Given that the processor core 104 in this example is an ARM processor core having a load/store architecture whereby only data values held within registers may be manipulated, the instruction translator 108 is arranged to generate ARM instructions that, as necessary, fetch any required stack operands into the set of registers before they are manipulated or store to addressable memory any currently held stack operands within the set of registers to make room for result stack operands that may be generated.    It will be appreciated that each Java bytecode may be considered as having an associated "require full" value indicating the number of stack operands that must be present within the set of registers prior to its execution together with a "require empty" value indicating the number of empty registers within the set of registers that must be available prior to execution of the ARM instructions representing the Java opcode.<br>
Table 2 illustrates the relationship between initial mapping state values, require full values, final state values and associated ARM instructions. The initial state values<br>
  and the final state values correspond to the mapping states illustrated in Table 1. The instruction translator 108 determines a require full value associated with the particular Java bytecode (opcode) it is translating. The instruction translator (108), in dependence upon the initial mapping state that it has, determines whether or not more stack operands need to be loaded into the set of registers prior to executing the Java<br>
  bytecode. Table 1 shows the initial states together with tests applied to the require full value of the Java bytecode that are together applied to determine whether a stack operand needs to be loaded into the set of registers using an associated ARM instruction (an LDR instruction) as well as the final mapping state that will be adopted<br><br>
after such a stack cache load operation. In practice, if more than one stack operand needs to be loaded into the set of registers prior to execution of the Java bytecode, then multiple mapping state transitions will occur, each with an associated ARM instruction loading a stack operand into one of the registers of the set of registers. In different embodiments it may be possible to load multiple stack operands in a single state transition and accordingly make mapping state changes beyond those illustrated in<br><br>
As will be seen from Table 2, a new stack operand loaded into the set of registers storing stack operands will form a new top of stack operand and this will be loaded into a particular one of the registers within the set of registers depending upon the initial state.<br>
Table 3 in a similar manner illustrates the relationship between initial state, require empty value, final state and an associated ARM instruction for emptying a register within the set of registers to move between the initial state and the final state if the require empty value of a particular Java bytecode indicates that it is necessary given the initial state before the Java bytecode is executed. The particular register values stored off to the addressable memory with an STR instruction will vary depending upon which of the registers is the current top of stack operand.<br>
INITIAL     REQUIRE FINAL     ACTIONS<br><br><br>
TABLE 3<br>
It will be appreciated that in the above described example system the require full and require empty conditions are mutually exclusive, that is to say only one of the require full or require empty conditions can be true at any given time for a particular Java bytecode which the instruction translator is attempting to translate.    The instruction templates used by the instruction translator.. 108 together with the instructions it is chosen to support .with the hardware instruction translator 108 are selected such that this mutually exclusive requirement may be met. If this requirement were not in place, then the situation could arise in which a particular Java bytecode required a number of input stack operands to be present within the set of registers that would not allow sufficient empty registers to be available after execution of the instruction representing the Java bytecode to allow the results of the execution to be held within the registers as required.<br>
It will be appreciated that a given Java bytecode will have an overall nett stack action representing the balance between the number of stack operands consumed and the number of stack operands generated upon execution of that Java bytecode. Since the number of stack operands consumed is a requirement prior to execution and the number of stack operands generated is a requirement after execution, the require full and require empty values associated with each Java bytecode must be satisfied prior to execution of that bytecode even if the nett overall action would in itself be met. Table 4 illustrates the relationship between an initial state, an overall stack action, a final<br><br>
state and a change in register use and relative position of the top of stack operand (TOS). It may be that one or more of the state transitions illustrated in Table 2 or Table 3 need to be carried out prior to carrying out the state transitions illustrated in Table 4 in order to establish the preconditions for a given Java bytecode depending on the require full and require empty values of the Java bytecode.<br><br><br><br>
TABLE 4<br>
It will be appreciated that the relationships between states and conditions illustrated in Table 2, Table 3 and Table 4 could be combined into a single state<br><br>
transition table or state diagram, but they have been shown separately above to aid clarity.<br>
The relationships between the different states, conditions, and nett actions may be used to define a hardware state machine (in the form of a finite state machine) for controlling this aspect of the operation of the instruction translator 108. Alternatively, these relationships could be modelled by software or a combination of hardware and software.<br>
There follows below an example of a subset of the possible Java bytecodes that indicates for each Java bytecode of the subset the associated require full, require empty and stack action values for that bytecode which may be used in conjunction with Tables 2, 3 and 4.<br><br><br><br>
There also follows example instruction templates for each of the Java bytecode instructions set out above. The instructions shown are the ARM instructions which implement the required behaviour of each of the Java bytecodes. The register field "TOS-3", "TOS-2", "TOS-1", "TOS", "TOS+1" and "TOS+2" may be replaced with the appropriate register specifier as read from Table 1 depending upon the mapping state currently adopted. The denotation "TOS+n" indicates the Nth register above the register currently storing the top of stack operand starting from the register storing the top of stack operand and counting upwards in register value until reaching the end of<br><br>
the set of registers at which point a wrap is made to the first register within the set of registers.<br><br>
An example execution sequence is illustrated below of a single Java bytecode executed by a hardware translation unit 108 in accordance with the techniques described above. The execution sequence is shown in terms of an initial state progressing through a sequence of states dependent upon the instructions being executed, generating a sequence of ARM instructions as a result of the actions being performed on each state transition, the whole having the effect of translating a Java bytecode to a sequence of ARM instructions.<br><br><br>
LDR R3, [Rstack, #-4]! Next state:    01000<br>
Instruction:        iadd (Require-Full=2, Require-Empty=0, Stack-Actions -I)<br>
Condition:     Stack-Action=-l State Transition:   01000     -1    00111 Instruction template:<br>
ADD  tos-1, tos-l, tos ARM instructions(s) (after substitution):<br>
ADD R3, R3, R0 Next state:     00111<br>
Figure 6 illustrates in a different way the execution of a number of further Java bytecode instructions. The top portion of Figure 6 illustrates the sequence of ARM instructions and changes of mapping states and register contents that occur upon execution of an iadd Java bytecode instruction. The initial mapping state is 00000 corresponding to all of the registers within the set of registers being empty. The first two ARM instructions generated serve to POP two stack operands into the registers storing stack operands with the top of stack "TOS" register being RO. The third ARM instruction actually performs the add operation and writes the result into register R3 (which now becomes the top of stack operand) whilst consuming the stack operand that was previously held within register Rl, thus producing an overall stack action of-1.<br>
Processing then proceeds to execution of two Java bytecodes each representing a long load of two stack operands. The require empty condition of 2 for the first Java bytecode is immediately met and accordingly two ARM LDR instructions may be issued and executed.   The mapping state after execution of the first long load Java<br>
  bytecode is 01101. In this state the set of registers contains only a single empty register. The next Java bytecode long load instruction has a require empty value of 2 that is not met and accordingly the first action required is a PUSH of a stack operand to the addressable memory using an ARM STR instruction. This frees up a register within the set of registers for use by a new stack operand which may then be loaded as part of<br>
; the two following LDR instructions. As previously mentioned, the instruction translation may be achieved by hardware, software, or a combination of the two. Given below is a subsection of an example software interpreter generated in accordance with the above described techniques.<br><br><br><br><br><br><br><br><br>
Figure 7 illustrates a Java bytecode instruction "laload" which has the function of reading two words of data from within a data array specified by two words of data starting at the top of stack position. The two words read from the data array then replace the two words that specified their position and to form the topmost stack entries.<br>
In order that the "laload" instruction has sufficient register space for the temporary storage of the stack operands being fetched from the array without overwriting the input stack operands that specify the array and position within the array of the data, the Java bytecode instruction is specified as having a require empty value of 2, i.e. two of the registers within the register bank dedicated to stack operand storage must be emptied prior to executing the ARM instructions emulating the "laload" instruction. If there are not two empty registers when this Java bytecode is encountered, then store operations (STRs) may be performed to PUSH stack operands currently held within the registers out to memory so as to make space for the temporary storage necessary and meet the require empty value for the instruction.<br><br>
The instruction also has a require full value of 2 as the position of the data is specified by an array location and an index within that array as two separate stack operands. The drawing illustrates the first state as already meeting the require full and require empty conditions and having a mapping state of "01001". The "laload" instruction is broken down into three ARM instructions. The first of these loads the array reference into a spare working register outside of the set of registers acting as a register cache of stack operands. The second instruction then uses this array reference in conjunction with an index value within the array to access a first array word that is written into one of the empty registers dedicated to stack operand storage.<br>
It is significant to note that after the execution of the first two ARM instructions, the mapping state of the system is not changed and the top of stack pointer remains where it started with the registers specified as empty still being so specified.<br>
The final instruction within the sequence of ARM instructions loads the second array word into the set of registers for storing stack operands. As this is the final instruction, if an interrupt does occur during it, then it will not be serviced until after the instruction completes and so it is safe to change the input state with this instruction by a change to the mapping state of the registers storing stack operands. In this example, the mapping state changes to "01011" which places the new top of stack pointer at the second array word and indicates that the input variables of the array reference and index value are now empty registers, i.e. marking the registers as empty is equivalent to removing the values they held from the stack.<br>
It will be noted that whilst the overall stack action of the "laload" instruction has not changed the number of stack operands held within the registers, a mapping state swap has nevertheless occurred. The change of mapping state performed upon execution of the final operation is hardwired into the instruction translator as a function of the Java bytecode being translated and is indicated by the "swap" parameter shown as a characteristic of the "laload" instruction.<br><br>
Whilst the example of this drawing is one specific instruction, it will be appreciated that the principles set out may be extended to many different Java bytecode instructions that are emulated as ARM instructions or other types of instruction.<br>
Figure 8 is a flow diagram schematically illustrating the above technique. At - step 10 a Java bytecode is fetched from memory. At step 12 the require full and require empty values for that Java bytecode are examined. If either of the require empty or require full conditions are not met, then respective PUSH and POP operations of stack operands (possibly multiple stack operands) may be performed with steps 14 and 16. It is will be noted that this particular system does not allow the require empty and require full conditions to be simultaneously unmet. Multiple passes through steps 14 and 16 may be required until the condition of step 12 is met.<br>
At step 18, the first ARM instruction specified within the translation template for the Java bytecode concerned is selected. At step 20, a check is made as to whether or not the selected ARM instruction is the final instruction to be executed in the emulation of the Java bytecode fetched at step 10.   If the ARM instruction being executed is the final instruction, then step 21 serves to update the program counter value to point to the next Java bytecode in the sequence of instructions to be executed. It will be understood that if the ARM instruction is the final instruction, then it will complete its execution irrespective of whether or not an interrupt now occurs and accordingly it is safe to update the program counter value to the next Java bytecode and restart execution from that point as the state of the system will have reached that matching normal, uninterrupted, full execution of the Java bytecode. If the test at step 20 indicates that the final bytecode has not been reached, then updating of the program counter value is bypassed.<br>
Step 22 executes the current ARM instruction. At step 24 a test is made as to whether or not there are any more ARM instructions that require executing as part of the template. If there are more ARM instructions, then the next of these is selected at step 26 and processing is returned to step 20. If there are no more instructions, then processing proceeds to step 28 at which any mapping change/swap specified for the<br><br>
Java bytecode concerned is performed in order to reflect the desired top of stack location and full/empty status of the various registers holding stack operands.<br>
Figure 8 also schematically illustrates the points at which an interrupt if asserted is serviced and then processing restarted after an interrupt. An interrupt starts to be serviced after the execution of an ARM instruction currently in progress at step 22 with whatever is the current program counter value being stored as a return point with the bytecode sequence.   If the current ARM instruction executing is the final instruction within the template sequence, then step 21 will have just updated the program counter value and accordingly this will point to the next Java bytecode (or ARM instruction should an instruction set switch have just been initiated).   If the currently executing ARM instruction is anything other thanthe final instruction in the sequence, then the program counter value will still be the same as that indicated at the start of the execution of the Java bytecode concerned and accordingly when a return is made, the whole Java bytecode will be re-executed.<br>
Figure 9 illustrates a Java bytecode translation unit 68 that receives a stream of Java bytecodes and outputs a translated stream of ARM instructions (or corresponding control signals) to control the action of a processor core. As described previously, the<br>
0 Java bytecode translator 68 translates simple Java bytecodes using instruction templates into ARM instructions or sequences of ARM instructions. When each Java bytecode has been executed, then a counter value within scheduling control logic 70 is decremented. When this counter value reaches 0, then the Java bytecode translation unit 68 issues an ARM instruction branching to scheduling code that manages scheduling between threads<br>
i     or tasks as appropriate.<br>
Whilst simple Java bytecodes are handled by the Java bytecode translation unit 68 itself providing high speed hardware based execution of these bytecodes, bytecodes requiring more complex processing operations are sent to a software interpreter provided in the form of a collection of interpretation routines (examples of a selection of such routines are given earlier in this description). More specifically, the Java bytecode translation unit 68 can determined that the bytecode it has received is not one which is supported by hardware translation and accordingly a branch can be made to an address<br><br>
dependent upon that Java bytecode where a software routine for interpreting that bytecode is found or referenced. This mechanism can also be employed when the scheduling logic 70 indicates that a scheduling operation is needed to yield a branch to the scheduling code.<br>
Figure 10 illustrates the operation of the embodiment of Figure 9 in more detail and the split of tasks between hardware and software. All Java bytecodes are received by the Java bytecode translation unit 68 and cause the counter to be decremented at step 72. At step 74 a check is made as to whether or not the counter value has reached 0. If the counter value has reached 0 (counting down from either a predetermined value hardwired into the system or a value that may be user controlled/programmed), then a branch is made to scheduling code at step 76. Once the scheduling code has completed at step 76, control is returned to the hardware and processing proceeds to step 72, where .the next Java bytecode is fetched and the counter again decremented. Since the counter reached 0, then it will now roll round to a new, non-zero value. Alternatively, a new value may be forced into the counter as part of the exiting of the scheduling process at step 76.<br>
If the test at step 74 indicated that the counter did not equal 0, then step 78 fetches the Java bytecode. At step 80 a determination is made as to whether the fetched bytecode is a simple bytecode that may be executed by hardware translation at step 82 or requires more complex processing and accordingly should be passed out for software interpretation at step 84. If processing is passed out to software interpretation, then once this has completed control is returned to the hardware where step 72 decrements the counter again to take account of the fetching of the next Java bytecode.<br>
Figure 11 illustrates an alternative control arrangement. At the start of processing at step 86 an instruction signal (scheduling signal) is deasserted. At step 88, a fetched Java bytecode is examined to see if it is a simple bytecode for which hardware translation is supported. If hardware translation is not supported, then control is passed out to the interpreting software at step 90 which then executes a ARM instruction routine to interpret the Java bytecode. If the bytecode is a simple one for which hardware translation is supported, then processing proceeds to step 92 at which one or more ARM instructions are issued in sequence by the Java bytecode translation unit 68 acting as a<br><br>
form of multi-cycle finite state machine. Once the Java bytecode has been properly executed either at step 90 or at step 92, then processing proceeds to step 94 at which the instruction signal is asserted for a short period prior to being deasserted at step 86. The assertion of the instruction signal indicates to external circuitry that an appropriate safe point has been reached at which a timer based scheduling interrupt could take place without risking a loss of data integrity due to the partial execution of an interpreted or translated instruction.<br>
Figure 12 illustrates example circuitry that may be used to respond to the instruction signal generated in Figure 11. A timer 96 periodically generates a timer signal after expiry of a given time period. This timer signal is stored within a latch 98 until it is cleared by a clear timer interrupt signal. The output of the latch 98 is logically combined by an AND gate 100 with the instruction signal asserted at step 94. When the latch is set and the instruction signal is asserted, then an interrupt is generated as the output of the AND gate 100 and is used to trigger an interrupt that performs scheduling operations using the interrupt processing mechanisms provided within the system for standard interrupt processing. Once the interrupt signal has been generated, this in turn triggers the production of a clear timer interrupt signal that clears the latch 98 until the next timer output pulse occurs.<br>
Figure 13 is a signal diagram illustrating the operation of the circuit of Figure 12. The processor core clock signals occur at a regular frequency. The timer 96 generates timer signals at predetermined periods to indicate that, when safe, a scheduling operation should be initiated. The timer signals are latched. Instruction signals are generated at times spaced apart by intervals that depend upon how quickly a particular Java bytecode was executed. A simple Java bytecode may execute in a single processor core clock cycle, or more typically two or three, whereas a complex Java bytecode providing a high level management type function may take several hundred processor clock cycles before its execution is completed by the software interpreter. In either case, a pending asserted latched timer signal is not acted upon to trigger a scheduling operation until the instruction signal issues indicating that it is safe for the scheduling operation to commence.  The simultaneous occurrence of a latched timer signal and the instruction<br><br>
signal triggers the generation of an interrupt signal followed immediately thereafter by clear signal that clears the latch 98.<br><br>
Claim:<br>
Apparatus for processing data, said apparatus comprising: a processor core (104) having a register bank (106) containing a plurality of registers and being operable to execute operations upon register operands held in said registers as specified within instructions of a first instruction set; and<br>
an instruction translator (108) operable to translate instructions of a second instruction set into translator output signals corresponding to instructions of said first instruction set, instructions of said second instruction set specifying operations to be executed upon stack operands held in a stack; wherein said instruction translator (108) is operable to allocate a set of registers within said register bank (106) to hold stack operands from a portion of said stack;<br>
said instruction translator, (108) has a plurality of mapping states in which different registers within said set of registers hold respective stack operands from different positions within said portion of said stack; and<br>
said instruction translator (108) is operable to change between mapping states in dependence upon operations that add or remove stack operands held within said set of registers; and wherein said instruction translator (108) uses a plurality of instruction templates for translating instructions from said second instruction set to instructions from said first instruction set; and<br>
an instruction from said second set comprising one or more stack operands has an instruction template comprising one or more instructions from said first instruction set in which register operands are mapped to said stack operands in dependence upon a currently adopted mapping state of said instruction translator.<br><br>
Apparatus as claimed in claim 1, wherein said translator output signals comprise signals forming an instruction of said first instruction set.<br>
Apparatus as claimed in any one of claims 1 and 2, wherein said translator output signals comprise control signals that control operation of said processor core and said control signals match control signals produced on decoding instructions of said first instruction set.<br>
Apparatus as claimed in any one of claims 1, 2 and 3, wherein said translator output signals comprise control signals that control operation of said processor core (104) and specify parameters not specified by control signals produced on decoding instructions of said first instruction set.<br>
Apparatus as claimed in any one of the preceding claims, wherein said instruction translator (108) provides mapping states such that stack operands are added to or removed from said set of registers without moving stack operands between registers within said set of registers.<br>
Apparatus as claimed in any one of the preceding claims, wherein said set of registers are operable to hold stack operands from a top portion of said stack comprising a top of stack operand from a top position within said stack.<br>
Apparatus as claimed in any one of the preceding claims, wherein said stack further comprises a plurality of addressable memory locations holding stack operands.<br><br>
Apparatus as claimed in claim 7, wherein stack operands overflow from said set of registers into said plurality of addressable memory locations.<br>
9.	Apparatus as claimed in any one of claims 7 and 8, wherein stack operands held within said plurality of addressable memory locations are loaded into said set of registers prior to use.<br>
10.	Apparatus  as claimed in  any one  of the  preceding claims, wherein said instruction translator comprises one or more of: hardware translation logic; and<br>
hardware compiling logic.<br><br>
11.	Apparatus as claimed in any one of the preceding claims, wherein said instruction translator comprises a first plurality of state bits indicative of a number of stack operands held within said set of registers.<br>
12.	Apparatus as claimed in claim 6 and any one of claims 5 and 7 to 11, wherein said instruction translator comprises a second plurality of state bits indicative of which register within said set of registers holds said top of stack operand.<br>
13.	A method of processing data using a processor core having a register bank containing a plurality of registers and being operable to execute operations upon register operands held in said registers as specified within instruction of a first instruction set, said method comprising an instruction translator (108) for :<br><br>
translating   instructions   of   a   second   instruction   set   into<br>
translator output signals corresponding to instructions of said<br>
first instruction set using a plurality of instruction templates<br>
instructions of said second instruction set specifying operations<br>
to be executed upon stack operands held in a stack;<br>
allocating a set of registers within said register bank to hold<br>
stack operands from a portion of said stack;<br>
adopting one of a plurality of mapping states in which different<br>
registers  within   said  set  of registers  hold  respective   stack<br>
operands from different positions within said portion of said<br>
stack;<br>
wherein   an   instruction   from   said   second   instruction   set<br>
including  one  or  more  stack  operands  has  an   instruction<br>
template comprising one or more instructions from said first<br>
instruction set in which register operands are mapped to said<br>
stack   operands   in   dependence   upon   a   currently   adopted<br>
mapping state of said instruction translator; and<br>
changing   between    said   plurality    of   mapping    states    in<br>
dependence upon operations that add or remove stack operands<br>
held within said set of registers.<br>
Dated this the 17th day of September, 2002<br>
    [ JAYANTA PAL]<br>
Of Remfry &amp; Sagar<br>
ATTORNEY FOR THE APPLICANT[S]<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWNhbmNlbGxlZCBwYWdlcygxMC0wMy0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-cancelled pages(10-03-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWNsYWltcyhncmFudGVkKS0oMTAtMDMtMjAwNikuZG9j" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-claims(granted)-(10-03-2006).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWNsYWltcyhncmFudGVkKS0oMTAtMDMtMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-claims(granted)-(10-03-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWNvcnJlc3BvbmRlbmNlKDEwLTAzLTIwMDYpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-correspondence(10-03-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWNvcnJlc3BvbmRlbmNlKGlwbyktKDA3LTEyLTIwMDYpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-correspondence(ipo)-(07-12-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWRyYXdpbmcoMzEtMDEtMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-drawing(31-01-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWZvcm0gMTkoMzAtMTItMjAwNCkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-form 19(30-12-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWZvcm0gMWEoMTAtMDMtMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-form 1a(10-03-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWZvcm0gMWEoMTctMDktMjAwMikucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-form 1a(17-09-2002).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWZvcm0gMihncmFudGVkKS0oMTAtMDMtMjAwNikuZG9j" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-form 2(granted)-(10-03-2006).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWZvcm0gMihncmFudGVkKS0oMTAtMDMtMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-form 2(granted)-(10-03-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWZvcm0gMygxNy0wOS0yMDAyKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-form 3(17-09-2002).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWZvcm0gMygzMC0wMS0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-form 3(30-01-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWZvcm0gMygzMS0wMS0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-form 3(31-01-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWZvcm0gNCgwNy0wMi0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-form 4(07-02-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLWZvcm0gNSgxNy0wOS0yMDAyKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-form 5(17-09-2002).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLXBjdC1pcGVhLTQwOSgxNy0wOS0yMDAyKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-pct-ipea-409(17-09-2002).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLXBjdC1pc2EtMjEwKDE3LTA5LTIwMDIpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-pct-isa-210(17-09-2002).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLXBldGl0aW9uIHVuZGVyIHJ1bGUgMTM3KDMxLTAxLTIwMDYpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-petition under rule 137(31-01-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDItMDEyNzctbXVtLXBvd2VyIG9mIGF1dGhvcml0eSgxMS0xMC0yMDAyKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2002-01277-mum-power of authority(11-10-2002).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="202721-a-prolonged-release-medicament-for-treating-primary-insomnia.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="202723-an-electric-switching-device-for-alternating-current.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>202722</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2002/01277/MUM</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>15/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>13-Apr-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>09-Jun-2006</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>17-Sep-2002</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>ARM LIMITED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>110 FULBOURN ROAD, CHERRY HINTON, CAMBRIDGE CB1 9NJ, UNITED KINGDOM.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>EDWARD COLLES NEVILL</td>
											<td>HOLLY HOUSE, 16 HIGH STREET, HEMINGFORD GREY, HUNTINGDON PE18 9DR, ENGLAND.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>ANDREW CHRISTOPHER ROSE</td>
											<td>69 FULBOURN ROAD, CHERRY HINTON, CAMBRIDGE CB1 9JL, ENGLAND.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/GB01/02776</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2001-06-21</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>0024404.6</td>
									<td>2000-10-05</td>
								    <td>U.K.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/202722-an-apparatus-and-method-for-processing-data by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:33:48 GMT -->
</html>
