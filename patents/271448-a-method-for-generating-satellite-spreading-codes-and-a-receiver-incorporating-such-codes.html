<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/271448-a-method-for-generating-satellite-spreading-codes-and-a-receiver-incorporating-such-codes by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:28:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 271448:A METHOD FOR GENERATING SATELLITE SPREADING CODES AND A RECEIVER INCORPORATING SUCH CODES</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD FOR GENERATING SATELLITE SPREADING CODES AND A RECEIVER INCORPORATING SUCH CODES</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>One embodiment of the invention provides a method of creating a set of secondary spreading codes for use in a satellite navigation system comprising a constellation of satellites. Each satellite in the constellation employs a tiered spreading code comprising at least a primary code and a secondary code. Each satellite in the constellation is allocated a different secondary spreading code from the set of secondary spreading codes. The method involves generating an initial set of bit pattems, where each bit pattem represents a potential secondary spreading code. The method further involves performing an optimization process on bit patterns within the initial set of bit pattems. As a result of the optimization, at least some of the bit pattems in the initial set are modified or replaced, to create a final set of bit pattems for use as the set of secondary spreading codes.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
SPREADING CODES FOR A SATELLITE NAVIGATION SYSTEM<br>
Field of the Invention<br>
The present invention relates to the generation and use of spreading codes for a satellite navigation system.<br>
Backgroimd of the Invention<br>
Satellite navigation systems are becoming increasingly important in a wide range of applications, including handheld devices for position determination, in-car navigation support, and so on. The main satellite navigation system in service at present is the global positioning system (GPS) operated by the United States Department of Defense. Worldwide sales of GPS equipment reached nearly 3.5 billion dollars by 2003, and this figure is expected to grow steadily over the next few years. A European counterpart satellite navigation system, named Galileo, is planned for launch and service availability later this decade.<br>
A satellite navigation system comprises a constellation of satellites that each broadcasts one or more signals to earth. The basic components of a satellite signal are a spreading code (also referred to as a positioning, synchronisation or ranging code) which is combined with navigation data. The resulting combination is then modulated onto a carrier at a set firequency for transmission to earth. Each satellite generally transmits at multiple fi'equencies, which can help to compensate for any atmospheric distortion.<br>
In some cases, multiple signals (referred to as channels) may be modulated onto a single carrier via some appropriate multiplexing scheme. For example, it is planned for certain Galileo signals to comprise a data channel in phase quadrature with a pilot channel. The pilot channel contains only a spreading code, but no navigation data, while the data channel contains both the spreading code and the navigation data.<br><br>
The spreading code component of a satellite signal typically comprises a predetermined sequence of bits (sometimes referred to as 'chips') and is used to perform two main tasks. Firstly, the spreading code provides a synchronisation mechanism to allow a receiver to lock onto a satellite signal. Thus each satellite (and typically each channel broadcast from that satellite) has its own synchronisation code. When a receiver is first switched on, it does not know which satellite signals can be received, since certain satellites in the constellation will be below the horizx)n for that particular location at that particular time. The receiver uses the synchronisation codes to lock into a signal from a first satellite. Once this has been done, the navigation data in the signal can be accessed. This then provides ephemeris data for the other satellites in the constellation, and allows the remaining satellites that are visible to the receiver to be acquired relatively quickly.<br>
Many receivers employ a two-phase acquisition process. In the first phase, the receiver performs a simultaneous cross-correlation of the incoming signal against the set of all possible signals. This searches for a signal from any satellite, with any possible timing offset between the satellite and the receiver, and with any possible Doppler shift between the satellite and the receiver (which is dependent on the motion of the satellite in space). If a cross-correlation is found to exceed a predetermined threshold, then a second phase involving a more detailed analysis is performed for the relevant combination of satellite, timing offset and Doppler shift. This second-phase analysis may, for example, involve a longer integration time, an attempt to access and decode the navigation data, etc, in order to confirm that a correct acquisition has been made.<br>
The second main task of a spreading code is to provide a distance estimate from the satellite to the receiver, based on the time that it has taken the signal to travel from the satellite to the receiver, which can be expressed as: c(Tr-Zi), where: c is the velocity of light (known, subject to ionospheric effects, etc), Ts is the time of sending from the satellite, which is encoded into the signal itself, and Tr is the time of signal receipt at the receiver.<br><br>
The position of the receiver can then be determined in three-dimensional space by using a process of trilateration, given the known positions of the satellites (as specified in their navigation data). In theory, this can be performed with signal information from a minimum of three satellites. In practice however we can write Tr = Tm-^o, where Tm is the measured time of receipt at the receiver, and o is ttte offset between the receiver clock and satellite clock, which is generally unknown, except for specialised receivers. This then implies that signal information is obtained from at least one additional satellite to compensate for the unknown time offset at the receiver. If signals from further satellites are available, a statistical position determination can be performed using any appropriate algorithm such as least squares. This can also provide some indication of the error associated with an estimated position.<br>
One important parameter for the spreading code is the bit rate at which the spreading code is transmitted^ since this in turn controls the accuracy with which the positional determination can be made. For example, with a bit rate of 1 MHz, each bit represents a light travel time of 300 metres. The positioning accuracy is then determined by how accurately the phase offset between the satellite and the receiver can be judged for a single bit. This is generally dependent upon the noise in the system. For example, if the phase offset can be measured to an accuracy of 90 degrees (7i/2), this corresponds to a positional determination of 75 metres. It will be appreciated that having a higher bit rate for the spreading code allows more accurate position determinations to be made.<br>
Another important parameter for the spreading code is its total length, in other words the mmiber of bits or chips in the spreading code before it repeats. One reason for this is that the finite length of the spreading code can lead to ambiguity in the position determination. For example, assume that the bit rate is 10 MHz and the total length of the bit sequence is 256 bits, which therefore corresponds to a light travel time of 7.68 km. As a result, the distance measurement from the satellite to Ihe receiver is not uniquely specified, but rather can only be expressed as 7.68n H- c/km, where d is determined by the relative timing of the spreading code as broadcast and as received, but y? is an unknown integer. There are various ways in which the ambiguity as to the value of n can be resolved, including using signals from a larger number of satelhtes, or by using knowledge of an approximate position derived from some other source.<br><br>
One conmion approach is to relate the code phase to the bit edge of the navigation data bit (this process is called bit synchronization), and also to relate the bit edge to the time of week (ToW) contained in the navigation data transmitted by the satellite.<br>
It will be appreciated that increasing the repetition length for the spreading code helps to reduce problems with ambiguous distance determinations. A longer length for the spreading code also provides better separation of signals from different sources, and increased robustness against interference. On the other hand, having a longer repetition length for the spreading code may delay initial acquisition of the signal, as well as requiring more processing capability within the receiver. The length of the spreading code also impacts the data rate that can be used for the navigation data, since there is normally only one bit of navigation data for each complete spreading code sequence (otherwise the two would interfere). Therefore, the longer the repetition length for the spreading code, the lower the bit rate for the navigation data.<br>
One known strategy to counter this problem is to xxse a hierarchical or tiered spreading code based on primary and secondary codes. If we assume that the primary code has Nl bits and tiie secondary code has N2 bits, then the first Nl bits of the overall spreading code correspond to the primary sequence exclusive-ORed with the first bit of the secondary code, the next Nl bits of the spreading code comprise a repeat of the Nl bits of the primary code, this time exclusive-ORed with the second bit of the secondary code, and so on. This gives a total repetition length for the code of NlxN2. However, the repetition length for synchronisation purposes is only Nl, since the primary code v^U still give a correlation peak irrespective of the value of the bit from the secondary code (this will just change the sign of the correlation peak). Likewise, the bit rate of the navigation data is dependent on the length of the primary code alone (Nl), rather than the length of the primary and secondary codes combined (N1*N2).<br>
The GPS spreading codes are implemented using linear feedback shift registers (LFSRs), in which selected outputs from an N-stage shift register are tapped and fed back to the input. The feedback connections within the LFSR can be rqjresented as a polynomial of order N, whereby the operation of an LFSR can be fully specified by its polynomial and the initial setting of the LFSR.<br><br>
GPS uses a subset of LFSRs known as Gold codes that have certain special mathematical properties. One of these is that they generate an output of pseudo-random noise having a maximal repetition length of 2^-1, so that a relatively compact LFSR can generate an output with a long repetition length. Gold codes also have good auto-correlation properties that support accurate positioning. In particular, the autocorrelation function has a well-defined peak at zero time shift, and is relatively small for all other (i.e. non-zero) time shifts. It is also possible to select a set of Gold codes that have good cross-correlation properties, whereby the cross-correlation fimction between different codes is kept relatively small. This is important for signal acquisition, since it helps to prevent a synchronisation code from one satellite being accidentally mistaken for a synchronisation code from another satellite. A further important practical criterion for a spreading code is to have equal (or nearly equal) numbers of ones and zeros - this is referred to as balancing.<br>
Additional information about satellite navigation systems, and in particular about GPS, can be found in: "Re-Tooling the Global Positioning System" by Per Enge, p64-71, Scientific American, May 2004, and in "Global Positioning System: Signals, Measurements and Performance", by Misra and Enge, Ganga-Jamuna Press, 2001, ISBN 0-9709544-0-9. Information about the proposed Galileo signals can be foxmd in: "Status of Galileo Frequency and Signal Design" by Hein et al, September 2002, available from:<br>
ht^://europa.eu.int/comn[i/dgs/energy_transport/galileo/doc/galileo_stf_ioii2002.pdf, see also "Galileo Frequency and Signal Design" by Issler et al, GPS World, Jun 2003, available from: ht^://www.gpsworld.com/gpsworld/article/articleDetail.jsp?id=61244. A proposed Galileo/GPS receiver is described in: "HIGAPS - A Large-Scale Integrated Combined Galileo/GPS Chipset for the Consumer Market" by Heinrichs et al, available from http://forschung.unibw-muenchen.de/papers/krc5ejjflurjj9jsndc4spthvmg0be.pdf.<br>
Although the use of Gold codes is well-established for existing satellite navigation systems, there are some limitations associated with such codes. For example, they are only available with certain code lengths (not all values of N can be used for the LFSR polynomial). In general, the code length is determined by the ratio of the chip rate of the spreading code and<br><br>
the bit rate of the navigation data. If the code length is restricted to an available Gold code, then this implies a constraint on the chip rate and the bit rate, which might in turn impact other considerations, such as acquisition time and positioning accuracy. In some cases, the limitation on code length for Gold codes has been overcome by using truncated Gold codes, but this truncation has an adverse impact on the mathematical properties of the code set (in terms of the autocorrelation function, etc).<br>
In addition, the cross-correlation properties of Gold codes are not generally optimised for the situation where the polarity of the code changes fix)m one repetition of the code to the next, in accordance with the navigation data that is being transmitted. This latter problem is exacerbated where the bit rate of the navigation data is relatively high (as for Galileo), since this leads to a significant probability that a spreading code transmission has the opposite polarity from the immediately preceding transmission of the spreading code. (This is also the reason for the provision of pilot channels in Galileo, in order to aid acqmsition without disruption by the navigation data).<br>
Cross-correlation properties are also of particular concern for locations having relatively poor signal reception, such as inside a building. In this case a first signal from one satellite may be strong, for example, if there is a line of sight to the satellite through a window, while a second signal from another satellite may be substantially weaker, for example, if the line of sight to the second satellite passes through significant buildmg structure. In this situation, if an attempt is made to acquire the second satellite, there is a risk that the correlation against the stronger but incorrect first signal may yield a greater (or similar) result than the correlation against the weaker but correct second signal. Although any resulting misidentification of the first signal as the second signal will normally be corrected later in a subsequent acquisition phase, this introduces delays, as the acquisition procedure then has to return to the first phase- If there are multiple such misidentifications, acquisition time may be increased significantly.<br>
Summary of the Invention<br><br>
Accordingly-, one embodiment of the invention provides a method of creating a set of secondary spreading codes for use in a satellite navigation system comprising a constellation of satellites. Each satellite in the constellation employs a tiered spreading code comprising at least a primary code and a secondary code. Each satellite in the constellation is allocated a different secondary spreading code from the set of secondary spreading codes. The method comprises generating an initial set of bit patterns, where each bit pattern represents a potential secondary spreading code. The method further comprises performing an optimisation process on bit patterns within the mitial set of bit patterns so that at least some of the bit patterns in the initial set are modified or replaced, thereby creating a final set of bit patterns for use as the set of secondary spreading codes.<br>
The provision of different secondary codes for different satellites has been found to reduce correlation between the codes from the different satellites, and so helps with improved receiver performance. The use of an optimisation process to determine the set of secondary codes offers more flexibility than codes sets based on mathematical algorithms (such as Gold codes), for example in terais of the length of the secondary code, the number of codes available in a set, and the particular properties of the codes.<br>
In one embodiment, the bit patterns in the initial set of bit patterns comprise random sequences of bits, although any other suitable starting patterns may be used, for example as generated by linear feedback shift registers or some other pseudo-random algorithm. Note that the use of randomly created initial bit patterns generally helps to ensure good coverage of the overall search space for potential secondary codes. During the optimisation process, the bit patterns may be modified by randomly flipping a bit in at least one of the bit patterns- For longer secondary codes it may be desirable to flip multiple bits during at least the initial part of the optimisation process in order to speed convergence, although since the secondary codes are usually relatively short (compared to the overall length of a tiered code), flipping just a single bit of the code for each iteration has generally been found to give a reasonable speed of convergence. The bit modifications may be reversed if it is found that they lead to decreased performance (thereby ensuring liiat the set of bit patterns does not deteriorate), although such<br><br>
decreased performance may be accepted on a probabilistic basis (especially if the decrease is not too great) in order to give the optimisation the ability to escape from local maxima.<br>
It will be appreciated that there is a wide variety of knovm optimisation strategies, such as simulated annealing, genetic algorithms, and so on, and any suitable such strategy may be employed to create the final set of bit patterns. In some of these strategies, the optimisation may involve the generation of a larger population of bit patterns followed by selection of the best examples (e.g. survival of the fittest), while o&amp;xev strategies may be based on continuous modification of individual bit patterns within a predetermined set.<br>
In one embodiment, the optimisation process includes rejecting bit patterns that fail a balance criterion, thereby ensuring that there is relatively little DC component in the codes. The balance criterion may be based on the square root of the number of bits in a bit pattern, which reflects the expected DC component for a random code. Note that in other embodiments, code balance might be included as part of the formal optimisation - i.e. the optimisation works to reduce balance, rather than simply rejecting bit patterns with a balance that is greater than a given threshold. Another possibility is that once bit patterns having good balance properties have been identified, then the optimisation process is arranged to leave the balance invariant (such as by selecting pairs of bits to flip, one being a 0 and one being a 1), Other code criteria that might be handled in a similar manner to balance include the maximum run length of a particular bit value (either one and/or zero).<br>
In one embodiment, the optimisation process utilises a performance (or cost) function derived from the auto-correlation function for a bit pattern. This can be used to select bit patterns that have good individual properties. A performance or cost function derived fi:om the cross correlation function can tiien be used to select a group of bit patterns that in combination form a good set of codes. It will be appreciated that minimal side-lobes in the auto-correlation function lead to a better acquisition properties, for example, the signal can be acquired more easily imder poor reception conditions, such as indoors and irnder tree foliage, while minimum cross-correlation with other codes reduces multiple access interference and intra-system noise, thereby increasing the robustness of signal acquisition, tracking, and data demodulation.<br><br>
The optimisation process may include a first phase of identifying bit patterns having good individual properties, and a second phase of selecting the set of secondary spreading codes from the identified bit patterns having good individual properties. The number of bit patterns identified as having good individual properties may be significantly higher than the number of satellites in the constellation. For example, the first phase may identify a group of 250 or more bit patterns that have good individual properties. Such a group then provides a good range of choice during the second phase of the optimisation, as well as accommodating potential uses of the codes outside the satellite constellation itself- e.g. in pseudolites, as discussed in more detail below, which can lead to a requirement for a larger number of potential codes.<br>
The use of first and second phases for the optimisation has been found to be a convenient and effective approach for performing the optimisation. However, other embodiments might only use a single phase of optimisation that is performed directly on groups of bit patterns.<br>
In one embodiment, the second phase includes calculating the cross correlation function between every pair of identified bit patterns havkig good individual properties. This exhaustive search of all possible combinations has been found to be more efficient computationally than an iterative search of potential sets of bit patterns, although the latter approach might be used if appropriate (for example, if the number of identified bit patterns is very large).<br>
In one embodiment, the number of bits in a bit pattern for a secondary code is in the range 25 to 512, more particularly in the range 50 to 128. Note that for very short secondary code lengths, the available code space can be searched exhaustively to determine a suitable set of bit patterns (rafiier than using a form of optimisation procedure as described herein).<br>
Another embodunent of the invention provides a receiver incorporating a final set of bit patterns created using the above method. The bit patterns in the receiver may be protected by an error-correcting code. The receiver may have at least one read only memory (ROM) that stores )     the secondary code portions of the tiered spreading codes^ and optionally the primary code<br><br>
portions as well. In some receivers, it may be possible to update this ROM, for example to reflect any changes to the spreading codes emitted from the satellites.<br>
In some implementations, the receiver may incorporate bit patterns for at least two satellite constellations, for example Galileo and GPS. Note that the GPS spreading codes are Gold codes, and are normally generated within a receiver using a linear feedback shift register. However, the GPS codes could be stored as complete bit patterns if it is desired to have a single consistent approach to be used for multiple satellite navigation systems.<br>
Note that there are various ways in which the bit patterns may be provided to the receiver. For example, in some embodiments the bit patterns may be pre-installed into the receiver. In some embodiments, the bit patterns may be installed (or upgraded) into the receiver via some form of removable memory device, such as flash memory. In some embodiments, the bit patterns may be installed (or upgraded) into the receiver over a network, for example by downloading over the Internet or over a mobile telephone network (the latter is particularly convenient if the receiver itself is incorporated into some form of mobile telephone device). With this latter approach, the codes need not necessarily be stored in the receiver itself, but rather may just be accessed as and when required over the network.<br>
Accordingly another embodiment of the invention provides a method of operating a server that communicates with receivers for use in conjunction with a satellite navigation system. The method comprises storing a set of bit patterns corresponding to secondary codes used by the satellite navigation system, and in response to a received request from a receiver to access the set of stored bit patterns, supplying the stored bit patterns to the receiver for use in acquiring signals from the satellite navigation system. The bit patterns may be supplied over the telephone network, the Internet, or any other suitable network.<br>
Another embodiment of the invention provides a satellite incorporating one or more bit patterns from a final set of bit patterns created using a method such as described above. One or more such bit patterns can also be incorporated into a pseudolite. (A pseudolite generates an analogous positioning signal to that from a navigation satellite, but a pseudolite is ground-based.<br><br>
and is typically employed at locations where high accxxracy is required, for example around airports, to augment positioning signals from satellites).<br>
The approach described herein allows a decision on the final form of the secondary spreading codes to be delayed until a very late stage of system development, since the hardware (e.g. a memory device) need not be specific to a given code (unlike a particular LFSR), Furthermore, it may be possible to update the bit patterns stored in a satellite already in orbit. Such updating may be performed in response to a detected error in the stored bit pattern (perhaps induced by a cosmic ray), as well as being useful for in-orbit testing of codes during the last phase of implementation or commissioning. The update facility is also beneficial if it becomes desirable to transmit a different code from that originally planned, for example because of interference with other services, or because certain slots have been re-allocated. In such circumstances it will generally be required to perform a corresponding update to the receivers, although another reason for updating may be to restrict the set of users that can access the spreading code from the satellite (either for commercial or security reasons).<br>
Note that although the approach described herein is primarily intended for use in satellite navigation systems (including pseudolites), it could also be employed in other navigation or communication systems (satellite, terrestrial or maritime) that have previously used LFSRs to generate synchronisation codes and such-like.<br>
Brief Description of the Dravyings<br>
Various embodiments of the invention will now be described in detail by way of example only with reference to the following drawings:<br>
Figure 1A illustrates simulated cross-correlation function (CCF) performance between the first two tiered spreading codes sharing a common secondary code for the originally proposed Galileo E5A-Q pilot signals;<br>
Figure IB illustrates sknulated cross-correlation function performance between the first two tiered spreading codes sharing a common secondary code for the originally proposed Galileo E5B-Q pilot signals;<br><br>
Figure 2 illustrates simulated cross-correlation function (CCF) performance between the first two tiered spreading codes sharing a common secondary code for the Galileo E5 A-Q pilot signals with a lOHz Doppler frequency offset;<br>
Figure 3A illustrates simulated cross-correlation function (CCF) performance using different secondary codes for the Galileo E5A-Q pilot signals in accordance with one embodiment of the invention;<br>
Figure 3B illustrates simulated cross-correlation function (CCF) performance using different secondary codes for the Galileo E5B-Q pilot signals in accordance with one embodiment of the invention;<br>
Figure 3C illustrates simulated cross-correlation function (CCF) performance using different secondary codes for the Galileo E5A-Q pilot signals in accordance with one embodiment of the invention, with the inclusion of a lOHz Doppler frequency offset;<br>
Figure 4 is a high-level flowchart illustrating a method for generating secondary spreading codes in accordance with one embodiment of the invention;<br>
Figure 5 is a flowchart illustrating part of the method of Figure 4 in more detail in accordance with one embodiment of the invention;<br>
Figure 6A is a plot of CCF performance for a 50 member group of secondary codes for zero Doppler shifl generated in accordance with one embodiment of the invention;<br>
Figure 6B is a plot of CCF performance for the same 50 member group of secondary codes generated in accordance with one embodiment of the invention as shov^oi in Figure 6A, but averaged across a range of Doppler shifts;<br>
Figure 7 is a high-level schematic diagram of a subsystem for generating a tiered code in accordance with one embodiment of the invention;<br>
Figure 8A is a high-level schematic diagram of a satellite system in accordance with one embodiment of the invention; and<br>
Figure 8B is a high-level schematic diagram of a receiver system in accordance with one embodiment of the invention.<br>
Detailed Description<br>
The following abbreviations are used in the present description:<br><br>
ACF	Auto Correlation Fionction<br>
BPSK	Binary Phase Shift Keying<br>
CCF	Cross Correlation Function<br>
CRC	Cyclic Redundancy Code<br>
CS	Commercial Service<br>
CT	Crosstalk<br>
DC	Direct Current (zero frequency component)<br>
ECC	Error Correcting Code<br>
ELW	Excess Line Weight<br>
HNV	Highest Neighbour Value<br>
LFSR	Linear Feedback Shift Register<br>
MEWSD	Mean Excess Welch Square Distance<br>
MP	Multipath<br>
NV	Neighbour Value<br>
PROM	Programmable Read Only Memory<br>
PSK	Phase Shift Keying<br>
RMS	Root Mean Square<br>
ROM	Read Only Memory<br>
Note also that within this description code sequences are defined for convenience in logic level format (0 and 1); in practice these code sequences are translated to bipolar (±1) signal levels for modulation and correlation purposes. The mapping between the spreading code logic levels and corresponding signal levels in accordance with one embodiment of the invention is shown in Table L<br><br>
Table 2 summarises the proposed main ranging code parameters for each Galileo signal component for various services (0S= open service, CS= closed service, SoL= safety of life service). This table excludes the public regulated service (PRS) spreading codes that use cryptographically generated pseudo-random sequences.<br><br><br>
The proposed Galileo spreading code sequence lengths and construction method take into account various signal paranaeters and performance-related requirements. For all the signal codes shown above the overall sequence lengths have been chosen to be equal to one symbol period for the data signals or 100ms for the pilot signals. For compatibility reasons with GPS, the chipping rates are all multiples of 1.023MHz. As can be seen most of the codes use a tiered approach whereby a primary code is repeated in order to achieve the required overall code sequence length, which is equal to the product of the primary and secondary code lengths. The tiered code approach simplifies the generation of long spreading codes and allows a receiver to acquire the signals just using the primary code sequences, if required, in order to minimise acquisition times.<br>
Note that a shorter primary code length of 5115 has now been adopted for the commercial service (CS) pilot code on E6 to match that of the corresponding data spreading code, which would be beneficial where both the data and pilot signals are combined for acquisition purposes. As a result, the 50 bit secondary code length as previously proposed would be increased to 100 bits. Therefore, the families of 50 bit secondary codes described later may no longer be needed for the currently proposed Galileo signal on E6-C, which coxild instead make use of the same 100 bit codes as developed for the E5 pilot signals (and as described in more detail below).<br><br>
Each Galileo satellite uses an independent primary code for each signal component in order to provide basic CDMA operation. The primary codes proposed for the E5 signals are based on a family of Gold codes that are generated from the product of a pair of LFSRs (Linear Feedback Shift Registers), while the codes currently proposed for E6-B&amp;C and Ll-B&amp;C use a family of primary codes based on the active optimisation of random codes, as described in PCX application PCT/EP2004/014488.<br>
Table 3 lists the secondary codes previously proposed for the Galileo system, in which the secondary code indicated would be used as a common secondary code for all the corresponding primary code family members. (Note that only certain of the codes have been allocated to particular Galileo signals, as indicated in Table 3; in addition. Table 3 does not reflect the change of the E6-C signal secondary code from 50 bits to 100 bits).<br><br>
Figure 1A illustrates the simulated cross-correlation function (CCF) performance between the first two tiered spreading codes for the E5 pilot signals, assuming that the E5A-Q signal codes all share the same 100 chip CSioob secondary code. The primary codes are all 10230 chips in length so the overall tiered code length is 1023000 chips (100ms). Figure IB shows similar CCF results for the first two E5B-Q pilot signal codes, which share the same CSiood secondary code. No Doppler offset has been included in these simulations (i.e. the plots<br><br>
have been calculated for zero Doppler frequency offset between the two received spreading codes).<br>
As can be seen the CCF performance is generally very good (
One possible approach to try to eliminate the high CCF peaks might be to deliberately offset the common secondary code in time between different satellites. However this would require code sequence time shifts of 40ms between the different satellites, and since the maximum tiered code length is 100ms (for pilot signals) then we can only re-use each code tsvice. Even if we also allow tiie same codes to be used for anti-podal satellites, this is still only sufficient for a total of 4 satellites and not the 30 included in the Galileo constellation.<br>
Another possible approach would be to increase tiie pilot code lengths furttier. However, this is not considered attractive, due to the long integration times required and the corresponding impact on receiver design.<br>
The long pilot code sequences of 100ms are sensitive to Doppler offsets. In fact, a Doppler offset of only lOHz introduces a complete cycle of phase shift onto one sequence with respect to tiie other, thereby causmg half of the sequence to be inverted. This completely changes the CCF as can be seen in Figure 2, which shows the CCF for the E5A-Q pilot codes using a common secondary code with a lOHz Doppler frequency offset. The effect of the lOHz Doppler offset on these E5A pilot signals reduces the worst case CCF levels from -30 to -42dB with respect to ttie corresponding maximum ACF level for a single code. The distribution of<br><br>
Doppler frequency shifts between pairs of satellites is approximately linear up to the maximum value of 6.7kHz for the proposed Galileo satellite constellation.<br>
The effective chip rate of the secondary codes depends on the repetition rates of the corresponding primary codes. Since the secondary codes considered in Figure 2 are used for the 100ms pilot signal components, the effective chip rate is simply NxlOHz, where N is the secondary code length, corresponding to 500Hz and lOOOHz for 50 bit and 100 bit secondary codes respectively. When the Doppler frequ^icy offset is equal to these effective chip rates then the phase change per secondary code chip becomes 2n, after which the Doppler effect repeats. Note that this condition does not apply for the underlying primary codes and so the CCF of the overall tiered code will not be seen to repeat at these frequency intervals.<br>
Therefore, for tracking purposes, the combined probability of other satellites having both a relative Doppler shift below lOHz and a relative timing error of less than 1ms is quite small. As a result, the overall impact of the -30dB CCF maximum peaks is significantly reduced. (Note that for the shorter 50 bit secondary codes, the region of relevant time error increases to 2ms, but the impact is still fairly low).<br>
Nevertheless, during initial acquisition modes, when a wide range of frequency and time shifts have to be searched, the relatively high subsidiary CCF peaks from using common secondary codes are likely to cause undesirable false detections. This may reduce performance under difficult acquisition conditions, such as for indoor appUcations, where large variations between satellite signal levels can be expected.<br>
Figure 3 A illustrates how the CCF performance can be improved by using different secondary codes for each primary code. In Figure 3A, the tiered code for E5A-Q code 1 has been modified to use the CSiooa secondary code and the CCF re-calculated. No Doppler frequency offset is included. As can be seen, the worst case CCF side-lobes have been reduced to less than -42dB, which is a 12dB improvement under this zero Doppler condition.<br><br>
As confirmation, Figure 3B illustrates the CCF for the E5B-Q pilot codes 1 and 2 where the secondary code for tiered code 1 has be^i changed to CSiooc- Again, the worst-case CCF sidelobes have been reduced to approximately -42dB, which is the same as shown previously for the E5A pilot codes when using different secondary codes-Figure 3C depicts the CCF for the two E5A pilot signals using different secondary codes, but this time with a lOHz Doppler frequency offset. This shows a slightly degraded CCF performance compared to Figure 3 A, with a worst-case peak of-40dB.<br>
hi order to use different secondary codes for different satellites, sufficient code members of suitable quality to be used with each satellite's primary code must be foxmd. For an N bit code there are a total of 2^^ possible code combinations, but only a limited number of these will have independent code properties. For example, each code can be inverted or reversed and will still have identical code properties; likewise each code sequence can be cyclically rotated by the number of chips in the code length and still retain identical code properties. Therefore, for an N bit code the maximum number of independent codes (CN) is;<br>
CN = 2^/(4.N)<br>
(Note that this formula is approximate and represents an upper bound only, since it includes for example codes that are symmetrical, i.e. forward and reverse equal, and/or that contain repeated sequences, which are xmlikely to provide useful codes). Nevertheless, the above formula can be applied to the secondary code lengths considered for the Galileo signals to estimate the number of independent codes available for the secondary codes, as listed in Table 4.<br><br><br>
For the shorter secondary codes of 25 bits or less, it is computationally feasible with current facilities to carry out exhaustive searches of all code possibilities in order to find those with acceptable (or optimum) properties. However, for the longer 50 and 100 bit secondary codes there are too many possible codes for it to be practical to search exhaustively using current computational facilities. Nevertheless, good performance can be obtained for 50 and 100 bit baseline codes by using a random code starting point, and then performing a chip-wise optimisation process. In fact, since there are more choices available for longer codes, in general this allows more stringent optimisation or selection criteria to be applied in respect of such codes.<br>
In order to find suitable families of secondary codes, a two-stage search process as illustrated in the flowchart of Figure 4 was adopted in accordance with one embodiment of the present invention. Firstly a pool of candidate secondary codes was foxind (405), where the candidates individually had good ACF, ELW and DC balance properties (as described in more detail below). Secondly, from the pool of candidate codes found, candidate codes that were not mutually independent were deleted (410), and a group or family of secondary codes having good mutual CCF properties was selected (415) (in fact several groups were selected, depending on different selection criteria).<br>
One or more selection criteria are required in order to identify and select codes with good properties. Important parameters for such a selection are the auto-correlation function (ACF), the excess line weight (ELW) and code balance. The excess line weight (ELW) criterion is defined as the dB power ratio between the highest spreading code spectral line with respect to the overall RMS value. A code's DC balance criterion is simply the sum of all the code chips, assuming signal notation (±1) is used, and corresponds to the zero frequency (DC) component of the code spectrum.<br>
For ACF performance, two different sub-criteria may be used. The first of these is highest neighbour value (HNV), which is an indication of the height difference between the ACF peak and the next biggest peak. In one embodiment, for the pilot codes that use long secondary codes, this criterion is defined as:<br><br>
HNVp = (N/HNV)^    where N == code length in chips.<br>
The second ACF criterion is a merit factor (MF), which is determined from the average of all the ACF neighbour values.<br>
MFp = N V E NV^     where NV are the neighbour values.<br>
An overall selection criterion can then be defined as follows: Perfomiance = HNVp + MFp/100 - ELW<br>
Although the code balance criterion doesn't appear directly within this overall performance parameter, it is used to reject all codes where:<br>
jDC balance] &gt; V N    where N = code length in chips. (Note that this threshold is the average DC value to be expected for a random code sequence).<br>
Using these criteria, Table 5 shows the performance for the 50 and 100 bit secondary codes from Table 3. Note that the actual ACF HNVs are 6 for the 50 bit codes and 8 for the 100 bit secondary codes.<br><br>
As stated earlier the number of possible codes for the longer 50 and 100 bit secondary codes is too great for exhaustive search techniques with currently available computational facilities (although of course this may change in the future). Therefore an optimisation process, as shown in the flowchart of Figure 5, has been used to obtain a final set of candidate secondary codes from an initial random code selection in accordance with one embodiment of the invention (this corresponds to operation 405 from Figure 4).<br><br>
To start the process a random reference binary code (Cr) of the required length (N bits) is generated (510). First the modulus of the code's DC balance value is tested to check whether it exceeds the square root of the number of code bits (515). If this is the case then the code is rejected, and another random code is generated instead. When an acceptably balanced code is found its performance is calculated as a reference value (Pr) (520). Note that the optimisation process used in the method of Figure 5 tries to maximise a performance-related factor, although other embodiments may instead seek to minimise some sort of cost fimction (for present purposes these can generally be regarded as the same thing).<br>
Next one or more bits of the reference code are randomly inverted to produce a new code (Cn) (525). The number of bits inverted controls the "step" size through the search space. One approach is to invert a relatively large number of bits initially, corresponding to big steps through the search space when presumably the algorithm is a long way from a maximum, and then to invert a smaller number of bits at later iterations as the maximum is approached, in order to perform a more fine-grained search. In the present circumstances, it was generally found acceptable to invert only a single bit each time for operation 525. This is still a 1% change in the sequence (for a 100 chip sequence), and so does not lead to unduly slow convergence.<br>
It is now tested whether the new code fails the DC balance criterion (530). If so, the new code is rejected, and we return to operation 525 to generate a new code by flipping a random bit (or bits) of code Cr (not of code Cn).<br>
Assuming however that code Cn does fulfil the DC balance criterion at operation 530, the performance of the new code Cn is measured as Pn (535). An optimisation decision process is then performed (540) to test whether a random number selected linearly from the range (0 
 <br>
Note that if Pn&gt;Pr at operation 540, then code performance has been improved by the bit change at operation 525. In this case that the test of operation 540 is necessarily positive, leading to a code replacement at operation 545 (since the random test number cannot be greater than unity). However, even if Pn<pr indicating that the performance of new code is in fact worse than old there still a certain probability decreasing for test operation to give positive outcome leading replacement at this facility can help system avoid becoming trapped local maximum since it allows optimisation some circumstances move away from maximum.></pr>
Note that the sensitivity of the decision process can be modified by multiplying the delta performance value (Pn-Pr) by a sensitivity factor in operation 540 (this is analogous to varying the temperature in a related 'simulated annealing' search method). The sensitivity factor may be modified between iterations if appropriate. However, for the code searches described herein, a fixed factor of unity has been found to be satisfactory, as shown in Figure 5.<br>
A test is now made to see whether a target performance (Pt) has been achieved (550). If so, a suitable secondary code has been located, and the search can terminate (560), In one embodiment, the target performance level (Pt) is set to approximately that of the worst baseline secondary code (from Table 3). Alternatively, if the test at operation 550 determines that the performance threshold is not exceeded, processing returns to operation 525 to flip a random additional bit of the (modified) code. Note that this loop back is subject to testing for a maximum number of iterations (555), which in one embodiment is set to 1 million. If this limit is reached, then there may be a problem with convergence, and it is decided to return to operation 510 to generate a completely new random reference code Cr.<br>
It will be appreciated that the flowchart of Figure 5 is presented by way of illustration only, and the skilled person will be aware of many potential variations and modifications. For example, rather than flipping a single bit at operation 525, the procedure might randomly select a 0 and a 1 from the code to flip. This would then ensure that the balance of the code was maintained. In addition, the optimisation strategy may take into account one or more other<br><br>
criteria (in addition to or instead of those already discxxssed). For example, one possibility would be to require that the first side-lobe (i.e. corresponding to a bit shift of one place) of the autocorrelation function (ACF) is zero for each code. This is a useful property since it ensures that the ACF has a known (fixed) behaviour in the vicinity of zero-offset, which can help with strategies to mitigate multipath effects. In addition, the optimisation procedure may not necessarily exit once a given performance threshold has been reached (at operation 550), but may continue for at least some further iterations to try to find an even better bit pattern.<br>
The procedure illustrated in Figure 5 was used to search for suitable 50 and 100 bit secondary codes. Note that at this stage the mutual CCF properties between codes were not taken into account. The list of all codes found from the procedure of Figure 5 was then checked to ensure that it only included independent codes (corresponding to operation 410 in Figure 4). In particular, any inverse, reverse or cyclically shifted codes discovered were removed. (Several repeated codes were in fact found and rejected while searching for suitable 50 bit secondary codes, but no such repeats were found during the 100 bit code length searches, probably due to the much greater search space).<br>
Table 6 shows the range of performance values over the 100 best 50 bit secondary codes that were found using the search procedure of Figure 5. The 100 codes were selected from a total of 1304 codes that were found to have exceeded the performance threshold Ft (although this is not expected to be exhaustive).<br><br>
By way of comparison, the current baseline 50 bit secondary codes CS50a and CS50b from Table 3 are in positions 1146 and 1294 respectively out of the total 1304 secondary codes located. Note that the top 324 codes found have ACF HNVs of only 2, which is much better performance than the two original reference codes that have HNVs of 6,<br><br>
Similarly, Table 7 shows the range of performance values over the 200 best 100 bit secondary codes out of tiie 981 that were found that exceeded the performance threshold. In this case the top 200 codes are selected, since codes of this length are intended for botii the E5A-Q and E5B-Q pilot signals. Note that the second best code in Table 7 is the current CSlOOd reference code from Table 3, while the other baseline codes CSlOOa-c are in positions 981, 980 and 733 respectively.<br>
The preceding codes were all selected without testing CCF performance. The nejct step is therefore to select, firom the complete sets of secondary codes found, a group of at least 50 codes (for each signal) that also have good mutual CCF properties. However, it should be noted that this performance should not be worse than the current situation, where all code members use the same (common) secondary code.<br>
To test all combinations of any 100 codes from a pool of just a few hundred candidates is not feasible using currently available computational facilities, especially when allowing for various Doppler shifts (which mil effect the CCF performance between different satellite codes). Accordingly, another optimisation process was performed.<br>
In one embodiment, two methods, both using the same optimisation procedure, were utilised. Each of these methods starts with a randomly selected set of 100 codes chosen from the pool of approximately 1000 codes found through the method of Figure 5 (as described above). The two methods then replace one of the codes for each iteration, either by a random choice for one method, or by identifying the code that provided the worst CCF contribution for the other method. However, in this embodiment, it was found to be relatively hard to optimise (converge) the overall family CCF, especially when including Doppler shift effects, since the iteration rate<br><br>
was slow and the search program regularly got stuck in local maxima. In particular, the delta impact of changing a single code could be swamped by overall family CCF performance variations. One factor affecting speed was that the search program was continually recalculating almost the same CCFs for every iteration, although in fact only the CCFs involving the replaced code actually need to be computed for a new iteration. The search program was therefore modified to support this change in order to speed up the iteration rate. Attempts were also made to improve the sensitivity to individual code changes by tuning the performance criteria; nevertheless, the rate of convergence remained rather slow.<br>
In anoflier embodiment, a rather different approach was taken. In this embodiment, the CCFs of all code pair combinations for the complete pool of codes were computed. The matrix of computed CCFs also included a range of Doppler frequency offsets, namely 25 steps, each of 20 Hz, for the 50 bit secondary codes, and 50 steps, each of 20 Hz, for the 100 bit secondary codes. These produced maximum shifts of 500 Hz and 1000 Hz for the 50 bit and 100 bit secondary codes respectively, which match the repetition rates of the corresponding primary codes. At these frequency offsets the phase change per secondary code chip becomes 27i, after which the Doppler effect on the secondary codes repeats as previously discussed.<br>
Altiiough this embodiment utilises a large amoimt of memory or storage, it avoids the repetition of time-consuming CCF calculations. The subsequent optimisation process is then much faster, since it oidy involves finding the best set of codes using the pre-computed CCF values and one or more suitable criteria that combine the family of CCF values. For example, code groups may be constructed by eliminating codes that are seen to have poor CCF values, or by selecting codes that have good CCF values.<br>
In one embodiment, the CCF optimisation criteria adopted concentrate on the tracking performance, since the pool of codes have already been optimised on an individual basis for ACF properties, which drive the acquisition performance. Three different performance criteria were defined, based on a merit factor (MF) approach, including crosstalk (CT) and multipath (MP) variants. Two crosstalk merit factor criteria (CTl &amp; CT2) were used. The CT2 criteria takes into account that the time offset between satellites cannot exceed 20ms and therefore does<br><br>
not need to include the full range of possible offsets up to the pilot code length of 100ms. The third criteria (MP) uses a multipath variant of the merit factor. These criteria were employed by the optimisation algorithm to produce several code groups. For reference purposes, the first code group(s) included repetitions of the common baseline secondary code. Another code group used the top set of codes from each pool of codes.<br><br>
Figure 6A presents a typical plot of the CCF performance, using the CT2 criteria, for a 50 member code group of 50 bit secondary codes with zero Doppler. This plot is repeated in Figure 6B for the same code group, but showing the average CCF across all Doppler frequency offsets. Note that the randomizing effect of the Doppler shift tends to smooth the overall CCF to a value much less dependent on specific code structure.<br><br>
Table 8 smmnarises the results of the code set selection procediire for 12 different 50 bit secondary code groups Gl to 012, which each contains 50 code members.<br><br>
The &amp;st group Gl is a dummy group based on the same (conmion) baseline code CSSOa^ which indicates the reference performance level if only a single common secondary code is used. The next group G2 contains the top 50 codes from the secondary code search list of Table 6. The following 10 groups G3 to G12 were generated by optimising with respect to the three different CCF selection criteria described previously.<br>
The three main columns in Table 8 (CTl, CT2 &amp; MP) represent the results using the different crosstalk and multipath criteria. For these results the higher values represent better performance. An overall rank is shown in Table 8, determined by combining the individual ranks for each criterion. Note that common code (group Gl) is ranked last, and produces the worst score for each individual criterion. Code group G5 is ranked first, A further assessment of these 50 bit secondary codes using a code evaluation tool is described below.<br>
(It will be appreciated that since the ranking process of Table 8 includes two crosstalk criteria, this reduces the relative influence of the multipath criterion. This may or may not be appropriate, depending upon the intended use and circumstances of the signals).<br><br>
Table 9 summarises analogous results for 13 different groups Gl to 013, each containing 137 secondary codes of 100 bits.<br><br>
The first two groups of Table 9, Gl and G2, are dummy groups based on common baseline codes CSlOOd and CSlOOb respectively. These groups are therefore indicative of reference performance levels where only a single common secondary code is used. The next group G3 contains the top 137 codes from the secondary code search list. The following 10 groups G4 to G13 were generated using a CCF optimisation process analogous to that for the 50 bit code groups. As for the 50 bit code group evaluation, an overall rank has been included by combining the individual ranks for each criterion. Again, the common codes (groups Gl &amp; G2) are ranked poorly and occupy 2 of the worst 3 positions. Code group Gl 1 is ranked first. A further assessment of the 100 bit secondary codes using a code evaluation tool is provided below.<br>
Although the procedure described above in connection with Figures 4 and 5 is based on a two-phase approach, namely firstly identifying a set of good individual codes (operation 405), and secondly identifying good groups within this set (operation 415), a single integrated procedure might be used mstead. For example, this might involve randomly generating a group of codes, and then performing an optimisation process on this group that takes into consideration both the individual properties of the codes, and also the mutual properties of different codes in the group (especially their cross-correlation fimction). There is a range of alternative strategies<br><br>
available for such a task, based on concepts such as genetic algorithms, simulated aimealing, and so on. For example, if there are N code patterns in the final group, then a set of P code patterns might be generated initially (P&gt;N). Each optimisation cycle could then involve retaining the best subset of (say) N code patterns, and then generating another P-N new code patterns for testing in conjunction with the retained subset from the previous cycle. Some optimisation strategies may combine this selection from a larger population with updating individual code patterns within the population (as per operation 525).<br>
In assessing the codes groups identified in Tables 8 and 9, it will be appreciated that the two main criteria for code design are perforaiance under acquisition and tracking modes of operation. Within these two modes one can distinguish two further performance aspects, namely the suppression of delayed versions of the same code (multipath case), and the rejection of all other satellite codes (crosstalk case). Any performance assessment should include the effects of Doppler frequency shift, as appropriate. One or more additional criteria relating to the code's spectral properties may also be adopted.<br>
For acquisition, the codes' ACFs (multipath case) or mutual CCFs (crosstalk case), with allowance for Doppler offset, may be used as performance criteria. These can then be compared to the appropriate Welch bound (WB) for the code length and code family size. These criteria measure the Average Mean Excess Welch Square Distance (AMEWSD) for the multipath and crosstalk cases. For the multipath case, only a limited range of Doppler shifts are normally tested, since only one satellite code is considered, and this represents the expected range of acquisition search frequency bin error. However in the crosstalk case, which includes other satellite codes, a maximum value of 6.7kH2 Doppler shift has to be taken into account. Note that both these criteria take into account the effects of even and odd correlation.<br>
For tracking purposes, the codes' ACFs (multipath case) or mutual CCFs (crosstalk case) may be used directly to provide an Average Merit Factor (AMF) measure of performance. As for the acquisition tests, the multipath case may be restricted to a limited range of Doppler frequency shifts. In addition, the ACF is only evaluated for time offsets of ±1 and ±2 chips, to<br><br>
reflect the limited range of multipath delays expected while tracking a signal. This range of time offsets is not strictly relevant for the slow secondary codes on their own.<br>
It is also desirable for the codes to have a flat spectrum, similar to random noise. The presence of strong spectral lines increases cross-talk between codes, as well as susceptibility to external narrowband interference. The criteria used here measure the Average Excess Line Weight (AELW) with respect to the equivalent spectral power for a random code.<br>
A code evaluation tool based on the five test criteria mentioned above was used to test the secondary code proposals from Tables 8 and 9. The tool performs two types of calculation, namely multipath (MP) and crosstalk (CT), involving one code and a code pair respectively. In theory for testing the secondary codes, the evaluation tool should be run with the complete sets of tiered codes. However this is not feasible with currently available computational resources, and so the secondary codes were tested on their own. This approach is reasonable since the CCF performance of a tiered code can be seen to be the product of the individual primary and secondary codes, and it also avoids the need to specify the primary codes themselves or tte assigmnent of a particular primary code to a particular secondary code, which may both be subject to change.<br><br><br>
The five main columns (MEWSD-CT&amp;MP, MF-CT&amp;MP and ELW) represent the results from the code evaluation tool. These are all computed as cost functions where the lowest values represent the best performance. (The tool does not provide any answers for the merit factor multipath (MF - MP) case - this appears to be due to the short length of the secondary codes being evaluated). Note that the values of MEWSD-CT and MEWSD-MP are computed in accordance with the following definitions:<br><br><br>
Table 11 summarises the results for the 13 different 100 bit secondary code groups Gl to G13 from Table 9, which each contains 137 code members.<br><br>
(As for the 50 bit code tests, the tool did not produce any results for the merit factor multipath (MF - MP) criterion). Matching the results shown in Table 9, the best 100 bit secondary code group is found to be Gl 1. The first reference set Gl (common CSlOOd code) is worst for all criteria except the ELW. The second reference set G2 (conmion CSlOOb code) performs better at equal 6^ place, which can be attributed to having the best performance in the MEWSD multipath criterion.<br>
In summary therefore, a process has been described for optimising secondary codes, especially for those codes used as part of the long tiered codes for the pilot signal components. Previous Galileo baseline code specifications have adopted a common secondary code for all primary code family members, but this produces relatively high CCF sidelobes where the signal delay between satellites is less than a few ms. Since this problem is only serious for low Doppler frequency offsets between satellites, it will mainly degrade acquisition performance. The CCF sidelobes can be significantly reduced by the use of independent secondary codes for each primary code member.<br>
A two-stage optimisation procedure has been utilised to find suitable groups of 50 bit and 100 bit secondary codes, since these relatively long secondary codes are expected to yield<br><br>
sufficient suitable codes, allowing for the number of satellites in the Galileo system. The first st£Lge located codes with good ACF and ELW properties, comparable with or better than the original baseline codes. This produced approximately 1000 candidates for both the 50 and 100 bit secondary codes.<br>
The second stage then selected a suitable group of codes with good mutual CCF properties from the overall pool of codes found. In fact several groups were selected depending on varioxis optimisation criteria. These groups were then compared against each other by a code evaluation tool using an agreed (predetermined) set of performance criteria.<br>
For the 50 bit secondary codes, a particular code group (G5, see Table 8) is recommended. This group contains 50 different codes, which can be assigned to the different satellites, rather than using a common secondary code as per the previous baseline proposal for the E6-C pilot signal (although as previously mentioned, the primary code intended for the E6-C pilot signal has now been shortened, so that the length of the corresponding secondary code will in fact be increased from 50 bits to 100 bits).<br>
For the 100 bit secondary codes, a particular code group (Gl 1, see Table 9) is recommended, specifically to replace the use of the common secondary code CSSOd for the E5A-Q pilot signal component and the common code CS50b for tiie E5B-Q pilot signal component. The code group Gl 1 contains 137 compatible codes allowing the allocation of 50 codes for both E5A and E5B pilot signal components, plus an additional 37 codes that coixld be assigned to the GPS L5 pilot signal. With the change to the E6-C pilot signal, these 100 bit secondary codes may be used for this signal as well.<br>
The Galileo LI -C signal component currently uses a tiered pilot code with a common 25 bit secondary code. The procedure described herein should allow sufficient codes to be identified for this shorter secondary code length that would allow the use of independent secondary codes for different satellites, and this in turn should lead to consequential performance<br>
improvements.<br><br>
It will be appreciated that the number of codes to be included within a given code set is dependent upon the particular requirements of the relevant satellite navigation system. Such systems are generally designed to operate with some 24-30 different satellites, usually with one or more additional satellites as potential spares in case of failure. The desired number of codes within a code set may be fijrther increased to accommodate "pseudolite" signals. These are signals emitted from ground locations, for example near airports, that appear to a receiver as additional satellite navigation signals, and so can give more precise and reliable position determination in such locations.<br>
In addition, in some circumstances, it may be desired to change the set of spreading codes broadcast from a satellite on a regular basis. This can be useful for security or commercial reasons, for example where access to the new codes is conditional upon payment of a license fee, or is restricted to certain sets of government or military users. If the spreading codes are changed from time to time, then a larger number of codes sets is required. Note however that with a tiered code construction, the code changes may potentially be implemented just by changing the primary codes, while maintaining the same secondary code through the change.<br>
Figure 7 is a high-level schematic diagram of a subsystem 600 for generating a tiered spreading code in accordance with one embodiment of the invention. Note that subsystem 600 may be incorporated into a satellite to generate a spreading code for transmission to earth. In addition, subsystem 600 may be incorporated into a receiver for detecting a satellite signal, for example by cross-correlating the signal mcoming to the receiver with the output from subsystem 600.<br>
In operation, the N-bit secondary code for the spreading code is loaded into shift register 630. Prior to this, the secondary code may be stored in some non-volatile storage device (not shown), for example a form of ROM or EEPROM (such as flash memory).   Alternatively, the secondary code may be utilised directly from the storage device (i.e. without first loading into a shift register). The secondary code sequence available from shift register 630 is specific to the relevant satellite for subsystem 600.<br><br>
Component 620 is used to generate an M-bit primary code. In some embodiments, component 620 may be a linear feedback shift register (LFSR), such as used for generating a Gold code for GPS signals. Alternatively, the complete M-bit primary code may also be stored in some form of storage device, for example a ROM or EEPROM (such as flash memory). This latter option is particularly appropriate where the primary code comprises some form of random bit code, rather than a pseudo-random sequence that can be (re)generated by appropriate logic.<br>
The primary code generator 620 receives a clock signal 605 at the signal chip rate, and outputs the next bit of the primary code in response to this clock signal. The clock signal 605 is also passed through a divide by M unit 610 before being passed to the secondary code unit 630. Consequently, the secondary code sequence progresses a single bit for each complete cycle through the primary code. The output for the secondary code is then combined using an exclusive-OR operation 640 with the output for the primary code to produce the tiered code 650.<br>
Note tiiat in some implementations, subsystem 600 may only be used for the initial code generation, such as during satellite or receiver manufacture. The tiered code 650 would then be stored as a single (flat) bit sequence in the satellite and/or receiver, despite having an underlying hierarchical structure. Such an approach might be useful for simplifying overall hardware design.<br>
Figure 8 A is a high-level schematic block diagram of a transmission system 601 for use in a satellite payload in accordance with one embodiment of the invention. (It will be appreciated that an analogous structure could also be used in a pseudolite or other such device that emulates a satellite). The transmission system 601 utilises a tiered spreading code including a secondary code such as generated using the method of Figure 4, At least the secondary portion of the spreading code 611 is stored in a memory device 610, which in normal broadcast activities functions as a read-only memory. In certain embodiments, the primary code may also be stored in memory 610 (or in some other memory device), either separately or in conjunction with the secondary code, depending upon how the primary code is implemented (as discussed above with reference to Figure 7). In one implementation memory device 610 may be operated from a<br><br>
logical perspective as a circular buffer, using a read pointer to cycle around the stored code sequence 611.<br>
Since the feature size of modem memory devices is very small, the stored bits in memory 610 may be vulnerable to cosmic ray hits (especially in a space environment) and other possible contamination. Accordingly, in one embodiment, the output of memory device 610 is passed through an error correction code (ECC) unit 612 to protect the accuracy of code 611. The ECC unit 612 is able to detect an error in code 611 as read out from memory 610, and may be able, in some circimistances, to automatically correct the error (depending upon the nature of the code and the error). For example, memory 610 may store two copies of the code 611, and read each bit simultaneously from both copies. If the two bits read from the different versions disagree, this signals (i.e. detects) an error in one of the stored versions. If three copies of the code 611 are stored in memory 610, then any detected error may be corrected automatically on the basis of majority voting.<br>
The skilled person will be aware of many ECC mechanisms from data commxinications and data storage applications, such as the use of convolutional encoding, cyclic redundancy codes (CRC), and so on. These generally have a much higher efficiency than simply storing multiple copies of the code 611 - i.e. they provide better protection against errors with a lower overhead in terms of additional storage requirements.<br>
After the code has passed through the ECC check 612, it is combined with the navigation data 617 by the channel generation subsystem 620. The channel generation subsystem 620 may also include a subsystem such as illustrated in Figure 7 to generate a tiered code from the secondary code from memory 610 and from the primary code (whether obtamed from memory 610 or generated by some other mechanism). Alternatively, channel generation subsystem 620 may receive a tiered code 650 in which the primary and secondary codes have already been combined, for example, if stored code 611 already integrates both the primary and secondary codes.<br><br>
The channel generation subsystem generally uses some form of modulo-2 addition (exclusive-OR) to combine the spreading code and the navigation data. The resulting channel is then passed to a modulation unit 625, where it is superimposed on a carrier signal using some appropriate modulation mechanism, such as binary phase shift keying (BPSK). Note that in some satellite systems, multiple channels may be modulated onto a single carrier signal. The carrier signal is then passed to transmitter 630 for broadcast to earth.<br>
Although in some implementations code 611 may be "hard-wned" into memory 610 prior to launch, it is more flexible if memory device 610 includes a write capability - e.g. it is implemented as some form of programmable read only memory (PROM). For example, if ECC check 612 does discover that the stored code 611 has been corrupted, then a write capability for memory device 610 allows the correct version of the code to be written back into die memory device 610 (the correct version of the code may be available from the ECC unit 612 itself, or may have to be provided by a ground control system). There can also be various other reasons for wanting to update the code 611 stored in memory 610. For example, a new code might be installed to help improve performance during a testing phase, perhaps if the original code suffers from interference with some other service or satellite. There might also be commercial or security reasons for changing code 611, the former to raise licensing revenue perhaps, the latter to restrict access to the positioning signal to suitably authorised personnel.<br>
Figure 8B is a high-level schematic block diagram of a receiver 701 in accordance with one embodiment of the invention. Receiver 701 may be provided as a stand-alone unit, or may be incorporated into some larger device, for example a mobile (cellular) telephone, a computer, an automobile or other form of vehicle, a hospital bed, an aircraft or ship, a freight container, and so on. In operation, receiver 701 includes aerial 715 for receiving a satellite signal such as that transmitted by satellite 60 L The aerial 715 links to a de-modulator 720, which in turn passes the incoming de-modulated signal to channel acquisition unit 725.<br>
The receiver 701 also includes a memory device 710 that stores at least the secondary code portions 611 A, 611B...61 IN for the constellation(s) of satellites supported by receiver 701. In addition, analogous to the situation with Figure 8 A, the primary code portions of these codes<br><br>
may also be stored in the relevant memory units 610A, 610B, ...610N, or may instead be generated using an LFSR or other suitable device, depending upon the particular choice of primary code.<br>
Memory device 710 generally stores the entire bit patterns for the secondary codes 61 lA, 61 IB,... 61 IN, since a more compact representation of such secondary codes is not normally possible in the absence of any formalised mathematical structure. Examples of the possible bit patterns for use as secondary codes 611 A, 61 IB,... 61 IN and for storage in memory device 710 are set out m Appendix 1. (The skilled person will appreciate that the stored bit patterns 611 need not exactly match the bit patterns broadcast from the satellite, as long as they are close enough to ensure a strong correlation for signal reception purposes).<br>
Memory device 710 may be provided as a read only memory (ROM), or it may have some update capacity, for example, being implemented as a programmable read only memory (PROM).  The latter is particularly appropriate where the codes 611 A, 61 IB,... 61 IN are subject to update, either for commercial or security reasons. Note that in some circumstances memory 710 may represent some form of removable storage medium that can be inserted into and removed from receiver 701. For example, memory device 710 may comprise a smart card (analogous to a SIM card hi a mobile telephone) or a flash memory device. This would then allow the codes 611 in receiver 701 to be updated by replacing the removable memory device. A further possibility is that device 710 may be able to download codes from a remote system (e.g. a server) over some commimication network, such as the Internet or a mobile telephone connection, for storage in and use from local RAM. This download may be subject to appropriate authorisation of the user, in order to restrict use of the satellite navigation system for commercial, security or legal reasons.<br>
In some implementations, the output from memory 710 is passed through an ECC unit 712 to perfonn error detection and/or correction as described above in relation to the satellite system 601, although in other receivers the ECC check mechanism 712 may be omitted. The code 611 is then provided to the channel acquisition unit 725 so that the channel can be acquired from the de-modulated signal. The channel acquisition unit 725 is responsible for combining the<br><br>
primary and secondary codes for a satellite, such as by using the subsystem shown in Figure 7, although in other embodiments this combination may be done at an earlier stage (either within device 701 or prior to loading the codes into memory 710).<br>
Note that the satellite acquisition may be performed sequentially by trying one code 611 A, then another 61 IB, and so on. More commonly, multiple codes (potentially all of them) are correlated against the de-modulated signal in parallel. Once the receiver has locked into a sufficient number of incoming signals by identifying the presence of their respective spreading codes 611 A, 61 IB, the navigation data firom those signals can be extracted and used by the position determination unit in conjunction with the timing of the received spreading codes to help calculate the location of the receiver.<br>
In many embodiments, receiver 701 may be able to receive signals firom more than one satellite navigation system, for example, fi'om both Galileo and fi'om GPS. Although the spreading codes for GPS comprise Gold codes that can be implemented as LFSRs, it will be appreciated that such codes can also be stored in their entirety within memory device 710. Accordingly, the single architecture of memory 710 is compatible with specific or bespoke code patterns as well as with conventional code patterns derived fi-om LFSRs.<br>
In conclusion, although a variety of embodiments have been described herein, these are provided by way of example only, and many variations and modifications on such embodiments will be apparent to the skilled person and fall within the scope of the present invention, which is defined by the appended claims and their equivalents.<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
Claims<br>
1.	A method for creating a set of secondary spreading codes for use in a satellite navigation<br>
system comprising a constellation of satellites, wherein each satellite in the constellation<br>
employs a tiered spreading code comprising at least a primary code and a secondary code, and<br>
wherein each satellite in the constellation is allocated a different secondary spreading code from<br>
said set of secondary spreading codes, the method comprising;<br>
generating an initial set of bit patterns, wherein each bit pattern represents a potential secondary spreading code; and<br>
performing an optimisation process on bit patterns wiliiin the initial set of bit patterns, whereby at least some of the bit patterns in said initial set are modified or replaced, to create a final set of bit patterns for use as the set of secondary spreading codes,<br>
2.	The method of claim 1, wherein the bit patterns in the initial set of bit patterns comprise random sequences of bits.<br>
3.	The method of claim 1 or 2, wherein the optimisation process includes rejecting bit patterns that fail a balance criterion,<br>
4.	The method of claim 3, wherein said balance criterion is based on the square root of the number of bits in a bit pattern.<br>
5.	The method of any preceding claim, wherein the optimisation process utilises a performance or cost function derived from the auto-correlation function for a bit pattern.<br>
6.	The method of any preceding claim, wherein the optimisation process utilises a performance or cost function derived from the cross correlation function between different bit patterns.<br><br>
7.	The method of any preceding claim, wherein the optimisation process includes modifying the bit patterns by randomly flipping a bit in at least one of the bit patterns.<br>
8.	The method of any preceding claim, wherein the optimisation process includes a first phase of identifying bit patterns having good individual properties, and a second phase of selecting the set of secondary spreading codes from the identified bit patterns having good individual properties.<br>
9.	The method of claim 8, wherein the first phase identifies at least 250 bit patterns having good individual properties.<br>
10.	The method of claim 8 or 9, wherein the second phase includes calculating the cross correlation function between every pair of identified bit patterns having good individual properties.<br>
11.	The method of any preceding claim, wherein the number of bits in a bit pattern is in the<br>
range 25 to 512.<br>
12.	The method of claim 11, wherein the number of bits in a bit pattem is in the range 50 to<br>
128.<br>
13.	A receiver incorporating a final set of bit patterns created using the method of any preceding claim.<br>
14.	The receiver of claim 13, wherein said bit patterns are protected by an error-correcting code.<br>
15.	The receiver of claim 13 or 14, fiirfher comprising at least one read only memory (ROM) which stores the primary code and second code portions of the tiered spreading codes.<br><br>
16.	A removable memory device for use in a receiver, wherein said memory device incorporates a final set of bit patterns created using the method of any of claims 1 to 12.<br>
17.	The removable memory device of claim 16, wherein said bit patterns are protected by an error-correcting code.<br>
18.	Apparatus incorporating one or more bit patterns from the final set of bit patterns created using the method of any of claims 1 to 12.<br>
19.	The apparatus of claim 18, wherein said apparatus comprises a satellite.<br>
20.	The apparatus of claim 18, wherein said apparatus comprises a pseudolite.<br>
2L      A satellite signal incorporating at least one bit pattern from the final set of bit patterns created using the method of any of claims 1 to 12.<br>
22.	A receiver incorporating a final set of bit patterns selected substantially from the bit patterns set out in Appendix 1.1 or Appendix 1.2.<br>
23.	A removable memory device for use in a receiver, wherein said memory device incorporates a final set of bit patterns selected substantially from the bit patterns set out in Appendix 1.1 or Appendix 1.2.<br>
24.	Apparatus incorporating at least one bit pattern selected from the bit patterns set out in Appendix 1.1 or Appendix 1.2.<br>
25.	The apparatus of claim 24, wherein said apparatus comprises a satellite.<br>
26.	The apparatus of claim 24, wherein said apparatus comprises a pseudolite.<br><br>
27.	A satellite signal incorporating at least one bit pattern selected from the bit patterns set out in Appendix 1,1 or Appendix 1.2.<br>
28.	A method of operating a receiver for use in conjunction with a satellite navigation system, the method comprisuig;<br>
accessing a set of stored bit patterns, said bit patterns corresponding to secondary codes used by the satellite navigation system and selected substantially from the bit patterns set out in Appendix 1.1 or Appendix 1.2; and<br>
using the stored bit patterns to acquire signals from the satellite navigation system.<br>
29.	The method of claim 28, wherein said stored bit patterns are accessed by the receiver over a network.<br>
30.	A method of operating a receiver for use in conjunction with a satellite navigation system, the method comprising:<br>
accessing a set of stored bit patterns, said bit patterns corresponding to secondary codes used by the satellite navigation system and created using the method of any of claims 1 to 12; and<br>
using the stored bit patterns to acquire signals from the satellite navigation system.<br>
31.	The method of claim 30, wherein said stored bit patterns are accessed by the receiver over a network,<br>
32.	A method of operating a server that communicates with receivers for use in conjunction with a satellite navigation system, the method comprising:<br>
storing a set of bit patterns, said bit patterns corresponding to secondary codes used by the satellite navigation system and created using the method of any of claims 1 to 12; receiving a request from a receiver to access the set of stored bit patterns; and supplying the stored bit patterns to tiie receiver in response to said request for use in acquiring signals from the satellite navigation system.<br><br>
33.      A method of operating a server that commxmicates with receivers for use in conjunction<br>
with a satellite navigation system, the method comprising;<br>
storing a set of bit patterns, said bit patterns corresponding to secondary codes used by<br>
the satellite navigation system and being selected substantially from the bit patterns set out in<br>
Appendix 1.1 or Appendix 12<br>
receiving a request from a receiver to access the set of stored bit patterns; and supplying the stored bit patterns to the receiver in response to said request for use in<br>
acquiring signals from the satellite navigation system.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=LZoRMAWmpuEYsYN1LvejjA==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=LZoRMAWmpuEYsYN1LvejjA==&amp;amp;loc=egcICQiyoj82NGgGrC5ChA==</a></p>
		<br>
		<div class="pull-left">
			<a href="271447-portable-air-purifying-system-utilizing-enclosed-filters.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="271449-step-down-voltage-converter.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>271448</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>9/CHENP/2008</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>09/2016</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>26-Feb-2016</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>22-Feb-2016</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>01-Jan-2008</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>EUROPEAN SPACE AGENCY</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>8-10, RUE MARIO-NIKIS, 75738 PARIS CEDEX 15, FRANCE</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>BARNES, BRIAN</td>
											<td>EADS ASTRIUM LTD, ANCHORAGE ROAD,PORTSMOUTH, HAMPSHIRE PO3 5PU, UK</td>
										</tr>
										<tr>
											<td>2</td>
											<td>LEGATE, STEVE</td>
											<td>EADS ASTRIUM LTD, ANCHORAGE ROAD,PORTSMOUTH, HAMPSHIRE PO3 5PU, UK</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04J 13/04</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/EP05/07235</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-07-01</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td></td>
									<td></td>
								    <td>NA</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/271448-a-method-for-generating-satellite-spreading-codes-and-a-receiver-incorporating-such-codes by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:28:31 GMT -->
</html>
