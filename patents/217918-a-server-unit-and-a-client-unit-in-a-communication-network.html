<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/217918-a-server-unit-and-a-client-unit-in-a-communication-network by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:16:33 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 217918:A SERVER UNIT AND A CLIENT UNIT IN A COMMUNICATION NETWORK</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A SERVER UNIT AND A CLIENT UNIT IN A COMMUNICATION NETWORK</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The real-time performance in communications networks is improved, especially between a large number of participants, by means of a server unit comprising receiving means for receiving information from at least a client unit, said information comprising at least part of the state information about a distributed interactive application, said server unit comprising: state information storing means for storing application state information received from at least one of said client unit, transmission means for forwarding the state information received from said client to at least one other node in the network, and for transmitting at least part of the information stored in said state information storing means to said at least one client. In this way the whole state of the application can be kept in one or more units in the network, which removes the need for each client to store the entire state, thereby reducing memory and banwidth requirements for each client.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT 1970<br>
[39 OF 1970]<br>
COMPLETE SPECIFICATION<br>
[See Section 10]<br>
"METHOD AND APPARATUS IN A COMMUNICATION NETWORK"<br><br><br>
TELEFONAKTIEBOLAGET LM ERICSSON [PUBL], a Swedish company, of S-126 25 Stockholm, Sweden,<br>
The following specification particularly describes the nature of the invention and the manner in which it is to be performed:-<br><br><br><br><br>
WQ-G&amp;68864-	-PCT/SE00/0Q93T<br>
2<br>
Method and Apparatus in a Communication Network<br>
Technical Field<br>
The present invention relates to communications networks and in particular to the <br>
5       real-time communication between several users of an application in such a network.<br>
Description of Related Art<br>
Multi-user communications applications are currently being developed, for example for multi-user games. Such games may be played by a number of users connected to <br>
10	 the same LAN or even to different pans of larger networks, such as the Internet. For such applications, three main synchronization models are used: client-server synchronization, peer-to-peer synchronization or broadcast synchronization. Some multi-user games on die Internet today involve up to 100 000 players, of which several thousand may be playing at the same time. All synchronization methods used<br>
15        today cause rather long delays. Therefore, the multi-user games played over the<br>
Internet today are games in which the speed is not critical. For example, fast action games, such as car racing games or battle games, in which the user must react to what is happening within fractions of a second cannot be played with acceptable quality using any of the standard synchronization methods.<br>
20<br>
Dial-in networks typically use client-server synchronization. In this case, a server receives data from all players. It has to find out what information each player needs and send it. The central server is an obvious bottleneck in the system. Central client-server games can support 2 - 250 players. The higher number refers to servers<br>
25        where the update rate is as low as 2 Hz. The central server adds latency both because of the increased transport distance and the processing and scheduling delay in the server. Consider e.g. a situation where the clients are on the U.S. West coast while the server is on the U.S. East coast. About 80 ms of transport latency and at least several 10 ms of processing latency are caused by the client-server mode of<br>
30       operation.<br><br>
-WO 00/68864-	- PCT/SE0Q&amp;Q932-<br>
Therefore, client-server synchronization is not feasible for real-time applications with large numbers of players in which the delay is critical.<br>
Peer-to-peer synchronization means that all clients send application data directly to<br>
5	all other clients. This model is frequently used for games that are played over the<br>
public Internet. Game developers provide a free application lobby server where players meet for setting up games and for joining ongoing games. Once a game has started it is played in the peer-to-peer mode without drawing any resources from the game developer's site.<br>
10<br>
Peer-to-peer synchronization has obvious scaleability problems since the network load is proportional to the square of the number of players; the client access bandwidth and CPU power requirement are proportional to the number of players. The payload in each packet is 10-40 bytes, which means that the protocol overhead <br>
15      	  usually is more than 50%. Small game packets give a large protocol overhead. With header compression methods, however, this overhead can be reduced significantly. Peer-to-peer games over the Internet suffer from unpredictable delays and frequent collapses because of loss of synchronization.<br>
20        It follows that peer-to-peer synchronization, too, is best adapted to small networks, with communication over relatively short distances and between a limited number of users.<br>
Broadcast synchronization can be used by a limited number of players on a Local <br>
25        Area Network (LAN) but is not suitable for larger networks.<br>
	Because of the restrictions posed i.a. by the synchronization methods, multi-<br>
participant communications with good real-time characteristics is not possible with<br>
current technology<br>
30	With multicast the information that has to be transmitted in the network can be sig-<br>
nificantly reduced, in that information only has to be transmitted once to each mul-<br><br>
ticast server, instead of once to each user. Each multicast server then copies the information and transmits it to the users connected to it. A selection of the information each user needs to receive may be made. This may reduce traffic both between servers and between each server and its users. Such a solution for use in gaming is<br>
5       	disclosed in US 5 841 980,<br>
In the system disclosed in US 5 841 980 each user only has the information related to the part of the game which is relevant to the user in the current situation, e.g. information about the geographical area he is in. If the circumstances change, for ex-<br>
10      	  ample, if the user moves to another room, information that is important in the new circumstances will not be available to the user.<br>
Object of the Invention<br>
It is an object of the present invention to improve the real-time performance in <br>
15   	     communications networks, especially for collaborative communication between a large number of participants.<br>
Summary of the Invention<br>
This object is achieved according to the invention by a server unit for use in a <br>
20   	     communications network, said server unit comprising receiving means for receiving information from at least a first client unit, said information comprising at least part of the state information about a distributed interactive application, said server unit being characterized in that it comprises<br>
-	state information storing means for storing application state information com-<br>
25            prised in the information received through the receiving means from at least one<br>
of said first and second client units,<br>
-	first transmission means for forwarding the state information received from said<br>
at least first client unit to at least one other node in the network,<br>
-	second transmission means for transmitting at least pan of the information stored<br>
30            in said state information storing means to said at least one client unit.<br><br>
WO 00/68864	5	FCT/SE 00/00937<br>
This enables keeping the whole state of the application in one or more units in the network, which removes die need for each client to store the entire state, thereby reducing the need for memory capacity in each client and also the bandwidth needed for communication with each client. If each part of the state of the applica-<br>
5     	   tion is stored in more than one network node or client, a back-up facility is achieved.<br>
The object is also achieved according to the invention by a client unit for use in a terminal in a communications network, comprising an application software for a <br>
10        distributed interactive application client unit being characterized in that it comprises<br>
-	at least one input means for reading an input from said terminal, said input con<br>
stituting at least application state information for the distributed interactive appli<br>
cation<br>
-	transmission means for transmitting application state information to an applica-<br>
15           tion access server<br>
-	receiving means for receiving at least application state information for the distributed interactive application from said application access server<br>
-	means for displaying said state information.<br>
20        The method and apparatus according to the invention are particularly useful for<br>
distributed interactive applications, especially involving real-time communication.<br>
Preferably, the receiving means of said server means is adapted to<br>
-	receive subscription information from at least said first client, said subscription<br>
25	information identifying objects of the distributed interactive application about<br>
which said first client wishes receive information,<br>
-	transmit information to said at least one client unit in dependence of the sub<br>
scription information received from that client unit,<br>
-	said server unit further comprising at least one client subscription list for storing<br>
30	said subscription information.<br><br>
Accordingly, said client unit further comprises means for setting subscription information for specifying at least one object of the distributed interactive application from which available information should be received and means for transmitting said subscription information to said application access server.<br>
5<br>
This reduces the amount of information to be transmitted to each user, thereby reducing the transmission delay and also helping each user analyze the information, since only the most imponant information for a particular user is shown to that user. Each client is able to decide for itself what is important.<br>
10<br>
In a preferred embodiment, the receiving means is adapted to receive urgency information relating to said first client from at least a second client. The urgency information may be transmitted to the first client, or application state information regarding said second client may be forwarded to at least said first client in depend-<br>
15  	      ence of said urgency information. The urgency information may also be used to indicate that certain application state information should not be forwarded to said first client. The urgency information may be used to change a client subscription.<br>
In said preferred embodiment the client unit further comprises means for setting ur-<br>
20    	    gency data for specifying at least one other client that should receive state information from the client as soon as possible.<br>
Advantageously, the transmission means of the client unit for transmitting application state information is adapted to arrange information in object information pack-<br>
25    	    ets, each packet relating to one object constituting part of the application, before transmitting the packets to the server unit, and said receiving means is adapted to extract information from packets received from the server unit.<br>
The application access server system is independent of the application and can <br>
30       therefore support a wide range of different applications.<br><br>
WO-60/68864	I	PCT/SE00/00932 -<br>
Application access server units working together could communicate over a network, which preferably offers reserved or managed transmission capacity. The aggregated bandwidth requirement of an application can be estimated by the network management system and sufficient network resources can be allocated to the re-<br>
5	served network that is connecting the application access server units. New applications are allowed only if resources are available. The network management also controls the resending and duplication policy of the application access server units. Multicasting and resource reservation protocols can be used on "the aggregated streams between the application access server units. The advantage of this system is <br>
10   	     that resource reservation on the player level is not necessary. Application clients can usually handle occasional lost packets if the overall statistical performance is good. Using the application access server according to the invention means that a game client never will lose synchronization permanently since the application access server units always maintain the game state.<br>
15<br>
Brief Description of the Drawings<br>
The apparatus and method according to the invention will be described in more detail in the following, with reference to the appended drawings, in which: Figure 1 illustrates an embodiment of a network according to the invention;<br>
20        Figure 2 illustrates an application access server according to a first embodiment of the invention;<br>
Figure 3 shows an embodiment of an application state record according to the invention; Figure 4 shows an application client according to an embodiment of the invention;<br>
25        Figure 5 illustrates the communication stacks used according to an embodiment the invention;<br>
Figure 6 shows a second embodiment of the application access server according to the invention; Figure 7 shows an application router used in the second embodiment of the applica-<br>
30        don access server;<br><br>
00/08864	l	*PCT/SE00/00932-<br>
Figure 8 is a schematic representation of a hierarchical structure of application access servers used in an embodiment of the invention.<br>
Detailed Description of Embodiments<br>
Figure 1 shows an embodiment of a communications network according to the invention. According to the invention, the network comprises at least one application access server. In Figure 1, a first 1, a second 3 and a third 5 application access server are shown, connected to each other through a network 7, for example, a reserved telecommunications network. It may also be any other type of network, however, networks in which it is not possible to reserve network resources, such as the Internet, may provide a lower quality if heavily loaded. A number of clients 11, 12, 13, 14, 15 are also connected to the network 7. A client can connect to the appropriate application access server 1, 3 or 5 in any way known in the art, as will be discussed in more detail below.<br>
Clients can communicate with each other through the application access servers for the purpose of running a distributed interactive application, in which a large member of participants simultaneously affect and contribute to the state of the application, for example a real-time multi-user game. Between each client and the application access server to which it is connected there will usually be a low capacity connection, such as a modem connection. Between two application access servers, on the other hand, high and variable network capacities will be available. The application access servers according to the invention are therefore adapted to handle the information about the state of the application in such a way as to reduce the amount of information transmitted to each client, by transmitting to each client only the information that is most relevant to this client. Between the application access servers, the transmission capacity will not normally be a problem and therefore more information can be transmitted between application access servers.<br><br>
W0 00/65864	9	PCT/SE00/00932<br>
One or more application lobby servers 21, of a kind known per se, may also be present in the network. These servers typically comprise functions that allow the clients to register for a particular type of service, handle billing functions, etc.<br>
5	According to the invention, the software required for the application is found in the client 11, 12, 13, 14, 15. To use the communication functions according to the invention, therefore, the user must make sure he has the application software needed. The application software may be retrieved in any way known in the art, for example, downloaded from the Internet or installed from CD-ROM. If required for the <br>
10  	     application he must also register with the application lobby server. Typically, the application lobby server 21 will provide an address, usually an IP address and port number of one or more application access servers 1, 3, 5, but this address may also be obtained in any other way.<br>
15       The user connects to an application access server in the way common in the art,<br>
normally by entering the IP address of the application access server or a pool of application access servers. Several algorithms exist for selecting the appropriate one of a number of nodes in the network identified by the same address. The application access server receives information from the user and starts transmitting information<br>
20        to the user, as will be described in more detail in the following. Instead of the client logging in to the application access server, the application lobby server can also transmit client network addresses to the application access servers.<br>
The application is assumed to consist of a set of objects, which are controlled by the <br>
25	participants. An object is an entity in the application that is controlled by a human participant or that is generated in a client and cannot be regenerated locally in each application client, e.g. controlled by a random generator or other unpredictable computing process. Application objects can be things that the participants will intuitively recognize as objects, or game figures, but they can also be background data <br>
30     	   structures such as environment variables that are controlled by players. An application object is controlled by one or several players. Each object typically has a set of<br><br>
WO00/68864	10	PCT/SE00/00932<br>
properties and attributes that may be changed while the application is running. In a game these properties may be a character's strength and other capabilities, or the maximum speed of a car, and the attributes may be, for example, items collected by the character. <br>
5<br>
The information received from the user will normally comprise three different types of information, in addition to the signalling overhead: state information, subscription information, control data and urgency information. The state information is information about the object or objects that are controlled by the user, which should<br>
10 .      be distributed to other users of the application. The subscription information lists the client's priorities regarding different application objects provided by the application access servers. For example, information regarding a certain group of objects should be received at once it becomes available, or as often as possible, whereas information from another group of objects is not that urgent. Several priority levels<br>
15	may be set, for example, in the form of acceptable delays or precedence in case of lack of bandwidth. The urgency information generated by a client may be used to override or change the subscriptions of another client so that the other client will receive information about objects that are not included in its subscription, or to make sure that the client does not receive certain information. All three types of in-<br>
20        formation will be discussed in more detail below.<br>
As an example, the application of a real-time game being played by a large number of users, will be described. Such games are played today with a limited number of players, located fairly near each other, for example in a local area network (LAN). <br>
25  	      Played over a wide area network, such a game may in the future involve several thousands of players, typically distributed over a large game field, or virtual geographical area. With prior art technology this is not possible with an acceptable quality, as discussed above.<br>
30        Each player is immediately affected only by the things that happen near him in the virtual game area. The farther away another player is. the less important changes to<br><br>
WO 00/68864	11	'FCT/SE00/00932<br>
this player will be. For example, a player may be involved in a fight with a first hostile player, a friendly player may be coming to rescue and a second hostile player may be trying to stop the friendly player. At the same time, other players will be doing.things that may become interesting at a later time, but for the time being, <br>
5 	       the player's main concern is to survive the fight. Therefore, the movements of the first hostile player must be displayed immediately. The movements of the friendly player and the second hostile player should also be given a high priority, while the things happening farther away should be given a low priority. "<br>
l0        In the example discussed above, obviously, the configuration of the players will<br>
change so that at another time information from other players will have the highest priority, usually the players who are located near the user at any given time.<br>
The application access server handles communication with application clients. It re-<br>
15	ceives information about the actions of the client that affect the application state and other information. It also transmits application state information from other participants to the participants according to their subscriptions. Each application client sets subscriptions regarding which application information to receive and transmits information about these subscriptions to the application access server. The application <br>
20     	   access server stores and updates a record of the subscriptions of the clients that are served by the application access server. The subscriptions of each client are used to determine which data is to be sent to this client. A client might also set subscriptions for another client. In one mode of operation, a master client might for example set the subscriptions of all other clients.<br>
The application access server to which a client is connected is that client's local application access server, and the client is referred to as a local client of that application access server.<br>
30        The application access server also keeps a client authority list. Each client has the right to change the state of one or more game objects. The client authority list has<br><br>
WO 00/68864	12	-PCT/SEOO/00932<br>
one entry for each client where the identifiers of the objects that are controlled by the client are stored. The application access server checks the authority each time it receives object state information from a client. The game state will be updated only if an identifier found in the information packet matches one of the numbers in the <br>
5     	   entry for the client in the authority list, otherwise the information is ignored. Object state information arriving from other application access server units is not verified ;ince the sending application access server has already checked for authority.<br>
Each application access server also communicates with other application access <br>
10	server units, sending application state information and, optionally, aggregated subscriptions to them and receiving the same type of information from them. Usually, the information to be transmitted to the other application access servers is packaged according to an appropriate protocol and transmitted without being prioritized or sorted in any way. It would of course be possible to select the information to be <br>
15	transmitted to each application access server in dependence of the users' subscriptions of its local clients. Aggregated subscriptions are the sum of all application object requests from clients belonging to a given application access server. For example, the application access server may use multicasting to other application access server units. This ensures that each application access server unit receives all <br>
20   	     needed updates and that the game state is distributed efficiently over the application access server units.<br>
Urgency data is set by a client if the data is important to another client but this other client is not aware of this and therefore cannot set his own subscriptions. The ur-<br>
25  	      gency is therefore defined by the sending client and may be different for different receiving clients. The application access server alerts the receiving client if urgent data is waiting. The urgency information may also be used to prohibit the forwarding of certain information to one or more clients.<br>
30        Each application access server also stores and updates a complete or partial copy of the application state. Between them, the application access server units that are allo-<br><br>
WO 00/68864	PCT/SEOO/00932-<br>
cated to a communication session must store the complete application state. In the simplest case, every application access server stores the complete application state, but it is also possible to split the information between the application access servers, with or without overlapping information. Such solutions require special software to . handle the distribution of the appropriate data to each application access server.<br>
The application access server communicates with the application lobby server for setting up the application, adding and removing participants while the application is running and handling errors and network failures.<br>
Figure 2 shows an application access server 50 according to an embodiment of the invention, with its functional entities. This application access server could be implemented in hardware or in software. In connection with Figure 2, only a general description is given. Appropriate formats and protocols will be discussed later.<br>
The application access server receives data from each client in the network, and from other units, such as other application access servers, through input buffers 51. There is one input buffer for each client, remote application access server and application lobby server, although in Figure 2, for clarity, only one input buffer is shown.<br>
The actions of each local participant are sent as payload in application object packets that arrive in the input buffer of the application access server associated with this client. These application object packets update application objects that are controlled by the participant. The application object packets are written into the application state record using-a set of insertion rules.<br>
The data received from the clients may comprise three types of data: data about the state of the application (state data), data about the subscriptions of the client (priority data) and other control information, such as requests for time reference, status of other clients and other information from the system. The state data is passed<br><br>
WO 00/68804	14	PCT/SE00/00932<br>
through an application object packet pipeline 53, to an application state record 55. The application state record 55 keeps all the state data for all the relevant objects, as will be described in more detail in the following. The application state record also keeps the urgency data as described above. – <br>
5-   	    Groups of clients may be defined, said group for example comprising the participants in a working group or, in the case of a game, in die same team. In this case, subscriptions and/or urgency data may also be specified for groups of users, not only for individual users.<br>
10        Control data, especially data that does not have to be handled in real time, such as information on added or removed application objects, is passed from the input buffer 51 to the application access server control unit 57. In a hardware implementation the control unit 57 may be a microprocessor. Control data handled by the .   control unit could be related, for example, to the creation and destruction of players<br>
15        and objects, and to groups of players and objects.<br>
Subscriptions are passed through an application priority control protocol message pipeline 59 to a Client Priority List (CPL) 61 containing the subscriptions of each client that is supported by die application access server. The subscriptions can be <br>
20   	     updated by the clients and by the application access server control unit. The control unit could decide, for example, to update the subscriptions of a client in response to an urgency message received from another client.<br>
Several different prioritization strategies can be employed by die application clients<br>
25        using the application access server system.<br>
A simple method is that application clients send an enumerated list of objects to the CPL 61. In this case objects not on the list could be updated, for example, in a round-robin mode when all the objects on the list have been updated. If all objects in the list have been updated the remaining objects could be updated, for example in<br>
30        a round robin mode. The subscriptions of a particular client comprises a list of all<br>
objects for which a subscription has been set by this client. In addition the list stored<br><br>
WO 00/68864	15	PCT/SE00/00932<br>
in the application access server preferably comprises a flag for each object indicating if new information for the object has been received. The flag is used to determine whether or not information about a certain object needs to be sent to the client. When the information has been sent to the client, the flag is reset. When a new up-<br>
5    	    date for an object is received by the application access server, the flag is set again.<br>
The client subscriptions could also be defined with a time interval associated to each object. The client would then send a series of requests, for example of the format: <br>
10	<object number>, <object priority>, <object update time intervals>. A simple list could simply have the format <object number>, <object priority> The application access server will try to send updates to the client so that each object is updated at least once during each time interval with the priority given according to the <object priority> field in the request. An infinity symbol could be <br>
l5     	   used so that some objects are not updated at all. A special "send only new complete object state" flag can be set. This option is used when the client wants to receive updates for the object with long intervals (several seconds). It would be wasteful to send incremental updates if the wanted time resolution is longer than the state refresh interval. <br>
20<br>
An output pipeline 63 receives subscription information from the client priority list 61 and uses this information to search the application state record 55 for information to be transmitted to the client in question, using an appropriate algorithm as discussed above. The selected state information passes from the application state <br>
25   	     record 55 through the output pipeline 63 to an output buffer 65 and from the output buffer to the client. The control unit 57 sends control messages to clients and remote servers, for example, for the purpose of synchronizing clocks or providing latency estimates to clients.<br>
30	Although the application access server shown in Figure 2 is shown to have only one<br>
of each type of unit, preferably the application access server comprises one input<br><br>
WO 00/68864	16	PCT/SEOO/OO932 <br>
buffer 51, one application object packet input pipeline 53, one priority message pipeline 55, and one output processing pipeline 63 and one output buffer 65 for each client,, and for each other server, etc. in the network with which the application access server exchanges information. Alternatively, a group of clients or servers, <br>
5   	     could share one input buffer 51, one application object packet input pipeline 53, one priority message pipeline 55, and one output processing pipeline 63 and one output buffer 65. The application access server also comprises one client priority list 61 for each client, server, etc.<br>
10       The data received from other application access servers comprises object state data from other clients. It may also comprise priority information from these clients, which is preferably aggregated in such a way that each object appears on the priority list only once. In this case, the information will be packaged so that there is one priority list for each application access server, that is. each application access server<br>
15       is treated like a client. The information received from another application access server is treated in the same way as the information received from a client, except that the input and output buffers 51, 65, also have to perform certain protocol handling, as will be discussed below. Alternatively, no subscription information will be received from other application access servers, in which case all state information<br>
20        will be transmitted to these application access servers.<br>
The application access server may also handle optional fair play modes where all players are updated simultaneously (see below).<br>
25        As mentioned above, one or more application lobby servers (21 in Figure 1), of a kind known per se, may be present in the network. Application lobby servers are responsible for updating the configuration data during the game providing the application access server with data such as: • IP addresses or other network addresses of new application access server units<br>
30	that enter the game<br><br>
17<br>
•	Updated lists of network addresses identifying the participants served by the application access server. This enables new participants to join an ongoing application.<br>
•	Updated lists of enumerated game objects. For each object it is specified which<br>
|	application access server is responsible for storing the state, if the state is distrib-<br>
uted between the application access servers. It might also be specified who is authorized to update the state. This enables creation, destruction and change of control of game objects. Clients can also create and destroy game objects.<br>
•	A new complete or partial game state. This enables recovery after a pause or fail-<br>
10           ure in the game when the application access server system has discarded the<br>
game state.<br>
Figure 3 shows an example of an application state record used in the application access server according to the invention:<br>
15       The state of each application object is stored in the application state record as a set of enumerated application object states AOSl - AOS4. Each application object state consists of a series of application object packets AOP11- AOP13, AOP21-AOP24, AOP31 and AOP41-AOP42, respectively. An object packet is a container for object data. All data that is sent from an application to a remote application client or server<br>
20        is wrapped in an application object package so that it can be handled by the application access server system.<br>
The information received by an application access server from all other application access servers to which it is connected is used to update the application object in-<br>
35     	   formation in the application state record. Preferably, there are two types of application object packet: 1) a reference application object packet comprising all current data about an object, and 2) an incremental packet comprising only information about what has changed since a time that is given by the time stamp of the APO to which the incremental packet refers. The first AOP in an AOS must be a Reference<br><br>
WO 00/68864	PCT/SE00/00932<br>
packet, which may be followed by a set of Incremental Packets, or by a reference packet. Some games will only generate reference packets.<br>
The application state record also keeps a record of the application object packets that need to be delivered to other application access server units. This may be done using a data structure new_client_data that can be implemented as a matrix new_client_data(i, k) where each element is a flag. The parameter i is a client number and the parameter k is an application access server number. The flag is set if the application object packet should be delivered to the external application access server.<br>
As an example of how application object states can be used to describe application objects, Figure 3 shows an application object state AOS1. This object might describe the position of a vehicle in a racing game. The position of vehicle (xl, yl) is first sent as game payload in a reference application object packet AOP11 at game time tl. To save bandwidth, the relative change in the position (Δx2, Δy2) at game time t2 is transmitted as an incremental application object packet AOP12. The incremental application object packet AOP12 points to the reference application object packet AOP11 as reference. At game time t3 a new incremental position (Δx3, Δy3) is sent in a mird application object packet AOP13. The third application object packet AOP13 has the second application object packet AOP12 as reference. After having received all three application object packets AOP11, AOP12, AOP13, the client can calculate the position of the vehicle at time t3 according to (xl+Δx2+Δx3, yl+Δy2+Δy3).<br>
When a new reference application object packet is received for a particular object, the application state record can delete all previous packets belonging to the object and just store the new reference packet. Note that the syntax and semantics of the game payload can only be understood by the game application running on the client<br><br>
19<br>
terminal. Applications should send reference packets frequently in order to avoid long interrupts caused by lost data.<br>
An alternative way of coding the application would be to let the third application _<br>
.5 .	..    object packet AOP13 at time t3 use the reference application object packet AOP11 as reference and state only the change of position, Sx, 5y relative to (xl, yl). This would save application access server memory since the second application object packet AOP12 at time t2 could be deleted as soon as the third application object packet AOP13 arrives. The client would now calculate the position of the vehicle at <br>
10	time t3 according to (xl+δx3,yl+δy3). The application access server uses information in the application object packet header for determining if a previous application object packet is expired and can be deleted. In Figure 3 AOS 2 consists of four application object packets AOP21, AOP22, AOP23 and AOP24, where the first one AOP21 is a reference packet and the three following application object packets <br>
15       AOP22, AOP23, AOP23 are incremental. The last increment has time stamp t8.<br>
AOS 2 thus describes the state of object 2 up to game time t8. The AOS 3 in Fig. 3 consists only of one reference application object packet AOP31, which is sufficient for describing the object.<br>
20       Before allowing a new client to sign on to the application, the application access<br>
server may, according to a preferred embodiment, estimate the increased bandwidth needed and ensure that this bandwidth is available in the network. Methods for doing this are well known in the art. If no capacity problems are foreseen, this step will not be needed.<br>
25<br>
Figure 4 shows an embodiment of a computer on which a client according to the invention is running. The computer comprises a processing unit 101 in which programs are run, for example an application program 103 according to the invention. The processing unit also communicates with an application access server (not<br>
30        shown) and possibly other units in the network, by means of communications soft-<br><br>
WO 00/68864	19<br>
ware 105. The application program 103 communicates with communication software 105 through a network application interface 107. The network application interface has functions for sending,and receiving application data from the application program.<br>
The computer also comprises a screen 109 for displaying data about the application, for example an overview of the part of the game that is of immediate interest to the participant. For inputting data to the application, for example, the computer may have a keyboard 111, a mouse 113 and/or a joystick 115 connected to it, by means of which an object in the game may be moved, or other types of changes may be entered.<br>
The client application 103 receives said input, processes it and displays the result of it on the screen 109, and/or by means of for example loudspeakers and/or haptic <br>
15       display means. It also forwards application state data based on said input to the<br>
network application interface 107, from which it is forwarded to the application access server.<br>
Through the communications software 105 and the network application interface <br>
20 	       107 the application 103 also receives application state information concerning other objects from the game access server, processes it and displays the result on the screen 105.<br>
In this embodiment the network application interface 107 comprises two parts: an <br>
25   	     application programming interface 107A and an application access interface (AAI) 107B. This solution was chosen to enable the use of a standard program module, such as Microsoft DirectPlay, for implementing the network AAI 107B, as discussed below.<br>
30        The application access interface (AAI) 107B is a software module in the client terminal. It is an intermediate module between the network interface and the network<br><br>
WO 00/68864	21	PCT/SE00/00932<br>
API 107A. The application access interface 107B receives and terminates application object packets and control messages, and removes application object packet headers before the application object packet payload is passed to the network application interface 107. It also translates control messages and passes them to die API <br>
5	107A or handles them directly. The AAI 107B handles functions that are required for the communication with the application access server to function but that are not implemented in the client application program. Therefore, it may not be necessary for clients that have been developed for use with an application access server according to the invention. For example, the AAI can handle the clock that places <br>
l0    	    time stamps on the application object packages, if the client does not have functions for this.<br>
In the upstream direction, AAI 107B receives messages and objects from the API 107B. Data concerning application objects from the client is transformed into the <br>
15   	     application object packet format. Application object packets are transmitted over the communication link to the application access server.<br>
The AAI 107B also generates upstream application control protocol messages, in particular, application control protocol subscription messages. The information that <br>
20   	     is needed for setting up subscriptions and other application control protocol messages must be extracted from the application via the network API and from urgency list messages from the application access server.<br>
A physical client e.g. a game console could be engaged in several games or host <br>
25	several human players in the same game. Each physical application client can run several logical application clients where a logical application client corresponds to one instance of an application connected to one instance of the Application Access Interface. Application clients in this document correspond to a logical application client. A network address pointing to a logical application client could consist of the <br>
30   	    IP address of the physical client combined with the port number of the application access interface.<br><br>
WO 00/68864	PCT/SE00/00932<br>
21<br>
The best performance is achieved if the application access server system is considered when the application program is developed. Functions for determining subscriptions indicating the preferred order of receiving data can then be included in the application program. Messages could be. directly directed to a co-player with high urgency if it is apparent from the situation in the game that the receiving player cannot predict the high priority of the message. Consider e.g. a situation in a game where player 1 is stalking player 2. Player 2 is suddenly attacked by player 1 without having any warning. Player 2 is unable to set the correct priority for messages from player 1 but player 1 can send a high urgency message to player 2.<br>
For developing the network API, for example, the Microsoft DirectPlay API may be used. The AAI is then needed to format the output such as ACP and AOP, and may be written as a DirectPlay service provider.<br>
Using the Microsoft DirectPlay API .there are at least two different ways of extracting subscriptions. Note that the subscription should show the priority of the local participant for receiving updates about enumerated application objects. Application objects in this document are the same as "players" in the DirectPlay notation since DirectPlay "players" are application entities that can send and receive messages. A DirectPlay "player" can be controlled by a human player or it could be an autonomous game object.<br>
In the first method information gained from DirectPlay's receive method is used. By setting the DPRECEIVE_FROMPLAYER flag and specifying the lpidFrom parameter appropriately, the method can retrieve the first message from the "player" that is identified by the lpidFrom parameter. This information can be used by the application access interface for making the subscription. If no message from the identified "player" was available in the DirectPlay message queue, it would be reasonable to put the identified application object at the top of the priority list.<br><br>
WO 00/68864	.	PCT/SE00/00932<br>
In the second method the DirectPlay Send method is used, in which the idTo parameter identifies the "player" or player group that should receive the messages. It is reasonable to assume that "players" receiving frequent messages are associated with application objects with which the local player is presently interacting. The<br>
5-  -	    AAI could hence subscribe to "players" identified by the idTo parameter.<br>
Figure 5 shows an example of the communication stacks that may be used according to the invention. One communication stack is used for the communication between a client such as the one shown in Figure 4 and an application access server.<br>
10       The client and the application access server comprise essentially the same type of stack. In the client the uppermost layer of the stack communicates with the application access interface layer 10 of Figure 4, and in the application access server the stack communicates with an application access server software is also shown. Figure 5 also shows a communication stack for use between an application access<br>
15    server and another unit in the network. This other unit may be, for example, another application access server, or an application lobby server. The communication stacks used conform to the OSI model.<br>
The client communication stack communicates with the application programming <br>
20   	    interface 107 in the client. The uppermost level of the stack, is the ACP/AOP layer 109. This level is handled by the application access interface 107 in Figure 4.<br>
From the ACP/AOP layer 109 ACP/AOP packets containing information such as application object data or subscription information are delivered to a link layer 111.<br>
25       The link protocol may be for example PPP. In the opposite direction, the ACP/AOP layer 109 removes header information from information packets received from the application access server and forwards the application state information to the client application. The ACP packets may be terminated in AAI. The subscription itself can be handled by the client itself, if it comprises functions for handling the subscrip-<br>
30       tion.<br><br>
WO 00/68864	PCT/SE00/00932<br>
The lowest layer is a channel layer 113, comprising channel coding and the actual physical connection.<br>
The application access server comprises essentially the same type of stack for – <br>
5       communication with the client: a channel layer 113' corresponds to the channel<br>
layer of the client. The channel layer 113' is connected to an AOP/ACP layer 109' through a link layer 111'.<br>
An AOP/ACO layer 109' in the application access server communicates directly <br>
10       	 with an application access server software 115 which is arranged to handle the AOP and ACP information.<br>
The application access server can be built with interfaces to many different client link protocols. Ideally, an application access server should be able to handle any <br>
15    	    link protocol, including UDP, TCP and RTP. RTP is a protocol developed specifically for the transmission of voice and video data.<br>
The link protocol should be designed so .that the protocol overhead on the link from the application access server to the client is kept low. This can be done, for exam-<br>
20    	    pie, by using an appropriate link protocol where IP/UDP/RTP is not used or by efficient IP/UDP/RTP header compression. The link layer should further minimize latency and provide information to the application access server on the properties of the link. Such information could include expected bandwidth, bit error rate and link latency.<br>
An appropriate transport protocol, here called the application transport protocol, ATP should be used on the link but application object packets and application control packet messages could also be sent directly via the link protocol.<br>
30        For communication between two or more application access servers, a stream of IP packets are sent from the output buffer 65 of the local application access server (see<br><br>
WO  00/68864	25	PCT/SE00/00932<br>
Figure 2) to one or more remote application access server units participating in the ongoing application. Each IP packet contains a TCP or UDP packet and the TCP or UDP payload is an Application Transport Protocol (ATP) packet.<br>
|        The uppermost protocol layer of the communication stack for communication between two application access servers is an AOP/ACP layer 117 similar to the one used in the client communication -stack. An application object packet might be quite small, that is, ~ 40 bytes or less. To make the communication between two application access servers more efficient, several application object packets are therefore<br>
10        aggregated in an application transport protocol (ATP) layer 119. The next layer is a TCP or UDP layer 121 and the lowermost layer is an IP layer 123, both of which 121, 123 are well known in the art. From the IP layer information packets are transmitted to remote application access server units. The output buffer unit (65 in Figure 2) keeps a set of sorting buffers for collecting application object packets that<br>
15        will be the ATP payload. The structure of these buffers depends on the distribution strategy. There might be one sorting buffer for each remote application access server.<br>
An application object packet may include a field listing the clients that should get <br>
20   	     the update. This field is translated to a list of application access server units that<br>
should receive the application object packet. The application access server keeps a table that matches client numbers to application access server numbers. This means that all relevant application access server units eventually will get the update. The application access server units will then dispatch the application object packets to <br>
25   	     their local clients. A simple optional mode of operation is that all application access server units receive all application data.<br>
The local application access server identifies application object packets that need to be sent to remote clients via remote application access server units. The application <br>
30    	    state receiver of the local application access server is therefore scanned and application object packets with the new_client_data flag set are found. An application<br><br>
WO 00/68864	PCT/SE00/00932<br>
26<br>
object packet header comprises a recipient group field listing one or more client addresses to which the application object packet should be sent. This recipient group field is examined. Client addresses are translated to remote application access server addresses and copies of the application object packet are put into the sorting buffers <br>
5    	   that correspond to the recipient application access server units. The recipient group field is modified for each application object packet copy so that only recipient clients that belong to the receiving application access server or group of application access servers remain. The new_client_data flag is reset.<br>
10        Application Object Packets contain payload from the game application. The application access server system cannot read the internal payload format of the games. Such messages are therefore wrapped in an application object packet (AOP). The header of an AOP can be read by the application access server system. It is used for appending information that is needed for the timely delivery of the game payload,<br>
15<br>
In the embodiment discussed here, three non-standard protocols are used in addition to standard Internet protocols such as IP, TCP, UDP and RTP:<br>
•	Application Object Packet (AOP) is a container for game data. All data that is<br>
sent from a game application to a remote game client or server is wrapped in an<br>
20	AOP so that it can be handled by the application access server system.<br>
•	Application Control Protocol (ACP) is used for sending control messages. Con<br>
trol messages are sent between application access server units, clients and appli<br>
cation lobby servers.<br>
•	Application Transport Protocol (ATP) is used for sending aggregated game data<br>
25            between application access server units and optionally also between application<br>
access servers and clients.<br>
Application Object Packets contain messages from the game application. The application access server system can not read the internal message format of the games. <br>
30        Such messages are therefore wrapped in an application object packet (AOP). The<br><br>
27<br>
WO 00/68864	PCT/SE00/00932<br>
header of an AOP can be read by the application access server system. It is used for appending information that is needed for the timely delivery of the game payload.<br>
Application messages can completely define the state of an application object or<br>
 5       they can alternatively describe the application object relative to a reference state.<br>
AOPs are therefore of two types: Reference packet (BP) and Incremental Packet<br>
(IP).<br>
An application object packet consists of a header followed by game specific pay-load: Header fields that may be used in the AOP include: <br>
l0        1)  Application object number<br>
2)	Time stamp showing the time in the game when the AOP was generated<br>
3)	Optional packet number. Combined with the object number and the time stamp it creates a unique identifier of the packet. Packet numbers are only used if several AOPs, belonging to the same game object, have the same time stamp.<br>
15        4)  If, for example, voice and/or video information may be transmitted, a flag showing if the packet contains this type of information may be included.<br>
5)	A flag showing if the AOP is a reference packet or an incremental packet<br>
6)	If the AOP is incremental, a pointer to the reference AOP. This pointer could consist of the time stamp and the packet number of the reference AOP. The ref-<br>
20	erence AOP could be either a basic AOP or an incremental AOP.<br>
7)	A record describing the clients that should receive the message. This can be<br>
done by listing the clients or use a predefined client group. The default is that all<br>
clients receive the data. An urgency field is associated with each receiving client<br>
or client group. This field is used for alerting the receiver if the message is ur-<br>
25	gent-Three urgency bits would be sufficient.<br><br>
WO 00/6886-4-	PCT/SE00/00932<br>
Flags that can be set in the urgency field are,<br>
Forbidden: the AOP should not distributed to the client or client group<br>
Fair_Play: use fair play mode (see below)<br>
Very_Urgent: overrides client priorities<br>
5	Urgent: client will be alerted<br>
Normal: delivered according to client priorities<br>
Not_Urgent: delivered by best effort<br>
A simple format could be:<br><number of entries><client lxurgency for client lxclient><urgency for></urgency>
l0	client2&gt;	<br>
Later items in the list overrides previous items. The field:<br>
2, all Forbidden, client_3 Urgent<br>
could e.g. mean that all clients are forbidden to receive the AOP with me exception of client number 3 that will get the AOP in the Urgent mode. <br>
15        8) Size of payload.<br>
The application control protocol (ACP) is used for sending control messages between game clients, application access server units and the application lobby server (ALS). An outline of ACP is provided here. Each ACP packet consists of a header <br>
20	        and a message body.<br>
An ACP message may include the following fields:<br>
1)	ACP message type<br>
2)	Time stamp showing the time in the game when the message was generated<br>
'    3) Size of message<br>
4) Message body<br>
Note that the source of the message is identified by higher protocol levels. In the<br>
following the messages that can be transmitted using ACP will be outlined.<br><br>
WO 00/68864	PCT/SE00/00932<br>
ACP messages from client to the application access server may include the following:<br>
•	Terminate client. The, application access server management system removes the<br>
client from all records and notifies the Application Lobby Server (ALS). The cli<br>
ent is responsible for notifying the ALS if it is leaving the game. The ALS is re<br>
sponsible for finalizing the contact with the terminated client e.g. by sending the<br>
. final scores and notifying other players.<br>
•	Subscriptions<br>
•	Add game object. A new game object number is generated by the application access server and an application access server memory is allocated for receiving object state information from the client.<br>
•	Remove game object. The object is removed from all application access server memory after all clients and remote application access server units that are listed for receiving updates have received the last'update.<br>
•	Send estimated latencies for objects. This request includes a list of object numbers. The application access server responds by sending the estimated end-to-end latencies for the objects. The client application uses the estimates for latency hiding.<br>
•	Define object group. Object groups are useful for giving short names to long lists of object numbers that otherwise might have to be sent on the client link. Direct-Play handles hierarchical "player" groups so the game API will be able to provide useful group definitions. The application access server stores object group information and treats an object group as an alias for a list of objects. The message might have the format:<br>
message type = define object group; &gt; <object group name> <list of objects><br>
•	Define client group. Client groups are useful for setting short names on long lists<br>
of client numbers that otherwise might have to be sent over the client link in<br>
AOP fields. The application access server stores client group information and<br>
treats a client group as an alias for a list of clients. The message might have the<br><br>
WO 00/68864	PCT/SE00/00932<br>
format.<br>
message type = define client group <client group name><list of clients><br>
•	Send time reference. This message is used for downloading a reference time from<br>
the application access server.<br>
5<br>
ACP messages from the application access server to the client include the following:<br>
•	Urgency list. This message is used for alerting the client if urgent unread AOPs<br>
are waiting. The application access server scans all unread AOPs that has the<br>
10	present client on the AOP recipient list. The urgency list could have the format:<br><urgency class><list.of object numbers><urgency class><list of object numbers> and so on<br>
•	Latency estimate. This consists of a set of entries according to:<br><game object number><upstream latency><upstream latency variance><br>
15	<downstream latency><downstream latency variance><br>
A "don't know" symbol can be used for any field except the first.<br>
•	Confirm object group number. The application access server has received a "de<br>
fine object group" message from a client. It confirms that a global object group<br>
number has been allocated. The message body would include.<br>
20   .        <global object group number><client object group name> A simple method for allocating object numbers would be: Assume that a total of N application access server units are active. Enumerate all active application access server units. If application access server number k is asked for a new object number it allocates the lowest free object number from the<br>
25	series {k, N+k, 2N+k, 3N+k, ....}<br>
•	Confirm client group number. The application access server has received a "de<br>
fine client group message" from a client. It confirms that a global client group<br>
number has been allocated. The message body would include<br><global client group number><clients client group name><br><br>
WO 00/68864	31	PCT/3E00/00932<br>
     The same algorithm that is used for allocating global object group names could<br>
     be used for allocating client group names.<br>
    • Clock synchronization. The application access server sends a time reference ac<br>
      cording to:<br>
5	<client time> = <time> + <client link latency><br>
The client has an algorithm for adjusting the local clock according to a series of received clock synchronization messages.<br>
ACP messages from one application access server to another include: <br>
l0  	      •  Aggregated subscriptions. Aggregated priority lists showing the objects that the clients belonging to the sending application access server need to see, that is, the objects for which information should be sent to the sending application access server. The list has the same format as a simple client priority list. It is built by adding all valid local client priority lists and removing duplicates. <br>
15     	  •  Resend request. This message has the same format as a simple priority list and is interpreted as a request for resending the state of the listed objects.<br>
•	Define object group. Object group definitions may be distributed between appli<br>
cation access servers. Using global names for long lists of object numbers helps<br>
in reducing traffic.<br>
20        • Define client group. Client group definitions may be distributed between application access server.<br>
ACP messages from an application access server to an application lobby server include: <br>
25     	   •  Client has been terminated. This message is sent when a client has voluntarily disconnected from the game.<br>
•	Client time-out The application access server may send a message to the ALS if a<br>
client has been silent for a long time or if the link to the client is closed. The ALS<br>
decides on further actions such as removing the client from the game.<br>
30<br><br>
An ALS can act as a client. The ALS might e.g. control game objects that keep the scores of the game. A port of the ALS is then connected to the ALS as a client using a "link" protocol such as TCP/IP. The ALS can therefore use the same messages as a client. Other ALS to ALS messages are listed here: <br>
5        	Application set-up information, including<br>
•	Network address including port number identifying the ALS<br>
•	An URL that uniquely identifies the game<br>
•	IP addresses of other application access server units that participates in the game<br>
•	A list of network addresses including application port numbers that identifies the lip             clients.	,<br><br>
•	Optionally a list of enumerated game objects. For each object it is specified which application access server that is responsible for storing the state. It might also be specified who is authorized to update the state.<br>
•	Optionally, an initial game state to be stored.<br>
15        •  Optional data specifying control strategies such as the time-outs.<br>
•	Add application access server. The network address, number and client list of the new application access server is specified.<br>
•	Remove application access server. The number of the application access server to be removed is specified<br>
20        •  Add client. This includes the network address of the new client; optionally the initial state of the new game objects that are controlled by the new client.<br>
•	Remove client. The application access server system removes the client from the game.<br>
•	Modified client status. This message changes the clients authority to control<br>
25	game objects or associates the client to a different application access server. The<br>
format could be:<br><client number> application access server number&gt; <object numbers> where the object numbers indicates game objects that are controlled by the client.<br><br>
33<br>
WO 00/68864	PCT/SE00/00932<br>
The Application Transport Protocol (ATP) is used for transporting Application Object Packets (AOP) and Application Control Protocol (ACP) messages. The ATP has a series of AOPs and ACP messages in the pay load and is mainly used for sending aggregated data between application access server units. Application access <br>
5  	     server units would typically communicate using the protocol stack IP/UDP/ATP. ATP is hence on the same logical level as the RTP protocol.<br>
The ATP header includes:<br>
•	An URL that identifies the game <br>
10       • Earliest AOP or ACP time stamp<br>
•	Latest AOP or ACP time stamp<br>
•	Number of AOPs and ACP messages<br>
ATP is normally only used for communication between application access servers,<br>
15  	      as shown. If the bandwidth of the connection between a client and an application server is sufficiently high it may also be used for these connections.<br>
Conventional protocols such as TCP/IP and/or UDP/IP are used for communication with the Application Lobby Server and other application access server units.<br>
20        TCP/IP should be used for setting up the game and UDP/IP should be used for sending real-time game data, for the following reasons:<br>
TCP resending and reordering is too slow and complex for the game application. TCP reordering might delay the delivery of the most recent update for the purpose of delivering too old data. Resending of data that is no longer needed is obviously<br>
25        wasteful. The application access server units know the precise priorities and can request resending from several sources if needed.<br>
	RTP can be used for sending time stamps but RTP is designed for audio and video<br>
streams and is not very well suited for game streams. RTP could, however, be used<br>
30	for carrying voice and video streams that are associated with games.<br><br>
WO 00/68864<br><br><br><br>
PCT/SE00/00932<br><br>
A "fair play mode" may also be implemented in the system. In this mode the application access server units synchronize the delivery of critical application information so those updates are received by all clients concerned simultaneously. This <br>
5     	   mode can be used for competitions.<br>
The Application Lobby Server decides, while setting up an application, if the fair play mode is available. If the fair play mode is allowed, the sending client decides for each transmitted AOP if fair play delivery should be used. This is done by set<br>
10        ting the Fair_Play flag in the urgency field of the AOP. The application access<br>
server system is now responsible for delivering the AOP "simultaneously" to all clients. This requirement overrides all other client priorities.<br>
A possible technical solution for this is the "bucket synchronization" method. The <br>
15	application access server units agree to update the clients with a fixed absolute delay. Updates arriving earlier have to wait for the agreed time slot. This method has the disadvantage of increasing the overall delay in the system. The fair play mode can alternatively be handled by the game application. In this mode the client application applies the agreed delay to received game data using the time stamp of each <br>
20 		game object to calculate how much the packet should be delayed to achieve the agreed absolute delay.<br><br>
WO 00/68864	35	PCT/SE00/00932<br>
Figure 6 shows another embodiment of an application access server 150 according to the invention. Where nothing else is said, this embodiment is similar to the one discussed in the above. In this embodiment the communication functions of the application access server are divided between one or more application routers 152 and an application server 154. The application server 154 comprises an application state record 155 and a client priority list 161 as described in connection with Figure 1. The application router 152 communicates with one or more clients 170, through the client's application programming interface API 172, which will be discussed in more detail below. Each application access server 150 comprises one application server 154 serving one or more application routers 152. The application router 152 also communicates with other nodes in the network, such as application routers in other application access servers (not shown). Preferably, the application server 154 and the application router 152 are implemented as separate hardware units to optimize each with regard to their specific functions. Alternatively, they may have separate processor resources allocated to them. In particular, the application router must run without interruption since interruptions would affect negatively the real-time performance of the client applications.<br>
As before, the application access server to which a client is connected is that client's local application access server, and the client is a local client of that application access server. Similarly, the application server and the application router serving the client are the client's local application server and application router.<br>
The application server receives ATP packets containing basic objects (see below) and control messages from clients through the application router. Before processing a basic object e.g. by putting it in the application state database, the application server checks that the sending client is allowed to update the object. If the client is not authorised to update the object, the object is rejected and the sending client may receive an error message. Before processing a control message, the application server<br>
checks that the sending client is allowed to request the indicated operation, and if not rejects the control message and optionally sending an error message back<br><br>
WO 00/68864	PCT/SE00/00932<br>
to the sending client. Consider e.g. a case when the sending client requests that an object group is deleted. This group might have been created by the content server, which is a special client, responsible for managing the game state and communicating with the application access server over a standard client API. The <br>
5   	    content server has uploaded authorisation rules to the game access server that forbids clients to delete the object group. In this case, the application server will reject the control message that requests the deletion of the object group.<br>
This authorisation check is performed using tables of authorisation rules that shows <br>
10   	     what kind of operations that the client is allowed to perform. The authorisation tables are set up by clients or by the control units using initialization files.<br>
A client can, if authorised to do so, request the creation of an object group. A client can also add members, remove members and delete the object group. Members of<br>
15        the an object group are objects and object groups. Request for any such operation on object groups are sent by the client as a control message which is broadcasted by the application routers to all application servers that participate in the session. The object group is identified by an identifier which has the same format as an object identifier. Each application server includes an object group database 162 that for<br>
20        each application session stores the object groups that has been created during the session. The object group database 162 stores at least the following fields for each object group: 1) the object group identifier 2) a list of the members of the object group 3) a list of the parents of the object group. A parent of an object group A is an object group that has the object group A as a member. The object database is<br>
25        organised as the object database in the previous embodiment but for each object there is a list of object groups that are parents to the object.<br>
Objects received from clients, and from other application access servers, that should form part of the application state is forwarded from the application router 152 to the <br>
30      	  application server 154 and stored in the application state record 155. Subscription<br><br>
WO 00/68864	-PCT/3E00/00932<br>
36<br>
information received from clients and other application access servers is forwarded to the application server 154 and stored in the client priority list 161.<br>
A site manager 174 controls the function of one or more application access servers <br>
5  	     150, each comprising one or more application routers 152 and an application server 154, preferably through a connection to the application router 152. The site manager could also use the standard protocol SNMP (Simple Network Management Protocol) to control the site.<br>
10        One site therefore comprises one site manager and a number of application access servers 150 controlled by one site manager 174. The main tasks of the site manager 174 are connection management, client connections, resource management, configuration of application servers and routers, admission control, authentication of clients, time synchronisation for a site, network management and supervision of<br>
15       load and status of application servers and application routers.<br>
The site manager optionally receives Application Transport Protocol (ATP) packets containing control messages from clients. It should be noted that the ATP in this embodiment is different from the ATP described in connection with the previous<br>
20        embodiment and will be described below. Before processing a control message, the SM checks that the sending client is allowed to request the indicated operation, if not the control message is rejected and the sending client receives an optional error message. This authorisation check is performed using tables of authorisation rules that shows what kind of operations that the client is allowed to. The authorisation<br>
25        tables are set up by clients or by a lobby access servers 78, using initialization files.<br>
One or more lobby access servers 178 are provided for connection to the application lobby server 176, one or more lobby access servers 178. The application lobby server is discussed in connection with Fig. 2. The lobby access server or servers 178 <br>
30  	      are connected to the site manager 174. The lobby access server handles game session requests from lobby servers and arranges and manages game sessions. This in-<br><br>
WO 00/60864	PCT/SE00/00932<br>
eludes registration and authentication of lobby servers, and accounting. It also keeps information about games and lobby severs in a database. A central control unit (not shown) may be used to supervise and maintain the application communication system.<br>
5<br>
An application communication system comprises one or more interconnected sites and lobby access servers. A central control unit (not shown) may be used to supervise and maintain the application communication system.<br>
10        The lobby access server 178 may comprise or be connected to a database 180 comprising information about the application lobby servers present in the network, such as which application lobby server or servers are allowed to add clients to a particular game, or a particular application access server. The application lobby server 176 may comprise, or be connected to, a database 182 comprising client data such as<br>
15        authorization profiles for each client.<br>
The communication between the site manager and the application server or servers it controls includes adding and removing sessions, and adding and removing clients from sessions. The communication between the site manager and the application <br>
20   	     router or routers includes the same as above as well as login permissions for clients. Also, error messages are sent from the application server or application router to the site manager.<br>
Preferably, the local application router 152 can handle both stream objects and basic <br>
25	objects received from clients, other application routers or other units in the network. Clients send one copy of each update of a basic object to the local application access server. The object contains e.g. the status of the player's avatar. The basic object is forwarded to all relevant application servers in the session. Basic objects received by an application router from clients or other application access servers are <br>
30   	     stored in the application state record of the associated application server. Players that want to receive the stream object issues a subscription to the local application<br><br>
WO 00/68864<br><br>
39<br><br>
PCT/SE00/00932<br><br>
server. The application server sends a series of updates of the object from the local application state record according to the parameters of the subscription. Stream objects are not stored in the application server. Basic objects and stream objects will be discussed in more detail in the following. An application router receives Application Transport Protocol (ATP) packets from clients, the local application server, from other application routers and optionally from the local site manager. ATP packets are transported through other network protocols, such as UDP/TP. Other application routers are either remote (belonging to a remote Application Access Server) or local (belonging to the same Application Access Server as the application router). The received ATP packets are of three different types: basic objects and stream objects in Application Object Packets (AOP), control data in Application Control Packets (ACP), and client messages in Client Message Packets (CMP). ATP packets are either deleted or routed by unicast or multicast to receiving clients, application routers, the local application server or to the local site manager. The different routing cases are shown in the table. Control packets that are addressed to the receiving application router are terminated and not routed.<br>
A routing table for an application router is shown in the table below:<br><br>
Received ATP packet<br>
Stream object from client<br><br>
Routed to the following nodes<br>
Local clients that are subscribing to the stream object<br>
Other application routers that has clients that are subscribing to the stream object<br>
All other application routers<br>
Clients (if any) that are specified in the optional address field of the AOP. Remote clients are reached via their local application routers.<br><br>
Manda-<br>
tory(M)/<br>
Optional(O)<br>
M<br>
M<br>
O<br>
M<br><br>
Comment<br>
A special case that is easy to implement<br>
Direct addressing requires more bandwidth than subscriptions and should be used sparingly.<br><br>
WO 00/68864<br><br>
40<br><br><br>
PCT/SE00/00932<br><br><br>
Basic object from client	The local application serverClients (if any) that are specified in the optional address field of the AOP. Remote clients are reached via their local application routers.	| M M	<br>
Client message from client	Clients that are specified in the address field of the CMP. Remote clients are reached via their local application routers.	M	<br>
Control packet from client	The local application serverThe local application routerThe local site manager	0 0 0	Depending on the nature of the message<br>
Basic object from local application server	Clients that are specified in the address field of the AOP.Remote application servers (via one of their application routers) that are specified in the address field of the AOP.All remote application servers optionally via a multicast addressRemote clients that have subscribed to the object (via their application router) that are specified in the address field of the AOP.	M M0 0	A special case that is easy to implementA special case that is expensive in bandwidth but makes the game state well defined at any given time<br>
Control packet from local application server	Clients, local site manager, remote application server or application router that are specified in the address field of the ACP.		<br>
Stream object from application router	Local clients that are subscribing to the stream objectClients and application	MM                     !	iii<br><br>
We 00/68864<br><br><br><br>
PCT/SE00/00937<br><br><br>
	routers (if any) that are specified in the optional address field of the AOP. Remote clients are reached via their local application routers.		<br>
Basic object from application router	The local application serverClients (if any) that are specified in the optional address field of the AOP.Remote application servers (via one of their application routers) that are specified in the optional address field of the AOP.	MM M	<br>
Control packet from application router	Clients, local site manager, remote application server or application router that are specified in the address field of the ACP.	M	<br>
Control packet from the local site manager.	Clients, local or remote application server or application router that are specified in the address field of the ACP.	M	<br>
Stream objects are not stored in the application server. Clients typically use them for sending the position of moving items in a virtual world. They can be transported very fast through the network. Only the most recent version of a stream object is assumed to matter for the receiving client. The handling of stream objects is typically unreliable, as they may be dropped deliberately by application routers for flow control. All stream objects received by an application router are forwarded to all local clients that have subscribed to the stream object, or to a stream object group comprising the stream object. The application router 152 also comprises priority or subscription information for stream objects, since these objects are not handled by the application server, as will be discussed below.<br><br>
WO 00/68864<br><br>
42<br><br>
PCT/SE00/00932<br><br>
Typically a client who wants to join an application session, for a example a particular ongoing multiplayer session, connects over the Internet to a application <br>
5        lobby server 176. The application lobby server provides information on ongoing<br>
application sessions and usually also allows clients to create new sessions and invite other clients to join. A client may send a request to the application lobby server 176 to create, delete, join or leave an application session. If the application lobby server accepts any such session control request it will forward the request to a lobby access<br>
10        server 178. If creation of a session is requested the lobby access server 178 will<br>
respond by issuing a application session identifier. For requests such as a request to delete a session or add or remove a client the application lobby server 176 will include the application session identifier in the request that is sent to the lobby access server 178. The lobby access server 178 responds by investigating if<br>
15        resources are available in the application access server system to match the<br>
requested operation. If resources are available, the lobby access server 178 will perform the requested operation.<br>
If creation of a session is requested the lobby access server 178 will select a set of <br>
20        sites that will serve the session and send control messages including the session<br>
identifier to the relevant site managers 174 requesting that the session is initiated on suitable application access servers 150.<br>
If deletion of a session is requested the lobby access server 178 will send control <br>
25     	   messages including the session identifier to the site managers 174 of the sites that are running the session requesting that the session is deleted.<br>
If joining of a client is requested the application lobby server 176 includes at least the network address of the client 170, the session identifier and optionally a site <br>
30    	    identifier in the control message to the lobby access server 178. The network<br>
address might e.g. be the IP address and the port number of the client application<br><br>
WO 00/68864	PCT/SE00/00932<br>
process. The lobby access server 178 selects a suitable site and sends a control message to the site manager 174 of the site requesting that the client 170 joins the game session. This control message includes at least the network address of the client 170 and the session identifier to the site manager 174 of that site. The site manager selects a suitable application access server and a suitable application router within that unit to be responsible for serving the client and sends a control message to the client 170 inviting the client to join the game. The network address of the application router that will serve the client and a password is included in the message. The client 170 contacts the relevant application access server 150 including the password in the control message. The application access server 150 includes the client 170 in the local client database and the client can proceed with sending and receiving game data.<br>
Alternatively, the site manager 174 can send the network address of the application <br>
15 	       router 152 that will serve the client 170 to the lobby access server 178, the lobby access server 178 will forward the network address and a password to the application lobby server 150. The application lobby server 176 will forward the network address and a password to the requesting client 170 that connects to the relevant application access server as described above.<br>
20<br>
Although no buffers, software processes etc. are shown in Figure 6, it will be appreciated by the skilled person that they may be needed to implement the application access server of the invention.<br>
25        Clients 170, application access servers 150 and site managers 174 communicate<br>
using the Application Transport Protocol (ATP). ATP packets are typically carried as payload in UDP packets as discussed in the previous embodiment. The ATP used in this embodiment will be described in the following. The Application Transport Protocol includes two protocol levels 1) compound ATP packet 2) regular ATP<br>
30        packet.<br><br>
A compound ATP packet comprises a of a Source Header and several regular ATP packets. The Source Header comprises the following fields:<br>
1)	Application session identifier<br>
2)	Client identifier indicating the sending client<br>
5       3) Optional fields that are used by the protocol for guaranteed transmission including acknowledgement fields and packet counters.<br>
A regular ATP packet (in the following also, called "ATP packet") consists of an ATP header, an ATP optional header, an optional ATP Target Header and an ATP <br>
10      	 Content Packet.<br>
The ATP header may include the following fields:<br>
1)	A Type Field, which is a set of flags indicating the type of the Content Packet<br>
and the presence of optional fields in the Content Packet. Content packet types<br>
15	are, control message, client message, basic object or stream object. The intended<br>
receiver of a message can be indicated in the Type Field.<br>
2)	A flag indicating if the ATP packet is sent in the reliable or the unreliable mode<br>
3)	A flag indicating if a Target Header is present<br>
4)	A set of flags indicating the presence and content of the ATP optional header.<br>
20        5) A field indicating the size of the content packet<br>
The ATP optional header consists of the following optional fields:<br>
1)	session identifier<br>
2)	client identifier 25        3) object identifier<br>
         The ATP optional header is used for identifying the Content Packet. The application<br>
       payload that is associated with a basic object might e.g. be sent in the Content<br>
      Packet. The ATP optional header is used for identifying the the basic object using<br>
30	the relative addressing system that is .described below.<br><br>
WO 00/68864	PCT/SE00/00932<br>
The ATP target header TH is used for direct addressing of ATP packets. The ATP address of the receiver is indicated in the ATP target header. The first position in the TH is a byte that holds the size of die TH. The TH consists of an array of dynamic address fields that is either a list of client identifiers indicating the intended <br>
5    	    receivers of the message or a list of stream object keys. A key is an attribute of the stream object that may be set by the sender. Clients can subscribe to stream objects that carry a specific key without knowing the object identifiers of the wanted stream objects. In a game like Quake, keys can be used for selecting stream objects belonging to different rooms. The stream objects are used for sending the positions<br>
10       of the avatars in the game. A key is assigned to each room in the game. Players that are sending stream objects add the key that corresponds to the room where the avatar is located. Players that are receiving data subscribe to stream objects with keys that correspond to rooms in which they are interested. Stream object keys can alternatively be used to identify a team or to classify objects, for example, as<br>
15       dangerous. A stream object filter in the local application access server receives the player's subscriptions for stream object; keys and ensures that the player gets stream objects with the requested keys.<br>
The ATP Content Packet (CP) can be of any of the following types 1) basic object <br>
20  	      2) stream object 3) control message 4) client message. A basic object, stream object and client message CP includes application payload. Control messages include a message type and message parameters. The Aplication Control Protocol specifies the format of the message type field and the parameters of each message.<br>
25        Session identifiers, client identifiers and. object identifiers are dynamic address<br>
fields as described below. Client groups and object groups have the same identifier format as clients and objects, respectively.<br>
The following names and definitions are used in this document. An Application <br>
30  	      Object Packet is an ATP packet that contains an application object in the Content Packet. An Application Control Protocol packet is an ATP packet that contains a<br><br>
WO 00/68864	46	PCT/SE00/00932<br>
control message in the content packet. Sending a basic object, stream object or client message means always that an ATP packet with the appropriate type of content packet is sent. A client message packet is an ATP packet containing a receiver address and a client message in the content packet.<br>
ATP usage examples include the following:<br>
A)	A client is sending a basic object to the local application server. The object identifier but not the client identifier or the session identifier are put in the ATP optional header. No ATP target header is needed. The object payload is put in the content packet. The use of optional headers and dynamic address fields means that the header overhead can be as small as four bytes. This is essential since objects are often sent over a low bandwidth connection.<br>
B)	A client is sending a client message to another client. The object identifier and the client identifier of the sending client are put in the ATP optional header. No<br>
15	session identifier is needed. A target header is used containing the client<br>
identifier of the receiving client. The message payload is put in the content packet. The input filter of the application router on the sending side adds the session identifier to the target header. The output filter of the application router on the receiving side removes the session identifier before forwarding the packet<br>
20	to the receiving client.<br>
ATP uses dynamic address fields. A dynamic field is a variable length prefix code. . A prefix code is a code where each code field in a bit stream can be uniquely decoded without reference to previous code words. A simple example is the alphabet<br>
25        {10, 110, 1110, ....}. Huffman codes are optimal (shortest expected length) prefix codes for a given statistical distribution of symbols.<br>
An alternative format of dynamic address fields is dynamic size integers. Dynamic size integers are well known in computer science. Dynamic size integers are used whenever small values are most common, but large values must be possible. For 2-<br>
30        byte dynamic size integer, the most significant bit tells the size of the integer - 1<br>
means one byte and 0 means 2 bytes. For 4 byte dynamic size integers. the two most<br><br>
WO 00/68864	47	PCT/SE00/00932<br>
significant bits tells the size of die integer - 01 means one byte, 10 means two bytes, 11 means 3 bytes and 00 means 4 bytes.<br>
Dynamic address fields may be used according to one of the following two <br>
5     	   methods:<br>
In the first method, ATP has fields for three different identifiers 1) application session identifier 2) client identifier and 3) object identifier. The application session identifier is globally unique and allocated by a central authority"such as the net manager or lobby access server. Each client, application router, application server <br>
10   	     and optionally site managers has a client identifier and are in the following called nodes. A client group identifier has the format of a client identifier.<br>
The client identifier is unique only in a specific application session. A central authority such as the or lobby access server or a central control unit allocates client<br>
15       identifiers. The client identifier identifies the node only if the applicaction session identifier is known. ATP stores the client. identifier in a dynamic field. Each node in an application session is allocated a client identifier with as few bits as possible. Frequently used client identifiers may be allocated the shortest codes e.g. according to the Huffman coding procedure.<br>
20<br>
The object identifier is unique to a given client in a given session. The client allocates the object identifier. The object identifier identifies the object only if the session identifier and client identifier is known. ATP stores the object identifier in a dynamic field. Each object is allocated an object identifier with as few bits as<br>
25        possible. Frequently used object identifiers may be allocated the shortest codes e.g. according to the Huffman coding procedure.<br>
           The second method is the same as the first, with the following exception. The client<br>
          identifier consist of two dynamic fields. The first field is the identifier of the<br>
30	application router that is serving the client. The second dynamic field is a client<br>
index. This index is selected to be as shore as possible and is unique to the client<br><br>
WO 00/68864		PCT/SE00/00932<br>
given that the application session identifier and local application router client identifier is known. The client identifier of the local application server can alternatively be used instead of the client identifier of the local application router.<br>
5       The advantage Of using dynamic address fields and relative addressing as described above is that the bandwidth usage and delays are minimised. Only the relevant address fields are sent. Examples of this are:<br>
1)	A client participates only in one application session. ATP packets containing<br>
objects from the clients contain only the object identifier. The application ses-<br>
10	sion identifier and the client identifier are not sent, since the application router<br>
knows this implicitly.<br>
2)	ATP packets containing objects that are sent from the local application server to<br>
the client need only to include the object identifier and the client identifier of the<br>
client that owns the object.<br>
15        3) A client that creates a new object can immediately allocate an object identifier. Central allocation of globally unique object identifiers would require communication with the central authority before a new object can be created.<br>
The client group addressing is handled according to the following: A client group is <br>
20  	      identified in ATP by a client identifier. The identifier is created using the same method as for other client identifiers. Creation of a client group is requested by a client during the application session or the creation of the client group is performed as a part of the initialization of the session.<br>
25        Each ATP packet includes a Type Field in the ATP header. The Type Field<br>
indicates the nature of the content. Different codes in the type field indicate e.g. that the content is basic object, stream object, control packet or a client message. The application router can use the type field for default routing in some cases without reading and analysing the address fields. Examples of default routing based on the<br>
30        type field are:<br><br>
WO 00/68864	49	PCT/SE00/00932<br>
1) all basic objects are routed to the local application server 2) control packets with one specific code in the type field are routed to the local application server and control packets with one other specific code in the type field are routed to the local site manager.<br>
Figure 7 shows an application router 152 used in the embodiment discussed in connection with Figure 6, and how ATP packets flow through the application router. The application router 152 consists of a set of input filters 190, 192, a router core 194 and a set of output filters 196, 198. The application router has an input and an <br>
10    	    output filter for each node with which it communicates. The router core 194 comprises a number of routing tables 199 for performing the routing of ATP packets.<br>
Packets come from three types of sources - from the application server of the same <br>
15	application access server, and other similar units, e.g. the site manager, from other application routers and from application clients connected to this application router. There are different routing tables 199 for all three types. There is one incoming filter 190, 192 and one outgoing filter 196, 198 for every connection to another application router or an application client. For the connections to the application <br>
20        server, no input or output filters are needed. The filters implement assembling<br>
several application packets into transport packages and also handles resending for reliable packets. The application client output 196, 198 filters remove redundant information on the client line and also supplies load balancing for the downlink to the application client 170.<br>
The client 170 that is associated with the output filter, or any other client that is authorised, can send a subscription for a stream object or a stream object key to the output filter of the receiving client. The subscription is sent as a control message that indicates the content of the subscription and the client identifier of the receiving <br>
30  	      client. The output filter will scan stream objects that arrive to the application<br>
routers. Stream objects matching the subscription are sent to the client, possibly<br><br>
WO 00/68864	PCT/SE00/00932<br>
50<br>
after applying a drop rate. A stream object matches a subscription either if the object identifier of the stream object is equal to the object identifier that is given in the subscription or if a stream object key that is carried by the stream object matches a stream object key that is given in the subscription.<br>
Consider a case when the client (that is associated with the output filter) has subscribed to a stream object and the stream object is received from the sending client. The client or any other client that is authorised can set a droprate that is associated with a given stream object. This droprate is sent in a control message to <br>
10  	     the local application router. If the droprate is set to a value 0 
The output filter will delete ATP header fields that do not need to be sent to the <br>
15  	 .    client. A direct addressed message from another client contains e.g. the application session identifier and the client identifier of the receiving client in the header. This information is not useful to the receiving client and is therefore deleted by the application router output filter.<br>
20       The input filter for a specific node, such as a client, receives ATP packets<br>
containing stream objects, basic objects, control messages and direct addressed client messages from the node. Before sending the ATP packets to the routing core the following operations is performed:<br>
1) The input filter checks if the client is allowed to update a stream object or a<br>
25	basic object or if the sending client is allowed to send a direct addressed<br>
message to the client that is indicated in the message. This authorisation check is performed using authorisation tables that shows what kind of operations that the client is allowed to perform. The authorisation tables are set up by clients or by the LAS via the site manager using initialization files.<br><br>
WO 00/68864	51	PCT/SE00/00932<br>
      2) The input filter adds the address of the sending client in the appropriate ATP<br>
           field. This address is not sent on the communication link between the sending<br>
        client and the application router in order to save bandwidth<br>
      3) The application router stores lists of client groups. Such lists associates a client<br>
5	identifier that indicates a client group to a list of client identifiers that indicates<br>
            clients. Lists of client groups are set up by clients or by the LAS via the site<br>
            manager. If an ATP packet with a client group in the reciever address fields is<br>
       received by the input filter, it will do one of the following three alternative<br>
         operations: A) Find the list of client identifiers that belongs to the client group.<br>
10	Find the number N of application routers that should receive at least one copy of<br>
         the ATP packet. Make N copies of the ATP packet that is put in the output filter<br>
        to each of the receiving application router. There is a flag in the ATP header that<br>
        indicates that the content should not be distributed to any remote receiver but<br>
        only to local clients. This flag is set in each output packet. This is the preferred<br>
15	mode of operation.<br>
4) Find the list of client identifiers that belongs to the client group. Find the<br>
         number N of application routers that should receive at least one copy of the ATP<br>
       packet. Make N copies of the ATP packet that is put in the output filter to each<br>
         of the receiving application router. In each packet replace the client group<br>
20	identifier with a list of receiving clients where the list includes only members of<br>
           the client group that are local clients to the receiving application router.<br>
         Duplicate the ATP packet so that in each duplicate the client group identifier is<br>
         replaced with one unique client identifier indicating one of the clients in the<br>
      client identifier list that is associated with the client group.<br>
25        5) A default header is stored by the input filter for each stream object that the client<br>
          that is associated with the input filter is sending. This default header contains the<br>
        stream object keys associated with the stream object. If the client sends an<br>
        explicit header containing stream object keys this header will replace the default<br>
          header that is stored by the input filter. If the client sends the stream object<br>
30	without a header containing stream object keys, the input filter will add the<br>
default header to the stream object before sending it to the router core. This<br><br>
WO 00/68864	52	PCT/SE00/00932-<br>
means that the sending client do not have to send one copy of the stream object keys with each copy of the stream object. It is sufficient to send a header containing the stream object keys each time that the keys are changing and the first time that the stream object is sent, <br>
5<br>
A regular ATP packet carries a content that is either an application object (stream or basic), a control message or a client message. A compound ATP packet consists of an optional small compound header and at least one and usually several regular ATP packets. A compund ATP packet is sent as payload in a standard transport <br>
10  	      protocol. Usually compound ATP packets are sent as payload in UDP packets.<br>
The method for collecting regular ATP packets in compound ATP packets is essential for achieving the correct balance between bandwidth efficiency and low latency. Large compound ATP packets gives high transmission latency but low <br>
15  	      header overhead and hence efficient bandwidth utilisation. Aggregation of regular ATP packets into compound ATP packets takes place in several modules of the system.<br>
For aggregation in the application client for sending to the local application router, <br>
20    	    two alternative methods may be used: In the first method, aggregation is under<br>
direct control of the application program. Regular ATP packets are sent to an output buffer. The application program decides when the content of the buffer is put into a compound ATP packet and is transmitted to the local application router. In the second method, the aggregation is performed by an automatic algorithm in the <br>
25	client. Regular ATP packets are sent to an output buffer by the application program. The algorithm decides when the content of the buffer is put into a compound ATP packet and is transmitted to the local application router. An example of a suitable algorithm is: A compound packet is sent if the buffer size exceeds a given size S. A compound packet is sent if the time since the last transmission of a compound <br>
30    	    packet exceeds a given time interval T. The parameters S and T are set by the application program.<br><br><br>
For aggregation in application router for sending to a client, for example, the same algorithm as in the second method above may be used.<br>
For aggregation in application router for sending to a application router, sending the <br>
5   	     maximum size ATP compound packet that is allowed by the next protocol level e.g. UDP will usually work well, since the communication link between application routers can be assumed to be very fast and regular packets are sent very frequently.<br>
If the bandwidth is constrained or ATP packets are sent infrequently it is advised to <br>
10   	     use the same algorithm as in method 2 of the previous section on,aggregations in the application client.<br>
The size S (in bits) should be selected as S 
15    	    and TO is the allowed transmission latency usually 1-10 ms. The time interval T should be in the intervall l-10ms.<br>
Clients can send subscriptions for basic objects as control messages to the local application server. A subscription specifies the receiving clients, a target for the subscription and subscriptioTrparameters. A subscription is an instruction to the application server to send a series of basic objects to the receiving clients. A series of updates of each basic object is sent according to the parameters of the subscription and depending on how the source of the basic object updates it.<br>
25        The client sending the subscription is usually the receiving client but a client may also make a subscription on behalf of another client. A subscription can also be issed on behalf of a client group. All clients in the client group will then receive the result of the subscription.<br>
30        The target for the subscription is a set of basic objects identified by object<br>
identifiers according to the ATP protocol. The target can be described by 1) an<br><br><br>
WO 00/68864	54	PCT/SE00/00932-<br><br>
object identifier, 2) a set of object identifier 3) an object group identifier 4) a mixed set of object identifiers and object group identifiers 5) general Boolean expression including object groups and objects as operands and logical operators AND, OR and NOT. A correctly defined target expression is evaluated by the application <br>
5    	    server using the information in the object database and the object group database. The result of this evaluation is always a finite set of basic objects.<br>
Subscription parameters may be used to specify how often, how many times, and for how long the content of the subscription is to be delivered. This may be <br>
10        specified as the maximum rate at which updated versions of the object should be<br>
received. If the owner of the object updates it at a slower rate, each new version will be received as soon as it is delivered. If the object is updated faster than the selected maximum rate, the updates will be received at precisely the selected rate. Some of the intermediate versions will not be received in this case.<br>
15<br>
A content server or master client may have superior knowledge of the state of the game. It could therefore be suitable that the master client subscribes to basic objects on behalf of a target client. The master client then builds and submits the subscription to the system. The local application access server delivers the basic <br>
20        objects requested in the subscription directly to the target client or target client group.<br>
A subscription belongs to a client or a client group. A subscription refers to a set of game objects. This set can be expressed as a general Boolean expression including <br>
25   	     object groups and objects.<br>
The Application Access Server (AAS) will try to deliver objects with the subscription frequency. The delivery time is the inverse of the subscription frequency. Objects that exist in the database when the subscription is issued will be <br>
30   	     delivered within the delivery time. If an object in the database is modified while the subscription is active, The AAS will try to deliver it within the deliver.' time.<br><br>
WO 00/68864<br><br><br><br>
PCT/SE00/00932<br><br>
A Subscription Class is a positive integer. Two methods for delivering data according to the subscription class is described here.<br>
5        Method 1: Subscriptions with the highest class are first satisfied completely. Next,<br>
        the AAS will try to satisfy the subscriptions in the next highest class completely.<br>
       This means that subscriptions in lower classes never might be satisfied. If the<br>
         bandwidth is insufficient for delivering objects within a subscription class with the<br>
         requested frequency the AAS will scale all frequencies within the class so that it<br>
10	becomes feasible to deliver to the client.<br>
Method 2: Three different classes are used. The different classes are called 1 = HIGH, 2 = MEDIUM and 3 = LOW. With class 1 the object is always sent to the subscriber at maximum rate until the buffer is full and the rate drops to zero. With <br>
15  	      class 2 the object's send rate to the subscriber is proportional to buffer load. The less buffer capacity the lower rate. With class 3, the object is sent to the subscriber only if there are no other objects in the buffer.<br>
In one specific implementation application object packets may include several enu-<br>
20  	      merated payloads. In that case subscriptions have an optional Weight parameter. The Weight parameter is an integer. Weight = n means that the first n payloads in the object are delivered.<br>
Some objects may not be updated at regular intervals, but instead an exact number <br>
25	of times. Therefore, it is possible to request a specific number of updates regarding a particular object. The application server will then set a counter that is associated with the object to an integer value that is specified in the subscription. The counter is decremented by one unit each time that the object is delivered. The subscription is removed if Counter = 0. <br>
30<br><br>
WO 00/68864	__	                                         PCT/SE00/00932<br>
55<br>
The client may request that the object be sent at the requested frequency even if the same update has been sent before. This is done by setting the "forced sending" FS flag.<br>
5      Also, to prevent information relating to old subscriptions to overload the network, the time to live, or duration of a subscription should be set. The subscription is removed after the subscription time-to-live expires.<br><br>
Stream objects are distributed between application routers using one of the <br>
10        following methods:<br>
Method 1) A stream object that is received by one application router is duplicated and sent to all other application routers that participates in the application session. This may be done efficiently, for example, by associating all application routers that particpates in the application session with an IP multicast address. <br>
15   	    Method 2) Each application router receives a set of subscriptions to stream objects and stream object keys from local clients. All such subscriptions are aggregated to.a joint subscription that includes all stream objects and stream object keys that local clients subscribes to without any duplications. Stream objects but not stream object keys that are generated by local clients are removed from the aggregated<br>
20        subscription. The aggregated subscription is sent to all other application routers. A application router that receives an aggregated subscription from another application router and that finds the source to any of the stream objects and stream object keys in the aggregrated subscription is among the local clients will send that part of the subscription to the subscribing application router.<br>
25        Method 3) Each application router prepares an aggregated set of subscriptions as in Method 2. The aggregated subscription is sent to a parent application router that has been assigned by the site manager. The parent application router delivers the subset of the aggregated subscription that is available and includes the remainder in its own aggregated subscription that is sent: to the parent application router that has<br>
30        been assigned to the first parent application router. This assumes that the<br><br>
57<br>
WO 00/6886                                                                                                                                              PCT/SE00/00932<br>
management system has organised an hierarchy of application routers for the application session.<br>
Basic objects are distributed between application servers. A application server is <br>
5	always reached via one of its associated local application routers. When an application server sends a basic object to another application server, the first application server always sends the basic object with the second application server's identifier in the recipient address field of the ATP packet to one of the local application routers. This application router will send the object to a local application <br>
10    	    router of the second application server. The local application router of the second application server will send the object to the second application server.<br>
Basic objects are distributed between application servers using one of the following methods:<br>
15       Method 1) A basic object that is received by one application server is duplicated and sent to all other application servers chat participates in the application session. This may optionally be done efficiently by associating one local application router for each application server that particpates in the application session with an IP multicast address.<br>
20        Method 2) Each application server receives a set of subscriptions to basic objects from local clients. All such subscriptions are aggregated to a joint subscription that includes all basic objects that local clients subscribes to but without any subscription parameters. Basic objects that are generated by local clients are removed from the aggregated subscription. The aggregated subscription is sent to<br>
25        all other application servers. A application server that receives an aggregated<br>
subscription from another application server and that finds the source of any of the basic objects in the aggregrated subscription is among the local clients will immediatly send such objects to the subscribing application server and store the relevant part of the subscription. Any further updates of the relevant objects will<br>
30        also be sent immediatly to the subscribing application server.<br><br>
58<br>
Method 3) Each application server prepares an aggregated set of subscriptions as in Method 2. The aggregated subscription is sent to a parent application server that has been assigned by the site manager. The parent application router delivers die subset of the aggregated subscription that is available and includes the remainder in its <br>
5    	    own aggregated subscription that is sent to the parent application server that has been assigned to the first parent application server. This assumes that the management system has organised a hierarchy of application servers for the application session.<br>
10       Control data that needs to be distributed among all application access servers that participates in a session includes e.g. clients joining and leaving and creation and destruction of client groups. Such control data should be multicasted to all application routers in the session, application routers will either terminate the control message or forward it to the local application server or site manager as<br>
15        required.<br>
Some clients may be registered with an application access server as spectators. Spectators are not allowed to upload application actions but they can upload a subscription that depends on the spectator's point of view in the game.<br>
20<br>
Application access servers according to the invention may also be used in hierarchical systems. Figure 8 shows an example of such a configuration in which an higher-level application access server 201 serves other application access server units 203, 205, 207, which in turn serve application clients 209. The higher-level application<br>
25        access server 201 receives ATP packets with game data and aggregated subscriptions from downstream application access server units that are considered to be "clients". The higher-level application access server unit 201 communicates with other peer application access server units and possibly with application access server units that are on a still higher level in the hierarchy. Hierarchical application<br>
30        access server systems are used for creating a hierarchical distributed representation of the game state for an application involving a large number of clients.<br><br>
59<br>
         Remote application access server units might be organized in a multicasting tree<br>
        and in that case there will be one sorting buffer per multicasting group. A simple<br>
       distribution strategy where all information is sent to all remote application access<br>
5	server units may be used. In that case there is only one buffer.<br>
A set of application clients could have broadband connections providing low latency access so that no application access server is needed. A typical example is that all players are on the same LAN. If the game application and API still expects an <br>
10   	     application access server, it would be possible to run an application access server function in software on the client machine.<br>
A application access server unit could also be situated at any intermediate position in the network. This means that the "link" protocol between client and application<br>
15        access server could optionally be UDP/IP or TCP/IP. Alternatively, a central game server running a dial-in game service could use application access server units as components. The central site would then consist of a set of modem pools that are connected to application access server units and application lobby servers. This would be an efficient and scaleable architecture for building a central site but it<br>
20        would not have the advantage of early aggresation of game traffic.<br><br>
Claims<br><br><br><br><br>
1.	A server unit for use in a communications network, said server unit comprising receiving means for receiving information from at least a first node, each first node <br>
5  	      being represented  as a client unit, said information comprising at least part of the state information about a distributed interactive application, said server unit being characterized in that it comprises<br>
-	state information storing means for storing application state information com<br>
prised in the information received through the receiving means from said first<br>
10	node,<br>
-	first transmission means for transmitting the at least part of the information from<br>
the state information storing means to at least one second node in the network,<br>
second transmission means for transmitting at least part of the information stored<br>
in said state information storing means to said at least first node.<br>
15<br>
2. A server unit according to claim 1, further comprising a client priority list for storing priority information received from said at least one first node through the receiving means, said priority information identifying objects of the distributed interactive application about which a first client at said first node wishes receive infor-<br>
20       mation and identify the preferred order in which the first node wishes to receive the objects, the second transmission means being adapted to transmit information from said state information storing means to said at least one client unit in dependence of the priority information received from that first node.<br>
25        3. A server unit according to claim 1, further comprising a subscriptiortlist for storing subscription information received from said at least one first node through the receiving means, said subscription information identifying how often information related to a certain object is to be received in the first node.<br><br>
4.	A server unit according to claim 1 or 3. further comprising a subscription list for<br>
storing subscription information received from said at least one first node through<br>
the receiving means, said subscription information identifying the number of times<br>
information related to a certain object is to be received in the first node.<br>
5<br>
5.	A server unit according to any one of the preceding claims, wherein the receiving<br>
means is adapted to receive priority information relating to said first node from at<br>
least a third node, being represented as a client node, and forward or not forward<br>
application state information originating in said third node to at least said first<br>
10	node in dependence of said urgency information.<br>
6.	A server unit according to any one of the preceding claims, wherein the receiving means is adapted to receive priority information relating to said first node from at least a third node, and inform said first node about the priority information.<br>
7.	A server unit according to any one of the preceding claims, wherein the state information storing means is adapted to discard stored state information after a predetermined period of time.<br>
20 8. A server unit according to any one of the preceding claims, wherein the information transmitted to said at least first node is state information received from at least one other node.<br>
9.	A server unit according to any one of the preceding claims, wherein said state in-<br>
25         formation storing means is adapted to store the application state information in<br>
terms of properties of objects, said objects constituting the application state.<br>
10.	A server unit according to claim 9, wherein said state information storing means<br>
is adapted to store reference packets or datagrams describing the state of an object at<br>
30	a given time.<br><br>
WO 00/68864	62	PCT/SEOO/00932<br>
11.	A server unit according to claim 10. wherein said state information storing<br>
means is adapted to store incremental packets describing the change of the state of<br>
the object since a particular previous packet, and information identifying said previ-<br>
5        ous packet.<br>
12.	A server unit according to any one of the preceding claims, further comprising<br>
registration means for registering authorization information for said at least one first<br>
node,said authorization information indicating the application state objects that said<br>
10        first node is authorized to change.<br>
13.	A server unit according to any one of the preceding claims, comprising<br>
at least one application router comprising the first and second transmission means and the receiving means, <br>
15       an application server comprising the information storing means.<br>
14.	A server unit according to claim 13. wherein the application server and said at<br>
least one application router are implemented as separate hardware units.<br>
20        15. A server unit according to claim 13, wherein the application server and said at least one application router are implemented in software, the software relating to the application server and the at least one application router, respectively, having reserved computing resources.<br>
25 16 A server unit according to any one of the claims 13-15. wherein the application router is arranged to receive a stream object and transmit it to at least one other application access server.<br><br>
17. A server unit according to claim 14, wherein the application router is arranged to broadcast the stream object to all other application access servers involved in a communication session.<br>
5	18. A server unit according to any one of the claims 13-17, wherein the application<br>
router is arranged to receive a basic object and forward it to the at least one application server for storage in a database in the application server and to receive an addressed data packet relating to a basic object from the application server and forward it to a client and/or at least one other server unit.<br>
10<br>
19. A server unit according to any one of the claims 13-18, wherein the application router is arranged to receive control information from the application server and forward it to a client and/or at least one other server unit, and/or a site manager.<br>
15      20. A client unit for use in a terminal in a communications network, comprising application software for a distributed interactive application, said client unit being characterized in that it comprises<br>
-	at least one input means for reading an input from said terminal, said input con<br>
stituting at least application state information for the distributed interactive appli-<br>
20	cation,<br><br>
-	transmission means for transmitting application state information to an application access server in the communications network,<br>
-	receiving means for receiving at least application state information for the distributed interactive application from said application access server<br>
25	-   means for displaying said state information received by said receiving means.<br>
21. A client unit according to claim 20, further comprising priority setting means for setting priority information for specifying at least one other application state object about which available information should be received as soon as possible and<br><br>
WO 00/68864		PCT/SE00/00932	<br>
64      <br>
transmitting means for transmitting said priority information from said priority setting means to said application access server.<br>
22.	A client unit according to claim 20 or 21, further comprising priority data means<br>
5       for setting priority data for specifying at least one other node that should receive<br>
state information from the client as soon as possible.<br>
23.	A client unit according to any one of the claims 20-22, wherein said transmis<br>
sion means for transmitting application state information is adapted to arrange in-.<br>
10       formation in application object packets, each packet relating to one object constituting part of the application, before transmitting the packets to the access server, and said receiving means is adapted to extract information about application objects from packets received from the access server.<br>
15        24. A communications network characterized in that it comprises at least one server unit according to any one of the claims 1 to 19.<br>
25. A communications network according to claim 24, further comprising at least one client unit according to any one of the claims 20 to 23.<br>
20<br><br>
25<br><br><br>
26.	A communications network according to any one of claims 24-25, further comprising at least a second application access server and connection means connecting said first and second application access servers, wherein communication resources may be reserved on said connection means.<br>
27.	A communications network according to any one of claims 24-26, further comprising at least a third application access server, communicating with said first application access server but not with said second application access server, in such a way that a hierarchy of application access servers is achieved in the network.<br><br>
30<br><br>
28. A communications network according to any one of the claims 24-27, farther comprising at least one site manager arranged to control at least one application access server.<br>
5        29. A communications network according to claim 28, further comprising a lobby access server arranged to constitute an interface between at least one application lobby server and said at least one site manager.<br></object></client></client></time></client></clients></global></client></global></downstream></downstream></upstream></upstream></game></list></urgency></list.of></urgency></list></client></list></object></client></number></object></object></object></object></object></object></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWNhbmNlbGxlZCBwYWdlcygwOS0wNS0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-cancelled pages(09-05-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWNsYWltcyhncmFudGVkKS0oMDktMDUtMjAwNSkuZG9j" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-claims(granted)-(09-05-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWNsYWltcyhncmFudGVkKS0oMDktMDUtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-claims(granted)-(09-05-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWNvcnJlc3BvbmRlbmNlKGlwbyktKDEzLTA1LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-correspondence(ipo)-(13-05-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWNvcnJlc3BvbmRlbmNlMSgyMS0wMi0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-correspondence1(21-02-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWNvcnJlc3BvbmRlbmNlMigyNS0wNy0yMDA3KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-correspondence2(25-07-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWRyYXdpbmctKDA5LTA1LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-drawing-(09-05-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWZvcm0gMTMoMDUtMTItMjAwMSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-form 13(05-12-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWZvcm0gMTMoMTctMDctMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-form 13(17-07-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWZvcm0gMTkoMjctMDQtMjAwNCkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-form 19(27-04-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWZvcm0gMWEoMjEtMDItMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-form 1a(21-02-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWZvcm0gMihncmFudGVkKS0oMDktMDUtMjAwNSkuZG9j" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-form 2(granted)-(09-05-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWZvcm0gMihncmFudGVkKS0oMDktMDUtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-form 2(granted)-(09-05-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWZvcm0gMjYoMTktMDUtMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-form 26(19-05-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWZvcm0gMygwNy0xMS0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-form 3(07-11-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWZvcm0gMygyMC0wNy0yMDA0KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-form 3(20-07-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLWZvcm0gNSgwNy0xMS0yMDAwKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-form 5(07-11-2000).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLXBvd2VyIG9mIGF1dGhvcml0eSgwOS0wMS0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-power of authority(09-01-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzNzItbXVtLXBvd2VyIG9mIGF1dGhvcml0eSgyMS0wMi0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01372-mum-power of authority(21-02-2005).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="217917-a-device-for-cutting-seal-of-a-pack.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="217919-acceleration-control-apparatus-for-vehicle.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>217918</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2001/01372/MUM</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>19/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>09-May-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>31-Mar-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>07-Nov-2001</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>TELEFONAKTIEBOLAGET LM ERICSSON (PUBL)</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>SE-126 25 STOCKHOLM, SWEDEN</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>TONI BRANDT</td>
											<td>KVARNHAGSVAGEN 135, S-145 60 NORSBORG, SWEDEN</td>
										</tr>
										<tr>
											<td>2</td>
											<td>HÄGGBLAD PAR</td>
											<td>Djäkneg. 9:650 S-754 23 Uppsala (SE).</td>
										</tr>
										<tr>
											<td>3</td>
											<td>JONSSON JONAS</td>
											<td>Hjortvägen 26 S-178 32 Ekerö (SE).</td>
										</tr>
										<tr>
											<td>4</td>
											<td>JÄNDEL MAGNUS</td>
											<td>Vårvägen 10 S-194 60 Upplands Väsby (SE).</td>
										</tr>
										<tr>
											<td>5</td>
											<td>KARLSSON KRISTER</td>
											<td>Lindhagensgatan 69 S-112 43 Stockholm (SE).</td>
										</tr>
										<tr>
											<td>6</td>
											<td>KARLSSON ROLAND</td>
											<td>Drakenbergsg. 3 IV S-117 21 Stockholm (SE).</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G 06 F 19/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/SE2000/000932</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-05-10</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>9901694-1</td>
									<td>1999-05-10</td>
								    <td>Sweden</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/217918-a-server-unit-and-a-client-unit-in-a-communication-network by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:16:34 GMT -->
</html>
