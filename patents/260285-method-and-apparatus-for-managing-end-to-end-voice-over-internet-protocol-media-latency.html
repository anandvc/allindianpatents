<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/260285-method-and-apparatus-for-managing-end-to-end-voice-over-internet-protocol-media-latency by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:24:56 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 260285:METHOD AND APPARATUS FOR MANAGING END-TO-END VOICE OVER INTERNET PROTOCOL MEDIA LATENCY</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD AND APPARATUS FOR MANAGING END-TO-END VOICE OVER INTERNET PROTOCOL MEDIA LATENCY</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method and apparatus for adaptively managing communication latency, including processing one or more data frames in a communication network; sampling the one or more data frames in accordance with a first sampling time; interpolating the sampled one or more data frames; and forming a play-out waveform using the one or more data frames and having a predetermined length in time. The one or more data frames can be one or more vocoder frames and a play-out time of the one or more vocoder frames is different than the original sampling time.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>METHOD AND APPARATUS FOR MANAGING END-TO-END VOICE OVER INTERNET PROTOCOL MEDIA LATENCY<br>
FIELD<br>
[0001]      The invention generally relates to vocoders, speech processing, telephony, and data communications. More particularly, the present invention relates to a method and apparatus for reducing latency experienced by users in a group communication network and adaptively managing the end-to-end voice over Internet protocol (VoIP) media<br>
latency.<br>
DESCRIPTION OF THE RELATED ART<br>
[0002]      A VoIP phone call is a phone call that is transmitted over a data network, such as the Internet. Internet protocols allow voice call data to be placed or slotted in between other types of data on a data network. Some examples of data networks are a public Internet, a corporate Intranet, an Extranet or other such types of data networks. [0003]      There are numerous advantages (e.g cost, performance and call management) associated with making VoIP phone calls as compared to those made over a traditional telephony system. The phone calls are usually significantly cheaper than traditional circuit-switch telephony, because their cost is usually part of the overall expense (often priced as a flat rate regardless of usage) of subscribing to the data network. Additionally, many regulatory agencies presently classify VoIP calls as part of an overall information services package and not voice phone calls, thereby escaping many of the different types of taxes that are associated with traditional telephony. [0004]      There are also the benefits associated with managing what would be a separate voice network and separate data network as one, unified network. An Internet phone is basically a networked computer or computing device and therefore it can be managed like a computer, where actions such as moves, changes and upgrades are centrally managed and these actions can also be managed remotely. Finally, a VoIP system can be easily integrated with new or existing data network services. For example, VoIP can support integrated messaging, voice mail, number portability, caller ID, Web access and management and other such features.<br>
 [0005]      Traditional circuit-switch telephony is based on an implicit guarantee or at least a high, probabilistic expectation, that a circuit (whether virtual, physical, wireless or wired) will deliver voice in a predictable, manageable and reliable stream. [0006]      The same implicit guarantee and expectation referred to above also remains a valid assumption for digital circuit-switch telephony. Although the voice data is digitized and packetized into discrete chunks of information, typically referred to as vocoder frames, the circuit path that these frames take from a talker to a listener provides a continuous and reliable stream of vocoder frames representing the voice data. [0007]       A vocoder is a device used to synthesize speech and convert analog waveforms into digital signals for transmission over a communication network. Vocoders are also used to reduce the bandwidth requirements for transmitting digitized speech signals. They use various techniques to compress voiced speech by extracting and manipulating parameters that are related to models representing human speech generation.<br>
[0008]      Typically, vocoders are composed of an encoder, which analyzes the incoming speech to extract the relevant parameters, and a decoder, which resynthesizes the speech using relevant parameters which it receives over the transmission channel. Speech is divided into blocks of time or analysis frames, during which the parameters are calculated. The parameters are then updated for each new frame. [0009]      VoIP based applications used to mitigate the effects of variable, late, or lost vocoder frame delivery on voice quality have been limited by the capabilities offered by existing interfaces to the vocoder. These existing interfaces have been traditionally designed around the requirements and characteristics of circuit-based channels. Packet-data channels on which VoIP applications are based provide a fundamentally different environment for the datagrams transiting the path between talker and listener. There are algorithms to address these differences, however better strategies are made possible by the availability of new interfaces and capabilities for a vocoder. [0010]      Although a circuit path used may not be perfect or optimal, any errors that are introduced into this data stream by the circuit path affect the vocoder frames in a predictable fashion. For any given frame of data that transits across the circuit, one of the following three cases would most likely apply.<br>
1. The frame will transit unmodified after a fixed end-to-end delay; or<br>
2.	The frame will transit with one or more bit errors after a fixed end-to-end<br>
delay; or<br>
3.	The frame will be lost, leaving a gap of information (e.g. in time) before the<br>
next vocoder frame in the stream arrives. Note that case (3) above could be viewed as a<br>
special case or variation of case (2), where all the bits in the frame potentially are in error<br>
after transiting the circuit.<br>
[0011]      One fundamental characteristic of a communication circuit is that it introduces a fixed end-to-end delay to all frames transiting the circuit, whether the frames are in analog or digital form. As a result, vocoders developed for traditional voice applications are designed to cope with potential errors that may arise in the path taken from talker to listener. Depending upon the type used, some of these vocoders can either:<br>
A.	Compensate for bit-errors introduced into frames through error-correction or<br>
other coding techniques included in the vocoder frames themselves; or<br>
B.	Compensate for lost frames by allowing higher layers to signal an erasure<br>
condition to the vocoder, resulting in the vocoder interpolating across the time gap using<br>
polynomial or other prediction type algorithms specifically supported by the vocoder<br>
type that is being used.<br>
[0012]      These compensation mechanisms for coping with errors in traditional circuit paths have worked well for full-duplex (two way communication) circuit based communications. Generally, voice quality in these applications degrades gracefully as errors are introduced into the circuit.<br>
[0013]      In a VoIP or VoIP-based telecommunication system, one or more vocoder frames are packaged in IP datagrams and transmitted as discrete chunks of data over a packet network. Clients and servers that communicate via a reliable channel, such as a uniform resource locator (URL) or a socket, have a dedicated point-to-point channel between themselves, or at least the operational illusion of a dedicated channel. [0014]      In circuit switched networks, clients and servers communicate by establishing connections, transmitting the data, and then closing the connections. All data sent over the channel is received in the same order in which the data was sent. This data orientation is guaranteed by the channel. In contrast, applications that communicate via datagrams send and receive completely independent packets of information. These clients and servers do not have and do not need a dedicated point-to-point channel. The<br>
delivery of datagrams to their destinations is not guaranteed, nor is the order of the arrival of the datagrams at the recipient.<br>
[0015]      A datagram is an independent, self-contained message sent over a network whose arrival, arrival time, and content are not guaranteed. In a datagram based system, the addition of addressing information to each packet allows the packet-data network to route each datagram independently, on a node-by-node basis, as the datagram traverses the network. This is compared to circuit switch networks which carry data (e.g. the vocoder frames) along a predefined path and consequently have a fixed, predictable latency.<br>
[0016]       Generally, latency refers to the waiting time or time delay experienced in getting information or data through a network. Latency may originate in many different ways. For example, latency can arise from propagation delay. Propagation delay is the length of time that it takes information to travel a distance from information origination to information termination (e.g over a given telephone line distance). In a packet-based system, there can be transmission delay, where the latency can arise from the length of time it takes to send the packet across the given media, hi a telecommunications context, media is most often the conduit or link that carries transmissions. Some examples of transport media include coaxial cable, copper wire, radio waves, waveguide and fiber. Transmission delay is typically determined by the size of the media and the size of the data packet. Another source of latency is processing delay, which is the time required by a network device for performing various tasks, such as route lookup, changing and managing headers, changing the encapsulation of data and other switching tasks<br>
[0017]      In this context, one fundamental difference between a circuit-switch telephony system and a datagram based system is not only that the voice frames of the datagram based system are encapsulated with Internet Protocol (IP) headers, but that they are subject to and exhibit variable link characteristics (e.g. probability of error, congestion) as they traverse a packet-data network.<br>
[0018]      As a result of these characteristics, vocoder packets in a VoIP application can arrive at the listener with varying end-to-end latencies when compared to other frames, either earlier or later in a sequence of VoIP datagram transmissions. Typical packet networks discard corrupted datagrams, but otherwise they transmit on a best-effort<br>
basis. For example, some packets can be lost and never arrive at their ultimate destination. Other packets may arrive too late and not be useful. [0019]      One challenge facing VoIP applications and other IP-based media streaming applications as well, such as video telephony applications, is that voice play-out cannot begin until the first media datagram is received by the listener. If this datagram is uncharacteristically delayed (or if the first media datagram transmitted is lost and hence the receiver must wait for subsequent datagrams to successfully transit), a large initial end-to-end latency is initially introduced into the media stream. [0020]      Consequently, in many scenarios, VoIP applications need to address the following two issues. They need to contend with packets arriving with variable latencies and with varying inter-arrival times or jitter, including packets that arrive out of sequence. They also need to contend with packets that are lost, or arrive too late to be interesting or useful at the application layer.<br>
[0021]      One way of dealing with variability in inter-arrival times is to smooth out the received jitter at the receiver by buffering received vocoder frames for a fixed period of time. This buffering approach effectively simulates the fixed end-to-end latency of a circuit path at the expense of delaying play-out for some or all vocoder frames. Various algorithms exist for determining the introduced delay, commonly known as playout threshold or watermark.<br>
[0022]      However, if a fixed delay is used, the delay is typically proportional to the maximum expected end-to-end latency for the packet network between the talker and the listener. As a result, this approach tends to significantly increase VoIP end-to-end media latency compared to a circuit path between the same talker and listener. [0023]      A fixed delay is often introduced to media play-out to allow vocoder frames delayed by a packet-data network to arrive before their play-out time arrives. The longer the introduced delay, the more likely a given vocoder frame will arrive before its play-out time arrives. However, the longer delays contribute to longer end-to-end media latencies, which in turn detract from the perceived voice quality and the general usability of the application.<br>
[0024]      There are approaches to compensate for late or lost packets carrying vocoder frames. One approach is to signal an erasure event to the vocoder when the time arrives to play a vocoder frame which has been lost or will arrive late. Another approach is to simply ignore the lost packets and play the next available vocoder frame in place of the<br>
lost frame. The latter approach is used when knowledge of lost frame events is not available or known at the layer submitting frames to the vocoder for play-out. This strategy is also used for compressing time or shedding end-to-end media latency that may build up over time in a VoIP stream by using the lost data as an opportunity to catch up with the data trasmission. Relying on the packet-data network to determine which vocoder frames are best to discard may result in significant detrimental impacts to voice quality.<br>
[0025]      Consequently, choosing a threshold based on long-term performance statistics of a given packet data network tends to delay voice play-out unnecessarily when a specific network or network path is performing better than average or better than the previously obtained statistics. An alternative is to choose a threshold based on the actual or predicted link performance at that particular point in time. For example, a running average of the empirical end-to-end delay can be tabulated and maintained by the receiver, and is some circumstances, used as a threshold to start media play-out. [0026]      However, since the quality of the running average is proportional to the number of samples used to determine it, in practice, this average delay can only be used for subsequent talk-spurts (half-duplex) or talk-streams (full-duplex). An approximate estimate can be inferred by limiting the number of frames used to compile the running average. As an extreme, the delay can be inferred by examining the first received packet, although in practice, there are limitations associated with this approach. [0027]      If the talker and the listener have coordinated time sources (e.g. communications in a Code Division Multiple Access (CDMA) system), an accurate and precise determination of the end-to-end network latencies between the talker and listener can be determined. If averaged over a large enough sample size, this delay represents the fixed component of the end-to-end network latency and can be subtracted from the watermark used to initiate media play-out. The result is a threshold that only represents the delay required to smooth out the expected jitter.<br>
[0028]      Therefore, it is desirable to provide a mechanism for adaptively managing end-to-end VoIP media latency and to mitigate the effects of variable, late, or lost vocoder frames delivery on voice quality.<br>
SUMMARY OF THE INVENTION<br>
[0029]      It should be emphasized that the terms "comprises" and "comprising", when used in this specification, are taken to specify the presence of stated features, integers, steps or components; but the use of these terms does not preclude the presence or addition of one or more other features, integers, steps, components or groups thereof. [0030]      One embodiment is a method for adaptively managing communication latency. This includes monitoring end-to-end media latency in a communication network; measuring a current value of end-to-end media latency; comparing the measured current value of end-to-end latency against a predetermined media latency value; and discarding data if the measured current value of end-to-end latency is greater than the predetermined media latency value. In one aspect, the discarding further includes determining a current depth in frames of a media play-out buffer. In another aspect, the media play-out buffer is located at a receiver location within the communication network. In another aspect, the discarding further comprises evaluating a proportion of targeted frames in a media stream relative to a total number of frames in the media stream.<br>
[0031]      Another embodiment is a method for adaptively managing communication latency including processing one or more data frames in a communication network; sampling the one or more data frames in accordance with a first sampling time; interpolating the sampled one or more data frames; and forming a play-out waveform using the one or more data frames and wherein the play-out waveform has a predetermined length in time. In one aspect the one or more data frames include one or more vocoder frames and a play-out time of the one or more vocoder frames is different than the first sampling time. In another aspect, the play-out time of the one or more vocoder frames is of a shorter time duration than the first sampling time. In another aspect a pitch-preserving transform is applied to the one or more vocoder frames, hi another aspect a frequency-to-time domain transform is applied to the one or more vocoder frames. In another aspect, the pitch-preserving transform compresses the play-out time of the one or more vocoder frames, In another aspect, the pitch-preserving transform expands the play-out time of the one or more vocoder frames, in another aspect, the one or more vocoder frames stored in a queue are stored and monitored. In another aspect, the queue storing the one or more vocoder frames is a play-out queue buffer. Another aspect includes monitoring a plurality of vocoder frames stored in the<br>
play-out queue buffer; ascertaining a storage capacity depth of the play-out queue buffer; and determining if the depth of the play-out queue buffer is sufficient to mask an expected jitter in a media stream, in another aspect, if the depth of the play-out queue buffer is determined to be too low to mask the expected jitter in the media stream, a latency is induced into the play-out waveform. In another aspect, the latency is modified by expanding a length of the play-out waveform. In another aspect, the latency is modified by compressing a length of the play-out waveform. Another aspect applies a pitch-preserving transform to the one or more vocoder frames. Another aspect applies a frequency-to-time domain transform to the one or more vocoder frames. Another aspect uses a time-compression algorithm to reduce the latency, if the latency exceeds a predetermined value.<br>
[0032]      Another embodiment is an apparatus for adaptively managing communication latency including means for monitoring end-to-end media latency in a communication network; means for measuring a current value of end-to-end media latency; means for comparing the measured current value of end-to-end latency against a predetermined media latency value; and means for discarding data if the measured current value of end-to-end latency is greater than the predetermined media latency value. In one aspect, the means for discarding further includes determining a current depth in frames of a media play-out buffer, in another aspect, the media play-out buffer is located at a receiver location within the communication network. In another aspect, the means for discarding further comprises evaluating a proportion of targeted frames in a media stream relative to a total number of frames in the media stream. [0033]   Another embodiment is an apparatus for adaptively managing communication latency including means for processing one or more data frames in a communication network; means for sampling the one or more data frames in accordance with a first sampling time; means for interpolating the sampled one or more data frames; and means for forming a play-out waveform using the one or more data frames and wherein the play-out waveform has a predetermined length in tune, in one aspect, the one or more data frames include one or more vocoder frames and a play-out time of the one or more vocoder frames is different than the first sampling time, in another aspect, the play-out time of the one or more vocoder frames is of a shorter time duration than the first sampling time. Another aspect includes applying a pitch-preserving transform to the one or more vocoder frames. Another aspect includes applying a frequency-to-time<br>
domain transform to the one or more vocoder frames. In another aspect, the pitch-preserving transform compresses the play-out time of the one or more vocoder frames. In another aspect, the pitch-preserving transform expands the play-out time of the one or more vocoder frames. Another aspect stores and monitors the one or more vocoder frames stored in a queue. In another aspect, the queue stores the one or more vocoder frames is a play-out queue buffer. In another aspect there are means for monitoring a plurality of vocoder frames stored in the play-out queue buffer; means for ascertaining a storage capacity depth of the play-out queue buffer; and means for determining if the depth of the play-out queue buffer is sufficient to mask an expected jitter in a media stream. In another aspect, if the depth of the play-out queue buffer is determined to be too low to mask the expected jitter in the media stream, a latency is induced into the play-out waveform. In another aspect, the latency is modified by expanding a length of the play-out waveform. In another aspect, the latency is modified by compressing a length of the play-out waveform. Another aspect applies a pitch-preserving transform to the one or more vocoder frames. Another aspect applies a frequency-to-time domain transform to the one or more vocoder frames. Another aspect uses a time-compression algorithm to reduce the latency, if the latency exceeds a predetermined value. [0034]   In another embodiment, a communication device includes a computer-readable medium embodying a method for adaptively managing communication latency including: processing one or more data frames in a communication network; sampling the one or more data frames in accordance with a first sampling time; interpolating the sampled one or more data frames; and forming a play-out waveform using the one or more data frames and wherein the play-out waveform has a predetermined length in time. In one aspect, the one or more data frames include one or more vocoder frames and a play-out time of the one or more vocoder frames is different than the first sampling time. In another aspect, the play-out time of the one or more vocoder frames is of a shorter time duration than the first sampling time. In another aspect, a pitch-preserving transform is applied to the one or more vocoder frames. In another aspect, a frequency-to-time domain transform is applied to the one or more vocoder frames. In another aspect, the pitch-preserving transform compresses the play-out time of the one or more vocoder frames. In another aspect, the pitch-preserving transform expands the play-out time of the one or more vocoder frames. In another aspect, the one or more vocoder frames stored in a queue are stored and monitored. In another aspect, the queue storing the one or more vocoder frames is a play-out queue buffer. Another aspect includes monitoring a plurality of vocoder frames stored in the play-out queue buffer; ascertaining a storage capacity depth of the play-out queue buffer; and determining if the depth of the play-out queue buffer is sufficient to mask an expected jitter in a media stream. In another aspect, if the depth of the play-out queue buffer is determined to be too low to mask the expected jitter in the media stream, a latency is induced into the play-out waveform. In another aspect, the latency is modified by expanding a length of the play-out waveform. In another aspect, the latency is modified by compressing a length of the play-out waveform. In another aspect, a pitch-preserving transform is applied to the one or more vocoder frames, in another aspect, a frequency-to-time domain transform is applied to the one or more vocoder frames. In another aspect, a time-compression algorithm is used to reduce the latency, if the latency exceeds a predetermined value.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0035]      The features and advantages of the present invention will be better understood<br>
by reading the following detailed description in conjunction with the drawings in which:<br>
[0036]      FIG. 1 illustrates an exemplary communication network;<br>
[0037]      FIG. 2 is a flow chart illustrating operation of adaptively managing<br>
communication latency according to one exemplary embodiment; [0038]      FIG. 3 is a flow chart illustrating operation of data frame interpolation<br>
according to one exemplary embodiment; and [0039]      FIG. 4 is a flow chart illustrating the determination of buffer depth that is<br>
sufficient to mask expected jitter according to one exemplary embodiment.<br>
DETAILED DESCRIPTION OF THE INVENTION<br>
[0040]      The word "exemplary" is used to mean "serving as an example, instance, or illustration."  Any embodiment described as "exemplary" is not necessarily to be construed as preferred or advantageous over other embodiments. [0041]      Before one embodiment of the invention is explained in detail, it is to be understood that the invention is not limited in its application to the details of the construction and the arrangement of the components set forth in the following description or illustrated in the drawings. The invention is capable of being implemented in other embodiments and carried out in various ways. Also, it is understood that the phraseology and terminology used herein is for purposes of description and understanding and should not be regarded as limiting. [0042]      FIG. 1 illustrates an exemplary communication network 100. The communication network 100 includes one or more communication towers 106, each connected to a base station (BS) 110 and serving users with communication devices 102. The communication devices 102 can be cellular telephones, pagers, personal digital assistants (PDAs), laptop computers, or other hand-held, stationary, or portable communication devices that support data communications.<br>
[0043]      The commands and data input by each user are transmitted as digital data to a communications tower 106. The communication between a user using a communication device 102 and the communication tower 106 can be based on different technologies and protocols. For example, code division multiple access (CDMA), time division multiple access (TDMA), frequency division multiple access (FDMA), the global system for mobile communications (GSM), or other types of communication protocols may be used in a wireless communications network or a data communications network. The data from each user is sent from the communication tower 106 to a base station (BS) 1.10, and forwarded to a mobile switching center (MSC) 114, which may be connected to a public switched telephone network (PSTN) 118 and the Internet 120. The MSC 114 may be connected to a server 116 that supports the PTT feature in the communications network 100. The server includes an application that supports the PTT feature besides storing a table that lists members of each communication group. Optionally, the server 116 may be part of the MSC 114.<br>
[0044]      In the embodiment illustrated in FIG. 2, the latency present in data transmitted through a communication network (such as the exemplary one illustrated in FIG. 1) is observed and monitored 200. With respect to a given piece of data (e.g packets, data frames, datagrams, vocoder frames or the like), a current value of the latency associated with a specific piece(s) of information is determined 202. The latency can be measured in any incremental or temporal duration that a particular implementation suggests is useful or desired for the given application. After the measured latency value has been determined, the measured latency value is compared against a predetermined latency value 204. In one embodiment, the predetermined latency value represents an acceptable, threshold level of latency that is compared with the measured latency.<br>
 [0045]      If the measured current value of latency 204 is greater than the predetermined latency value, data is discarded 206. The discarding of the data improves the latency of the communication network. Determining the amount of media to be discarded depends upon several factors, such as the communication network involved, the types of media transiting the network and its size, quality level desired (e.g. voice quality) and other such variables and system parameters. The amount of media to be discarded can be based upon the factors discussed above, or the media discarded can also be performed on an iterative basis while searching for an acceptable outcome to an end user. This contributes to the ability of the method to adaptively manage the process, based upon changing communication conditions and operational parameters. Then, upon discarding the media in 206, the method returns to monitoring the latency in 200 and continues in an iterative manner.<br>
[0046]      One exemplary way for recovering from an initial delay is to discard vocoder frames at the receiver, with each frame typically representing 20 ms of voice. This process of reducing end-to-end media latency by throwing away information is a form of latency shedding. The idea is to throw away information to support acceptable levels of latency, while still retaining enough information to discern the intended communication content. Vocoders that are designed around the 8 kHz sampling assumptions are generally designed to represent 20 ms of speech per frame. This particular value is also standardized by the ffiTF's Real Time Protocol (RFC 1889). Those skilled in the art will appreciate that different sampling schemes, size of data frames, assumptions and the like may be used, without departing from the spirit and scope of the present invention.<br>
[0047]      Another approach of managing latency is to discard vocoder frames at the talker (e.g. before transmission). This approach has the added advantage of saving bandwidth, since less data is input for transmission across the communication network. However, this approach is considered impractical for half-duplex VoIP applications which do not utilize a media quality back-channel (i.e. which does not use real time conferencing protocol (RTCP) or a similar protocol to provide feedback regarding media receipt statistics). Those skilled in the art will realize that other data applications, in addition to VoIP applications, can be used without departing from the spirit and scope of the claimed invention.<br>
[0048]      Choosing which frames to play-out and which frames to discard is one factor to consider, because discarding any information from a highly compressed vocoder stream will result in reduced or impacted voice quality. For some variable rate vocoders employed by CDMA handsets [e.g. Qualcomm Code Excited Linear Prediction (QCELP), Enhanced Variable Rate Coding (EVRC), Selectable Mode Vocoders (SMV) and the like], some vocoder frames contain more critical information than others. For example, it is generally true that the effect on perceived voice quality due to the loss of an eighth-rate (also referred to as rate 1/8) vocoder frame is less than the effect due to the loss of a full-rate (also referred to as rate 1) or half-rate (also referred to as rate '/z) vocoder frame. Consequently, the nature and impact of the information discarded and the vocoder used is a consideration in determining what and how much to discard.<br>
[0049]      Another exemplary form of latency shedding is to periodically discard eighth-rate frames as they are prepared for play-out at the listener. The rate at which frames are identified for discard depend on several factors, including (a) the current end-to-end media latency, (b) the current depth (in frames) of the media play-out buffer at the listener, and (c) the proportion of frames which could be targeted relative to the total number of frames in the media stream.<br>
[0050]      However, not all eighth-rate frames are equal, and although eighth-rate frames generally code less critical segments of the voice stream in time, simply discarding 20 ms segments can introduce noticeable artifacts in the decoded speech.<br>
[0051]      An example of this approach is outlined below in pseudo-code form:<br>
while     (listening_to_media   (   )   )     { frame  = get_next_frame   (   )   ; /*     is current media latency too high?     */ if     (current_media_latency   (   )   &gt; MAX_MEDIA_LATENCY){<br>
^/*ignore frame  */     ;        . else<br>
vocoder_play_frame   (frame)   ;}<br>
[0052]      Please note that the pseudo-code shown immediately above and any other pseudo-code presented in the specification is provided for purposes of providing a clearer understanding and explanation and are not intended to limit the scope of the invention in any way. Furthermore, note that the exemplary scenario discussed above used an eighth-rate vocoder frame, although an Nth-rate frame can also be used without departing from the scope and spirit of the invention.<br>
[0053]      One assumption in the pseudo-code discussed above is that this approach assumes only an interface to send single vocoder frames sequentially to the vocoder for play-out: vocoder_piay_frame  ( )   - the minimal interface that a vocoder designed purely for traditional circuit-switch applications would be required to provide. [0054]      Another approach to recovering from initial media latency delays in real-time that is less likely to introduce perceptible media artifacts in the output waveform is to use one or more sequential vocoder frames to generate a shorter wave-form than the waveform that was originally used to produce the vocoder frames, using a transform algorithm. Some examples of transform algorithms that may be used to generate a shorter wave-form are pitch-preserving or equivalent  frequency-to-time domain transforms and the like.<br>
[0055]      hi the embodiment illustrated in FIG. 3, dataframes are processed 300, such as those dataframes representing one or more sequential vocoder frames. The processing includes determining the data content and type of data contained within a particular dataframe. The dataframes are then sampled 302 and interpolated 304. This allows the dataframes to be examined in accordance with a specific sampling scheme so that desired dataframes are looked at in accordance with predetermined sampling criteria and then interpolated in accordance with predetermined interpolation criteria. Interpolation is a way of estimating values based upon other values. For example, a current dataframe is compared between past dataframes and future dataframes to arrive at reconstructed current dataframe. Different sampling and interpolating techniques well known to those skilled in the art may be used without departing from the spirit and scope of the present invention.<br>
[0056]      In FIG. 3, a waveform is formed having a predetermined length 306 after the sampling 302 and interpolation 306. For example, in order to reduce latency, the resulting waveform generated from the vocoder frames is one that has a shorter waveform than the wave-form that was originally used to produce the vocoder frames. As mentioned earlier, pitch-preserving or equivalent frequency-to-time domain transforms are two types of transforms that may be used to produce the shorter wave-form. Then, upon forming a waveform having a predetermined length in 306, the method returns to monitoring the latency in 300 and continues in an iterative manner.  [0057]      Consider another exemplary scenario where initial media play-out of a VoIP stream has been delayed to the point of introducing an artificial 1000 ms delay into the voice-stream. Also, assume that in this particular VoIP application, media is being bundled as five vocoder frames per datagram. Those skilled in the art will appreciate that other values representing the amount of artificial delay introduced into the voice-stream, as well as different amounts of vocoder frames bundled per datagram may be used without departing from the spirit and scope of the present invention. Rather than submitting each vocoder frame independently to the vocoder, and possibly discarding any eighth-rate frames in the stream to shed latency as described above, all five vocoder frames could be submitted as a group to the vocoder with instructions to produce a waveform that is shorter than the corresponding 100 ms input.<br>
[0058]      Pitch-preserving transforms exist that allow an arbitrary almost arbitrary time waveform to be generated from the frequency domain information provided by the vocoder frame data itself. Various application layer interfaces may be defined and implemented for vocoders for the purpose of compressing or shedding latency in a realtime VoIP stream.<br>
[0059]      In one exemplary scenario, pseudo-code for receiving bundled media and submitting each frame individually without any latency shedding for five frames of data<br>
is given below:<br>
While   (listening_to_media)      {<br>
nframes = get_next_bundle   (frames,   FIVE_FRAMES)   ;<br>
vocoder_play_frame	(frames	[0]);<br>
vocoder_play_frame	(frames	[1]);<br>
vocoder_play_frame	(frames	[2]);<br>
vocoder__play_frame	(frames	[3]);<br>
vocoder__play_frame	(frames	[4]);<br>
[0060]      However, if the ability to submit one or more frames to the vocoder with instructions to interpolate a waveform shorter than that corresponding to one produced by a sampling rate of 20 ms per frame is available, an exemplary algorithm similar to the following could be realized:<br>
while   (listening_to_media)   {<br>
nframes  = get_next_bundle   (frames,   FIVE_FRAMES)   ;length = nframes  * TWENTY_MS_PER_FRAME  ; /*  shed latency by playing  fast:   */ latency = current_media_latency   (   } ,-<br>
if   (latency &gt; MAX_MEDIA_LATENCY)      { if     (latency &gt; TEN_MS)<br>
length =  length - TEN_MS else<br>
length =  length -  latency; }<br>
vocoder_play_variable   (frame,   nframes,   length)   ;}<br>
[0061]      In this case, a new vocoder interface, vocoder_play_variable (  ), is required. This interface takes one or more vocoder frames and interpolates them into a play-out wave-form having a prescribed length in time. Because the play-out time of these vocoder frames can be shorter than the original sampling time (e.g through the use of a pitch-preserving transform), latency can be shed more gracefully than simply dropping eighth-rate frames. In the exemplary pseudo-code shown above, whenever the real-time experienced media-latency exceeds a prescribed limit, bundles of five vocoder frames are shortened from their original 100 ms sampling period (but to no less than 90 ms) to control media latency.<br>
[0062]      Other algorithms may utilize other information such as the packet-error rate, received frame statistics, and current media buffer depth. This information can be used singly or in combination. The ability to shed media latency gracefully enhances the operational performance of VoIP applications. As described above, the interfaces and design characteristics provided by the underlying vocoder determine just how graceful latency can be shed. Adding an interface to support variable interpolation of one or more vocoder frames can be used to implement more graceful latency shedding algorithms at the application layer.<br>
[0063]      In addition to supporting latency shedding, the new interface vocoder_play__variable  (  ) can be used to mitigate the occurrence of media under-run events in a VoIP based application. A media under-run event occurs when, as a result of packet-loss, network congestion, or other factors, a vocoder frame is not available at the listener when it is time to play the next vocoder frame. Another way of saying this is that the listener prematurely runs out of vocoder frames to listen to.<br>
Under-run events can occur when media latency is high or low; the problems are normally independent of each other.<br>
[0064]      Generally, VoIP applications artificially introduce a small amount of end-to-end media latency into the playout stream at the listener in order to smooth out jitter in the inter-arrival delays of the received vocoder frames. This small delay is generally desirable, because it can be used to mask the fact that some vocoder frames arrive later than expected.<br>
[0065]      In practice, it is not desirable to introduce a delay that will hide all variability in the arrival rate of received vocoder frames. In effect, this approach sizes the system for worst case operation. This would introduce unreasonably large initial end-to-end media latencies. Some late arrival events must be tolerated (and the late arriving frames ignored), in the extreme case, the listener's play-out buffer is drained while waiting for new frames to arrive, producing an under-run condition.<br>
[0066]      These under-runs degrade media quality for at least two basic reasons. First, they introduce an artificial gap in the media play-out waveform. With traditional vocoder interfaces, the vocoder has no choice but to tolerate the under-run and play an erasure frame (or equivalent), while waiting for new media to arrive. Second, if late media does arrive after an under-run, it either must be dropped which further degrades the play-out waveform, or if it is played, an increase in the end-to-end latency must be tolerated. And if the late media never arrives at the listener, but rather the late packets are lost in the network (but later media arrives on schedule), media quality is impacted as a result of frames being lost from the playout stream.<br>
[0067]      However, the ability to control the length in time of the wave-form produced by one or more vocoder frames on play-out can be used to control the impacts of under-run events on media quality.<br>
[0068]      FIG. 4 illustrates a flowchart showing an exemplary embodiment of how a buffer depth is determined that is sufficient to mask expected jitter. By monitoring the number of vocoder frames stored in the listener's play-out queue (400 of FIG. 4), the application can determine when the depth of this play-out buffer is too low to mask the expected jitter in the media stream (402 of FIG. 4).<br>
[0069]     Then, based upon the number of vocoder frames monitored 400 and determining if the buffer depth is sufficient to mask the expected jitter 402, the latency can be adjusted (404 of FIG. 4). This adjustment is performed in accordance with a desired criteria. For example, in one embodiment, the adjustment can be based upon a desired outcome or level of quality. At this point, the application can choose to artificially introduce latency into the play-out wave-form using the available vocoder frames by expanding the length of the wave-form produced. It should be apparent that expanding the length of the waveform will introduce latency into the process. Again, the application of a pitch-preserving transformation is useful in this context. If media latency grows too large, it can be reduced by different methods, such as time-compression. Further, in this case, if delayed media arrives late, rather than being forced to discard it, the information in these vocoder frames can be used to produce a better quality, although shortened wave-form.<br>
[0070]      The pseudo-code below outlines another exemplary play-out strategy that employs both time-compression and time-expansion to control media latency from growing unreasonably large, while mitigating the effects of lost or delayed frames from the media stream.<br>
while   (listening _to_media)      {<br>
nframes  = get_next_bundle   (frames,   FIVE_FRAMES)   ;<br>
length = nframes  * TWENTY_MS_PER_FRAME;<br>
/*  is playout buffer getting low?  */ depth = current_playout_depth   (   )   ; if      (depth 
length =  length + TEN_MS; else     {<br>
/*  shed latency by playing fast?  */ latency = current_media_latency   (   )   ; if   (latency &gt; MAX_MEDIA_LATENCY)      { if   (latency &gt; TEN_MS)<br>
length = length - TEN_MS; else<br>
length = length -  latency; }<br>
vocoder_play_variable   (frame,  nframes,   length)   ; } [0071]      In view of the method being executable on a wireless service provider's<br>
computer device or a wireless communications device, the method can be performed by a program resident in a computer readable medium, where the program directs a server or other computer device having a computer to execute the method. The computer readable medium can be the memory of the server, or can be in a connected database. Furthermore, the computer readable medium can be in a secondary storage media that is loadable onto a wireless communications device computer platform, such as a magnetic disk or tape, optical disk, hard disk, flash memory, or other storage media as is known in the art.<br>
[0072]      Those skilled in the art will appreciate that the method described in this specification and any associated algorithms can be implemented in any form, ranging from code running on a general purpose computer to dedicated circuitry, and any combination in between, hi the context of Figures 2-4 described in the specification, the method may be implemented, for example, by operating portion(s) of the wireless network (such as the one shown in FIG. 1), such as a wireless communications device or the server (or any other device and combination of devices), to execute a sequence of machine-readable instructions. The instructions can reside in various types of signal-bearing or data storage primary, secondary, tertiary or other levels of storage media. For example, the media may comprise RAM (not shown) accessible by, or residing within, the components of the wireless network. Whether contained in RAM, a diskette, or other secondary storage media, the instructions may be stored on a variety of machine-readable data storage media, such as a direct access storage device (DASD) [e.g. a conventional hard drive or a redundant array of inexpensive disks (RAID) array], magnetic tape, electronic read-only memory (e.g., ROM, EPROM, or EEPROM), flash memory cards, an optical storage device (e.g. CD-ROM, WORM, DVD, digital optical tape), paper "punch" cards, or other suitable data storage media including digital and analog transmission data.<br>
[0073]      Furthermore, it should be appreciated that any illustrated circuits, logical block diagrams, modules and algorithm steps described in connection with the various disclosed embodiments may be implemented as hardware, software, firmware, or any combinations thereof. To clearly illustrate the interchangeability of hardware, software and firmware, the various circuits, logical block diagrams, modules and algorithm steps are described generally in terms of their functionality. The decision on how the functionality is implemented in hardware, software and firmware depends upon the particular application and the design constraints of the overall system. The described functionality and operation may be implemented in varying ways for each particular application, but such implementation decisions should not be interpreted as departing from the spirit and scope of the present invention.<br>
[0074]      Those skilled in the art will appreciate that, although illustrative embodiments of the invention have been shown and described, other variations, implementations, and associated algorithms are possible, without departing from the spirit and scope of the invention. The scope of the invention is given by the appended claims, rather than the preceding description. All variations and equivalents which fall within the range of the claims are intended to be embraced therein.<br><br><br><br><br><br>
CLAIMS<br>
1.	A method for adaptively managing communication latency comprising:<br>
monitoring end-to-end media latency in a communication network;<br>
measuring a current value of end-to-end media latency;<br>
comparing the measured current value of end-to-end latency against a predetermined media latency value; and<br>
discarding data if the measured current value of end-to-end latency is greater than the predetermined media latency value.<br>
2.	The method of claim 1, wherein the discarding further comprises<br>
determining a current depth in frames of a media play-out buffer.<br>
3.	The method of claim 2, wherein the data play-out buffer is located at a<br>
receiver location within the communication network.<br>
4.	The method of claim 2, wherein the discarding further comprises<br>
evaluating a proportion of targeted frames in a media stream relative to a total<br>
number of frames in the media stream.<br>
5.	A method for adaptively managing communication latency comprising:<br>
processing one or more data frames in a communication network;<br>
sampling the one or more data frames in accordance with a first sampling time;<br>
interpolating the sampled one or more data frames; and<br>
forming a play-out waveform using the one or more data frames and<br>
wherein the play-out waveform has a predetermined length in time.<br>
6.	The method of claim 5, wherein the one or more data frames include one<br>
or more vocoder frames and a play-out time of the one or more vocoder frames<br>
is different than the first sampling time.<br>
7.	The method of claim 5, wherein the play-out time of the one or more<br>
vocoder frames is of a shorter time duration than the first sampling time.<br>
8.	The method of claim 6, further comprising applying a pitch-preserving<br>
transform to the one or more vocoder frames.<br>
9.	The method of claim 6, further comprising applying a frequency-to-time<br>
domain transform to the one or more vocoder frames.<br>
10.	The method of claim 6, wherein the pitch-preserving transform<br>
compresses the play-out time of the one or more vocoder frames.<br>
V<br>
11.	The method of claim 6, wherein the pitch-preserving transform expands<br>
the play-out time of the one or more vocoder frames.<br>
12.	The method of claim 6, further comprising storing and monitoring the<br>
one or more vocoder frames stored in a queue.<br>
13.	The method of claim 12, wherein the queue storing the one or more<br>
vocoder frames is a play-out queue buffer.<br>
14.	The method of claim 13, further comprising:<br>
monitoring a plurality of vocoder frames stored in the play-out queue<br>
buffer;<br>
ascertaining a storage capacity depth of the play-out queue buffer; and determining if the depth of the play-out queue buffer is sufficient to mas<br>
an expected jitter in a media stream.<br>
15.	The method of claim 14, wherein if the depth of the play-out queue<br>
buffer is determined to be too low to mask the expected jitter in the media<br>
stream, a latency is induced into the play-out waveform.<br>
16.	The method of claim 15, wherein the latency is modified by expanding a<br>
length of the play-out waveform.<br>
17.	The method of claim 15, wherein the latency is modified by compressing<br>
a length of the play-out waveform.<br>
18.	The method of claim 14, further comprising applying a pitch-preserving<br>
transform to the one or more vocoder frames.<br>
19.	The method of claim 14, further comprising applying a frequency-to-<br>
time domain transform to the one or more vocoder frames.<br>
20.	The method of claim 15, further comprising using a time-compression<br>
algorithm to reduce the latency, if the latency exceeds a predetermined value.<br>
21.	An apparatus for adaptively managing communication latency<br>
comprising:<br>
means for monitoring end-to-end media latency in a communication network;<br>
means for measuring a current value of end-to-end media latency;<br>
means for comparing the measured current value of end-to-end latency against a predetermined media latency value; and<br>
means for discarding data if the measured current value of end-to-end latency is greater than the predetermined media latency value.<br>
22.	The apparatus of claim 21, wherein the means for discarding further<br>
comprises determining a current depth in frames of a media play-out buffer.<br>
23.	The apparatus of claim 22, wherein the data play-out buffer is located at<br>
a listener location within the communication network.<br>
24.	The apparatus of claim 21, wherein the means for discarding further<br>
comprises evaluating a proportion of targeted frames in a media stream relative<br>
to a total number of frames in the media stream.<br>
25.	An apparatus for adaptively managing communication latency<br>
comprising:<br>
means for processing one or more data frames in a communication network;<br>
means for sampling the one or more data frames in accordance with a first sampling time;<br>
means for interpolating the sampled one or more data frames; and<br>
means for forming a play-out waveform using the one or more data frames and wherein the play-out waveform has a predetermined length in time.<br>
26.	The apparatus of claim 25, wherein the one or more data frames include<br>
one or more vocoder frames and a play-out time of the one or more vocoder<br>
frames is different than the first sampling time.<br>
27.	The apparatus of claim 25, wherein the play-out time of the one or more<br>
vocoder frames is of a shorter time duration than the first sampling time.<br>
28.	The apparatus of claim 26, further comprising applying a pitch-<br>
preserving transform to the one or more vocoder frames.<br>
29.	The apparatus of claim 26, further comprising applying a frequency-to-<br>
time domain transform to the one or more vocoder frames.<br>
30.	The apparatus of claim 26, wherein the pitch-preserving transform<br>
compresses the play-out time of the one or more vocoder frames.<br>
31.	The apparatus of claim 26, wherein the pitch-preserving transform<br>
expands the play-out time of the one or more vocoder frames.<br>
32.	The apparatus of claim 26, further comprising storing and monitoring the<br>
one or more vocoder frames stored in a queue.<br>
33.	The apparatus of claim 32, wherein the queue storing the one or more<br>
vocoder frames is a play-out queue buffer.<br>
34.	The apparatus of claim 33, further comprising:<br>
means for monitoring a plurality of vocoder frames stored in the play-out<br>
queue buffer;<br>
means for ascertaining a storage capacity depth of the play-out queue buffer; and<br>
means for determining if the depth of the play-out queue buffer is sufficient to mask an expected jitter in a media stream.<br>
35.	The apparatus of claim 34, wherein if the depth of the play-out queue<br>
buffer is determined to be too low to mask the expected jitter in the media<br>
stream, a latency is induced into the play-out waveform.<br>
36.	The apparatus of claim 35, wherein the latency is modified by expanding<br>
a length of the play-out waveform.<br>
37.	The apparatus of claim 35, wherein the latency is modified by<br>
compressing a length of the play-out waveform.<br>
38.	The apparatus of claim 34, further comprising applying a pitch-<br>
preserving transform to the one or more vocoder frames.<br>
39.	The apparatus of claim 34, further comprising applying a frequency-to-<br>
time domain transform to the one or more vocoder frames.<br>
40.	The apparatus of claim 35, further comprising using a time-compression<br>
algorithm to reduce the latency, if the latency exceeds a predetermined value.<br>
41.	A computer-readable medium on which is stored a computer program for<br>
embodying a method for adaptively managing communication latency, where<br>
the computer program comprises instructions which, when executed by a<br>
computer device, comprises:<br>
processing one or more data frames in a communication network;<br>
sampling the one or more data frames in accordance with a first sampling<br>
time;<br>
interpolating the sampled one or more data frames; and<br>
forming a play-out waveform using the one or more data frames and<br>
wherein the play-out waveform has a predetermined length in time,<br>
42.	The computer-readable medium of claim 41, wherein the one or more<br>
data frames include one or more vocoder frames and a play-out time of the one<br>
or more vocoder frames is different than the first sampling time.<br>
43.	The computer-readable medium of claim 41, wherein the play-out time<br>
of the one or more vocoder frames is of a shorter time duration than the first<br>
sampling time.<br>
44.	The computer-readable medium of claim 42, further comprising applying<br>
a pitch-preserving transform to the one or more vocoder frames.<br>
45.	The computer-readable medium of claim 42, further comprising applying<br>
a frequency-to-time domain transform to the one or more vocoder frames.<br>
46.	The computer-readable medium of claim 42, wherein the pitch-<br>
preserving transform compresses the play-out time of the one or more vocoder<br>
frames.<br>
47.	The computer-readable medium of claim 42, wherein the pitch-<br>
preserving transform expands the play-out time of the one or more vocoder<br>
frames.<br>
48.	The computer-readable medium of claim 42, further comprising storing<br>
and monitoring the one or more vocoder frames stored in a queue.<br>
49.	The computer-readable medium of claim 48, wherein the queue storing<br>
the one or more vocoder frames is a play-out queue buffer.<br>
50.	The computer-readable medium of claim 49, further comprising:<br>
monitoring a plurality of vocoder frames stored in the play-out queue<br>
buffer;<br>
as certaining a storage capacity depth of the play-out queue buffer; and determining if the depth of the play-out queue buffer is sufficient to mask an expected jitter in a media stream.<br>
51. The computer-readable medium of claim 5 0, wherein if the depth of the play-out queue buffer is determined to be too low to mask the expected jitter in the media stream, a latency is induced into the play-out waveform.<br>
52.	The computer-readable medium of claim 5 1 , wherein the latency is<br>
modified by expanding a length of the play-out waveform.<br>
53.	The computer-readable medium of claim 51, wherein the latency is<br>
modified by compressing a length of the play-out waveform.<br>
54.	The computer-readable medium of claim 50, further comprising applying<br>
a pitch-preserving transform to the one or more vocoder frames. •<br>
55.	The computer-readable medium of claim 50, further comprising applying<br>
a frequency-to-time domain transform to the one or more vocoder frames.<br>
56.	The computer-readable medium of claim 51 , further comprising using a<br>
time-compression algorithm to reduce the latency, if the latency exceeds a<br>
predetermined value.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LUNsYWltcy0oMTAtMTAtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-Claims-(10-10-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LUNvcnJlc3BvbmRlbmNlIE90aGVycy0oMTctMDQtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-Correspondence Others-(17-04-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LUNvcnJlc3BvbmRlbmNlLU90aGVycy0oMTAtMTAtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-Correspondence-Others-(10-10-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LWNvcnJlc3BvbmRlbmNlLW90aGVycy0xLnBkZg==" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-correspondence-others-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LWNvcnJlc3BvbmRlbmNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LURyYXdpbmdzLSgxMC0xMC0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-Drawings-(10-10-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LUZvcm0tMTMtKDEwLTEwLTIwMTIpLnBkZg==" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-Form-13-(10-10-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LWZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LUZvcm0tMy0oMTctMDQtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-Form-3-(17-04-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LUdQQS0oMTAtMTAtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-GPA-(10-10-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LXBjdC0yMTAucGRm" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-pct-210.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzA4NC1kZWxucC0yMDA3LVBldGl0aW9uLTEzNy0oMTAtMTAtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">3084-delnp-2007-Petition-137-(10-10-2012).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="260284-a-system-for-providing-a-status-of-a-user-to-incoming-callers-and-the-method-thereof.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="260286-method-and-apparatus-of-controlling-reverse-transmission-in-a-mobile-communication-system.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>260285</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>3084/DELNP/2007</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>17/2014</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>25-Apr-2014</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>19-Apr-2014</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>25-Apr-2007</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 MOREHOUSE DRIVE, SAN DIEGO, CA 92121 USA.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>ROSEN ERIC C.</td>
											<td>611 CALLE PAULE, SOLANA BEACH, CALIFORNIA 92075 USA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04J 3/06</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2005/037510</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-10-19</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/969,496</td>
									<td>2004-10-20</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/260285-method-and-apparatus-for-managing-end-to-end-voice-over-internet-protocol-media-latency by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:24:57 GMT -->
</html>
