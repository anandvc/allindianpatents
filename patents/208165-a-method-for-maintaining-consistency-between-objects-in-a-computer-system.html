<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/208165-a-method-for-maintaining-consistency-between-objects-in-a-computer-system by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:56:24 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 208165:A METHOD FOR MAINTAINING CONSISTENCY BETWEEN OBJECTS IN A COMPUTER SYSTEM</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD FOR MAINTAINING CONSISTENCY BETWEEN OBJECTS IN A COMPUTER SYSTEM</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A method for maintaining consistency between objects in a computer system, the method comprising: providing a first relationship between a first entity and a second entity; providing a semantic object comprising an action to be performed in response to a change in the first entity; associating the semantic object with the second entity; and making a change in the first entity thereby invoking the action.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT 1970<br>
[39 OF 1970]<br>
&amp;<br>
THE PATENTS RULES, 2003<br>
COMPLETE SPECIFICATION<br>
[See Section 10; rule 13]<br>
'A METHOD FOR MAINTAINING CONSISTENCY BETWEEN OBJECTS IN<br>
A COMPUTER SYSTEM'<br>
INTERGRAPH SOFTWARE TECHNOLOGIES COMPANY ("IST"), a corporation organized and existing under the laws of the State of Nevada, 2325-B Renaissance Drive, Las Vegas, Nevada 89119, United States of America,<br>
The following specification particularly describes the invention and the manner in which it is to be performed:<br><br>
PATENT Attorney Docket No.: 12172-008610<br>
MANAGING OBJECT RELATIONSHIPS USING AN OBJECT<br>
REPOSITORY<br>
CROSS-REFERENCES TO RELATED APPLICATIONS<br>
This application claims priority from the following provisional patent application, the disclosure of which is herein incorporated by reference for all purposes:<br>
U.S. Provisional Patent Application No. 60/131,970 in the names of Yann L. Duparcmeur, et al. titled, "Object Relationship Management System," filed April 30, 1999.<br>
The following commonly owned previously filed applications are hereby incorporated by reference in their entirety for all purposes:<br>
U.S. Patent Application Serial No. 09/258/595 in the names of Mark D. Fortenbery, et al. titled, "OLE for Design and Modeling," filed February 26,1999; and<br>
U.S. Patent Application Serial No. 09/459,812 in the names of Jean-Louis Ardoin et al. titled, "Object Relationship Management System", filed December 13,1999.<br>
COPYRIGHT NOTICE A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.<br>
BACKGROUND OF THE INVENTION The present invention relates generally to the field of object based software systems, and more particularly to techniques for managing relationships between objects of the software systems and maintaining data and referential integrity of the software systems when an object is changed, for example, modified, copied, or deleted. With the increase in the number of heterogeneous application programs used by consumers, it become increasingly important that these applications be able to communicate with each other in a consistent manner without having to know the implementation details of the applications involved. Traditionally, this was accomplished by using applications developed by a common vendor or by a group of vendors who had<br><br>
agreed upon a common interface between the various applications. While this approach achieved a limited degree of success in integrating heterogeneous applications, the approach soon became unfeasible as the number of vendors and the number of applications rapidly increased.<br>
More recently vendors are attempting to solve the application integration problem by deygloping applications using object-oriented frameworks and repository technology. Repositories enable sharing and reuse of information by providing a common hub for storing metadata which describes the structure and meaning of software components. Metadata enables heterogeneous applications to manipulate software components without knowing the implementations of the components. To promote sharing and reuse of metadata information among heterogeneous applications, information models are defined to standardize the structure and semantics of the metadata. A repository, using a standardized information model, provides a global and consistent mechanism for accessing metadata for application development.<br>
An example of a repository is the Microsoft Repository developed by Microsoft Corporation of Redmond, Washington. The Microsoft Repository uses the Open Information Model (OIM) for describing metadata specifications and provides an environment for sharing, reuse, and integration of metadata for application development. Information stored in the Microsoft Repository is exposed using Microsoft's Common Object Model (COM) which forms the basis for the Object Linking and Embedding (OLE) technology which allows objects to share data and capabilities. COM defines a binary standard for object implementation that is independent of the implementation programming language. COM objects are in-memory representations of the information stored in the repository. A repository may include a object-oriented or relational or mixed database.<br>
The repository information model defines the classes of the objects, types of relationships that can exist between the objects, and various properties that are attached to the object classes and the relationship types. A "class" may contain properties, methods, and collections which are grouped into functionally related groups which are implemented as COM "interfaces." In COM, a class may have multiple interfaces which are publicly accessible to users of the object-oriented framework and enable communication between applications.<br>
A repository object is defined in terms of the interfaces that it exposes. The set of interfaces that an object exposes describes the object's state, the manner in<br><br>
which the object can be manipulated, and the associations the object can have with other objects. Relationships may also be defined between interfaces of different objects or of the same object. Further information and details about COM and OLE may be obtained from "Inside OLE 2" by Kraig Brockschmidt, 1994, Microsoft Press, and "Inside COM, Microsoft's Component Object Model," by Dale Rogerson, 1997, Microsoft press, both of which are hereby incorporated by reference for all purposes.<br>
Fig. 1 depicts a convention representation of a COM interface 10, for an object 11 (another term for object 11 is component) and a user 12 of the object. Object 11 is said to have an "interface implementation", including interfaces 13 and 14, that are analogous to an object oriented programming "class." Interfaces 13 and 14 include member functions 15 and 16, respectively. User 12 can manipulate object 11 by calling functions 15, and 16 of interfaces 13 and/or interface 14, respectively. In response to the function calls, object 11 may return specific data about itself to user 12. Object 11, however maintains exclusive control of its own data 17. In some cases user 12 may only be aware of one of several interfaces available in object 12. The available interface may then be queried for additional interfaces. A pointer to the queried interface is returned if the queried interface is supported by the object. For example, the lUnknown interface 13 is a COM interface that is typically available to all users of COM objects. The lUnknown interface may then be queried to obtain pointers to other interfaces supported by the object, such as interface 14. After obtaining a pointer to interface 14, user 12 can call member functions 16 belonging to interface 14.<br>
As previously stated, relationships may be established between interfaces of one or more objects or between interfaces of the same object. A relationship describes the way in which one object refers to another object, as exposed through their interfaces. The participants in a relationship are usually referred to as "entities" participating in the relationship. Relationships are usually binary, for example relationships in Microsoft Repository, may be directed or bi-directional. A relationship typically includes an origin of the relationship, referred to as the "origin" entity, and a destination of the relationship, referred to as the "destination" entity. In Microsoft Repository, each relationship conforms to a particular relationship type and is associated with an object of the class RelationshipDef. This object contains the metadata associated with the relationship.<br>
Several actions have to be preformed when entities involved in a relationship are changed, for example, modified, copied, or deleted. These operations are important for maintaining referential and data integrity of the object system.<br><br>
Accordingly, an important aspect of any object-oriented framework system is the manner in which referential and data integrity of the system is maintained when entities involved in a relationship are changed.<br>
Several techniques have been developed for maintaining integrity of the object system when entities participating in relationships are changed. In conventional systems, the actions be performed upon a change operation are usually associated with each occurrence of the relationship. In addition, the code implementing the actions is typically spread through out the object implementation and thus is difficult to understand arid maintain. The increased complexity of the implementation also makes it unsuitable for modification or customization.<br>
Thus, there is a need for a relationship management system which allows generalized relationships to be defined between objects and which provides a simplified technique for maintaining referential and data integrity of the object system when objects involved in a relationship are changed.<br>
SUMMARY OF THE INVENTION One embodiment of the present invention provides a method of maintaining consistency between objects in a computer system. The method includes providing a first relationship between a first entity and a second entity. A semantic is also provided, including an action to be performed in response to a change in the first entity. A semantic object is associated with the second entity and making a change in the first entity invokes the action. In a second embodiment, the method may also include providing a second relationship between a third entity and the second entity. And after the action is invoked, performing the action on the third entity. The action may be selected from a group consisting of copy, delete, and modify.<br>
In another embodiment a computer system for maintaining consistency between objects is provided. The computer system includes a processor; and a memory coupled to the processor. The memory stores relationship pattern information and modules for execution by the processor. The pattern information includes information defining a first relationship between a first entity and a second entity, information defining a second relationship between a third entity and the second entity, and information defining a semantic object with actions to be performed for changing the third entity in response to changes in the first entity. The modules include a module for<br><br>
associating the semantic object with the second entity and a module for invoking the actions when the first entity is changed.<br>
In yet another embodiment a method of assembling information in order to maintain integrity of objects in a database is provided. The method includes establishing a relationship pattern, having a binary relation between a first entity and a second entity. A semantic object having an action to be performed in response to a change in the first entity is provided and is associated with the second entity. Metadata having information from the relationship pattern and arguments of the semantic object are then determined. The metadata and the semantic object are stored. In one embodiment the metadata is stored in a COM or CORBA repository and the semantic object is stored in a DLL file.<br>
In another embodiment a method for updating information in a database, having a first relation between a first entity and a second entity and a second relation between a second entity and a third entity is provided. A first object of the first entity is next changed. The first relation associated with the first object is identified and using the first relation and repository metadata, the second entity is identified. The second entity is also identified as an active entity. A semantic object associated with the active entity is next found, where the semantic object has an action to be performed in response to a change in the first entity. Using arguments of the semantic object, the third entity is identified. Lastly, the action is evaluated to change the third entity.<br>
In another embodiment a method for providing consistency among persistent objects in a computer system is disclosed. The technique includes using the metadata in a repository to construct a graph having entities and relations; A semantic object is associated with each active entity. A passive entity having a persistent object is then changed in the graph; and the graph is traversed to update the entities using the semantic objects.<br>
BRIEF DESCRIPTION OF THE DRAWINGS Fig. 1 depicts a convention for representing COM/OLE interface for an<br>
object and a consumer of the object according to an embodiment of the present invention; Fig. 2 depicts a block diagram of a system incorporating an embodiment of<br>
the present invention;<br>
Fig. 3 depicts the various components of a relationship pattern according<br>
to an embodiment of the present invention;<br><br>
Fig. 4 depicts an example of a relationship pattern according to an embodiment of the present invention;<br>
Fig. 5 shows a block diagram illustrating the steps to create metadata for a relationship pattern in a specific embodiment of the present invention;<br>
Fig. 6 shows an example of a relationship pattern that represents two parallel pipes;<br>
Fig. 7 shows a UML diagram describing Fig. 6 of another embodiment of the present invention;<br>
Fig. 8 illustrates two objects: a dimension and a line;<br>
Fig. 9 illustrates a graphic representation of the COM interfaces for line and dimension of Fig. 8;<br>
Fig. 10 illustrates a UML representation for line and dimension of Fig. 8 using a specific embodiment of the present invention;<br>
Fig. 10A illustrates another UML representation for line and dimension of Fig. 8 using another specific embodiment of the present invention;<br>
Fig. 11 shows a relationship pattern of Fig. 10 at the business model level;<br>
Fig. 12 gives a flowchart illustrating the updating process for one embodiment of the present invention;<br>
Fig. 13 illustrates a UML diagram for parallel lines; and<br>
Fig. 14 depicts relationship pattern information for Fig. 13 as seen using a repository browser of one embodiment of the present invention.<br>
DESCRIPTION OF THE SPECIFIC EMBODIMENTS Fig. 2 is a block diagram of a system 60 incorporating an embodiment of the present invention. System 60 includes a display monitor 61, a computer 62, a keyboard 63, and a mouse 64. Computer 62 includes familiar computer components such as a processor 65, and memory storage devices such as a random access memory (RAM) 66, a disk drive 67, and a system bus 68 interconnecting the above components. Mouse 64 is but one example of a graphical input device, a digitizing tablet 65 is an example of another. In the embodiment depicted in Fig. 2, system 60 includes a IBM PC compatible personal computer, running Windows™ operating system or one of its variants, OLE and COM software developed by Microsoft Corporation, and ASSOC GSCAD product currently under development by Intergraph Corporation. Fig. 2 is representative of one type of system for embodying the present invention. It will be readily apparent to one of<br><br>
ordinary skill in the art that many system types and configurations are suitable for use in conjunction with the present invention.<br>
According to one specific embodiment of the present invention a relationship pattern includes a set of entities related to one common entity by binary relationships and a semantic object. The types of binary relationships include dependency and equivalence. A further description is given in United States Patent No. 5,692,184, "Object Relationship Management System," by Jean-Louis Ardoin, et. al, filed May 9,1995, assigned to Intergraph Corporation, which is herein incorporated by reference in its entirety for all purposes (referred to herein as "Patent No. 5,692,184"). For sake of documentation, the common entity in a relationship pattern definition is referred to as an "active" entity. The active entity is, for example, an interface definition or an instance of the Microsoft Repository class InterfaceDef. In this embodiment relationship definitions between entities are stored in the Microsoft Repository and relationship pattern definitions are defined based on the relationship definitions stored in the Microsoft repository, which includes a database.<br>
The set of entities related to the active entity by binary relationships are referred to as "passive" entities. These passive entities are connected to the active entity by membership in one or more binary relationships. A relationship describes the functional way in which the passive entities contribute to or respond to changes in the active entity. Accordingly, a passive entity may serve either as an input entity or as an output entity or as a constraint for a relationship pattern. A cardinality value is associated with each end of a relationship describing the expected number of participants or elements on either side of a relationship. The cardinality may comprise zero or more elements. When a relationship has a directionality, i.e., a dependency relationship, then one end of the relationship is called the "origin" while the other end of the relationship is called a "destination." The cardinality and/or end designation, i.e., origin or destination, of each end of a binary relationship is called a "role." It should be noted that the words "active" and "passive" are used only for documentation purposes and do not in any manner limit the scope of the present invention.<br>
The semantic object describes actions to be performed to maintain referential and data integrity of the object system or database when any entity of a relationship pattern is changed, for example, modified, copied, or deleted. The actions include a delete action describing processing to be triggered when a relationship pattern entity is deleted, a copy action describing processing to be triggered when a relationship<br><br>
pattern entity is copied, and one or more modify (or "compute") actions describing processing to be triggered when a relationship pattern entity is modified or a computation on an object(s) is performed. A semantic object is a functional unit and does not store any state information about the relationship pattern from one invocation to the next. In one embodiment a semantic object is realized as a COM interface, for example, IJCompute, for the compute/modify semantic object.<br>
The semantic object has one or more arguments related to the semantic object by repository relationships. The arguments include the relationship type. Typically, the arguments are part of information that provides a navigation path from the active entity to the passive entity/entities. An argument may be classified as input, output, or constraint, where constraint occurs in an equivalence relationship.<br>
A semantic object may be associated with any interface in the object system. The interface with which the semantic is associated becomes the active entity. This facilitates the extensibility of the object system. Further, in one embodiment of the present invention, the arguments of a semantic object and their type in the relationship pattern, i.e. input, output, or constraint, are readily definable. This improves ease of use of the object system.<br>
In sum, in one embodiment, a relationship pattern includes an active entity, one or more passive entities, the binary relationships with accompanying roles, and a semantic object.<br>
Fig. 3 depicts an example of a relationship pattern 70 entities A 72, B 74, C 76, D 78 and semantic object 80. Entity C 76 is the active entity since it is the common entity which is involved in a binary relationship with the other entities in the relationship pattern. Entities A 72, B 74, and D 78 are passive entities. Fig. 3 also shows three binary relationships: Relation_A 81, RelationB 86, and ReIation_C 88. Relation_A 81 shows a dependency relationship with a Origin 82 and a Destination 84, where Origin 84 and Destination 86 are two roles of Relation_A. A semantic object 80 is associated with active entity C 76 and controls the processing to be triggered, in the context of an active entity, when an entity belonging to the relationship pattern is change, for example, modified, copied, or deleted.<br>
Fig. 4 depicts an example of a relationship pattern 100 including active entity IJMakeParaAtDistance 102 and three passive entities 104,106, and 108 defined as IJDLine interfaces. Entities 104 and 106 are the input entities while entity 108 is the output entity for relationship pattern 100. According to the relationship pattern of Fig. 4,<br><br>
output entity 108 is drawn parallel to input entity 104 and at a predetermined distance from input entity 106. Passive entity 104 is in a relationship 'TarallelTo" 120 with active entity 102, passive entity 106 is in a relationship "DistanceFrom" 122 with active entity 102, and output passive entity 108 is in a relationship "MakeParallelAtDistanceResult (MPADResult)" 124 with active entity 102. Further, all three relationship have a 1-1 cardinality on the origin of the active entity relationship. This implies that one IJDLine entity 108 established via relationship MPADResult 124 is parallel to one IJDLine entity 104 established via relationship ParallelTo 120 and a specific distance from one IJDLine entity 106 established via relationship Distancefrom 122. The cardinalities on the destination sides of the relationship are 0-1 implying that the IJDLine entities do not have to be in the relationship, but if they are, then at most one JDLine can be in the relationship. There are several roles, for example, 120-a, 120-b, 122-a, 122-b, 124-a, and 124-b. An illustrative example is the roles for the "ParallelTo" 120 relationship, which are "ParallelToDestination: 0..1" 120-a on the destination side and "ParallelToOrigin: 0..1" 120-b on the origin side<br>
A semantic object 130 is associated with active entity 102. Semantic object 130 shown in Fig. 4 has an accompanying evaluate method, which recomputes the output entity when changes are made to the input entities 104 or 106. In one embodiment the semantic object 130 is implemented as a COM object. An example of a class definition, i.e., COM object, for the MakeParallelComputeSem semantic object 130 is:<br>
Class CMakeParallelComputeSem: IJCompute<br>
{<br>
public:<br>
STDMETHODIMP Evaluate( LPENUMJARGDESC pRelatedValues);<br>
STDMETHODIMP PreValueModify( LPJARGDESC pPreModifyValue, LPENUMJARGDESC pArgsOfSemantic);<br>
}<br>
IJCompute is the base class for CMakeParallelComputeSem and is the interface for Class CMakeParallelComputeSem. In one embodiment IJCompute may have the following format:<br>
Interface IJCompute: IUnknown<br>
{<br>
IJCompute: :EnumValues<br><br>
Enumerates the arguments of the semantic and qualifies them as input / output / constraint. A return code of RELATION_S_IMPLICIT_INPUT / OUTPUT indicates that entities enumerating the corresponding relation should be considered as argument of the semantic even if not enumerated by this function<br>
UCompute: :Evaluate<br>
Asks the semantics) to update its output after a change of one or more of its inputs. This function is called only if arguments of the semantics have been actually been modified.<br>
UCompute: :GetSolver<br>
Only used on constraint to find the corresponding constraint solver.<br>
UCompute: :PreValueModify<br>
Tells the semantic(s) that the passed in argument is about to be modified. This occurs before the modification actually happens. The modification could come from a command, a recompute semantic or a solver.<br>
UCompute: :ImplementDeferOrError<br>
Indicates if the semantic is defer / error aware.<br>
}<br>
The code implementing the Evaluate method may be, for example, the following (stub format):<br>
STDMETHODIMP CMakeParallelComputeSem: Evaluate<br>
(LPENUMJIDREF pRelatedValues)<br>
{	// Code to recompute the output entity 108 when changes are made<br>
// to the input entities 104 or 106<br>
return S_OK;<br>
}<br>
The MakeParallelComputeSem semantic object 130 takes two input arguments, Parellelto:IDJLine=INPUT 132, and DistanceFromOrgin:IDJLine=INPUT 134 and one output argument, MPADResult:IDJLine=OUTPUT 136. In alternate embodiments, a delete and copy semantic may also be associated with active entity 102. For the example of Fig. 4, active entity 102 exists solely for providing a context around<br><br>
which to build the relationship pattern. The active entity is thus an interface to a "stub" object. However, in alternate embodiments a "real" object or a business object may also act as an active entity.<br>
Fig. 5 shows a block diagram illustrating the steps to create metadata for a relationship pattern in a specific embodiment of the present invention. First the relationship pattern is described (step 210) either using an informal figure such as Fig. 4 or using a Universal Modeling Language (UML) diagram. Next the passive entities must be created or located using a GUID (Globally Unique Identifier) or a IK) (Interface Identifier) - OBJID (Object Identifier) pair (step 212). The active entity is then created or located (step 214) using another GUID or UD-OBJTD pair. In step 216 the relationships between the active entity and one or more passive entities are added. These binary relationships may have a cardinality and/or a direction. The relationships may have roles, for example, a dependency relationship has an "Origin" role and a "Destination" role. The semantic object(s) is declared (step 218) and any arguments that the semantic needs to function are identified (step 220). The preceding steps created metadata that at step 222 can be stored in the Repository.<br>
Fig. 4 may be used as an example of using the steps of Fig. 5 for creating metadata for the Repository, in a specific embodiment. The code is in Appendix 1, which is incorporated herein. The ASSOC update engine is given in Appendix 2, which is incorporated herein. Fig. 4 describes the relationship pattern (step 210).<br>
At step 212 OBJIDs and HDs for passive entities are declared. A relationship pattern uses objects via their interfaces. Thus the object-interface pairs for all passive contributors to each relationship in the pattern need to be specified. In our example, we have the same JDLine accessed via its LJDLine interface for each of the three relationships 120,122, and 124. Thus we define an OBJID (which is a GUTD appended by a long identifier) and refer to an existing HD. This GUTD should be the same as the interface HD to be used.<br>
// Define OBJID and HDs that serve as (Passive) JDLines<br>
define UD IJDLine 0x260E0AlF 0x04F18 0x11D1 0x97 0x70 0x08 Ox 00 0x36 0x75 0x42 Ox 03<br>
define OBJID JDLine 0x260E0AlF 0x04F18 0x11D1 0x97 0x70 0x08 Ox 00 0x36 0x75 0x42 Ox 03 0x00<br><br>
Now that the participating OBJID and IID are specified, an interface for the Repository may be created. The createlNTERFACE key word is used, followed by the participating OBJID and ED:<br>
createlNTERFACE IJDLine objid JDLine iid IJDLine<br>
Note that we could have called the OBJID, UD and INTERFACE by any names we chose. It is not the name ("IJDLine") but the actual value of the JJD that marks it as an IJDLine interface.<br>
At step 214 an OBJID and UD for the active entity is declared. In our example, the active entity is a stand-alone. That is, it exists for the sole reason of tying the passive entities of the relationship pattern together, and does not have serve as an independent business object. The name of the active object is: MakeParaAtDistanceHub and its corresponding interface: IJMakeParaAtDistanceHub. The process in step 214 is similar to step 212.<br>
define UD IJMakeParaDistanceHub   0x42D921B7 0x7567 0x11D1 OxBD 0x31 0x08 0x00 0x36 0xF4 0x17 0x03<br>
define OBJID IJMakeParaDistanceHub 0x42D921B7 0x7567 0x11D1 OxBD 0x31 0x08 0x00 0x36 0xF4 0x17 0x03 0x00<br>
createlNTERFACE IJMakeParaDistanceHub<br>
objid IJMakeParaDistanceHub<br>
iid IJMakeParaDistanceHub<br>
In step 216, we define the participating relationships and roles. Our example incorporates JDLines as the passive entities in all relationships, of which there are three: "ParallelTo", "DistanceFrom" and "MPADResult". The following shows the code for specifying the "ParallelTo" relation. The full specification for all three relations can be found in Appendix 1.<br>
First, we define an OBJID for the relationship and name it "ParallelTo". Then we create a GUID using the GuidGen tool (in Visual C++) and with the addition of a long integer, we get:<br><br>
define OBJID ParallelTo 0xE6FAEAE2 0x77BA Oxl ldl OxBD 0x33 0x08 0x00 0x36 0xF4 0x17 0x03 0x00<br>
Having defined a OBJID for "ParallelTo", we use it in the createRELATION declaration and name the relation "ParallelToRelation". We specify the origin as DMakeParaDistanceHub (and name the origin role "ParallelToOrigin"), the destination as IJDLine (and name the destination role "ParallelToDestination"), and the type as COLLECTION_NAMING:<br>
createRELATION ParallelToRelation Origin IJMakeParaDistanceHub ParallelToOrigin Destination IJDLine ParallelToDestination Type COLLECTION_NAMING<br>
The other two relationships are declared similarly (with different GUTDs, of course). In step 218 a semantic object is declared. Our example has only one semantic, compute. We declare a compute semantic named MakeParallelComputeSem. The process begins with defining an OBJID, in this case the identifier of our semantic instance:"<br>
define OBJID MakeParallelComputeSem  0xE6FAEAE4 0x77BA 0x1 ldl OxBD 0x33 0x08 0x00 0x36 0xF4 0x17 0x03 0x10<br>
Next an instance of the semantic object is created (using the createlNSTANCE SemanticDef key phrase) and is connected to the relationship pattern active entity, IJMakeParaDistanceHub (using the ConnectTo key word). In the ConnectTo statement, we specify an interface (IHoldSemantic) and a collection name (Semantics). This is the collection of semantics managed by this active entity. The active entity knows nothing about this collection of its semantics; it is the act of defining them to the Repository via these statements that actually connects them. This is a major advantage of the metadata approach: entities and relationships and patterns and semantics can all be glued together outside the compiled code. The syntax is:<br>
createlNSTANCE SemanticDef MakeParallelComputeSem ConnectTo IJMakeParaDistanceHub IHoldSemantic Semantics<br><br>
A semantic has two properties: Property 1 is the type of semantic:<br>
Compute, Delete or Copy; and Property 2 is the progid of the object that provides the<br>
semantics' implementation. Our type is Compute.<br>
setPROPERTY MakeParallelComputeSem ISemantic noname<br>
type char<br>
index 1<br>
value Compute<br>
setPROPERTY MakeParallelComputeSem ISemantic noname<br>
type char<br>
Index 2<br>
value AnchorSemantics.MakeParallelCompute. 1<br>
We next declare the arguments of the semantic at step 220. Our semantic has three arguments. The first two are input arguments that provide the parallel Une and the distance line. The third argument is the output line. The declaration of the parallel input line is shown below. The other two are similar (see Appendix 1).<br>
We begin declarations by creating OBJID's. Each argument has a corresponding OBJID. We name each argument according to the relation that it represents. We then connect each argument to the semantic. Note that the use of the ConnectTo keyword in this situation employs an additional argument following the collection name (Arguments): the index (1,2, or 3) of the argument. This determines the order of arguments evaluated by the Evaluate method.<br>
define OBJID ParallelTo_Arg 0xE6FAEAE5 0x77BA 0x1 ldl OxBD 0x33<br>
0x08 0x00 0x36 0xF4 0x17 0x03 0x00<br>
insertINSTANCEArgumentDefParallelTo_Arg<br>
ConnectTo MakeParallelComputeSem ISemantic Arguments 1<br>
Each argument has two properties. Property 1 specifies whether the<br>
argument is INPUT or OUTPUT. Property 2 specifies the OBJID of the relationship)to<br>
which this argument corresponds.<br>
setPROPERTY ParallelTo_Arg IHaveArguments noname<br>
type char<br>
Index 1<br>
value INPUT<br>
setPROPERTY ParallelTo_Arg IHaveArguments noname<br>
type OBJID<br>
Index 2<br>
value ParallelToRole<br><br>
At step 222 MakeRepos is used to build the target Repository file and thus store the metadata in the Microsoft Repository.<br>
Fig. 6 shows an example of a relationship pattern 300 that represents two parallel pipes(oriented relationship) 310 and 312 with the direction and distance that is given by a line 314. In short, the second pipe 312 is parallel to the first pipe 310 at a distance equal to the length of the line 314 and using the line 314 for the direction.<br>
Fig. 7 shows a UML diagram 400 describing Fig. 6 of another embodiment of the present invention. The UML shows this relationship pattern by using an interface hub, DXFormPipe (active entity) 410 that has relations 412, 416, 418 to the passive entities, DDPipe 422 and IJLine 424, and is tied to the compute semantic SXFormPipe 450. The descriptions of various metadata of one embodiment of the present invention that can be stored in a Repository are given in Appendix 3. The extensions to UML for one embodiment of the present invention are given in Appendix 4. Both Appendices 3 and 4 are incorporated herein.<br>
In order to create metadata to be stored in the Repository for this embodiment using the example UML diagram of Fig. 7, the steps in Fig. 6 are followed, although not necessarily in the same order. Step 210 describes the relationship pattern in the UML diagram of Fig. 7. In step 212 the passive entities 422,424 need to be added. A class DDPipe is first added:<br>
In the Typelnrepository "Value" column, change the value to Interface<br>
Change the "Value" of GUJD and put in the GUTD of IJDPipe: {E0C4E513-6EBD-11D2-BDEF-080036801C04}<br>
There are two ways to find the GUTD of an interface: (1) look at the corresponding .idl file where the interface has been defined, or (2) use the registry (regedit) and do a search for the interface name such as IJDPipe 422. Next the IJLine 424 interface is added. For this example it is assumed the IJLine interface already exists. In step 214 the active entity, DXFormPipe 410, is added:<br>
In the Typelnrepository "Value" column, change the value to Interface<br>
Change the value of GUID and put in the GUTD of DXFormPipe: {4AC243C0-70F8-11D2-BDEF-080036801C04}<br><br>
In this embodiment step 218 is performed before step 216. In step 216 a semantic object is added by adding a class SXFormPipe 450:<br>
In the Typelnrepository "Value" column, change the value to Semantic<br>
Change the "Value" of SemanticType to Compute<br>
Change the "Value" of SsemanticProgH) to<br>
SXFormGSCADPipe.SXFormPipe.l. (It is the ProgID of the compute semantic.)<br>
Next an association, TieToSXFormPipe, is created between IJXFormPipe 410 and SXFormPipe 450.<br>
At step 216 binary relationships are added:<br>
Create an association between IJDPipe and IJXFormPipe: Name: InputPipe 412<br>
Role A (IJXFormPipe side): InputPipeDst 420 Role B (IJDPipe side): InputPipeOrg 422 GSCD B Tab, change IsOrign: True<br>
Create an association between IJDPipe and IJXFormPipe : Name: OutputPipe 416<br>
Role A (IJXFormPipe side): OutputPipeDst 426 Role B (IJDPipe side): OutputPipeOrg 424 GSCD B Tab, change IsOrign: True<br>
Create an association between IJXFormPipe and IJLine : Name: InputTranslation 418 Role A (IJLine side): InputTranslationOrg 428 Role B (IJXFormPipe side): InputTranslationDst 430 GSCD A Tab, change IsOrign: True<br>
At step 220 the arguments of the semantic are defined for SXFormPipe:<br>
InputPipeOrg, SXFormPipe, String, Input 452 InputTranslationOrg, SXFormPipe, String, Input 454 OutputPipeOrg, SXFormPipe, String, Output 456<br>
At step 222 our UML model, i.e., Fig. 7, is defined with all the necessary information (metadata) needed to define the relationship pattern for Fig. 6 and can be exported to the Repository.<br>
In one embodiment of the present invention, after the metadata is created and deposited and the semantic objects defined, changes to a passive entity may be<br><br>
propagated consistently through the system by using the metadata and the semantic object(s). Use of the information in the relation objects and/or the active entities, i.e., at the business model level, is not needed, as opposed to prior art which needed to access to one and/or the other. An example will show the differences.<br>
Fig. 8 illustrates two objects: a dimension 512 and a line 510 and is described in Fig. 8 of Patent No. 5,692,184. In this example, the dimension 512 depends on the line 510 such that whenever the geometry of the line 510 changes the dimension 512 is re-calculated.<br>
Fig. 9 illustrates a graphic representation of the COM interfaces for line 510 and dimension 512 of Fig. 8 and is described in Fig. 9 of Patent No. 5,692,184 (col. 63, line 49 to col. 64, line 37). The three nodes in the associative graph are a value node 530 representing the line's geometry (identified by line 540, and interface DLine 550), a function node 560 representing the evaluation function, "ComputeCFun," (identified by interface IJCompute 520), and a value node 570 representing the line's dimension (identified by dimension 580, and interface IJDimension 590).<br>
The evaluation function of function node 560 is called every time the IJLine interface 550 is changed. The evaluation function determines how the output entity, in this case IJDimension 590, is modified due to the change in input entity, IJLine 550. The evaluation function is accessed through its interface IJCompute 520, which is in turn accessed through IJRelation 515. Thus the evaluate function is accessed through a relation interface (IJRelation 515) and its interface, IJCompute 520 is part of the dimension object 570, 580.<br>
Fig. 10 illustrates a UML representation for line 510 and dimension 512 of Fig. 8 using a specific embodiment of the present invention. Besides the IJLine Interface 550 (input passive entity) of Line object 610 and IJDimension interface 590 (output passive entity)of Dimension object 612, there is a IJHub interface 620 (active entity)for the hub object 614. IJHub 620 has no method or properties and serves solely as a hub between the two passive entities 550 and 590. There are two binary relationships, Relation_A 622 and Relation_B 624. The relationships 622 and 624 are different than those of Fig. 9, IJRelationValue 517 and IRelation 515 above, in that 622 and 624 do not point to a function. In one embodiment the evaluation function is in the semantic object 630 and is accessed through the IJCompute interface (not shown). The semantic has two arguments: Relation_A: IJLine = INPUT 632 and Relation_B: IJDimension = OUTPUT 634. Thus the semantic object 630 is separate from the entities 550, 590, and 620.<br><br>
Fig. 10A illustrates another UML representation for line 510 and dimension 512 of Fig. 8 using another specific embodiment of the present invention. In this embodiment the IJDimension interface 590 has been combined with the IJHub interface 620 into IJDimension 640. UDimension 640 is both a passive entity, as it receives the output of the semantic object 656, as well as active entity, as it tied to the semantic object 656. Note that more than one semantic may be associated with one active entity. The relationship between IJLine 550 and IJDimension 640 is SpecialRelationForThatPattem 650 and it has an origin role 652 and a destination role 654.<br>
Fig. 11 shows a relationship pattern of Fig. 10 at the business model level. Fig. 11 has instances of the classes given in Fig. 10 and has no semantic object 630. "xxx" 610-a is an instance of class Line 610. "yyy" 612-a is an instance of class Dimension 612. "Instance of Hub" 614-a is an instance of class Hub 614. There is also an instance 622-a of RelationA 622-a and an instance 624-a of Relation^ 624-a. Thus a change on "xxx" 610-a may cause a change in "yyy" 612-a. However, how the change is accomplished is not part of the business level, but is part of the metadata and semantic object (see Fig. 10).<br>
Fig. 12 gives a flowchart illustrating the updating process for one embodiment of the present invention. At step 710 the value of an object is changed for example, modified (or the object may be deleted or copied). Next at step 712 the relations associated with the changed object are identified. At step 714 the metadata is examined to find the active entity that has a relation to the changed object. A semantic object(s) is then identified for the active entity (step 718). The other passive entities are identified by following the relations (given in the semantic object arguments) from the active entity (step 720). A list is created of the passive entities, where each passive entity is qualified with a input/output/constraint identification (step 722). The IJcompute interface for the semantic is called and the Evaluate method is performed on the list of qualified entities, and the output (and some constraint) object(s) is updated with the result(s) of the Evaluate method (step 724). Note the evaluate method is in charge of updating the output object(s).<br>
An example of the steps in Fig. 12 applied to Figs. 10 and 11 is:<br>
1.	Modify a line (interface IJLine 550 on object xxx 610a).<br>
2.	Look at the relations enabled on object xxx 610a and find an instance of<br>
Relation A 622-a.<br><br>
3.	Look in the metadata for the definition of relation_A 622 and see that relation_A 622 is attached to DHub 620.<br>
4.	Look at all the semantics associated to IJHub 620 and find semantic object 630.<br>
5.	Look at the arguments 632, 634 of that semantic object 630 and find one that takes Relation_A:IJLine 632 as input. If a line was attached to IJHub using another relation type, e.g. RelationZ, the semantic would not need to be triggered. From now on the semantic must be triggered to update the outputs. Look in the metadata for the other arguments required and find IJDimension 590 following Relation_B 624 from IJHub 620.<br>
6.	Navigating the instances, construct a structure containing a pointer on xxx.IJLine (qualified as INPUT) and a pointer on yyy.IJDimension (qualified as OUTPUT).<br>
7.	Look at the CLSID(Class Identifier) associated with the semantic in the metadata. The CLSID is an identifier used to get the filename of the DLL (Dynamic Link Library) file containing the semantic object 630,<br>
8.	Cocreate the object having CLSID found in step 7 and query its IJCompute interface. "CoCreatelnstance" creates an instance of the semantic object 630.<br>
9.	Call the evaluate method on the IJCompute interface of step 8 with the arguments of the structure constructed in step 6. The evaluate method updates the Dimension (interface IJDimension 590 on object yyy 612-a).<br>
By using the metadata types and the associative graph and applying the steps in Fig. 12, consistency can be maintained for any number of persistent objects or any objects in a object-oriented or relational database (persistent objects is further described in "The Essential Distributed Objects, Survival Guide," Robert Orfali, Dan Harkey, and Jeri Edwards, 1996, John Wiley and Sons, which is herein incorporated by reference. Thus a change in one entity could be propagated though out the persistent objects or database. This is accomplished by using the metadata to construct the associative graph starting from the changed entity and then traversing the graph to update the connected entities.<br>
Fig. 13 illustrates a UML diagram for parallel lines. The output line (with XFormResult relation 802) is parallel to the Model line (with XFormModel relation 804) and is at distance and direction given by a translation line (with XFormTranslation<br><br>
relation 806). DDLine 810 is a passive entity. IJCopyXForm 812 is an active entity. SCopyXForm 814 is the semantic object tied to the active entity 812.<br>
Fig. 14 depicts relationship pattern information for Fig. 13 as seen using a repository browser of one embodiment of the present invention. The active entity ICopyXForm 812 is displayed in a tree format. IXDLine 810 is also displayed (not shown on Fig. 14) on the same level as ICopyXForm 812. Semantic SCopyXForm 814 has a collection of arguments associated with it including arguments XFormModelOrigin 816, XFormTranslationOrigin 818, and XFormResultOrigin 820. The arguments are qualified as input, output, or constraint arguments as indicated by the "the_type_of_argum..." property 830. Accordingly, Fig. 13 depicts that the XFormModelOrigin entity is an input argument 816. The "type_of_the_Relship" property 832 indicates which relationship to follow to find the argument starting from the active entity. It should be noted that the active entity itself may be qualified as an input, output, or constraint argument to the semantic associated with the relationship pattern definition.<br>
In the foregoing specification, the invention has been described with reference to specific exemplary embodiments thereof. Other embodiments will be apparent to those of ordinary skill in the art. For example, embodiments of the present invention could be realized using CORBA (Common Object Request Broker Architecture) rather than COM. A comparison is given in the text "COM and COBRA Side by Side," by Jason Pritchard, Ph.D, 1999, Addison-Wesley and is herein incorporated by reference in its entirety for all purposes. Thus, it is evident that various modifications and changes may be made thereunto without departing from the broader spirit and scope of the invention as set forth in the appended claims and their full scope of equivalents.<br><br>
APPENDIX 1<br>
lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll<br>
II Add new TIM (type information model)for the purpose of adding a<br>
// new relationship pattern,<br>
// IJMakeAnchorLineParallelAtDistance.<br>
CreateTTM AnchorParallelAtDistance-TIM<br>
lltlllllllllllllllllllllllllHIIIIIIIIIHIIIIHIIIIIIIIHIIIIHIIIIIIII<br>
II Declare Passives for relationships.<br>
// IJMakeAnchorLineParallelAtDistance uses only IJDLines, so here<br>
// define IJDLine IE), OBJID and declare Interface/Objid connection<br>
// The value of the IJD comes from the IDL file in the project that<br>
// creates IJDLine'<br>
define UD IJDLine 0x260E0AlF 0x4F18 Oxl IDl 0x97 0x70 0x08 0x00 0x36 0x75 0x42 0x03<br>
define OBJID JDLine 0x260E0AlF 0x4F18 0x1 1Dl 0x97 0x70 0x080x00 0x36 0x75 0x42 0x03 0x00<br>
createlNTERFACE UDLine<br>
objid IJDLine<br>
iid IJDLine<br>
lllllll/llllllllllllllllllllllllllllllllllll/lllllllll/llll/lllllllllll<br>
II Declare Active Entity for a relationship pattern.<br>
// define DMakeParaDistanceHub IID, OBJID and INTERFACE connection<br>
define JJD DMakeParaDistanceHub 0x42D921B7 0x7567 0x1 IDl 0xBD0x31 0x08 0x00 0x36 0xF4 0x17 0x03<br>
define OBJID DMakeParaDistanceHub<br>
0x42D921B7 0x7567 0x1 IDl 0xBD0x31 0x08 0x00 0x36 0xF4 0x17 0x03<br>
createlNTERFACE DMakeParaDistanceHub<br>
objid DMakeParaDistanceHub<br>
iid DMakeParaDistanceHub<br>
lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll<br>
II Declare relationships that participate in Pattern.<br>
//<br>
// Declare Parallel-defining a relationship<br>
// ParallelToRelation. Use GuidGen, DEFINE_GUID format, and delete<br>
// extraneous stuff, then tack on long "0"<br>
define OBJID ParallelToRelation 0xE6FAEAE2 0x77BA 0x1 ldl OxBD 0x33 0x08 0x00 0x36 0xF4 0x17 0x03 0x00<br>
createRELATION ParallelToRelation<br><br>
Origin DMakeParaDistanceHub ParallelToOrigin Destination IJDLine ParallelToDestination Type COLLECTION_NAMING<br>
lllllllllltlllllllllllllllllllltllltlllllllllilllllllllllllllllllllllll<br>
II Declare Distance-defining Relation DistanceFromRelation.<br>
define OBJID DistanceFromRelation 0xE6FAEAE6 0x77BA 0x1 Idl 1 OxBD 0x33 0x08 0x00 0x36 0xF4 0x17 0x03 0x00<br>
createRELATION DistanceFromRelation<br>
Origin IJMakeParaDistanceHub DistanceFromOrigin<br>
Destination IJDLine DistanceFromDestination<br>
Type COLLECTION_NAMTNG<br>
lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll<br>
II Declare Result-defining Relation MPADResultRelation.<br>
define OBJID MPADResultRelation 0xE6FAEAE8 0x77BA 0x1 Idl OxBD Ox3 0x08 0x00 0x36 0xF4 0x17 0x03 0x00<br>
createRELATION MPADResultRelation<br>
Origin IJMakeParaDistanceHub MPADResultOrigin<br>
Destination IJDLine MPADResultDestination<br>
Type COLLECTION_NAMTNG<br>
lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll<br>
II Declare a compute semantic: ComputeParaDistance. Note that in<br>
// this case, the long ID is 0x10 as opposed to our customary 0x00<br>
define OBJID ComputeParaDistance<br>
0xE6FAEAE4 0x77BA 0x1 1dl OxBD 0x33 0x08 0x00 0x36 0xF4 0x17 0x03 0x10<br>
lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll<br>
II Create an instance of the semantic and attach it to the<br>
// relationship pattern via Active: IJMakeParaDistanceHub<br>
// Then set Property 1 (type of semantic: Compute) and Property 2<br>
// (progid of object that provides semantic implementation).<br>
// IHoldSemantic &amp; ISemantic are defined in IMSCoreRelPats.RLP<br>
createINSTANCE SemanticDef MakeParallelComputeSem<br>
ConnectTo IJMakeParaDistanceHub IHoldSemantic Semantics<br>
setPROPERTY ComputeParaDistance ISemantic noname<br>
type char<br>
index 1<br>
value Compute<br>
setPROPERTY ComputeParaDistance ISemantic noname<br><br>
type char<br>
Index 2<br>
value AnchorSemantics. ComputeParaDistance.l<br>
IIIIIIIIIIIIIIIIIIHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII<br>
II Declare semantic arguments. Each argument has a corresponding<br>
// OBJID. We will name each argument according to the Relation it<br>
// represents. We connect each argument to the semantic. Note that<br>
// the ConnectTo keyword uses an extra argument when connecting<br>
// arguments: the index (1,2, or 3) of the argument. This specifies<br>
// the order of arguments evaluated by the Evaluate method.<br>
// ArgumentDef &amp; IHaveArguments are defined in IMSCoreRelPats.RLP<br>
define OBJTD ParallelTo_Arg 0xE6FAEAE5 0x77BA Oxl Idl OxBD 0x33 0x08 0x00 0x36 0xF4 0x17 0x03 0x00<br>
insertINSTANCE ArgumentDef ParallelTo_Arg<br>
ConnectTo ComputeParaDistanceObjid ISemantic Arguments 1<br>
lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll<br>
II Each argument has two properties: Property 1 specifies whether<br>
// the argument is INPUT or OUTPUT. Property specifies the GUJD of<br>
// the Relation (e.g., relationship) to which this argument corresponds<br>
setPROPERTY ParallelTo_Arg IHaveArguments noname<br>
type char<br>
Index 1<br>
value INPUT<br>
setPROPERTY ParalleITo_Arg IHaveArguments noname<br>
typeGUID<br>
Index 2<br>
value ParallelToRelation<br>
llllllll/lllllllllllll/llllllllllllllllllll/lllllllllllllllllllllllllll<br>
II Declare DistanceFrom argument<br>
define OBJID DistanceFrom_Arg 0xE6FAEAE7 0x77BA 0x11dl OxBD 0x33 0x08 0x00 0x36 0xF4 0x17 0x03<br>
insertTNSTANCE ArgumentDef DistanceFrom_Arg<br>
ConnectTo ComputeParaDistanceObjid ISemantic Arguments 2<br>
setPROPERTY DistanceFrom_Arg IHaveArguments noname<br>
type char<br>
Index 1<br>
value INPUT<br><br>
setPROPERTY DistanceFrom_Arg IHaveArguments noname<br>
typeGUID<br>
Index 2<br>
value DistanceFromRelation<br>
lllllillllllllllllllllllllllllllllllllllllllHIIIIIIIIIIIIIIIIIllllllll<br>
II Declare MPADResultRelation argument. Note that it is an OUTPUT argument<br>
define OBJID MPADResultRelation_Arg 0xE6FAEAE9 0x77BA Oxl ldl 0xBD33 0x08 0x00 0x36 0xF4 0x17 0x03<br>
insertlNSTANCE ArgumentDef MP ADResultRelation_Arg<br>
ConnectTo ComputeParaDistanceObjid ISemantic Arguments 3<br>
setPROPERTY MPADResultRelation_A IHaveArguments noname<br>
type char<br>
Index 1<br>
value OUTPUT<br>
setPROPERTY MPADResultRelation_A IHaveArguments noname<br>
typeGUID<br>
Index 2<br>
value MPADResultRelation<br>
lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll<br><br>
2.3      Semantics In A Recompute Graph<br>
Assoc recognizes two kinds of semantics: associative functions and constraints. This paragraph will describe them. It will also introduce solvers and interface dependencies, that play also an active role during the update process.<br>
2.3.1   Associative Functions<br>
Consider a cell in a spreadsheet that calculates the sum of a row of numbers. Whenever a number in the row is modified, the sum is updated. In associative terms, this would the result of an associative function which<br>
•	takes for input the row of numbers<br>
•	produces the relevant sum for output.<br>
We say that the sum depends on the numbers in the row. Notice that you cannot directly edit the sum. The sum only exists as the output of the dependency relation. To change the sum you must change one or more of the values it depends on or make the sum depend on a new set of values. You can only affect the output of a . recompute semantic by changing its input.<br>
Now, consider another cell that calculates an average by dividing the sum. When a number in the row is changed: the sum would be updated first then the average would be updated, associative functions imply an ordering of evaluation.<br>
When an associative function is evaluated, it entirely replaces its output value. For this to produce predictable results:<br>
•	A value cannot be the output of more that one associative function. If this were the case, it could not keep a consistent and predictable content. It would only represent the result of which ever function was evaluated last.<br>
•	If declared output, the value can only be changed by the re-evaluation that declares it output. As seen in the spreadsheet example above, you cannot directly edit an associative output. Any direct modification of an output would be over-written at the next re-evaluation of the function which declares it output.<br><br>
For example, suppose a function that sets the start and end points of a line "LineBy2Pts (Line, P1, P2)" is an associative function that has a line for its output. When called, this function updates the geometry of the line from the input values P1, P2. If either of the two points changed, the evaluation function would compute a new value for the line. Notice that if the line is modified without modifying the associative function, nor the input point, the evaluation function LineBy2Pts function is re-evaluated, and post back to the line its initial geometry. You can never directly modify the output of a dependency relation.<br>
2.3.2   Constraints<br>
In case of constraint, the related entities play symmetrical roles. Both can be edited and it may have an effect on the other entity in relationship.<br>
Consider a graphics system that can create a parallel constraint between two lines: line 1 and line 2.<br>
•	The end-user can grab Line 1 with the mouse and move it. In response, the system moves line 2 so that it remains parallel to line 1.<br>
•	The end-user can also move line 2 and the system would move line 1 to remain parallel.<br>
In associative terms, the lines would be in an constraint relationship. Notice the difference between dependency and constraint<br>
•	In the dependency example above you could not directly modify the sum.<br>
•	In contrast, in an equivalence relation any of the entities may be modified. (Outputs are treated equally with inputs.) Equivalence is not a one-way relation. Because of this, there is no possible ordering. An associative application updates equivalence relations by examining a set of entities and their related constraints as a whole. A decision is made as to which entities can be modified to satisfy all of the constraints.<br>
A predicate or constraint is used to define an equation or a constraint between values.<br>
Several simultaneous predicates can be associated to the same value. Therefore, unlike an associative function, a predicate only partially defines a value(s). An external mechanism, called a solver, is used to modify value respecting all the predicates applied to it. (However, if a value that is the output of an associative function is used as<br><br>
an argument of a predicate, it cannot be modified by a solver The solver treats these as a "constant".)<br>
For example, suppose a predicate that constraints the begin point of a line to match a given point: 'IsBeginPoint(LO,Pl)". The line geometry is only partially defined by this predicate. If LO or P1 changes, the predicate, LO and P1 are passed to a solver. The solver would modify LO or P1 to make LO's begin point concident with P1. If any other values were related by predicates to LO and P1, those values along with their predicates would be passed to the solver at the same time.<br>
2.3.3    Solvers<br>
Constraints end up being quite inactive during the update process: They<br>
•	enumerate their arguments and qualifies them input! constraint<br>
•	Indicates which solver to use for that type of constraints, the dialog to get from the solver the nature of the constraint being established by interface that Assoc is not aware of.<br>
And that's up to the solver to find the adequate solution.<br><br>
The solver is given as argument<br>
•	a list of values (qualified input or constrained)<br>
•	a list of constraints, and for each the list of values that the constraint take for argument. These constraints will implement additional interfaces, that Assoc is not aware of. The solver can query them additional information, example the type of the constraint.<br>
An argument that a constraint enumerates and qualifies CONSTRAINED may be presented to the solver INPUT only because the same value is output of another semantic.<br>
2.3.4   Internal Granularity For Values Coming From the Same Object<br>
An argument of a recompute semantic is a pair (pObject IID). This means that a single COM object may become several values in the recompute graph. (The IID may be an interface implemented by the COM object, or just a 'virtual interface', only defined to support relationship connection, without an associated Vtable, as MS Repository does.<br>
But are these values totally independent the one from the other? Is the value obtained from (pObject, IID1), affected by what's posted on (pObject,IID2)?<br>
That's why Assoc is adding additional recompute semantics when a COM object plays the role of several value in the recompute graph. This is such that<br>
•	Ordering of semantic outputting to the object versus semantics taking their input from the same object is correct<br>
•	Propagation of the MODIFIED bit is done correctly<br>
In 0.5, all the values coming from the same COM! object are considered independent the one from the other. The version 1.0 will complete this and detail how to describe this interface dependency in meta data.<br>
These concepts will be discussed paragraph 2.7 of this document.<br>
2.4      Update Is Performed On the Associative Dependent Graph<br>
Update is performed on an associative dependent graph, by the following successive steps:<br>
Definition of initial elements, elements that have been modified or inserted, and declared such to the revision manager<br><br>
(IJRevision::Update,IJRevision::Add)<br>
•	Search and sort of the dependent graph to obtain a set of values and an ordered list of associative functions and solvers<br>
•	Evaluate the ordered list of functions and solvers<br><br>
-	An evaluation function is evaluated by calling IJCompute: :Evaluate.<br>
-	A solver is evaluated by calling IJConstraintSolver::Solve. Constraints and related values are passed in. It is up to the solver by the technique of its choice to satisfy the predicates by modifying related values.<br>
•	Recatch the dependent graph if a semantic or a solver asks so. It<br>
requires an incremental search and sort of the dependent graph, before<br>
update calls are resumed.<br><br>
We're using for that purpose DAG (Directed Acyclic Graph) technic to optimize the update process. This ensures that recomputes semantic are called only one time, when adequate. But this requires that the recompute semantics modifies only what they declare output (or that the constraint solvers only modifies the constrained arguments of their constraints).<br>
In certain situations, a recompute semantic may need to modify something not declare output. The modified entities are then kept in a look aside list. At completion of the recompute process in the current DAG, a secondary recompute is then performed on the secondary DAG issued from that look aside list.<br>
This means that modifying non output values of semantic has a negative impact on performances. This should be only used carefully, and we don't want it to be current processing. That's why Assoc asserts if a semantic modifies a non output argument, without turning ON the "reentry mode" by calling IJRevision::BatchReentry. Our purpose doing so is to make sure this is really necessary, done by design. And that it doesn't just happen because of some mistake.<br>
2.5	Pre-Notification Of Value Change<br>
The function IJCompute.-PreValueModify is called on a semantic when a related value is going to be modified.' This means that the call is performed before the modification is actually performed.<br>
To achieve it: commands, associative functions and constraint solvers should notify the revision managerbefore they modifies the element, manipulated by the command, or output argument / constraint argument of the associative function / constraint solver.<br>
This lets a chance to the semantic to capture relevant information about the entity in its initial state before its value gets affected.<br>
2.6	Incremental Re-catch Of the Dependent Graph<br>
When a dependent graph updates, an incremental re-catch of the graph is necessary in 2 different cases<br><br>
2.6.1   Constraint System With Incremental Solving<br>
When elements that participates a constraint system are modified, the update engine could catch entire constraint systems and present complete to the adequate solver.<br>
That's the simplest solution for a constraint system of a reasonable size, example a profile, and it's done for solver which are note "incremental enable" (API IJRelationSolver::IslncrementalEnable). It becomes extremely expensive when the constraint systems grows in size, example a the floor plan of an hospital, or a P&amp;ID schema.<br>
The idea of incremental solving is to try to reduce the size of the constraint system that is presented to the solver to the immediate neighbors of the modified elements. The solver could:<br>
•	find a local solution, ie a solution that only changes value of immediate neighbors of the modified elements. But the value of an element should only be changed if all the constraints applied to it participates the caught graph. This means that elements at the boundary of the caught constrained system, presented to the solver because certain constraints applied to them are part of the system to solve, but some other are not, should not be modified. Such elements are flagged "RELATION_FROZEN".<br>
•	If a local solution could not be found, the constraint solver should ask the associative subsystem to perform an incremental re-catch of the graph that adds all the constraints on<br><br>
certain FROZEN elements. In addition to these constraints, this will introduce some more elements other arguments of these added constraints, that may be in turn frozen. Several solver call and re-catch of the graph can then be performed. Refer the API description here bellow to see how the solver could indicate how many elements should be introduced in the initial constraint system, and bow many more should be added at each re-catch (IJRelationSolver: :GetWidth).<br>
Incremental catch of the dependent graph with a salver width of 1<br><br><br>
r- Limits of the /    explored graph<br><br>
2.6.2   Edition Of the Graph By the Evaluate Function Of a Recompute Semantic<br><br>
As part of its processing, an evaluate function may modified certain relations of the dependent in the sense of<br>
-	semantic that the relation contains<br>
-	connectivity of the relation, ie removing or adding connected value to the relation.<br>
2.6.3   What's Done In Case Of Incremental Solving<br><br>
As described in earlier paragraphs the different steps of an update operation are<br>
1.	Find the set of interested values and functions or constrained<br>
2.	Order the functions and solver associated to the solver such that a function which declares a value output is called before the function that takes it for input<br>
3.	Call in that order each evaluation function and solver.<br>
If at step 3, the dependency graph is modified (edition of the relation), or if some more elements need to be taken in the domain of interest (incremental solve), this means that step 1 and 2 should be completed before step 3 can terminate.<br>
2.6.4 What's Relevant To That Technique In the Assoc Interfaces<br>
2.6.4.1 API For Constraint System with Incremental Solving IJRelationSol7ver: :IslncrementalEnable<br>
This API is called by Assoc to figure out if the solver is incremental enable or not. If incremental enable, a partial catch of the constraint system can be performed. The system to can be later on complete at the request of the solver per the incremental solving technique described here above.<br>
A solver that is incremental enable should return S_OK.<br>
IJRelationSolver: :Get Width<br>
This API is called by Assoc to controls how many elements are retained initially in a incremental constraint system, and to extend the constraint system when the solver asks for incremental catch. The "width" returned is the minimum number of non-frozen values between elements modified, or unfrozen, and the first frozen value.<br>
When representing a value by a node and a constraint by edges that connect constrained arguments, the minimum path between a modified element (or an unfrozen element) and a frozen element contains at least width nodes that can be edited.<br>
A returned value from 1 to 3 is recommended. Maximum is 8.<br>
IJRelationSolver: :Solve<br>
If the solver can not find a correct solution without modifying values marked RELATION_FROZEN, it should return these values in ppAddedValues and return the status RELATION_S_INCREMENTAL_SEARCH to ask the recompute machine for a more complete graph.<br><br>
All the semantics acting on these values and all the values that are values related to these semantics are then added to the graph. After the graph is re-ordered, the evaluation functions with the added values for output are called before the constraint solver is called again with the extended system.<br>
An alternate solution is to ask for a complete search of the constraint system by returning RELATION_S_FULL_CONSTRAINT.<br>
2.6.4.2 API For Edition Of the Graph During IJCompute::EvaIuate When an Evaluate function changes the relationships in the dependent graph, it<br><br>
[OBSCURED TEXT]<br>
graph is no longer valid, and ask for the incremental graph.<br>
2.7      Internal Atomicity Of Elements That Participate Recompute<br>
2.7.1   Description Of the Problem<br>
The overview of the associative subsystem describes how relationship types are defined to interfaces, and how an element by exposing several interfaces can participate multiple relationships of different types.<br>
If these relationship types and patterns are associated recompute semantics, the element becomes argument of several recompute semantics. These recompute semantics consider for arguments distinct interfaces of the element.<br>
Example : The object PQ, exposes interfaces IJD1 and IID2. It participates by these interfaces relationships Rl and R2. Because of meta data associated to these relationships<br>
-	(PO, IID1) is output of a semantic SI<br>
-	(PO, IID2) is input of another semantic S2.<br>
Now the problem: How much these 2 values of the recompute graph(P0, nDl) and (PO, ID32) can be seen independent from each other ?<br>
•	They are totally independent, IJD1 is representing for example the geometry of the entity, and 11D2 its user properties. That's then irrelevant to the associative subsystem that the 2 entities of the recompute graph are coming from the same COM objet.<br>
•	They are not so independent from each other: Posting new data to(P0, IID1) changes the data obtained from the other (PO, DD2). When proceeding the update graph, the semantic S1, outputting to IID 1, should then be proceeded before S2. In that configuration, certain restrictions may also apply to guarantee consistency of the data model after all the recompute are performed. That's what will be developed in the rest of the paragraph.<br>
2.7.2   Entities Seen As a Structure<br><br>
An entity is seen as a structure, containing fields or nested sub structures. This organises the internal data of the COM object into a tree, and it defines its internal atomicity.<br>
Interface IID used to connect relationships are paired to the atoms of the tree (fields, intermediate sub-structure, top most structure),<br>
As a result of this tree like structure, when an element is modified through anllD<br>
•	All the atoms nested (or scoped) in that modified atom (field or nested structures) are considered modified.<br>
•	All the atoms containing the modified atom are considered modified<br>
•	But the sibling are not<br>
For the semantics taking them for argument<br>
•	If a semantic declares an IID for input, and if anything has changed under the atom corresponding to that IID, the semantic should recompute<br>
•	When an IID is modified, all the atoms of the tree structure bellow that IID are considered modified, and the semantics taking them for INPUT should recompute.<br><br>
•	Because outputting to an outer IID is affecting the inner, the ordering<br>
of the semantic should be such that the semantic outputting to the outer<br>
IID is called before the semantic(s) taking the inner for input.<br>
2.7.3	Member Assignment<br>
The question is: Do we allow<br>
•	Semanticl to declare IID1 for input<br>
•	Semantic2 to declare IID2 for output<br>
With IID2 corresponding to an inner atom of EDI?<br>
This violates somehow the rule that an entity can be OUPUT of only one semantic at the time, since the recompute of both Semantic 1 and Semantic2 will affect what IID2 represents. We propose to allow that with the following logic:<br>
•	Semantic 1 affects globally the structure corresponding to IID1<br>
•	Semantic2 is evaluated after, and overrides the specific IID2 part of it<br>
2.7.4	Final Recompute Order<br>
•	The semantic that outputs to the outer atom recomputes first<br>
•	The inner atoms are marked modified<br>
•	Semantics that outputs to the inner atoms recomputes.<br>
•	Semantics that takes the inner atoms for input can then update.<br>
•	Outer atoms are marked modified, up to the outermost (that represents the complete element)<br>
•	Semantics inputting from the outer atoms can then update.<br>
2.7.5	Example<br>
The diagram bellow illustrates an object that exposes following IID<br>
IIDJFull_Object. It represents the complete object<br>
IID_Geometry. It represents the geometric part of the object, and it's scoped into IID_Full_Object.<br>
IID_Attributes. It represents the user attribution on the object. It's scoped under IID_Full_Object. It's a sibling of IID Geometry, which means that modifying IID Geometry and HD_Attributes (or what's scoped under it) has no effect on each other.<br><br>
IID_Attrl and IID_Attr2 represents specific user attributes. Their are iling and scoped under IID_Attributes.<br>
Relationships to that object, and associated meta data are such that (object, IID_Attributes) is output of semantic S1 (object, IID Attrl) is output of semantic S2 (object, HD Attr2) is input of semantic S3 (object, HD Geometry) is input of semantic S4<br><br>
(object, IID Full Object) is input of semantic S5<br><br>
If another entity that is input argument of SI is modified, the sequence of recompute will be:<br>
-	S1 recomputes first. This may change what is read from IID_Attrl, IID_Attr2<br>
-	S2 recomputes after, per "the member assignment rule"<br>
-	S3 and S5 will then recompute (the order is not defined, S3 may recompute before or after S5)<br>
But S4 will not recompute.<br><br>
2.7.6   Atomicity Defined On Classes<br>
The above description of the element atomicity comes from the meta data the application. We may consider 2 possible ways of defining it:<br>
•   At the interface level.<br>
s what we did initially. Meta data of an interface defines in which interface this interface is 'scoped'. This means that all the class sing this interface will present for it the same atomicity model, lat we have a unique scoping tree for all the intf, all the classes of rstem.<br><br>
I<br><br>
This showed non-practical and caused unsolvable conflict in establishing this unique tree.<br>
•	At the class level.<br>
The scoping tree is defined per class: All the entities of the same class expose the same atomicity model. But it will defer from one class to the nexthow an interface is scoped an be different from one class to another.<br>
We will use the same to define in the repository the roles that objects expose for the connection of relationships.<br>
If no scoping information is explicitly defined for a given ED, this IID is considered directly scoped under IDD FULLOBJECT (topmost atom representing the complete object).<br>
2.7.7   API<br>
Internal atomicity is described as follow:<br>
•	A specific IID : HD_FULL_OBJECT is associated to the complete object.<br>
•	HRESULT IJRelationMetaData:: GetScoping( const GUID Atom, GUID* ContainingAtom);<br>
with Atom IN, Inquired atoms ContainingAtom OUT Containing atom Remarks:<br>
-	Depending from IID_FULL_OBJECT should be the preferred way to depend on the complete object<br>
-	GetScoping(IID_FULL_OBJECT) should be the only call that returns S_FALSE, and no scoping intf.<br>
3. API And Interfaces<br>
What's bellow is just an introduction to the API. Please refer to the complete Assoo API documentation for much more information on each function, what it does, its argument list and its possible return code.<br><br>
3.1      IJCompute: Interface For Associative Function Or Predicate<br>
3.1.1   IJCompute: .'Evaluate Purpose<br>
Asks the semantics to update its output after a change of some of its inputs.<br>
This function is called only if arguments of the semantics have been actually been modified.<br>
Modified arguments can be detected by<br>
-	getting the argument from the enumerator pRelatedValues<br>
-	getting the flags associated to that argument by pArgDesc-&gt;GetArgumentFlags(&amp;flags)<br>
-	testing if that flag contains the bit RELATION_MODMED.<br>
This function should notify the revision manager of the output argument about to be modified by calling IJRevision-&gt;Update(pObject,iid). This should be done before the output is assigned a new value.<br>
Parameters<br><br>
LPENUMJARGDESC	IN	Enumerates<br>
pRelatedValues		<br>
Return code		<br>
S_OK		Successful completion<br>
E FAIL		Failure<br><br>
3.1.2   IJCompute::PreVahieModify<br>
Purpose<br>
Tells the semantics that a related entity is about to be modified. This occurs before the modification actually happens. The modification could come from a command / a recompute semantic or a solver. Parameters<br>
LPJARGDESC pModifiedValue LPENUMJARGDESC pRelated Values<br>
IN	Value about to be modified<br>
IN<br>
Enumerates the complete list of arguments of the semantic<br>
Precaution of use<br>
•	For performance reasons, PreValueModify of a semantic may be called for a value that is not actually argument of the semantic. This is up to the semantic to control.<br>
•	The semantic has no persistence at all, not even between the call to PreValueModify and to Evaluate. This means, that if the semantics has something to persist (example initial value for a constraint solver in order to find the solution the closest to the initial state), the semantics needs to return to persistent entity, by the mean of the pModifiedValue-GetCollection. The "initial state" can the be stored for example in the active entity, or in the solver, associating it to the runtime (pUnknown) or persistent identity of the element to be modified.<br>
3.1.3   IJCompute: ImplementDeferOrError<br>
Indicates if the semantic is defer / error aware.<br><br>
If the semantic is defer / error aware, its evaluate function will be called even if some of its arguments are in error / out of date.<br>
If not, the associative system will propagate automatically the out of date / error status to the output argument<br>
This will be implemented in latter cycle of the system, not there in 1.0.<br>
3.2      IJRelationSolver: Interface For Solver<br><br>
3.2.1   IJRelationSolver::Solver<br>
Purpose.<br>
Solves the constraints system after values or constraints participating it have been modified. Like IJCcmpute::Evaluate; this function should notified the revisi manager of modified elements before the modifications are performed.<br>
Parameters<br>
LPENUMJARGDESC	IN	Values in the constraint system<br>
pRelatedValues<br>
LPENUMCONSTRAINTDESC    IN	Constraint in the constraint system<br>
pRelatedConstraints<br>
LPENUMJARGDESC*	OUT        Used by incremental solver only, to ask<br>
ppAdditionalValue	values to be "unfrozen", when an<br>
acceptable solution can not be found. A value is presented FROZEN to the solver can not be modified by the solver, when all the relationships that it participates have not been explored yet.<br>
3.2.2	IJRelationSolver: :IsIncrementalEnable<br>
Purpose<br>
Indicates if the solver is "incremental enable", and how many elements away from modified values should be presented "not frozen" to the solver. Please refer to the paragraph about incremental solving techniques for more information on the matter.<br>
Return code<br>
S_OK	The solver is incremental enable<br>
S FALSE	The solver is not incremental enable<br>
3.2.3	IJRelationSolver: :GetWidth<br>
Purpose<br>
For a solver mcremental enable, indicates how many unfrozen values should be left between any modified value, and the first frozen value<br><br>
Parameters<br>
ULONG *witdh	OUT	Width, between 0 and 7. A<br>
value of 1 or 2 is recommended<br><br>
3.2.4   IJRelationSolver:: ImplementDeferOrError<br>
Same as IJCompute: :ImplementDeferOrError<br>
3.3      IJArgDesc: Description Of An Argument<br>
Arguments of this type (or enumerators of them, of the type LPENUMJARGDESC) are present in several interface functions described above. They are used to communicate between the associative subsystem and the associative functions or solver that it triggers, by the mean of the following member functions.<br>
An alternate implementation could have been to pass for argument! enumerate directly a structure containing the corresponding fields. This is not practical because<br>
-	more difficult to enable marshalling<br>
-	not VB compatible<br>
-	reference count nightmare since the structure would contains intf pointer to be released by the caller.<br>
3.3.1	IJArgDesc "GetArgu men tObject<br>
LPUNKNOWN pArgument	0	Real unknown of the argument This<br>
should be the unique intf pointe that you get when doing a QI (IID IUnknown) on the object, and not one of the misc intf that it implements<br>
3.3.2	LJArgDesc::GetArgumentIID<br>
LPIID pIID	0	ED of the argument<br>
3.3.3   IJArgDesc ::GetArgumentFlags<br>
ULONG *flags       0       Flags associated to the argument. When used as argument of<br>
Solve or Evaluate, this is made of the binary combination of: RELATIONJNPUT: This is a input arg of the semantic RELATIONJ3UTPUT This is a output arg of the semantic RELATION_CONSTRATNT This is a constraint arg of the semantic RELATION_MODIFIED This arg has been modified<br><br>
3.3.4 UArgDesc: ;Get4rgunieiirCol}ection<br><br>
LPUNNOWN pCoIlection<br><br>
0<br><br>
The object is presented argument of the semantic, because it belongs to a relationship's collection of an active entity. This API lets the semantic retrieve the collection, and from there get more information (type the relationship, identity of the active entity, etc).<br><br>
3.3.5 UArgDesc: .-GetlndexInCollection<br>
Returns the index of the argument in the collection (NB This is I based: The first member of the collection is at the index 1)<br>
ULONG*plndex	0<br><br>
3.3.6   IJArgDesc::GetlndexInSoIverArgument<br><br>
ULONG *plndex	0	Only of use when the pointer IJArgDesc is<br>
obtained from the enumerator returned by IJConstraintDesc: :EnumConstraintArgs. A solver is given for arguments the list of values and the list of constraint in the system. The list of values is the accumulation of all the constraint arguments.<br>
For a given constraint argument, this function returns the index of the corresponding value in the accumulated list of values:(NB 1 based, or 0 based???)<br>
3.4	IJConstraintDesc: Description Of a Constraint In the Constraint System<br>
An enumerator of this type is passed in to constraint solver to describe the constraint participating the constraint system currently solved.<br>
3.4.1	IJConstraintDesc: :GetConstraint<br>
LPUNKNOWN*pConstraint       0	Return the constraint That participates the<br>
constraint system. The constraint solver may need then to Query and use other interfaces on that object to figure out its type. Example, a solver to solve 2d profile will define by the mean of another intf a protocol to figure out if the constraint is coincidence parallelism, orthogonality, etc.<br>
3.4.2	IJConstraintDesc: :EnumArgOfConstraint<br>
LPENUMJARGDESC *	0	Enumerates the arguments of this constraint as<br>
ppArgDesc	they participate the constraint system : The<br>
argument maybe RELATION_MODIFIED or not. It could be INPUT only in the solver, while presented CONSTRAINT in the meta data because of the presence of other semantics outputting to it.<br>
3.5	IJRelationGraphlnfo: Additional Information About the Graph That<br>
Recomputes<br>
Recompute semantics in IJCompute::Evaluate and solvers in IJRelationSolver::Solve can query the first passed in argument (enumerator of related<br><br>
values) for this interface, and obtain such additional information about the graph that recomputes.<br>
3.5.1    IJRelationGraphlnfo: :IsCommitted No Parameters<br>
Returned Value<br>
S_OK	The current recompute corresponds to a modification about<br>
to be committed hence to a call to ITransaction::Commit<br>
S_FALSE	The current recompute corresponds to an intermediate<br>
evaluation during the transaction, asked for by a call to IJRevision::Flush. Not to the final evaluation, done at commit time of the transaction<br>
3.5.2   IJRelationGraphlnfo:: EnumAddedRelationships<br><br>
Purpose<br>
A recompute semantic can be fired just because relationships have been added to the active entity that the recompute semantic is associated to. This without any of the related object being marked RELATION_MODIFIED. This function allows identifying such configuration to implement optimized recompute by<br>
enumerating relationship added to the active entity by the interface IJDRelationship on the enumerated relationship controls the impact that the added relationship may have (or may not have) on the current semantic.<br><br>
Parameters<br>
LPUNKNOWN pObject<br>
LPENUMUNKNOWN<br>
ppEnumAddedRel<br><br>
IN OUT<br><br>
Inquired object<br>
enumerator of added relationships. The passed-in pObject can be origin or destination of the relationship. If no relationship has been added on pObject, a NULL enumerator is returned<br><br>
Returned Value<br>
S_OK E_OUTOFMEMORY<br>
3.5.3   lJRelationGraphlnfo:: EnumRemovedRelationships<br>
Purpose<br>
This function is for the same purpose as EnumAddedRelationships, to optimize recompute semantic with respect to deleted relationships.<br><br>
Parameters<br>
LPUNKNOWN pObject<br>
LPENUMUNKNOWN ppEnumAddedRel<br><br>
IN OUT<br><br>
Inquired object enumerator of removed relationships. The passed-in pObject can be origin or destination of the relationship. If no relationship has been removed on pObject, a NULL enumerator is returned.<br><br>
Returned Value<br>
S_OK E_OUTOFMEMORY<br>
     4. Symbolic Example<br><br><br>
Each node contains an identifier along with a value or function (associative function or a predicate.)<br>
-	"a", "b", "c", "d" and "e" are value<br>
-	"Z" and "X" are predicates<br>
-	"Y" is an associative function<br>
From the description of recompute above, when the node "a" is modified from 4 to 2, successive steps of the update will be<br>
•   Prenotify Y and Z that a is about to be modified. This means Y and Z are told about it when the value of a is still 4.<br>
-	Affect the new value 2 to a<br>
-	accumulate the modified values and relations: In this case, only one node was modified a<br>
-	search for all related nodes to evaluate:<br>
This results in the nodes: "a", "Z", "c", "Y", "b", "X", "d", "e".<br>
-	order the nodes to evaluate:<br>
Given the relationships above, "a", "Z" and "c" are equivalent, "a" must be evaluated before "Y", "Y" before "b". "b" must be evaluated before "X". "d", "X" and "e" are equivalent. This ordering can be expressed as:a = c<y d="f&lt;br/">
-	evaluate the ordered nodes:<br>
1. "a", "Z" and "c" would be passed to a solver to satisfy the predicate "Z". In this case, "c" could be changed to 10 to satisfy the predicate.<br><br>
2. The associative evaluation function "Y" would be called to calculate a new value for "b". Since "a' now has a value of 2, the new value of "b" would be 4.<br><br>
PATENT Attorney Docket No.: 12172-008610<br>
3. "d", "X" and "e" would be passed to a solver to satisfy the predicate "X". Since "b" now has a value of 4, "e" could be change to 4 to satisfy the predicate. The new values after the modification of " a":<br><br>
Notice that even though "e" was considered as part of the recompute it was not changed. (A solver can have more than one way to change values to satisfy predicates.) It is an important optimization to recognize values that don't change. In a graphics system, this can avoid needless erase/display. If there were other nodes dependent on "e" they would not have to be updated.<br><br>
1.	Introduction<br>
This Appendix describes the changes made to the Microsoft Repository needed to contain the additional metadata for an embodiment of the present invention.<br>
2.	Repository Class Definitions<br>
2.1      ReposRoot Class Definition<br>
There is one root object in each repository. The root object is the starting point for navigating to other objects in the repository. The root object serves as the starting point for both type and instance data navigations.<br>
•	Type data navigation:<br>
When you create a tool information model, the corresponding repository type library is attached to the root object via the ReposTypeLibs collection. This collection can be used to enumerate all of the tool information models (type data) that are contained in the repository.<br>
•	Instance data navigation:<br>
Once a tool information model is defined, the repository can be populated with instance data. This instance data consists of objects and relationships that conform to the classes and relationship types of the tool information model.<br>
Because the objects are connected via relationships, you can navigate through this data. However, to enable general purpose repository browsers to navigate this data, the first navigational step must be from the root object of the repository through a root relationship collection to the primary objects of your tool information model. Primary objects are objects that make a good starting point for navigating to other objects of your tool information model.<br><br>
Because this root relationship collection is different for each tool information model, it must be defined by the tool information model. There are two options for attaching this relationship collection to the root object:<br>
1.	The ReposRoot class implements the IReposRoot interface. This interface is provided to tool information model creators as a connection point. You can add your connecting relationship collection to this interface.<br>
2.	You can extend the ReposRoot class to implement a new interface that is defined in your tool information model. This interface implements a relationship collection that attaches the root object to the primary objects in your tool information model.<br>
To facilitate navigation, the root object in all repositories always has the same object identifier. The symbolic name for this object identifier is OBJID_ReposRootOb].<br>
When to Use<br>
Use the ReposRoot class to:<br>
•	Obtain a starting point for navigating to objects in the repository.<br>
•	Create a new tool information model.<br>
•	Attach a relationship collection to the root object of the repository that connects to the primary objects of your tool information model.<br><br><br><br>
Interfaces Interface<br>
IAnnotationalProps IManageReposTypeLib<br>
Description<br>
Gets and sets annotational properties.<br>
Adds tool infonnation models (repository type libraries) to a<br>
IRepositaryDispatch<br>
IRepositoryltem<br>
IRepositoryObject<br>
repository.<br>
Provides enhanced dispatch support.<br>
Manages repository objects and relationships.<br>
Retrieves repository object identifiers.<br>
IRepositaryObjectStorage   Creates and loads repository objects.<br>
IReposRoot	Provides an attachment point for tool information model<br>
instance data.<br>
2.2      ReposTypeLib Class Definition<br>
There is one repository type library for every tool infonnation model contained in the repository database. Each tool information model provides a logical grouping of all of the type definitions related to a particular tool (or tool set). Repository type libraries are instances of the ReposTypeLib class.<br>
To insert a new tool information model into the repository database, use the ReposRoot class.<br>
When to Use<br>
Use the ReposTypeLib class to:<br>
Define new classes, relationship types, and interfaces for a tool information model.<br><br>
■	Retrieve or modify the global identifier associated with a repository type library.<br>
■	Determine which type definitions are associated with a particular repository type library.<br><br><br><br>
Interfaces Interface<br>
IAnnotatianalProps IRepositoryDispatch IRepositoryltem IRepositoryObject<br>
Description<br>
Gets and sets annotational properties.<br>
Provides enhanced dispatch support.<br>
Manages repository objects and relationships.<br>
Retrieves repository object identifiers.<br>
IRepositoryObjectStorage   Creates and loads repository objects.<br>
IReposTypeLib	Creates class, interface, and relationship definitions for a<br>
repository type library.<br><br>
2.3      ClassDef Class Definition<br>
When you define a tool information model in the repository, you define classes of objects, types of relationships that can exist between objects, and various properties that are attached to these object classes and relationship types. The object classes that you define in your tool information model are represented by instances of the ClassDef class.<br>
To insert a new class definition into a tool information model, use the ReposTypeLib class.<br>
When to Use<br>
Use the ClassDef class to complete the definition of a new repository class. You can define new interfaces and attach them to the class definition. You can also attach existing interfaces to the class definition.<br><br><br><br>
Interfaces Interface<br>
lAnnatationalProps ICIassDef<br>
IRepositoryDispatch IRepositaryltem IRepositaryObject<br>
Description<br>
Gets and sets annotational properties.<br>
Manages class definitions.<br>
Provides enhanced dispatch support.<br>
Manages repository objects and relationships.<br>
Retrieves repository object identifiers. IRepository Objects torage   Creates and loads repository objects.<br>
IReposTypelnfo	Contains the collection of definition objects that are associated<br>
with a tool information model's repository type library.<br>
2.4      InterfaceDefDefinition<br>
The properties methods, and collections that a class implements are organized into functionally related groups. Each group is implemented as a COM interface. The properties, methods, and collections of each interface are members of the interface. An interface definition is the template to which an interface conforms. Interface definitions are instances of the InterfaceDef class.<br>
To create a new interface definition, use the ClassDef class or the ReposTypeLib class.<br>
When to Use<br>
Use the InterfaceDef class to:<br>
•	Retrieve or modify properties of an interface definition.<br>
•	Determine which members are attached to an interface definition.<br><br>
•	Determine which classes implement an interface.<br>
•	Determine the base interface from which an interface derives.<br>
•	Determine what interfaces derive from a particular interface.<br>
•	Determine what repository objects expose a particular interface.<br>
•	Add a new property, method or collection type to an interface definition.<br><br><br><br>
Interfaces Interface<br>
IAnnotatianalProps llnterfaceDef IRepositoryDispatch IRepositoryltem IRepositoryObject<br>
Description<br>
Gets and sets annotational properties.<br>
Manages interface definitions.<br>
Provides enhanced dispatch support.<br>
Manages repository objects and relationships.<br>
Retrieves repository object identifiers. IRepository Objects tor age  Creates and loads repository objects.<br>
IReposTypelnfo	Contains the collection of definition objects that are associated<br>
with a tool information model's repository type library.<br>
2.5      RelationshipDef Definition<br>
When you define a tool information model in the repository, you define classes of objects, types of relationships that can exist between objects, and various properties that are attached to these object classes and relationship types. The relationship types that you define in your tool information model are represented by instances of the RelationshipDef class.<br>
When to Use<br>
Use the RelationshipDef Class to access the properties of a relationship definition (also referred to as a relationship type).<br>
To insert a new relationship type into a tool information model, use the ReposTypeLib class.<br><br><br><br>
Interfaces Interface<br>
lAnnotationalProps IRepositoryDispatch IRepositoryltem IRepositoryObject<br>
Description<br>
Gets and sets annotational properties.<br>
Provides enhanced dispatch support.<br>
Manages repository objects and relationships.<br>
Retrieves repository object identifiers. IRepositoryObjectStorage   Creates and loads repository objects.<br>
IReposTypelnfo	Contains the collection of definition objects that are associated<br>
with a tool information model's repository type library.<br>
2.6      Method of Class Definition<br>
When you define a class for a tool information model, you specify the interfaces that the class implements. For each of those interfaces, you specify the members (properties, methods, and collections) that are attached to the interface.<br>
The definition of a method as a member of an interface does not result in the method's implementation logic being stored in the repository. However, it does add the method name to the set of defined member names for that interface. It also reserves the method's dispatch identifier in the set of defined dispatch identifier values for the interface.<br>
Instances of the MethodDef class represent method definitions.<br>
To attach a new method to an interface, use the InterfaceDef class.<br>
When to Use<br>
Use the MethodDef class to access or modify the characteristics of a method definition, or to determine the interface definition to which a particular method is attached.<br><br><br><br><br>
Interfaces Interface<br>
IAnnotationalProps HnterfaceMember IRepositoryDispatch IRepositaryltem IRepositoryObject IRepositoryObj ectstorage<br><br>
Description<br>
Gets and sets annotational properties. Relates a member to an interface. Provides enhanced dispatch support. Manages repository objects and relationships. Retrieves repository object identifiers. Creates and loads repository objects.<br><br>
2.7      PropertyDef Class Definition<br>
When you define a class for a tool information model, you specify the interfaces that the class implements. For each of those interfaces, you specify the members (properties, methods, and collections) that are attached to the interface.<br>
In order to attach a property to an interface, a property definition must exist for the property. The characteristics of the property (it's name, dispatch identifier, data type, and various storage details) are stored in the property definition. Property definitions are instances of the PropertyDef class.<br>
To attach a new property to an interface, use the InterfaceDef class.<br>
When to Use<br>
Use the PropertyDef class to access or modify the characteristics of a property definition, or to determine the interface definition to which a particular property is attached.<br><br><br><br><br>
Interfaces Interface<br>
lAnnotationalProps HnterfaceMember IPropertyDef IRepositoryDispatch IRepositoryltem IRepositoryObject IRepositoryObjectStorage<br><br>
Description<br>
Gets and sets annotational properties. Relates a member to an interface. Retains property characteristics. Provides enhanced dispatch support. Manages repository objects and relationships Retrieves repository object identifiers. Creates and loads repository objects.<br><br>
2.8      ColIectionDef Class Definition<br>
Repository objects are related to each other via relationships. The set of relationships, all of the same type, that relate one object to zero or more other objects, is a relationship collection.<br>
A collection type (also referred to as a collection definition) defines how instances of a particular collection type will behave. The characteristics of the collection type determine:<br>
•	The minimum and maximum number of items in a collection.<br>
•	Whether or not the collection type is an origin collection type.<br>
•	Whether or not the collection type permits the naming of destination<br>
objects, and if so, whether those names are case sensitive, and required to<br>
be unique.<br><br>
•	Whether or not the collection type permits the explicit sequencing of items in the collection.<br>
•	What happens to related objects when objects or relationships in the collection are deleted.<br>
•	The kind of relationship that a particular collection type uses to relate objects to each other.<br>
A collection is attached to an interface as a member of the interface. To add a new collection type to an interface definition, use the InterfaceDef class.<br>
When to Use<br><br>
Use the CollectionDef class to retrieve or modify the properties of a collection type, or to determine the kind of relationship that the collection implements.<br><br><br><br><br>
Interfaces Interface<br>
IAnnotatianalProps ICallectionDef IInterfaceMember IRepositoryDispatch IRepositaryltem IRepositoryObject IRepositoryObj ectStorage<br><br>
Description<br>
Gets and sets annotational properties. Manages collection definitions. Relates a member to an interface. Provides enhanced dispatch support. Manages repository objects and relationships. Retrieves repository object identifiers. Creates and loads repository objects.<br><br>
3.        Repository Interface Definitions<br>
This chapter describes the various interfaces that are part of the type Information Model defined by Microsoft and exposed through the Repository Browser. As for the previous chapter documentation from the Visual basis Books Online has been copied to this chapter to explain each of these interfaces.<br>
3.1      lAnnotationalProps Interface<br>
Annotational properties are repository properties that can be associated with individual repository objects or relationships. When a normal property is defined as a<br><br>
member of a repository interface, it is defined for all objects that implement that interface. Normal properties cannot be associated with repository relationships.<br>
In order to be able to attach an annotational property value to a particular repository object, two requirements must be met:<br>
1.	The object must conform to an object class that exposes the IAnnotationalProps interface.<br>
2.	A property definition object must exist for an IAnnotationalProps interface property with a name that matches the name of your annotational property.<br><br>
If these two requirements are met, then you can attach an annotational property value to an object by using the EReposProperty::put_VaIue method to set the value of the annotational property for that particular object.<br>
When to Use<br>
Use the IAnnotationalProps interface to access the annotational properties of a repository object or relationship.<br><br>
Methods<br>
IUnknown Method Querylnterface AddRef Release<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br><br><br><br>
IDispatch Method GetDsOfNames<br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br><br>
Description<br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get<br>
the type information for an interface. Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1). Provides access to properties and methods exposed by an<br>
Automation object.<br><br><br><br>
IRepositoryDispatch Method getProperties<br><br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposPropertiesinterface provides access to the Properties collection.<br><br>
Remarks<br>
Annotational properties are maintained by the repository as string data. The creator and users of the annotational property must get and set the property value using the appropriate data type via the VARIANT structure. If a data type other than string is used, the repository will perform the appropriate data conversion.<br><br>
Since all annotational properties in the repository must be defined as interface members of the IAnnotationalProps interface, all annotational property names share the same name space. When you choose a name for an annotational property, make the name as specific and unique as possible.<br>
3.2      ICIassDef Interface<br>
The ICIassDef interface helps you create tool information models, by adding interfaces to a class. To insert a new class definition into a tool information model, use the IReposTypeLib interface.<br>
To complete a class definition, once you have added alt of the interfaces, commit the transaction that brackets your class definition modifications.<br>
When to Use<br>
Use the ICIassDef interface to:<br>
•    Add a new or existing interface to a class definition.<br><br>
•	Retrieve the global identifier for the class.<br>
•	Access the collection of interfaces that are part of a class definition.Properties<br><br>
Properties<br>
Property ClassID<br><br>
Description<br>
The global identifier of the class.<br><br><br><br>
Methods lUnknown Method Querylnterface AddRef Release<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br><br><br><br>
IDispatch Method GetlDsOf Names<br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br><br>
Description<br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get<br>
the type Information for an interface. Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1). Provides access to properties and methods exposed by an<br>
Automation object.<br><br><br><br>
IRepositoryDispatch Method get_Properties<br><br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposProperties interface provides access to the Properties collection.<br><br><br><br>
IClassDef Method<br>
Addlnterface<br>
CreatelnterfaceDef<br><br>
Description<br>
Adds an existing interface to the class definition. Creates a new interface and adds it to the class definition.<br><br>
Objectlnstances       Materializes an lObjectCol interface pointer for the collection of all objects in the repository that conform to this class.<br>
Collections<br>
Collection	Description<br>
Interfaces	The collection of all interfaces that are implemented by a class.<br>
3.3      ICollectionDef Interface<br>
A collection type (also referred to as a collection definition) defines how instances of a particular type of collection will behave. The properties of the collection type determine:<br><br>
•	The rninimum and maximum number of items in a collection.<br>
•	Whether or not the collection type is an origin collection type.<br>
•	Whether or not the collection type permits the naming of destination objects, and if so, whether those names are case sensitive, and required to be unique.<br>
•	Whether or not the collection type permits the explicit sequencing of items in the collection.<br>
•	What happens to related objects when objects or relationships in the collection are deleted.<br>
The kind of relationship that a particular collection type uses to relate objects to each other is determined by its CoUectionltem collection. The CoUectionltem collection associates a single relationship type to the collection type.<br>
To add a new collection type, use the InterfaceDef interface.<br>
When to Use<br>
Use the ICollectionDef interface to retrieve or modify the properties of a collection type, or to determine the kind of relationship that the collection implements.<br>
Methods<br>
IUnknown Method	Description<br>
Querylnterface	Returns pointers to supported interfaces.<br>
AddRef	Increments the reference count.<br>
Release	Decrements the reference count.<br>
TDispatch Method	Description<br>
GetlDsOfNames	Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers.<br>
GetTypelnfo	Retrieves a type information object, which can be used to get<br>
the type information for an interface.<br>
GetTypelnfoCount	Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1).<br>
Invoke	Provides access to properties and methods exposed by an<br>
Automation object.<br><br>
IRepnsitnryDispatch Method getProperties<br><br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposProperties interface provides access to the Properties collection.<br><br><br><br>
Properties<br>
Property<br>
Flags<br>
IsOrigin<br>
MaxCount<br>
MinCount<br><br>
Description<br>
Flags that determine the behavior of this type of collection. Indicates whether or not collections of this type are origin<br>
collections. The maximum number of target objects that can be contained in<br>
a collection of this type. The minimum number of target objects that must be contained<br>
in a collection of this type.<br><br>
Collections<br>
Collection	Description<br>
Collectionltem	The collection of one relationship type that defines the<br>
relationship between target objects of this type of collection and a single source object.<br>
3.4      IInterfaceDef Interface<br>
The properties, methods, and collections that a class implements are organized into functionally related groups. Each group is implemented as a COM interface. The properties, methods, and collections of each interface are members of the interface. An interface definition is the template to which an interface conforms.<br>
To add a new interface to the repository, use the IClassDef interface or the IReposTypeLib interface.<br>
When to Use<br>
Use the HnterfaceDef interface to:<br>
•	Retrieve or modify properties of an interface definition.<br>
•	Determine which members are attached to an interface definition.<br>
•	Determine which classes implement an interface.<br>
•	Determine the base interface from which an interface derives.<br>
•	Determine what interfaces derive from a particular interface.<br>
•	Determine what repository objects expose a particular interface.<br>
•	Add a new property, method or collection type to an interface definition.<br>
Properties<br>
Property	Description<br>
Flags	Flags that specify whether the interface is extensible, and<br>
whether the interface should be visible to Automation<br>
interface queries.<br>
InterfaceLD	The global interface identifier for the interface.<br>
Table Name	The name of the SQL table that is used to store instance<br>
information for the properties of the interface.<br><br>
Methods<br>
IUnknown Method Querylnterface AddRef Release<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br><br><br><br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br><br>
Description<br>
Maps a single member and a set of argument names to a corresponding set of dispatch identifiers.<br>
Retrieves a type information object, which can be used to get the type information for an interface.<br><br>
GetTypelnfoCount<br>
Invoke<br><br>
Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1). Provides access to properties and methods exposed by an<br>
Automation object.<br><br><br><br>
IRepositorvDispatch Method getJProperties<br><br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposProperties interface provides access to the Properties collection.<br><br>
HnterfacePef Method	Description<br>
CreateMethodDef	Creates a new method definition, and attaches it to the interface<br>
definition.<br>
CreatePropertyDef	Creates a new property definition, and attaches it to the<br>
interface definition. CreateRelationshipColDef Creates a relationship collection type. The collection type is<br>
attached to the interface definition.<br>
Objectlnstances	Materializes an IObjectCol interface pointer for the collection<br>
of all objects n the repository that expose this interface.<br><br>
Collections Collection Ancestor<br>
Classes Descendants<br>
Members<br><br>
Description<br>
The collection of one base interface from which this interface<br>
derives. The collection of classes that implement the interface. The collection of other interfaces that derive from this<br>
interface. The collection of members that are attached to the interface<br>
definition.<br><br>
3.5      IlnterfaceMember Interface<br>
The properties, methods, and collections that a class implements are organized into functionally related groups. Each group is implemented as a COM interface. The properties, methods, and collections of each interface are members of the interface.<br><br>
The IlnterfaeeMember interface maintains this information for an interface member:<br>
•	The member dispatch identifier.<br>
•	Information about member visibility.<br>
•	The relationship to the interface that exposes a particular interface member.<br>
This information is common to properties, methods, and collection types. The PropertyDef, MethodDef, and CollectionDef classes all implement this interface.<br>
When to Use<br>
Use the IlnterfaeeMember interface to access the common properties of an interface member, or to determine which interface definition has a member of a particular property, method, or collection type.<br>
Properties<br><br>
Property DispatchID<br>
Flags<br><br>
Inscription<br>
-the dispatch identifier to use when accessing an instance of<br>
this type of member. Flags that specify details about this type of member.<br><br><br><br>
Methods lUnknown Method Querylhterlace AddRef Release<br><br>
Description<br>
Returns pointrers to suppotteh intefraces. Increments the reference count, Decrements the reference count.<br><br><br><br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br><br>
ascription<br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get<br>
the type information for an interface. Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1). provides access to properties and methods exposed by an<br>
Automation object.<br><br><br><br>
IRepositoryDispatch Method getProperties<br><br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposProperties interface provides access to the Properties collection.<br><br><br><br>
Collections Collection Interface<br><br>
Description.<br>
The collection of one interface that exposes this type of member.<br><br>
3.6      IManageReposTypeLib Interface<br>
Each tool information  model that is stored in the repository is represented by a<br>
repository type library.<br><br>
When to Use<br>
Use the IManageReposTypeLib interface to:<br>
•	Create a repository type library for a new tool information model.<br>
•	Determine what tool information models are currently stored in the repository.<br>
Methods<br>
lUnknown Method	Description<br><br>
Querylnterface<br>
AddRef<br>
Release<br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br>
Description<br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers. Retrieves a type inforrmation object, which cm be used to get<br>
the type information for an interface. Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1). Provides access to properties and methods exposed by an<br>
Automation object.<br>
IRePositorvDispatch Method get_Properties<br>
Description<br>
Retrieves the IReposProperties interface pointer. The rReposProperties interface provides access to the Properties collection.<br>
IManapeRepnsTypeLib Method    Description<br>
CreateTypeLib	Creates a repository type library for a new tool<br>
information model.<br>
Collections<br>
Collection	Inscription<br>
ReposTypeLibs	The collection of repository type libraries that are currently<br>
stored in the repository.<br>
3.7      INamedObject interface<br>
Normally, a name is associated with a repository object via a naming relationship. The collection for such a relationship provides the scope for the name, and can require that all names in the collection be unique. This is the preferred method for naming objects, when a given object will be the destination of only one naming relationship.<br><br>
If your tool information model contains a class that is not the destination of a naming relationship type, or is the destination of multiple relationship types, but no single relationship type is the obvious choice to be the naming relationship type, then you can attach the name property to the class. This is accomplished by defining your class to implement the INamedObject interface. If your class implements the INamedObject interface, the repository engine will use that interface when asked to retrieve or set an object name.<br>
When to Use<br>
Use the INamedObject interface to access the Name property of a repository object that exposes this interface.<br>
Properties<br><br>
Property	Description<br>
Name	The name of the object.<br>
Methods<br>
IUnknown Method	Description<br>
Querylnterface	Returns pointers to supported interfaces.<br>
AddRef	Increments the reference count.<br>
Release	Decrements the reference count.<br>
TDispatch Method	Description<br>
GetIDsOsOfNam.es	Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers.<br>
GetTypelnfo	Retrieves a type information object, which can be used to get<br>
the type information for an interface.<br>
GetTypelnfoCount	Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1).<br>
Invoke	Provides access to properties and methods exposed by an<br>
Automation object.<br>
IReposiroryDispatch Method	Description<br>
get_Properties	Retrieves the IReposProperties interface pointer. The<br>
ReposProperties interface provides access to the persistent members exposed by the INamedObject interface.<br>
Remarks<br>
None of the standard repository engine or Type Information Model classes implement the INamedObject interface. However, the repository engine does use the INamedObject interface, if it is exposed by a repository object.<br>
When the IRepositoryItem::get_Name method is invoked for a repository object, the repository engine will perform these steps to retrieve the name:<br>
1.        If the object exposes the INamedObject interface, the repository engine returns the value of the Name property.<br><br>
2.	Otherwise, the repository engine searches for a naming relationship for which the current object is the destination object.<br>
3.	If such a relationship is found, the repository engine returns the name associated with that relationship.<br>
4.	If the object is not the destination of a naming relationship, then the repository engine returns a null name.<br>
When the IRepositoryItem::put_Name method is invoked for a repository object, the repository engine will perform these steps to set the name:<br>
1.	The repository engine sets the value of the Name property of all naming relationships for which the object is the destination.<br>
2.	If the object exposes the INamedObject interface, the repository engine also sets the value of the Name property attached to that interface.<br><br>
3.8      IPropertyDef Interface<br>
A property definition object specifies the characteristics of a particular type of property. These characteristics are defined by the properties of the property definition object To create a new property definition:<br>
1.	Use the CreatePropertyDef method of the IlnterfaceDef interface.<br>
2.	Define any non-default characteristics of your new property definition by manipulating the properties of the property definition object.<br>
3.	Commit your changes to the repository database.<br>
When to Use<br>
Use the IPropertyDef interface to retrieve or modify the characteristics of a property definition.<br><br>
Properties Property APIType ColumnName Flags SQLScale<br>
SQLSize SQLType<br><br>
Description<br>
The C data type of the property.<br>
The name of the column in the SQL table for this property.<br>
Specifies details about the property.<br>
The number of digits to the right of the decimal point for a<br>
numeric property. The size in bytes of the property. The SQL data type of the property.<br><br><br><br>
Methods TUnknown Method Querylnterface AddRef Release<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br><br><br><br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br><br>
Description<br>
Maps a single member and a set of argument names to a corresponding set of dispatch identifiers.<br>
Retrieves a type information object, which can be used to get the type information for an interface.<br><br>
GetTypelnfoCount	Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1).<br>
Invoke	Provides access to properties and methods exposed by an<br>
Automation object.<br>
IRepositoryDispatch Method	Description<br>
get_Properties	Retrieves the IReposProperties interface pointer. The<br>
IReposProperties interface provides access to the Properties collection.<br><br>
(.9      IRelationship Interface<br>
A relationship connects two repository objects in the repository database. A relationship has an origin, repository object, a destination repository object, and a set of properties. Each relationship conforms to a particular relationship type.<br>
When to Use<br>
Use the IRelationship Interface to manipulate a relationship, or to retrieve the source, target origin, or destination object for a relationship.<br><br>
Methods ITnknown Method Querylnterface AddRef Release<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br><br><br><br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br><br>
Description<br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get<br>
the type information for an interface. Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1). Provides access to properties and methods exposed by an<br>
Automation object.<br><br><br><br>
TRepositorvDispatch Method get_Properties<br><br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposProperties interface provides access to the Properties collection.<br><br>
IRepositoryItem Method	Description<br>
Delete	Deletes a repository item.<br>
get_Interface	Retrieves an interface pointer to the specified item interface.<br>
get_Name	Retrieves the name associated with an item.<br><br>
get_Repository<br>
getJType Lock<br>
putName Refresh<br><br>
Retrieves the Repository interface pointer for an item's open<br>
repository instance. Retrieves the type of an item. Locks the item.<br>
Sets the name associated with an item. Refreshes the cached image of the item.<br><br><br><br>
TRelationship Method<br>
getDestination<br>
getOrigin<br><br>
Description<br>
Retrieves an interface pointer to the destination object. Retrieves an interface pointer to the origin object.<br><br>
get_Source get_Target<br><br>
Retrieves an interface pointer to the source object. Retrieves an interface pointer to the target object.<br><br>
3.10    IRepositoryObject Interface<br>
The IRepositoryObject interface provides methods to manage repository objects.<br><br>
When to Use<br><br>
Use the IRepositoryabject Interface to:<br>
•	Retrieve the object identifier or the internal identifier for a repository object.<br>
•	Retrieve a repository object's type or name.<br>
•	Obtain a lock on a repository object.<br>
•	Change the name of a repository obj ect.<br>
•	Refresh the cached image of a repository object.<br>
•	Delete a repository object.<br>
•	Get a pointer to an alternate interface that the object exposes.<br>
•	Get the open repository instance through which the object is accessed.<br><br><br><br>
Methods U In known Method Querylnterface AddRef Release<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br><br><br><br>
IDispatch Method GetlDsOfNames<br>
GetTypeInfo<br>
GetTypeInfoCount<br><br>
Description<br>
Maps a single member and a set of argument names to a corresponding set of dispatch identifiers.<br>
Retrieves a type information object, which can be used to get the type information for an interface.<br>
Retrieves the number of type information interfaces that an object provides (either 0 or 1).<br><br>
[nvoke<br><br>
Provides access to properties and methods exposed by an Automation object.<br><br><br><br>
TRepositon. Dispatch Method get_Properties<br><br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposProperties interface provides access to the Properties collection.<br><br>
TRepositoryltem Method	Description<br>
Delete	Deletes a repository item.<br>
get_Interface	Retrieves an interface pointer to the specified item interface.<br>
get Name	Retrieves the name associated with an item.<br><br>
get_Repository<br>
get_Type Lock<br>
put_Name Refresh<br><br>
Retrieves the Repository interface pointer for an item's open<br>
repository instance. Retrieves the type of an item. Locks the item.<br>
Sets the name associated with an item. Refreshes the cached image of the item.<br><br><br><br>
IRepositorvObiect Method<br>
getlnternallD<br>
get_ObjectID<br><br>
Description<br>
Retrieves the internal identifier for a repository object. Retrieves the object identifier for a repository object.<br><br>
3.11    IReposRoot Interface<br>
The IReposRoot interface is a placeholder interface; it contains no properties, methods, or collections beyond Automation dispatch methods. It is provided as a convenient connection point to the root object. When you create a tool information model, you can attach a relationship collection to this interface that provides a navigational connection to the primary objects of your tool information model.<br>
When to Use<br>
Use the IReposRoot interface as a starting point to navigate to other objects in<br>
the repository.<br><br>
Methods TTfnknown Method Querylnterface AddRef Release<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br><br><br><br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br><br>
Description<br>
Maps a single member and a set of argument names to a corresponding set of dispatch identifiers.<br>
Retrieves a type information object, which can be used to get the type information for an interface.<br><br>
GetTypelnfoCount	Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1).<br>
Invoke	Provides access to properties and methods exposed by an<br>
Automation object.<br>
IRepositorvDispatch Method	Pescription<br>
getJProperties	Retrieves the IReposProperties interface pointer. The<br>
IReposProperties interface provides access to the Properties collection.<br><br>
3.12    IReposTypelnfo Interface<br>
This interface relates class, interface, and relationship definition objects to repository type libraries.<br>
When to Use<br>
Use the IReposTypelnfo interface to:<br>
•	Determine which repository type libraries contain a particular class, interface, or relationship type.<br>
•	Determine what collection types are associated with a particular relationship type.<br><br>
Methods<br>
lUnknown Method Querylnterface AddRef Release<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br><br><br><br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br><br>
Description<br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get<br>
the type information for an interface. Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1). Provides access to properties and methods exposed by an<br>
Automation object.<br><br><br><br>
IRepositoryDispatch Method get_Properties<br><br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposProperties interface provides access to the Properties collection.<br><br>
Collections<br>
Collection	Description<br>
ItemlnCollectians	The origin and destination collection types that are connected<br>
to a relationship definition object.<br>
ReposTypeLibScopes	The collection of repository type libraries that contain a<br>
particular class, interface, or relationship type.<br>
3.13    IReposTypeLib Interface<br>
There is one repository type library for every tool information model contained in the repository. Each tool information model provides a logical grouping of all of the type definitions related to a particular tool (or tool set).<br>
To add a new repository type library to the repository, use the IManageReposTypeLib interface.<br><br>
When to Use<br>
Use the IReposTypeLib interface to:<br>
•	Define new classes, relationship types, and interfaces for a tool information model.<br>
•	Retrieve or modify the global identifier associated with a repository type library.<br>
•	Determine which type definitions are associated with a particular repository type library.<br><br>
Properties<br>
Property TypeLibID<br><br>
Description<br>
The global identifier for the repository type library.<br><br><br><br>
Methods IUnknown Method Querylnterface AddRef Release<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count Decrements the reference count.<br><br><br><br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br><br>
Description<br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get<br>
the type information for an interface. Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1). Provides access to properties and methods exposed by an<br>
Automation object.<br><br><br><br>
IRepositoryDispatch Method get_Properties<br><br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposProperties interface provides access to the Properties collection.<br><br>
IReposTvpeLib Method CreateClassDef CreatelnterfaceDef CreateRelationshipDef<br><br>
Description<br>
Creates a new class definition object. Creates a new interface definition object. Creates a new relationship definition abject.<br><br><br><br>
Collections Collection ReposTypelnfos<br><br>
Description<br>
The collection of all classes, interfaced and relationship types that are defined in the repository type library.<br><br>
ReposTypeLibContexts       The collection of one repository root object that is the context<br>
for the repository type library.<br>
3.14    ISummarylnformation Interface<br>
The Summaryinformation interface maintains Comments and ShortDescription properties for objects that expose this interface.<br>
When to Use<br>
Use the ISummaryinformation interface to access the Comments and ShortDescription properties of a repository object.<br><br>
Properties Property Comments ShortDescription<br><br>
Description<br>
General comments about the object. Brief description of the object.<br><br><br><br>
Methods TUnknown Method Querylnterface AddRef Release<br><br>
Description<br>
Returns pointers to supported interfaces, increments the reference count. Decrements the reference count.<br><br><br><br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br><br>
Description<br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get<br>
the type information for an interface. Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1) Provides access to properties and methods exposed by an<br>
Automation object.<br><br>
IRepositorvDispatch Method	Description<br>
get_Properties	Retrieves the IReposProperties interface pointer. The<br>
IReposProperties interface provides access to the properties exposed by the ISummarylnformation interface.<br>
4.        Repository Relationship Definitions<br>
This chapter describes the relationships contained within the Repository's Type Information Model (TIM).<br>
4.1       UnterfaceDef Relationships<br>
The Class Implements interface relationship connects the IClassDef and IlnterfaceDef interfaces. This relationship is used to define the interfaces that a class implements.<br><br>
The Interface JnheritsFrom Interface relationship is used to identify<br>
interfaces that inherit (are subclassed) from oilier interfaces.<br>
The InterfaceJIasMembers relationship is used to house the interface<br>
members (methods, properties, collections) that are part of an interface.<br>
Interface inherftsFrom_interface<br><br><br>
4.1.1   Interfaces Collection<br>
The collection of all interfaces that are implemented by this class.<br>
Collection Descriptor<br>
Relationship Type Source is Origin<br>
Minimum Collection Size<br>
Maximum Collection Size<br>
Sequenced Collection Deletes Propagated Destinations Named Case Sensitive Names Unique Names<br><br>
Descriptor Value<br>
Class-Implements-Interface<br>
Yes<br>
Zero<br>
Many<br>
No<br>
No<br>
No<br>
Not applicable<br>
Not applicable<br><br><br><br>
Syntax<br><br>
Set variable = object.Interfaces( index)<br><br>
The Interfaces collection syntax has these pads:<br>
Eart	Description<br>
variable	A variable declared as an InterfaceDef object. Receives the specified<br>
interface.<br>
object	An obj ect expression that evaluates to a ClassDef object.<br><br>
index<br><br>
An integer index that identifies which element in the collection is to be addressed. The valid range is from one to the number of elements in the collection. The number of elements in the collection is specified by object.Interfaces.Count.<br><br><br><br>
4.1.2   Classes Collection<br>
This collection specifies which classes implement the interface.<br>
Collection Descriptor<br>
Relationship Type<br>
Source Is Origin<br>
Minimum Collection Size Maximum Collection Size Sequenced Collection Deletes Propagated Destinations Named Case Sensitive Names Unique Names<br><br>
Descriptor Value<br>
Class-Implements-Interface<br>
No<br>
Zero<br>
Many<br>
No<br>
No<br>
No<br>
Not Applicable<br>
Not Applicable<br><br>
Syntax<br>
Set variable = object.Classes( index)<br>
The Classes collection syntax has these parts:<br>
Earl	Description<br>
variable        _ A variable declared as a ClassDef object. Receives the specified class<br>
definition.<br>
object	An object expression that evaluates to an InterfaceDef object.<br>
index	An integer index that identifies which element in the collection is to be<br>
addressed. The valid range is from one to the number of elements in<br>
the collection. The number of elements in the collection is specified<br>
by object Classes.Count.<br>
4.1.3   Members Collection<br>
This collection specifies which members are attached to the interface.<br><br>
Collection Descriptor	Descriptor Value<br>
Relationship Tvpe	Interface-Has-Members<br>
Source Is Origin	Yes<br>
Minimum Collection Size	Zero<br>
Maximum Collection Size	Many<br>
Sequenced Collection	Yes<br>
Deletes Propagated	Yes<br>
Destinations Named	Yes<br>
Case Sensitive Names	No<br>
Unique Names	Yes<br><br>
Syntax<br>
Set variable = object.Members( index)<br>
The Members collection syntax has these parts:<br>
Part	Descrirtiop<br>
variable	A variable declared as an object. Receives the specified property definition,<br>
method definition, or collection definition.<br>
object	An object expression that evaluates to an InterfaceDef object.<br>
index	An integer index that identifies which element in the collection is to be<br>
addressed. The valid range is from one to the number of elements in<br>
the collection. The number of elements in the collection is specified<br>
by object Members.Count.<br>
4.1.4   Interface Collection<br>
For a particular property, method, or collection definition, the Interface collection specifies which interface exposes a member of this type.<br>
Dispatch Identifier: DISPED Iface (37)<br>
Collection Descriptor	Descriptor Value<br>
Relationship Type	Interface-Has-Members<br>
Source Is Origin	No<br>
Minimum Collection Size	One<br>
Maximum Collection Size	One<br>
Sequenced Collection	Yes<br>
Deletes Propagated	Yes<br>
Destinations Named	Yes<br>
Case Sensitive Names	No<br>
Unique Names	Yes<br>
4.1.5   Ancestor Collection<br>
This collection specifies the one base interface from which this interface derives.<br><br>
Collection Descriptor<br>
Relationship Type Source Is Origin Minimum Collection Size Maximum Collection Size Sequenced Collection<br>
Deletes Propagated<br>
Destinations Named Case Sensitive Names<br><br>
Descriptor Value<br>
Interface-lnheritsFrom-Interface<br>
Yes<br>
One<br>
One<br>
No<br>
No<br>
No<br>
Not applicable<br><br>
Unique Names<br><br>
Not applicable<br><br>
Syntax<br>
Set variable = object Ancestor( index)<br><br>
Eari<br>
variable<br>
object index<br><br>
The Ancestor collection syntax has these parts: Description<br>
A variable declared as an InterfaceDef object. Receives the specified base<br>
interface definition. An object expression that evaluates to an InterfaceDef object. An integer index that identifies which element in the collection is to be<br>
addressed. The valid range is from one to the number of elements in<br><br><br><br>
the collection!<br><br>
The number of elements in the collection is specified<br><br>
by object Andestor.Count<br><br>
4.1.6   Descendants Collection<br>
This collection specifics other interfaces that derive from this interface.<br>
Collection Descriptor<br>
Relationship Type<br>
Source Ts Origin<br>
Minimum Collection Size<br>
Maximum Collection Size Sequenced Collection Deletes Propagated Destinations Named Case Sensitive Names Unique Names<br>
Descriptor Value Interface-lnheritsFrom-Interface<br>
No<br>
Zero<br>
Many<br>
No<br>
No<br>
No<br>
Not applicable<br>
Not applicable<br>
Syntax<br>
Set variable = object.Descendants( index)<br>
The Descendants collection syntax has these parts:<br><br>
i<br><br>
Part	Description<br>
variable	A variable declared as an InterfaceDef object. Receives the specified interface<br>
definition.<br>
object	An object expression that evaluates to an InterfaceDef object.<br>
index	An integer index that identifies which element in the collection is to be<br>
addressed. The valid range is from one to the number of elements in<br>
the collection. The number of elements in the collection is specified<br>
by object .Descendants.Count.<br><br>
4.2      Type Library Relationships<br>
The Container•_ ContextForReposTypeLibs relationship connects the IManageReposTypeLib and IReposTypeLib interfaces and identifies the type libraries contained within a type library manager and the type library managers for a particular type library.<br>
The ReposTypeLib_ScopeForReposTypelnfo relationship identifies the type infos (classes, interfaces and relationship types) that are defined within a Repository type library.<br>
The Collection_ Contains Items relationship identifies the two collections that are associated with a given relationship type.<br><br>
4.2.1 ReposTypeLibs Collection<br>
The collection of repository type libraries that are currently stored in the repository. Each repository type library represents a tool information model.<br><br>
Collection Descriptor	Descriptor Value<br>
Relationship Tvpe	TIbManager-ContextFor-ReposTypeLibs<br>
Source Ts Origin	Yes<br>
Minimum Collection Size	Zero<br>
Maximum Collection Size	Many<br>
Sequenced Collection	No<br>
Deletes Propagated	Yes<br>
Destinations Named	Yes<br>
Case Sensitive Names	No<br>
TInique Names	Yes<br>
Syntax<br>
Set variable = object.ReposTypeLibs( index)<br>
The ReposTypeLibs collection syntax has these parts:<br><br>
Part	Description<br>
variable	A variable declared as a ReposTypeLib object. Receives the specified<br>
repository type library.<br>
object	An object expression that evaluates to a ReposRoot object.<br>
index	An integer index that identifies which element in the collection is to be<br>
addressed. The valid range is from one to the number of elements in<br>
the collection. The number of elements in the collection is specified<br>
by object.ReposTypeLibs.Count.<br>
4.2.2   ReposTypeLibContexts Collection<br>
The collection of one repository root that is the context for a repository type library.<br>
Collection Descriptor	Descriptor Value<br>
Relationship Type	TIbManager-ContextFor-ReposTypeLibs<br>
Source Is Origin	No<br>
Minimum Collection Size	One<br>
Maximum Collection Size	Many<br>
Sequenced Collection	No<br>
Deletes Propagated	Yes<br>
Destinations Named	Yes<br>
Case Sensitive Names	No<br>
Unique Names	Yes<br>
Syntax<br>
Set variable object.ReposTypeLibContexts( index)<br>
The ReposTypeLibContexts collection syntax has these parts: Part Description<br>
variable	A variable declared as a ReposRoot object. Receives the repository root<br>
object.<br>
object	An object expression that evaluates to a ReposTypeLib object.<br><br>
index	An integer index that identifies which element in the collection is to be<br>
addressed. The valid range is from one to the number of elements in the collection. The number of elements in the collection is specified by object.ReposTypeLibContexts.COunt.<br>
4.2.3   ReposTypelnfos Collection<br>
The collection of all classes, interfaces, and relationship types that are associated with a repository type Ubrary. The repository engine uses this collection to enforce the unique naming of all classes, interfaces, and relationship types for a repository type library.<br>
Collection Descriptor	Descriptor Value<br>
Relationship Type	ReposTypeLib-ScopeFor-ReposTypelnfo<br>
Source Ts Origin	Yes<br>
Minimum Collection Size	Zero<br><br>
Maximum Collection Size	Many<br>
Sequenced Col1ection	No<br>
Deletes Propagated	Yes<br>
Destinations Named	Yes<br>
Case Sensitive Names	No<br>
Unique Names	Yes<br>
Syntax<br>
Set variable = object.ReposTypeInfos( index)<br>
The ReposTypelnfos collection syntax has these pads:<br>
Part	Description<br>
variable	A variable declared as an Object. Receives the specified class definition,<br>
interface definition, or relationship definition.<br>
object	An object expression that evaluates to a ReposTypeLib object.<br>
index	An integer index that identifies which element in the collection is to be<br>
addressed. The valid range is from one to the number of elements in<br>
the collection. The number of elements in the collection is specified<br>
by object.ReposTypelnfos.Count.<br>
4.2.4   ReposTypeLibScopes Collection<br>
The collection of repository type libraries that contain this definition.<br>
Collection Descriptor	Descriptor Value<br>
Relationship Type	ReposTypeLib-ScopeFor-ReposTypelnfO<br>
Source Is Origin	No<br>
Minimum Collection Size	One<br>
Maximum Collection Size	Many<br>
Sequenced Collection	No<br>
Deletes Propagated	Yes<br>
Destinations Named	Yes<br>
Case Sensitive Names	No<br>
Unique Names	Yes<br><br>
Syntax<br>
Set variable = object ReposTypeLibScopes( index)<br>
The ReposTypeLibScopes collection syntax has these parts:<br>
Fart	Description<br>
variable	A variable declared as a ReposTypeLib object. Receives the specified<br>
repository type library object.<br><br>
object	An object expression that evaluates to an InterfaceDef object.<br>
index	An integer index that identifies which element in the collection is to be<br>
addressed. The valid range is from one to the number of elements in the collection. The number of elements in the collection is specified by object.TypeLibScopes.Count.<br>
4.2.5   ItemlnCollection Collection<br>
A relationship type is associated with two collection types. Origin collections conform to one collection type (the origin collection type), and destination collections conform to the other collection type (the destination collection type). The ItemlnCoUections collection contains the two collection definition objects that represent the origin and destination collection types.<br>
Collection Descriptor	Descriptor Value<br>
Relationship Type	Collection-Contains-Items<br>
Source os is Origin	No<br>
Minimum Collection Size	Zero<br>
Mavimnm Collection Size	Two<br>
SequencedCollection	No<br>
Deletes Propagated	No<br>
Destinations Named	No<br>
Case Sensitive Names	Not applicable<br>
Unique Names	Not applicable<br>
Syntax<br>
Set variable = object ItemlnCollections( index)<br>
The ItemlnCoUections collection syntax has these parts:<br>
Part	Description<br>
variable	A variable declared as a CollectionDef object. Receives the specified<br>
collection definition.<br>
object	An object expression that evaluates to a RelationshipDef obj ect.<br><br>
index	An integer index that identifies which element in the collection is to be<br>
addressed. The valid range is from one to the number of elements in the collection. The number of elements in the collection is specified by object ItemlnCollectionsCount.<br>
Remarks<br>
If the relationship type has not yet been connected to its origin and destination collection types, then this collection can contain less than two collection types.<br>
4.2.6   Collectionltem Collection<br>
The collection of one relationship type that defines the relationship between<br>
target objects of this type of collection and a single source object.<br>
Collection Descriptor	Descriptor Value<br><br>
Relationship Type<br>
Source ig Qrigin<br>
Minimum Collection Size Maximum Collection Size Sequenced Collection Deletes Propagated Destinations Named<br>
Cage Sensitive Names<br>
Unique Names<br><br>
Collection-Contains-Items<br>
Yes<br>
Zero<br>
One<br>
No<br>
No<br>
No<br>
Not applicable<br>
Not applicable<br><br>
Syntax<br>
Set variable *= object.CollectionItem( index)<br>
The Collectionitem collection syntax has these parts:<br>
Part	Description<br>
variable	A variable declared as a RelationshipDef object. Receives the specified<br>
relationship definition object.<br>
object	An object expression that evaluates to a CollectionDef object.<br>
index	An integer index that identifies which element in the collection is to be<br>
addressed. The valid range is from one to the number of elements in<br>
the collection. The number of elements in the collection is specified<br>
by object CollectionItem.Count.<br>
5.        Base-TIM Information Model<br>
A new type information model Base-TIM has been added to the Microsoft Repository to.handle the additional metadata definitions that the Type Information Model as defined by Microsoft and described in the previous chapters does not handle.<br>
The following chapters describe the various classes, interfaces and relationships that have been defined for the Base-TIM model.<br>
6.        Added Classes<br>
The following classes have been defined for the Base-TIM information model in the Repository:<br><br>
•	ArgumentDef<br>
•	SemanticDef<br>
•	UnitsOfMeasureDef<br>
6.1      ArgumentDef Class<br>
The ArgumentDef class is used to define the arguments for a semantic. The arguments for a semantic are the interfaces that are needed by the semantic for its processing.<br><br>
The interfaces for a semantic are identified by a relationship/collection on the ctive entity. When a semantic is processed, these interfaces are loaded into an array of structures which is passed as an argument to the appropriate semantic method (e.g. Evaluate). The cardinality of the collection on the active entity determines the number of entries that a particular "argument" consumes in this array. For example a to-one relationship (which has a collection with a cardinality of one) will consume one spot in this array whereas a to-many relationship will consume n slots where n is the number of connected interfaces for that relationship.<br>
When to Use<br>
Use the ArgumentDef class to add arguments to or delete arguments from a semantic.<br><br>
6.2      SemanticDef Class<br>
The SemanticDef class is used to define the existence of a compute, copy or delete semantic and to identify the active entity for that semantic and the arguments to that semantic. The SemanticDef class implements the ISemanticDef interface which is tied to the IHoIDsemantic interface for the active entity. The ISemanticDef interface is also tied to the IHaveArguments interface which is used to identify the arguments to the semantic.<br>
When to Use<br>
Use the SemanticDef class to access or modify semantic definitions.<br><br><br>
6.3      UnitsOfMeasureDef Class<br>
The UnitsOfMeasureDef class is used to define the units of measure domains that can be apphed to properties with units of measure.<br>
When to Use<br>
Use the UnitsOfMeasureDef class to access or modify units of measure domain definitions.<br><br><br>
Added Interfaces<br>
The following interfaces have been defined for the BASE-TIM model: IHaveArguments IHoldSemantic IJAggregate IJCodeSet IJCodeSetlnterface IJImply IJInterfacelnfos rfProperty2 IJRelationshipType IManageDelete IUserType IJUOMDomain ISemantic<br>
All of these interfaces are Repository-supported interfaces with only properties and/or collections that are inherently supported by the Repository machine.<br>
7.1      IHaveArguments Interface<br>
The IHaveArguments interface is used to add an argument to a semantic.<br>
When to Use<br>
Use the IHaveArguments interface to add an argument to a semantic or delete an argument from a semantic.<br><br>
Properties<br>
Property	Description<br>
the_type_of_the_argument The type of the argument (input, output, constrained)<br>
the_type_of_the_Relship     The GUID for the relationship<br>
Indirect__Argument	In case the interface that is argument of the semantic is not the<br>
destination of the relationship, this property contains the<br>
IID of the argument interface.<br><br>
Methods<br><br>
lUnknown Method Querylnterface AddRef Release<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br><br><br><br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br><br>
Description<br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get<br>
the type information for an interface. Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1). Provides access to properties and methods exposed by an<br>
Automation object.<br><br>
IRepositoryDispatch Method Description<br>
get_Properties	Retrieves the IReposProperties interface pointer. The<br>
IReposProperties interface provides access to the<br>
Properties collection.<br><br>
Collections Collection<br>
SemanticForArg<br><br>
Description<br>
The collection of the one semantic to which this argument is tied<br><br>
7.2      IHoldSemantic Interface<br>
The IHoldSemantic interface is used to identify the interface that is the active entity for a semantic.<br>
When to Use<br>
Use the IHoldsemantic interface to define the interface that is the active entity<br>
for a semantic.<br><br>
Methods IUnknown Method Querylnterface AddRef Release<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br><br><br><br>
IDispatch Method GetlDsOfNames<br><br>
Description<br>
Maps a single member and a set of argument names to a corresponding set of dispatch identifiers.<br><br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br><br>
Retrieves a type information object, which can be used to get<br>
the type information for an interface. Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1). Provides access to properties and methods exposed by an<br>
Automation object.<br><br>
TRepositorvDispatch Method	Description<br>
get_Properties	Retrieves the IReposProperties interface pointer. The<br>
IReposProperties interface provides access to the<br>
Properties collection.<br>
Collections<br>
Collection	Description<br>
Semantics	The collection of semantics for which this interface is the active<br>
entity The IHoldsemantic interface is added to the InterfaceDef class to indicate that any interface can potentially be the active entity for a semantic.<br><br>
7.3      IJAggregate Interface<br>
The IJAggregate interface is used to establish an aggregation relationship between classes.<br><br>
When to Use<br>
Use the UAggregate interface to define that a class aggregates another class.<br><br>
Properties Property AggregationType<br><br>
Description<br>
The type of aggregation (Aggregation, Containment)<br><br>
Methods<br>
IUnknown Method	Description<br>
Querylnterface	Returns pointers to supported interfaces.<br>
AddRef	Increments the reference count.<br>
Release	Decrements the reference count.<br><br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br><br>
Description<br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get<br>
the type information   for an interface. Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1). Provides access to properties and methods exposed by an<br>
Automation object.<br><br>
IRepositoryDispatch Method	Description<br>
get_Properties	Retrieves the IReposF'roperties interface pointer. The<br>
IReposProperties interface provides access to the<br>
Properties collection -<br><br>
Collections Collection Aggregates AggregatedBy<br><br>
Description<br>
The collection of classes that this class aggregates The collection of classes that that aggregate this class<br><br>
The UAggregate interface has been added to the ClassDef class. This allows any class to aggregate other classes or be aggregated by other classes.<br><br><br><br>
7.4      IJCodeSet Interface<br>
The IJCodeSet interface is used to identify properties whose values are defined by entries in another class/interface. A code set property is differentiated from a relationship between two interfaces by the fact that the pointer is one directional (from the property in the one class to the other interface) and there are no semantics associated with the pointer.<br>
When to Use<br>
Use the IJCodeSet interface to define or modify the code set characteristics of<br>
a property.<br><br>
Properties Property Name<br>
FilterCriteria<br><br>
Description<br>
The name of the property in the related interface that is to be<br>
displayed as the value for this property The filter criteria to be applied to the instances to come up with<br>
the set of possible values for the property<br><br><br><br>
Methods IUnknown Method Querylnterface AddRef<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count.<br><br>
Release<br><br>
Decrements the reference count.<br><br>
IDispatch Method	Description<br><br>
etEDsOfNames GetTypelnfo GetTypelnfoCount Invoke<br><br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get<br>
the type information for an interface. Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1) Provides access to properties and methods exposed by an<br>
Automation object.<br><br>
IRepositorvDispatch Method	Description<br>
get_Properties	Retrieves the IReposProperties interface pointer. The<br>
ReposProperties interface provides access to the<br>
Properties collection.<br><br>
Collections<br>
Collection CodeSetlnterface<br><br>
Description<br>
The collection of one interface that identifies the type of objects in the code set<br><br>
The IJCodeSet interface has been added to the Microsoft-defined PropertyDef class definition. This allows any property definition to use a code set definition.<br><br><br>
7.5      UCodeSetlnterface Interface<br>
The IJCodeSetlnterface interface is used to identify an interface definition as containing the set of possible values (code set) for a property definitions). Normally, the manipulation of the relationship between all interface definition used as a code set and a property is done from the PropertyDef object using the IJCodeSet interface.<br><br>
Methods IUnknown Method Querylnterface AddRef Release<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br><br><br><br>
IDispatch Method GeODsOfNames<br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br><br>
Description<br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get<br>
the type information for an interface. Retrieves the number of type information interfaces that an<br>
object provides (either 0 or 1). Provides access to properties and methods exposed by an<br>
Automation object.<br><br>
IRepositorvDispatch Method	Description<br>
get_Properties	Retrieves the IReposProperties interface pointer. The<br>
IReposProperties interface provides access to the<br>
Properties collection.<br>
Collections<br>
Collection	Description<br>
PropertiesForCodeSet	The collection of properties using this interface as a code set<br>
The IJCodeSet interface has been added to the Microsoft-defined InterfaceDef class definition. This allows any interface definition to be used as a code set.<br><br><br><br>
7.6      IJImply Interface<br>
The IJImply interface is used for identifying interfaces that are implied by       other interfaces.<br>
When to Use<br>
Use the IJImply interface to define that an interface implies another interface.<br><br>
Methods<br>
IUnkPOwn Method<br>
Queryinterface<br>
AddRef<br>
Release<br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
GetTypeinfoCount<br>
Invoke<br><br>
Pescription<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br>
Description<br>
Maps a single member and a set of argument names to a corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get the type information for an interface. Retrieves the number of type information interfaces that an object provides (either 0 or 1) Provides access to properties and methods exposed by an Automation object.<br><br>
IRepositorvDispatch Method      Description<br>
getProperties	Retrieves the IReposProperties interface pointer. The<br>
IReposProperties interface provides access to the<br>
Properties collection.<br><br>
Collections<br>
Collection Implies<br>
ImpliedBy<br><br>
Description<br>
The collection of interfaces that this interface implies<br>
The collection of interfaces that imply this interface The Dimply interface has been added to the InterfaceDef class to indicate<br><br>
that any interface can imply another interface or be implied by another interface.<br><br>
7.7      IJInterfaceinfos Interface<br>
The is used to store informations about interfaces in the context of user attributes.<br>
When to Use<br>
Use when an interface is a collection of attributes.<br><br>
Properties<br><br>
Property<br>
UserName<br>
Jflag<br>
Methods<br>
IUnknown Method<br>
Querymterface<br>
AddRef<br>
Release<br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br>
IRepositorvDispatch Method get_Properties<br><br>
Description<br>
Display name for a collection of attributes (not used)<br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br>
Description<br>
Maps a single member and a set of argument names to a corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get the type information for an interface. Retrieves the number of type information interfaces that an object provides (either 0 or 1). Provides access to properties and methods exposed by an Automation object.<br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposProperties interface provides access to the Properties collection.<br><br><br><br>
Collections Collection<br><br>
Description<br><br><br><br>
7.8      IJProperty Interface<br>
The IJPropery2 interface contains additional attribute metadata beyond what is supported by the IPropertyDef interface.<br>
When to Use<br>
Use the IJProperty2 interface to do the following:<br>
•	define or modify any of the metadata properties accessible through this interface<br>
•	identify that an attribute uses a particular units of measure<br>
•	identify that an attribute is the same as another attribute. This can only be set if an attribute is not persistent.<br><br>
Properties<br>
Property OnPropertyPage<br>
SpecificUnitsOfMeasure<br>
UserName UnitsType<br><br>
Description<br>
Indicates whether the attribute will appear on a<br>
property page<br>
Indicates whether an attribute has a specific units of<br>
measure (e.g. ft). This value should only be set if the<br>
attribute is also tied to a units of measure type (not<br>
used)<br>
Display name of the attribute<br>
Type of units for this property<br><br>
PrimaryUnits	Default primary display units for this property<br>
PecondaryUnits	Default secondary display units for this property<br>
TertiaryUnits	Default tertiary display units for this property<br>
deList	Table number for code listed attributes (-1 if not)<br><br>
ReadOnly	Indicate if the value of this attribute can be set<br><br>
Methods IUnknown Method<br>
Querylnterface AddRef Release<br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
information for an interface. GetTypelnfoCount<br>
Invoke<br>
IRepositoryDispatch Method get_Properties<br><br>
Description<br>
Returns pointers to supported interfaces.<br>
Increments the reference count.<br>
Decrements the reference, count.<br>
Description<br>
Maps a single member and a set of argument names to<br>
a corresponding set of dispatch identifiers.<br>
Retrieves a type infonnation object, which can be used<br>
to get the type<br>
Retrieves the number of type information interfaces<br>
that an object provides (either 0 or 1).<br>
Provides access to properties and methods exposed by<br>
an Automation object.<br>
Description<br>
Retrieves the IReposProperties interface pointer. The<br>
IReposProperties interface provides access to the<br>
Properties collection.<br><br>
Collections<br><br>
Collection<br>
UnitsOfMeasure<br>
Same As AreSame<br><br>
Description<br>
The collection of at most one unit of measure that<br>
applies to this attribute<br>
The collection of at most one property for which this<br>
attribute is the same attribute<br>
The collection of properties that are the same as this<br>
one<br><br>
The IJProperty2 interface has been added to the PropertyDef class to allow the definition of the additional metadata for any attribute/property.<br><br><br><br>
7.9      IJRelationshipType Interface<br>
IJRelationshiptype interface is used to store the QUID associated to an interface type.<br>
When to Use<br><br>
Properties<br>
Property<br>
RelationshipTypeGUlD<br>
Methods<br>
IUnknown Method Querylnterface AddRef Release<br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
GetTypelnfoCount<br><br>
Description<br>
GUID<br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br>
Description<br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers.<br>
Retrieves a type information object, which can be used<br>
to get the type information for an interface.<br>
Retrieves the number of type information interfaces that<br>
an object provides (either 0 or 1).<br><br>
Invoke	Provides access to properties and methods exposed by<br>
an Automation object.<br><br>
IRepositoryDispatch<br>
Method.<br>
get_Properties<br><br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposProperties interface provides access to the Properties collection.<br><br><br><br>
Collections Collection<br><br>
Description<br><br><br><br><br><br>
7.10  IManageDelete Interface<br>
The IManageDelete interface contains additional information about the propagation of the delete associated to a relationship.<br>
When to Use<br>
Use the IManageDelete interface to define a delete behavior of a relationship.<br><br>
Properties<br>
Property Delete Forward<br>
DeleteJBackward DisconnectionProgID<br><br>
Description<br>
Flag for the forward delete behavior. The possible<br>
values are PROPAGATE, NO_PROPAGATE or<br>
PROPAGATE_CONDITIONAL.<br>
Flag for the forward delete behavior.<br>
ProgID of a semantic to fire when a relationship of this<br>
type is deleted.<br><br>
Methods<br><br>
ITInknown Method Querylnterface AddRef Release<br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
GetTypelnfoCount<br>
Invoke<br>
IRepositorvDispfltch<br>
Method<br>
get_Properties<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br>
Description<br>
Maps a single member and a set of argument names to a<br>
corresponding set of dispatch identifiers.<br>
Retrieves a type information object, which can be used<br>
to get the type information for an interface.<br>
Retrieves the number of type information interfaces that<br>
an object provides (either 0 or 1).<br>
Provides access to properties and methods exposed by<br>
an Automation object.<br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposProperties interface provides access to the Properties collection.<br><br><br><br>
Collections<br>
Collection<br><br>
Description<br><br><br>
7,11    IUserType Interface<br>
The IJUserType to modify the definition of a class and create a user defined class.<br>
When to Use<br><br>
Use the UUserType interface to define a semantic a user type.<br>
Properties<br><br>
Property RootCLSID<br><br>
Description<br>
OLSID of the class that is used as a server for this codeless class.<br><br>
Methods<br><br>
Illnknown Method Querylnterface AddRef Release<br>
IPispatch Method GetlDsOfNames<br>
GetTypelnfo<br>
GetTypelttfoCount<br>
Invoke<br>
IRepositoryDisoatch Method get_Properties<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br>
Description<br>
Maps a single member and a set of argument names to a corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get the type information for an interface. Retrieves the number of type information interfaces that an object provides (either 0 or 1). Provides access to properties and methods exposed by an Automation object.<br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposProperties interface provides access to the Properties collection.<br><br><br><br>
Collections Collection<br><br>
Description<br><br><br><br>
7.12    ISemantiC Interface<br>
The ISemantic interface is used to define a semantic and tie it to its active entity and its arguments.<br>
When to Use<br>
Use the Semantic interface to define a semantic and to relate that semantic to its active entity and to its arguments (i.e. the interfaces that are input, output and/or constrained by the semantic)<br><br>
Properties<br>
Property Type<br>
SticProglfl SolverPraglD<br>
Methods<br><br>
Description<br>
Type of the semantic (Compute, Copy, Delete) ProgiD of the class that implements the semantic ProgID of the class that implements the solver<br><br><br><br>
IUnknown Method Querylntefface AddRef Release<br>
IDispatch Method GetlDsOfNames<br>
GetTypelnfo<br><br>
Description<br>
Returns pointers to supported interfaces. Increments the reference count. Decrements the reference count.<br>
Description<br>
Maps a single member and a set of argument names to a corresponding set of dispatch identifiers. Retrieves a type information object, which can be used to get the type information for an interface.<br><br>
elnfbCount<br>
invoice<br>
IRepositorvDispatch Method get_Properties<br><br>
Retrieves the number of type information interfaces that an object provides (eitherOor 1). Provides access to properties and methods exposed by an Automation object.<br>
Description<br>
Retrieves the IReposProperties interface pointer. The IReposProperties interface provides access to the Properties collection.<br><br>
Collections<br><br>
Collection<br>
Arguments<br>
ActiveEntity<br><br>
Description<br>
The collection of arguments to the semantic<br>
The collection of one interface that is the active entity<br>
for the semantic<br><br>
8.        Added Relationships<br>
8.1      Semantic Relationships<br>
The Interface IsActiveEntityFor_Semantics relationship has been added to the metadata model to identify the active entity" for a semantic (the InrerfaceDef corresponding to the IHoldSemantic) and to connect that active entity to its semantic definition.<br>
The Semantic Has_Arguments relationship is used to connect a semantic with the definition of its input, output and constraint arguments (i.e. the connected interfaces that play a role in the semantic).<br><br><br>
8.1.1   Semantics Collection<br>
This collection specifies which semantics use this interface as the active entity.<br>
Collection Descriptor	Descriptor Value<br>
Relationship Type	Interface-IsActiveEntityFor-Semantics<br><br>
Source Is Origin	Yes<br>
Minimum Collection Size	Zero<br>
Maximum Collection Size	Many<br>
Sequenced Collection	No?<br>
Deletes Propagated	No<br>
Destinations Named	No<br>
Case Sensitive Names	Not Applicable<br>
Unique Names	Not Applicable<br>
Syntax<br>
Set varible = object.Semantics(index)<br>
The Semantics collection syntax has these parts:<br>
Part	Description<br>
variable	A variable declared as a SemanticDef object.<br>
Receives the specified semantic definition.<br>
object	An object expression that evaluates to an<br>
InterfaceDef object<br>
index	An integer index that identifies which element in<br>
the collection is to be addressed. The valid range is from pne to the number of elements in the collection. The number elements in the collection is specified by object.Semantics.Count.<br>
8.1.2   ActiveEntity Collection<br>
This collection of one interface which is the active entity for the semantic.<br>
Collection Descriptor	Descriptor Value<br>
Relationship Type	Interface-IsActiveEntityFor-Semantics<br>
Source Is Origin	No<br>
Minimum Collection Size	One<br>
Maximum Collection Size	One<br>
Sequenced Collection	No<br>
Deletes Propagated	No<br>
Destinations Named	No<br>
Case Sensitive Names	Not Applicable<br>
Unique Names	Not Applicable<br>
Syntax<br>
Set variable = object. ActiveEntity (index)<br>
The ActiveEntity collection syntax has these parts:<br>
Part	Description<br><br>
variable	A variable declared as an InterfaceDef object.<br>
Receives the specified interface definition.<br>
object	An object expression that evaluates to an<br>
SemanticDef object.<br>
index	An integer index that identifies which element in<br>
the collection is to be addressed. The valid range is from one to the number of elements in the collection. The number of elements in the collection is one.<br>
8.1.3	Arguments Collection<br>
This collection specifies the arguments to the semantic.<br>
Collection Descriptor	Descriptor Value<br>
Relationship Type	Semantic-Has-Arguments<br>
Source Ts Origin	Yes<br>
Minimum Collection Size	One<br>
Maximum Collection Size	Many<br>
	Sequenced Collection	Yes<br>
Deletes Propagated	No<br>
Destinations Named	No<br>
Case Sensitive Names	Not Applicable<br>
Unique Names	Not Applicable<br>
Syntax<br>
Set variable - object.Argumtntsf index)<br>
The Arguments collection syntax has these parts:<br>
Part	Description<br>
variable	A variable declared as a InterfaceDef object.<br>
Receives the specified interface definition.<br>
object	An object expression that evaluates to an<br>
SemanticDef object.<br>
index	An integer index that identifies which element in<br>
the collection is to be addressed. The valid range is from one to the number of elements in the collection. The number of elements in the collection is specified by object.Arguments.Count.<br>
8.1.4	SemanticForArg Collection<br>
This collection of one semantic for which this interface argument is an argument.<br>
Collection Descriptor	Descriptor Value<br>
Relationship Type	Semantic-Has-Arguments<br>
Source is Origin	No<br>
Minimum Collection Size	One<br>
Maximum Collection Size	One<br>
Sequenced Collection	No<br><br>
Deletes Propagated<br>
Destinations Named<br>
Case Sensitive Names Unique Names<br>
Syntax<br><br>
No<br>
No<br>
Not Applicable<br>
Not Applicable<br><br>
Set variable = object. SemanticForArg( index)<br>
The SemanticForArg collection syntax has these parts:<br>
Part	Description<br>
variable	A variable declared as a SemanticDef object.<br>
Receives the specified semantic definition.<br>
object	An object expression that evaluates to an<br>
ArgumentDef obj ect<br>
index	An integer index that identifies which element in the<br>
collection is to be addressed. The valid range is from one to the number of elements in the collection. The number of elements in the collection is one.<br>
8.2      Aggregation Relationship<br>
To support aggregation a Class Aggregates _Classes relationship has been created<br>
Cfass_Aggregates_ Classes<br>
+Aggregates<br>
IJAggregate<br>
+AggregatedBy<br>
and its IJAggregate interface added to the Microsoft-defined ClassDef class.<br>
8.2.1   Aggregates Collection<br>
This collection specifies the classes that this class aggregates.<br><br>
Collection Descriptor<br>
Relationship Type Source Is Origin Minimum Collection Size Maximum Collection Size<br>
Sequenced Collection<br>
Deletes Propagated Destinations Named Case Sensitive Names<br>
Descriptor Value<br>
Class-Aggregates-Classes<br>
Yes<br>
Zero<br>
Many<br>
Yes<br>
No<br>
No<br>
Not Applicable<br><br>
Unique Names	Not Applicable<br>
Syntax<br>
Set variable = object. Aggregates^ index)<br>
The Aggregates collection syntax has these parts:<br>
Earl	Description<br>
variable	A. variable declared as a ClassDef object. Receives the<br>
specified class definition.<br>
object	An object expression that evaluates to a ClassDef<br>
object.<br>
index	An integer index that identifies which element in the<br>
collection is to be addressed. The valid range is from one to the number of elements in the collection. The number of elements in the collection is defined by object. Aggregates.Count.<br>
8.2.2   AggregatedBy Collection<br>
This collection of one semantic for which this interface argument is an argument.<br>
Collection Descriptor	Descriptor Value<br>
Relationship Type	Class-Aggregates-Classes<br>
Source Is Origin	No<br>
Minimum Collection Size	Zero<br>
Maximum Collection Size	Many<br>
Sequenced Collection	No<br>
Deletes Propagated	No<br>
Destinations Named	No<br>
Case Sensitive Names	Not Applicable<br>
Uniqvte Names	Not Applicable<br>
Syntax<br>
Set variable = object. AggregatedBy( index)<br>
The AggregatedBy collection syntax has these parts:<br>
Part	Descriptiop<br>
variable	A variable declared as a ClassDef object. Receives<br>
the specified class definition.<br>
object	An object expression that evaluates to a ClassDef<br>
object.<br>
index	An integer index that identifies which element in the<br>
collection is to be addressed. The valid range is from one to the number of elements in the collection. The number of elements in the collection is obj ectAggregatedEyCount.<br><br>
8.3      Imply Relationship<br>
To support an interface implying other interfaces an Interface Implies Interfaces relationship has been created and<br><br><br><br>
its Ulmply interface added to the InterfaceDef class defined by Microsoft.<br>
8.3.1   Implies Collection<br>
This collection specifies the interfaces that this interface implies.<br><br>
Collection Descriptor Relationship Type Source Is Origin Minimum Collection Size Maximum Collection Size Sequenced Collection Deletes Propagated Destinations Named Case Sensitive Names Unique Names<br>
Syntax<br><br>
Descriptor Value<br>
Interface-Implies-Interfaces<br>
Yes<br>
Zero<br>
Many<br>
No<br>
No<br>
No<br>
Not Applicable<br>
Not Applicable<br><br>
Set variable = object Amplies (index)<br>
The Implies collection syntax has these parts:<br>
fart	Description<br>
variable	A variable declared as an InterfaceDef object. Receives the<br>
specified interface definition.<br>
object	An object expression that evaluates to an InterfaceDef object.<br>
index	An integer index that identifies which element in the collection<br>
is to be addressed. The valid range is from one to the number<br>
of elements in the collection. The number of elements in the<br>
collection is object.Implies.Count<br>
8.3.2   ImpIiedBy Collection<br>
This collection specifies the interfaces that imply this interface.<br><br>
Collection Descriptor<br><br>
Descriptor Value<br><br>
Relationship Type Source Is Origin Minimmn Collection Size Maximum Collection Size Seguencgd Collection Deletes Propagated<br>
Destinations Named<br>
Case Sensitive Names<br>
Unique Names<br><br>
Ihterface-Implies-Interfaces<br>
No<br>
Zero<br>
Many<br>
No<br>
No<br>
No<br>
Not Applicable<br>
Not Applicable<br><br>
Syntax<br>
Set variable = object ImpIiedBy (index)<br>
The ImpliedBy collection syntax has these parts:<br><br>
variable<br>
object<br>
index<br><br>
Description<br>
A variable declared as an Interfaceflef object. Receives the specified interface definition. An object expression that evaluates to an InterfaceDef object.<br>
An integer index that identifies which element in the collection is to be addressed. The valid range is from one to the number of elements in the collection. The number of elements in the collection is object.ImpliedBy.Count.<br><br>
8.4      Property Relationships<br>
The UnitsOfMeasure_ApplyTo_properties relationship is used to define the units of measure for properties that have units of measure.<br>
The PropertyJsBasisForproperties relationship allows a non-persistent property to be defined as being the same as another property. This is particularly useful for properties with units of measure where the property defined as being the same as another property is defined to have specific units of measure (e.g. property diameter_ft is same as property diameter and has specific units of ft).<br><br><br>
8.4.1   SameAs Collection<br>
This collection of at most one specifies the property for which this property is the same.<br><br>
Collection Descriptor<br>
Relationship Type<br>
Source Is Origin<br>
Minimum Collection Size Maximum Collection.Size Seguenced Collection Deletes Propagated Destinations Named<br>
Case Sensitive Names Unique Names<br>
Syntax<br><br>
Descriptor Value<br>
Property-IsBasisFor-Properties<br>
No<br>
Zero<br>
One<br>
No<br>
No<br>
No<br>
Not Applicable<br>
Not Applicable<br><br>
Set variable = object.SameAs( index)<br>
The SameAs collection syntax has these parts:<br>
fart	Description<br>
variable	A variable declared as a PropertyDef object. Receives<br>
the specified property definition.<br>
object	An object expression that evaluates to a PropertyDef<br>
object.<br>
index	An integer index that identifies which element in the<br>
collection is to be addressed. The valid range is from one to the number of elements in the collection. The number of elements in the collection is object.SameAs.Count.<br>
8.4.2   AreSame Collection<br>
This collection specifies the properties that are the same as this property.<br><br>
Collection Descriptor<br>
Relationship Type<br>
Source Is Origin<br>
Minimum Collection Size Maximum Collection Size Sequenced Collection Deletes Propagated Destinations Named<br>
Case Sensitive Names<br>
Unique Names<br><br>
Descriptor Value<br>
Property-IsBasisFor-Properties<br>
Yes<br>
Zero<br>
Many<br>
No<br>
No<br>
No<br>
Not Applicable<br>
Not Applicable<br><br>
Syntax<br>
Set variable = object.AreSame( index)<br>
The AreSame collection syntax has these parts:<br><br>
Part variable<br>
object<br>
index<br><br>
Description<br>
A variable declared as a PropertyDef object.<br>
Receives the specified property definition.<br>
An object expression that evaluates to a PropertyDef<br>
object.<br>
An integer index that identifies which element in tbe<br>
collection is to be addressed. The valid range is from<br>
one to the number of elements in the collection. The<br>
number of elements in the collection is<br>
obj ect. AreSame.Count.<br><br>
8.5<br>
Code Set Relationships<br>
The interface_jsCodeSetFor_Properties relationship couples a property definition to an interface containing possible values for that property. This allows a property to be code-listed.<br><br><br><br>
8.5.1    CodeSetlnterface Collection<br>
This collection of one identifies the interface that a property definition<br>
uses.<br><br>
Collection Descriptor<br>
Relationship Type<br>
Source Is Origin Minimum Collection Size Maximum Collection Size Sequenced Collection Deletes Propagated<br>
Destinations Named<br>
Case Sensitive Names Unique Names<br><br>
Descriptor Value<br>
Interface_IsCodeSetFor Properties<br>
No<br>
Zero<br>
One<br>
No<br>
No<br>
No<br>
Not Applicable<br>
Not Applicable<br><br><br><br>
Syntax<br><br>
Set variable = object.CodeSetlnterface (index)<br>
The CodeSetlnterface collection syntax has these parts:<br><br>
Part	Description<br>
variable	A variable declared as an InterfaceDef obj ect.<br>
Receives the specified class definition.<br>
object	An object expression that evaluates to a PropertyDef<br>
object.<br><br>
index	An integer index that identifies which element in the<br>
collection is to be addressed. The valid range is from one to the number of elements in the collection. The number of elements in the collection is object. CodeSetlnterface.Count.<br>
8.5.2   PropertiesForCodeSet Collection<br>
This collection specifies the properties that use a code set interface.<br>
Collection Descriptor	Descriptor Value<br>
Relationship Type	Interface_IsCodeSetFor Properties<br>
Source Is Origin	Yes<br>
Minimum Collection Size	Zero<br>
Maximum Collection Size	Many<br>
Sequenced Collection	No<br>
Deletes Propagated	No<br>
Destinations Named	No<br>
Case Sensitive Names	Not Applicable<br>
Unique Names	Not Applicable<br>
Syntax<br>
Set variable = object.PropertiesForCodeSetf index,)<br>
The PropertiesForCodeSet collection syntax has these parts<br>
Part	Description<br>
variable	A variable declared as a PropertyDef obj ect.<br>
Receives the specified property definition.<br>
object	An object expression that evaluates to an<br>
InterfaceDef obj ect.<br>
index	An integer index that identifies which element in the<br>
collection is to be addressed. The valid range is from one to the number of elements in the collection. The number of elements in the collection is obj ectPropertiesForCodeSetCount.<br><br>
1.	Introduction<br>
This Appendix discloses additions to the Unified Modelling Language (UML) needed to describe the metadata used to describe one embodiment of the present invention.<br>
2.	Class properties<br>
IGeometry<br>
Below are specific properties defined for UML classes.<br>
•	TypelnRepository — Possible values of"', Interface, Class, or Semantic. A null string represents the default value of unassigned. From here on this property will be referred to as TIR. This property indicates that the UML class represents a repository class, interface or semantic. The export tool will attempt to set the unassigned TIR based on the name of the class. A class starting with "F will have its TIR set to Interface; a class starting with "C" will have its TIR set to Class, and a class starting with "S' will have its TIR set to Semantic, 'the export tool will issue a warning when it sets the TIR based on these starting letters.<br>
•	IsDuallnterface — True or False, True by default. If TIR is interface, a true value indicates the interface is dual and, therefore, inherits from IDispatch. If TIR is not interface, this property is not applicable.<br>
•	IsExtensible — True or False, True by default. If TIR is interface, a true value sets the IsExtensible flag to true for the interface definition in the repository. It is currently unclear what this flag means in the repository. Microsoft has been asked to clarify.<br>
•	IsHidden — True or False, False by default. If TIR is interface, a true value sets the IsHidden falgs to true for the interface definition in the repository. The repository may use this flag to keep the interface hidden from view by automation viewers (e.g. VP object browser)<br>
•	Defaultlnterface — Null string by default. If TIR is class, this string property holds the name of the default interface for the class. The export tool will attempt to set this value by comparing implemented<br><br>
interface names against the class name. An implemented interface with the same name as the class but starting with T' will automatically be used.<br>
•	SemanticType — Possible values of "", Compute, or Copy. A null string represents the default value of unassigned. If TIR is semantic, this string property indicates if the semantic is for compute or copy. The export tool attempts no automatic assignment.<br>
•	SemantieProgID — Null string by default. If TIR is semantic, this string property holds the ProgID of the COM object called by the associativity subsystem to compute or copy objects in a relationship. The export tool attempts no automatic assignment.<br>
•	SolverProgID — Null string by default. If TIR is semantic, this string property holds the ProgID of the COM object called by the associativity subsystem to compute objects in a constraint relationship.<br>
•	GUID — Null string by default. If TIR is class, this string property holds the ClassID of the COM class. If TIR is interface, this string property holds the InterfacelD of the COM interface. The format of the string must match the format" {00000000-0000-0000-0000-000000000000}" as specified by the StringToCLSID Win32 function. The export tool will automatically generate a unique value for this string.<br>
•	ObjectID — Null string by default. If TIR is class or interface, this string property holds the ObjectID of the repository classdef or interfacedef represented by the DML. class. The format of the string must match the format"{ {00000000-0000-0000-0000-000000000000 } ,00000000}" as specified by the repository documentation. The export tool will automatically generate a unique value for this string.<br>
•	TableName — Null string by default. If TIR is interface, this string property holds the Access or SQLServer table name used to store instances of properties on the interface. The export tool will automatically generate a table name based on the interface name.<br><br>
•   UserName — Null string by default. If TIR is interface or class, this a display name used by the attribute helper.<br><br>
•	IsHardCoded — If TIR is interface, true by default, it means that this interface has a real implementation by opposition to a virtual interface just used for relationship connections or codeledd artributes.<br>
•	RootCLSID — If TIR is class, default is NULL, it means that this class is a user type i.e. a specialization of the class Root class.<br>
3.3      Association and Role properties<br><br>
Below are the GSCAD specific properties defined for UML associations. These properties are accessed under the GSCAD tab from the association specification dialog.<br>
•	DeleteForward, DeleteBackward — Possible values of Propagate, DontPropagate, or ConditionalPropagate. The default value is DontPropagate for both properties. These properties indicate the delete propagation rules when deleting a COM object that has relationships to other objects. See GSCAD assoc documentation for more information.<br>
•	DisconnectionProgID — Null string by default. This string property holds the ProgID of a COM object called by the associativity subsystem when a COM object is deleted. The function called is analogous to a destructor function on a C++ object. The export tool allows a null string value and attempts no automatic assignment.<br>
•	RelationshipTypeGUID — Null string by default. This string property holds the type of the repository relationship corresponding to the UML association. The QUID used to represent the type is the same QUID used in the IJAssocRelation::QetCollectionOfRelationsByType method. Previously, the QUID used for the relationship type was extracted from the QUID part of the relationship object id in the repository, this property is now used instead of the QUID part of the object id. The format of the string must match the format" {00000000-0000-0000-0000-000000000000}" as specified by the StringToCLSID<br><br>
Win32 function. The export tool will automatically generate a unique value for this string.<br>
•	ObjectlD — Null string by default. This string property holds the<br>
ObjectID of the repository classdef or interfacedef represented by the<br>
UML class. The format of the string must match the format<br>
"{{00000000-0000-0000-0000-000000000000} ,00000000}" as specified by the repository documentation. The export tool will automatically generate a unique value for this string. Below are the GSCAD specific properties defined for UML roles. These<br>
properties are under the GSCAD A and GSCAD B tabs from the association specification<br>
dialog.<br>
•	Min — Possible values of 0 to infinity (represented by —1). The default value is 0. This string property defines the cardinality of one side the relationship represented by the UML association. The export tool attempts no automatic assignment.<br>
•	Max — Possible values of 0 to infinity (represented by —I). The default value is -I. This string property defines the cardinality of one side the relationship represented by the UML association. The export tool attempts no automatic assignment.<br>
•	IsOrigin — True or False, False by default. A true value defines the role as the origin side of the relationship. Only relationship origins may be named or indexed. The export tool attempts no automatic assignment.<br>
•	IsNaming — True or False, False by default. A true value indicates the origin side of the relationship supports naming. A true value is only valid if IsOrigin is true. the export tool attempts no automatic assignment.<br>
•	IsUniqueNaming — True or False, False by default. A true value indicates the origin side of the relationship requires only unique names can be given when adding to the relationship. A true value is only valid if IsOrigin and IsNaming are both true, [he export tool attempts no automatic assignment.<br><br>
•   IsCaseSensitive — True or False, False by default. A true value indicates the origin side of the relationship supports case sensitive names. A true value is only valid if IsOrigin and IsNaming are both true. The export tool attempts no automatic assignment.<br><br>
•	PropagateDelete — True or False, False by default. A true value sets the corresponding repository relationshipdef to true. At this time, no GSCAD sub-system uses this flag. The export tool attempts no automatic assignment.<br>
•	IsSequenced — True or False, False by default, A true value indicates the origin side of the relationship supports integer indexing. The export tool attempts no automatic assignment.<br>
•	IsHidden — True or False, False by default. A true value sets the IsHidden flag to true for the relationship definition in the repository. The repository may use this flag to keep the interface hidden from view by automation viewers (e.g. VB object browser). The export tool attempts no automatic assignment.<br>
•	DispID — Null string by default. This string property holds the Dispatch id of the repository collection represented by the UML role. The string must be in the form of a unique integer number. The export tool will automatically generate a unique value for this string.<br>
•	ObjectID — Currently unused.<br>
5.4      Property properties<br><br>
Below are the properties defined for UML class properties. These properties are accessed first by opening the class specification dialog, selecting a property and view its property specification dialog.<br>
•	OnPropertyPage — True or False, True by default. If true, this property must be displayed by the attribute control..<br>
•	UnitsOfMeasure —0 by default. It contains the unit type of the attribute.<br><br>
•	PrimaryUnitsOfMeasure, SecondaryUnitsOfNleasure, TertiaryUnitsOfMeasure —0 by default. It contains the code for the display units.<br>
•	CoIumnName — Null string by default, This string property holds the Dispatch id of the repository collection represented by the UML role. The string must be in the form of a unique integer number. The export tool will automatically generate a unique value for this string.<br>
•	DispID) — Null string by default. This string property holds the Dispatch id of the repository property represented by the UML property. The string must be in the form of a unique integer number. The export tool will automatically generate a unique value for this string. This value must match the one defined in the idl if this property has to be displayed by the attribute helper.<br>
•	ObjectID — Currently unused.<br>
•	APIType, SQLType, SQLSize, SQLScale — These properties are automatically set by the tool from the type of the property. The export tool hard codes these properties to SQL_C_STINYrNTJ SQLJTINYINT, I, and 0, respectively.<br>
•	InRepository — True or False, False by default. Indicate whether or not this property must be exported in the meta data.<br>
•	CodeList — NULL by default, give the name of the codelist table if this property is codelisted.<br>
•	Readonly — True or False. False by default, indicate if this property can be modified using the attribute control.<br>
•	UserName - NULL by default, this is Display name used by the attribute control<br>
•	OnPropertyPage — True or False, True by default. Indicate if this property must be displayed by the attribute control.<br><br>
5.5      Generalize property<br><br>
Below is the property defined for UML generalization (inherit) element.<br>
•   AggregateeClass — Null string by default. This string property can contain a UML class name used to disambiguate COM aggregation when a COM class has more than one aggregatee and each aggregatee implements the same interface. The string must contain a valid UML class name. The export tool attempts no automatic assignment.<br>
6.        GSCAD interpretation of UML diagrams<br>
Using UML diagrams in conjunction with GSCAD property settings on UML elements allows the export tool to define the following repository metadata: Interfaces definitions. Interface inheritance. Interface implies interface relationship. Interface scoping rules for associativity. Relationships definitions. Semantics on interfaces. Arguments on semantics and their type. Indirect interfaces as arguments on semantics. COM classes.<br>
Interfaces implemented on COM classes. Aggregation and containment between COM classes.<br><br>
Use of the export tool completely supersedes rip files and makerepos.exe as the means of populating GSCAD metadata in the repository.<br>
6.1      Interface definitions<br>
The applications use interface definitions in the repository to determine existence of semantics and user defined attributes. An interface is defined in .rip using the following syntax.<br>
define	OBJTD IJDGeometry	0xal732cbf0x51360xl ldl 0x97 0x70 0x08<br>
0x00 0x36 0x75 0x42 0x03 0x0<br>
define	ITD IJDGeometry	0xal732cbf 0x5136 0x11 dl 0x97 0x70<br>
0x08 0x00 0x36 0x75 0x42 0x03<br>
create	INTERFACE IJDGeometry<br>
objid	IJDGeometry<br>
iid	IJDGeometry<br>
A repository Interface definition can be specified using UML and GSCA[)<br>
properties. Placing a UML class, assigning an interface name, and setting GSCAD<br>
property TypelnRepository to Interface is all that is necessary for the export tool to define<br>
the interface definition in the repository.<br><br><br>
However, if this interface has already been defined in an application, it is mportant for he GSCAD GUID property to be properly set. This property defines the [nterface IID that must match up with the defined LID in the application. Looking at the above rip text, the USCAD GUID property should be defined as {al732cbf-5136-1 ldl-9770-080036754203}.<br>
6.2      Interface inheritance<br>
GSCAD applications may use inheritance information for query and user defined type support. No rip syntax exists for describing interface inheritance. It is defined in DML as follows.<br><br>
For interface inheritance, the inherits (also called generalization) UML relationship requires no GSCAD property settings.<br>
6 3      Interface implies relationships<br>
OSCAD applications use implies infomiation for query support. No rip syntax exists for describing interface implies relationships. It is defined in UML as follows.<br><br><br>
The UML dependency relationship is used with the "Implies" stereotype name. The export tool will generate an implies relationship in the repository between       IJDGeometry and IJDLine.<br><br>
6.4      Interface scoping for associativity<br>
GSCAD applications use interface scoping rules via the associativity<br>
subsystem to determine interface dependency during associativity graph compute. See<br>
assoc documentation for mote information. Interface scoping is defined in rip using the<br>
following syntax. A scoping relation can be global to an application or only valid within<br>
the context of a class.<br>
setSCOPE<br>
Interface	IJDOccurrence<br>
Scope	IIOccurrence<br>
The same is defined in UML as follows.<br><br>
Two interfaces can be considered equivalent by the associativity. It is defined in UML as follows.<br><br>
One interface can be the origin of at most one scoping relation (ScopedBy or IsEquivalent) in a given context. An interface that is equivalent to  another cannot be a scoping and cannot be scoped.<br>
•	ClassName - NULL by default, indicate in which context this scoping relation apply. The context must be the name of an exported class. If no class name is given the context is global (default scoping rule) and the IsGIobal property must be true.<br>
•	GUID — CLSID of the context class. Set by Export to Repos tool if the scoping relation must be applied within the context of a class,<br><br>
IsOIobal — True by default, indicate if this scoping relation is applied within the context of a class. True if ClassNAme is NULL, False otherwise. For interface scoping, the dependency relationship is used with the<br>
"ScopedBy" or 'IsEquivalent" stereotype name. The export tool will add the scoping<br>
information to the interface definition in the repository.<br>
6.5      Relationship definition<br>
GSCAD applications connect physical objects together based on<br>
relationship definitions stored in the repository. See assoc documentation for more<br>
information. A relationship is defined in rip using the following syntax.<br>
define OBJID	XFormModel Oxl 0x2 0x3 0x1 0x2 0x3 0x1 0x2 0x3 0x10x3 0x0<br>
createRELATION	XformModel<br>
Origin	UCopyXEorm XformModelOrigin<br>
Destination	IJDLine XformModelDestination<br>
Type	COLLECTION_NAMING<br>
setPROPERTY	XFormModel IManageDelete DeleteForward<br>
type	char<br>
index	1<br>
value	NO_PROPAGATE<br>
setPROPERTY	XFormModel IManageDelete Delete_Backward<br>
type	char<br>
index	2<br>
value	PROPAGATE<br><br>
-setPROPFRTY	XFormModel IManageDelete ConnectionProgID<br>
type	char<br>
index	3<br>
value	XFormCompSticXFormCompStic. 1<br>
The same is defined in UML as follows.<br><br>
The UML association is used to define the repository relationship definition. The GSCAD properties added to the association allow setting of propagation rules and disconnection functions to call (See section 4.3 Association and Role properties). It is extremely important to understand that UML roles and repository collections are exactly opposite. In the repository, a relationship has two collections, the origin collection on the origin interface and the destination collection on the destination interface. In UML, an association exists between interfaces based on the roles each element plays in the association. For example:<br><br>
Here IMan is playing the husband role and IWoman is playing the Wife role in UML. When this relationship is mapped to the repository, the relationship will be called Marriage and the IMan will get an origin collection named Wife and the IWoman will get a destination collection named Husband. That is, IMan has a collection of Wife objects and IWoman has a collection of Husband objects (cardinality of the relationship will be left as an exercise for the reader).<br>
Therefore UML association roles reverse when mapped to the repository. Looking at the above XFormModel example, this explains why the XforrnModelOrigin origin collection on IJCopyXForm defined in rip syntax became the role on IJDLine in UML.<br><br>
The IsOrigin GSCAD property on a IJML role is defined in terms the repository NOT UML. Therefore, in the above XFormModel example, the XFormModelOrigin role on IJDLine has IsOrigin set to true because it is desired to have the IJCopyXForm relationship collection called XFormModelOrigin be the origin collection. As will be seen later, the setting of the IsOrigin OSCAX) property plays an important role in defining semantic arguments.<br>
6.6      Semantics on an interface<br>
GSCAD applications use semantics on interfaces via the associativity<br>
subsystem to compute or copy objects in relationships. See assoc documentation for more<br>
information. A semantic is defined using rip syntax as follows.<br>
//Define semantic<br>
define OBJID SMakeBeam	0x22d718be 0x9cef Oxlldl 0xa6 0x77 0x0 OxaO 0xc9<br>
0x8d 0x9d Oxbl Ox 10<br>
createlNSTANCE	SemanticDef SMakefleam<br>
ConnectTo	IMakeBeam IHoldSemantic Semantics<br>
setPROPERTY	SMakeBeam ISemantic nonanie<br>
type	char<br>
index	1<br>
value	Compute<br>
setPROPERTY	SMakeBeam ISemantic noname<br>
type	char<br>
Index	2<br>
value	Beams MakeBeam.ProfileVector.l<br><br>
//Add profile input argument define OB JID ProfileArg<br>
insertlNSTANCEArgumentDef<br>
connectto<br>
setPROPFRTY<br>
type<br>
Index<br>
value<br>
setPROPERTY<br>
type<br>
Index<br>
value<br>
//Add vector input argument define OBJID VectorArg<br>
0x22d718c2 0x9cef Oxlldl 0xa6 0x77 0x0 OxaO 0xc9<br>
0x8d 0x9d Oxbl 0x0<br>
ProfileArg<br>
SMakefleam ISemantic Arguments<br>
ProfileArg IHaveArguments noname<br>
char<br>
1<br>
INPUT<br>
ProfileArg IHaveArguments noname<br>
QUID<br>
2<br>
ProfileForBeam<br>
0x22d718c4 0x9cef Oxlldl 0xa6 0x77 0x0 OxaO 0xc9 0x8d 0x9d Oxbl 0x0<br>
insertlNSTANCEArgumentDef	VectorArg<br>
connectto<br>
2<br>
setPROPFRTY	SMakeBeam ISemantic Arguments<br><br>
	VectorArg IHaveArguments noname<br>
type	char<br>
Index	<br>
value	INPUT<br>
setPROPERTY	VectorArg IHaveArguments noname<br>
type	GUTD<br>
Index	2<br>
value	VectorForBeam<br>
//Add beam output argument	<br>
define OBJID	0x22d718c5 0x9cef Oxlldl 0xa6 0x77 0x0 OxaO 0xc9<br>
ResultingBeamArg	0x8d 0x9d Oxbl 0x0 insertlNSTANCEArgumentDef<br>
	ResultingBeamArg<br>
connectto	SMakeBeam ISemantic Arguments 3<br>
setROPERTY	ResultingBeamArg IHaveArguments noname<br>
type	char<br>
Index	1<br>
value	OUTPUT<br>
setPROPFRTY	ResultingBeamArg<br>
IHaveArguments noname	<br>
type	GUID<br>
Index	2<br>
value	ResultingBeam<br>
The same is defined in UML as follows.<br><br><br>
This is an example of an associative system with Passive Entities IProfile, IVector, and IBeam and Active Entity IBeamMaker (again see assoc documentation for a complete description Active and Passive Entities). The semantic SMakeBeam is anchored to the Active Entity IBeamMake interface via a special association named TieToSMakeBeam. The UML class elements IProfile, IVector, IBeamMaker, and IBeam are all UML interface definitions. Each has the GSCAD TypelnRepository property set to Interface. SMakeBeam is different because its QSCAD TypelnRepository property is set to Semantic. In fact, looking at the OSCAD properties of SMakeBeam we see the following settings:<br>
•	TypelnRepository = Semantic<br>
•	SemanticType = Compute<br>
•	SemantieProgID = Beams,MakeBeam,ProfileVector.l Since TypelnRepository is set to Semantic, the export tool treats<br>
SMakefleam differently that the other UML elements. It interprets properties on the semantic as argument definitions. Each property must be of type String and each property must have an initial value of Input, Output, Constraint, Selfjnput, Self_output, Self_constraint The Rose98 property specification for the ProfileProvider property on SMakeBeam is shown below:<br><br><br>
The actual name of the property must exactly match a role of an association on the IBeamMaker interface. Since IBeamMaker is an Active Entity only and is not a Passive Entity, the role names supplied must be roles on the other side of the association. Specifying other-side role names goes hand in hand with defining the initial value (semantic argument type). Because IBeamMaker is an Active Entity and not a Passive Entity, no initial value should be marked as Self input, Self output or Self_constraint. That is, it is illegal to specify ProfileProvider, VectorProvider, or BeamRequester as semantic arguments AND list their types as Self_*.<br>
Suppose we wish to not have the intermediate IBeamMaker Active Entity and instead have IB earn be both the Active Entity and Passive Entity.<br><br><br><br>
Now IBAeam is both the Active Entity and Passive Entity. How call we tell? Simply by noticing SMakeBeam has an argument of type Self_output. Notice the property name ProfileRequester listed on SMakeBeam. When a semantic wishes to take a Selfjnput, Self_output or Self_constraint argument, ANY role name on the IBeam can be listed. Therefore, we could have specified VectorRequester: String = Selfoutput and gotten the same result.<br>
Another important piece of information related to role name arguments to semantics is the setting of the IsOrigin GSCAD property on the role. For all semantic arguments that are not of Self* type, the IsOrigin property must be set to true. Therefore, in the above example, ProfileProvider and VectorProvider must have IsOrigin set to true. If the semantic argument is of type Self, the IsOrigin property must be set to false on the role.<br>
Rules for constraint type arguments match exactly with non-constraint type arguments. Self_constraint roles can only be listed as arguments if they exist on the Active Entity interface. Non-Self_constraint roles must exist on the other side of the association. All non-Self_constraint roles must have IsOrigin set to true and all Selfconstraint roles must have IsOrigin set to false,<br>
When the export tool finds a semantic, it automatically labels the association between the semantic and interface Tie To<semantic name>.<br>
6.7      Indirect interfaces as arguments to semantics<br>
GSCAD applications can define indirect interfaces as semantic arguments rather than having to create an entirely new relationship. See assoc documentation for more information. An indirect interface argument to a semantic is defined using rip syntax as follows. //Define a semantic to compute the length of the beam<br>
define OBJID	SComputeBeamLength 0x3 0x1 0x1 0x2 0x3 0x4 0x5 0x6<br>
	0x7 0x8 0x9 0x10<br>
createlNSTANCE	SemanticDef SComputeBeamLength<br>
ConnectTo	LAnalyzeBeam IHoldSemantic Semantics<br>
setPROPERTY	SComputeBeamLength ISemantic noname<br>
type	char<br>
index	1<br>
value	Compute<br>
setPROPERTY	SComputeBeamLength ISemantic noname<br>
type	char<br>
Index	2<br>
value	Analysis.BeamLength. 1<br><br>
//IBeam as argument define OB JID BeamArg insertlNSTANCE connectto setPROPERTY<br>
type<br>
Index<br>
value<br>
setPROPERTY<br>
type<br>
Index<br>
value<br><br>
0x334 0x1 0x1 0x2 0x3 0x4 0x5 0x6 0x7 0x8 0x9 0x0<br>
ArgumentDef BeantArg<br>
SCompuiel3eamLength ISemantic Arguments    .<br>
BeamArg IHaveArguments noname<br>
char<br>
1<br>
INPUT<br>
BeamArg IHaveArgunients noname<br>
GUID<br>
2<br>
BeamTo Analyze<br><br>
//The actual argument to the semantic is not IBeam but rather UGeometry<br>
setPROPFRTY	BeamArg II laveArguments noname<br>
type	IK)<br>
Index	3<br>
value	UGeometry<br>
The same is defined in LJML as follows.<br><br><br>
In this example, the argument to the semantic is in the form <interfacename> with BeamProvider being the role name and IJGeometry being the interface name. The export tool detects the semicolon and generates metadata indicating the semantic's actual argument is the indirect interface specified.<br>
6.8      Take an argument tied by a relationship to another interface than the active entity<br>
If the Export to Repos tool does not find the argument role directly tied to the active-ferity, it will try to find it on any interface implied by the active entity. This allows to have a generic connection pattern used by different semantics tied to different active entities.<br><br><br>
This pattern is not "correct" in the sense that no relationship argument of semantic is origin on the active entity. This semantic will never be triggered (see assoc doc for details) but the model can be exported.<br><br>
6.9      COM classes<br>
GSCAD applications currently do not make use of COM class metadata in the repository. Possible future uses include automatic property page display, query, and associativity scoping rules on COM classes that override interface level scoping rules. No rip syntax exists for describing COM classes. It is defined in UML as follows.<br><br>
The UML generalization (inherits) relationship is used with the "Implements" stereotype name. The export tool will generate a repository class defimtion for CBeam. The class definition will have a relationship to all interfaces implemented on the class. In order for the export tool to recognize the CBeam UML element as a COM class, the TypelnRepository GSCAD property must be set to Class.<br>
It is important to note the export tool will only define interfaces implemented on a class that have a direct generalization relationship. Classes that implement interfaces who have implies relationships do not automatically get the implied interface implemented. Instead, the class must have a direct relationship to the implied interface.<br><br><br>
6.10    Aggregation and containment on COM classes<br>
GSCAD applications currently do not make use of CONI class aggregation or containment metadata in the repository. Possible future uses include automatic property page display, query, and associativity scoping rules on COM classes that override interface level scoping rules. No rIp syntax exists for describing aggregation or<br>
containment. It is defined in UML as follows.<br><br><br>
The UML aggregation relationship is used to show CSpecialBeam aggregating CBeam. Additionally, the generalization relationship from CSpecialBeam to IBeam with stereotype name "Aggregates" indicates CSpecialBeam is aggregating the IBeam interface on CBeam. The export tool will generate a repository class definition for CSpecialBeam and will add an aggregation relationship to CBeam. The export tool adds metadata about the aggregation of the IBeam interface.<br>
Containment is shown in a similar fashion to aggregation.<br><br>
Here CSpecialBean contains the IBeam interface on CBeam. The UML generalization relationship is used as with aggregation but with the Implements stereltype name. Note an ambiguity exists in the following case.<br><br><br>
Here, it is unclear if CSpecialBeam is containing the IBeam interface on CBeam or CBoxBeam. To disambiguate this case, the generalization relationship has a GSCAD property AggregateeClass. In the above case, setting this property on the CSpecialBeam to EBeam specialization relationship to either CBeam or CBoxBeam will disambiguate the containment relationship. Note this same case can occur for multiple aggregated objects. By default, the export tool will set this property to the first aggregatee found. The tool issues a warning noting the assumption.<br><br>
WE CLAIM:<br>
1.	A method for maintaining consistency between objects in a<br>
computer system, the method comprising:<br>
providing a first relationship between a first entity and a second entity;<br>
providing a semantic object comprising an action to be performed in response to a change in the first entity;<br>
associating the semantic object with the second entity; and<br>
making a change in the first entity thereby invoking the action.<br>
2.	The method as claimed in claim 1, wherein the second entity has an active entity.<br>
3.	The method as claimed in claim 2, wherein the active entity has an associated stub object.<br>
4.	The method as claimed in claim 2, wherein the first entity has passive entity.<br>
5.	The method as claimed in claim 1, wherein the objects are persistent objects.<br>
6.	The method as claimed in claim 1, comprising: determining a relationship pattern comprising the first entity, the second entity, and the semantic object; determining one or more arguments of the semantic object; invoking a change in the first entity; using information from the<br><br>
relationship pattern and one or more arguments of the semantic object, determining the location of an output; and evaluating the action to produce the output.<br>
7.	The method as claimed in claim 1, wherein the semantic object is accessed from a DLL file.<br>
8.	The method as claimed in claim 1, comprising: providing a second relationship between a third entity and the second entity; and after the action is invoked, performing the action on the third entity.<br>
9.	The method as claimed in claim 1, wherein the action is selected from a group consisting of copy, delete, and modify.<br>
10.	A method of maintaining the integrity of objects in a database, the method comprising: determining a relationship pattern, comprising a binary relation between a first entity and a second entity; providing a semantic object comprising an action to be performed in response to a change in the first entity; associating the semantic object with the second entity; determining metadata comprising information from the relationship pattern and arguments of the semantic object; and storing the metadata and the semantic object.<br>
11.	The method as claimed in claim 10, wherein the metadata is stored in a COM or CORBA repository.<br>
12.	The method as claimed in claim 10, wherein the semantic object is stored in a DLL file.<br><br>
13.	A method of updating information in a database, comprising a first relation between a first entity and a second entity and a second relation between a second entity and a third entity, the method comprising: changing a first object of the first entity; identifying the first relation as being associated with the first object; using the first relation and repository metadata, identifying the second entity us an active entity; identifying a semantic object associated with the active entity, wherein the semantic object comprises an action to be performed in response to a change in the first entity; using arguments of the semantic object, identifying the third entity; and evaluating the action to change the third entity.<br>
14.	A method for providing consistency among persistent objects in a computer system, comprising: using the metadata in a repository, constructing a graph, comprising entities and relations; associating with each active entity a semantic object changing one passive entity, comprising a persistent object, in the graph; and traversing the graph to update the entities using the semantic objects.<br>
Dated this 30th  day of October, 2001<br>
[JAYANTA PAL]<br>
                                                                                                                                                    OF MREMFRY &amp; SAGAR ATTORNEY FOR THE APPLICANTS</interfacename></semantic></y></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUFCU1RSQUNUKDMwLTEwLTIwMDEpLnBkZg==" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-ABSTRACT(30-10-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUFCU1RSQUNUKEFNRU5ERUQpLSgyOC02LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-ABSTRACT(AMENDED)-(28-6-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUFCU1RSQUNUKEdSQU5URUQpLSgxOC03LTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-ABSTRACT(GRANTED)-(18-7-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWNhbmNlbGxlZCBwYWdlcygyOC0wNi0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-cancelled pages(28-06-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUNBTkNFTExFRCBQQUdFUygyOC02LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-CANCELLED PAGES(28-6-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUNMQUlNUygzMC0xMC0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-CLAIMS(30-10-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUNMQUlNUyhHUkFOVEVEKS0oMTgtNy0yMDA3KS5wZGY=" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-CLAIMS(GRANTED)-(18-7-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWNsYWltcyhncmFudGVkKS0oMjgtMDYtMjAwNSkuZG9j" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-claims(granted)-(28-06-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWNsYWltcyhncmFudGVkKS0oMjgtMDYtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-claims(granted)-(28-06-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWNvcnJlc3BvbmRlbmNlKDI4LTA2LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-correspondence(28-06-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWNvcnJlc3BvbmRlbmNlKGlwbyktKDE4LTA3LTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-correspondence(ipo)-(18-07-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUNPUlJFU1BPTkRFTkNFKElQTyktKDMxLTgtMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-CORRESPONDENCE(IPO)-(31-8-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLURFRUQgT0YgQVNTSUdOTUVOVCgxNC0xMC0yMDAzKS5wZGY=" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-DEED OF ASSIGNMENT(14-10-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWRlZWQgb2YgYXNzaW5nbWVudCgxNy0wOS0yMDAzKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-deed of assingment(17-09-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLURFU0NSSVBUSU9OKENPTVBMRVRFKS0oMzAtMTAtMjAwMSkucGRm" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-DESCRIPTION(COMPLETE)-(30-10-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLURFU0NSSVBUSU9OKEdSQU5URUQpLSgxOC03LTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-DESCRIPTION(GRANTED)-(18-7-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWRyYXdpbmcoMjgtMDYtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-drawing(28-06-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLURSQVdJTkcoMzAtMTAtMjAwMSkucGRm" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-DRAWING(30-10-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLURSQVdJTkcoQU1FTkRFRCktKDI4LTYtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-DRAWING(AMENDED)-(28-6-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLURSQVdJTkcoR1JBTlRFRCktKDE4LTctMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-DRAWING(GRANTED)-(18-7-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUZPUk0gMSgxNC0xMC0yMDAzKS5wZGY=" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-FORM 1(14-10-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUZPUk0gMSgyNS03LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-FORM 1(25-7-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWZvcm0gMSgyOC0wNi0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-form 1(28-06-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUZPUk0gMSgzMC0xMC0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-FORM 1(30-10-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWZvcm0gMTMoMTktMTEtMjAwMSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-form 13(19-11-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWZvcm0gMTkoMjctMDQtMjAwNCkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-form 19(27-04-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUZPUk0gMihDT01QTEVURSktKDMwLTEwLTIwMDEpLnBkZg==" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-FORM 2(COMPLETE)-(30-10-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUZPUk0gMihHUkFOVEVEKS0oMTgtNy0yMDA3KS5wZGY=" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-FORM 2(GRANTED)-(18-7-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWZvcm0gMihncmFudGVkKS0oMjgtMDYtMjAwNSkuZG9j" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-form 2(granted)-(28-06-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWZvcm0gMihncmFudGVkKS0oMjgtMDYtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-form 2(granted)-(28-06-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUZPUk0gMihUSVRMRSBQQUdFKS0oMzAtMTAtMjAwMSkucGRm" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-FORM 2(TITLE PAGE)-(30-10-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLUZPUk0gMihUSVRMRSBQQUdFKS0oR1JBTlRFRCktKDE4LTctMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-FORM 2(TITLE PAGE)-(GRANTED)-(18-7-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWZvcm0gMygzMC0xMC0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-form 3(30-10-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWZvcm0gNSgzMC0xMC0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-form 5(30-10-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLWZvcm0gNigxNC0xMC0yMDAzKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-form 6(14-10-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLVBPV0VSIE9GIEFVVEhPUklUWSgxNC0xMC0yMDAzKS5wZGY=" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-POWER OF AUTHORITY(14-10-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLXBvd2VyIG9mIGF1dGhvcml0eSgxNy0wOS0yMDAzKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-power of authority(17-09-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDEzMzYtbXVtLXBvd2VyIG9mIGF1dGhvcml0eSgyOC0wNi0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-01336-mum-power of authority(28-06-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLVBPV0VSIE9GIEFVVEhPUklUWSg2LTUtMjAwMikucGRm" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-POWER OF AUTHORITY(6-5-2002).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLVNQRUNJRklDQVRJT04oQU1FTkRFRCktKDI4LTYtMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-SPECIFICATION(AMENDED)-(28-6-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=SU4tUENULTIwMDEtMDEzMzYtTVVNLVdPIElOVEVSTkFUSU9OQUwgUFVCTElDQVRJT04gUkVQT1JUKDMwLTEwLTIwMDEpLnBkZg==" target="_blank" style="word-wrap:break-word;">IN-PCT-2001-01336-MUM-WO INTERNATIONAL PUBLICATION REPORT(30-10-2001).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="208164-a-polymeric-rigid-container.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="208166-a-device-and-a-method-for-removing-an-object-from-a-moulding-tool.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>208165</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2001/01336/MUM</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>32/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>10-Aug-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>18-Jul-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>30-Oct-2001</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTERGRAPH SOFTWARE TECHNOLOGIES COMPANY (&quot;IST&quot;)</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2325-B RENAISSANCE DRIVE, LAS VEGAS, NEVADA 89119, UNIETD STATE OF AMERICA.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>YANN LIMON DUPARCMEUR</td>
											<td>18, RUE DE LOURMEL, F-75015 PARIS, FRANCE.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>ROBERT N. PATIENCE</td>
											<td>5302 RIVERVIEW DRIVER, HUNTSVILLE, AL 35803, USA</td>
										</tr>
										<tr>
											<td>3</td>
											<td>JEAN-LOUIS ARDOIN</td>
											<td>26, RUE JEAN GEORGET, F-92140 CLAMART, FRANCE.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US00/11364</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-04-28</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/131,970</td>
									<td>1999-07-30</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/208165-a-method-for-maintaining-consistency-between-objects-in-a-computer-system by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:56:25 GMT -->
</html>
