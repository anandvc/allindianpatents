<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/279805-gnss-signal-processor by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:08:00 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 279805:GNSS SIGNAL PROCESSOR</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">GNSS SIGNAL PROCESSOR</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A signal processor for GPS or other GNSS radiolocalization systems, includes a RAM pre-correlation buffer (37) which is filled with samples which are generated by a sampling stage (35) whose sampling rate is governed by a programmable oscillator (350) which is set according to the Doppler shift of a satellite whose acquisition is intended, in sync with the code NCO. Thus all sample alignment in the buffer is fixed. The device further includes an amplitude compressor (36) to limit the size of the buffer memory and is optimized to provide data to the following DFT unit (60) in small bursts thatcan be processed in real time without the need for intermediate buffers. Thanks to these features the processor limits the amount of fast intermediate memories, is simpler and has lowerpower consumption.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>Field of the invention<br>
<br>
[0001] The present invention concerns a satellite radiolocalization receiver and in particular, but not exclusively, a radiolocalization receiver adapted to receive and process radiolocalization signals generated by a constellation of geo-localization satellite, like for example the satellites of the GPS, GLONASS or Galileo System or other global navigation satellite systems (GNSS). The present invention also concerns a signal processor unit adapted for treating radiolocalization signals provided by a suitable RF interface, and which can be embedded in a dedicated GNSS apparatus or in another host system, like for example a general-purpose computer, PDA or cell phone.<br>
<br>
Description of related art<br>
<br>
[0002] The Global Navigation Satellite Systems (GNSS) generically include the Global Positioning System (GPS), operated by the United States, the Global Orbiting Navigation Satellite System (GLONASS) operated by the Russian Federation and the projected Galileo positioning system, to be built by the European Union.<br>
<br>
[0003] The following description and examples will often refer, for the sake of simplicity, to a GPS receiver only. It will be understood, however, that the present invention is not necessarily restricted to such a receiver, but includes also all GNSS sources, and can be extended to other future radiolocalization systems to which the invention is applicable.<br>
<br>
[0004] GNSS radio signals are located in the portion of the radio spectrum above 1 GHz, have power level, at ground, of the order of<br>
<br>
-120 dBm or less and are generally direct-sequence spread-spectrum signals modulated by pseudo-random code binary sequences, which are used in the receiver for positioning and navigation. The general <br>
<br>
functioning of a satellite radiolocalization devices are well known and will be resumed briefly in the description. Reference is also made to International patent application, WO06069489 and WO05003807 and to European Patent applications EP1 198068 and EP16121054 in the name of the applicant.<br>
<br>
[0005] Satellite radiolocalization systems, such as GPS (Global Positioning System), GLONASS or Galileo rely on the reception of radio signals broadcast from a number of orbiting satellites and use the information contained in these signals to determine the distances, or ranges, from the receiver to each of the received satellites. The orbits of the satellites being known, absolute time and the location of the GPS receiver can then be determined geometrically.<br>
<br>
[0006] In the context of the present invention the terms " receiver" and "GPS receiver" can designate a complete self-contained receiver device, but also a module, included in a complex entity, for example a GPS module in a cellular phone, a car alarm, a PDA (Portable Digital Assistant) and so forth. The terms above may also indicate a pluggable module, which may be connected with a hosting device by means of an appropriate bus, for example a GPS PC-card.<br>
<br>
[0007] The terms " receiver" and "GPS receiver" should also be understood, in the context of the present invention, as including one of more integrated circuits, arranged to realize a complete GPS receiver or a complete GPS module, as defined above.<br>
<br>
[0008] The following description relates mostly to the GPS Global Positioning System. The invention is not however limited to this particular system but can also be employed in receivers for radiolocalization systems based on the same principles, for example the GLONASS system or the GALILEO system.<br>
<br>
[0009] In the case of the original GPS radiolocalization system, each of the operational GPS satellites, also indicated as Space Vehicle or SV, <br>
<br>
transmits a navigational radio signal at two carrier frequencies, referenced as " L1 " and " L2" and situated at 1572.42 MHz and 1227.60 MHz respectively. The L1 and L2 carriers are modulated by two digital ranging code sequences, called the C/A (coarse acquisition) code and the P(Y) code, the latter being mostly restricted to the US government and military.<br>
<br>
[0010] The C/A code, which is used by commercial GPS receiver, is modulated in the L1 and in the L2 carriers. C/A codes, which are unique for each GPS satellite, are pseudo-random Gold codes comprising a repetition of a 1023 bits, or "chips", with a transition rate of 1.023 MHz, and are often indicated in short as PRN. The C/A code thus repeats itself every millisecond. The ranging code sequences are synchronized to a common precise time reference, the "GPS time" which is held by precise clocks on board of each satellite, and which are synchronized to a master clock. The effect of the PSK modulation with the C/A code is to spread the spectrum of the modulated signal over a 1 MHz bandwidth.<br>
<br>
[0011] Other radiolocalization systems, for example the proposed Galileo system and proposed extensions to the GPS system, also employ similar or equivalent signal structures, based on ranging codes synchronized to a common standard of absolute time.<br>
<br>
[0012] Both L1 and L2 carriers further carry a 50 bps navigation message, the NAV code. The navigation message contains, along with other information, the coordinates of the GPS satellites as a function of time, clock corrections, and atmospheric data. The NAV message is encoded by inverting the logical value of the C/A code whenever the NAV bit is " 1 ", and leaving it unaltered otherwise.<br>
<br>
[0013] The signal strength of the GPS signals on earth surface is, nominally, -130 dBmW, a value which is further attenuated whenever the view of the sky is obstructed, and especially within buildings. Other satellite navigation systems provide signals of comparable strength. <br>
<br>
Such levels are well below the noise floor, thus the signal can be received only by use of statistical techniques.<br>
<br>
[0014] In order to acquire these codes and perform a position fix a GPS receiver generates, for each received satellite, a local replica of the C/A code, the PRN code, adjusted to a local NCO running at a frequency close to 1.023 MHz. The code is then time-shifted, correlated with the received signal in a correlation engine of the receiver, and integrated, for a time that can be more or less long according to the noise level, until a peak of correlation value is obtained for a certain value of time- shift, that depends from the distance between the receiver and the satellite.<br>
<br>
[0015] The amount of time-shift needed to achieve optimal correlation, or pseudo-range, is an indication of the distance between the satellite and the GPS receiver. The internal clock of the GPS is usually affected by a large error with respect to the GPS satellite clocks. In order to resolve this error a GPS receiver must acquire at least four satellites to provide a position fix comprising the three space coordinates x, y, z and time t.<br>
<br>
[0016] When searching for a GPS space vehicle (SV) we have to search in a 3 dimensional search domain, where the dimensions are SV-Id,<br>
<br>
Doppler, and code phase offset. Given that we may have no information to initialize the search we have to assume worst case that we will have to perform a full search over the entire search space for one or more SVs until we locate an SV to provide a timing reference, in other cases we may already have the knowledge of timing and position which can be applied to reduce the search space. Once a sufficient number of correlation the peaks are found, on the other hand, in the "tracking" state, the system has only to follow their drift, which is usually done with less difficulty or delay.<br>
<br>
[0017] In order to speed up the acquisition state, many receivers adopt a massively parallel architecture, in which the correlation engine <br>
<br>
of the receiver comprises a large number of correlators, in order to explore several combinations of time shift and Doppler frequency in parallel. In typical cases, a correlation engine is able to perform correlation of the incoming signal with thousands of code phase- shift/Doppler frequency combinations.<br>
<br>
[0018] Many known parallel search engines achieve a large computing speed by memorizing source data in memory and then processing this data in the time domain at a frequency higher than the data rate as provided by the SV. These appear to be taking advantage of the gold code being 1023 = 11 * 3 * 31 chips in length and allocating resources as a function of these prime numbers, for example buffering 31 chips of source data and performing correlations against this input buffer for 33 code phase / Doppler combinations divided between a number of channels.<br>
<br>
[0019] All of these architectures suffer from the drawback of sampling the data at the reference clock frequency, compensating for the 'ideal' code rate and buffering samples at some multiple of this code rate.<br>
<br>
[0020] A further limitation of known parallel correlators is that the memorized samples have to be offset according to value of the NCO oscillator in the correlator. This require a dedicated circuitry, usually involving large register based buffers and complex sample steering logic, which consumes power and takes up silicon space.<br>
<br>
[0021] Additionally, known parallel GPS correlators produce short bursts of partial correlation results, which have to be stored in intermediate buffer before further processing can take place. This pipelining is another cause of power consumption and costs. As title of comparison, in known massively parallel architectures, the intermediate buffer between the correlation and the DFT engine represents the largest and faster memory of the device. <br>
<br>
[0022] Known GPS correlator use downsampling in the input data, i.e. they sub-sample the input data at a frequency that is lower than the correlation frequency and interpolate on the output of the sample buffer. This limits the performance and efficacy of the correlation stage.<br>
<br>
Brief summary of the invention<br>
<br>
[0023] It is an object of the present invention to provide an improved correlator for a GNSS processor which overcomes the limitation of the prior art. In particular, the present invention aims to provide a GNSS massively parallel processor which is simpler, more economical and consumes less power than known processors of equivalent performances.<br>
<br>
[0024] Further objects of the invention are the provision of a processor which requires less intermediate buffers and does not need a complex sample-offset circuitry.<br>
<br>
[0025] These goals are attained by a new massively parallel processor comprising the features claim 1. The processor of the invention is based on an early buffering of the data, before the correlation engine, which is then arranged to process them at high speed. The whole architecture is optimized to avoid intermediate storages, by adjusting the throughput of all stages.<br>
<br>
Brief Description of the Drawings<br>
<br>
[0026] The invention will be better understood with the aid of the description of an embodiment given by way of example and illustrated by the figures, in which:<br>
<br>
Figure 1 reproduces, in schematic form, the architecture of a GNSS receiver suitable for the implementation of the invention <br>
<br>
Figure 2 presents a schematic diagram of a possible realization of a GPS correlation engine,<br>
<br>
Figure 3 illustrates a dynamics compression operation according to one aspect of the invention.<br>
<br>
Figure 4 shows a baseline subtraction scheme according to one aspect of the invention.<br>
<br>
Detailed description of modes of realization of the invention<br>
<br>
[0027] Figure 1 represents schematically the layout of a generic GNSS device 10 comprising one or more antennas 30 which allow coupling with radio signals radiated from different GNSS satellites.<br>
<br>
[0028] According to figure 1, the radiolocalization device 10 of the present invention comprises a RF-receiver or radiofrequency module 40, whose function is to process the signals received from the radiolocalization satellites by the antenna 30. The radiofrequency circuit comprises a single- or multiple-conversion heterodyne radio receiver and provides at his output 47 a navigation signal of low frequency, like a baseband signal, analogue or digital, or a low-IF signal, for example a low-lf signal at 4.092 MHz.<br>
<br>
[0029] According to the modulation scheme of the received satellite constellation, the output 45 will comprise several angular component of the signal. In the case of GPS, for example, two components shifted by 90° are needed, and are conventionally referred to as the I (In-phase) and Q (Quadraphase) component. Other modulation schemes, for example the modulation proposed for the GALILEO system, call for more than two angular components.<br>
<br>
[0030] The RF module 40 is connected to a main time base generator 55, which provides a stable time base reference for the radiolocalization device 10, for example a 32.734 MHz time base. Since time base <br>
<br>
generator 55 must be considerably precise and stable to allow acquisition and tracking of the GPS signal, it comprises generally a high- quality temperature compensated crystal oscillator or TCXO.<br>
<br>
[0031] The output 47 of the RF module 40 is fed to a signal processor 50, also called pseudo-range engine 50 which, in turn, provides control instructions 46 to the RF circuit 40. The function of the pseudo-range engine 50 is to de-spread the signals received from the satellites, by generating, for each received satellite, a local replica of the modulation code (the C/A code in the case of a commercial GPS receiver) which is precisely time-aligned with the received signal. The code shifts, or pseudo-ranges 77, generated by the pseudo-range engine 50 are transmitted to the navigation engine 1060, which calculates a fix for position and time coordinates x, y, z, t. The navigation engine also steers the pseudo-range engine 50 by appropriate search instructions 78. The positional fix is usually obtained by iterative Kalman filters, or by other known means, and the navigation engine may need to follow the pseudo-range data 77 along several code periods until a satisfactory solution is found.<br>
<br>
[0032] Preferably the pseudo-range engine 50 and the RF module 40 are realized as two separate integrated circuits or as a single common integrated circuit.<br>
<br>
[0033] In the illustrated variant of the invention the navigation engine 1060 is part of a host system 100, which also comprises application navigation software 1070 and appropriate peripherals 1080 for interaction with a user. The radiolocalization device 10 of the invention is, in this case, an extension of the host system, for example in the form of an extension card or module for a cellular phone, a PDA, a game console, a personal computer or any other suitable host device. The invention comprises however also standalone apparatuses which incorporate navigation engine, application software and peripherals together with the RF module and pseudo-range engine. In this case the <br>
<br>
functions of the navigation engine 1060 and of the pseudo-range engine 50 could conveniently be grouped in a single-chip device.<br>
<br>
[0034] In the case of a multi-standard GNSS radiolocalization device, the received satellites may belong to several satellite constellations, for example to the GPS, Galileo, or GLONASS constellations, and emit in several radio bands.<br>
<br>
[0035] Preferred embodiments of the invention have circuitry elements or the software equivalents thereof for performing correlation. Such elements, when broken down into abstracted, individual units, may be referred to as "taps", with reference to a classical correlation architecture based on tapped shift registers. It must be kept in mind, however, that the present invention is not limited to this particular architecture, and that the term "tap" designates here an abstract correlation unit, arranged to produce a correlation value, and which may also be partially or totally realized in software.<br>
<br>
[0036] According to figure 2, the GNSS processor of the invention comprises a carrier wipeoff stage, comprising a mixer 322 and a local oscillator, which removes an estimated or known carrier wave from the digital samples providing a baseband signal, as it is known in the art. Such carrier wipeoff circuits are typically shared by a number of different correlators. The processor further includes at least one sampling stage 35 for recording the carrier-stripped data in the baseband signal in a pre-correlation buffer 37. The sampling stage is clocked by the code NCO 350, whose rate is controlled, for example by the CPU (not represented) according to the Doppler shift of a satellite whose acquisition is intended. The pre-correlation samples in buffer 37 are, therefore, automatically sampled in chip units, and one can avoid the sampled-alignment logic needed to accommodate Doppler shifts of the SV.<br>
<br>
[0037] Since each SV has an independent and different Doppler shift, the processor of the invention preferably comprises a plurality of code- <br>
<br>
generators code NCO 350 and pre-correlation buffers 37. This parallelization of resources with respect to SV contributes to the processing power of the GNSS processor.<br>
<br>
[0038] According to another aspect of the invention, the dynamic of range of signals in the pre-correlation buffer is compressed, by compression unit 36. A valuable memory saving can be achieved this way, with negligible effects on the correlation result. Taking, for sake of example, a 20 Hz sampling rate for the carrier-stripped signal, and supposing that each carrier-stripped sample is represented by one of (-3, -2, -1, 0, 1, 2, 3) values (coded in 3 bits), and supposing that one integrates them to 1/2 chip samples in the pre-correlation buffer, one can see that such pre-correlation buffer should store, in a fully linear mode, values in the [-30, 30] range.<br>
<br>
[0039] The values in the pre-correlation buffer are distributed according to a bell-shaped curve 260, and as shown for example in figure 3 for example centred on zero, and with quickly decreasing tails. Very few samples, statistically, will be in the tails, and the result of the correlation that is to be performed will not change appreciably, if the values in the tail of the distribution are misrepresented.<br>
<br>
[0040] Accordingly, the invention may include a compression unit 36, to compress the dynamics of the pre-correlation signals, preferably by a linear scaling function, or by a nonlinear compression function. According to one possible illustrated example, the compression unit 36 clips the resulting values signal above and below predefined upper and lower threshold values. Values exceeding upper and lower thresholds are discarded, on represented at the corresponding threshold value. Amplitude linear scaling may optionally be used before clipping. Figure 3 shows the theoretical distribution 260 of the pre-correlation samples in fully linear representation, the distribution of the scaled-down samples 261 and the distribution 265 (hatched) of the samples after application of the saturation operator. <br>
<br>
[0041] Other compression systems are also possible and included in the scope of the present invention. The compression unit could use, for example a double-linear response, or an approximate logarithmic response, or any non-linear compression function, as it is known in the art. The dynamic range of the pre-correlation buffer can then be reduced, with a corresponding saving in memory size, with no ill effect on the performances of the search engine.<br>
<br>
[0042] Preferably, the processor of the invention also includes a biasing unit 33, operatively arranged to encode the values stored in the pre-correlation buffer in a digital number that is always non-negative or always non-positive, for example by adding a fixed bias to the data. All the successive stages, including the correlator 50, are adapted to process digital data in this unsigned format.<br>
<br>
[0043] The use of non-negative values in the processor of the invention allows a simpler logical structure, thus a reduced silicon area and, as a consequence a better routing. Timing needs are also more relaxed in the correlation units of the invention, than in conventional correlators, if unsigned integers are used. Besides being advantageous in themselves, these features further contribute to power saving.<br>
<br>
[0044] According to another, not represented, variant of the invention, an equivalent data biasing is obtained after the correlator 50, by adding a fixed bias to the code-stripped data. In this case signed data are stored in the pre-correlation buffer 37.<br>
<br>
[0045] Although the length of the gold codes used in GPS signals is of 1023 chips, the processor of the invention preferably treats the gold code as a 1024 chips sequence, by suitable adaptation in the code generator 39 (Figure 2). The pre-correlation data can thus be efficiently stored and retrieved in a RAM.<br>
<br>
[0046] Referring again to figure 2, The SV signal needs compensating for both code and carrier Doppler, however since the carrier rate is 1540 <br>
<br>
times the code Doppler the losses due to code Doppler can be ignored for most practical purposes, and in particular in the correlators 50, provided the data is sampled within a few tens of mHz of the actual code Doppler.<br>
<br>
[0047] Data stored in pre-correlation buffers 37 are correlated at high speed in correlators 50, with local replica codes generated by code generators 39. Preferably, ach correlator operates, by multiplexer 45, on data provided by several independent channels 30, each channel being dedicated to the acquisition of one determined SV . The correlator output is fed to the DFT engine 60 to increase the frequency search space for each correlation. This imposes some constraints on the maximum search time against the code Doppler, in order to limit gain losses due to the gradual drift of the replica code against the actual code. Up to about 1/3 chip offset it is still possible to usefully accumulate the results through a DFT. Additionally there is a loss in the DFT on lines further from the centre frequency so the DFT is limited, for example, to 8 lines.<br>
<br>
[0048] To improve the pipelining, the correlators 50 are designed to provide a set of correlation data to the DFT engine every 4 us, this being the rate that the DFT is able to process in real time, without the need of an intermediate buffer.<br>
<br>
[0049] Referring again to figure 2, The DFT unit 60 provides coherent integration values having both a real (I) and an imaginary part (Q). These are fed, preferably via a coherent memory buffer 65, to the amplitude processor 70 which calculates absolute correlation values and accumulates the result in an incoherent integration buffer 80. Since the amplitude of the correlation values are by definition non negative values, the data in the incoherent integration buffer are non-decreasing function of time. Preferably, and according to another aspect of the invention, the amplitude processor 70 subtracts a baseline value from the incoherent integration data, and stores in the buffer 80 only the part exceeding the baseline. In this way, the data stored in the buffer <br>
<br>
are smaller, thus the size and power consumption of buffer 80 can be reduced.<br>
<br>
[0050] According to an optional feature of the present invention, the output of correlator 50 is down-scaled by an appropriate scaling unit (not shown) before feeding to the DFT engine 60, in order to reduce memory requirements in the latter.<br>
<br>
[0051] Figure 4 illustrates an example of baseline subtraction according to this aspect of the invention. Memory area 81 contains a plurality of memory registers used to store the result of coherent integration for a desired set of taps in a GNSS receiver. Memory area 81 is updated periodically, during acquisition with new values of amplitudes provided by the amplitude module 70 the coherently integrated correlations.<br>
<br>
[0052] Amplitude module 70 calculates absolute value (or, equivalently, the square) of I, Q data provided by coherent integration data and, optionally, divides data by a predefined scaling factor in prescaler 82, providing increment values 186 for the incoherent integration.<br>
<br>
[0053] According to a preferred aspect of the invention, amplitude module 70 comprises an offset subtraction unit 89, which subtracts an offset value from amplitude data. The offset values are independently summed and stored in offset accumulator 88, while individual tap amplitudes are accumulated in incoherent integration memory 81. The offset value is recalculated, at each coherent integration cycle, for example as the minimum amplitude among all the considered taps, but other choices are possible. The incoherent memory 81 and the offset accumulator 88 are both available to the CPU (not represented in the drawing), which can easily recombine them to obtain the accumulated amplitudes, when needed. <br>
<br>
[0054] An advantage of the disposition of figure 4 is that the data stored in memory area 81 do not grow linearly in magnitude with the progression of incoherent integration. Rather, by choosing suitable values for the offset, the memory area 81 shall store only differential values, in the distribution of incoherently integrated values. Module 70 of figure 3 thus realizes a compression of incoherent integration data, because small values can be represented in a reduced number of bits.<br>
<br>
[0055] We will now provide a detailed example of implementation of a processor according to the invention. We wish to calculate a correlation between a gold code generated by a local Pseudo-Random Noise Generator (PRNG) and a set of data samples stored in the pre- correlation buffer 37.<br>
<br>
[0056] Let p be the phase difference between the data sample set and the replica code from the PRNG., let Tp ( Tap p) be the correlation between the data and replica code at phase p, let Sn be the sample at offset n from the start of the sample buffer and let Cn represent code sample n from the code boundary. Assuming the code repeats periodically we can calculate a correlation over M data samples as follows<br>
<br>
Q  <br>
<br>
[0057] In order to reduce the data pipeline width and accumulator logic we need to compute the correlation iteratively using a smaller data pipeline and repeating the accumulation in a number of steps. Assuming we choose a width for our data pipeline W as the number of samples we can process in a single cycle, we can then compute this correlation in IWW cycles.<br>
<br>
MlW W-X<br>
<br>
Ip ~ 2^ i—l ^(p+n+I W) ' ^(n+I W) 1=0 ?=0 <br>
<br>
[0058] Now assuming that we want to calculate K contiguous taps starting at tap Tp, we number the taps Tp to T(p + k) O = k = K -1 we get the following equation for T(P+k)<br>
<br>
MlW W-X<br>
<br>
* p+k ~ 2^ i—l (p+n+I W+k) ' ^(n+I W) 1=0 ?=0<br>
<br>
[0059] From this equation it can be seen that in any cycle the correlator needs code samples Cnc where<br>
<br>
(I - W) = nc = (((I + I) - W) -I)<br>
<br>
and data samples Sns where<br>
<br>
(I - W + p) = ns = ((I - (W + l)) + K + p -l)<br>
<br>
[0060] Assuming that our data buffer is implemented in RAM to reduce power and logic, then we have the constraint on the range of samples that can be provided in any cycle, and we can compensate this by offsetting the phase of the code at startup. Additionally we can see that most data samples are required in 2 correlation cycles.<br>
<br>
[0061] Now for a practical implementation we can select a technology and suitable clocking plan which leads to the hardware requirements,<br>
<br>
[0062] For example assuming we have a required tap spacing of ?h uS and our code chip rate is 1 us, we select a suitable maximum clock frequency of 72 Mhz we now have to select the data pipeline width<br>
<br>
[0063] We choose, for example, a repetition rate of 4us for the correlation and can then allocate 288 cycles for the correlation, since the code length is 2046 samples (M = 2046) we select processing 8 code phases (W = 8) per slot in 256 integration cycles. Also, as we want to cover the entire code epoch, 2046 taps, we require that we produce <br>
<br>
(2046 / 8) i.e 8 code taps per slot (K = 8). It is clear, however, that other IWN combinations could also be possible, according to the circumstances<br>
<br>
[0064] Putting these into the equations above each cycle of correlation will need 8 code samples and 15 data samples; however we can reduce the code samples to 4 since the code is 1023 chips long, hence each code chip provides 2 code samples.<br>
<br>
[0065] Thus in cycle (i) we need code samples Q81) to Q8, + 7) and data samples S(8! + P) to S(8! + P + 15)<br>
<br>
[0066] In cycle (i+1) we need code samples Q81 + 8) to Q81 + I6) and data samples S(S1 + P + 8) to S(8| + p + 23)<br>
<br>
[0067] The code for each cycle is unique, but the data for each cycle overlaps so that data samples S(8! + P + 8) to S(8| + p + 15) are used in cycles (i) and (i+1), this allows us to buffer them locally in the correlator and reduce the number of new data samples provided in each cycle to just 8.<br>
<br>
[0068] This also requires an initial load cycle where the first 8 samples are loaded and no correlation is performed, the subsequent cycles perform the correlation, but this results in a code phase misalignment, this is adjusted by applying the code phase shift relationship p together with an implementation defined constant offset to the code.<br>
<br>
[0069] Now we have a data path that is capable of producing 8 taps of correlation on 8 contiguous code phases every 4 us, and repeating this 256 times will produce 2048 taps of data every 1 ms.<br>
<br>
[0070] This works well provided that the data samples are always synchronous to the code rate, but the actual gold code against which we are correlating has length 1023 chips, or 2046 samples, consequently tap 0 will be produced on correlator output 0 in the first slot ( slot 0) and will then be produced again on the 7th correlator output in the <br>
<br>
256th slot ( slot 255), resulting in slot 0 of the following ms producing taps 2..9.<br>
<br>
[0071] This is not a problem when the taps are to be buffered and post processed, however we wish to accumulate the correlation results and process them using a DFT engine to gain a wider Doppler search range, and for this to be implemented without buffering it is preferable to have each tap phase always aligned on the same correlator output.<br>
<br>
[0072] To achieve this we can simply apply a phase shift to the code at the end of the last slot to re-align the codes in the following ms period, this results in 2048 taps being produced and the last 2 taps discarded as they are a duplicate of the first 2.<br>
<br>
[0073] In general terms, some of the embodiments of the present invention foresee the introduction of a phase shift to the code generator at the end of each code period, in order to time-align the local replica codes with the data in the pre-correlation buffer 37. This is advantageous as the processor can then be dimensioned in " natural " sizes which are powers of two, even if the PRN codes do not have a length which is a power of two, like the gold codes used in GPS which have a length of 1023 chips.<br>
<br>
[0074] In order to simplify the data pipeline so that data is always correctly aligned it is very important that the data samples are always correctly aligned in the input buffer, this is achieved by using the pre- correlation buffer stage already which is filled in sync with the code NCO adjusted for the code Doppler, this ensures that for an infinite time the data samples are correctly aligned and the correlation can proceed indefinitely without any further alignment being necessary, this has a huge benefit in hardware simplification and power reduction.<br>
<br>
[0075] Now that we have selected the data pipeline architecture it becomes apparent that we need to provide 256 data sets for each correlation, so we set the data sample buffer memory width to 8 <br>
<br>
samples accordingly, and configure the correlation engine to produce the required taps, however in order to produce all 8 taps we require 2046 + 7 data samples, this requires 257 entries in the input data buffer.<br>
<br>
[0076] To simplify the hardware we can design the data buffer as 256 entries deep and design the pipeline to that the oldest data sample is first read and passed to the correlator before being overwritten with new data, then a further 256 reads are performed producing the required 257 data sets.<br>
<br>
[0077] Since this implies that we are discarding a data sample set in each correlation slot we realize that the oldest data sample for each slot conveniently has a phase offset from the previous slot of 8 samples (taps) consequently we can start each correlation using the oldest data and exactly the same code phase as the previous slot.<br>
<br>
[0078] Then after all correlations within a ms have been completed we need to phase shift the code for the following ms period by 2 samples in order to provide the desired tap alignment in the next ms period.<br>
<br>
[0079] According to a preferred variant, the signal processor of the invention does not use downsampling, in the input buffer, i.e. the processor samples the input at a rate determined by the Code NCO oscillator 350, multiplies these samples by the carrier signal at the same rate, then accumulates all samples storing accumulated results at the same Code NCO rate.<br>
<br>
[0080] According to this variant the code generator actually does not produce a code phase shift at the end of every code period, since the sample data is shifted, so it periodically inserts a code phase shift under control of the channels state machine, but this actually occurs once per ms, not at the end of every code period, since the change in phase of the sampled data between slots is exactly equal to the code phase window covered by the correlation in the slot. <br>
<br>
We Claim:<br>
<br>
1. A signal processor for a GNSS digital signal comprising spread- spectrum radiolocalization signals, received from radiolocalization satellites, each satellite transmitting a radiolocalization signal modulated by a known PRN code, having a Doppler shift and a code phase shift, the signal processor comprising:<br>
<br>
at least one sampling stage (35) comprising accumulation means driven by a programmable oscillator (350), for generating a number of samples of programmable duration, determined by the output of the programmable oscillator (350), which is settable according to the Doppler shift of a satellite whose acquisition is intended, and one pre-correlation buffer memory (37), arranged to store the succession of samples produced by the sampling stage,<br>
<br>
at least one correlator engine, arranged to correlate the samples in the pre-correlation buffer with a plurality of local replicas of the PRN codes, each replica having a phase shift, and to generate a plurality of correlation values.<br>
<br>
2. The signal processor of any of the previous claims, further comprising at least one carrier wipeoff unit (325, 322), to remove a carrier component from said GNSS signal and provide a carrier-stripped GNSS signal, wherein the sampling stage is sensitive to the carrier-stripped GNSS signal,<br>
<br>
3. The signal processor of the previous claim, further comprising a compression unit (36), acting on the sampled signals for reducing their dynamic range according to a linear or non-linear compression function.<br>
<br>
4. The signal processor of any of the previous claims, further comprising a biasing unit 33, operatively arranged to encode the values stored in the pre-correlation buffer in a digital number that is always non- negative or always non-positive. <br>
<br>
<br>
5. The signal processor of any of the previous claims, comprising at least one code generator (39) generating the local replicas of the PRN codes, wherein said code generator (39) is arranged to introduce a phase- shift in the code at the end of each code period.<br>
<br>
6. The signal processor of any of the previous claims, further comprising a DFT engine (60) connected on output of the correlation engine, arranged to produce multiple correlation taps arranged on several Doppler shifts lines.<br>
<br>
7. The signal processor of claim 6,, wherein the correlation engine (50) produces data at a rate that can be handled in real time by the DFT engine<br>
<br>
(60).<br>
<br>
8. The signal processor of claim 6, further comprising a scaling unit to down-scale the correlation values generated by correlator unit (50) and fed to the DFT engine (60).<br>
<br>
9. The signal processor of claim 1, further comprising an amplitude module (70) , an incoherent integration memory (81), arranged to accumulate the output of the amplitude module (70), and an offset subtraction unit (89) arranged to remove a common offset from amplitude data generated from amplitude module (70).<br>
<br>
10. A processing method for a GNSS radiolocalization signal comprising the steps of :<br>
<br>
generating or receiving a carrier-stripped GNSS signal comprising spread-spectrum radiolocalization signals, received from radiolocalization satellites, each satellite transmitting a radiolocalization signal modulated by a known PRN code, having a<br>
<br>
Doppler shift and a code phase shift,<br>
<br>
sampling the carrier-stripped GNSS signal according to a programmable oscillator, which is programmed according to the <br>
<br>
Doppler shift of a satellite whose acquisition is intended, and storing the samples so obtained in a one pre-correlation buffer memory,<br>
<br>
correlating the samples in the pre-correlation buffer with a plurality of local replicas of the PRN code, each replica having a phase shift, and to generate a plurality of correlation values.<br>
<br>
11. The processing method of claim 9, further comprising a step of compressing the dynamic range of data in said pre-correlation buffer.<br>
<br>
12. The processing method of any of claims form 10 to 11, further comprising a step of encoding the values stored in the pre-correlation buffer in a digital number that is always non-negative or always non- positive.<br>
<br>
13. The processing method of any of claims form 10 to 12, further comprising a step of generating local replicas of the PRN codes having a phase-shift in the code at the end of each code period.<br>
<br>
14. The processing method of any of claims form 10 to 13, further comprising a step of applying DFT operations to the correlation values in order to obtain multiple correlation taps arranged on several Doppler shifts lines.<br>
<br>
15. The processing method of the previous claim, further comprising a step of computing amplitude values of the correlation taps, and a step of integrating the amplitude in an incoherent integration memory area (81) after subtraction of a common offset amplitude.<br>
<br>
16. The signal processor of one of the claims 1-9, in which the sampling stage (35) generate samples of the carrier-stripped signal at a sampling rate determined by the programmable oscillator (350), and the correlation engine generate said correlation values at a correlation rate that equals the sampling rate. <br>
<br>
<br>
17. The signal processor of claim 16, wherein the correlation values are accumulated in the accumulation means at a rate that equals the sampling rate.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=6Ri4C2T7hCT51eZy+3RBrA==&amp;amp;loc=vsnutRQWHdTHa1EUofPtPQ==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=6Ri4C2T7hCT51eZy+3RBrA==&amp;amp;loc=vsnutRQWHdTHa1EUofPtPQ==</a></p>
		<br>
		<div class="pull-left">
			<a href="279804-multi-carrier-wireless-network-using-flexible-fractional-frequency-reuse.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="279806-system-and-method-to-determine-electric-motor-efficiency-nonintrusively.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>279805</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1954/MUMNP/2009</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>05/2017</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>03-Feb-2017</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>31-Jan-2017</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>20-Oct-2009</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 Morehouse Drive  San Diego  California 92121-1714  United States of America</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>YOUNG  Phil</td>
											<td>43 Quintonside  Grange Park  NN45AD Northhampton  United Kingdom</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G01S 1/00,H04B1/707</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/EP2008/055756</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2008-05-09</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>07107873.7</td>
									<td>2007-05-10</td>
								    <td>EPO</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/279805-gnss-signal-processor by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 04 Apr 2024 23:08:01 GMT -->
</html>
