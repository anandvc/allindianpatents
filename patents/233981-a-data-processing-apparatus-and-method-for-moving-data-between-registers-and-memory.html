<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/233981-a-data-processing-apparatus-and-method-for-moving-data-between-registers-and-memory by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:00:20 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 233981:&quot;A DATA PROCESSING APPARATUS AND METHOD FOR MOVING DATA BETWEEN REGISTERS AND MEMORY&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;A DATA PROCESSING APPARATUS AND METHOD FOR MOVING DATA BETWEEN REGISTERS AND MEMORY&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A data processing apparatus, comprising: a register data store (20) having a plurality of registers (Dn) operable to hold data elements, the number of data elements held in each register being dependent on a data type of the data elements; characterized by a processor (18) operable to perform in parallel a data processing operation on multiple data elements occupying different lanes of parallel processing in at least one of said registers; access logic (22, 23, 23&#x27;, 24) operable in response to a single access instruction to move a plurality of data elements between specified registers (220, 225, 230) and a continuous block of memory (200) in which data elements are held as an array of structures having a structure format, the structure format having a plurality of components; the single access instruction including data type information identifying the data type associated with the data elements to be moved, and identifying the number of components in the structure format; and the access logic (22, 23, 23&#x27;) being operable to rearrange the plurality of data elements as they are moved such that each specified register holds data elements of one component whilst in memory the data elements are held as said array of structures, the rearrangement performed by the access logic being dependent on the data type.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>The present invention relates to a data processing apparatus and method for moving data between registers and memory.<br>
FIELD OF THE INVENTION<br>
The present invention relates to a data processing apparatus and method for moving data between registers and memory. BACKGROUND OF THE INVENTION<br>
When it is necessary to perform a particular data processing operation on a number of separate data elements, one known approach for accelerating the performance of such an operation is to employ a SIMD (Single Instruction Multiple Data) approach. In accordance with the SIMD approach, multiple of the data elements are placed side-by-side within a register, and then the operation is performed in parallel on those data elements.<br>
However, the real performance benefits of the SIMD approach can only be fully realised if tlie data elements can be arranged in the appropriate order within tlie register without significant overhead.   Typically, prior to performing the SIMD operation, the relevant data elements will need to be loaded from memory into the register(s), and it is often the case that the required data elements for the SIMD operation are not located consecutively within the memory address space.   As an example, the data in memory may represent red, green and blue components for pixel values (i.e. be RGB data), and accordingly when data is loaded from a continuous block of memory into a register, the data elements within the register will also represent red, green and blue components, repeated for each pixel. It may be desired to perform a particular operation on all of the red components retrieved, and accordingly a problem that arises is how to arrange the red components in a manner such that a SIMD operation can then be applied to them.<br>
In accordance with one known technique, data from a continuous block of memory (incorporating the required data elements to be subjected to SIMD processing) is loaded from memory into one or more registers. If each data element within a register is then considered as occupying a different lane of processing, the processor can be arranged to operate on different lanes in different ways in order to perform the required. SIMD processing of particular data elements. Alternatively, certain- customised instructions can be developed for particular operations.  Whilst use of these techniques<br><br><br>
can avoid the need to reorder the data before the SIMD operation is performed, both of these approaches are relatively complex, and significantly increase code size by requiring different instructions and/or processes to be defined for different operations. Accordingly, such approaches do not represent a generic solution.<br>
In addition, it can be seen that such approaches present a large overhead in terms of wasted resource bandwidth. For example, if a particular register has the capacity to store eight data elements, but some of the locations within the register contain data elements which are not going to be subjected to the SMD operation, then it is not possible to get the maximum potential benefit from the use of the SIMD operation. As a particular example, if only four of the data elements within a particular register are to be subjected to the SIMD operation, then only half of the potential bandwidth supported by the register is being utilised.<br>
An alternative prior art approach is to load the required data from the memory into one or more registers in the same manner as described above, but then to employ certain rearrangement operations specified by additional instructions in order to<br>
&gt;<br>
rearrange the data so that the data elements to be subjected to a SIMD operation are placed side by side within one or more registers. Whilst this then enables the subsequent SIMD operation to make maximum use of the available bandwidth of the register, there is a significant performance impact due to the requirement to execute one or more further instructions prior to execution of the SIMD operation in order to rearrange the data as required. This can significantly adversely affect the potential benefit to be realised from use of the SIMD operation.<br>
In the different technical field of vector processing, it is known to provide load instructions which can collect individual data elements from non-consecutive locations in memory by specifying a starting address and a stride. This can for example enable every third data element starting from a particular address to be loaded into a register. Similar store instructions may also be provided.<br>
Such an approach can be advantageous in vector processing systems, since such systems do not generally employ caches within the memory system, and typically are not seeking to access continuous blocks of memory. Accordingly, the increased complexity in the load/store hardware required to implement such striding functions is deemed worthwhile.<br>
However, data processing systems that may be used to perform the earlier described SIMD operations on data elements placed side-by-side within particular registers typically do wish to access continuous blocks of memory, and accordingly it would not be desirable to increase the complexity of the basic load/store hardware in order to support such striding functions. As an example, considering the earlier example where the data represents red, green and blue components of pixels, then it may be desired to access the red green and blue data elements for a particular sequence of pixels, and these data elements will typically be stored within a continuous block of memory.   Whilst increasing the complexity of the load/store unit to support striding functionality might enable the red components to be gathered into a particular register, the blue components to be gathered into another register, and the green components to be gathered into another register, this would require separate instructions to be issued for each component, and further would significantly increase the number of memory accesses required in order to retrieve the data In particular, it can be seen that every data element would in that instance be accessed from a non-consecutive location in memory, and that hence potentially a separate access would be required for every data element, whereas in fact the data required does occupy a continuous block of memory. Accordingly, it will be appreciated that employing such an approach would not only increase the complexity of the load/store hardware, but would also have a very significant adverse impact on the speed with which the data can be accessed.<br>
Accordingly, it would be desirable to provide an improved technique for moving data elements between specified registers and a continuous block of memory in order to support efficient SIMD processing operations. SUMMARY OF THE INVENTION<br>
Viewed from a first aspect, the present invention provides a data processing apparatus, comprising: a register data store having a plurality of registers operable to hold data elements, the number of data elements held in each register being dependent on a data type of the data elements; a processor operable to perform in parallel a data processing operation on multiple data elements occupying different lanes of parallel processing in at least one of said registers; access logic operable in response to a single access instruction to move a plurality of data elements between specified registers and a continuous block of memory in which data elements are held as an array of structures having a structure format, the structure format having a plurality of components; the single access instruction including data type information identifying the data type<br>
associated with the data elements to be moved, and identifying the number of components in the structure format; and the access logic being operable to rearrange the plurality of data elements as they are moved such that each specified register holds data elements of one component whilst in memory the data elements are held as said array of structures, the rearrangement performed by the access logic being dependent on the data type.<br>
Li accordance with the present invention, a processor is provided which is operable to perform in parallel a data processing operation on multiple data elements accessed in at least one of the registers. Accordingly, the processor is able to perform SIMD operations on data elements. Access.logic is also provided which is responsive to a single access instruction to move a plurality of data elements between specified registers and a continuous block of memory in which data elements are stored as an array of structures having a structure format. The structure format has a plurality of components. Hence, considering the earlier example of red, green and blue data elements, the structure format may be considered as having three components, if it is desired to perform different operations on the red, green and blue data elements. Similarly, if the data in memory represented complex numbers, each complex number having a real and an imaginary part, then the structure format in that instance may have two components, namely the real component and the imaginary component, assuming that different operations were required to be performed on those components.<br>
It will be appreciated that the data elements may take a variety of forms, and indeed different forms of data elements may be supported within the same data processing apparatus. The single access instruction includes data type information identifying a data type associated with the data elements being moved. The data type information may identify any relevant information used to define the data type. As an example, the data type information may identify the size of the data elements being moved. In other embodiments, it might also identify other aspects, such as whether the data is signed or unsigned, etc.<br>
In accordance with the present invention, the single access instruction further identifies the number of components in the structure format. Further, the access logic is operable to rearrange the data elements as they are moved such that each specified register stores data elements of one component whilst in memory the data elements are stored as said array of structures.<br>
By such an approach, the required data elements can be accessed in a very efficient manner by loading from, or storing to, a continuous block of memory, whilst in addition enabling any required rearrangement of the data to take place during the access. Thus, in the event of a load from memory, the data elements are then stored in the registers in an appropriate order to enable the SIMD operation to proceed without further delay, whilst in the event of a store operation, data elements that have been subjected to a SIMD operation are stored back to memory in the correct structure format without any further delay.<br>
The present invention hence provides a particularly efficient technique for handling the movement of data elements between registers and memory in order to allow the performance benefits of employing SIMD operations to be more fully realised.<br>
It will be appreciated that the specified registers involved in the access can be identified in a number of ways. For example, certain default registers may be used. However, in one embodiment, the single access instruction identifies the specified registers, the number of specified registers being a multiple of the number of components. By ensuring that the number of specified registers is a multiple of the number of components, the access logic can ensure that any particular register only stores data elements of one component, and further can readily determine which components to allocate to which registers. For example, if the structure format has three components, and three specified registers are identified by the instruction, then clearly one component can be allocated to each register. Similarly, if six specified registers were identified, then the registers could be allocated in any pre-ordained manner, for example the first two registers could be allocated to the first component, the second two registers to the second component, and the last two registers to the third component.<br>
In some embodiments, the data elements being moved may be of different data types. As an example, the data elements of one component may be of a different data type to the data elements of another component. In one particular example, the data elements of one component may be of a different size to the data elements of another component. However, in one particular embodiment, each of the data elements being moved is of the same data type, and accordingly the data type information only needs to identify information pertaining to a single data type. This hence facilitates an efficient encoding of the data type information within the single access instruction.<br>
It will be appreciated that the specified registers may be identified in a variety of ways. However, in one embodiment, the specified registers have a fixed relationship to each other. By placing such a restriction on the identification of the specified registers, this facilitates an efficient encoding of the specified registers within the single access instruction.<br>
The fixed relationship may take a variety of forms.     However, in one embodiment, in accordance with the fixed relationship the specified registers are separated by n intermediate registers, where n is 2m-l and where m is an integer greater than or equal to zero.   This is particular beneficial in one embodiment of the present invention, where the registers within the register data store can be aliased in a number of ways. For example, the register data store can be considered to comprise of a number of 64-bit registers which can each be separately identified, or alternatively may be considered as consisting of half that number of 128-bit registers. Further, this view of the registers can be changed on a dynamic basis. Hence, it may be desirable to load data elements of a particular component into a first 64-bit register, and then load further data elements of the same component into an adjacent 64-bit register. Thereafter, those two registers can be considered as a single 128-bit register for the purposes of a subsequent SIMD operation.  By defining the fixed relationship between the specified registers in the above manner, this can support such functionality.<br>
As a very specific example, when, loading RGB data from memory into the registers, a first single access instruction can be used to load data elements of the red component into a first register, data elements of the green component into a third register, and data elements of the blue component into a fifth register. Then a following single access instruction can be used to load further data elements of the red component into a second register, further data elements of the green component into a fourth register, and further data elements of the blue component into a sixth register. Thereafter, a SIMD operation to be performed on the data elements of the red component may specify as a source register a 128-bit register (actually consisting of the   . 64-bit registers 1 and 2).<br>
Whilst the fixed relationship may be defined in the above manner in order to support the functionality described above, in one embodiment the specified registers are<br>
a series of adjacent registers within the register data store.  This provides a particularly efficient encoding within the single access instruction.<br>
It will be appreciated that the single access instruction can take a variety of forms. However, in one embodiment, the single access instruction is a single load instruction, said access logic being operable in response to said single load instruction to load the plurality of data elements from said continuous block of memory to said specified registers and, prior to storing the data elements in said specified registers, to rearrange said data elements by de-interleaving the data elements of different components so that data elements of different components are stored in different registers of said specified registers.<br>
In accordance with this embodiment, the memory access can be managed in a very efficient manner, since the data elements in a continuous block of memory are accessed, and then the individual data elements are de-interleaved so that data elements of one component are stored in a different register to data elements of another component. This avoids the need to execute further instructions after the single load instruction in order to reorder the data before any SIMD operation can be performed, and hence enables the performance benefit of the SIMD operation to be more fully realised.<br>
In accordance with one embodiment of the present invention, the single access instruction may be single store instruction, said access logic being operable in response to said single store instruction to store the plurality of data elements from said specified registers to said continuous block of memory and, prior to storing the data elements in said continuous block of memory, to rearrange said data elements by interleaving the data elements of different components so that the data elements are stored in said continuous block of memory as said array of structures.<br>
Having provided an efficient mechanism for loading the data, elements from memory into the registers in order to allow SIMD operations to proceed without delay, it will appreciated that it is also beneficial from a performance standpoint to provide a similarly efficient technique for storing the data elements back to memory once they are no longer required by the processor. In accordance with this embodiment of the present invention, the access logic is responsive to the single store instruction to rearrange the data elements by interleaving the data elements of different components so that the data elements are then stored in the continuous block of memory as the array of structures.<br>
Again, a very efficient access to the memory takes place, since the memory access is to a continuous block of memory.<br>
in one embodiment of the present invention, the single access instruction identifies the number of structures to access. This hence provides additional flexibility, in that it is then possible in the instance of a load instruction to load a subset of data elements that does not completely fill an entire register. Similarly, when performing a store instruction, it enables a subset of data elements within a register to be stored back to memory.<br>
In one particular embodiment, when the single access instruction is a single load instruction, if the number of structures is insufficient to cause the specified registers to be filled with data elements, the access logic is operable to cause any unfilled parts of the specified registers to be filled with one or more predetermined values. It will be appreciated that the predetermined values can take a variety of forms. In one particular embodiment, logical zeros are used to fill the remaining unfilled parts of the specified registers.<br>
It will be appreciated that the way in which the memory is addressed may take a variety of forms. However, in one embodiment, the single access instruction identifies an addressing mode to be used to identify the data elements to be moved. In one particular embodiment, the addressing mode identifies a start address for the continuous block of memory. Typically, the start address is not encoded directly within the instruction, but instead a register is identified within the instruction, and that register is arranged to hold the start address.<br>
It will be appreciated that the specified registers may be of any appropriate size. If, for example, the data elements of different components are of different sizes, then it may be appropriate for the specified registers to also be of different sizes. However, in one embodiment, the specified registers are of the same size. .<br>
In one embodiment of the present invention, the single access instruction may identify a transformation to be applied to the data elements, and the access logic is operable to apply said transformation to the data elements as they are moved. The transformation may take a variety of forms. However, as an example, the transformation may specify that the data elements are to be sign-extended as they are loaded from memory,, and prior to storing within the registers. Accordingly, as a specific example, if<br>
the data elements are of a signed 8-bit data type, then the single access instruction may identify as a transformation that these data elements should be sign-extended to 16 bits and then stored in the registers as signed 16-bit values. One way to specify such a transformation within the instruction is to specify the data types of the data elements being accessed, and the resultant data type required. By employing such an approach, an efficient mechanism can be put in place to enable data elements to be transformed as they are loaded from memory into registers, or as they are stored from registers back to memory.<br>
Viewed from a second aspect, the present invention provides a method of operating a data processing apparatus comprising a register data store having a plurality of registers operable to hold data elements, the number of data elements held in each register being dependent on a data type of the data elements, and a processor operable to perform in parallel a data processing operation on multiple data elements occupying different lanes of parallel processing in at least one of said registers, the method comprising the steps of: (a) in response to a single access instruction moving a plurality of data elements between specified registers and a continuous block of memory in which data elements are held as an array of structures having a structure format, the structure format having a plurality of components; the single access instruction including data type information identifying the data type associated with the data elements to be moved, and identifying the number of components in the structure format, and the method further comprising the step of: (b) rearranging the plurality of data elements as they are moved such that each specified register holds data elements of one component whilst in memory the data elements are held as said array of structures, the rearranging performed being dependent on the data type.<br>
Viewed from a third aspect, the present invention provides a computer program product comprising a computer program including at least one single access instruction which when executed causes a data processing apparatus to operate in accordance with the method of the second aspect of the present invention.<br>
DESCRIPTION OF THE DRAWINGS<br>
The present invention will be described further, by way of example only, with reference to preferred embodiments thereof as illustrated in the accompanying drawings, in which:<br>
Figure 1 schematically illustrates an integrated circuit supporting both conventional scalar data processing and SJMD data processing;<br>
Figure 2 schematically illustrates a read and write port arrangement for a SMD register data store;<br>
Figure 3 schematically illustrates an example SIMD read and write operation in which the destination register is twice the width of the source registers;<br>
Figure 4 shows different types of relationship between source register size and destination register size for different data processing operations;<br>
Figure 5 schematically illustrates a syntax which may be used to define a data processing instruction in accordance with the present techniques;<br>
Figure 6 schematically illustrates the SIMD register data store viewed as 64-bit registers and 128-bit registers;<br><br>
Figure 7 schematically illustrates the overlap ("aliasing") between 64-bit and 128-bit registers;<br>
Figure 8 schematically illustrates a plurality of data elements stored within SIMD registers of different sizes;<br>
Figure 9 schematically illustrates the referencing of a scalar value within a SIMD vector register;<br>
Figure 10 schematically illustrates a data processing instruction in which the number of processing lanes and the data element size remain constant;<br>
Figures 11A and 11B schematically illustrate a data processing instruction in which the number of processing lanes remains constant and the data element size changes;<br>
Figure 12 illustrates the transfer of data between a SIMD register data store and a scalar register data store;<br>
Figures 13, 14 and 15 schematically illustrate the operation of various register transfer instructions;<br>
Figure 16 is a flow diagram illustrating an example of a situation in which register transfer instructions of the types illustrated in Figures 14 and 15 maybe usefully employed;<br>
Figure 17 is a diagram schematically illustrating how data elements are loaded from a continuous block of memory into some specified registers in accordance with one embodiment;<br>
Figure 18 schematically illustrates some examples of different structures that may exist within memory in accordance with embodiments;<br>
Figures 19A to 19C illustrate the operation of a particular example of a single store instruction in accordance with one embodiment;<br>
Figures 20A to 20C illustrate the operation of a particular example of a single load instruction in accordance with one embodiment;<br>
Figures 21A to 21C illustrate the operation of a further particular example of a single load instruction in accordance with one embodiment;<br>
Figures 22A to 22C illustrate the operation of another particular example of a single load instruction in accordance with one embodiment;<br>
Figure 23 is a block diagram illustrating in more detail the logic provided within the reordering logic of Figure 1;<br>
Figures 24-26 illustrate the flow of data through the reordering logic for four different sequences of single access instructions in accordance with embodiments;<br>
Figure 27 illustrates a known folding operation;<br>
Figure 28 illustrates a folding operation of one embodiment;<br><br>
Figure 29 illustrates a folding operation of another embodiment; Figures 30a to 30d illustrate the operation of various folding instructions;<br>
Figure 31  illustrates schematically logic  arranged to perform  a folding operation provided within the SIMD processing logic of Figure 1;<br>
Figure 32 illustrates the operation of a vector-by-scalar instruction;<br>
Figure 33 illustrates an arrangement of scalar operands in the SIMD register file of Figure 1;<br>
Figure 34 illustrates schematically logic arranged to perform a vector-by-scalar operation provided within the SIMD processing logic of Figure 1;<br>
Figure 35 shows a method of shifting right and packing high according to the prior art;<br>
Figure 36 schematically shows a shift right and narrow operation according to an embodiment of the present technique;<br>
Figure 37 schematically shows a shift left and narrow according to the present technique;<br>
Figure 38 schematically shows a cast up and shift left according to an embodiment of the present technique;<br>
Figure 39 schematically shows a shifting of data elements by different amounts;<br>
Figure ,40 schematically shows a conventional multiplexer;<br>
Figure 41 schematically shows an embodiment where the selection of source values a or b is done on a bit-wise basis;<br>
Figure 42 schematically shows an alternative embodiment where the selection of source values a or b is done on a data element basis;<br>
Figure 43 schematically shows three examples of multiplexer arrangements corresponding to the three multiplexing instructions provided by the present technique;<br>
Figure 44 schematically illustrates a SHvlD register storing multiple 'data elements in different layouts depending upon the endianess mode;<br>
Figure 45 schematically illustrates the operation of memory accessing logic and data element reordering logic in accordance with a first example;<br><br>
Figure 46 schematically illustrates the operation of memory accessing logic and data element reordering logic in accordance with a second example;<br>
Figure 47  schematically illustrates  an example embodiment of the data element reordering logic of Figures 45 and 46 in more detail;<br>
Figure 48 schematically illustrates a register data store including two registers serving as table registers, a result register and an index register;<br>
Figure 49 schematically illustrates the action of a table lookup extension instruction;<br>
Figure 50 schematically illustrates processing performed upon an index register before the index values within the index register are reused by a further table lookup extension instruction;<br>
Figure 51 schematically illustrates the operation of a table lookup instruction in which zero values are written into the result registers at locations corresponding to out-of-range index values;<br>
Figure 52 illustrates how the LSU of Figure 1 is coupled with a memory system and a Memory Management Unit in accordance with one embodiment;<br>
Figures 53A to 53D are diagrams schematically illustrating various examples of data blocks to be accessed in accordance with an embodiment;<br>
Figures 54A and 54B are diagrams schematically illustrating further examples of data blocks to be accessed in accordance with an embodiment;<br>
Figures 55A to 55C schematically illustrate an interleave operation, a de-interleave operation and a transpose operation, respectively;<br>
Figures 56A and 56B schematically illustrate how interleave and transpose operations are performed in accordance with one embodiment;<br>
Figures 57A to 57C illustrate how a sequence of instructions in accordance with one embodiment may be used to transpose an array of image pixels;<br>
Figure 58 illustrates how an instruction of one embodiment may be used to interleave real and imaginary parts of complex numbers;<br>
Figures 59A and 59B illustrate how a sequence of two instructions in accordance with one embodiment can be used to perform in parallel a multiplication of two complex numbers;<br>
Figure 60 schematically shows an add returning high half operation and its associated instruction;<br>
Figure 61 schematically shows an add returning high half operation with rounding and its associated instruction;<br>
Figure 62 schematically shows a subtract returning high half operation and its associated instruction;<br>
Figure 63 shows a table of possible constants generated from an instruction having a data portion, abcdefgh and a control portion associated with it;<br>
Figure 64 shows constant generation logic;<br>
Figure 65 shows a data processor having constant generation logic;<br>
Figure 66A and 66B schematically show a data processor response to two types of instruction with generated constant; and<br>
Figure 67 shows the generation of a bit mask according to the present technique.<br>
DESCRIPTION OF EMBODIMENTS<br>
Figure 1 schematically illustrates a data processing system (integrated circuit) 2 incorporating both a scalar data processing functionality and a S1MD data processing functionality. The scalar data processing portion can be considered to be a standard ARM processor core incorporating a scalar register data store 4, a multiplier 6, a shifter 8, an adder 10, an instruction pipeline 12 and a scalar decoder 14 as well as many other circuit elements which have not, for the sake of clarity, been illustrated. In operation, such a scalar processor core stores fixed length 32-bit data values within the scalar register data store 4 and manipulates these using the multiplier 6, shifter 8 and adder 10 under control of data processing instructions passed along the instruction pipeline 12 and supplied to the scalar decoder 14. The scalar decoder 14 produces control signals which control the operation of the scalar processing elements in a conventional way.<br>
As illustrated in Figure 1 the integrated circuit 2 includes various dedicated SIMD processing elements including a SIMD register data store 20, dedicated SIMD processing logic 18 and reordering logic 24. A load store unit 22 is shared with the scalar portion and could be the same or a modified version of the load store unit conventionally found within a scalar processor.<br>
The instruction pipeline 12 is extended with additional pipeline stages which serve to control SIMD processing operation via a dedicated SIMD decoder 16. (It will be appreciated that in other embodiments the SIMD pipeline may be provided in parallel with the scalar pipeline.) The SIMD decoder 16 generates SIMD control signals which control the operation of the SIMD processing elements, such as reading of SIMD registers, writing of SIMD registers and the configuration of the SIMD<br>
processing logic so as to perform the desired data processing operations. The SIMD pipeline stages follow the scalar stages resulting in the SIMD portion of the processor effectively seeing a different execution point to the scalar portion. This can result in the need for some interlocking as will be discussed below.<br>
The reordering logic 24 serves the purpose of reordering data elements retrieved from a memory (not illustrated) coupled to the integrated circuit 2 in to an order more suited to the desired SIMD processing operation. This reordering logic 24, its operations and advantages will be discussed further below. There are also provided load and store FIFOs 23 and 23' between the load store unit 22 and the reordering logic 24.<br>
The scalar register data store 4 can in this example be considered as being divided into a fixed number of fixed length registers, such as the conventional 16 32-bit ARM registers. In contrast, the SIMD register data store 20 provides a block of storage which may be addressed/accessed in a flexible way depending upon the parameters associated with the SIMD data processing instruction concerned. More particularly, the SIMD data processing instruction specifies source and 'destination register numbers, data element sizes and register sizes associated with the data processing instruction. These parameters are together combined by the SIMD decoder 16 and read/write ports of the register data store 20 to control the mapping of the different portions and accordingly data elements stored within the SIMD register data store .20 to the register being accessed. Thus, SIMD registers of differing sizes, differing data element sizes and the like can effectively be aliased together (i.e. these registers can be considered as overlapping and accessible via different register specifiers, register size and data element size combinations as may be desired. The SIMD decoder 16 and the read/write ports can be considered to provide register accessing logic in this example embodiment).<br>
Figure 2 schematically illustrates the read and write port arrangement which may be provided for the SIMD register data store 20. In this example thirty two SIMD registers are capable of being specified by the register specifying field (5 bits)<br>
within the SIMD data processing instructions. N read ports are associated with the SIMD register data store 20. The minimum granularity supported is a 64-bit register value. In this example, the register sizes directly supported are 64-bits and 128-bits. It will be readily apparent to those in this field that this arrangement could be scaled to support 256-bit and higher register sizes directly, or indirectly by synthesis using supported instructions with smaller sizes of register. Figure 2 schematically illustrates M de-multiplexers serving as write ports to the SIMD register data store 20. It will be appreciated that in practice such de-multiplexers are provided in the form of appropriately directed enable signals to rows of. storage elements within the SIMD register data store together with the action of multiplexers routing the desired inputs to their destination.<br>
Figure 3 illustrates a particular example in which two 64-bit SIMD register values (denoted as a D double words) each containing multiple data elements are multiplied together to generate multiple output data elements that are stored together in a 128-bit register (denoted as a Q quad word). Separate read ports are arranged to read the source SIMD register values DI and Da from the SIMD register data store 20. Two write ports act together to respectively allow the first Q [63:0] portion and second Q [127:64] portion of the 128-bit result to be written back to the SIMD register store 20. It will be appreciated that the data element size within the D registers and the Q registers can vary. As an example, four 16-bit data elements may be contained within each of the source D registers with the destination Q register containing a set of corresponding four 32-bit data elements being the result of the multiplication. In this example it will be seen how the number of lanes of parallel processing (four) remains constant whilst the data element size is increased from 16-bits to 32-bits as required by the multiplication operation being performed.<br>
Figure 4 illustrates various different types of relationship between source register size and destination register size which may be supported. In the uppermost example given the number of lanes of parallel processing remains constant and the data element size remains constant, hi the second and fourth examples the number of lanes of .parallel processing remains constant but the data element size changes<br>
between the source and the destination. In the third example the two source elements have different data element sizes. The SIMD processing structure and techniques of the present system support these different types of data processing instruction as will be described further below. The final three examples are unary operations with a single input variable. The fifth example keeps the same data element size. The sixth example doubles the data element size and the seventh example halves the data element size.<br>
Figure 5 schematically illustrates the syntax of a SIMD data processing instruction. The first portion of the syntax specifies the SIMD operator concerned, in this case a multiplication operation. This is followed by a field indicating the output data element size and other characteristics of. the output data elements. In this example the output data elements are 16-bits in length and are signed integers. The next field indicates the input data element size and characteristics, in this case signed 8-bit integers. The next field indicates the destination register size and register specifier. In this example the 128-bit quad word SIMD register with the register specifier 12 is to be used as the destination SIMD register. The two source SIMD registers are each double word 64-bit registers with the register specifiers respectively being "1" and "4". Further information on the syntax is described below.<br>
A set of data types to represent the different data formats are defined. These are described in Table 0. Most instructions use at least one data type qualifier to determine the exact operation. However, operations do not necessarily support all data types. The data type is applied as a suffix to the fields indicating the data element size and characteristics.<br>
Data type	Interpretation<br>
Qualifier<br><size>	Any element of <size> bits<br><size>	Signed   or   unsigned   modulo   integer   of<br><size> bits<br>
.F<size>	Floating-point number of <size> bits<br>
.P<size>	Polynomial over {0,1} of degree less than<br><size><br>
.S<size>	Signed Integer of <size> bits<br>
.U<size>	Unsigned Integer of <size> bits<br>
Table 0 	<br>
Figure 6 illustrates how the SIMD register data store 20 may be viewed as being divided into thirty two 64-bit registers or sixteen 128-bit registers. These registers map to the same physical SIMD register data store 20 and accordingly alias together. As an example, a data element within register DO may also be accessed as a data element within register QO.<br>
Figure 7 schematically further illustrates the overlap between the 64-bit and 128-bit registers. As illustrated, a 128-bit register Q(n) corresponds to two 64-bit<br><br>
registers D(2n+l) and D(2n).<br>
Figure 8 schematically illustrates example data elements which may be stored within SIMD registers of differing sizes. In the upper portion of Figure 8, a 128-bit SIMD register is illustrated as either containing four 32-bit data elements or eight 16-bit data elements. The data elements may be signed or unsigned integers, floating point numbers or other formats of number as desired and suited to the parallel processing to be performed.<br>
The lower portion, of Figure 8 illustrates a 64-bit SIMD register which may contain either two signed 32-bit integers or four unsigned 16-bit integers. Many other possibilities are available and will be apparent to those in the technical field.<br>
Figure 9 schematically illustrates how an individual scalar value within a SIMD register may be referenced. The illustrated SIMD register 26 contains four signed integer values. If this SIMD register is considered as register Dn,'then the different individual signed integer values can be denoted as Dn[3] to Dn[0]. Such<br>
referencing of individual data elements within a SIMD register is used, for example, when performing register transfer instructions which select one of the data elements within a SIMD register and move it to or from one of the registers within the scalar register data store 4.<br>
Figure 10 illustrates how a SIMD data processing instruction may be performed with the number of processing lanes remaining constant and the data element size remaining constant between the two source registers and the destination register. In this example the source SIMD registers are D registers (64-bits and containing four 16-bit data elements) having four parallel processing lanes. The destination SIMD register is also a 64-bit D register containing four result 16-bit data element values.<br>
In contrast to Figure 10, Figure 11A illustrates an example in which the destination SIMD register is twice the width of the source SIMD registers. The number of lanes of processing remains constant but the data element size doubles. This type of behaviour is suited for use with SIMD operations such as multiply, add, subtract and shift (particularly left shift). Figure 11B illustrates an example in which the destination SIMD register is half the width of the source SIMD registers. This type of instruction is useful for add and shifts (particularly right shifts).<br>
The ability to alter data element size between source and destination whilst maintaining the number of processing lanes allows sequences of SIMD data processing instructions to be built up without the requirement for data element reordering or doubling up of instructions as a consequence of changes in data element size produced by the data processing operations performed. This is a significant advantage in terms of processing speed, code density, power consumption and the like.<br>
Figure 12 schematically illustrates the scalar register data store 4 and the SIMD register data store 20 coupled together by register transfer logic 28.. Control signals received from either or both the scalar decoder 14 or the SIMD decoder 16<br>
control the register transfer logic 28 in response to register transfer instructions within the instruction pipeline 12 to move data between a specified register within the scalar register data store 4 and a specified position within a specified register of the SIMD register data store 20. A data value moving from the scalar register to the SIMD register may also be copied to all positions within the SIMD register as is illustrated in Figure 13. This type of register transfer instruction with duplication is well suited to rapidly populating all processing lanes within a SIMD register with values, such as scaling values, which need to be applied to different other operands within SIMD registers by the SIMD processing logic 18.<br>
Figure 14 illustrates a different type of register transfer instruction. In this example a 32-bit scalar value A is moved to a specified position (lane) within the SIMD register. The other lanes maintain their original values. The scalar value is not duplicated across the entire scalar register. The position within the destination scalar register can be changed by an appropriate field value within the register transfer instruction. This type of operation allows an'individual data element within a SIMD register to be populated with a data value taken from the scalar register data store.<br>
Figure 15 illustrates a further type of register transfer instruction. In this example a 16-bit data element from within the SIMD register is taken from a specified variable position within that SIMD register and copied to one of the scalar registers. Since the scalar register is a 32-bit register, then the data element is in this example sign extended. The data element could instead be zero extended depending upon the requirements of the particular algorithm or system.<br>
Figure 16 is a flow diagram schematically illustrating an example type of processing in which the register transfer instructions of Figure 14 and Figure 15 may be advantageously employed. At step 30 some SIMD processing is performed in parallel upon multiple lanes each containing their own data elements. At some point this processing requires a data manipulation to be performed which is either not supported by the SIMD processing logic 18 or can only be inefficiently so supported, hi this circumstance it is desired to separately move the individual data elements<br>
across to the scalar processing system to allow this complex data operation to be performed. Step 32 selects the first data element to be so moved. Step 34 then executes a register transfer instruction such as that illustrated in Figure 15. Step 36 executes the desired complex processing upon the individual data element now in the scalar portion of the system. When this complex processing has been completed, step 38 executes a register transfer instruction such as that illustrated in Figure 14 to return the now modified data element back to its original position. Step 40 determines whether the last data element has been reached, and if this is not the case the step 42 selects the next data element before returning processing to step 34. If all of the data elements which required the complex operation to be performed upon them have been moved across to the scalar system, subject to the desired processing and moved back to the SIMD system, then processing proceeds from step 40 to step 44 at which the parallel SIMD processing is resumed.<br>
Data processing instructions specifying SIMD registers for accessing the fegister data store include one or more register fields encoding a register numver of a register to be accessed. The 5-bit register specifiers used are designed to be the same as those used by the ARM Vector Floating Point (VFP) unit - that is, the instruction bits that specify a register are:<br>
*	For destination registers:<br>
D = bit[22]<br>
Rd = bits[15:12] *	For first source register specifiers:<br>
N = bit[7]<br>
Rn = bits[19:16]<br>
*	For second source register specifiers:<br>
m = bit[5]<br>
= bits[3:0]<br>
Furthermore, the use of these bits is chosen so that Di registers and word scalars are encoded consistently with the way that VFP specifies double- and single-precision registers respectively, and the encodings for Qi registers and halfword scalars follow the same principles. The following describes how (D,Rd) are used; (N,Rn) and (M,Rtn) are used analogously:<br>
Qd: Qi register number is (D,Rd[3],Rd[2],Rd[l])<br>
.Corresponding Di register numbers are (D,Rd[3],Rd[2],Rd[l],0) and<br>
(D,Rd[3],Rd[2],Rd[l],l)<br>
Rd[0] Should Be Zero<br>
Dd: Di register number is (D,Rd[3],Rd[2],Rd[l],Rd[0])<br>
Word scalar:<br>
Di register number is (0,Rd[3],Rd[2],Rd[l],Rd[0])<br>
word[D] is selected from register on little-endian basis<br>
Halfword scalar:<br>
Di register number is (0,0,Rd[2],Rd[l],Rd[0])<br>
halfword[(D,Rd[3])] is selected from register on little-endian basis.<br>
Byte scalar:<br>
Di register number is (0,0,0,Rd[l],Rd[0])<br>
byte[(D,Rd[3],Rd[2])] is selected from register on little-endian basis.<br>
Thus, the bits D, Rd[3]5 Rd[2], Rd[l] and Rd[0] may be considered as mappable to a 5-bit contiguous field which is rotatable by a number of bit positions dependent upon the register size for the register number. In practice the register encoding bits are not mapped or rotated as separate operations but are supplied to the reiger accessing logic to form a row address and a column address for accessing the register data store with a movable mask being applied depending upon register size to select the correct portions of the bit to serve as row and portion column addresses.<br>
In accordance with embodiments, load and store instructions are provided for moving data between the SIMD register file 20 (see figure 1) and memory. The load instructions can be used to load data elements from memory into specified registers, whilst the store instructions are used to store data elements from specified registers to memory. These load and store instructions are designed to support the movement of data required by algorithms using the SIMD processing logic 18. The load and store instructions of embodiments specify the size of data elements that they are loading and storing, and this information is used to provide a consistent ordering within a register regardless of the endianness of the memory system.<br>
The load and store instructions of embodiments allow a number of data elements from a continuous block of memory to be loaded into or stored from the SIMD register file 20. hi accordance with one embodiment, accesses can be performed at any byte alignment, and load or store up to 32 bytes.<br>
&gt;<br>
The load and store instructions of embodiments are considered to access the data from memory in which the data elements are arranged into structures, with each structure having a number of components. . In accordance with one embodiment, the structures in memory can contain between one and four components where a component can have any data type size that is recognised by the SIMD processing logic 18, in preferred embodiments these data type sizes being 8, 16, 32 or 64-bits. Some common examples of structure formats used in embodiments are shown in the following table:<br>
(Table Removed)<br>
For any particular load or store instruction, each structure in memory the subject of the access will have the same structure format, and accordingly will include the same number of components. The load and store instructions are arranged to identify the number of components in the structure format, and this information is used by the reordering logic 24 to provide de-interleaving of data elements when performing load operations, and interleaving of data elements when performing store operations, allowing data to be arranged in registers such that the different data<br>
&gt;<br>
elements of the structure appear in different registers. This concept is illustrated schematically in Figure 17 for the situation of a load instruction used to load a number of data elements from a continuous block of memory into three specified registers. In this example, the specified registers are the three 64-bit registers DO 220, Dl 225 and D2 230. In this example, the structure format is a 3D vector format, and accordingly each structure 210 in the memory 200 has three components 215.<br>
As shown in figure 1, the load instruction is routed from the instruction pipeline 12 to the sealer decoder 14, resulting in appropriate memory access control signals being sent to the load store unit (LSU) 22. The LSU then accesses the required four structures A[0], A[l], A[2], and A[3] from a continuous block of memory. Accordingly, the LSU 22 can operate in its normal manner. Thereafter, the data is routed via the reordering logic 24 which is arranged to de-interleave the three components in each structure, such that data elements pertaining to the X component are routed to register DO 220, data elements of the Y component are routed to register Dl 225, and elements of the Z component are routed to register D2 230.<br><br>
The ability to load from an array of structures and separate the information into separate registers as part of the load operation can be used to allow data to be immediately ready for efficient SIMD processing.<br>
The reordering logic 24 is also arranged to perform an analogous process when storing data from specified registers back to the continuous block of memory, in this instance the reordering logic 24 performing an interleaving operation in order to reproduce the structure format prior to the data being stored in memory.<br>
As can be seen from Figure 1, the load instructions are routed from the<br>
instruction pipeline to the scalar decoder 14 prior to those instructions reaching the<br>
SIMD stages of the instruction pipeline 12. This enables the process of loading the<br>
data into the SIMD register files 20 to occur earlier than would otherwise be possible,<br>
and has the benefit that a subsequent SIMD processing instruction will not typically<br>
have to wait for the data to be loaded before it can begin execution, thereby<br>
significantly reducing the latency of load operations. Store instructions however will<br>
need to be passed through the instruction pipeline until they can be routed to the<br>
SIMD decoder 16, from where appropriate control signals can be used to control the<br>
accessing of the data from the SIMD register files 20, and the appropriate reordering<br>
within the reordering logic 24 prior to the data being stored via the LSU 22 back to<br>
the memory. However, certain parts of the store instruction can be performed whilst<br>
in the ARM portion of the instruction pipeline 12, for example checking the address,<br>
memory access permissions, etc., to ensure that the instruction will not cause a data<br>
abort.	<br>
The load and store instructions of embodiments can be viewed as following a single syntax. The syntax can be expressed as follows: V(LD|ST)<st>.<dt>{@<a>} <reglist>, { <n>,} <addr><br>
where<br><st>	The Structure Format<br><br>
Data elements in memory are considered as an array of structures having <st> components. This information is used to interleave and de-interleave data elements as they move between memory and the SMD register store to enable efficient SDVID processing.<br><dt>	The Data Type<br>
This determines the size of the data elements being loaded<br><a>	An Alignment Specifier (optional)<br><reglist>         The SEVID Register List<br>
This determines the SDVID register state that will be written to or read from. For loads, this is precisely the parts of the SIMD register file that will be affected by the instruction. The register list is considered a collection of data elements of size <dt>, split in to <st> vectors of equal length.<br>
Note that the number of bytes within the register list is not necessarily the same as the number of bytes of memory accessed. See the <n> options and Figures 20A to 20C.<br><n>     Number of Structures (optional)<br>
This defines the number of structures to load or store. This allows a register list to only partially be loaded with memory data, and the remaining parts be zeroed. When it is not supplied, it takes the default value which means the register list and memory access size are the same.<br>
default <n> := elements<dt>(<reglist>) / <st><br><addr>	The Addressing Mode used for the access<br><br>
hi accordance with embodiments, the addressing mode can take a variety of forms, and in particular the three forms illustrated below:<br><addr><br>
[Rn]      ;// address := Rn<br>
[Rn]!      ;// address := Rn, Rn := Rn + transfer_size (where "transfer_size" is the<br>
amount of memory accessed)<br>
[Rn], Rm  ;// address := Rn, Rn := Rn + Rm<br>
The semantics discussed above allow single structures or multiple structures to be loaded or stored, logical zeros to be written to remaining parts of registers that are not filled with data from memory, and insertion into registers by using a register list containing sealer qualifiers (e.g. D0[l]). It will be appreciated that in embodiments the actual load and store instructions that are provided will typically be a subset of all possible combinations of the above syntax.<br>
With regard to the structure format, Figure 18 illustrates three possible examples of structure format, and their corresponding "st" value. As can be seen from Figure 18, the first structure 250 has only a single component, and accordingly the st value is one. In the second example, the structure 255 has two components, for example representing real part x and imaginary part y of a complex number, and accordingly the st value is two. Finally, in the third example, the structure 260 has three components, representing R, G and B data elements, and accordingly the st value is three.<br>
To help illustrate some of the functionality available when using the load and store instructions of embodiments, Figures 19 to 22 illustrate specific examples of load and store instructions. Considering first Figures 19A to 19C, Figure 19A illustrates the reglist states specified by a store instruction<br>
VST 2.16 (DO, Dl, D2, D3}, [rl]<br>
• . This instruction is used to store multiple structures from the specified register files to a continuous block of memory. As can be seen, Figure 19A identifies that the reglist contains four specified registers DO 270, Dl 280, D2 290 andY&gt;3 300. As shown in Figure 19B, these registers can be considered as being split into "st" vectors (i.e. 2) of "dt" sized (i.e. 16-bit) data elements. In register DO, these data elements are referenced by the numeral 275, in Dl by the numeral 285, in D2 by the numeral 295 and in D3 by the numeral 305. As can be seen from Figure 19C, the reordering logic 24 is arranged to interleave data elements from these two vectors so that each data element 314 is stored to the memory 310 in the required structure format for the structure 312.<br>
Figures 20A to 20C are a similar set of diagrams illustrating the operation performed by the instruction<br>
VLD2.16{DO,D1},#1, [rl]<br>
Figure 20A illustrates the collection of the reglist state, identifying the registers DO 270 and Dl 280. Figure 20B then illustrates how these registers are split into st vectors (i.e. 2) of dt sized (i.e. 16-bit) data elements.<br>
hi contrast to the example of Figures 19A to 19C, this instruction specifies an "n" parameter identifying the number of structures to be accessed, in this example n being 1. Accordingly, for this load instruction, n x st (i.e. 1x2) data elements need to be read from memory beginning at the effective address and to then be distributed into the vectors in a round-robin allocation beginning at the lowest indexed element of the first vector. This process is illustrated in Figure 20C, and results in the data element x0 of the first component 314 being written into the lowest 16 bits of the register DO,<br>
n    .<br>
whilst the data element y0 of the second component is written to the lowest 16 bits of the register Dl. In accordance with this embodiment, any parts of the register state not written to once all of the data elements have been loaded are set to zero. It should be noted that for the equivalent store instruction, n x st data elements are stored in the reverse manner to the loads.<br>
Figures 21A to 21C illustrate another particular example in which the syntax for the instructions is extended to allow two data types to be specified, namely the data type for the data elements being accessed and the data type for the resultant data elements to be loaded into the registers, or stored to memory. Accordingly, Figures 21A to 21C illustrate the operation performed by the instruction<br>
VLB 2.32.S16 {DO, Dl, D2, D3}, [rl]<br>
As shown in Figure 21 A, the reglist state is collected, identifying registers DO 270, Dl 280, D2 290 and D3 300.- Then, as shown by Figure 2IB, this register state is split into st vectors (i.e. 2) of dt sized (i.e. 32-bit) data elements, since this instruction<br>
specifies that by the time the data elements are stored within the registers, they will be 32 bits in length.<br>
As also specified by the instruction, the data elements in memory are 1 6-bits in length, and accordingly once the data elements have been accessed from the memory 310, they will be passed through some transformation logic 340 (which optionally can be incorporated as part of the reordering logic 24) which is used to then extend each of the 16-bit data elements to form new 32-bit data elements 342. These data elements are de-interleaved so that data elements of the first component are stored within registers DO and Dl, whilst data elements of the second component are stored within registers D2 and D3.<br>
Figures 22A to 22C illustrate a further example, and in particular illustrate the operation of the instruction.<br>
VLD2.16 {D0[2], Dl[2]}, [rl]<br>
Whilst this instruction can share the same syntax as the previous instructions, this instruction is conceptually a different type of instruction, in that rather than loading data elements from a continuous block of memory in which the data elements are stored as an array of structures, this load instruction only loads a single structure. Further., the data elements of the single structure that are loaded can be placed into any chosen lane of processing within the specified registers. Hence, when considering 64-bit wide registers, and 16-bit data elements, there are four possible lanes of processing within which the data elements can be placed. In preferred embodiments, the chosen lane for the particular instruction is indicated within the reglist data by identifying the particular lane.<br>
Considering Figure 22A, it can be seen that when the reglist state is collected, this identifies lane 2 320 of register D03 and lane 2 325 of register Dl. As shown in Figure 22B, these are then split into .st vectors (i.e. 2) of dt sized (i.e. 16-bit) data elements. Thereafter, as shown in Figure 22C, once the structure 312 has been accessed from the memory 310, the reordering logic 24 is arranged to direct the data<br>
element x0 to lane 2 of the DO register 330, whilst directing the data element y0 to lane 2 of the Dl register 335. In this example, it will be appreciated that the lanes can be identified in the range from 0 to 3.<br>
For the interested reader, the following tables identify various types of load and store instructions that may be provided in one particular embodiment:<br>
(Table Removed)<br>
In one embodiment, the reordering logic 24 of figure 1 takes the form illustrated in figure 23. The logic of figure 23 includes two multiplexers 350, 355 at its inputs, which in the event of a load instruction are arranged to receive data from a load FIFO 23 associated with the LSU 22 illustrated in figure 1, or in the event of a store instruction are arranged to receive data from the SDVDD register store 20. Further, in some situations, a load instruction may also cause the logic of figure 23 to receive data from the SIMD register store 20. The multiplexers 350, 355 are controlled to choo.se between the different inputs, and to route the chosen inputs to the associated input registers 360, 365. In one embodiment, each input register is able to store 64 bits of data. The data stored in the input registers is then read through the crossbar multiplexer 375 into the register cache 380, crossbar control register 370 providing drive signals to the crossbar multiplexer to direct individual bytes of data received from the input registers to desired byte locations within the register cache. The values in control register 370 are derived by the instruction decoder.<br>
. As shown in figure*23, the register cache 380 can be considered as consisting of four registers, and in one embodiment each register is 64 bits in length.<br>
After data has been stored in the register cache 380, it can then be read via output multiplexers 385 to either the store data FIFO 23' associated with the LSU 22 (in the event of a store instruction), or the SIMD register file 20 (in the event of a load instruction).<br>
Whilst the byte crossbar multiplexer 375 can read the input registers at byte granularity and write into the register cache at byte granularity, the write multiplexers 385 read from the register cache at 64-bit granularity.<br>
The reordering logic 24 is largely autonomous from the rest of the SIMD processing logic 18, but is given instructions in program order in the same fashion as other functional units within the integrated circuit. In one embodiment, it has two register file read ports and two write ports which it controls itself. In order that<br>
hazards are detected and avoided the reordering logic 24 may be arranged to communicate with some interlock logic (not shown) using scoreboards.<br>
Store instructions from the SIMD register file 20 are performed out-of-order with respect to other SIMD instructions, but remain in-order with respect to other store instructions from the SIMD register file. Pending stores are kept in a queue, and when the store data is ready it is read and passed into the store FIFO 23' associated with the LSU 22 via the reordering logic 24.<br>
hi one embodiment, all data passing between memory and the SIMD register file 20 is routed via the reordering logic 24. However, in an alternative embodiment, a bypass path around the reordering logic 24 may be provided for situations where it is determined that no reordering is required.<br>
The register cache 380 is referred to as a "cache" since under certain conditions it caches register values before they are written to the SIMD register file 20. The register cache holds data in the format that data is to be output from the reordering logic 24.<br>
Figures 24A to 24C illustrate the operation of the reordering logic 24 to implement the necessary reordering required when performing an instruction of the type VLD 3.16 {DO, D1,D2}, [rl].<br>
Once the data has been loaded by the LSU 22, then in a first cycle (as shown in Figure 24A) 64 bits of the retrieved data is loaded via multiplexer 350 into the input register 360, whilst the next 64 bits are loaded via the multiplexer 355 into the input registers 365. In the example illustrated in figures 24A through 24C, it is assumed that the structure format represents a 3D vector having components x, y, z. hi the next cycle, as shown in Figure 24B, the 16-bit data elements within the input registers are read into the register cache 380 via the byte crossbar multiplexer 375 which reorders the data so that any data elements relating to x components are placed in a first register, any data elements relating to y components are placed in a second<br>
register, and any data elements relating to z components are placed in a third register of the register cache. Also during this cycle, the next 64 bits of data from the load FIFO 23 are loaded via multiplexer 350 into the input register 360.<br>
In the next cycle, as shown in Figure 24C, the data elements from the input register 360 are routed through the byte crossbar multiplexer into the register cache, with the x, y and z components being de-interleaved as discussed earlier. As shown in figure 24C, this results in the register cache containing four x components in a first register, four y components in a second register, and four z components in a third register. The contents of the register cache can then be output via the write multiplexers 385, two registers at a time, to the registers specified by the load instruction.<br>
Figures 25A-25D illustrate a second example of the flow of data through the reordering logic in order to perform the necessary reordering required when executing the instruction VLD 3.16 {D0[l], Dl[l], D2[l]}, [rl].    In accordance with this instruction, data is going to be loaded into a particular lane of the registers DO, Dl and D2, namely the second 16-bit wide lane of four 16-bit wide lanes within those registers.  Before a data element can be stored in a particular lane of a register, the current contents of the register need to be retrieved, so that when the register is subsequently written to, the contents of the register are written as a whole.   This feature avoids the need to provide for any writing to only a portion of a register in the SMD register file 20. Accordingly, during a first cycle, as shown in Figure 25 A, the current contents of the registers DO and Dl are read fromxthe SDVED register file via the multiplexers 350, 355 into the input registers 360, 365.   In the next cycle, as shown in figure 25B, these contents are read into the register cache 380 through the crossbar multiplexer 375 with the contents of DO being placed in a first register and the contents of Dl being placed in a second register of the register cache. During the same cycle, the contents of the register D2 are retrieved from the SEV1D register file via the multiplexer 350 and stored in the input register 360.<br>
In the next cycle, as shown in Figure 25 C, the contents of the register D2 are read into the register cache 380 via the crossbar multiplexer 375, such that they are stored in a third register of the register cache. During the same cycle, the data structure the subject of the load, which typically will have already have been retrieved by the LSU, is read from the load FIFO 23 via the multiplexer 350 into the input registers 360. In the example illustrated in figure 25C, it is again considered that the structure in memory represents 3D vector data with components x, y and z. In the next cycle, as shown in Figure 25D, the x, y and z components are read into the second lane of data elements via the crossbar multiplexer 375, so that the data element XQ overwrites within the register cache the previous contents of the second lane of register DO, the component yo overwrites within the register cache the data element previously in the second lane of the register Dl, and the component zO overwrites within the register cache the data element previously stored in the second lane of the register D2.<br>
It will be appreciated that at this point the actual contents of the registers DO, Dl and D2 in the SIMD register file have not yet changed. However, the data stored in the register cache can now be output via the write multiplexers 385 back to the registers DO, Dl, D2 to overwrite the previous contents. As a result, it can be seen that a single load instruction can be used to load the components of a particular structure from memory, and to then insert the individual components of that structure into different registers at a chosen lane location.<br>
Figures 25E to 25H illustrate a third example of a flow of the data through the reordering logic in order to perform the necessary reordering required when executing the complementary store instruction to the load instruction that was discussed earlier with reference to Figures 25A to 25D. Accordingly, Figures 25E to 25H illustrate the steps required to perform the necessary reordering when executing the instruction VST 3.16 {D0[l], Dl[l], D2[l]}, [rl]. Hence, in accordance with this instruction, data is going to be stored from the second 16-bit wide lane of the registers DO, Dl and D2 back to memory. As shown in Figure 25E, during a first cycle, the current contents of the registers DO and Dl are read from the SIMD register file via the<br>
multiplexers 350, 355 into the input registers 360, 365. In the next cycle, as shown in Figure 25F, the data elements in the second lane, i.e. the values XQ and y0, are read into a first register of the register cache 380 through the crossbar multiplexer 375. During the same cycle, .the contents of the register D2 are retrieved from the SBVID register file via the multiplexer 350 and stored in the input register 360.<br>
In the next cycle, as shown in Figure 25G, the data element in the second lane of register D2 is read into the first register of the register cache 380 via the crossbar multiplexer 375. Then, in the next cycle, as shown in Figure 25H, the x, y and z components can now be output by the write multiplexers 385 to the LSU for storing back to memory. It will be appreciated that at this stage the data elements have now been reordered into the structure format required for storage in memory.<br>
Figures 26A to 26E illustrate the reordering that takes place within the reordering logic during execution of the following sequence of four instructions: VLB 3.16 {DO, Dl, D2}, #1, [rl] VLD 3.16 (DO [1], Dl [1], D2 [1]}, [r2] VLD 3.16 {DO [2], Dl [2], D2 [2]}, [r3] VLD 3.16 {DO [3], Dl [3], D2 [3]}, [r4]<br>
Once the data identified by the first load instruction has been retrieved by the LSU, it is read via the multiplexer 350 into the input register 360 during a first cycle (see Figure 26A). In the next cycle, it is read into the register cache 380 via the crossbar multiplexer 375, such that the x, y and z components are placed inMifferent registers of the register cache. The "#1" within the first instruction signifies that each data element should be placed in the least significant data lanes of each register, and that the remaining lanes should be filled with logic 0 values, this being shown in figure 26B. Also during this cycle, the data elements identified by the second load instruction are retrieved into the input register 360. During the next cycle (see Figure 26C), the data elements stored in the. input register 360 are moved into the register cache 380 via the cross bar multiplexer 375, where they are stored in the second lane.<br>
Also during this cycle, the data elements of the third load instruction are placed within the input register 360.<br>
In the next cycle, the contents of the input register 360 are routed via the crossbar multiplexer 375 into the third lane of the register cache, whilst the data elements of the subject of the fourth load instruction are retrieved into the input register 360. This is shown in figure 26D.<br>
Finally, as shown in figure 26E, in the next cycle these data elements are routed via the crossbar multiplexer 375 into the register cache 380, where they are stored in the fourth lane. Thereafter, the 64-bit wide chunks of data in each register of the register cache can be output to the specified registers of the S1MD register file.<br>
It should be noted that in contrast to the approach taken in figures 25A to 25D, the use of the first VLD instruction illustrated with reference to figures 26A to 26E, whereby once the data elements have been placed in a particular lane, the remaining lanes are filled with 0 values, avoids the need to retrieve from the SIMD register file the current contents of any of the registers DO to D2 before any updates are made. From a review of figures 26A to 26E, it can be seen that the register cache 380 in this instance acts as a "write through cache", since it caches the data elements for a sequence of load instructions, and when each instruction is completed, writes the data to the relevant registers of the SIMD register file. However, the register file does not typically need to be read from whilst each subsequent instruction in the sequence is being performed.<br>
It is often required in data processing to reduce a so-called vector of elements to a single element by applying a commutative and associative operator 'op' between all the elements. This will be described as a folding operation. Typical examples of folding operations are to sum the elements of a vector, or find the maximum value of the elements in a vector.<br>
In a parallel processing architecture, one known approach used to perform such a folding operation is described with reference to Figure 27. The data elements [0] to [3] to be folded are contained a register rl. It will be appreciated that a benefit of parallel processing architectures is that it can enable the same operation to be performed concurrently on multiple data elements. This is concept can be more clearly understood with reference to so-called parallel processing lanes. In this example, each parallel processing lane contains one of the data element [0] to [3].<br>
Firstly, at step A, a first instruction is issued which causes rotation of the data elements by two places to form rotated data elements in register r2. This places different data elements in each processing lane so that Single Instruction Multiple Data (SIMD) operation can be applied at step B..<br>
Thereafter, at step B, a second instruction is issued which causes a SIMD operation to be performed on the data elements in each lane. In this example, the resultant data elements of these multiple parallel operations are stored in register r3. Accordingly, it can be seen that entries in r3 now contain the results of the combination of half of data elements of the register rl (i.e. r3 contains: [0] op [2]; [1] op [3]; [2] op [0]; and [3] op [1]).<br>
Next, a third instruction is issued which causes the results stored in the register r3 to be rotated by one parallel processing lane at step C and stored in the register r4. Once again, the rotation of the data elements of stored in r3 with respect to those of r4 enables different data elements to occupy the same parallel processing lane.<br>
Finally, at step D, a fourth instruction is issued which causes a further single instruction multiple data operation to be performed on data elements stored in each lane and the results are stored in register r5.<br>
Accordingly, it can be seen that by using just four instructions all the data elements across the register can be combined and the results stored in each entry in<br>
the register r5 (i.e. each entry in r5 contains: [0] op [1] op [2] op [3]).  The resultant data element can be read as required from any of the four entries in the register r5.<br>
Figure 28 illustrates the principle of a folding instruction of one embodiment. Unlike the conventional arrangement of parallel processing lanes (which is described with reference to Figure 27) in which each parallel processing lane has a fixed width throughout the lane which is equal to the width of one data element, in this embodiment the arrangement of the parallel processing lanes differs. In this new arrangement., the width of each parallel processing lane at its input is equal to the width of at least two source data elements and at its output is generally equal to the width of one resultant data element. It has been found that arranging the parallel processing lanes in this way provides significant advantages over prior art arrangements since groups of data elements (for example pairs of data elements) within a single register can be the subject of parallel processing operations. As will be clear from the discussion .below, this obviates the need to perform the data manipulation operations of the prior art arrangements (i.e. the rotation operations) since there is no need to arrange data elements in the correct entry locations in further registers in order to enable multiple operations to occur in parallel.<br>
Accordingly, source data elements d[0] to d[3] are provided in respective entries in a register. The adjacent source data elements d[0] and d[l] can be considered as a pair of source data elements. The source data elements d[2] and d[3] can also be considered as a pair of source data elements. Hence, in this example, there are two pairs of source data elements.<br>
At step (A) an operation is performed on each pair of source data elements within the register in order to generate a resultant data element, the same operation occurring on each adjacent pair of source data elements.<br>
Hence, it will be appreciated that the pair of source data elements and the corresponding resultant data element all occupy the same lane of parallel processing. It can be seen that after step (A) the number of resultant data elements is half that of<br>
the number of source data elements. The data elements d[2] op d[3] and d[0] op d[l] can also be considered as a pair of source data elements.<br>
At step (B) a further identical operation is performed on a pair of source data elements in order to generate a resultant data element d[0] op d[l] op d[2] op d[3]. It can be seen that after step (B) the number of resultant data elements is also half that of the number of source data elements. As mentioned previously, the operations are commutative and associative operations and so the same resultant data elements are generated irrespective of the exact order of combination of the source data elements.<br>
.Hence, it can be seen that the number of source data elements can be halved as a result of each operation and that the same operation can be performed on those source data elements in order to produce the required result. Accordingly, it can be seen that the required resultant data element can be generated in just two operations whereas the prior art arrangement of Figure 27 needed to perform at least four operations. It will be appreciated that this improvement in efficiency is achieved through performing parallel processing operations on groups of data elements within a source register. Although just two pairs of source data elements have been illustrated for reasons of clarity, it will be appreciated that any number of pairs of source data elements could have been the subject of the operation. Also, whilst operations on pairs of source data elements have been illustrated for reasons of clarity, it will be appreciated that any number of source data elements (e.g. three, four or more) could<br>
have been the-subject of the operation.<br><br>
In practice, for efficiency reasons, the folding instruction is arranged to perform parallel operations on a minimum number of data elements, determined by the smallest supported register size in the register data file 20. Figure 29 illustrates an implementation which generates the same number of resultant data elements as the number of source data elements.<br>
Source data elements d[0] to d[3] are provided in a register Dn. In order to generate the same number of resultant data elements, the source data elements d[0] to<br>
d[3] are also provided in a register Dm. It will be appreciated that the registers Dn and Dm are likely to be the same register with the SMD processing logic 18 reading each source data element from the register Dn twice in order to generate duplicated resultant data elements.<br>
At step (A), a single SIMD instruction is issued, each pair of source data elements have an operation performed thereon and a corresponding resultant data element is generated.<br>
At step (B), another single SIMD instruction is issued to cause each pair of source data elements to have an operation performed thereon in order to generate a corresponding resultant data element.<br>
Accordingly, it can be seen that all the source data elements have been combined to produce resultant data elements.<br>
Figures 30a to 30d illustrate the operation of various folding instructions which follow the same syntax described elsewhere. It will be appreciated that where two source registers are indicated that these may be the same register. Also, it will be appreciated that each source register could be specified as the destination register in order to reduce the amount of register space utilised.<br>
Figure 30a illustrates the operation of a SIMD folding instruction whereby pairs of source data elements from the same register, represented by 'n' bits, have an operation performed thereon in order to generate resultant data elements represented by 2n bits. Promoting the resultant data elements to have 2n bits reduces the probability that an overflow will occur. When promoting the resultant data elements, they are typically sign-extended or padded with O's. The following example summing folding instructions support such an operation:<br>
Mnemonic      Data Type      Operand Format         Description<br>
VSUM .S16.S8	Dd, Dm	(add adjacent pairs of elements<br>
and promote)<br><br>
.S32.S16<br>
.S64.S32<br>
.U16.U8<br>
.U32.U16<br>
.U64.U32<br><br>
Qd,Qm<br><br>
In the particular example shown in Figure 30a (VSUM.S32.S16 Dd, Dm), a 64-bit register Dm containing four 16-bit data elements are folded and stored in a 64-bit register Dd containing two 32-bit resultant data elements.<br>
Figure 3 Ob illustrates the operation of a SIMD folding instruction whereby pairs of source data elements from different registers, represented by 'n' bits, have an operation performed thereon in order to generate resultant data elements also represented by 'n' bits. The following example summing, maximum and minimum instructions support such an operation:<br><br>
Mnemonic      Data Type VSUM .18 .116 .132 .F32<br><br>
Operand Format Dd, Dn, Dm<br><br>
Description<br>
(add adjacent pairs of elements)<br><br><br><br>
Mnemonic      Data Type VFMX .88 .816 .832 .US .U16 .U32 .F32<br><br><br><br>
Operand Format Dd, Dn, Dm<br><br>
Description<br>
(take maximum of adjacent pairs)<br><br>
Mnemonic      Data Type      Operand Format         Description<br>
VFMN .88	Dd, Dn, Dm	(take minimum of adjacent pairs)<br>
.816 .832 .U8 .U16 .U32 .F32<br>
In the particular example shown in Figure 30b (VSUM.I16 Dd, Dn, Dm), two 64-bit registers Dm, Dn, each containing four 16-bit data elements are folded and stored in a 64-bit register Dd containing four 16-.bit resultant data elements.<br>
Figure 30c illustrates the operation of a SIMD folding instruction whereby pairs of source data elements from the same register, represented by 'n' bits, have an operation performed thereon in order to generate resultant data elements also represented by {n' bits. In the particular example shown in Figure 30c, a 128-bit register Qm containing eight 16-bit data elements are folded and stored in a 64-bit register Dd containing four 16-bit resultant data elements.<br>
Figure 30d illustrates the operation of a SIMD folding instruction similar to Figure 3 Ob, but where Dm=Dn which causes the resultant data values to be duplicated in the destination register. Pairs of .source data elements from the same register, represented by cn' bits, have an operation performed thereon in order to generate resultant data elements also represented by 'n' bits, each of which is- duplicated in another entry in the register. In the particular example shown in Figure 30d, a 64-bit register Dm containing four 16-bit data elements are folded and stored in a 64-bit register Dd containing two sets of two 16-bit resultant data elements.<br>
Figure 31 illustrates schematically example SIMD folding logic which can support folding instructions and which is provided as part of the SIMD processing logic 18. For sake of clarity, the logic shown is used to support instructions which<br>
select the maximum of each adjacent pair. However, it will be appreciated that the logic can be readily adapted to provide support for other operations, as will be described in more detail below.<br>
The logic receives source data elements (Dm[0] to Dm[3]) from the register Dm, optionally together with source data elements (Dn[0j to Dn[3]) from the register Dn. Alternatively, the logic receives source data elements (Qm[0] to Qm[7]) from the register Qm. Each pair of adjacent source data elements are provided to an associated folding operation logic unit 400. Each folding operation logic unit 400 has an arithmetic unit 410 which subtracts one source data element from the other and provides an indication of which was the greater over the path 415 to a multiplexer 420. Based upon the indication provided over the path 415, the multiplexer outputs . the greater value source data element from the operation logic unit 400. Hence, it can be seen that each folding operation logic unit 400 is arranged to output the maximum of the associated adjacent pair of data elements over respective paths 425, 435, 445, 455.<br>
Selection and distribution logic 450 receives the resultant data elements and provides these as required over paths 431 to 434 for storage in entries of a register Dd in the SIMD register data file 20 in support of the above-mentioned instructions. The operation of the selection and distribution logic 450 will now be described.<br>
In order to support the instruction illustrated in Figure 30a, source data elements Dm[0] to Dm[3] are provided to the lower two folding operation logic units 400. The folding operation logic units 400 output data elements over the paths 425 and 435. The paths 431 and 432 will provide Dm[0] op Dm[l] in a sign-extended or zero-extended format, whilst paths 433 and 434 will provide Dm[2] op Dm[3] in a sign-extended or zero-extended format. This is achieved by signals being generated by the SIMD decoder 16 in response to the folding instruction which cause the multiplexers 470 to select their B input, the multiplexers 460 to select either sign-extension or zero-extension, the multiplexers 490 to select their E input and the multiplexer 480 to select its D input.<br>
In order to support the instruction illustrated in Figure 30b, source data elements Dm[0] to Dm[3] are provided to the lower two folding operation logic units 400, whilst source data elements Dn[0] to Dn[3] are provided to the upper two folding operation logic units 400. The folding operation logic units 400 output data elements over the paths 425, 435, 445 and 455. Path 431 will provide Dm[0] op Dm[l], path 432 will provide Dm[2] op Dm[3], path 433 will provide Dn[0] op Dn[l], and path 434 will provide Dn[2] op Dn[3]. This is achieved by signals being generated by the SIMD decoder 16 in response to the folding instruction which cause the multiplexers 470 to select their A input, the multiplexer 480 to select its C input and the multiplexers 490 to select their E input.<br>
In order to support the instruction illustrated in Figure 30c, source data elements Qm[0] to Qm[7] are provided to the folding operation logic units 400. The folding operation logic units 400 output data elements over the paths 425, 435, 445 and 455. Path 431 will provide Qm[0] op Qm[l], path 432 will provide Qm[2] op Qm[3], path 433 will provide Qm[4] op Qm[5], and path 434 will provide Qm[6] op Qm[7]. This is achieved by signals being generated by the SEVED decoder 16 in response to the folding instruction which cause the multiplexers 470 to select their A input, the multiplexer 480 to select its C input and the multiplexers 490 to select their E input.<br>
In order to support the instruction illustrated in Figure 30d, source data elements Dm[0] to Dm[3] are provided to the lower two folding operation logic units 400. The folding operation logic units 400 output data elements over the paths 425 and 435. Path 431 will provide Dm[0] op Dm[l], path 432 will provide Dm[2] op Dm[3], path 433 will provide Dm[0] op Dm[l], and path 434 will provide Dm[2] op Dm[3]. This is achieved by signals being generated by the SIMD decoder 16 in response to the folding instruction which cause the multiplexers 470 to select their A input, the multiplexer 480 to select its D input and the multiplexers 490 to select their F input. Alternatively, it will be appreciated that the source data elements could have instead also been provided to the upper two folding operation logic units 400 and the<br>
same operation as that illustration to reference to Figure 30b could have been performed which would reduce the complexity of the selection and distribution logic 450.<br>
Accordingly, it can be seen that this logic enables a resultant data element to be generated from two adjacent source data elements in a single operation directly from the source data elements.<br>
As mentioned above, the folding operation logic unit 400 may be arranged to perform any number of operations on the source data elements. For example, further logic could readily be provided to selectively enable the multiplexer 420 to supply the minimum of the source data elements over the path 425. Alternatively, the arithmetic unit 410 could be arranged to selectively add, subtract, compare or multiply the source data elements and to output the resultant data element. Hence, it will be appreciated that the approach of the present embodiment advantageously provides a great deal of flexibility in the range of folding operations that can be performed using this arrangement.<br>
Also, it will be appreciated that whilst the logic described with reference to Figure 31 supports 16-bit operations, similar logic could be provided in order to support 32 or 8-bit operations, or indeed any other sizes.<br>
Figure 32 illustrates the operation of a vector-by-scalar SDVID instruction. The SIMD instructions follow the same syntax described elsewhere, It will be appreciated that, as before, where two source registers are indicated, these may be the same register. Also, each source register could be specified as the destination register in order to reduce the amount of register space utilised and to enable efficient recirculation of data elements.<br>
A register Dm stores a number .of data elements Dm[0] to Dm[3]. Each of these data elements represent a selectable scalar operand. The vector by scalar SDVID instruction specifies one of the data elements as the scalar operand and performs an<br>
operation using that scalar operand in parallel on all the data elements in another register Dn, the results of which are stored in a corresponding entry in the register Dd. It will be appreciated that the data elements stored in the registers Dm, Dn and Dd could all be of differing sizes. In particular, the resultant data elements may be promoted with respect to the source data elements. Promoting may involve zero padding or sign extending to convert from one .data type to another.. This may have the additional advantage of guaranteeing that an overflow can not occur.<br>
Being able to select one scalar operand for a SIMD operation is particular efficient in situations involving matrices of data elements. Different scalar operands can be written to the SIMD register file 20 and then readily selected for different vector-by-scalar operations without the need to re-write data elements or move data elements around. The following example multiplication instructions support such an operation:<br>
Multiply Subtract by Scalar<br>
Mnemonic      Data Type      Operand Format        Description<br>
VMLS.I16	Dd, Dn, Dm[x]	(Vd[i] = Vd[i] - (Vn[i] * Vm[x]))<br>
.132	Qd, Qn, Dm[x]<br>
.F32<br>
.S32.S16        Qd,Dn,Dm[x]<br>
.S64.S32<br>
.U32.U16<br>
.U64.U32<br>
Vd, Vn and Vm describe vectors of elements constructed from the chosen register format and chosen data type. Elements within this vector are selected using the array notation [x]. For example, Vd[0] selects the lowest element in the vector Vd.<br>
An iterator i is used to allow a vector definition; the semantics hold for all values of i where i is less than the number of elements within the vector. The instruction definitions provide 'Data Type' and 'Operand Format' columns; a valid<br>
instruction is constructed by taking one from each column.<br><br>
Figure 33 illustrates an arrangement of scalar operands HO to H31 in the SIMD register file 20. As mentioned elsewhere, the preferred number of bits used in a field of the instruction to specify the location of a data element in the SIMD register file 20 is 5-bits. This enables 32 possible locations to be specified. It will be appreciated that one possible way to map the scalar operands onto the SIMD register file 20 would have been to have placed each operand in the first entry in each of the registers DO to DSJ. However, the SIMD register file 20 is instead arranged to map or alias the selectable scalar operands to the first 32 logical entries in the SIMD register<br>
file 20. Mapping the scalar operands in this way provides significant advantages. Firstly, by locating the scalar operands in contiguous entries minimises the number of D registers used to store the scalar operands which in turn maximises the number of D registers available to store other data elements. By having the scalar operands stored in contiguous entries enables all scalar operands within a vector to be accessed, which is particularly beneficial when performing matrix or filter operations. For example, a matrix by vector multiplication requires a vector by scalar operation to be performed for each scalar chosen from the vector. Furthermore, storing the selectable scalar operands in this way enables, from at least some of the registers, all the scalar operands to be selected from those registers.<br>
Figure 34 illustrates schematically logic arranged to perform a vector-by-scalar operation of an embodiment.<br>
The source data elements (Dm[0] to Dm[3]) provided from the register Dm. Each source data element is provided to scalar selection logic 510 which comprises a number of multiplexers 500. Each source data element is provided to one input of each multiplexer 500 (i.e. each multiplexer receives source data elements Dm[0] to Dm[3]. Hence, it can be seen that each multiplexer can output any of the source data elements Dm[0] to Dm[3j. hi this embodiment, each multiplexer is arranged to output the same source data element. Hence, the scalar selection logic 510 can be arranged to select and output one scalar operand. This is achieved by signals being generated by the SIMD decoder 16 in response to the vector-by-scalar instruction which cause the multiplexers to output one of the source data elements Dm[0] to Dni[3] as the selected scalar operand.<br>
Vector-by-scalar operation logic 520 receives the selected scalar operand and also receives source data elements Dn[0] to Dn[3] provided from the register Dn. Each source data element is provided to the vector-by-scalar operation logic 520 which comprises a number of operation units 530. Each source data element is provided to one of the operation units 530 (i.e. each operation unit receives one of the source data elements Dm[0] to Dm[3] and the selected scalar operand). The vector-by-scalar<br>
operation logic 520 performs an operation on the two data elements and outputs a resultant data element for storage in respective entries of a register in the SIMD register data file 20 in support of the above-mentioned instructions. This is achieved by signals being generated by the SIMD decoder 16 in response to the vector-by-scalar instruction which cause the operations units 530 to perform the required operation on the received data elements.<br>
Accordingly, it can be seen that this logic enables one of data element of a source register to be selected as a scalar operand and to perform the vector-by-scalar operations using the same scalar operand on all source data elements from another register.<br>
Figure 35 shows a known way of dealing with a shift and narrow operation during SIMD processing. As can be seen three separate instructions (SHR, SHR and PACK LO) are required to perform this operation. Intermediate values are shown with dotted lines for clarity in Figure 35 and in Figures 36 and 38.<br>
Figure 36 shows a shift right and narrow operation according to the present technique. The architecture of the present embodiment is particularly well adapted to process shift and narrow operations and can do so in response to a single instruction. The instruction is decoded by an instruction decoder within SIMD decoder 16 (see Figure 1). In this example the data in register Qn, located in SIMD register file 20 (see Fig 1) is shifted right by 5 bits and then the remaining data is rounded and then the 16 right hand side bits are transferred across to the destination register Dd, also located in SIMD register file 20. The hardware is able to optionally support rounding and/or saturation of the data depending on the instruction. Generally shifting right instructions do not require saturation as when dealing with integers shifting right generally produces a smaller number. However, when shifting right and narrowing saturation may be appropriate.<br>
Saturation is a process that can be used to restrict a data element to a certain range by choosing the closest allowable value.   For example if two unsigned 8-bit<br>
integers are multiplied using 8 bit registers, the result may overflow. In this case the most accurate result that could be given is binary 11111111, and thus, the number will be saturated to give this value. A similar problem may arise when shifting and narrowing, whereby a number that is narrowed cannot fit into the narrower space. In this case in the case of an unsigned number, when any of the bits that are discarded in the shift step are not zero then the number is saturated to the maximum allowable value, hi the case of a signed number the problem is more complicated. In this case the number must be saturated to the maximum allowable positive number or maximum allowable negative number when the most Significant bit is different from any of the discarded bits.<br>
Saturation can also occur where the type of data element input is different to<br>
that output, e.g. a signed value may be shifted and narrowed, saturated and an<br>
unsigned value output. The ability to output different data types can be very useful.<br>
For example, in pixel processing luminance is an unsigned value, however, during<br>
processing this value it may be appropriate to process it as a signed value. Following<br>
processing an unsigned value should be output, however simply switching from a<br>
signed to an unsigned value could cause problems, unless the ability to saturate the<br>
value is provided. For example, if during processing due to slight inaccuracies the<br>
luminance value has dropped to a negative number, simply outputting this negative<br>
signed value as an unsigned value would be a nonsense. Thus, the ability to saturate<br>
any negative number to zero prior to outputting the unsigned value is a very useful<br>
tool.	<br>
Examples of possible formats for different shift instructions are given below in tables 6 and 7. As can be seen the instructions specifies that it is vector instruction by having a V at the front, a shift is then specified with the SH and in the case of shifting with immediates, the direction right or left is then indicated by an R or L. The instruction then comprises two types, as in table 0, the first being the size of the data elements in the destination register and the second being the size of the element in the source register. The next information comprises the name of the destination register<br>
and of the source register and then an immediate value may be given, this value indicates the number of bits that the data is to be shifted and is preceded by a #. Modifiers to the general format of the instruction may be used5 a Q is used to indicate the operation uses saturating integer arithmetic and a R is used to indicate that the operation performs rounding More details of the format of the instructions are given earlier in the description, for example, in table 0.<br>
Table 7 shows instructions for shifting by signed variables. This instruction is the same as the shifting left by immediates, but instead of providing an immediate with the instruction a register address indicating where a vector of signed variable is stored is provided with the instruction. In this case a negative number indicates a right hand shift. As the number of bits to be shifted are stored in a vector, a different signed variable can be stored for each data element so that they can each be shifted by different amounts. This process is shown in more detail in Figure 39.<br>
TABLE  6<br>
Shift by Immediate<br>
Immediate shifts use an immediate value encoded within the instruction to shift all elements of the source vector by the same amount. Narrowing versions allow casting down of values, which can include saturation, while Long versions allow casting up with any fixed point.<br>
Shift with accumulate versions are provided to support efficient scaling and accumulation found in many DSP algorithms. Right shift instructions also provide rounding options. Rounding is performed by in effect adding a half to the number to be rounded. Thus, when shifting right by n places 2""1 is added to the value prior to shifting it._ Thus, in the following table round(n) - 211"1 if n  or 0 if n
Bitwise extract instructions are included to allow efficient packing of data.<br>
(Table Removed)<br>
Shift by Signed Variable<br>
Shifts in this section perform shifts on one vector of elements controlled by the signed shift amounts specified in a second vector. Supporting signed shift amounts allows support for shifting by exponent values, which may reasonably be negative; a<br><br>
negative control value will perform a shift right. Vector shifts allow each element to be shifted by a different amount, but can be used to shift all lanes by the same amount by duplicating the shift control operand to all lanes of a vector before performing the shift. The signed shift control value is an element is the same size as the smallest operand element size of the operand to be shifted. However, the shifter variable is interpreted using only the bottom 8-bits of each lane to determine the shift amount. Rounding and Saturation options are also available.<br>
(Table Removed)<br>
Thus, as can be seen the hardware supports instructions that are able to specify both the size of the source data element and resultant data element and also sometimes the number of places that the data is to be shifted. This makes it an extremely adaptable and powerful tool.<br>
The shift right and narrow operation shown in Figure 36 has a number of possible applications. For example, in calculations involving fixed point numbers where a certain accuracy is required, it may be appropriate to place a say 16-bit number somewhere towards the centre of a 32-bit data value to reduce the risk of data over or under flow, while calculations are performed. At the end of the calculations a 16-bit number may be required, and thus a shift and narrow operation as shown in Figure 36 would be appropriate. The possibility envisaged by the present technique of using different sized source and destination registers is particularly effective here and allows different sized data to remain in a particular lane during SDVTD processing.<br>
A further use of the shift and narrow operation similar to that illustrated in Figure 36 could be in the processing of colour pixel data. SIMD processing is particularly appropriate for video data as video data comprises many pixels that all require the same operation to be performed upon them. Thus, different pixel data can be in different lanes in a register and a single instruction can perform the same operations on all of the data. Often, video data may come as red green and blue data. This needs to be separated out before meaningful operations can be performed upon it. Figure 37 shows a typical example of red green and blue data being present in a 16-bit data element. In the example shown the blue data could be extracted by a shift left by 3 bits and narrow operation. The shift left by 3 places sends the blue data to the right of the middle of the data element, as is shown schematically by the dotted line register (representing an intermediate value), three zeros fill in the three empty positions at the right of the data value caused by the shift left of the data. The narrow operation results in the blue data and the three zeros being transferred to the resultant 8 bit-data element.<br>
In addition to shifting and narrowing the present technique can also be used to cast up and shift, this process is shown in Figure 38. In this case, the casting up is performed followed by a shift left. This operation can be used to for example transfer a 32-bit value to a 64-bit value, the 32 bit value being placed in an appropriate position within the 64 bit value. In the example shown two 32 bit values are<br>
transferred to 64 bit values by being placed at the most significant bits in the lane with zeros being added as least significant bits.<br>
Figure 39 shows the possibility of using a vector of values indicating the number of places each data element should be. shifted, the values being signed integers, negative numbers indicating a shift right. A register holding a value for each data element is used and each data element is shifted by the amount specified by the value located in its lane. The instructions for such operations are set out previously in table 7.<br>
Figure 40 schematically shows a simple multiplexing operation, hi this multiplexing operation, multiplexer 700 selects either value a or value b to be output at D depending on the value of the control bit c. c is used to select the output between a and b. c is often based upon the result of a decision such as is a &gt; b. Embodiments of the architecture provide the ability to perform multiplexing operations during SMD processing. SIMD processing is not suitable for performing branch operations and thus multiplexing can not be performed using standard if then else instructions, rather a mask is created, the mask being used to indicate which parts of two source registers a and b are to be selected.<br>
This mask consists of control values that are used to indicate which parts of two source registers a and b are to be selected. In some embodiments a one in a certain position may indicate that a certain section of b is to be selected while a zero in that position would indicate that a corresponding section of a is to be selected. This mask is stored in a general-purpose register thereby reducing the need for special purpose registers.<br>
Generation of the mask is dependent on the -multiplexing operation to be performed and is created in response to this operation. For example in the case given above a comparison of a and b is performed. This can be done on a portion by portion basis, for example corresponding data elements in the SIMD processing are<br>
compared. Corresponding data elements of b and a are compared and a value is written to the portion of the general purpose register that is being used to store the control values depending whether b is greater than a, or b is equal to or less than a. This can be done using a compare greater than instruction VCGT on all of the data elements in parallel. This instruction is provided in the instruction set of embodiments of the system. Table 8 below shows some of the wide range of comparison instructions that are provided by embodiments of the architecture.<br>
TABLES<br>
Comparison and Selection<br>
Comparison and tests of variables to generate masks can be performed which can be used to provide data plane selection and masking. It also provides instructions to select the maximum and minimum, including folding versions which can be used at the end of vectorised code to find the maximum or minimum within a vector. <br>
(Table Removed)<br>
Once the mask has been created a single instruction can be used to select either a or b using the general-purpose register containing this mask, the control register C. Thus, the data processor is controlled by C to perform the multiplexing operation of selecting either a or b.<br>
Figure 41 schematically shows an embodiment of the system wherein the selection of source values a or b is done on a bit wise basis. In this case the control register 730 has been filled with data by comparing data elements in registers a 710 and b 720. Thus, data element aO, which is say eight bits wide is compared with'data element bO having the same size. In this case a is less than or equal -to b and thus eight zeros are inserted into the corresponding portion of the control register 730. If a is greater than b 8 ones are inserted into the corresponding portion of the control register 730. A similar comparison is performed in parallel for all the data elements<br>
and corresponding control bits produced. The comparison operation that generates the control vector corresponds to the instruction VCGT.S8 c,a,b. Selection can then be performed very simply on a bit by bit basis by performing simple logical operations between the bits store in the source registers and the corresponding bits stored in the control register, each resultant bit being written to a destination register, which in this example is register 730, i.e. the results overwrite the control values. The advantage of this bitwise selection is that it is independent of data type and width and if appropriate different sized data elements can be compared.<br>
Figure 42 shows an alternative embodiment where the control is not done on a bit- wise basis but is done on a data element basis. In the embodiment shown if a data element in the control register C 730, is greater than or equal to zero then a corresponding data element in source register b 720, it is written to the destination register (in this case register 720). If, as in this example, C is a signed integer, then only the most significant bit of C needs to be considered when deciding which of a or b to select.<br>
In other embodiments other properties of C can be used to determine whether a data element from register a, 710 is to be selected, or one from data register b, 720. Examples of such properties include, whether C is odd or even, where again only one bit of the control value need to be considered, in this case the least significant bit, or if C is equal to zero, not equal to zero or greater than zero.<br>
Generally ARM instructions and in fact many other RISC instructions only provide three operands with any instruction. Multiplexing operations in general require four operands to specify two source registers a and b, a control register C and a destination register D. Embodiments of the present system take advantage of the fact that generally following a multiplexing operation, at least one of the two sets of source data or the control data is no longer required. Thus, the destination register is chosen to be either one of the two source registers or the control register. This only works as the control register is a general-purpose register and not a special register, hi embodiments of the system, three different instructions are provided in the<br>
instruction set, an instruction specific to writing back to one source register, another instruction for writing back to the other source register and a third instruction for writing to the control register. Each instruction requires just three operands, specifying two source registers and a control register. These three instructions are specified in table 9 below.<br>
TABLE 9<br>
Logical and Bitwise selection<br>
(Table Removed)<br>
Figure 43 schematically shows three examples of multiplexer arrangements corresponding to the three multiplexing instructions provided by the system. Figure 43 a shows multiplexer 701 wired to perform the instruction bitwise select VBSL. In this example, contrary to the example illustrated in Figures 41 and 42, A is selected when C is false (0), and B is selected when C is true (1). In the embodiment illustrated the destination register is the same as the control register so that the resultant values overwrite the control values. If the reverse selection was required, i.e. A is selected when C is true and B when C is false, the same circuit could be used<br>
by simply swapping the operands A and B.<br><br>
Figure 43b shows a multiplexer 702 corresponding to the instruction BIT bitwise insert if true, and results in source register A acting as both source and destination -register and being overwritten with the result data. In this example B is written into A when C is true, while if C is false the value present in register A remains unchanged. In this embodiment if the reverse selection is required, i.e. it is desired to write B to the destination register if C is false rather than true it is not<br><br>
possible to simply switch the registers around as the device does not have the symmetry of multiplexer 701.<br>
Figure 43 c shows a multiplexer 703 that is set up to correspond to the reverse selection of Figure 43b, i.e. the instruction BIF bitwise insert if false. In this embodiment the value in register A is written into register B when C is false, while when C is true the value in register B remains unchanged. As in figure 43b there is no symmetry in this system.<br>
Figure 44 schematically illustrates a sequence of bytes of data BO to By stored within a memory. These bytes are stored in accordance with byte invariant addressing whereby the same byte of data will be returned in response to reading of a given memory address irrespective of the current endianess mode. The memory also supports unaligned addressing whereby half words,' words or larger multi-byte data elements may be read from the memory starting at an arbitrary memory byte address.<br>
When the eight bytes of data BO to By are read from the memory with the system in little endian mode, then the bytes BQ to By are laid out within a register 800 in the order shown in Figure 44. The register 800 contains four data elements each comprising a half word of sixteen bits. Figure 44 also shows the same eight bytes of data BO to By being read out into a register 802 when the system is operating in big \ endian mode.<br>
In this example, the data once read out from memory into the respective SIMD register 800, 802 is subject to a squaring operation which results in a doubling of the data element size. Accordingly, the result is written in two destination SIMD registers 804, 806. As will be seen from Figure 44, the result values written respectively in the first or second of these register pairs 804, 806 vary depending upon the endianess mode in which the data has been read from the memory. Accordingly, a SIMD computer program which is to further manipulate the squared result values may<br>
need to be altered to take account of the different layout of the data depending upon the endianess mode. This disadvantageously results in the need to produce two different forms of the computer program to cope with different endianess in the way that the data has been stored within the memory.<br>
Figure 45 addresses this problem by the provision of reordering logic 808. The data processing system includes memory accessing logic 810 which serves to read the eight bytes of data Bo to B? from the memory starting at a specified memory address and utilising the byte invariant addressing characteristic of the memory. The output of the memory accessing logic 810 accordingly presents bytes read from a given memory address at the same output lane irrespective of the endianess mode. Thus, in the example illustrated in which the data elements are half words, a byte recovered from a particular memory address may be the most significant portion of a half word when in one endianess mode whilst it is the least significant portion of a half word in the other endianess mode.<br><br>
The data element reordering logic 808 is responsible for reordering the data elements retrieved from the memory by the memory access logic 810 such that the data elements which are loaded into the SIMD register 812 will be in a form consistent with the data having been stored in a little endian form and loaded without rearrangement irrespective of the endianess mode being used within .the memory system. In the case of a little endian mode being used within the memory system, the data element reordering logic 808 will not reorder the bytes and will pass these through unaltered. However, in the case of the data being stored in a big endian form within the memory system, the data element reordering logic 808 serves to reverse the order of the bytes read from the memory within each half word so that the half word data element will appear in little endian form within the SIMD register 812. In this way, a single SIMD computer program can perform the correct data processing operations upon the data elements transferred into the SIMD register irrespective of the endianess mode in which these were stored within the memory. It will be seen from Figure 45 that the data element reordering logic 808 is responsive to a signal indicating the endianess mode being used by the memory and a signal indicating the<br>
size of the data elements concerned. The endianess mode being used will control whether or not any reordering is required and the size will control the nature of the reordering applied if it is required. It will be seen that when the data is stored within the memory in little endian mode and the SIMD registers are little endian, then no reordering is required. Conversely, if the SIMD registers assumed a big endian form then no reordering would be required when the data was stored in big endian form within the memory but reordering would be required when the data was stored within a little endian form within the memory.<br>
Figure 46 illustrates an example similar to that of Figure 45 except that in this example the data elements are 32-bit data words. As will be seen, when these data words are stored within the memory in a big endian form, the reordering applied by •the data element reordering logic 808 reverses the byte order of four byte data elements as retrieved by the memory accessing logic 810 so that these are stored into the SIMD register 812 in a form consistent with the data having been stored in a little<br>
*<br>
endian form in the memory and loaded without rearrangement.<br>
It will be appreciated that in the context of the processor system as a whole described herein, the memory accessing logic 810 and the data element reordering element 808 may form part of the previously described load store unit. The data element reordering logic 808 may also be used to compensate for memory system endianess when reading data into the scalar registers when a particular endianess is<br>
being assumed for the data within the scalar registers.<br><br>
Figure 47 illustrates the data element reordering logic 808 hi more detail. It will be seen that this is formed as three levels of multiplexers controlled by respective controlled signals Z, Y and X. These three layers are respectively responsible for reversing positions of adjacent bytes, adjacent half words and adjacent words of data. The control signals X, Y and Z are decoded from an endianess signal which when asserted indicates big endian mode and a size signal indicating respectively 64, 32 or 16 bit data element size as is illustrated in Figure 47. It will be appreciated that many<br>
other forms of data element reordering logic could be used to achieve the same functional result as is illustrated in Figures 45 and 46.<br>
The memory access instruction which is used to perform the byte invariant addressing of the memory conveniently uses a memory address pointer which is held within a register of a scalar register bank of the processor. The processor supports data processing instructions which change the data element size as well as data processing instructions which operate on. selected ones of data elements within a SMD register.<br>
Figure 48 illustrates a register data store 900 which includes a list of registers DO, Dl each serving as a table register, an index-register D7 and a result register D5. It will be seen that the table registers DO, Dl are contiguously numbered registers within the register data store 900. The result register D7 and the index register D5 are arbitrarily positioned relative to the table registers and each other. The syntax of the instruction corresponding to this data manipulation is shown in the figure.<br>
Figure 49 schematically illustrates the action of a table lookup extension instruction. This instruction specifies a list of registers to be used as a block of table registers, such as by specifying the first register in the list and the number of registers in the list (e.g. one to four). The instruction also specifies a register to be used as the index register D7 and a register to be used as the result register D5. The table lookup extension instruction further specifies the data elements size of the data elements stored within the table registers DO, Dl and to be selected and written into the result register D5. In the example illustrated, the table registers DO, Dl each contain eight data elements. Accordingly, the index values have an in-range span of 0 to 15. Index values outside of this predetermined range will not result in a table lookup and instead the corresponding position within the result register D5 will be left unchanged.  As illustrated, the fourth and sixth index values are out-of-range in this way.  The other index values point to respective data elements within the table registers DO, Dl and these data elements are then stored into the corresponding positions within the result register D5.   There is a one-to-one correspondence between index value position<br>
within the index register D7 and data element position within the result register D5. The values marked "U" in the result register D5 indicate that the values stored at those locations are preserved during the action of the table lookup extension instruction. Thus, whatever bits were stored in those locations prior to execution of the. instruction are still stored within those positions following the execution of the instruction.<br>
Figure 50 illustrates the index values from Figure 49 which are then subject to a SEMD subtraction operation whereby an offset.of sixteen is applied to each of the index values. This takes the previously in-range index values to out-of-range values. The previously out-of-range values are now moved in-range. Thus, when the index register D7 containing the now modified index values is reused hi another table lookup extension instruction, the fourth and sixth index values are now in-range and result in table lookups being performed in table registers DO, Dl (or other different<br>
registers which may be specified in the second table lookup extension instruction)<br>
i which have also been reloaded prior to the execution of a second table lookup<br>
extension instruction. Thus, a single set of index values within an index register D7 may be subject to an offset and then reused with reloaded table registers DO, Dl to give the effect of a larger table being available.<br>
Figure 51 illustrates further a table lookup instruction which may be provided in addition to the table lookup extension instruction. The difference between these instructions is that when an out-of-range index value is encountered in a table lookup instruction, the location within the result register D5 corresponding to that index value is written to with zero values rather than being left unchanged. This type of behaviour is useful in certain programming situations. The example Figure 51 illustrates three table registers rather than two table registers. The first, third, fourth, sixth and seventh index values are out-of-range. The second, fifth and eighth index values are in-range and result in table lookups of corresponding data elements within the table registers.<br>
As mentioned earlier, load and store instructions are provided for moving data between the SIMD register file 20 (see Figure 1) and memory. Each such load and store instruction will specify a start address identifying the location within the memory from which the access operation (whether that be a load operation or a store operation) should begin, hi accordance with the load and store instructions of embodiments, the amount of data that is the subject of that load or store instruction can be varied on a per instruction basis. In particular embodiments, the amount of  . data is identified by identifying the data type "dt" (i.e. the size of each data element) and identifying the number of data elements to be accessed by identifying the SIMD register list and optionally the number of structures to be accessed.<br>
When performing SIMD processing, it is often the case that the access operations performed with respect to the necessary data elements are often unaligned accesses (also referred to herein as byte aligned accesses). In other words, the start address will often be unaligned, and in such situations the LSU 22 needs to allocate to the access operation the maximum number of accesses that may be required to enable the access operation to complete.<br>
Whilst in a possible implementation, the LSU 22 could be arranged to assume that every access is unaligned, this means that the LSU 22 is unable to improve the efficiency of the access operations in situations where the start address is in fact aligned with a certain multiple number of bytes.<br>
Whilst the LSU 22 would be able to determine from the start address whether the start address has a predetermined alignment, the LSU 22 typically has to commit the number of accesses for the access operation at a time before the start address has actually been computed. In a particular embodiment, the LSU 22 has a pipelined architecture, and the number of accesses to be used to perform any particular access operation is determined by the LSU in the decode stage of the pipeline. However, often the start address is computed in a subsequent execute stage of the pipeline, for example by adding an offset value to a base address, and accordingly the LSU 22 is<br>
unable to await determination of the start address before determining how man)' accesses to allocate to the access operation.<br>
In accordance with an embodiment, this problem is alleviated by providing an alignment specifier field within the access instruction, also referred to herein as an alignment qualifier. In one particular embodiment, the alignment qualifier can take a first value which indicates that the start address is to be treated as byte aligned, i.e. unaligned. It will be appreciated that this first value could be provided by any predetermined encoding of the alignment specifier field. In addition, the alignment qualifier can take any one of a plurality of second values indicating different predetermined alignments that the start address is to be treated as conforming to, and in one particular embodiment, the plurality of available second values are as indicated in the following table:<br>
(Table Removed)<br>
The manner in which this alignment specifier information is used in one embodiment will now be described with reference to Figure 52. As shown in Figure 52, the LSU 22 will typically be connected to a memory system via a data bus of a<br>
predetermined width. Often the memory system will consist of a number of different levels of memory, and the first level of memory is often a cache, this being the level of memory with which the LSU communicates via the data bus. Accordingly, as shown in Figure 52, the LSU 22 is arranged to communicate with a level 1 cache 1010 of the memory via a data bus 1020, in this particular example the data bus being considered to have a width of 64 bits. In the event of a cache hit the access takes place with respect of the contents of the level 1 cache, whereas in the event of a cache miss, the level 1 cache 1010 will then communicate with other parts of the memory system 1000 via one or more further buses 1030.<br>
The various parts of the memory system may be distributed., and in the example illustrated in Figure 52, it is assumed that the level 1 cache 1010 is provided on-chip, i.e. is incorporated within the integrated circuit 2 of Figure 1, whilst the rest of the memory system 1000 is provided off-chip. The delimitation between on-chip and off-chip is indicated by the dotted line 1035 in Figure 52. However, it will be appreciated by those skilled in the art that other configurations may be used, and so for example all of the memory system may be provided off-chip, or some other delimitation between the on-chip parts of the memory system and the off-chip parts of the memory system may be provided.<br>
The LSU 22 is also arranged to communicate with a memory management unit (MMU) 1005, which typically incorporates a Translation Lookaside Buffer (TLB) 1015. As will be appreciated by those skilled in the art, an MMU is used to perform certain access control functions, for example conversion of virtual to physical addresses, determination of access permissions (i.e. whether the access can take place), etc. To do this, the MMU stores within the TLB 1015 descriptors obtained from page tables in memory. Each descriptor defines for a corresponding page of memory the necessary access control information relevant to that page of memory.<br>
The LSU 22 is arranged to communicate certain details of the access to both the level 1 cache 1010 and the MMU 1005 via a control path 1025. hi particular, the LSU 22 is arranged to output to the level 1 cache and the MMU a start address and an<br>
indication of the size of the block of data to be accessed. Furthermore, in accordance with one embodiment, the LSU 22 also outputs alignment information derived from the alignment specifier. The manner in which the alignment specifier information is used by the LSU 22 and/or by the level 1 cache 1010 and the MMU 1005 will now be described further with reference to Figures 53A to 54B.<br>
Figure 53A illustrates a memory address space, with each solid horizontal line indicating a 64-bit alignment in memory. If the access operation specifies the 128-bit long data block 1040, which for the sake of argument we will assume has a start address of 0x4, then the LSU 22 needs to determine the number of separate accesses over the 64-bit data bus 1020 to allocate to the access operation. Further, as discussed earlier, it will typically need to make this determination before it knows what the start address is. In the embodiment envisaged with respect to Figure 52, the LSU 22 is arranged to use the alignment specifier information when determining the number of<br>
accesses to allocate.<br><br>
In the example of Figure 53A, the start address is 32-bit aligned, and the alignment specifier may have identified this alignment. In that instance, as can be seen from Figure 53A, the LSU 22 has to assume the worst case scenario, and hence assume that three separate accesses will be required in order to perform the necessary access operation with regard to the data block 1040. This is the same number of accesses that would have to be allocated for an unaligned access.<br>
However, if we now consider the similar example illustrated in Figure 53B, it can be seen that again a 128-bit data block 1045 is to be accessed, but in this instance the start address is 64-bit aligned. If the alignment specifier information identifies this 64-bit alignment, or indeed identifies the data as being 128-bit aligned, then in this case the LSU 22 only needs to allocate two separate accesses to the access operation, thereby providing a significant improvement in efficiency. If, however, the data bus were 128-bits wide, then if the alignment specifier indicated 128-bit alignment rather than 64-bit alignment, the LSU 22 would only need to allocate a single access.<br>
Considering now the example in Figure 53C, here it can be seen that a 96-bit size data block 1050 needs to be accessed, and in this instance it is assumed that the alignment specifier identifies that the start address is 32-bit aligned. Again, in this example, even though the LSU 22 will not actually have calculated the start address at the time the number of accesses needs to be committed, the LSU 22 can still assume that only two accesses need to be allocated to the access operation. Figure 53D illustrates a fourth example in which an 80-bit data block 1055 is to be accessed, and in which the alignment specifier identifies that the start address is 16-bit aligned. Again, the LSU 22 only needs to allocate two accesses to the access operation. If instead the alignment specifier had indicated that the access was to be treated as an unaligned access, then it is clear that the LSU would have to have allocated three accesses to the access operation, as indeed would have been the case for the access illustrated in Figure 53C. Accordingly, it can be seen that the alignment specifier information can be used by the LSU 22 to significantly improve the performance of<br>
1<br>
accesses in situations where the alignment specifier indicates a certain predetermined alignment of the start address.<br>
It should be noted that the alignment specifier cannot be taken as a guarantee that the start address (also referred to herein as the effective address) will have that alignment, but does provide the LSU 22 with an assumption.on which to proceed. If the start address subsequently turns out not to obey the alignment specified by the<br>
alignment specifier, then in one embodiment the associated load or store operation is<br>
\ arranged to generate an alignment fault.   The alignment fault can then be handled<br>
using any one of a number of known techniques.<br>
As mentioned earlier, the alignment information is not only used by the LSU 22, but is also propagated via path 1025 to both the level 1 cache 1010 and the MMU 1005. The manner in which this information may be used by the level 1 cache or the MMU will now be described with reference to Figures 54A and 54B. As illustrated in Figures 54A and 54B, an access to a 256-bit data block 1060, 1065 is considered, in these examples the solid horizontal lines in the diagrams indicating a 128-bit<br>
alignment in memory. In Figure 54A, it is assumed that the data block is 64-bit aligned, whilst in Figure 54B it is assumed that the data block is 128-bit aligned. In both instances, since the data bus 1020 is only 64-bits wide, it will be clear that the LSU 22 has to allocate four accesses to the access operation. From the LSU's perspective, it does not matter whether the alignment specifier specifies that the start address is 64-bit aligned or 128-bit aligned.<br>
However, the cache lines within the level 1 cache 1010 may each be capable of storing in excess of 256 bits of data, and further may be 128-bit aligned. In the example of Figure 54A, since the data block is not 128-bit aligned, the cache will need to assume that two cache lines will need to be accessed. However, in the example of Figure 54B, the level 1 cache 1010 can determine from the alignment specifier that only a single cache line within the level 1 cache needs to be accessed, and this can be used to increase the efficiency of the access operation within the level 1 cache 1010.<br>
*<br>
Similarly, the page tables that need to be accessed by the MMU in order to retrieve the appropriate descriptors into the TLB 1015 will often store in excess of 256 bits of data, and may often be 128-bit aligned. Accordingly, the'MMU 1005 can use the alignment information provided over path 1025 in order to determine the number of page tables to be accessed. Whilst in the example of Figure 54A, the MMU 1005 may need to assume that more than one page table will need to be accessed, in the example of Figure 54B, the MMU can determine from the alignment specifier that only a single page table needs to be accessed, and this information can be used to improve the efficiency of the access control functions performed by the MMU 1005.<br>
Accordingly, it can be seen that the use of the alignment specifier within the load or store instructions as described above can be used to enable the hardware to optimise certain aspects of the access operation, which is especially useful if the number of access cycles and/or cache accesses has to be committed to before the start address can be determined. This scheme is useful for load or store instructions<br>
specifying various lengths of data to be accessed, and on processors with differing data bus sizes between the LSU and the memory system.<br>
There are a number of data processing operations which do not lend themselves to being performed in a standard SBVED format, where multiple data elements are placed side-by-side within a register, and then the operation is performed in parallel on those data elements. Examples of some such operations are illustrated in Figures 55A to 55C. Figure 55A illustrates an interleave operation, where it is desired to interleave four data elements A, B, C, D within a first register 1100 with four data elements E, F, G, H within a second register 1102. In Figure 55A, the resultant interleave data elements are shown within destination registers 1104, 1106. These destination registers may be different registers to the source registers 1100, 1102, or alternatively may be the same set of two registers as the source registers. As can be seen from Figure 5 5A, in accordance with this interleave operation, the first data elements from each source register are placed side-by-side within the destination registers, followed by the second data elements from both source registers, followed by the third data elements from both source registers, followed by the fourth data elements from both source registers.<br>
Figure 55B illustrates the reverse de-interleave operation, where it is required to de-interleave the eight data elements placed in the two source registers 1108 and 1110.    In accordance with this operation, the first, third, fifth and seventh data elements are placed in one destination register 1112, whilst the second, fourth, sixth and eighth data elements are placed in a second destination register 1114. As with the Figure 55A example, it will be appreciated that the destination registers may be different to the source registers, or alternative!}' may be the same registers.  If in the examples of Figures 55 A and 55B it is assumed that the registers are 64-bit registers, then in this particular example the data elements being interleaved or de-interleaved are 16-bit wide data elements.   However, it will be appreciated that there is no requirement for the data elements being interleaved or de-interleaved to be 16-bits wide, nor for the source and destination registers to be 64-bit registers.<br>
Figure 55C illustrates the function performed by a transpose operation. In accordance with this example, two data elements A, B from a first source register 1116, and two data elements C, D from a second source register 1118, are to be transposed, and the result of the transposition is that the second data element from the first source register 1116 is swapped with the first data element from the second source register 1118, such that within the first destination register 1120, the data elements A, C are provided, whilst in a second destination register 1122 the data elements B, D are provided. Again, the destination registers may be different to the source registers, but it is often the case that the destination registers are in fact the same registers as the source registers. In one example, each of the registers 1116, 1118, 1120, 1122 may be considered to be 64-bit registers, in which event the data elements are 32-bit wide data elements. However, there is no requirement for the data elements to be 32-bit wide, nor for the registers to be 64-bit registers.<br>
Further, whilst in all of the above examples it has been assumed that the entire contents of the registers are shown, it is envisaged that any of these three discussed operations could be performed independently on the data elements within different portions of the relevant source registers, and hence the figures in that case illustrate only a portion of the source/destination registers.<br>
As mentioned earlier, the standard SDVID approach involves placing multiple data elements side-by-side within a register, and then performing an operation in parallel on those data elements. In other words, the parallelisation of the operation is performed at the data element granularity. Whilst this leads to very efficient execution of operations where the required data elements can be arranged in such a manner, for example by spreading the required source data elements across multiple registers, there are a significant number of operations where it is not practical to arrange the required source data elements in such a way, and hence in which the potential speed benefits of a SBVID approach have not previously been able to be exploited. The above interleave, de-interleave and transpose operations are examples of such operations which have not previously been able to take advantage of the speed benefits of a SHVID approach, but it will be appreciated that there are also many other<br>
examples, for example certain types of arithmetic operations. One particular example of such an arithmetic operation is an arithmetic operation which needs to be applied to a complex number consisting of real and imaginary parts.<br>
In accordance with one embodiment, this problem is alleviated by providing the ability for certain data processing instructions to identify not only a data element size, but also to further identify as a separate entity a lane size, the lane size being, a multiple of the data element size. The parallelisation of the data processing operation then occurs at the granularity of the lane size rather than the data element size, such that more than one data element involved in a particular instantiation of the data processing operation can co-exist within the same source register. Hence, the processing logic used to perform the data processing operation can define based on the lane size a number of lanes of parallel processing, and the data processing operation can then be performed in parallel in each of the lanes, the data processing operation being applied to selected data elements within each such lane of parallel<br><br>
processing.<br>
By such an approach, it is possible to perform in a SIMD manner interleave operations such as those described earlier with reference to Figure 55A. In particular, Figure 56A illustrates the processing performed when executing a "ZIP" instruction in accordance with one embodiment. In this particular example, the ZIP instruction is a 32|ZIP.8 instruction. This instruction hence identifies that the data elements are 8-bits wide, and the lanes are 32-bits wide. For the example of Figure 5 6A, it is assumed that the ZIP instruction has specified the source registers to be the 64-bit registers DO 1125 and Dl 1130. Each of these registers hence contains eight 8-bit data elements. Within each lane the interleave operation is applied independently, and in parallel, resulting in the rearrangement of data elements as shown in the lower half of Figure 56A. In one embodiment, it is assumed that for the ZIP instruction, the destination registers are the same as the source registers, and accordingly these rearranged data elements are once again stored within the registers DO 1125 and Dl 1130. As can be seen from Figure 56A, within lane 1, the first four data elements of<br>
each source register have been interleaved, and within lane 2, the second four data elements of each source register have been interleaved.<br>
It will be readily appreciated that different forms of interleaving could be performed by changing either the lane size, or the data element size. For example, if the lane size was identified as being 64-bits, i.e. resulting in there being only a single lane, then it can be seen that the destination register DO would contain the interleaved result of the first four data elements of each register, whilst the destination register Dl would contain the interleaved result of the second four data elements of each register. It will be appreciated that a corresponding UNZIP instruction can be provided in order to perform the corresponding de-interleave operation, the UNZIP instruction again being able to specify both a lane size and a data element size.<br>
Typically, a transpose operation is considered to be a quite different operation to an interleave operation or a de-interleave operation, and hence it would typically be<br>
1<br>
envisaged that a separate instruction would need to be provided to perform transpose operations. However, it has been realised that when providing an interleave or a de-interleave instruction with the ability to separately define a lane size and a data element size, then the same instruction can in fact be used to perform a transpose operation when two source registers are specified, and the lane size is set to be twice the data element size.    This is illustrated in Figure 56B where the interleave instruction ZIP has been set to identify a data element size of 8 bits, and a lane size of 16 bits (i.e. twice the data element size). Assuming the same 64-bit source registers DO 1125 and Dl 1130 are chosen as in the Figure 56A example, this defines four lanes of parallel processing as shown in Figure 56B.  As can then beseen from the lower half of Figure 56B, the interleaving process actually results within each lane in the generation of a transposed result, in that the first data element of the second source register within each lane is swapped with the second data element of the first source register within each lane.<br>
Hence, in accordance with the above described embodiment, the same ZIP instruction can be used to perform either an interleave, or a transpose operation,<br>
dependent on how the lane size and data element size are defined. It should farther be noted that a transposition can also be performed in exactly the same manner using the UNZIP instruction, and accordingly a 16|UNZIP.8 instruction will perform exactly the same transpose operation as a 161 ZIP.8 instruction.<br>
Figures 57A to 57C illustrate one particular example of an implementation of such ZIP instructions, in which a four-by-four array of pixels 1135 within an image are to be transposed about the line 1136 (see Figure 57A). Each pixel will typically consist of red, green and blue components expressed in RGB format. If for the sake of argument we assume that the data required to define each pixel is 16-bits in length, then it can be seen that the data for each horizontal line of four pixels in the array 1135 can be placed in a separate source register A, B, C, D.<br>
Figure 57B illustrates the various transpositions that occur if the following two instructions are executed: 32|ZIP.16A,B 32|ZTP.16C,D<br>
Each ZIP instruction hence defines the lane width to be 32-bits, and the data element width to be 16-bits, and thus within each lane the first data element in the second register is swapped with the second data element in the first register, as shown by the four diagonal arrowed lines illustrated in Figure 57B. Hence, separate transpositions occur within each of the four two-by-two blocks 1137, 1141, 1143 and<br>
\t<br>
1145.<br>
Figure 57C then illustrates the transposition that occurs as a result of execution of the following two instructions: 64|ZIP.32A?C 64|ZIP.32B,D<br>
In accordance with these instructions, the lane width is set to be 64-bits, i.e. the entire width of the source registers, and the data element width is chosen to be 32-bits. Execution of the first ZP instruction thus results in the second 32-bit wide data element in register A 1147 being swapped with the first 32-bit wide data element within the register C 1151. Similarly, the second ZIP instruction results in the second 32-bit wide data element in the register B 1149 being swapped with the first 32-bit data element within the register D 1153.  As illustrated by the diagonal arrowed line in Figure 57C, this hence results in the two-by-two block of pixels in the top left being swapped by the two-by-two block of pixels in the bottom right.   As will be appreciated by those skilled in the art, this sequence of four ZIP instructions has hence transposed the entire four-by-four array 1135 of pixels about the diagonal line 1136.   Figure 58 illustrates one particular example of the use of the interleave instruction. In this example, complex numbers consisting of real and imaginary parts are considered. It may be the case that a certain computation needs to be performed on the real parts of a series of complex numbers, whilst a separate computation needs to be performed on the imaginary part of those complex numbers. As a result, the real parts may have been arranged in a particular register DO 1155 whilst the imaginary parts may have been placed in a separate register Dl 1160. At some point, it may be desired to reunite the real and imaginary parts of each complex number so that they are adjacent to each other within the registers. As is illustrated in Figure 58, this can be achieved through the use of a 641 ZIP. 16 instruction which sets the lane width to be the full width of the source registers, and sets the data element width to be 16-bits, i.e. the width of each of the real and imaginary parts.  As shown by the lower half of Figure 58, the result of the execution of the ZIP instruction is that each of the real and imaginary parts of each complex number a, b, c, d are reunited within the register space, the destination register DO 1155 containing the real and imaginary parts of the complex numbers a and b and the destination register Dl 1160 containing the real and imaginary parts of the complex numbers c and d.<br>
It is not just data rearranging instructions like interleave and de-interleave instructions that can take advantage of the ability to specify the lane size independently of the data element size. For example, figures 59A and 59B illustrate a<br>
sequence of two instructions that can be used to perform a multiplication of two complex numbers. In particular, it is desired to multiply a complex number A by a complex number B, in order to generate a resultant complex number D, as illustrated by the following equation:<br>
. Figure 59A shows the operation performed in response to a first multiply instruction of the following form: 321MUL. 16 Dd, Dn, Dm[0]<br>
The source registers are 64-bit registers, and the multiply instruction specifies a lane width of 32 bits and a data element size of 16 bits. The multiply instruction is arranged within each lane to multiply the first data element in that lane within the source register Dm 1165 with each of the data elements in that lane in the second source register Dn 1170 (as shown in Figure 59A), with the resultant values being stored in corresponding locations within the destination register Dd 1175. Within each lane, the first data element in the destination register is considered to represent the real part of the partial result of the complex number, and the second data element is considered to represent the imaginary part of the partial result of the complex number.<br>
Following execution of the instruction illustrated in Figure 5 9 A, the following instruction is then executed:<br>
.  32|MASX.16Dd3Dn,Dm[l]<br>
As illustrated by Figure 59B, this instruction is a "multiply add subtract with exchange" instruction. In accordance with this instruction, the second data element within each lane of the source register Dm is multiplied with each data element within the corresponding lane of the second source register Dn, in the manner illustrated in Figure 59B. Then, the result of that multiplication is either added to, or subtracted from, the values of corresponding data elements already stored within the destination<br><br>
egister Dd 1175, with the result then being placed back within the destination register Dd 1175. It will be appreciated from a comparison of the operations of Figures 59A and 59B with the earlier identified equations for generating the real and imaginary parts of the resultant complex number D that'by employing these two instructions in sequence, the computation can be performed in parallel for two sets of complex numbers, thereby enabling the speed benefit of a SIMD approach to be realised.<br>
From the above examples, it will be appreciated that by providing an instruction with the ability to specify a lane size in addition to a data element size, the number of operations that can potentially benefit from a SIMD implementation is increased, and hence this provides a much improved flexibility with regard to the implementation of operations in a SIMD manner.<br>
The present technique provides the ability to perform SIMD processing on vectors where the source and destination data element widths are different. One<br><br>
particularly useful operation in this environment is an add or subtract then return high half SIMD operation. Figure 60 shows an example of an add return high half operation according to the present technique. An instruction decoder within the SIMD decoder 16 (see Figure 1) decodes instruction VADH.I16.I32 Dd,Qn,Qm and performs the addition return high half illustrated in Figure 60 and set out below.<br>
In Figure 60 two source registers located in the SIMD register file 20 (see<br>
Figure 1), Qri and Qm contain vectors of 32-bit data elements a and b.   These are<br>
 added together to form a vector of 16-bit data elements Dd also located in register file<br>
20 formed from the high half of the data sums:<br>
Qn = [a3 a2 al aO] Qm = [b3 b2 bl b]<br>
Output<br>
Dd - [(a3+b3)16, (a2+b2)16, (al+bl)l6, (aO+bO)16].<br>
Figure 61 schematically shows a similar operation to that shown in Figure 60 but in this case, the instruction decoded is VRADH.I16.132 Dd,Qn,Qm and the operation performed is an add return high with rounding. This is performed in a very similar way to the operation illustrated in Figure 60 but the high half is rounded. This is done, in this example, by adding a data value having a one in the most significant bit position of the lower half of the data value and zeros elsewhere after the addition and prior to taking the high half.<br>
In this Figure as in Figure 61 intermediate values are shown with dotted lines for clarity.<br>
Further instructions (not illustrated) that may be supported are an addition or subtraction return high with saturation. In this case the addition or subtraction will be saturated where appropriate prior to the high half being taken.<br>
i<br>
Table 11 shows examples of some of the instructions that are supported by the present technique. Size<a> returns the size of the data type in bits and round</a><td> returns rounding constant l(size<dt> -1).<br>
(Table Removed)<br>
The present technique can be performed on different types of data provided that taking the high half of the data is a sensible thing to do. It is particularly appropriate to processing performed on fixed point numbers.<br>
The above technique has many applications and can be used, for example, to accelerate SEVID FFT implementations. SBVID is particularly useful for performing FFT (fast fourier transform) operations, where the same operations need to be performed on multiple data. Thus, using SBVID processing allows the multiple data to be processed in parallel. The calculations performed for FFTs often involve multiplying complex numbers together. This involves the multiplication of data values and then the addition or subtraction of the products. In SIMD processing these<br><br>
calculations are performed in parallel to increase processing speed.<br>
A simple example of the sort of sums that need to be performed is given below.<br>
(a -He) * (b + id) = e +if<br>
Thus, the real portion e is equal to: a * b — c * d and The imaginary portion f is equal to:     a * d + c * b<br>
Figure 62 shows a calculation to determine the real portion e. As can be seen the vectors for a containing 16 bit data element are multiplied with the vectors for b containing the same size data elements and those for c with d. These products produce two vectors with 32 bit data elements. To produce e one of the vectors needs to be subtracted from the other but the final result is only needed to the same accuracy as the original values. Thus, a resulting vector with 16 bit data elements is required. This operation can be performed in response to the single instruction VSBH. 16.32<br>
Dd, Qn, Qm as is shown in the Figure. This instruction, subtract return high half, is therefore particularly useful in this context.   Furthermore, it has the advantage of allowing the arithmetic operation to be performed on the wider data width and the narrowing only occurring after the arithmetic operation (subtraction). This generally gives a more accurate result than narrowing prior to performing the subtraction.<br>
ARM have provided their instruction set with an instruction encoding which allows an immediate to be specified with some instructions. Clearly, the immediate size should be limited if it is encoded with the instruction.<br>
An immediate value of a size suitable for encoding with an instruction has limited use in SIMD processing where data elements are processed in parallel. In order to address this problem, a set of instructions with generated constant is provided that have a limited size immediate associated therewith, but have the ability to expand this immediate. Thus, for example, a byte sized immediate can be expanded to<br>
f<br>
produce a 64-bit constant or immediate, hi this way the immediate can be used in logical operations with a 64-bit source register comprising multiple source data elements in SIMD processing.<br>
Figure 63 shows an immediate abcdefgh, that is encoded within an instruction along with a control value, which is shown in the left hand column, of the table. The binary immediate can be expanded to fill a 64-bit register, the actual expansion<br>
performed depending on the instruction and the control portion associated with it. In<br>
 the example shown, the 8-bit immediate abcdefgh, is repeated at different places<br>
within a 64 bit data value, the positions at which the immediate is placed depending on the control value. Furthermore, zeros and/or ones can be used to fill the empty spaces where the value is not placed. The choice of either ones and/or zeros is also determined by the control value. Thus, in this example a wide range of possible constants for use in SIMD processing can be produced from an instruction having an 8-bit immediate and 4-bit control value associated with it.<br>
In one embodiment (last line of the table), instead of repeating the immediate at certain places, each bit of the immediate is expanded to produce the new 64 bit immediate or constant.<br>
As can be seen in some cases, the constant is the same in each lane, while in others different constants appear in some of the lanes. In some embodiments (not shown), the possibility of inverting these constants is also provided and this also increases the number of constants that can be generated.<br>
An example of the format of an instruction that can be used for constant generation as shown in Figure 63 is given below, in this instructions <value> is the data portion or immediate and <mode> is the control portion which provides an indication as to how the <value> portion is to be expanded within the generated constant (shown as different lines in the table of Figure 63).<br>
VMOV Dd, #<value>, <mode> where<br><value> is a byte <mode> is one of the enumerated expansion functions<br>
These adapted instructions generally have an associated data value that has a data portion <value> which comprises the immediate and a control portion <mode>. As is shown in Figure 63 the control portion indicates how the immediate is to be expanded. This may be done in a variety of ways, but in some embodiments, the control portion indicates which expansion of the constant is to be performed using constant generation logic. <br>
Figure 64 schematically shows an example of constant generation logic operable to generate a constant from a data portion 1210 and a control portion 1200 associated with an instruction according to the present technique. In the example shown, the control portion 1200 controls the control generation logic 1220, which<br>
comprises gates 1230 to output either a portion of the data value 1210, or a one or a zero to each bit within the constant 1240 to be generated.<br>
Figure 65 shows a data processor (integrated circuit) similar to that shown in Figure 1, with like reference numerals representing like features. Figure 65 differs from Figure 1 in that it explicitly shows constant generation logic 1220. Constant generation logic 1220 can be considered to be adjacent to, or forming part, of the decode/control portion 14, 16. As can be seen instructions are sent from the instruction pipeline 12 to the decode/control logic 14, 16. This produces control signals which control the operation of the SIMD processing logic 18, the load store unit 22, and the scalar processing portion 4, 6, 8,10 of the processor. If an instruction with constant generation is received at the decode/control portion 14, 16, the constant generation logic is used to generate a constant for use in SIMD processing. This can either be sent directly to the SIMD register data store 20 (dotted line 1222), or if the instruction with constant generation comprises a SIMD data processing part, the<br>
i<br>
generated constant is sent to the SIMD processing logic (line 1224) where further manipulations are performed on the generated constant to produce a new data value.<br>
Figure 66A and B schematically illustrates the two different paths shown in Figure 65. Figure 66A shows the case where the instruction generates a constant which is sent directly to the register store, i.e. dotted line 1222. Figure 66B, shows the case where the instruction with generated constant comprises a data processing<br>
part.   In this' case data processing operations (OP) are performed on the generated<br>
constant and a further source operand 1250 to produce a final data value 1260 in<br>
response to the instruction, this corresponds to line 1224 of Figure 65.<br>
In addition to the constants shown in Figures 63 and their inversions, additional data processing operations such as an OR, AND, test, add or subtract can be performed on the generated constants to generate a much wider range of data values. This corresponds to Figure 13B and path 1224 in Figure 65. Table 12 gives an example of bitwise AND and bitwise OR that can be used to generate some additional data values.<br><br>
(Table Removed)<br>
The ability to perform further data processing operations on the generated constants can have a variety of uses. For example, Figure 67 shows how embodiments of the present technique can be used to generate a bit mask to extract a certain bit or bits from a number of data elements in a vector. In the example shown the fourth bit of each data element from a source vector is extracted. Initially the immediate 8 is expanded by repeating it and then this is followed by a logical AND instruction which ANDs the generated constant with a source vector to extract the desired bit from each data element. These operations are performed in response to the instruction<br>
VAND Dd,#0b00001000, Obi 100<br>
Wherein the <mode> value 1100 refers to a generated constant comprising an expanded data portion (see Figure 63).<br>
Although a particular embodiment has been described herein, it will be appreciated that the invention is not limited thereto and that many modifications and additions thereto may be made within the scope of the invention. For example, various combinations of the features of the following dependent claims could be made with the features of the independent claims without departing from the scope of the present invention.<br><br><br><br><br><br><br>
We claim:<br>
1.	A data processing apparatus, comprising:<br>
a register data store (20) having a plurality of registers (Dn) operable to hold data elements, the number of data elements held in each register being dependent on a data type of the data elements;<br>
characterized by:-<br>
a processor (18) operable to perform in parallel a data processing operation on multiple data elements occupying different lanes of parallel processing in at least one of said registers;<br>
access logic (22, 23, 23', 24) operable in response to a single access instruction to move a plurality of data elements between specified registers (220, 225, 230) and a continuous block of memory (200) in which data elements are held as an array of structures having a structure format, the structure format having a plurality of components;<br>
the single access instruction including data type information identifying the data type associated with the data elements to be moved, and identifying the number of components in the structure format; and<br>
the access logic (22, 23, 23' ) being operable to rearrange the plurality of data elements as they are moved such that each specified register holds data elements of one component whilst in memory the data elements are held as said array of structures, the rearrangement performed by the access logic being dependent on the data type.<br>
2.	A data processing apparatus as claimed in claim 1, wherein the single<br>
access instruction has a field used to identify the specified registers (220,<br><br>
225, 230), the number of specified registers being a multiple of the number of components.<br>
3.	A data processing apparatus as claimed in claim 1, wherein each of the data elements being moved is of the same data type.<br>
4.	A data processing apparatus as claimed in claim 1, wherein the specified registers (220, 225, 230) provide an efficient encoding of the specified registers within the single access instruction, in accordance with a fixed relationship; the said fixed relationship is defined wherein, the specified registers (220, 225, 230) are separated by n intermediate registers, where n is 2™-1 and where m is an integer greater than or equal to zero.<br>
5.	A data processing apparatus as claimed in claim 1, wherein said single access instruction is a single load instruction, said access logic (22, 23, 23', 24) being operable in response to said single load instruction to load the plurality of data elements from said continuous block of memory (200) to said specified registers and, prior to storing the data elements in said specified registers, to rearrange said data elements by de-interleaving the data elements of different components so that data elements of different components are stored in different registers of said specified registers.<br>
6.	A data processing apparatus as claimed in any of claims 1 to 4, wherein said single access instruction is a single store instruction, said access logic (22, 23, 23', 24) being operable in response to said single store instruction to store the plurality of data elements from said specified registers (220, 225, 230) to said continuous block of memory (200) and, prior to storing the data elements in said continuous block of memory, to rearrange said data elements by interleaving the data elements of different components so that the data elements are stored in said continuous block of memory as said array of structures.<br>
7.	A data processing apparatus as claimed in claim 1, wherein the single access instruction identifies the number of structures to access.<br><br>
8.	A data processing apparatus as claimed in claim 7 when dependent on claim 5, wherein if the number of structures is insufficient to cause the specified registers (220, 225, 230) to be filled with data elements, the access logic is operable to cause any unfilled parts of the specified registers to be filled with one or more predetermined values.<br>
9.	A data processing apparatus as claimed in any preceding claim, wherein the single access instruction comprises an addressing mode operand which identifies an addressing mode to be used to identify the data elements to be moved.<br>
10.	A data processing apparatus as claimed in claim 9, wherein the addressing mode operand identifies a start address for the continuous block of memory (200).<br>
11.	A data processing apparatus as claimed in any preceding claim, wherein the specified registers (220, 225, 230) are of the same size.<br>
12.	A data processing apparatus as claimed in any preceding claim, wherein the single access instruction identifies a transformation to be applied to the data elements, and the access logic (22, 23, 23', 24) is operable to apply said transformation to the data elements as they are moved.<br>
13.	A method of processing data comprising using a register data store (20) having a plurality of registers (Dn) operable to hold data elements, the number of data elements held in each register being dependent on a data type of the data elements, and a processor (18) operable to perform in parallel a data processing operation on multiple data elements occupying different lanes of parallel processing in at least one of said registers, the method comprising the steps of:<br>
(a) in response to a single access instruction access logic (22, 23, 23', 24) moving a plurality of data elements between specified registers and a continuous block of memory (200) in which data elements are held as an array of structures<br><br>
having a structure format, the structure format having a plurality of components;<br>
the single access instruction including data type information identifying the data type associated with the data elements to be moved, and identifying the number of components in the structure format, and the m.ethod further comprising the step of:<br>
(b) access logic (22, 23, 23', 24) rearranging the plurality of data elements as they are moved such that each specified register holds data elements of one component whilst in memory the data elements are held as said array of structures, the rearranging performed being dependent on the data type.<br>
14.	A method as claimed in claim 13, wherein the single access instruction has a field used to identify the specified registers (200, 225, 230) , the number of specified registers being a multiple of the number of components.<br>
15.	A method as claimed in claim 13, wherein each of the data elements being moved is of the same data type.<br>
16.	A method as claimed in any of claims 13 to 15, wherein the specified registers (220, 225, 230) have a fixed relationship to each other.<br>
17.	A method as claimed in claim 16, wherein in accordance with the fixed relationship the specified registers (220, 225, 230) are separated by n intermediate registers, where n is 2m-1 and where m is an integer greater than or equal to zero.<br>
18.	A method as claimed in claim 16 or claim 17, wherein the specified registers (220, 225, 230) are a series of adjacent registers within said register data store.<br><br>
19.	A method as claimed in any of claims 13 to 18, wherein said single<br>
access instruction is a single load instruction, and wherein:<br>
said step (a) comprises the step of access logic (22, 23, 23', 24) loading the plurality of data elements from said continuous block of memory (200) to said specified registers (220, 225, 230); and<br>
said step (b) comprises the step, prior to storing the data elements in said specified registers, of access logic rearranging said data elements by de-interleaving the data elements of different components so that data elements of different components are stored in different registers of said specified registers.<br>
20.	A method as claimed in any of claims 13 to 18, wherein said single<br>
access instruction is a single store instruction, and wherein:<br>
said step (a) comprises the step of access logic (22, 23, 23', 24) storing the plurality of data elements from said specified registers (220, 225, 230) to said continuous block of memory (200); and<br>
said step (b) comprises the step, prior to storing the data elements in said continuous block of memory (200), of access logic rearranging said data elements by interleaving the data elements of different components so that the data elements are stored in said continuous block of memory as said array of structures.<br>
21.	A method as claimed in any of claims 13 to 20 wherein the single access instruction identifies the number of structures to access.<br>
22.	A method as claimed in claim 21 when dependent on claim 19, wherein if the number of structures is insufficient to cause the specified registers (220, 225, 230) to be filled with data elements, the method further comprises the step of: access logic filling any unfilled parts of the specified registers with one or more predetermined values.<br><br>
23.	A method as claimed in any of claims 13 to 22, wherein the single access instruction comprises an addressing mode operand which identifies an addressing mode to be used to identify the data elements to be moved.<br>
24.	A method as claimed in claim 23, wherein the addressing mode operand identifies a start address for the continuous block of memory (200).<br>
25.	A method as claimed in any of claims 13 to 24, wherein the specified registers (220, 225, 230) are of the same size.<br>
26.	A method as claimed in any of claims 13 to 25, wherein the single access instruction identifies a transformation to be applied to the data elements, and the method further comprises the step of applying said transformation to the data elements as they are moved.<br></mode></mode></value></mode></value></mode></value></value></mode></value>
</dt>
</td>
    </addr></addr></st></reglist>
</dt></n></n></n></st>
</dt></reglist></a>
</dt></st></st></addr></n></reglist></a>
</dt></st></size></size></size></size></size></size></size></size></size></size></size></size></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtQWJzdHJhY3QtKDIwLTAzLTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Abstract-(20-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtQWJzdHJhY3QtKDI0LTA2LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Abstract-(24-06-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtQWJzdHJhY3QtKDMwLTA5LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Abstract-(30-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">623-delnp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtQ2xhaW1zLSgxNi0wMS0yMDA5KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Claims-(16-01-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtQ2xhaW1zLSgyMC0wMy0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Claims-(20-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtQ2xhaW1zLSgyNC0wNi0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Claims-(24-06-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtQ2xhaW1zLSgzMC0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Claims-(30-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">623-delnp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtY29tcGxldGUgc3BlY2lmaWNhdGlvbiAoZ3JhbnRlZCkucGRm" target="_blank" style="word-wrap:break-word;">623-delnp-2006-complete specification (granted).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtQ29ycmVzcG9uZGVuY2UtT3RoZXJzLSgwOS0wMS0yMDA5KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Correspondence-Others-(09-01-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtQ29ycmVzcG9uZGVuY2UtT3RoZXJzLSgyMC0wMy0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Correspondence-Others-(20-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtQ29ycmVzcG9uZGVuY2UtT3RoZXJzLSgyNC0wNi0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Correspondence-Others-(24-06-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtQ29ycmVzcG9uZGVuY2UtT3RoZXJzLSgzMC0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Correspondence-Others-(30-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtY29ycmVzcG9uZGVuY2Utb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">623-delnp-2006-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtRGVzY3JpcHRpb24gKENvbXBsZXRlKS0oMTYtMDEtMjAwOSkucGRm" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Description (Complete)-(16-01-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtRGVzY3JpcHRpb24gKENvbXBsZXRlKS0oMjAtMDMtMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Description (Complete)-(20-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtRGVzY3JpcHRpb24gKENvbXBsZXRlKS0oMzAtMDktMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Description (Complete)-(30-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtRGVzY3JpcHRpb24gKENvbXBsZXRlKS0yNC0wNi0yMDA4LnBkZg==" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Description (Complete)-24-06-2008.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">623-delnp-2006-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtRHJhd2luZ3MtKDIwLTAzLTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Drawings-(20-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtRHJhd2luZ3MtKDI0LTA2LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Drawings-(24-06-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">623-delnp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtRm9ybS0xLSgyMC0wMy0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Form-1-(20-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtRm9ybS0xLSgzMC0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Form-1-(30-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtZm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">623-delnp-2006-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtRm9ybS0yLSgwOS0wMS0yMDA5KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Form-2-(09-01-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtRm9ybS0yLSgyNC0wNi0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Form-2-(24-06-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtRm9ybS0yLSgzMC0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Form-2-(30-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtZm9ybS0yLnBkZg==" target="_blank" style="word-wrap:break-word;">623-delnp-2006-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtRm9ybS0zLSgyMC0wMy0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Form-3-(20-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtZm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">623-delnp-2006-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">623-delnp-2006-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtR1BBLSgyMC0wMy0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-GPA-(20-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtZ3BhLnBkZg==" target="_blank" style="word-wrap:break-word;">623-delnp-2006-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtcGN0LTEwMS5wZGY=" target="_blank" style="word-wrap:break-word;">623-delnp-2006-pct-101.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtcGN0LTIxMC5wZGY=" target="_blank" style="word-wrap:break-word;">623-delnp-2006-pct-210.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtcGN0LTQwOS5wZGY=" target="_blank" style="word-wrap:break-word;">623-delnp-2006-pct-409.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLWRlbG5wLTIwMDYtcGN0LTQxNi5wZGY=" target="_blank" style="word-wrap:break-word;">623-delnp-2006-pct-416.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtUGV0aXRpb24tMTM3LSgyMC0wMy0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Petition-137-(20-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NjIzLURFTE5QLTIwMDYtUGV0aXRpb24tMTM4LSgyMC0wMy0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">623-DELNP-2006-Petition-138-(20-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=Rm9ybS0yLSgyMC0wMy0yMDA4KS50aWY=" target="_blank" style="word-wrap:break-word;">Form-2-(20-03-2008).tif</a></p>
		<br>
		<div class="pull-left">
			<a href="233980-a-process-for-preparation-of-organic-carbamates.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="233982-a-catalytic-deoxyribonucleic-acid.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>233981</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>623/DELNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>21/2005</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>22-May-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>27-Apr-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>07-Feb-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>ARM LIMITED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>110 FULBOURN ROAD, CHERRY HINTON, CAMBRIDGE CB1 9NJ, ENGLAND.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>DAVID RAYMOND LUTZ</td>
											<td>11109 CALAVAR DRIVE, AUSTIN, TX 78726 USA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>CHRISTOPHER NEAL HINDS</td>
											<td>6400 BACK BAY LANE, AUSTIN, TX 78739, USA</td>
										</tr>
										<tr>
											<td>3</td>
											<td>SIMON ANDREW FORD</td>
											<td>5 LIMETREE CLOSE, CAMBRIDGE CB1 8PF, ENGLAND</td>
										</tr>
										<tr>
											<td>4</td>
											<td>DOMINIC HUGO SYMES</td>
											<td>3 APPLEWOOD CLOSE, CHERRY HINTON, CAMBRIDGE CB1 9NU, ENGLAND</td>
										</tr>
										<tr>
											<td>5</td>
											<td>ANDREW CHRISTOPHER ROSE</td>
											<td>102 THODAY STREET, CHERRY HINTON, CAMBRIDGE CB1 3AX, ENGLAND</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 9/312</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/GB2004/002847</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-07-01</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>0328503.8</td>
									<td>2003-12-09</td>
								    <td>U.K.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/233981-a-data-processing-apparatus-and-method-for-moving-data-between-registers-and-memory by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:00:21 GMT -->
</html>
