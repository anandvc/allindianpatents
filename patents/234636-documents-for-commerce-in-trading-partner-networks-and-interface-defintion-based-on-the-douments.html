<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/234636-documents-for-commerce-in-trading-partner-networks-and-interface-defintion-based-on-the-douments by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:21:33 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 234636:DOCUMENTS FOR COMMERCE IN TRADING PARTNER NETWORKS AND INTERFACE DEFINTION BASED ON THE DOUMENTS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">DOCUMENTS FOR COMMERCE IN TRADING PARTNER NETWORKS AND INTERFACE DEFINTION BASED ON THE DOUMENTS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>DOCUMENTS FOR COMMERCE IN TRADING PARTNER NETWORKS AND INTERFACE DEFINTION BASED ON THE DOUMENTS Machine readable docfuments connect businesses with customers, suppliers and trading partners. The self defining electronic documents such as XML based documents, can be easily understood amongst the partners. Definitions, are posted on the internet, otherwise communicated to membrs of the network. The business interface definitions tell potential trading partners the services the company offers and the documents to use when communicating with such services. Thus, a typical business interface definition allows a customer to place an orde3r by submitting a purchase order or a supplier checks availability by downloading and inventory status report. Also, composition of the input and output documents, coupled with interpretation information in a common business library, programs the transaction in a way which closely parallels the way in which paper based businesses operate.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
DOCUMENTS FOR COMMERCE IN TRADING PARTNER NETWORKS AND INTERFACE DEFINITIONS BASED ON<br>
THE DOCUMENTS<br>
BACKGROUND OF THE INVENTION Field of the Invention<br>
The present invention relates to systems and protocols supporting transactions among diverse clients coupled to a network; and more particularly to systems and protocols supporting commercial transactions among platforms having variant architectures.<br>
Description of Related Art<br>
The Internet and other communications networks provide avenues for communication among people and computer platforms which are being used for a wide variety of transactions, including commercial transactions intwhich participants buy and sell goods and services. Many efforts are underway to facilitate commercial transactions on the Internet. However, with many competing standards, in order to execute a transaction, the parties to the transaction must agree in advance on the protocols to be utilized, and often require custom integration of the platform architectures to support such transactions. Commercial processes internal to a particular node not compatible with agreed upon standards, may require substantial rework for integration with other nodes. Furthermore, as a company commits to one standard or the other, the company becomes locked-in to a given standardized group of transacting parties, to the exclusion of others.<br>
A good overview of the challenges met by Internet commerce development is provided in Tenenbaum, et aL, "Eco System: An Internet Commerce Architecture", Computer, May 1997, pp. 48-55.<br><br>
To open commercial transactions on the Internet, standardization of architectural frameworks is desired. Platforms developed to support such commercial frameworks include IBM Commerce Point, Microsoft Internet Commerce Framework, Netscape ONE (Open Network Environment), Oracle NCA (Network Computing Architecture), and Sun/JAVASoft JECF (JAVA Electronic Commerce Framework).<br>
In addition to these proprietary frameworks, programming techniques, such as common distributed object model based on CORBA HOP (Common Object Request Broker Architecture Internet ORB Protocol), are being pursued. Use of the common distributed object model is intended to simplify the migration of enterprise systems to systems which can inter-operate at the business application level for electronic commerce. However, a consumer or business using one framework is unable to execute transactions on a different framework. This limits the growth of electronic commerce systems.<br>
Companies implementing one framework will have an application programming interface API which is different than the API's supporting other frameworks. Thus, it is very difficult for companies to access each others business services, without requiring adoption of common business system interfaces. The development of such business system interfaces at the API level requires significant cooperation amongst the parties which is often impractical.<br>
Accordingly, it is desirable to provide a framework which facilitates interaction amongst diverse platforms in a communication network. Such system should facilitate spontaneous commerce between trading partners without custom integration or prior agreement on industry wide standards. Further, such systems should encourage incremental path to business automation, to eliminate much of the time, cost and risks of traditional systems integration.<br><br>
Overall, it is desirable to provide an electronic commerce system that replaces the closed trading partner networks based on proprietary standards with open markets.<br><br>
SUMMARY OF THE INVENTION<br>
The present invention offers an infrastructure for connecting businesses with customers, suppliers and trading partners. Under the infrastructure of the present invention, companies exchange information and services using self-defining, machine-readable documents, such as XML (Extensible Markup Language) based documents, that can be easily understood amongst the partners. Documents which describe the documents to be exchanged, called business interface definitions BIDs herein, are posted on the Internet, or otherwise communicated to members of the network. The business interface definitions tell potential trading partners the services the company offers and the documents to use when communicating with such services. Thus, a typical business interface definition allows a customer to place an order by submitting a purchase order, compliant with a document definition published in the BID of a party to receive the purchase order. A supplier is allowed to check availability by downloading an inventory status report compliant with a document definition published in the BID of a business system managing inventory data. Use of predefined, machine-readable business documents provides a more intuitive and flexible way to access enterprise applications.<br>
A node in the commerce network establishes an interface for transactions according to the present invention that comprises a machine-readable specification of an interface, along with a machine-readable data structure that includes interpretation information for the machine-readable specification of the interface. The machine-readable specification of the interface includes a definition of an input document and a definition of an output document, that are accepted and produced by transaction processes for which the node acts as an interface. The definitions of the input and output documents comprise respective descriptions of sets of storage units and logical structures for sets of storage units, such as according to a standard XML based<br><br>
document. The machine-readable data structure that includes interpretation information according to various aspects of the invention includes data type specifications (e.g. string, array, etc.) for logical structures in the definitions of the input and output documents, content models (e.g. lists of possible values) for logical structures and/or data structures that map predefined sets of storage units for a particular logic structure to respective entries in a list in order to provide a semantic definition of logical structures (e.g. mapping codes to product names).<br>
According to other aspects of the invention, the interface includes a repository in memory accessible by at least one node in the network that stores a library of logic structures and interpretation information for the logic structures. The repository can be extended to include a library of definitions of input and output documents, a library of specifications of interfaces, and a library of specifications for participant interface nodes in the network.<br>
Thus, a participant in the transaction framework of the: present invention executes transactions amongst nodes in a network that includes a plurality of nodes executing processes involved in the transactions. The method includes storing a machine-readable specification of an interface for a transaction, the specification includes a definition of an input document and a definition of an output document. The definition of the input and output documents comprise respective descriptions of sets of storage units and logical structures for the sets of storage units. In a preferred system, the definitions are expressed in a manner compliant with a standard XML document type definition DTD, extended by semantic mapping, content modeling and data typing of some elements. The participant in the transaction receives data comprising a document through a communication network. The participant parses the document according to the specification stored for a transaction to identify an input document for the transaction. After parsing the document, at least a portion of the input document is provided in a machine-readable format to a transaction process which produces an output. An output document is formed comprising the output of the<br><br>
transaction process, based on the definition of an output document in the stored specification. The output document is transmitted on the communication network, typically back to the source of the input document, or elsewhere as suits the needs of a particular type of transaction.<br>
Thus the business interface definition bridges the gap between the documents specified for example according to XML and the programs which execute on the front end of the transaction processing services at particular nodes. Such front ends are implemented for example by JAVA virtual machines, or by other common architectures providing for interconnection of systems across a network. The business interface definition provides a technique by which a transaction protocol is programmed using the business interface definition document. The program for the protocol of the transaction is established by a detailed formal specification of a document type.<br>
The machine-readable specification of the interface of the transaction is made accessible to other platforms in the network. Participant platforms include resources to design input documents and output documents according to the transaction interface specified at a complementary node. Thus, participant nodes include resources to access the definition of an input document for the complementary interface and a definition of an output document for the complementary interface. The stored specification for the accessing participant node is established by including at least part of the definition of the output document of the complementary interface in the definition of the input document of the interface stored in the specification.<br>
The process of establishing the stored specification of an interface according to another aspect of the invention includes accessing elements of the machine-readable specification from a repository. The repository stores a library of logic structures, content models, and schematic maps for logic structures, and definition of documents that comprise logic structures used to build interface description. A repository accessible in the network facilitates the<br><br>
building of interface descriptions which can be easily shared. Any differences between the input document created for a particular process and the output document expected as a return by a complementary process can be easily negotiated by communication on the network and agreeing on common logic structures to express particular information.<br>
The machine-readable specification of an interface of a transaction according to one aspect of the invention includes a document compliant with a definition of an interface document that is shared amongst members of the network. A definition of the interface document includes logic structures for storing an identifier of a particular transaction and at least one of definitions and references to definitions of input and output documents for the particular transaction. That is, the interface description for a particular service may actually encompass a definition of the input and output documents. Alternatively, it may include pointers to a location in the repository, or elsewhere in the network, of such definitions.<br>
According to another alternative of the invention, the machine-readable specification includes a business interface definition BID document compliant with a definition of an interface document that includes logical structures for storing an identifier of the interface, and for storing at least one of specifications and references to specifications of a set of one or more transactions supported by the interface. For each supported transaction, the document includes at least one of definitions and references to definitions of input and output documents for the particular transaction.<br>
According to another aspect of the invention, the storage units defined in the definitions of the input and output document comprise parsed data including character data encoding text characters, and mark-up data identifying sets of storage units according to the logical structures of the input and output documents. According to another aspect of the invention, at least one of the sets of storage units encodes the plurality of text characters providing a natural<br><br>
language word. This facilitates the use of the definitions of input and output documents by human readers and developers of such documents.<br>
According to another aspect of the invention, the specification of the input and output documents includes interpretation information for at least one of the sets of storage units identified by the logical structure. The interpretation information in one example encodes definitions for sets of parsed characters. In another example, the interpretation information provides for content model specifications, such as requiring a specific logic structure to carry a member of a list of codes mapped to product descriptions in a catalog. In some systems, the storage units in a logic structure of a document may include sets of unparsed data, as suits the needs of a particular implementation.<br>
According to yet another aspect of the invention, the transaction process in a particular platform has a transaction processing architecture which is one of a plurality of variant transaction processing architectures. Thus the participant node includes resources for translating at least a portion of the input document into a format readable according to the variant transaction processing architecture of the transaction process utilizing the information. The elements of the document definition are translated into programming objects that include variables and methods according to the variant transaction processing architectures of the transaction process. For a participant having a JAVA virtual machine acting as a transaction process front end, particular fields in the documents are translated into JAVA objects, including the data as well as get and set functions associated with a JAVA object. Other transaction processing architectures supportable according to the present invention include processes compliant with an interface description language in the sense of Common Object Request Broker Architecture CORBA, Component Object Model COM,On-Line Transaction Processing OLTP, and Electronic Data Interchange EDI.<br><br>
According to other aspects of the invention, a repository is provided that stores document types for use in the plurality of transactions. The machine-readable specification for a particular transaction defines at least one of the input and output documents by reference to a document type in the repository. According to another aspect, the document type included in the repository include a document type for identifying participants in the network. Such document type providing structures for identifying a participant, specifying the services supported by the participant, and specifying the input and output documents for each of such services.<br>
In addition to the methods described above, the present invention provides an apparatus for managing transactions among nodes that includes a network interface, memory for storing data and programs of instructions including a machine-readable specification of an interface for a transaction as described above, and a data processor that is coupled with the memory and the network interface. The programs of instructions stored in the apparatus include logic to execute the processes described above for a participant in the transactions.<br>
The present invention further provides an apparatus for establishing participant interfaces for transactions executed on a system that include a network interface and a data processing resources that execute transaction processes according to a transaction processing architecture. The apparatus includes programs of instructions that are executable by the system and stored on a medium accessible by the system that provide tools to build a definition of a participant interface for a participant in a particular transaction. The definition of a participant interface includes a definition of an input document and a definition of an output document. The definitions of the input and output documents comprise respective machine-readable descriptions of sets of storage units in logical structures for the sets of storage units, which may be compliant in one aspect of the invention with XML document type definitions.<br><br>
The apparatus for establishing participant interfaces according to this aspect of the invention also includes programs of instructions stored on a medium accessible by the data processing system and responsive to the definitions of input and output documents to compile data structures corresponding to the sets of storage units and logical structures of the input and output documents that are compliant with the transaction processing architecture, to compile instructions executable by the system to translate the input document to the corresponding data structures, and to compile instructions executable by the system to translate output of the transaction processes into sets of storage units and logical structures of the output document.<br>
The tools to build a definition of a participant interface in a preferred system include instructions executable by the system to access elements of the definition from complementary nodes and/or from a repository that stores a library of logical structures and interpretation information for logical structures used to build interface descriptions. According to various aspects of the invention, the repository includes not only a library of logical structures but definitions of documents that comprise logical structures, and formats for specifying participant interfaces. According to this aspect of the invention, tools are provided for building specifications of business interfaces according to the techniques described above in connection with the description of the participant nodes. The tools for building interfaces and the tools for compiling the interfaces into resources needed for communication with transaction processing architectures according to this aspect of the invention, are implemented in participant nodes in the preferred system, and utilized for the development and optimization of the interface descriptions as use of the network grows based on interface descriptions that define input and output documents.<br>
Accordingly, another aspect of the invention provides an apparatus that includes memory and a data processor that executes instructions stored in the<br><br>
memory that include tools to build a definition of a participant interface and a compiler performing the functions described above.<br>
According to yet another aspect of the invention, the use of the participant interface descriptions enables the operation of a market maker node. At such a node, a method for managing transactions is provided that comprises storing machine-readable specifications of a plurality of participant interfaces which identify transactions supported by the interfaces, and the respective input and output documents of such transactions. As described above, the definitions of the input and output documents comprise respective descriptions of sets of storage units and logical structures for the sets of storage units, such as according to the XML standard. In addition, the definitions of the transactions and the definitions of the participant interfaces all comprise documents specified according to a technique compliant with XML or other standardized document expression language. At such market maker node, data comprising a document is received over a communication network. The document is parsed according to the specifications to identify an input document in one or more transactions which accept the identified input document. At least a portion of the input document is provided in a machine-readable format to a transaction process associated with the one or more identified transactions. The step of providing at least a portion of the input document to a transaction process includes executing a routing process according to a processing architecture at the market maker node. The routing process in one aspect of the invention is executed according to a particular processing architecture, and at least a portion of the incoming document is translated into the format of the processing architecture of the routing process. The translating according to the preferred aspect includes producing programming objects that include variables and methods according to the processing architecture of the routing process.<br>
According to another aspect of the invention, the market maker node also supports the repository structure. Thus, a process is included at the market<br><br>
maker node for allowing access by participants in the network to a repository stored at the market maker node. As described above, the repository includes definitions of logic structures, interpretation information, and document definitions for use by the participant nodes to build transaction interface documents and includes instances of business interface definitions that identify the participants, and the transactions executed by the respective participants.<br>
The routing process includes according to various alternatives the translating of the input document into the variant processing architecture of the processes to which the document is to be routed, or routing the input document in its original document format across the network to a remote processing node, or to combinations of such processes. In alternatives, the routing process may also include techniques for transforming an input document defined according to one input document definition into a different document defined according to a different document specification for a process which has registered to watch for the input document.<br>
Also, the market maker node is provided according to the present invention as apparatus that includes a network interface, memory storing data and programs of instructions including the specifications of the participant interfaces, and a data processor. The logic is provided with the data processor in the form of programs of instructions or otherwise to perform the market maker process as discussed above.<br>
Accordingly, the present invention provides a foundation for electronic commerce based on the sharing of specifications of input and output documents. Documents provide an intuitive and flexible way to access business services, much simpler to implement than programming APIs. It is much easier to interconnect companies in terms of documents that are exchanged, on which such companies already largely agree, than in terms of business system interfaces which invariably differ. In addition, such documents are specified in a human readable format in the preferred embodiment. According to the present<br><br>
invention the business interfaces are specified in documents, such as XML documents that are readily interpretable by humans as well as by computers.<br>
Utilization of the document based transaction architecture of the present invention involves the use of a parser which operates in basically the same way for any source of documents, eliminating much of the need for custom programs to extract and integrate information from each participant in the network. Thus, integrating enterprise information from accounting, purchasing, manufacturing, shipping and other functions can be accomplished by first converting each source to a document having an architecture according to the present invention, and then processing the parsed data stream. Each node in the system that participates in the market only needs to know about the format of its internal systems, as well as the format of the documents being specified for interchange according to the transaction. Thus, there is no need to be able to produce the native format of every other node which might want to participate in the electronic commerce network.<br>
For complete business integration, the present invention provides a repository of standardized logical structures, like XML elements, attributes or meta data, establishing a semantic language for particular commerce communities, a means for mapping between different meta data descriptions, and a server for processing the documents and invoking appropriate applications and services. The basic building blocks of a network according to the present invention include the business interface definitions which tell potential trading partners what online services a company offers and which documents to use to invoke the services; and servers which provide the bridge to bind together the set of internal and external business services to create a trading community. The server operates to parse the incoming documents and invoke the appropriate services. Also the server according to the present invention handles the translation tasks from the format of the documents being received and transmitted, to and from the formats of the respective host systems. Thus,<br><br>
trading partners need only agree on the structure, content and sequencing of the business documents exchanged, and not on the details of application programmer interfaces. How a document is processed and the actions which result from receipt of a document are strictly up to the businesses providing the services. This elevates integration from the system level to the business level. It enables the business to present a clean and stable interface to its partners despite changes in its internal technology implementation, organization or processes.<br>
The whole process of building business interface definitions and enabling servers to manage commerce according to such descriptions is facilitated by a common business library, or repository, of information models for generic business concepts including business description primitives like companies, services and products, business forms like catalogs, purchase orders and invoices, and standard measurements, including time and date, location and classification of goods.<br>
Other aspects of the present invention can be seen upon review of the figures, the detailed description, and the claims which follow.<br>
BRIEF DESCRIPTION OF THE FIGURES<br>
Fig. 1 is a simplified diagram of an electronic commerce network including business interface definitions BIDs according to the present invention.<br>
Fig. 2 is a simplified diagram of a business interface definition document according to the present invention.<br>
Fig. 3 is a conceptual block diagram of a server for a participant node in the network of the present invention.<br>
Fig. 4 is a flow chart illustrating the processing of a received document at a participant node according to the present invention.<br>
Fig. 5 is a block diagram of a parser and transaction process front end for an XML based system.<br><br>
Fig. 6 is a conceptual diagram of the flow of a parse function.<br>
Fig. 7 is a simplified diagram of the resources at a server used for building a business interface definition according to the present invention.<br>
Fig. 8 is a simplified diagram of a repository according to the present invention for use for building business interface definitions.<br>
Fig. 9 is a flow chart illustrating the processes of building a business interface definition according to the present invention.<br>
Fig. 10 provides a heuristic view of a repository according to the present invention.<br>
Fig. 11 is a simplified diagram of the resources at a server providing the market maker function for the network of the present invention based on business interface definitions.<br>
Fig. 12 is a flow chart for the market maker node processing of a received document.<br>
Fig. 13 is a flow chart illustrating the process of registering participants at a market maker node according to the present invention.<br>
Fig. 14 is a flow chart illustrating the process of providing service specifications at a market maker node according to the process of Fig. 9.<br>
Fig. 15 is a diagram illustrating the sequence of operation at a participant or market maker node according to the present invention.<br>
Fig. 16 is a conceptual diagram of the elements of a commercial network based on BIDs, according to the present invention.<br>
DETAILED DESCRIPTION<br>
A detailed description of the present invention is provided with respect to the figures, in which Fig. 1 illustrates a network of market participants and market makers based on the use of business interface definitions, and supporting the trading of input and output documents specified according to such interface descriptions. The network includes a plurality of nodes 11-18 which are<br><br>
interconnected through a communication network such as the Internet 19, or other telecommunications or data communications network. Each of the nodes 11-19 consists of a computer, such as a portable computer, a desktop personal computer, a workstation, a network of systems, or other data processing resources. The nodes include memory for storing the business interface definition, processors that execute transaction processes supporting commercial transactions with other nodes in the network, and computer programs which are executed by the processors in support of such services. In addition each of the nodes includes a network interface for providing for communication across the Internet 19, or the other communication network.<br>
In the environment of Fig. 1, nodes 11,12,13,14,16 and 18 are designated market participants. Market participants include resources for consumers or suppliers of goods or services to be traded according to commercial transactions established according to the present invention.<br>
In this example, nodes 15 and 17 are market maker nodes. The market maker nodes include resources for registering business interface definitions, called a BID registry. Participants are able to send documents to a market maker node, at which the document is identified and routed to an appropriate participant which has registered to receive such documents as input. The market maker also facilitates the commercial network by maintaining a repository of standard forms making up a common business library for use in building business interface definitions.<br>
In this example, the market participant 18 is connected directly to the market maker 17, rather than through the Internet 19. This connection directly to the market maker illustrates that the configuration of the networks supporting commercial transactions can be very diverse, incorporating public networks such as the Internet 19, and private connections such as a local area network or a Point-to-Point connection as illustrated between nodes 17 and 18. Actual<br><br>
communication networks are quite diverse and suitable for use to establish commercial transaction networks according to the present invention.<br>
Fig. 2 is a heuristic diagram of nested structures in a business interface definition BID which is established for market participants in the network according to the present invention. The business interface definition illustrated in Fig. 2 is a data structure that consists of logic structures and storage units arranged according to a formal definition of a document structure, such as a XML document type definition DTD. The structure of Fig. 2 includes a first logic structure 200 for identifying a party. Associated with the logic structure 200 are nested logic structures for carrying the name 201, the physical address 202, the network address or location 203, and a set of transactions for a service 204. For each transaction in the service set, an interface definition is provided, including the transaction BID 205, the transaction BID 206, and the transaction BID 207. Within each transaction BID, such as transaction BID 205, logical structures are provided for including a name 208, a location on the network at which the service is performed 209, the operations performed by the service 210, and a set of input documents indicated by the tag 211. Also, the service BID 205 includes a set of output documents indicated by the tag 212. The set of input documents 211 includes a business interface definition for each input document for which the services are designed to respond, including input document business interface definitions 213,214, and 215. Each business interface definition for an input document includes a name 216, a location on the network at which a description of the document can be found 217, and the modules to be carried in the document as indicated by the field 218. In a similar manner, the output document set 212 includes interface definitions for output documents including the output document BID 219, output document BID 220, and output document BID 221. For each output document BID, a name 222, a location on the network or elsewhere 223, and the modules of the document 224 are specified. The business interface definition for the participant as illustrated<br><br>
in Fig. 2 includes actual definitions of a logic structures to be utilized for (he input and output documents of the respective services, or pointers or other references to locations at which these definitions can be found.<br>
In the preferred system, the document of Fig. 2 is specified in an XML document type definition DTD, although other document definition architectures could be used, and includes interpretation information for the logical structures used in interpretation of instances of the documents. In addition, each of the transaction BIDs, input document BIDs and output document BIDs are specified according to an XML document type definitions. The XML type document is an example of a system based on parsed data that includes mark-up data and character data. Mark-up data identifies logical structures within the document and sets of character data identify the content of the logical structures. In addition, unparsed data can be carried in the document for a variety of purposes. See for example the specification of the Extensible Mark-up Language XML 1.0 REC-XML-19980210 published by the WC3 XML Working Group at WWW.W3.ORG/TR/1998/REC-XML-19980210.<br>
Thus in an exemplary system, participant nodes in the network establish virtual enterprises by interconnecting business systems and services with XML encoded documents that businesses accept and generate. For example, the business interface definition of a particular service establishes that if a document matching the BID of a request for a catalog entry is received, then a document matching a BID of a catalog entry will be returned. Also, if a document matching the BID of a purchase order is received, and it is acceptable to the receiving terminal, a document matching the BID of an invoice will be returned. The nodes in the network process the XML documents before they enter the local business system, which is established according to the variant transaction processing architecture of any given system in the network. Thus, the system unpacks sets of related documents, such as MIME-encoded sets of XML documents, parses them to create a stream of "mark-up messages". The<br><br>
messages are routed to the appropriate applications and services using for example an event listener model like that described below.<br>
The documents exchanged between business services are encoded using an XML language built from a repository of building blocks (a common business language) from which more complex document definitions may be created. The repository stores modules of interpretation information that are focused on the functions and information common to business domains, including business description primitives like companies, services and products; business forms like catalogs, purchase orders and invoices; standard measurements, like time, date, location; classification codes and the like providing interpretation information for logical structures in the XML documents.<br>
The business interface definition is a higher level document that acts as a schema used for designing interfaces that trade documents according to the present invention. Thus the business interface definition bridges the gap between the documents specified according to XML and the programs which execute on the front end of the transaction processing services at particular nodes. Such front ends are implemented by JAVA virtual machines, or by other common architectures providing for interconnection of systems across a network. Thus, the business interface definition provides a technique by which a transaction protocol is programmed using the business interface definition document. The program for the protocol of the transaction is established by a detailed formal specification of a document type.<br>
An example business interface definition BID based on a market participant document which conforms to an XML format is provided below. The market participant DTD groups business information about market participants, associating contact and address information with a description of services and financial information. This business information is composed of names, codes, addresses, a dedicated taxonomic mechanism for describing<br><br>
business organization, and a pointer to terms of business. In addition, the services identified by the market participant DTD will specify the input and output documents which that participant is expected respond to and produce. Thus, documents which define schema using an exemplary common business language for a market participant DTD, a service DTD, and a transaction document DTD specified in XML with explanatory comments follow:<br><br>
Market Participant Sample<br><br><schema><br><hl>Market Participant Sample BID<br><meta>
WHO.OWNS="Veo Systems"        WHO.COPYRIGHT="Veo Systems"<br>
WHEN.COPYRIGHT="1998"       DESCRIPTION="Sample BID"<br>
WHO.CREATED=M*"	WHEN.CREATED="*"<br>
WHAT.VERSION="*"	WHO.MODIFIED-"*"<br>
WHEN.MODIFIED="*"	WHEN.EFFECTIVE="*"<br>
WHEN.EXPIRES=="*"	WHO.EFFECTIVE=,,*M<br>
WHO.EXPIRES="*"&gt;<br><br><prolog><br><xmldecl standalone=",,no,,"></xmldecl><br><doctypename><br><system>markpart.dtd</system><ydoctype><br><yprolog><br><dtd name="markpart.dtd"><br><h2>Market Participant</h2>
<br><h3>Market Participant</h3>
<br><elementtypename><br><explain><title>A Market Participant</title>
<br><synopsis>A business or person and its service interfaces.</synopsis><br><p>A market participant is a document definition that is created to describe a business and at<br>
least one person with an email address, and it presents a set of pointers to service interfaces<br>
located on the network. In this example, the pointers have been resolved and the complete BID<br>
is presented here.</p>
<p><yexplain><br><model><choice><br><elementname><br><element name="person"></element><br></elementname></choice></model><br><br><h3>Party Prototype</h3>
<br><prototype name="party"><br><explain><title>The Party Prototype</title></explain><br><model><sequence><br><element name="party.name" occurs="+"></element><br><elementname><br></elementname></sequence></model><br></prototype><br><h3>Party Types</h3>
<br><elementtype name="business"><br><explain><title>A Business</title>
<br><synopsis>A business (party) with a business number attribute.</synopsis><br><p>This element inherits the content model of the party prototype and adds a business number<br>
attribute, which serves as a key for database lookup. The business number may be used as a<br>
cross-reference to/from customer id, credit limits, contacts lists, etc.</p></explain><br><extends href="../index.html"><br><attdefname><required></required><br></attdefname></extends><br></elementtype><br><h3>Person Name</h3>
<br><elementtype name="person"><br><explarn><title>A Person</title></explarn><br><extends href="../index.html"><br><attdefname><implied></implied><br></attdefname></extends><br></elementtype><br><h3>Party Name</h3>
<br><elementtype name="party.name"><br><explarn><title>A Party's Name</title>
<br><synopsis>A party's name in a string of character.</synopsis></explarn></elementtype></yexplain></p></explain><br><model><string></string></model><br><br><br><h3>Address Set</h3>
<br><elementtype name="address.set"><br><model><sequence><br><elementname><br><element name="telephone" occurs="*"></element><br><element name="fax" occurs="*"></element><br><element name="emaiI" occurs="*"></element><br><element name="internet" occurs="*" x></element></elementname></sequence></model><br></elementtype><br><h3>Physical Address</h3>
<br><elementtypename><br><explain><title>PhysicalAddress</title>
<br><synopsis>The street address, city, state, and zip code.</synopsis><vexplain><br><model><sequence><br><element name="street"><br><element name="city"></element><br><element name="state"></element><br><element name="postcode" occurs="?"></element><br><element name="country"></element><br></element></sequence></model><br><br><h3>Street</h3>
<br><elementtype name="street"><explain><title>Street Address</title>
<synopsis>Street or postal address.</synopsis></explain><model><string></string></model></elementtype><br><h3>City</h3>
<br><elementtype name="city"><explain><title>City Name or Code</title>
<br><br><p>The city name or code is a string that contains sufficient information to identify a city within<br>
a designated state.</p>
<br></explain><br><model><string></string></model><br></elementtype><br><h3>State</h3>
<br><elementtype name='Hstate"'><br><explain><title>State, Province or Prefecture Name or Code</title>
<br><p>The state name or code contains sufficient information to identify a state within a designated<br>
country.</p></explain><br><model><stringdatatype><vstring></vstring></stringdatatype></model></elementtype><br><h3>Postal Code</h3>
<br><elementtype name="MpostcodeH"><br><explain><title>Postal Code</title>
<br><p>A postal code is an alphanumeric code, designated by an appropriate postal authority, that is<br>
used to identify a location or region within the jurisdiction of that postal authority. Postal<br>
authorities include designated national postal authorities.</p></explain><br><model><stringdatatype-hstring></stringdatatype-hstring></model><br></elementtype><br><h3>Country</h3>
<br><elemekttype name="country"><br><explain><title>Country Code</title>
<br><p>A country code is a two-letter code, designated by ISO, that is used to uniquely identify a<br>
country.</p></explain><br><model><stringdatatwe></stringdatatwe></model><br><br><h3>Network Addresses</h3> <elementtype name="telephone"><explain><title>Telephone Number</title>
<br><br><p>A telephone number is a string of alphanumerics and punctuation that uniquely identifies a telephone service terminal, including extension number.</p></explain><model><string></string></model></elementtype><br><h3>Fax<vh3><br><elementtype name="fax"><br><explain><title>Fax Number</title>
<br><p>A fax number is a string of alphanumerics and punctuation that uniquely identifies a fax<br>
service terminal.</p>
<br></explain><br><model><string></string></model><br></elementtype><br><h3>Email</h3>
<br><elementtype name="emair&gt;&lt;br/&gt;
&lt;EXPLAIN&gt;&lt;TITLE&gt;Email Address&lt;/TITLE&gt;&lt;br/&gt;
&lt;P&gt;An email address is a datatype-constrained string that uniquely identifies a mailbox on a&lt;br/&gt;
server.&lt;/P&gt;&lt;/EXPLAIN&gt;&lt;br/&gt;
&lt;MODEL&gt;&lt;STRmGDATATYPE=" email><br></elementtype><br><h3>Internet Address</h3>
<br><elementtype name="intemetM&gt;&lt;br/&gt;
&lt;EXPLAIN&gt;&lt;TITLE&gt;Internet Address&lt;/TITLE&gt;&lt;br/&gt;
&lt;P&gt;An Internet address is a datatype-constrained string that uniquely identifies a resource on the&lt;br/&gt;
Internet by means of a URL.&lt;/P&gt;&lt;/EXPLAIN&gt;&lt;br/&gt;
&lt;MODEL&gt;&lt;STRINGDATATYPE==MurlH&gt;&lt;/STRING&gt;&lt;/MODEL&gt;&lt;br/&gt;
&lt;/ELEMENTTYPE&gt;&lt;br/&gt;
&lt;7DTD&gt;&lt;br/&gt;
&lt;/SCHEMA&gt;&lt;br/&gt;
Service Description Sample&lt;br/&gt;
 &lt;br/&gt;
&lt;!DOCTYPE schema SYSTEM " bidl.dtd><br><schema><br><hl>Service Description Sample BHK/H1&gt;<br><meta>
WHO.OWNS="Veo Systems"       WHO.COPYRIGHT="Veo Systems"<br>
WHEN.COPYRIGHT="1998"       DESCRIPTION="Sample BID"<br>
WHO.CREATED="*"	WHEN.CREATED="*"<br>
WHAT.VERSION="*"	WHO.MODIFIED="*"<br>
WHEN.MODIFIED=" * "	WHEN.EFFECTIVE=" * "<br>
WHEN.EXPIRES="*"	WHO.EFFECTIVE="*"<br>
WHO.EXPIRES="*"&gt;<br><br><prolog><br><xmldeclstandalone><doctypename><system>service.dtd</system></doctypename></xmldeclstandalone></prolog><br><dtd name="service.dtd"><h2>Services</h2>
<br><h3>Includes</h3>
<br><system>comments.bim</system><br><h3>Service Set</h3>
<br><elementtype name="service.set"><br><explain><title>Service Set</title>
<br><synopsis>A set of services.</synopsis></explain><br><model><br><element name="service" occurs="+"></element><br></model></elementtype><br><h3>Services Prototype</h3> <prototypename><br><br><explain><title>Service</title></explain><br><model><sequence><br><elementname><br><element name='Mservice.terms"' occurs-></element><br><element name='Mservice.location"' occurs-><br><element name="service.operation" occurs="+" x><br></element></element></elementname></sequence><ymodel><br>
HREF=,,common.attrib,,x/IMPLEMENTS&gt;<br><br><h3>Service</h3>
<br><intro><p>A service is an addressable network resource that provides interfaces to specific<br>
operations by way of input and output documents.</p></intro><br><elementtype name="service"><br><explain>Service<br><p>A service is defined in terms of its name, the location(s) at which the service is available,<br>
and the operation(s) that the service performs.</p></explain><br><model><sequence><br><elementname><br><elementname><br><element name='=Mservice.operation"' occurs="+" x><br><elementname><br></elementname></element></elementname></elementname></sequence></model><br></elementtype><br><h3>Service Name</h3>
<br><elementtype name="Mservice.name,,"><br><explain><title>Service Name</title>
<br><p>The service name is a human-readable string that ascribes a moniker for a service. It may be<br>
employed is user interfaces and documentation, or for other purposes.</p></explain><br><modelxstring></modelxstring></elementtype></ymodel></model><br></prototypename></dtd></hl></schema></elementtype><br><h3>Service Location</h3>
<br><br><elementtypename><br><explain><title>ServiceLocation</title>
<br><synopsis>A URI of a service.</synopsis><br><p>A service location is a datatype-constrained string that locates a service on the Internet by<br>
means of a UR1.</p></explain><br><model><stringdatatype></stringdatatype></model><br><br><h3>Service Operations</h3>
<br><intro><p>A service operation consists of a name, location and its interface, as identified by<br>
the type of input document that the service operation accepts and by the type of document that it<br>
will return as a result.</p>
<br><elementtypename><br><explarn><title>ServiceOperations</title>
<br><p>A service operation must have a name, a location, and at least one document type as an<br>
input, with one or more possible document types returned as a result of the operation.</p>
<br></explarn></elementtypename></intro></elementtypename></vh3>
</h3></elemekttype></vexplain></explain><br><model><sequence><br><elementname><br><elementname><br><elementname><br><elementname><br></elementname></elementname></elementname></elementname></sequence></model><br><br><h3>Service Operation Name</h3>
<br><elementtypename><br><explain><title>Service Operation Name</title>
<br><p>The service operation name is a human-readable string that ascribes a moniker to a service<br>
operation. It may be employed in user interfaces and documentation, or for other<br>
purposes.</p></explain><br><model><string></string></model><br><br><h3>Service Operation Location</h3>
<br><br><intro><p>The service location is a network resource. That is to say, a URI.</p></intro><br>
^LEMENTTYPENAME^'^ervice.operation.location'^<br><explain><title>Service Operation Location</title>
<br><synopsis>A URI of a service operation.</synopsis><br><p>A service operation location is a datatype-constrained string that locates a service operation<br>
on the Internet by means of a URL.</p></explain><br><model><stringdatatype-nurlm></stringdatatype-nurlm></model><br><br><h3>Service Operation Input Document</h3>
<br><intro><p>The input to a service operation is defined by its input document type. That is, the<br>
service operation is invoked when the service operation location receives an input document<br>
whose type corresponds to the document type specified by this element.</p>
<br><p>Rather than define the expected input and output document types in the market participant<br>
document, this example provides pointers to externally-defined BIDs. This allows reuse of the<br>
same BID as the input and/or output document type for multiple operations. In addition, it<br>
encourages parallel design and implementation.</p></intro><br><elementtypename><br><explain><title>Service Operation Input</title>
<br><synopsis>Identifies the type of the service operation input document.</synopsis><br><p>Service location input is a datatype-constrained string that identifies a BID on the Internet<br>
bymeansofaURI.</p>
<br></explain><br><model><stringdatatype></stringdatatype></model><br><br><h3>Service Operation Output Document Type</h3>
<br><intro><p>The output of a service operation is defined by its output document type(s). That<br>
is, the service operation is expected to emit a document whose type corresponds to the document<br>
type specified by this element</p></intro><br><elementtypename><br><explain><title>Service Operation Output</title>
<br><synopsis>Identifies the type of the service operation output document.</synopsis><br><p>Service location output is a datatype-constrained string that identifies a BID on the Internet<br>
by means of a URL</p>
<br><br></explain><br><model><stringdatatype></stringdatatype></model><br><br><h3>Service Terms</h3>
<br><intro><p>This is a simple collection of string elements, describing the terms of an<br>
agreement.</p>
<br><elementtype name="service.terms"><br><explain><title>Service Terms</title>
<br><synopsis>Describes the terms of a given agreement.</synopsis><br></explain><br><model><stringdatatype></stringdatatype></model><br></elementtype><br></intro></elementtypename></elementtypename></elementtypename></elementtypename></elementtypename></dtd><br></yprolog></ydoctype></doctypename></prolog></hl></schema><br>
The service DTD schema may be extended with a service type element in a common business language repository as follows:<br>
service.type.name (<br>
catalog.operator<br>
| commercial.directory.operator<br>
| eft.services.provider<br>
| escrower<br>
| fulfillment.service<br>
| insurer<br>
| manufacturer<br>
| marketoperator<br>
| order.originator<br>
| ordering.service<br>
| personal.services.provider<br><br>
I retailer<br>
| retail.aggregator | schema.resolution.service | service.provider | shipment.acceptor | shipper | van<br>
| wholesale.aggregator ) ^REQUIRED %common.attrib; &gt;<br>
The service type element above illustrates interpretation information carried by a business interface definition, in this example a content form allowing identification of any one of a list of valid service types. Other interpretation information includes data typing, such as for example the element <h3>Internet Address</h3> including the content form "url" and expressed in the data type "string."   Yet other interpretation information includes mapping of codes to elements of a list, such as for example the element <h3>State</h3> including the code mapping for states in the file "COUNTRY.US.SUBENTITY."<br>
The service description referred to by the market participant DTD defines the documents that the service accepts and generates upon competition of the service. A basic service description is specified below as a XML document transactdtd.<br>
Transactdtd models a transaction description, such as an invoice, or a description of an exchange of value. This document type supports many uses, so the transaction description element has an attribute that allows user to distinguish among invoices, performance, offers to sell, requests for quotes and so on. The exchange may occur among more than two parties, but only two are called out, the offeror and the counter party, each of whom is represented by a<br><br>
pointer to a document conforming to the market participant DTD outlined above. The counter party pointer is optional, to accommodate offers to sell. The exchange description is described in the module tranprim.mod listed below, and includes pricing and subtotals. Following the exchange description, charges applying to the transaction as a whole may be provided, and a total charge must be supplied. Thus, the transaction description schema document transact.dtd for<br>
this example is set forth below:<br><br><!-- Copyright 1998 Veo Systems, Inc. --><br>
counterparty .pointer?, exhange.descrption+, general.charges?, net.total?)&gt; 
transaction.type (invoice | pro.forma | offer.to.sell | order | requestfor .quote | request.for.bid | requestfor.proposal | response.to.requesLfor.quote | response.to.request.for.bid | response.to.request.for.proposal) "invoice" %common.attrib; %altrep.attrib; %ttl.attrib; &gt;<br>
Representative market participant, and service DTDs, created according to the definitions above, are as follows:<br>
Market Participant DTD<br><br>
&gt;<br><ielement country><br><ielement person .name address.set>
&gt;<br><br><br><br><br><br>
Service DTD<br><br><br><br>
service.operation.input, service.operation.output) &gt;<br><br><br><br><br><br><br>
One instance of a document produced according to the transactdtd follows:<br><br><?xmlveraion ="1.0M?><br><!-- rorder.xml Version: 1.0 —><br/>
<!„ Copyright 1998 Veo Systems, Inc. --><br>rder"&gt; <meta>
<urn><br><thread.idparty.assigned.by>FRT876  <br><issuer.pointer><br><xlllocatorurllink>Customer Pointer  </xlllocatorurllink></issuer.pointer><counterparty.pointer><br><xll.locator urllink="compu.xml">Catalog entry owner pointer </xll.locator></counterparty.pointer><exchange.description><line.item><br><product.instance><productdescription.pointer><br><xll.locator urllink="cthink.xmr&gt;Catalogue Entry    Pointer &lt;yxll.locator&gt; &lt;/product.description.pointer&gt; &lt;productspecifics&gt; &lt;info.description.set&gt; &lt;info.description&gt; &lt;xml.descriptor&gt; &lt;doctype&gt;&lt;br/&gt;
 &lt;br/&gt;
&lt;dtd system.id==nurn:x-veosystems:dtd:cbl:gprod: 1.0"></xll.locator><br><br><xml.descriptor.details><br><xll.xptr.frag>DESCENDANT(ALL,os)STRINGC,Windows<br>
95")<br></xll.xptr.frag><br><xll.xptr.frag>DECENDANT(ALL,p.speed)STRlNG(n200") </xll.xptr.frag><xll.xptr.frag>DESCENDANT(ALL,hard.disk.capacity)<br>
STRING("4") <br><xn.xptr.frag>DESCENDANT(ALL,d.size)STRING(" 14.1") </xn.xptr.frag></xll.xptr.frag></xml.descriptor.details><br><quantity>l </quantity><br></productdescription.pointer></product.instance><shipment.coordinates.set><shipment.coordinates><shipment.destination><br><address.set><address.named>S W-1 </address.named><address.physical><br><building.sublocation>208C</building.sublocation><br><location.in.street>123<br></location.in.street><br><street>Frontage Rd.<br></street><br><city>Beltway<br></city><br><br><country.subentity.us></country.subentity.us>
country.subentity.us.name=MMDH/&gt;<br><postcode>20000<br></postcode></address.physical><telephone><br><telephone.number>617-666-2000<br></telephone.number><br><telephone.extension> 1201<br></telephone.extension></telephone></address.set></shipment.destination><br><shipment.special>No deliveries after 4 PM</shipment.special><br></shipment.coordinates><br></shipment.coordinates.set><br><paymentset><br><credit.card></credit.card>
issuer.name="VISA"<br>
instrument.number=,,3787-812345-67893,,<br>
expiry.date="12/97H<br>
currency.codes=MUSDt,/&gt;<br><amount.group><br><amount.monetarycurrency.code>3975 <br></amount.monetarycurrency.code></amount.group><br><line.item><br>
Accordingly, the present invention provides a technique by which a arket participant is able to identify itself, and identify the types of input<br><br>
documents and the types of output documents with which it is willing to transact business. The particular manner in which the content carried in such documents is processed by the other parties to the transaction, or by the local party, is not involved in establishing a business relationship nor carrying out transactions.<br>
Fig. 3 provides a simplified view of a participant node in the network according to the present invention. The node illustrated in Fig. 3 includes a network interface 300 which is coupled to a communication network on port 301. The network interface is coupled to a document parser 301. The parser 301 supplies the logical structures from an incoming document to a translator module 302, which provides for translating the incoming document into a form usable by the host transaction system, and vice versa translating the output of host processes into the format of a document which matches the output document form in the business interface definition for transmission to a destination. The parser 301 and translator 302 are responsive to the business interface definition stored in the participant module 303.<br>
The output data structures from the translator 302 are supplied to a transaction process front end 304 along with events signaled by the parser 301. The front end 304 in one embodiment consists of a JAVA virtual machine or other similar interface adapted for communication amongst diverse nodes in a network. The transaction processing front end 304 responds to the events indicated by the parser 301 and the translator 302 to route the incoming data to appropriate functions in the enterprise systems and networks to which the participant is coupled. Thus, the transaction process front end 304 in the example of Fig. 3 is coupled to commercial functions 305, database functions 306, other enterprise functions such as accounting and billing 307, and to the specific event listeners and processors 308 which are designed to respond to the events indicated by the parser.<br>
The parser 301 takes a purchase order like that in the example above, or other document, specified according to the business interface definition and<br><br>
creates a set of events that are recognized by the local transaction processing architecture, such as a set of JAVA events for a JAVA virtual machine.<br>
The parser of the present invention is uncoupled from the programs that listen for events based on the received documents. Various pieces of mark-up in a received document or a complete document meeting certain specifications serve as instructions for listening functions to start processing. Thus listening programs cany out the business logic associated with the document information. For example, a program associated with an address element may be code that validates the postal code by checking the database. These listeners subscribe to events by registering with a document router, which directs the relevant events to all subscribers who are interested in them.<br>
For example, the purchase order specified above may be monitored by programs listening for events generated by the parser, which would connect the document or its contents to an order entry program. Receipt of product descriptions within the purchase order, might invoke a program to check inventory. Receipt of address information within the purchase order, would then invoke a program to check availability of services for delivery. Buyer information fields in the document, could invoke processes to check order history for credit worthiness or to offer a promotion or similar processing based on knowing the identity of the consumer.<br>
Complex listeners can be created as configurations of primitive ones. For example, a purchase order listener may contain and invoke the list listeners set out in the previous paragraph, or the list members may be invoked on their own. Note that the applications that the listeners run are unlikely to be native XML processes or native JAVA processes. In these cases, the objects would be transformed into the format required by the receiving trans application. When the application finishes processing, its output is then transformed back to the XML format for communication to other nodes in the network.<br><br>
It can be seen that the market participant document type description, and the transaction document type description outlined above include a schematic mapping for logic elements in the documents, and include mark-up language based on natural language. The natural language mark-up, and other natural language attributes of XML facilitate the use of XML type mark-up languages for the specification of business interface definitions, service descriptions, and the descriptions of input and output documents.<br>
The participant module 303 in addition to storing the business interface definition includes a compiler which is used to compile objects or other data structures to be used by the transaction process front end 304 which corresponds to the logical structures in the incoming documents, and to compile the translator 302. Thus, as the business interface definition is modified or updated by the participant as the transactions with which the participant is involved change, the translator 302 and parser 301 are automatically kept up to date.<br>
In a preferred system, the set of JAVA events is created by a compiler which corresponds to the grove model of SGML, mainly the standard Element Structure Information Set augmented by the "property set1' for each element. International Standard ISO/IEC10179:1996 (E)t Information Technology -Processing Languages - Document Style Semantics and Specification Language (DSSSL). Turning the XML document into a set of events for the world to process contrasts with the normal model of parsing in which the parser output is maintained as an internal data structure. By translating the elements of the XML document into JAVA events or other programming structures that are suitable for use by the transaction processing front end of the respective nodes enables rich functionality at nodes utilizing the documents being traded.<br>
Thus, the transaction process front end 304 is able to operate in a publish and subscribe architecture that enables the addition of new listener programs without the knowledge of or impact on other listening programs in the system. Each listener, 305, 306, 307, 308 in Fig. 3, maintains a queue in which the front<br><br>
end 304 directs events. This enables multiple listeners to handle events in parallel at their own pace.<br>
Furthermore, according to the present invention the applications that the listeners run need not be native XML functions, or native ftinctions which match the format of the incoming document. Rather, these listeners may be JAVA functions, if the transaction process front end 304 is a JAVA interface, or may be functions which run according to a unique transaction processing architecture. In these cases, the objects would be transformed into the format required by the receiving application. When the application of the listener finishes, its output is then transformed back into the format of a document as specified by the business interface definition in the module 303. Thus, the translator 302 is coupled to the network interface 300 directly for supplying the composed documents as outputs.<br>
The listeners coupled to the transaction processing front end may include listeners for input documents, listeners for specific elements of the input documents, and listeners for attributes stored in particular elements of the input document. This enables diverse and flexible implementations of transaction processes at the participant nodes for filtering and responding to incoming documents.<br>
Fig. 4 illustrates a process of receiving and processing an incoming document for the system of Fig. 3. Thus, the process begins by receiving a document at the network interface (step 400). The parser identifies the document type (401) in response to the business interface definition. Using the business interface definition, which stores a DTD for the document in the XML format, the document is parsed (step 402). Next, the elements and attributes of the document are translated into the format of the host (step 403). In this example, the XML logic structures are translated into JAVA objects which carry the data of the XML element as well as methods associated with the data such as get and set functions. Next, the host objects are transferred to the host<br><br>
transaction processing front end (step 404). These objects are routed to processes in response to the events indicated by the parser and the translator. The processes which receive the elements of the document are executed and produce an output (step 405). The output is translated to the format of an output document as defined by the business interface definition (step 406). In this example, the translation proceeds from the form of a JAVA object to that of an XML document. Finally, the output document is transmitted to its destination through the network interface (step 407).<br>
Fig. 5 is a more detailed diagram of the event generator/event listener mechanism for the system of Fig. 3. In general the approach illustrated in Fig. 5 is a refinement of the JAVA JDK 1.1 event model. In this model, three kinds of objects are considered. A first kind of object is an event object which contains information about the occurrence of an event. There may be any number of kinds of event objects, corresponding to all the different kinds of events which can occur. A second kind of object is an Event generator, which monitors activity and generates event objects when something happens. Third, event listeners, listen for event objects generated by event generators. Event listeners generally listen to specific event generators, such as for mouse clicks on a particular window. Event listeners call an "ADD event listener" method on the event generator. This model can be adapted to the environment of Fig. 3 in which the objects are generated in response to parsing and walking a graph of objects, such as represented by an XML document.<br>
The system illustrated in Fig. 5 includes a generic XML parser 500. Such parser can be implemented using a standard call back model. When a parsing event occurs, the parser calls a particular method in an application object, passing in the appropriate information in the parameters. Thus a single application 501 resides with the parser. The application packages the information provided by the parser in an XML event object and sends it to as many event listeners as have identified themselves, as indicated by the block<br><br>
502. The set of events 502 is completely parser independent. The events 502 can be supplied to any number of listeners and any number of threads on any number of machines. The events are based on the element structure information set ESIS in one alternative. Thus, they consist of a list of the important aspects of a document structure, such as the starts and ends of elements, or of the recognition of an attribute. XML (and SGML) parsers generally use the ESIS structure as a default set of information for a parser to return to its application.<br>
A specialized ESIS listener 503 is coupled to the set of events 502. This listener 503 implements the ESIS listener API, and listens for all XML events from one or more generators. An element event generator 504 is a specialized ESIS listener which is also an XML event generator. Its listeners are objects only interested in events for particular types of elements. For example in an HTML environment, the listener may only be interested in ordered lists, that is only the part of the document between the <ol> and </ol>tags. For another example, a listener may listen for "party.name" elements, or for "service.name" elements according to the common business language, from the example documents above, process the events to ensure that the elements carry data that matches the schematic mapping for the element, and react according to the process needed at the receiving node.<br>
This allows the system to have small objects that listen for particular parts of the document, such as one which only adds up prices. Since listeners can both add and remove themselves from a generator, there can be a listener which only listens to for example the  part of an HTML document Because of this and because of the highly recursive nature of XML documents, it is possible to write highly targeted code, and to write concurrent listeners. For example, an <ol> listener can set up an <li> listener completely separate from the manner in which the <ul> (unordered list) listener sets up its <li> listener. Alternatively, it can create a listener which generates a graphic user interface and another which searches a database using the same input. Thus, the<br><br>
transaction processing front end (step 404). These objects are routed to processes in response to the events indicated by the parser and the translator. The processes which receive the elements of the document are executed and produce an output (step 405). The output is translated to the format of an output document as defined by the business interface definition (step 406). In this example, the translation proceeds from the form of a JAVA object to that of an XML document. Finally, the output document is transmitted to its destination through the network interface (step 407).<br>
Fig. 5 is a more detailed diagram of the event generator/event listener mechanism for the system of Fig. 3. In general the approach illustrated in Fig. 5 is a refinement of the JAVA JDK 1.1 event model. In this model, three kinds of objects are considered. A first kind of object is an event object which contains information about the occurrence of an event. There may be any number of kinds of event objects, corresponding to all the different kinds of events which can occur. A second kind of object is an Event generator, which monitors activity and generates event objects when something happens. Third, event listeners, listen for event objects generated by event generators. Event listeners generally listen to specific event generators, such as for mouse clicks on a particular window. Event listeners call an "ADD event listener" method on the event generator. This model can be adapted to the environment of Fig. 3 in which the objects are generated in response to parsing and walking a graph of objects, such as represented by an XML document.<br>
The system illustrated in Fig. 5 includes a generic XML parser 500. Such parser can be implemented using a standard call back model. When a parsing event occurs, the parser calls a particular method in an application object, passing in the appropriate information in the parameters. Thus a single application 501 resides with the parser. The application packages the information provided by the parser in an XML event object and sends it to as many event listeners as have identified themselves, as indicated by the block<br><br>
502. The set of events 502 is completely parser independent. The events 502 can be supplied to any number of listeners and any number of threads on any number of machines. The events are based on the element structure information set ESIS in one alternative. Thus, they consist of a list of the important aspects of a document structure, such as the starts and ends of elements, or of the recognition of an attribute. XML (and SGML) parsers generally use the ESIS structure as a default set of information for a parser to return to its application.<br>
A specialized ESIS listener 503 is coupled to the set of events 502. This listener 503 implements the ESIS listener API, and listens for all XML events from one or more generators. An element event generator 504 is a specialized ESIS listener which is also an XML event generator. Its listeners are objects only interested in events for particular types of elements. For example in an HTML environment, the listener may only be interested in ordered lists, that is only the part of the document between the <ol> and </ol>tags. For another example, a listener may listen for "party.name" elements, or for "service.name" elements according to the common business language, from the example documents above, process the events to ensure that the elements carry data that matches the schematic mapping for the element, and react according to the process needed at the receiving node.<br>
This allows the system to have small objects that listen for particular parts of the document, such as one which only adds up prices. Since listeners can both add and remove themselves from a generator, there can be a listener which only listens to for example the  part of an HTML document. Because of this and because of the highly recursive nature of XML documents, it is possible to write highly targeted code, and to write concurrent listeners. For example, an <ol> listener can set up an <li> listener completely separate from the manner in which the <ul> (unordered list) listener sets up its <li> listener. Alternatively, it can create a listener which generates a graphic user interface and another which searches a database using the same input. Thus, the<br><br>
document is treated as a program executed by the listeners, as opposed to the finished data structure which the application examines one piece at a time. If an application is written this way, it is not necessary to have the entire document in memory to execute an application.<br>
The next listener coupled to the set of events 502 is an attribute filter 505. The attribute filter 505 like the element filter 504 is an attribute event generator according to the ESIS listener model. The listener for an attribute filter specifies the attributes it is interested in, and receives events for any element having that attribute specified. So for example, a font manager might receive events only for elements having a font attribute, such as the <p font="Times Roman">.<br>
The element event generator 504 supplies such element objects to specialize the element listeners 504A.<br>
The attribute event generator 505 supplies the attribute; event objects to attribute listeners 505A. Similarly, the attribute objects are supplied to a "architecture" in the sense of an SGML/XML transformation from one document type to another using attributes. Thus the architecture of 505B allows a particular attribute with a particular name to be distinguished. Only elements with that attribute defined become part of the output document, and the name of the element in the output document is the value of the attribute in the input document. For example, if the architecture 505B is HTML, the string:<br>
PURCHASES HTML=MOL"&gt;<item html="LI"><name></name>
HTML="B"&gt;STUFF<price></price>
HTML="B"&gt;123</item> translates into:<br></p>
<ol><li>
<b>STUFF</b><b>123</b>
</li></ol> which is correct HTML.<br>
The next module which is coupled to the set of events 502 is a tree builder 506. The tree builder takes a stream of XML events and generates a tree<br><br>
representation of the underlying document. One preferred version of the tree builder 506 generates a document object model DOM object 507, according to the specification of the W3C (See, http://www.w3.org/TR/1998/ WD-DOM-19980720/ introduction.html). However listeners in event streams can be used to handle most requirements, a tree version is useful for supporting queries around a document, reordering of nodes, creation of new documents, and supporting a data structure in memory from which the same event stream can be generated multiple times, for example like parsing the document many times. A specialized builder 508 can be coupled to the tree builder 506 in order to build special subtrees for parts of the document as suits a particular implementation.<br>
In addition to responses to incoming documents, other sources of XML events 502 can be provided. Thus, an event stream 510 is generated by walking over a tree of DOM objects and regenerating the original event stream created when the document was being parsed. This allows the system to present the appearance that the document is being parsed several times.<br>
The idea of an object which walks a tree and generates a stream of events can be generalize beyond the tree of DOM objects, to any tree of objects which can be queried. Thus, a JAVA walker 512 may be an application which walks a tree of JAVA bean components 513. The walker walks over all the publicly accessible fields and methods. The walker keeps track of the objects it has already visited to ensure that it doesrit go into an endless cycle. JAVA events 514 are the type of events generated by the JAVA walker 512. This currently includes most of the kinds of information one can derive from an object. This is the JAVA equivalent of ESIS and allows the same programming approach applied to XML to be applied to JAVA objects generally, although particularly to JAVA beans.<br>
The JAVA to XML event generator 515 constitutes a JAVA listener and a JAVA event generator. It receives the stream of events 514 from the JAVA<br><br>
walker 512 and translates selected ones to present a JAVA object as an XML document. In the one preferred embodiment, the event generator 515 exploits the JAVA beans API. Each object seen becomes an element, with the element name the same as the class name. Within that element, each embedded method also becomes an element whose content is the value returned by invoking the method. If it is an object or an array of objects, then these are walked in turn.<br>
Fig. 6 outlines a particular application built on the framework of Fig. 5, This application takes in an XML document 600 and applies it to a parser/generator 601. ESIS events 602 are generated and supplied to an attribute generator 603 and tree builder 604. The attribute generator corresponds to the generator 505 of Fig. 5. It supplies the events to the "architecture" 505B for translating the XML input to an HTML output for example. These events are processed in parallel as indicated by block 605 and processed by listeners. The output of the listeners are supplied to a document writer 506 and then translated back to an XML format for output. Thus for example this application illustrated in Fig. 6 takes an XML document and outputs an HTML document containing a form. The form is then sent to a browser, and the result is converted back to XML. For this exercise, the architecture concept provides the mapping from XML to HTML. The three architectures included in Fig. 6 include one for providing the structure of the HTML document, such as tables and lists, a second specifying text to be displayed, such as labels for input fields on the browser document, and the third describes the input fields themselves. The elements of the XML document required to maintain the XML documents structure become invisible fields in the HTML form. This is useful for use in reconstruction of the XML document from the information the client will put into the HTTP post message that is sent back to the server. Each architecture takes the input document and transforms it into an architecture based on a subset of HTML. Listeners listening for these events, output events for the HTML document, which then go to a document<br><br>
writer object. The document writer object listens to XML events and turns them back into an XML document. The document writer object is a listener to all the element generators listening to the architectures in this example.<br>
The organization of the processing module illustrated in Figs. 5 and 6 is representative of one embodiment of the parser and transaction process front end for the system of Fig. 3. As can be seen, a very flexible interface is provided by which diverse transaction processes can be executed in response to the incoming XML documents, or other structured document formats.<br>
Fig. 7 illustrates a node similar to that of Fig. 3, except that it includes a business interface definition builder module 700. Thus, the system of Fig. 7 includes a network interface 701, a document parser 702, and a document translator 703. The translator 703 supplies its output to a transaction processing front end 704, which in turn is coupled to listening functions such as commercial functions 705, a database 706, enterprise functions 707, and other generic listeners and processors 708. As illustrated in Fig. 7, the business interface definition builder 700 includes a user interface, a common business library CBL repository, a process for reading complementary business interface definitions, and a compiler. The user interface is used to assist an enterprise in the building of a business interface definition relying on the common business library repository, and the ability to read complementary business interface definitions. Thus, the input document of a complementary business interface definition can be specified as the output document of a particular transaction, and the output document of the complementary business interface definition can be specified as the input to such transaction process. In a similar manner a transaction business interface definition can be composed using components selected from the CBL repository. The use of the CBL repository encourages the use of standardized document formats, such as the example schema (bidl) documents above, logical structures and interpretation information in the<br><br>
building of business interface definitions which can be readily adopted by other people in the network.<br>
The business interface definition builder module 700 also includes a compiler which is used for generating the translator 703, the objects to be produced by the translator according to the host transaction processing architecture, and to manage the parsing function 702.<br>
Fig. 8 is a heuristic diagram showing logical structures stored in the repository in the business interface definition builder 700. Thus, the repository storage representative party business interface definitions 800, including for example a consumer BID 801, a catalog house BID 802, a warehouse BID 803, and an auction house BID 804. Thus, a new participant in an online market may select as a basic interface description one of the standardized BIDs which best matches its business. In addition, the repository will store a set of service business interface definitions 805. For example, an order entry BID 806, an order tracking BID 807, an order fulfillment BID 808, and a catalog service BID 809 could be stored. As a new participant in the market builds a business interface definition, it may select the business interface definitions of standardized services stored in the repository.<br>
In addition to the party and service BIDs, input and output document BIDs are stored in the repository as indicated by the field 810. Thus, a purchase order BID 811, an invoice BID 812, a request for quote BID 813, aproduct availability report BID 814, and an order status BID 815 might be stored in the repository.<br>
The repository, in addition to the business interface definitions which in a preferred system are specified as document type definitions according to XML, stores interpretation information in the form of semantic maps as indicated by the field 816. Thus, semantic maps which are used for specifying weights 817, currencies 818, sizes 819, product identifiers 820, and product features 821 in this example might be stored in the repository. Further, the<br><br>
interpretation information provides for typing of data structures within the logical structures of documents.<br>
In addition, logical structures used in the composing of business interface definitions could be stored in the repository as indicated by block 822. Thus, forms for providing address information 823, forms for providing pricing information 824, and forms for providing terms of contractual relationships could be provided 825. As the network expands, the CBL repository will also expand and standardize tending to make the addition of new participants, and the modification of business interface definitions easier.<br>
Fig. 9 illustrates the process of building a business interface definition using the system of Fig. 7. The process begins by displaying a BID builder graphical interface to the user (step 900). The system accepts user input identifying a participant, service and document information generated by the graphical interface (step 901).<br>
Next, any referenced logical structures, interpretation information, document definitions and/or service definitions are retrieved from the repository in response to user input via the graphical user interface (step 902). In the next step, any complementary business interface definitions or components of business interface definitions are accessed from other participants in the network selected via user input, by customized search engines, web browsers or otherwise (step 903). A document definition for the participant is created using the information gathered (step 904). The translators for the document to host and host to document mappers are created by the compiler (step 905). Host architecture data structures corresponding to the definition are created by the compiler (step 906), and the business interface definition which has been created is posted on the network, such as by posting on a website or otherwise, making it accessible to other nodes in the network (step 907).<br>
Business interface definitions tell potential trading partners the online services the company offers and which documents to use to invoke those<br><br>
services. Thus, the services are defined in the business interface definition by the documents that they accept and produce. This is illustrated in the following<br>
fragment of an XML service definition.<br><service><br><service.name>Order Service</service.name><br><service.location>www.veosystems.com/order</service.location><br><service.op><br><service.op.name>SubmitOrder</service.op.name><br><service>wwwxommerce.net/po.dtd<br><service.op.outputdoc><br>
www.veosystemsxom/invoice.dtd</service.op.outputdoc></service></service.op><br><br>Track Order <service.op.inputdoc> www.commerce.net<br>
/request.track.dtd<service.op.inputdoc><service.op.outputdoc><br>
www.veosystems.com/response.track.dtd<service.op.outputdoo></service.op.outputdoo></service.op.outputdoc></service.op.inputdoc></service.op.inputdoc></service><br>
This XML fragment defines a service consisting of two transactions, one for taking orders and the other for tracking them. Each definition expresses a contract or promise to carry out a service if a valid request is submitted to the specified Web address. The Order service here requires an input document that conforms to a standard "po.dtd" Document Type Definition located in the repository, which may be local, or stored in an industry wide registry on the network. If a node can fulfill the order, it will return a document conforming to a customized "invoice.dtd" whose definition is local. In effect, the company is promising to do business with anyone who can submit a Purchase Order that conforms to the XML specification it declares. No prior arrangement is necessary.<br><br>
The DTD is the formal specification or grammar for documents of a given type; it describes the elements, their attributes, and the order in which they must appear. For example, purchase orders typically contain the names and addresses of the buyer and seller, a set of product descriptions, and associated terms and conditions such as price and delivery dates. In Electronic Data Interchange EDI for example, the X12 850 specification is a commonly used model for purchase orders.<br>
The repository encourages the development of XML document models from reusable semantic components that are common to many business domains. Such documents can be understood from their common message elements, even though they may appear quite different. This is the role of the Common Business Library repository.<br>
The Common Business Library repository consists of information models for generic business concepts including:<br>
•	business description primitives like companies, services, and products;<br>
•	business forms like catalogs, purchase orders, and invoices;<br>
•	standard measurements, date and time, location, classification codes.<br>
This information is represented as an extensible, public set of XML building blocks that companies can customize and assemble to develop XML applications quickly. Atomic CBL elements implement industry messaging standards and conventions such as standard ISO codes for countries, currencies, addresses, and time. Low level CBL semantics have also come from analysis of proposed metadata frameworks for Internet resources, such as Dublin Core.<br>
The next level of elements use these building blocks to implement the basic business forms such as those used in X12 EDI transactions as well as those used in emerging Internet standards such as OTP (Open Trading Protocol) and OBI (Open Buying on the Internet).<br><br>
CBL's focus is on the functions and information that are common to all business domains (business description primitives like companies, services, and products; business forms like catalogs, purchase orders, and invoices; standard measurements, date and time, location, classification codes), CBL builds on standards or industry conventions for semantics where possible (e.g., the rules that specify "day/month/year" in Europe vs "month/day/year11 in the U.S. are encoded in separate CBL modules).<br>
The CBL is a language that is used for designing applications. It is designed to bridge the gap between the "document world" of XML and the "programming world" of JAVA or other transaction processing architectures. Schema embodies a philosophy of "programming with documents" in which a detailed formal specification of a document type is the master source from which a variety of related forms can be generated. These forms include XML DTDs for CBL, JAVA bbjects, programs for converting XML instances to and from the corresponding JAVA objects, and supporting documentation.<br>
The CBL creates a single source from which almost all of the pieces of a system can be automatically generated by a compiler. The CBL works by extending SGML/XML, which is normally used to formally define the structures of particular document types, to include specification of the semantics associated with each information element and attribute. The limited set of (mostly) character types in SGML/XML can be extended to declare any kind of datatype.<br><br>
Here is a fragment from the CBL definition for the "datetime" module:<br><br><br>
schema CDATA #FIXED "urn:x-veosystems:stds:iso:8601:3.8" &gt;<br>
schema CDATA #FIXED "urn:x-veosystems:stds:iso:8601:3.12M &gt;<br>
In this fragment, the ELEMENT "year" is defined as character data, and an associated "schema" attribute, also character data, defines the schema for "year" to be section 3.8 of the ISO 8601 standard.<br>
This "datetime" CBL module is in fact defined as an instance of the Schema DTD. First, the module name is defined. Then the "datetime" element "YEAR" is bound to the semantics of ISO 8601:<br><schema><hl>Date and Time Module</hl><br><elemnttype name="year" datatype="YEAR,t&gt;&lt;MODEL&gt;&lt;br/&gt;
&lt;STRING DATATYPE=" year><attdef name=":schema:iso8601n" datatype="CDATA"><br><fixed>3.8 Gregorian calendar</fixed></attdef><br><br>
The example market participant and service modules above are also stored in the CBL repository.<br>
In Fig. 10, an Airbill 1000 is being defined by customizing a generic purchase order DTD 1001, adding more specific information about shipping weight 1002. The generic purchase order 1001 was initially assembled from the ground up out of CBL modules for address, date and time, currency, and vendor and product description. Using CBL thus significantly speeds the development and implementation of XML commerce applications. More importantly, CBL makes it easier for commercial applications to be interconnected.<br>
In the CBL, XML is extended with a schema. The extensions add strong-typing to XML elements so that content can be readily validated. For example, an element called <cpu_clock_speed> can be defined as an integer with a set of valid values: {100,133,166,200, 233,266 Mhz.}. The schema also adds class-subclass hierarchies, so that information can be readily instantiated from class definitions. A laptop, for instance, can be described as a computer with additional tags for features such as display type and battery life. These and other extensions facilitate data entry, as well as automated translations between XML and traditional Object-Oriented and relational data models.<br>
Thus the completed BID is run through the compiler which produces the DTDs for the actual instance of a participant and a service as outlined above, the JAVA beans which correspond to the logical structures in the DTD instances, and transformation code for transforming from XML to JAVA and from JAVA to XML. In alternative systems documentation is also generated for display on a user interface or for printing by a user to facilitate use of the objects.<br>
For the example market participant and service DTDs set forth above, the JAVA beans generated by the compiler are set forth (with some redactions for conciseness) as follows:<br><br>
import com.veo.vsp.doclet.meta.Document; public class AddressPhysical extends Document {<br>
public static final String DOCJTYPE = "address.physical";<br>
String mStreet;<br>
String mCity;<br>
public final static int AK = 0; public final static int AL = 1; public final static int AR = 2; public final static int AZ = 3; public final static int CA = 4;<br>
public final static int Wl = 48; public final static int WV = 49; public final static int WY = 50;<br>
int mState;<br>
String mPostcode; public final static int AD = 51; public final static int AE = 52; public final static int AF = 53; public final static int AG = 54; public final static int AI = 55; public final static int AM = 56;<br>
int mCountry; public AddressPhysical(){<br>
super(DOCJTYPE); mStreet - new StringO; mCity * new StringO;<br>
this.mState = -l; mPostcode - null;<br>
this.mCountry = -1;<br>
}<br>
public AddressPhysical(String doc_type){<br><br>
super(doc_type); mStreet = new StringO; mCity = new StringO;<br>
this.mState = -l; mPostcode = null;<br>
this.mCountry = -l;<br>
}<br>
static public AddressPhysical initAddressPhysical(String iStreet,String iCity,int<br>
iState,String iPostcode,int iCountry){<br>
AddressPhysical obj = new AddressPhysicalO;<br>
obj.initializeAH(iStreet, iCity, iState, iPostcode, iCountry);<br>
return obj;<br>
}<br>
public void initializeAll(String iStreet,String iCity,int iState,String iPostcode,int iCountry) {<br>
mStreet = iStreet; mCity - iCity; mState = iState; mPostcode = iPostcode; mCountry = iCountry;<br>
}<br>
public String getStreet(){ return mStreet;<br>
}<br>
public String getStreetToXML(){<br>
if (getStreet() == null) return null; char [] c = getStreet().toCharArray(); StringBuffer sb = new StringBuffer(); for (int x = 0; x ':<br>
sb.append("&gt;n); break; case •
 <br>
sb.append("
break; case '&amp;':<br>
sb.append("&amp;");<br>
break; case "":<br>
sb.append(""");<br>
break; case V:<br>
sb.append(""");<br>
break; default:<br>
if (Character. isDefined(c[x])) sb.append(c[x]);<br>
}<br>
}<br>
return sb.toString();<br>
}<br>
public void setStreet(String inp){<br>
this.mStreet * inp;<br>
}<br>
public void streetFromXML(String n){<br>
setStreet(n);<br>
}<br>
public String getCityO { return mCity;<br>
}<br>
public String getCityToXML(){<br>
if (getCity() — null) return null; char [] c = getCity().toCharArrayO; StringBuffer sb = new StringBufferO; for (int x - 0; x ': sb.append("&gt;M);<br><br>
break; case •
sb.append(n<m></m>
break; case '&amp;':<br>
sb.append(M&amp;");<br>
break; case ,m:<br>
sb.append(""");<br>
break; case T:<br>
sb.append(""H);<br>
break; default:<br>
if(Character.isDefmed(c[x])) sb.append(c[x]);<br>
}<br>
}<br>
return sb.toString();<br>
}<br>
public void setCity(String inp){<br>
this.mCity «inp;<br>
}<br>
public void cityFromXML(String n){<br>
setCity(n);<br>
}<br>
public intgetState(){ return mState;<br>
}<br>
public String getStateToXML(){<br>
switch (mState){<br>
case AK: return "AK"; case AL: return "AL"; case AR: return HAR"; case AZ: return "AZ";<br><br>
}<br>
return null;<br>
}<br>
public void setState(int inp){<br>
this.mState = inp;<br>
}<br>
public void stateFromXML(String s){<br>
if (s.equalsC'AK")) mState = AK;<br>
else if (s.equals("AL,,))mState » AL;<br>
else if (s.equalsC'AR^mState = AR;<br>
else if (s.equals("AZ"))mState = AZ;<br>
}<br>
public String getPostcode(){<br>
return mPostcode;<br>
}<br>
public String getPostcodeToXML(){<br>
if (getPostcode() = null) return null; char [] c = getPostcode().toCharArrayO; StringBuffer sb = new StringBuffer(); for (int x = 0; x ': sb.append("&gt;"); break; case '<: sb.append break case></:><br>
sb.append(H"M);<br>
break; case V:<br>
sb.append(""");<br>
break; default:<br>
if(Character.isDefined(c[x]))<br>
sb.append(c[x]);<br>
}<br>
}<br>
return sb.toStringO;<br>
}<br>
public void setPostcode(String inp){<br>
this.mPostcode = inp;<br>
}<br>
public void postcodeFromXML(String n){<br>
setPostcode(n);<br>
}<br>
public int getCountry(){<br>
return mCountry;<br>
}<br>
public String getCountryToXML(){<br>
switch (mCountry) {<br>
case AD: return "AD";<br>
case AE: return "AE";<br>
case AF: return "AF";<br>
}<br>
return null;<br>
}<br>
public void setCountry(int inp){<br>
this.mCountry = inp;<br>
}<br>
public void countryFromXML(String s){<br><br>
if (s.equals("AD")) mCountry - AD; else if (s.equals("AE"))mCountry = AE; else if (s.equals(nAF"))mCountry = AF; else if (s.equals(nAGf,))mCountry « AG; else if (s.equals("Ar))niCountry = AI;<br>
} }<br>
package com.veo.xdk.dev.schema.test.blib;<br>
import com.veo.vsp.doclet.meta.Document; public class AddressSet extends Document {<br>
public static final String DOCJTYPE - "address.set"; AddressPhysical mAddressPhysical; String [] mTelephone; String [] mFax; String [] mEmail; String [] mlnternet; public AddressSet(){<br>
super(DOCJTYPE);<br>
this.mAddressPhysical - new AddressPhysical(); mTelephone = null; mFax = null; mEmail = null; mlnternet = null;<br>
}<br>
public AddressSet(String doc_type){<br>
super(doc_type);<br>
this.mAddressPhysical = new AddressPhysical(); mTelephone = null; mFax = null; mEmail = null; mlnternet = null;<br><br>
}<br>
static public AddressSet initAddressSet(AddressPhysical iAddressPhysical,String [] iTelephone,String [] iFax,String [] iEmail,String [] ilnternet){ AddressSet obj = new AddressSet();<br>
obj.initializeAH(iAddressPhysical, iTelephone, iFax, iExnail, ilnternet); return obj;<br>
}<br>
public void initializeAH(AddressPhysical iAddressPhysical,String [] iTelephone,String [] iFax,String [] iEmail,String [] ilnternet) {<br>
mAddressPhysical = iAddressPhysical; mTelephone - iTelephone; mFax = iFax; mEmail = iEmail; mlnternet = ilnternet;<br>
}<br>
public AddressPhysical getAddressPhysical(){<br>
return mAddressPhysical;<br>
public void setAddressPhysical(AddressPhysical inp){ this.mAddressPhysical = inp;<br>
}<br>
public String [] getTelephone(){<br>
return mTelephone;<br>
}<br>
public String getTelephone(int index) {<br>
if (this.mTelephone — null)<br>
return null; if (index &gt;= this.mTelephone.length)<br>
return null; if (index  this.mTelephone.length)<br>
return null; if (index &gt;= 0) return this.mTelephone[index]; return this.mTelephone[this.mTelephone.length + index];<br><br>
public String [] getTelephoneToXML(){ String [] valArr = getTelephone(); if (valArr — null) return null; String [] nvArr - new String[valArr.length]; for (int z = 0; z ':<br>
sb.append("&gt;");<br>
break; case '
sb.append("
break; case '&amp;':<br>
sb.append("&amp;");<br>
break; case,m:<br>
sb.append("""); break;<br>
case'":<br>
sb.append(M"M); break; default: if (Character.isDefined(c[x])) sb.append(c[x]); } }<br>
nvArr[z]« sb.toStringO; } return nvArr;<br>
}<br>
public void setTelephone(int index, String inp){<br><br>
if (this.mTelephone == null) { if(index
this.mTelephone = new String[l];<br>
this.mTelephone[0] = inp; } else {<br>
this.mTelephone = new String[index + 1];<br>
this.mTelephone[index] = inp;<br>
}<br>
} else if (index 
String [] newTelephone = new String[this.mTelephone.length + 1]; java.lang.System.arraycopy((Object)mTelephone, 0, (Object)newTelephone, 0, this.mTelephone.length);<br>
newTelephone[newTelephone.length - 1] = inp; mTelephone = newTelephone; } else if (index &gt;= this.mTelephone.length) {<br>
String [] newTelephone = new String[index + 1]; java.lang.System.arraycopy((Object)mTelephorie, 0, (Object)newTelephone, 0, this.mTelephone.length);<br>
newTelephone[index] = inp; mTelephone = newTelephone; } else {<br>
this.mTelephone[index] = inp;<br>
}<br>
}<br>
public void setTelephone(String [] inp){<br>
this.mTelephone = inp;<br>
}<br>
public void telephoneFromXML(String n){<br>
setTelephone(-l,n);<br>
}<br>
public String [] getFax(){ return mFax;<br>
}<br>
public String getFax(int index) {<br>
if (this.mFax = null)<br><br>
return null; if (index &gt;= this.mFax.length)<br>
return null; if (index  this.mFax.length)<br>
return null; if (index &gt;= 0) return this.mFax[index]; return this.mFax[this.mFax.length + index];<br>
}<br>
public String [] getFaxToXML(){<br>
String [] valArr « getFax();<br>
if (valArr = null) return null;<br>
String [] nvArr = new String[valArr.length];<br>
for (int z = 0; z 
char [] c = valArr[z].toCharArray();<br>
StringBuffer st = new StringBufferO;<br>
StringBuffer sb « new StringBufferO;<br>
for (int x = 0; x 
switch(c[x]){ case •&gt;': sb.append("&gt;"); break; case '
 <br>
sb.append(c[x]);<br>
}<br>
}<br>
nvArr[z] = sb.toString();<br>
}<br>
return nvArr;<br>
}<br>
public void setFax(int index, String inp){<br>
if (this.mFax — null) {<br>
if(index
this.mFax = new String[l];<br>
this.mFax[0] = inp; } else {<br>
this.mFax * new String[index + 1];<br>
this.mFax[index] = inp;<br>
} } else if (index 
String [] newFax = new String[this.mFax. length + 1];<br>
java.lang.System.arraycopy((Object)mFax, 0, (Object)newFax, 0, this.mFax.length);<br>
newFaxfnewFax.length-1] = inp;<br>
mFax - newFax; } else if (index &gt;= this.mFax.length){<br>
String [] newFax = new String[index +1];<br>
java.lang.System.arraycopy((Object)mFax, 0, (Object)newFax, 0, this.mFax.length);<br>
newFax[index] = inp;<br>
mFax = newFax; } else {<br>
this.mFax[index] = inp;<br>
}<br>
public void setFax(String [] inp){ this.mFax = inp;<br>
}<br><br>
public void faxFromXML(String n){ setFax(-l,n);<br>
}<br>
public String [] getEmail(){<br>
return mEmail;<br>
}<br>
public String getEmail(int index) {<br>
if (this.mEmail = null)<br>
return null; if (index &gt;= this.mEmail.length)<br>
return null; if (index  this.mEmail.length)<br>
return null; if (index &gt;= 0) return this.mEmail[index]; return this.mEmail[this.mEmaillength + index];<br>
}<br>
public String [] getEmailToXML(){<br>
String [] valArr = getEmailQ;<br>
if (valArr = null) return null;<br>
String f] nvArr = new String[valArr.length];<br>
for (int z = 0; z 
char [] c = valArrtz].toCharArray();<br>
StringBuffer st = new StringBuffer();<br>
StringBuffer sb = new StringBuffer();<br>
for (int x = 0; x 
switch(c[x]){<br>
case *&gt;':<br>
sb.append("&gt;"); break;<br>
case '
sb.append("
break; case '&amp;*:<br>
sb.append("&amp;");<br>
break;<br><br>
case ••":<br>
sb.append(H"");<br>
break; case "':<br>
sb.append(""M);<br>
break; default:<br>
if (Character.isDefined(c[x])) sb.append(c[x]);<br>
}<br>
}<br>
nvArr[z] - sb.toStringO;<br>
}<br>
return nvArr;<br>
}<br>
public void setEmail(int index, String inp){<br>
if (this.mEmail = null) {<br>
if (index 
this.mEmail = new String[l];<br>
this.mEmail[0] - inp; } else {<br>
this.mEmail = new String[index + 1];<br>
this.mEmail[index] = inp;<br>
} } else if (index 
String [] newEmail = new String[this.mEmail.length +1];<br>
java.lang.System.anaycopy((Object)mEmailJ 0, (Object)newEmail» 0, this.mEmail.length);<br>
newEmail[newEmail.length -1] - inp;<br>
mEmail = newEmail; } else if (index &gt;= this.mEmail.length) {<br>
String [] newEmail = new String[index + 1];<br>
java.lang.System.arraycopy((Object)mEmail, 0, (Object)newEmail, 0, this.mEmail.length);<br>
newEmail[index] = inp;<br><br>
mEmail = newEmail; } else {<br>
this.mEmail[index] = inp;<br>
}<br>
}<br>
public void setEmail(String [] inp){<br>
this.mEmail = inp;<br>
}<br>
public void emailFromXML(String n){<br>
setEmail(-l,n);<br>
}<br>
public String [] getlnternet(){<br>
return mlnternet;<br>
}<br>
public String getlnternet(int index) {<br>
if (this.mlnternet — null)<br>
return null; if (index &gt;= this.mlnternetlength)<br>
return null; if (index  this.mlnternetlength)<br>
return null; if (index &gt;= 0) return this.mlnternet[index]; return this.mlntemet[this.mlntemet.length + index];<br>
}<br>
public String [] getInternetToXML(){<br>
String [] valArr = getlnternetO;<br>
if (valArr — null) return null;<br>
String [] nvArr = new String[valArr.length];<br>
for (int z - 0; z 
char [] c = valArr[z].toCharArray(); StringBuffer st - new StringBuffer(); StringBuffer sb * new StringBuffer(); for (int x = 0; x 
switch(c[x]){<br>
case •&gt;':<br><br>
sb.append("&gt;");<br>
break; case l<:></:>
sb.append("<h></h>
break; case '&amp;':<br>
sb.append("&amp;");<br>
break; case'"':<br>
sb.append(""");<br>
break; case "':<br>
sb.append(""");<br>
break; default:<br>
if (Character.isDefined(c[x])) sb.append(c[x]);<br>
}<br>
}<br>
nvArr[z] = sb.toString();<br>
}<br>
return nvArr;<br>
}<br>
public void setlnternet(int index, String inp){<br>
if(this.mlnternet —null) {<br>
if(index
this.mlnternet = new String[l];<br>
this.mlnternet[0] == inp; } else {<br>
this.mlnternet = new String[index + 1];<br>
this.mlnternet[index] = inp;<br>
} } else if (index 
String [] newlnternet = new String[this.mlnternet.length + 1];<br><br>
java.lang.System.airaycopy((Object)mInternet,0, (Object)newInternet, 0, this.mlnternet.length);<br>
newlntemet[newlnternet.length - 1] = inp;<br>
mlnternet = newlntemet; } else if (index &gt;- this.mlnternet.length){<br>
String [] newlntemet = new String[index + 1];<br>
java.lang.System.arraycopy((Object)mInternet, 0, (Object)newInternet, 0, this.mlnternet.length);<br>
newlnternetpndex] = inp;<br>
mlnternet = newlntemet; } else {<br>
this.mlnternet[index] = inp; }<br>
}<br>
public void setIntemet(String [] inp){<br>
this.mlntemet = inp;<br>
}<br>
public void intemetFromXML(String n){<br>
setlnternet(-l,n);<br>
}<br>
}<br>
package com.veo.xdk.dev.schema.test.blib;<br>
import com.veo.vsp.doclet.meta.Document; public class Business extends Party {<br>
public static final String DOC_TYPE = "business";<br>
String aBusinessNumber;<br>
public BusinessO{<br>
super(DOCJTYPE);<br>
aBusinessNumber = new String();<br>
}<br>
public Business(String doc_type){<br>
super(doc_type);<br>
aBusinessNumber = new StringQ;<br><br>
}<br>
static public Business initBusiness(String iBusinessNumber,String [] iPartyName,AddressSet iAddressSet){<br>
Business obj = new BusinessO;<br>
obj.initializeAll(iBusinessNumber, iPartyName, iAddressSet); return obj;<br>
}<br>
public void initializeAll(String iBusinessNumber,String [] iPartyName,AddressSet iAddressSet) {<br>
aBusinessNumber = iBusinessNumber; super.initializeAH(iPartyName, iAddressSet);<br>
}<br>
public String getBusinessNumber(){ return aBusinessNumber;<br>
}<br>
public String getBusinessNumberToXML(){<br>
if (getBusinessNumber() == null) return null; char [] c = getBusinessNumber().toCharArray(); StringBuffer sb = new StringBuffer(); for (int x = 0; x ': sb.append("&gt;M); break; case ,<l: sb.append break case></l:>
sb.append("&amp;"); break; case "": sb.append("""); break; case V:<br><br>
sb.append("""); break; default: if (Character.isDefined(c[x])) sb.append(c[x]);<br>
} } return sb.toStringO;<br>
}<br>
public void setBusinessNumber(String inp){ this.aBusinessNumber = inp;<br>
}<br>
public void businessNumberFromXML(String n){ setBusinessNumber(n);<br>
}<br>
import com.veo.vsp.doclet.meta.Document; public class Party extends Document {<br>
public static final String DOCJTYPE = "party"; String [] mPartyName; AddressSet mAddressSet; public Party(){<br>
super(DOC_TYPE); mPartyName = new String[0];<br>
this.mAddressSet = new AddressSet();<br>
}<br>
public Party(String doc_type){<br>
super(doc_type);<br>
mPartyName = new String[0];<br>
this.mAddressSet = new AddressSetO;<br>
}<br>
static public Party initParty(String [] iPartyName,AddressSet iAddressSet){ Party obj = new Party();<br><br>
obj,initializeAll(iPartyName, iAddressSet); return obj;<br>
}<br>
public void initializeAU(String [] iPartyName,AddressSet iAddressSet) { mPartyName = iPartyName; mAddressSet *= iAddressSet;<br>
}<br>
public String [] getPartyName(){.<br>
return mPartyName;<br>
}<br>
public String getPartyName(int index) {<br>
if (this.mPartyName = null)<br>
return null; if (index &gt;= this.mPartyName.length)<br>
return null; if (index  this.mPartyName.length)<br>
return null; if (index &gt;- 0) return this.mPartyName[index]; return this.mPartyName[this.mPartyName.length + index];<br>
}<br>
public String [] getPartyNameToXML(){<br>
String [] valArr = getPartyName();<br>
if (valArr ~ null) return null;<br>
String [] nvArr = new String[valArr.length];<br>
for (int z = 0; z 
char [] c = vaLArr[z].toCharArrayO;<br>
StringBuffer st = new StringBuffer();<br>
StringBuffer sb = new StringBufferQ;<br>
for (int x = 0; x 
switch(c[x]){<br>
case '&gt;*:<br>
sb.append("&gt;H); break;<br>
case '<?: <br/><br>
sb.append(n<n></n>
break; case '&amp;':<br>
sb.appendC'&amp;");<br>
break; case ,w:<br>
sb.append(""M);<br>
break; case,n:<br>
sb.append(""");<br>
break; default:<br>
if (Character.isDefined(c[x])) sb.append(c[x]);<br>
}<br>
}<br>
nvArr[z] = sb.toStringO;	!<br>
}<br>
return nvArr;<br>
}<br>
public void setPartyName(int index, String inp){<br>
if (this.mPartyName — null) {<br>
if (index 
this.mPartyName = new String[l];<br>
this.mPartyName[0] = inp; } else {<br>
this.mPartyName = new String[index + 1];<br>
this.mPartyName[index] = inp;<br>
} } else if (index 
String [] newPartyName = new String[this.mPartyName.length + 1];<br>
java.lang.System.arraycopy((Object)mPartyName, 0,<br>
(Object)newPartyName, 0, this.mPartyName. length);<br>
newPartyName[newPartyName.length -1] = inp;<br>
mPartyName = newPartyName;<br><br>
} else if (index &gt;= this.mPartyName.length){<br>
String [] newPartyName = new Stringfindex + 1];<br>
java.lang.System.arraycopy((Object)mPartyName, 0, (Object)newPartyName, 0, this.mPartyName.length);<br>
newPartyName[index] = inp;<br>
mPartyName = newPartyName; } else {<br>
this.mPartyName[index] = inp;<br>
}<br>
}<br>
public void setPartyName(String [] inp){<br>
this.mPartyName - inp;<br>
}<br>
public void partyNameFromXML(String n){<br>
setPartyName(-l, n);<br>
}<br>
public AddressSet getAddressSet() {<br>
return mAddressSet;<br>
}<br>
public void setAddressSet(AddressSet inp){<br>
this.mAddressSet = inp;<br>
} }<br>
package com.veo.xdk.dev.schema.test.blib;<br>
import com.veo.vsp.doclet.meta.Document; public class Person extends Party {<br>
public static final String DOCJTYPE = "person";<br>
String aSSN;<br>
public Person(){<br>
super(DOC_TYPE);<br>
aSSN = null;<br>
}<br>
public Person(String doc_type){<br><br>
super(doc_type); aSSN = null;<br>
}<br>
static public Person initPerson(String iSSN,String [] iPartyName,AddressSet<br>
iAddressSet){<br>
Person obj = new PersonO;<br>
obj.initializeAll(iSSN, iPartyName, iAddressSet);<br>
return obj;<br>
}<br>
public void initializeAH(String iSSN,String [] iPartyName,AddressSet iAddressSet) { aSSN = iSSN; super.initializeAll(iPartyName, iAddressSet);<br>
}<br>
public String getSSN(){<br>
return aSSN;<br>
}	f<br>
public String getSSNToXML(){<br>
if (getSSNO = null) return null;<br>
char [] c = getSSN().toCharArray();<br>
StringBuffer sb = new StringBufferO;<br>
for (int x = 0; x 
switch(c[x]){<br>
case •&gt;':<br>
sb.appendC'&gt;");<br>
break; case *
sb.append(M<n></n>
break; case '&amp;1:<br>
sb.append("&amp;");<br>
break; case "":<br>
sb.append(""");<br>
break;<br><br>
case V:<br>
sb.append(""");<br>
break; default:<br>
if (Character.isDefined(c[x])) sb.append(c[x]);<br>
}<br>
}<br>
return sb.toString();<br>
}<br>
public void setSSN(String inp){ this.aSSN = inp;<br>
}<br>
public void sSNFromXML(String n){<br>
setSSN(n);<br>
} }<br>
package com.veo.xdk.dev.schema.test.blib;<br>
import com.veo.vsp.doclet.meta.Document; public class PrototypeService extends Document {<br>
public static final String DOCJTYPE = "prototype.service"; String mServiceName; String [] mServiceTerms; String [] mServiceLocation; ServiceOperation [] mServiceOperation; public PrototypeService(){<br>
super(DOC_TYPE); mServiceName = new StringQ; mServiceTerms = new String[0]; mServiceLocation = new StringfO];<br>
this.mServiceOperation - new ServiceOperation[0];<br>
}<br>
public PrototypeService(String doc_type){<br><br>
super(docJype); mServiceName - new StringO; mServiceTerms = new String[0]; mServiceLocation = new String[0];<br>
this.mServiceOperation = new ServiceOperation[0];<br>
}<br>
static public PrototypeService initPrototypeService(String iServiceName,String []<br>
iServiceTerms,String [] iServiceLocation,ServiceOperation [] iServiceOperation){<br>
PrototypeService obj =new PrototypeService();<br>
obj.initializeAH(iServiceName, iServiceTerms, iServiceLocation, iServiceOperation);<br>
return obj;<br>
}<br>
public void initia!izeAll(String iServiceName,String Q iServiceTerms,String [] iServiceLocation,ServiceOperation [] iServiceOperation){<br>
mServiceName - iServiceName; mServiceTerms = iServiceTerms; mServiceLocation = iServiceLocation; mServiceOperation = iServiceOperation;<br>
}<br>
public String getServiceName(){<br>
return mServiceName;<br>
}<br>
public String getServiceNameToXML(){<br>
if (getServiceNameO — null) return null; char [] c = getServiceName().toCharArrayO; StringBuffer sb = new StringBufferO; for (bit x = 0; x ':<br>
sb.append("&gt;"); break; case *
 <br>
break; case *&amp;':<br>
sb.append(M&amp;");<br>
break; case "":<br>
sb.append(""M);<br>
break; case V:<br>
sb.append(""");.<br>
break; default:<br>
if (Character.isDefined(c[x])) sb.append(c[x]);<br>
}<br>
}<br>
return sb.toString();<br>
}<br>
public void setServiceName(String inp){<br>
this.mServiceName = inp;<br>
}<br>
public void serviceNameFromXML(String n){<br>
setServiceName(n);<br>
}<br>
public String [] getServiceTerms(){<br>
return mServiceTerms;<br>
}<br>
public String getServiceTerms(int index) { if (this.mServiceTerms — null)<br>
return null; if (index &gt;= this.mServiceTerms.length)<br>
return null; if (index  this.mServiceTerms.length)<br>
return null; if (index &gt;= 0) return this.mServiceTerms[index]; return this.mServiceTerms[this.mServiceTerms.length + index];<br><br>
}<br>
public String [] getServiceTermsToXML(){ String [] valArr = getServiceTermsO; if (valArr = null) return null; String [] nvArr = new String[valArr.length]; for (int z - 0; z ': sb.appendC'&gt;"); break; case '
}<br>
}<br>
nvArrfz] == sb.toString();<br>
}<br>
return nvArr;<br>
}<br><br>
public void setServiceTerms(int index, String inp){ if (this.mServiceTerms = null) { if (index 
this.mServiceTerms = new String[l]; this.mServiceTerms[0] = inp; } else {<br>
this.mServiceTerms - new String[index + 1]; this.mServiceTerms[index] = inp;<br>
} } else if (index 
String [] newServiceTerms = new Strmg[this.mServiceTerms.length<br>
java.lang.System.arraycopy((Object)mServiceTerms»0, (Object)newServiceTerms, 0, this.mServiceTerms.length);<br>
newServiceTerms[newServiceTerms.length -1] = inp;<br>
mServiceTerms * newServiceTerms; } else if (index &gt;= this.mServiceTerms.length) {<br>
String [] newServiceTerms = new String[index + 1];<br>
java.lang.System.arraycopy((Object)mServiceTerms, 0, (Object)newServiceTerms, 0, this.mServiceTerms.length);<br>
newServiceTerms[index] = inp;<br>
mServiceTerms = newServiceTerms; } else {<br>
this.mServiceTerms[index] - inp;<br>
}<br>
}<br>
public void setServiceTerms(String [] inp){<br>
this.mServiceTerms * inp;<br>
}<br>
public void serviceTermsFromXML(String n){ setServiceTerms(-l, n);<br>
}<br>
public String [] getServiceLocation(){ return mServiceLocation;<br><br>
public String getServiceLocation(int index) { if (this.mServiceLocation — null)<br>
return null; if (index &gt;- this.mServiceLocation.length)<br>
return null; if (index  this.mServiceLocation.length)<br>
return null; if (index &gt;= 0) return this.mServiceLocation[index]; return this.mServiceLocation[this.mServiceLocation.length + index];<br>
}<br>
public String [] getServiceLocationToXML(){<br>
String [] valArr = getServiceLocationO;<br>
if (valArr — null) return null;<br>
String [] nvArr = new String!valArr.length];<br>
for (int z = 0; z 
char [] c - valArr[z].toCharArrayO; StringBuffer st - new StringBuffer(); StringBuffer sb = new StringBuffer(); for (int x = 0; x 
switch(c[x]){<br>
case &gt;':<br>
sb.append("&gt;"); break; case '<:></:>
sb.append("<m break case></m>
sb.append("&amp;");<br>
break; case,Mt:<br>
sb.append(""");<br>
break; case'":<br>
sb.append(""H);<br>
break;<br><br>
default: if (Character.isDefined(c[x])) sb.append(c[x]);<br>
}<br>
}<br>
nvArrjz] = sb.toStringO;<br>
}<br>
return nvArr;<br>
}<br>
public void setServiceLocation(int index, String inp){<br>
if (this.mServiceLocation = null) {<br>
if (index 
this.mServiceLocation = new String[l];<br>
this.mServiceLocation[0]«inp; } else {<br>
this.mServiceLocation - new String[index +1];<br>
this.mServiceLocation[index] = inp;<br>
} } else if (index 
String [] newServiceLocation = new Stringfthis.mServiceLocation.length + 1];<br>
java.lang.System.arraycopy((Object)mServiceLocation, 0, (Object)newServiceLocation, 0, this.mServiceLocation.length);<br>
newServiceLocation[newServiceLocation.length- 1] = inp;<br>
mServiceLocation = newServiceLocation; } else if (index &gt;=this.mServiceLocation.length){<br>
String [] newServiceLocation = new String[index + 1];<br>
java.lang.System.arraycopy((Object)mServiceLocation,0, (Object)newServiceLocation, 0, this.mServiceLocation.length);<br>
newServiceLocation[index] = inp;<br>
mServiceLocation = newServiceLocation; } else {<br>
this.mServiceLocation[index] - inp;<br>
} }<br><br>
public void setServiceLocation(String [] inp){ this.mServiceLocation = inp;<br>
}<br>
public void serviceLocationFromXML(String n){<br>
setServiceLocation(-l, n);<br>
}<br>
public ServiceOperation [] getServiceOperation(){<br>
return mServiceOperation;<br>
}<br>
public ServiceOperation getServiceOperation(int index) {<br>
if (this.mServiceOperation == null)<br>
return null; if (index &gt;= this.mServiceOperation.length)<br>
return null; if (index  this.mServiceOperation.Iength)<br>
return null; if (index &gt;= 0) return this.mServiceOperation[index];    ■ return this.mServiceOperation[this.mServiceOperation.length + index];<br>
}<br>
public void setServiceOperation(int index, ServiceOperation inp){<br>
if (this.mServiceOperation «= null) {<br>
if(index
this.mServiceOperation = new ServiceOperation[l];<br>
this.mServiceOperation[0] - inp; } else {<br>
this.mServiceOperation = new ServiceOperation[index + I];<br>
this.mServiceOperation[index] = inp;<br>
} } else if (index 
ServiceOperation [] newServiceOperation = new ierviceOperation[this.mServiceOperation.length +1];<br>
java.lang.System.arraycopy((Object)mServiceOperation, 0, Object)newServiceOperation, 0, this.mServiceOperation.length);<br>
newServiceOperation[newServiceOperation.length - 1] = inp;<br>
mServiceOperation = newServiceOperation;<br><br>
} else if (index &gt;= this.mServiceOperation.length){<br>
ServiceOperation [] newServiceOperation - new ServiceOperation[index +1];<br>
java.lang.System.arraycopy((Object)mServiceOperation, 0, (Object)newServiceOperation, 0, this.mServiceOperation.length);<br>
newServiceOperation[index] = inp; mServiceOperation = newServiceOperation; } else {<br>
this.mServiceOperation[index] = inp;<br>
}<br>
}<br>
public void setServiceOperation(ServiceOperation [] inp){<br>
this.mServiceOperation = inp;<br>
} }<br>
package com.veo.xdk.dev.schema.test.blib;<br>
import com.veo.vsp.doclet.meta.Document; public class Service extends Document {<br>
public static final String DOCJTYPE = "service"; String mServiceName; String mServiceLocation; ServiceOperation [] mServiceOperation; String mServiceTerms; public Service(){<br>
super(DOC_TYPE); mServiceName = new String(); mServiceLocation - new StringO;<br>
this.mServiceOperation = new ServiceOperation[0]; mServiceTerms = new StringO;<br>
}<br>
public Service(String doc__type){<br>
super(doc_type); mServiceName = new StringO;<br><br>
mServiceLocation = new StringQ;<br>
this.mServiceOperation = new ServiceOperation[0]; mServiceTerms - new String();<br>
static public Service initService(String iServiceName,String iServiceLocation,ServiceOperation [] iServiceOperation.String iServiceTerms) {<br>
Service obj - new ServiceQ;<br>
obj.initializeAH(iServiceName, iServiceLocation, iServiceOperation, iServiceTerms);<br>
return obj;<br>
}<br>
public void initializeAll(String iServiceName,String iServiceLocation,ServiceOperation [] iServiceOperation,String iServiceTerms) {<br>
mServiceName = iServiceName; mServiceLocation = iServiceLocation; mServiceOperation = iServiceOperation; mServiceTerms = iServiceTerms;<br>
}<br>
public String getServiceName(){<br>
return mServiceName;<br>
}<br>
public String getServiceNameToXML(){<br>
if (getServiceName() — null) return null; char [] c = getServiceName().toCharArrayO; StringBuffer sb = new StringBufferO; for (int x = 0; x *: sb.appendO'&gt;"); break; case '<: sb.append break case></:><br>
sb.append(H&amp;");<br>
break; case,,H:<br>
sb.append(""");<br>
break; case V:<br>
sb.append(""M);<br>
break; default:<br>
if (Character.isDefined(c[x])) sb.append(c[x]);<br>
}<br>
}<br>
return sb.toStringO;<br>
public void setServiceName(String inp){<br>
this.mServiceName = inp;	:?<br>
}<br>
public void serviceNameFromXML(String n){<br>
setServiceName(n);<br>
}<br>
public String getServiceLocationO{ return mServiceLocation;<br>
}<br>
public String getServiceLocationToXML(){<br>
if (getServiceLocationO == null) return null; char [] c = getServiceLocationO-toCharArrayO; StringBuffer sb = new StringBuffer(); for (int x = 0; x ': sb.append(H&gt;"); break; case '<?: sb.append(M<H);<br/><br>
break; case '&amp;':<br>
sb.append("&amp;");<br>
break; case,m:<br>
sb.append(""");<br>
break; case V:<br>
sb.append(""");.<br>
break; default:<br>
if (Character.isDefmed(c[x])) sb.append(c[x]);<br>
}<br>
}<br>
return sb.toString();<br>
}<br>
public void setServiceLocation(String inp){<br>
this.mServiceLocation = inp;<br>
}<br>
public void serviceLocationFromXML(String n){ setServiceLocation(n);<br>
}<br>
public ServiceOperation [] getServiceOperation(){ return mServiceOperation;<br>
}<br>
public ServiceOperation getServiceOperation(int index) { if (this.mServiceOperation — null) return null; if (index &gt;= this.mServiceOperation.length)<br>
return null; if (index  this.mServiceOperation.length)<br>
return null; if (index &gt;= 0) return this.mServiceOperationfindex]; return this.mServiceOperationtthis.mServiceOperation.length + index];<br><br>
}<br>
public void setServiceOperation(int index, ServiceOperation inp){ if (this.mServiceOperation — null) { if (index 
this.mServiceOperation = new ServiceOperation[l]; this.mServiceOperation[0] = inp; } else {<br>
this.mServiceOperation = new ServiceOperation[index + 1]; this.mServiceOperation[index] = inp;<br>
} } else if (index 
ServiceOperation [] newServiceOperation = new ServiceOperation[this.mServiceOperation,length +1];<br>
java.lang.System.arraycopy((Object)mServiceOperation, 0, (Object)newServiceOperation, 0, this.mServiceOperation.length);<br>
newServiceOperation[newServiceOperation.length - 1] = inp;<br>
mServiceOperation = newServiceOperation; } else if (index &gt;= this.mServiceOperation.length){<br>
ServiceOperation [] newServiceOperation = new ServiceOperationfindex +1];<br>
java.lang.System.arraycopy((Object)mServiceOperation, 0, (Object)newServiceOperation, 0, this.mServiceOperation.length);<br>
newServiceOperation[index] «= inp;<br>
mServiceOperation = newServiceOperation; } else {<br>
this.mServiceOperation[index] = inp;<br>
}<br>
}<br>
public void setServiceOperation(ServiceOperation [] inp){<br>
this.mServiceOperation = inp;<br>
}<br>
public String getServiceTerms(){<br>
return mServiceTerms; public String getServiceTermsToXML(){<br><br>
if (getServiceTerms() = null) return null; char [] c - getServiceTerms().toCharArray(); StringBuffer sb = new StringBuffer(); for (int x = 0; x ': sb.append("&gt;"); break; case •
} } return sb.toStringO;<br>
}<br>
public void setServiceTerms(String inp){<br>
this.mServiceTerms - inp;<br>
}<br>
public void serviceTermsFromXML(Stringn){<br>
setServiceTerms(n); }<br><br>
package com.veo.xdk.dev.schema.test.blib;<br>
import com.veo.vsp.doclet.meta.Document; public class ServiceOperation extends Document {<br>
public static final String DOCJTYPE = "service.operation";<br>
String mServiceOperationName;<br>
String mServiceOperationLocation;<br>
String mServiceOperationlnput;<br>
String mServiceOperationOutput;<br>
public ServiceOperation(){<br>
super(DOCJTYPE); mServiceOperationName = new String(); mServiceOperationLocation - new StringO; mServiceOperationlnput = new StringO; mServiceOperationOutput = new StringO;<br>
}<br>
public ServiceOperation(String doc_type){<br>
super(doc_type);<br>
mServiceOperationName = new StringO;<br>
mServiceOperationLocation = new StringO;<br>
mServiceOperationlnput« new StringO;<br>
mServiceOperationOutput = new StringO;<br>
}<br>
static public ServiceOperation initServiceOperation(String<br>
iServiceOperationName,StringiServiceOperationLocation,StringiServiceOperationInput,String iServiceOperationOutput) {<br>
ServiceOperation obj = new ServiceOperationO;<br>
obj .initializeAH(iServiceOperationName, iServiceOperationLocation, iSewiceOperationlnput, iServiceOperationOutput);<br>
return obj;<br>
}<br>
public void initializeAU(String iServiceOperationName,String iServiceOperationLocation,String iServiceOperationInput,String iServiceOperationOutput) {<br>
mServiceOperationName = iServiceOperationName;<br><br>
mServiceOperationLocation = iServiceOperationLocation; mServiceOperationlnput = iServiceOperationlnput; mServiceOperationOutput = iServiceOperationOutput;<br>
}<br>
public String getServiceOperationName(){<br>
return mServiceOperationName;<br>
public String getServiceOperationNameToXML(){<br>
if (getServiceOperationName() == null) return null; char [] c = getServiceOperationName().toCharArray(); StringBuffer sb = new StringBuffer(); for (int x = 0; x ':<br>
sb.appendf&gt;"); break; case '
sb.appendC'&amp;"); break; case "": sb.append(M""); break; case V: sb.append(M""); break; default: if (Character.isDefined(c[x])) sb.append(c[x]);<br>
}<br>
}<br>
return sb.toStringQ;<br>
}<br><br>
public void setServiceOperationName(String inp){ this.mServiceOperationName * inp;<br>
}<br>
public void serviceOperationNameFromXML(String n){<br>
setServiceOperationName(n);<br>
}<br>
public String getServiceOperationLocation(){<br>
return mServiceOperationLocation;<br>
}<br>
public String getServiceOperationLocationToXML(){<br>
if (getServiceOperationLocation() == null) return null;<br>
char [] c == getServiceOperationLocation().toCharArray();<br>
StringBuffer sb = new StringBuffer();<br>
for (int x = 0; x 
switch(c[x]){<br>
case •&gt;':<br>
sb.append("&gt;M);	:<br>
break; case '
sb.appendC'
sb.append("""); break; case V:<br>
sb.append(M""); break; default: if (Character.isDefined(c[x])) sb.append(c[x]);<br>
} }<br><br>
return sb.toStringO;<br>
}<br>
public void setServiceOperationLocation(String inp){ this.mServiceOperationLocation «inp;<br>
}<br>
public void serviceOperationLocationFromXML(String n){<br>
setServiceOperationLocation(n);<br>
}<br>
public String getServiceOperationInput(){<br>
return mServiceOperationlnput;<br>
}<br>
public String getServiceOperationInputToXML(){<br>
if (getServiceOperationInput() == null) return null;<br>
char [] c = getServiceOperationInput().toCharArray();<br>
StringBuffer sb = new StringBuffer();<br>
for (int x = 0; x 
switch(c[x]){<br>
case '&gt;':<br>
sb.appendC&gt;");<br>
break;<br>
case '
sb.append("
break;<br>
case '&amp;':<br>
sb.append("&amp;");<br>
break;<br>
case,,M:<br>
sb.appendC'"");<br>
break;<br>
case r:<br>
sb.append(""");<br>
break;<br>
default:<br>
if (Character.isDefined(c[x]))<br>
sb.append(c[x]);<br><br>
}<br>
}<br>
return sb.toString();<br>
}<br>
public void setServiceOperationInput(String inp){<br>
this.mServiceOperationInput = inp;<br>
}<br>
public void serviceOperationInputFromXML(String n){<br>
setServiceOperationInput(n);<br>
}<br>
public String getServiceOperationOutput(){ return mServiceOperationOutput;<br>
}<br>
public String getServiceOperationOutputToXML(){<br>
if (getServiceOperationOutput() = null) return null;<br>
char [] c = getServiceOperationOutput().toCharArray();<br>
StringBuffer sb = new StringBuffer();<br>
for (int x = 0; x 
switch(c[x]){<br>
case '&gt;':<br>
sb.append(M&gt;");<br>
break; case *
sb.append("
break; case *&amp;':<br>
sb.append(M&amp;M);<br>
break; case "":<br>
sb.append(""");<br>
break; case V1:<br>
sb.append(""");<br>
break; default:<br><br>
if (Character.isDefined(c[x])) sb.append(c[x]);<br>
}<br>
}<br>
return sb.toStringO;<br>
}<br>
public void setServiceOperationOutput(String inp){<br>
this.mServiceOperationOutput = inp;<br>
}<br>
public void serviceOperationOutputFromXML(String n){<br>
setServiceOperationOutput(n);<br>
} }<br>
package com.veo.xdk.dev.schema.test.blib;<br>
import com.veo.vsp.doclet.meta,Document; public class ServiceSet extends Document {<br>
public static final String DOC_TYPE = "service.set"; Service [] mService;<br>
public ServiceSetO{<br>
super(DOCJTYPE); this.mService = new Service[0];<br>
}<br>
public ServiceSet(String doc_type){<br>
super(docjype);<br>
this.mService = new Service[0];<br>
}<br>
static public ServiceSet initServiceSet(Service [] iService){<br>
ServiceSet obj =* new ServiceSetO; obj .initializeAH(iService); return obj;<br>
public void initializeAll(Service [] iService){<br><br>
mService - iService;<br>
}<br>
public Service [] getService(){ return mService;<br>
}<br>
public Service getService(int index) {<br>
if (this.mService — null)<br>
return null; if (index &gt;= this.mService.length)<br>
return null; if (index  this.mService.length)<br>
return null; if (index &gt;= 0) return this.mService[index]; return this.mService[this.mService.length + index];<br>
}<br>
public void setService(int index, Service inp){<br>
if(this.mService==null) {<br>
if(index
this.mService = new Service[l];<br>
this.mService[0] = inp; } else {<br>
this.mService = new Servicefindex + 1];<br>
this.mService[index] - inp;<br>
} } else if (index 
Service [] newService * new Service[this.mService.length + 1];<br>
java.lang.System.arraycopy((Object)mService, 0, (Object)newService, 0, this.mService.length);<br>
newService[newService.length - 1] = inp;<br>
mService = newService; } else if (index &gt;= this.mService.length)!<br>
Service [] newService = new Service[index + 1];<br>
java.lang.System.arraycopy((Object)mService, 0, (Object)newService, 0, this.mService.length);<br>
newService[index] = inp;<br><br>
mService = newService; } else {<br>
this.mService[index] = inp;<br>
}<br>
.      }<br>
public void setService(Service [] inp){<br>
this.mService = inp;<br>
} }<br>
In addition to the JAVA beans set forth above, transformation code is produced for translating from JAVA to XML and XML to JAVA as set forth below:<br>
Java to XML<br>tree.dtd"&gt; <tree source="null" pass-through="false"><before><br><vardef name="attribute.def '&gt; &lt;element source = " attribute class="NAME" type="5" position="-2"><parse><data class="java.lang.String" position="-2"></data></parse></vardef><br><vardef name="pcdata.def !&gt; &lt;element source « " pcdata class="NAME" type="4" position="-2"><parse><br><data class="999" type="6" position="-2"></data></parse><br><vardef name="content.def *&gt; &lt;element source = " pcdata><br><br><parse><data class="999" type="6" position="-2"></data></parse></vardef><br><vardef name="ServiceSet.var"><br><element source="com.veo.xdk.dev.schema.test.blib.ServiceSet" class type position="-2"><parse><br><callvar name="Service.var"></callvar></parse></element></vardef><br><vardef name="PrototypeService.var"><br><element source class="prototype.service" type="4" position='M-2"'><br><parse>	;:;<br><callvar name parms="setSource ServiceNameToXML setGenerator service.name"></callvar><br><callvar name="pcdata.def1 parms = " setsource servicetermstoxml setgenerator service.terms></callvar><br><callvar name="pcdata.def' parms = " setsource servicelocationtoxml setgenerator service.location><br><callvarname></callvarname></callvar></parse></element></vardef><br><vardef name="Service. var"><br><element source="com.veo.xdk.dev.schema.test.blib.Service" class="service" type="8" position="0"><parse><br><callvar name="pcdata.def * parms = " setsource servicenametoxml setgenerator service.name><br><callvar name="pcdata.def' parms = " setsource servicelocationtoxml setgenerator service.location></callvar><br><br><callvar name="ServiceOperation.varn/&gt;&lt;br/&gt;
&lt;callvar name = " pcdata.def1 parms="setSource ServiceTermsToXML setGenerator service.terms"></callvar><br></callvar></parse></element></vardef><br><vardef name="ServiceOperation.var"><br><element source="com.veo.xdk.dev.schema.test.blib.ServiceOperationM class = " service.operation type="4" position="-2"><parse><br><callvar name="pcdata.def' parms = " setsource serviceoperationnametoxml setgenerator service.operation.name></callvar><br><callvar name="pcdata.def! parms - " setsource serviceoperationlocationtoxml setgenerator service.operation.location></callvar><br><callvar name="pcdata.def' parms - " setsource serviceoperationlnputtoxml setgenerator service.operation.input></callvar><br><callvar name="pcdata.def" parms="setSource ServiceOperationOUtputToXML setGenerator service.operation.output"></callvar></parse></element></vardef></vardef></before><parse><br><callvar name></callvar><callvar name><callvarname></callvarname><callvarname></callvarname></callvar></parse></tree><br>
XML to Java<br><tree source="null" pass-through><before><br><br><vardef name="business. var"><element source></element>
class = "com.veo.xdk.dev.schema.test.blib.Business" type = "7" setter = "setBusiness!,&gt; <before><br><onattribute name="business.number"><actions><br><callmeth name='f,businessNumberFromXML"'><parms><br><getattr name="business.number"></getattr></parms></callmeth></actions></onattribute></before><parse><br><callvar name .name.var parms="setPosition -l"></callvar><callvar name="address.set.var"></callvar></parse></vardef><br><vardef name .name.var><br><element source="party.name" setter="partyNameFromXML" position="-1" class="java.lang.String"><parse><br><data class="java.lang.String" position="0"></data></parse></element></vardef><br><vardef name="city.var"><br><element source="city" setter="cityFromXML" position="-1" class="java.lang.String"><parse><br><data class position="0"></data></parse></element><br><br></vardef><br><vardef name="internet.var"><element source="internet" setter="internetFromXML" position="-1" class="java.lang.String"><parse><br><data class="java.lang.String" position></data></parse></element></vardef><br><vardef name><br><element source="country" setter="countryFromXML" position="-1" class="java.Iang.String"><parse><br><data class="java.lang.String" position="07&gt; &lt;/parse&gt; &lt;/element&gt; &lt;/varde£&gt;&lt;br/&gt;
&lt;vardef name = " state.var><element source="state" setter="stateFromXML" position="-1" class="java.lang.String"><parse><br><data class="java.lang.String" position="0"></data></parse></element></data></parse></element></vardef><br><vardef name="email. var"><br><element source="email" setter="emailFromXML" position="-1" class="java.lang.String"><parse><br><data class="java.lang.String" position="0"></data></parse></element></vardef><br><vardef name="address.physical.var"><element source="address.physical"></element>
class = "com.veo.xdk.dev.schema.test.blib.AddressPhysical"<br><br>
type = "7" setter = "setAddressPhysical"&gt; <before><ybefore><parse><br><callvar name var parms="setPosition -1 "></callvar><callvar name="city, var" parms="setPosition -l"></callvar><callvar name="state, var" parms="setPosition -17&gt; &lt;callvar name = " postcode.var></callvar><callvar name="country.var" parms><parse><br><vardef name="telephone. var"><br><element source="telephone" setter="telephoneFromXML" position="-1" class="java.lang.String"><parse><br><data class="Java. lang. String" position="0"></data></parse></element></vardef><br><vardef name='Mperson.var"'><element source="person"></element>
class = "com.veo.xdk.dev.schema.test.blib.Person" type = "7" setter = "setPerson"&gt; <before><onattribute name><actions><callmeth name="sSNFromXML"><parms><br><getattr name></getattr></parms></callmeth></actions></onattribute><vbefore><br><br><parse><callvar name="party.name.var" parms="setPosition -1 "></callvar><callvar name="address.set.var'7&gt; &lt;/parse&gt; &lt;/element&gt; &lt;/varde£&gt;&lt;br/&gt;
&lt;vardef name = " fax.var><element source="fax" setter="faxFromXML" position="-1" class="java.lang.String"><parse><br><data class="java.lang.String" position="0"></data></parse></element></callvar></parse></vbefore></before></vardef><br><vardef name="street. var,f&gt;&lt;br/&gt;
&lt;element source = " street setter="streetFromXML" position class="java.lang.String"><parse><br><data class="java.lang.String" position m0></data></parse></vardef><br><vardef name="address.setvar"><element source="address.set"></element>
class »"com.veo.xdk.dev.schema.test.blib.AddressSet" type = "7" setter = nsetAddressSetn&gt; <before><ybefore><parse><br><callvar name="address.physical.var"></callvar><callvar name="telephone, var" parms="setPosition -!"></callvar><callvar name="fax.var" parms="setPosition -l"></callvar><callvar name="email.var" parms></callvar><callvarname parms></callvarname></parse><element><br><br></element></ybefore></before></vardef><br><vardef name><br><element source="postcode" setter="postcodeFromXML" position="-1" class="java.Iang.String"><parse><br><data class="java.lang.String" position="0"></data></parse></element></vardef><br><vardef name="market.participemt.var"><element source="marketparticipant"></element>
class = "com.veo.xdk.dev.schema.test.blib.MarketParticipant" type = "7" position = "0"&gt; <before></before><parse><callvarname></callvarname><callvar name></callvar></parse></vardef></parse></callvar></parse></ybefore></before><parse><br><callvar name="business.var"></callvar><callvar name="party .name.var"></callvar><callvar name="city.var'7&gt; &lt;callvar name = " internet.var></callvar><callvar name="country .var"></callvar><callvar name="state.var"></callvar><callvar name="email. var"></callvar><callvar name="address.physical.var"></callvar><callvar name="telephone.var"></callvar><callvar name></callvar><callvar name="fax.var"></callvar><callvar name="street. var"></callvar><br><br><callvar name="address.setvarM/&gt; &lt;callvar name = " postcode.varm></callvar><callvar name="marketparticipant.var"></callvar></parse><br></vardef></before></tree><br>
Makefiles:<br>
#<br>
#	this makefile was generated by bic version 0.0. 05/02/1998<br>
# #<br>
#	get the package name from the package argument passed to SchemaGen<br>
PACKAGEJNAME - com/veo/xdk/dev/schema/test/blib<br>
JAVA_SOURCES    +=	MarketParticipantjava \ Businessjava \ Person.java \ Party .Java \ AddressPhysical.java \ AddressSet.javaMAKEFILE__MASTER_DIR = xxx<br>
include $(MAKEFILE_MASTER_DIR)/Makefile.master<br>
all:: $(JAVA_CLASSES)<br>
#<br>
#	this makefile was generated by bic version 0.0.05/02/1998<br>
#<br><br>
# # #<br>
# get the package name from the package argument passed to SchemaGen PACKAGE_NAME « com/veo/xdk/dev/schema/test/blib<br>
JAVA_SOURCES    +-	ServiceSet.java \ PrototypeServicejava \ Service.java \ ServiceOperation.java MAKEFILE_MASTER_DIR = xxx<br>
include $(MAKEFILE_MASTER_DIR)/Makefile.master<br>
all:: $(JAVA_CLASSES)<br>
Finally, the XML document instances generated at run time according to the model above for one example follows:<br><market.participant><br><business business.number="1234567890"><br><party.name>IBM</party.name><br><address.set><address.physical><br><street>l IBM Way</street><city>Palo Alto</city><state>CA</state><br><br><postcode>94304</postcode><br><country>USA</country><br></address.physical><br><telephone>123 456-7890</telephone><fax>123 456 0987</fax><emaii>ibmec@ibmxom<br></emaii></address.set><br></business><br></market.participant><br><br><service.set><br><service><br><service.name>Order Service</service.name><br><service.location>www.ibm.com/order<br><service.operation><br><service.operation.name>SubmitOrder</service.operation.name><br><service.operation.location>www.ibm.com/order/submit</service.operation.location></service.operation></service.location><br><br><service.operation.output>urn:x-<br>
ibm:services;order:operations:poack.dtd</service.operation.output><br><br><service .operation><br><service.operation.name>TrackOrder</service.operation.name><br><service.operationiocation>www.ibm.com/order/track<br><service.operation.input>um:x«<br>
ibm:sei^ices:order:operations:trackarequest.dtd</service.operation.input><br><service.operation.output>urn:x-<br>
ibm:services:order:operations:track.iresponse.dtd<yservice.operation.output><br><br></yservice.operation.output></service.operation.output></service.operationiocation></service></service></service.set><br>
Using the tools along with a BID composer application, which provides a drag, drop and forms editing user interface, a developer is able to create a business interface definition and to produce a well formed, valid business interface definition in the form of an XML document. Thus, the example run time instance is a business interface definition for an ordering service for IBM to be used by Ingram Micro and others to order laptop computers from IBM. (There is no relationship between the applicant and IBM or Ingram Micro). Utilizing these processes, a user is able to build a system that allows for programming of a business interface using the documents defined according to the present invention.<br>
The role of CBL and the BID processor of the present invention in an XML/JAVA environment can be further understood by the following explanation of the processing of a Purchase Order.<br>
Company A defines its Purchase Order document type using a visual programming environment that contains a library of CBL DTDs and modules, all defined using common business language elements so that they contain data type and other interpretation information. Company As PO might just involve minor customizations to a more generic "transaction document" specification that comes with the CBL library, or it might be built from the ground up from CBL modules for address, date and time, currency, etc.<br>
The documentation for the generic "transaction document" specification (such as the transactdtd set out above) typifies the manner in which CBL specifications are built from modules and are interlinked with other CBL DTDs.<br>
A compiler takes the purchase order definition and generates several different target forms. All of these target forms can be derived through "tree to<br><br>
tree" transformations of the original specification. The most important for this example are:<br>
(a)	the XML DTD for the purchase order.<br>
(b)	a JAVA Bean that encapsulates the data structures for a purchase order (the JAVA classes, arguments, datatypes, methods, and exception structures are created that correspond to information in the Schema definition of the purchase order).<br>
(c)	A "marshaling" program that converts purchase orders that conform to the Purchase Order DTD into a Purchase Order JAVA Bean or loads them into a database, or creates HTML (or an XSL style sheet) for displaying purchase orders in a browser.<br>
(d)	An "unmarshaling" program that extracts the data values from Purchase Order JAVA Beans and converts them into an XML document that conforms to the Purchase Order DTD.<br>
Now, back to the scenario. A purchasing application generates a Purchase Order that conforms to the DTD specified as the service interface for a supplier who accepts purchase orders.<br>
The parser uses the purchase order DTD to decompose the purchase order instance into a stream of information about the elements and attribute values it contains. These "property sets" are then transformed into corresponding JAVA event objects by wrapping them with JAVA code. This transformation in effect treats the pieces of marked-up XML document as instructions in a custom programming language whose grammar is defined by the DTD. These JAVA events can now be processed by the marshaling applications generated by the compiler to "load" JAVA Bean data structures.<br><br>
Turning the XML document into a set of events for JAVA applications to process, is unlike the normal model of parsing in which the parser output is maintained as an internal data structure and processing does not begin until parsing completes. The event based processing, in response to the BID definitions, is the key to enabling the much richer functionality of the processor because it allows concurrent document application processing to begin as soon as the first event is emitted.<br>
JAVA programs that "listen for" events of various types are generated from the Schema definition of those events. These listeners are programs created to carry out the business logic associated with the XML definitions in the CBL; for example, associated with an "address" element may be code that validates the postal code by checking a database. These listeners "subscribe" to events by registering with the document router, which directs the relevant events to all the subscribers who are interested in them.<br>
This publish and subscribe architecture means that new listener programs can be added without knowledge by or impact on existing ones. Each listener has a queue into which the router directs its events, which enables multiple listeners can handle events in parallel at their own pace.<br>
For the example purchase order here, there might be listeners for:<br>
•	the purchase order, which would connect it to an order entry program,<br>
•	product descriptions, which might check inventory,<br>
•	address information, which could check Fed Ex or other service for delivery availability,<br>
•	buyer information, which could check order history (for creditworthiness, or to offer a promotion, or similar processing based on knowing who the customer is).<br><br>
Complex listeners can be created as configurations of primitive ones (e.g., a purchase order listener may contain and invoke these listeners here, or they may be invoked on their own).<br>
Fig. 11 illustrates the market maker node in the network of Fig. 1. The market maker node includes the basic structures of the system of Fig. 3, including a network interface 1101, a document parser 1102, a document to host and host to document translator 1103, and a front end 1104, referred to as a router in this example. The market maker module 1105 in this example includes a set of business interface definitions, or other identifiers sufficient to support the market maker function, for participants in the market, a CBL repository, and a compiler all serving the participants in the market. The router 1104 includes a participant registry and document filters which respond to the events generated at the output of the translator and by the parser to route incoming documents according to the participant registry and according to the element and attribute filters amongst the listeners to the XML event generators. Thus, certain participants in the market may register to receive documents that meet prespecified parameters. For example, input documents according to a particular DTD, and including an attribute such as numbers of products to be purchased greater than a threshold, or such as a maximum price of a document request to be purchased, can be used to filter documents at the router 1104. Only such documents as match the information registered in the participant registry at the router 1104 are then passed on to the registered participant.<br>
The router 1104 may also serve local host services 1105 and 1106, and as such act as a participant in the market as well as the market maker. Typically, documents that are received by the router 1104 are traversed to determine the destinations to which such documents should be routed, there again passed back through the translator 1103, if necessary, and out the network interface 1101 to the respective destinations.<br><br>
The market maker is a server that binds together a set of internal and external business services to create a virtual enterprise or trading community. The server parses incoming documents and invokes the appropriate services by, for example, handing off a request for product data to a catalog server or forwarding a purchase order to an ERP system. The server also handles translation tasks, mapping the information from a company's XML documents onto document formats used by trading partners and into data formats required by its legacy systems.<br>
With respect to the service definition above, when a company submits a purchase order, the XML parser in the server uses the purchase order DTD to transform the purchase order instance into a stream of information events. These events are then routed to any application that is programmed to handle events of a given type; in some cases, the information is forwarded over the Internet to a different business entirely. In the purchase order example, several applications may act on information coming from the parser:<br>
•	An order entry program processes the purchase order as a complete message;<br>
•	An ERP system checks inventory for the products described in the purchase order;<br>
•	A customer database verifies or updates the customer's address;<br>
•	A shipping company uses the address information to schedule a delivery<br>
•	A bank uses the credit card information to authorize the transaction.<br>
Trading partners need only agree on the structure, content, and sequencing of the business documents they exchange, not on the details of APIs. How a document is processed and what actions result is strictly up to the business providing the service. This elevates integration from the system level to the business level. It enables a business to present a clean and stable interface<br><br>
to its business partners despite changes in its internal technology implementation, organization, or processes.<br>
Figs. 12,13 and 14 illustrate processes executed at a market maker node in the system of Fig. 11. In Fig. 12, an input document is received at the network interface from an originating participant node (step 1200). The document is parsed (step 1201). The document is translated to the format of the host, for example XML to JAVA (step 1202). The host formatted events and objects are then passed to the router service (step 1203). The services registered to accept the document according to the document type and content of the document are identified (step 1204). The document or a portion of the document is passed to the identified services (step 1205). As service is performed in response to the document content (step 1206). The output data of the service is produced (step 1207). The output is converted to the document format, for example from a JAVA format to an XML format (step 1208). Finally, the output document is sent to a participant node (step 1209).<br>
The registration service is one such function which is managed by the router. Thus, a market participant document is accepted at the network interface as shown in Fig. 13 (step 1300). The market participant document is stored in the business interface definition repository (step 1301) for the market maker node. In addition, the document is parsed (step 1302). The parsed document is translated into the format of the host (step 1303). Next, the document is passed to the router service (step 1304). The router service includes a listener which identifies the registration service as the destination of the document according to the document type and content (step 1305). The document or elements of the document are passed to the registration service (step 1306). In the registration service, the needed service specifications are retrieved according to the business interface definition (step 1307). If the service specifications are gathered, at step 1308, the router service filters are set according to the business interface definition and the service specifications (step 1309). Registration<br><br>
acknowledgment data is produced (1310). The registration acknowledgment data is converted to a document format (step 1311). Finally, the acknowledgment document is sent to the participant node indicating to the participant that is successfully registered with the market maker (step 1312).<br>
The process at step 1307 of gathering needed service specifications is illustrated for one example in Fig. 14. This process begins by locating a service business interface definition supported by the market participant (step 1400). The service definition is retrieved, for example by an E-mail transaction or web access to repository node (step 1401). The service specification is stored in the BID repository (step 1402). The service business interface definition document is parsed (step 1403). The parsed document is translated into the format of the host (step 1404). Host objects are passed to the router service (step 1405). The registration service is identified according to the document type and content (step 1406). Finally, the information in the service business interface definition document is passed to the registration service (step 1407) for use according to the process of Fig. 13.<br>
Fig. 15 illustrates the processor, components and sequence of processing of incoming data at market maker node according to the present invention. The market maker node includes a communication agent 1500 at the network interface. The communication agent is coupled with an XML parser 1501 which supplies events to an XML processor 1502. The XML processor supplies events to a document router. The document router feeds a document service 1504 that provides an interface for supplying the received documents to the enterprise solution software 1505 in the host system. The communication agent 1500 is an Internet interface which includes appropriate protocol stacks supporting such protocols as HTTP, SMTP, FTP, or other protocols. Thus, the incoming data could come in an XML syntax, an ASCII data syntax or other syntax as suits a particular communication channel. All the documents received in non-XML syntaxes are translated into XML and passed the XML parser. A<br><br>
translation table 1506 is used to support the translation from non-XML form into XML form.<br>
The converted documents are supplied to the parser 1501. The XML parser parses the received XML document according to the document type definition which matches it. If an error is found, then the parser sends the document back to the communication agent 1500. A business interface definition compiler BIDC 1507 acts as a compiler for business interface definition data. The DTD file for the XML parser, JAVA beans corresponding to the DTD file, and translation rules for translating DTD files to JAVA beans are created by compiling the BID data. An XML instance is translated to JAVA instance by referring to these tools. Thus the BID compiler 1507 stores the DTD documents 1508 and produces JAVA documents which correspond 1509. The XML documents are passed to the processor 1502 which translates them into the JAVA format. In a preferred system, JAVA documents which have the same status as the document type definitions received in the XML format are produced. The JAVA beans are passed to the document router 1503. The document router 1503 receives the JAVA beans and passes the received class to the appropriate document service using a registry program, for example using the event listener architecture described above. The document service 1504 which receives the document in the form of JAVA beans from the router 1503 acts as the interface to the enterprise solution software. This includes a registry service 1510 by which listeners to XML events are coupled with the incoming data streams, and a service manager 1511 to manage the routing of the incoming documents to the appropriate services. The document service manager 1511 provides for administration of the registry service and for maintaining document consistency and the like.<br>
The document service communicates with the back end system using any proprietary API, or using such more common forms as the CORBA/COM interface or other architectures.<br><br>
Fig. 16 provides a heuristic diagram of the market maker and market participant structures according to the present invention. Thus, the electronic commerce market according to the present invention can be logically organized as set forth in Fig. 16. At the top of the organization, a market maker node 1600 is established. The market maker node includes resources that establish a marketplace 1601. Such resources include a market registry service and the like. Businesses 1602 register in the marketplace 1601 by publishing a business interface definition. The business interface definition defines the services 1603 for commercial transactions in which the businesses will participate. The transactions 1604 and services 1603 use documents 1605 to define the inputs and outputs, and outline the commercial relationship between participants in the transaction. The documents have content 1606 which carries the particulars of each transaction. The mariner in which the content is processed by the participants in the market, and by the market maker is completely independent of the document based electronic commerce network which is established according to the present invention. Overall, a robust, scalable, intuitive structure is presented for enabling electronic commerce on communication networks is provided.<br>
Thus, the present invention in an exemplary system provides a platform based on the XML processor and uses XML documents as the interface between loosely coupled business systems. The documents are transferred between businesses and processed by participant nodes before entering the company business system. Thus the platform enables electronic commerce applications between businesses where each business system operates using different internal commerce platforms, processes and semantics, by specifying a common set of business documents and forms.<br>
According to the present invention, virtual enterprises are created by interconnecting business systems and service, are primarily defined in terms of the documents (XML-encoded) that businesses accept and generate:<br><br>
•	"if you send me a request for a catalog, I will send you a catalog:<br>
•	"if you send me a purchase order and I can accept it, I will send you an invoice".<br>
The foregoing description of a preferred embodiment of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Obviously, many modifications and variations will be apparent to practitioners skilled in this art. It is intended that the scope of the invention be defined by the following claims and their equivalents.<br>
What is claimed is:<br><br><br><br><br>
CLAIMS<br>
1.	An interface for transactions among nodes in a network<br>
including a plurality of nodes which execute processes involved in the<br>
transactions, comprising:<br>
a machine readable specification of an interface to transaction processes stored in memory accessible by at least one node in the network, including interpretation information providing a definition of an input document, and a definition of an output document, the definitions of the input and output documents comprising respective descriptions of sets of storage units and logical structures for the sets of storage units.<br>
2.	The interface of claim 1, wherein the interpretation information includes data type specifications for at least one logical structure in the definitions of the input and output documents.<br>
3.	The interface of claim 1, wherein the interpretation information includes at least one data structure mapping predefined sets of storage units for a particular logical structure in the definitions of the input and output documents, to respective entries in a list.<br>
4.	The interface of claim 1, including a repository in memory accessible by at least one node in the network storing a library of logical structures, and interpretation information for logic structures.<br>
5.	The interface of claim 1, wherein the machine readable specification includes a document compliant with a definition of an interface document including logical structures for storing an identifier of a particular<br><br>
transaction, and at least one of definitions and references to definitions of input and output documents for the particular transaction.<br>
6.	The interface of claim 1, wherein the machine readable specification includes a document compliant with a definition of an interface document including logical structures for storing an identifier of the interface, and for storing at least one of specifications and references to specifications of a set of one or more transactions supported by the interface.<br>
7.	The interface of claim 6, wherein the machine readable specification includes a reference to a specification of a particular transaction, and the specification of the particular transaction includes a document including logical structures for storing at least one of definitions and references to definitions of input and output documents for the particular transaction.<br>
8.	The interface of claim 1, wherein the storage units comprise parsed data.<br>
9.	The interface of claim 8, wherein the parsed data in at least one of the input and output documents comprises:<br>
character data encoding text characters in the one of the input and output documents, and<br>
markup data identifying sets of storage units according to the logical structure of the one of the input and output documents.<br>
10.	The interface of claim 9, wherein at least one of the sets of<br>
storage units encodes a plurality of text characters providing a natural language<br>
word.<br><br>
11.	The interface of claim 8, wherein the interpretation information for at least one of the sets of storage units identified by a particular logical structure of at least one of the input and output documents, encodes respective definitions for sets of parsed characters.<br>
12.	The interface of claim 8, wherein the storage units comprise unparsed data.<br>
13.	The interface of claim 1, including a repository stored in memory accessible by at least one node in the network of document types for use in a plurality of transactions, and wherein the definition of one of the input and output documents includes a reference to a document type in the repository.<br>
14.	The method of claim 13, wherein the repository, of document types includes a document type for identifying participant processes in the network.<br>
15.	The interface of claim 1, wherein the definitions of the input and output documents comprise document type definitions compliant with a standard Extensible Markup Language XML.<br>
16.	The interface of claim 1, wherein the machine readable data structure including interpretation information comprises a document organized according to a document type definition compliant with a standard Extensible Markup Language XML.<br><br>
17.	Apparatus for establishing participant interfaces for transactions<br>
executed on a system including a network interface and a data processing<br>
resources which execute a transaction processes of the transactions according to<br>
a transaction processing architecture; comprising:<br>
programs of instructions executable by the system, stored on a medium accessible by the system, providing tools to build a definition of a participant interface for a participant in a particular transaction, the definition of a participant interface including a definition of an input document for the participant and a definition of an output document for the participant, the definitions of the input and output documents comprising respective machine-readable descriptions of sets of storage units and logical structures for the sets of storage units; and<br>
programs of instructions executable by the system, stored on a medium accessible by the system and responsive to the definitions of the input and output documents, to compile data structures corresponding to the sets of storage units and logical structures of the input and output documents compliant with the transaction processing architecture, to compile instructions executable by the system to translate the input document to the corresponding data structures, and to compile instructions executable by the system to translate output of the transaction processes into the sets of storage units and logical structures of the output document.<br>
18.	The apparatus of claim 17, wherein the tools to build a definition<br>
of a participant interface include instructions executable by the system to access<br>
elements of the definition from a repository, the repository storing a library of<br>
logical structures, and interpretation information for logic structures used to<br>
build interface descriptions.<br><br>
19.	The apparatus of claim 18, wherein the repository stores definitions of documents comprising logic structures.<br>
20.	The apparatus of claim 17, wherein the tools to build a definition of a participant interface include instructions executable by the system<br>
to access a definition of another participant interface for a complementary transaction, the accessed definition including a definition of an input document for the complementary transaction, and a definition of an output document for the complementary transaction; and<br>
to establish the definition of the participant interface by including the definition of the output document of the complementary transaction as the definition of the input document of the interface being built.<br>
21.	The apparatus of claim 20, wherein the tools to build a definition<br>
of a participant interface include instructions executable by the system<br>
to include the definition of the input document of the complementary transaction as the definition of the output document of interface being built.<br>
22.	The apparatus of claim 17, wherein the tools to build a definition of a participant interface include instructions executable by the system to build a document compliant with a definition of a participant interface document including logical structures for storing an identifier of a particular transaction, and at least one of definitions and references to definitions of input and output documents for the particular transaction.<br>
23.	The apparatus of claim 17, wherein the tools to build a definition of a participant interface include instructions executable by the system to build a document compliant with a definition of a participant interface document including logical structures for storing an identifier of the participant interface,<br><br>
and for storing at least one of specifications and references to specifications of a set of one or more transactions supported by the participant interface.<br>
24.	The apparatus of claim 23, wherein the a document compliant with a definition of a participant interface document includes a reference to a machine-readable specification of a particular transaction, and the specification of the particular transaction includes a document including logical structures for storing at least one of definitions and references to definitions of input and output documents for the particular transaction.<br>
25.	The apparatus of claim 17, wherein the storage units comprise parsed data.<br>
26.	The apparatus of claim 25, wherein the parsed data in at least one of the input and output documents comprises:<br>
character data encoding text characters in the one of the input and output documents, and<br>
markup data identifying sets of storage units according to the logical structure of the one of the input and output documents.<br>
27.	The apparatus of claim 26, wherein at least one of the sets of storage units encodes a plurality of text characters providing a natural language word,<br>
28.	The apparatus of claim 25, wherein the specification includes interpretation information for at least one of the sets of storage units identified by the logical structure of at least one of the input and output documents, encoding respective definitions for sets of parsed characters.<br><br>
29.	The apparatus of claim 25, wherein the storage units comprise unparsed data.<br>
30.	The apparatus of claim 17, wherein data structures corresponding to the sets of storage units and logical structures of the input and output documents include programming objects including variables and methods according to the variant transaction processing architecture.<br>
31.	The apparatus of claim 17, wherein the variant transaction processing architectures of the transaction process includes comprises a process compliant with an interface description language.<br>
32.	The apparatus of claim 17, wherein the definitions of the input and output documents comprise document type definitions compliant with a standard Extensible Markup Language XML.<br>
33.	The apparatus of claim 19, wherein the definition of one of the input and output documents includes a reference to a document type in the repository.<br>
34.	The apparatus of claim 18, wherein the repository includes interpretation information specifying measurements of products subject of transactions.<br>
35.	The apparatus of claim 18, wherein the repository includes interpretation information specifying costs of products subject of transactions.<br><br>
36.	The apparatus of claim 18, wherein the repository includes interpretation information specifying features of products subject of transactions.<br>
37.	The apparatus of claim 18, wherein the repository includes interpretation information specifying financial terms of transactions.<br>
38.	The apparatus of claim 18, wherein the repository includes interpretation information specifying terms of shipment for products subject of transactions.<br>
39.	Apparatus for establishing participant interfaces for transactions executed on a system; comprising:<br>
memory storing data and programs of instructions;<br>
a data processor coupled to the memory which executes the programs of instructions; wherein the programs of instructions include<br>
tools to build a definition of a participant interface for a participant in a particular transaction, the definition of a participant interface including a definition of an input document for the participant and a definition of an output document for the participant, the definitions of the input and output documents comprising respective machine-readable descriptions of sets of storage units and logical structures for the sets of storage units; and<br>
a compiler, responsive to the definitions of the input and output<br>
documents, to compile data structures corresponding to the sets of storage units and logical structures of the input and output documents compliant with the transaction processing architecture, to compile instructions executable by the system to translate the input document to the corresponding data structures,<br><br>
and to compile instructions executable by the system to translate output of the transaction processes into the sets of storage units and logical structures of the output document.<br>
40.	The apparatus of claim 39, including a repository stored in memory accessible by the data processor, and wherein the tools to build a definition of a participant interface include instructions executable by the system to access elements of the definition from the repository, the repository storing a library of logical structures, and interpretation information for logic structures used to build interface descriptions.<br>
41.	The apparatus of claim 40, wherein the repository stores definitions of documents comprising logic structures.<br>
42.	The apparatus of claim 39, wherein the tools to build a definition of a participant interface include instructions executable by the system<br>
to access a definition of another participant interface for a complementary transaction, the accessed definition including a definition of an input document for the complementary transaction, and a definition of an output document for the complementary transaction; and<br>
to establish the definition of the participant interface by including the definition of the output document of the complementary transaction as the definition of the input document of the interface being built.<br>
43.	The apparatus of claim 42, wherein the tools to build a definition<br>
of a participant interface include instructions executable by the system<br>
to include the definition of the input document of the complementary transaction as the definition of the output document of interface being built.<br><br>
44.	The apparatus of claim 39, wherein the tools to build a definition of a participant interface include instructions executable by the system to build a document compliant with a definition of a participant interface document including logical structures for storing an identifier of a particular transaction, and at least one of definitions and references to definitions of input and output documents for the particular transaction.<br>
45.	The apparatus of claim 39, wherein the tools to build a definition of a participant interface include instructions executable by the system to build a document compliant with a definition of a participant interface document including logical structures for storing an identifier of the participant interface, and for storing at least one of specifications and references to specifications of a set of one or more transactions supported by the participant interface.<br>
46.	The apparatus of claim 45, wherein the a document compliant with a definition of a participant interface document includes a reference to a machine-readable specification of a particular transaction, and the specification of the particular transaction includes a document including logical structures for storing at least one of definitions and references to definitions of input and output documents for the particular transaction.<br>
47.	The apparatus of claim 39, wherein the storage units comprise parsed data.<br>
48.	The apparatus of claim 47, wherein the parsed data in at least one of the input and output documents comprises:<br>
character data encoding text characters in the one of the input and output documents, and<br><br>
markup data identifying sets of storage units according to the logical structure of the one of the input and output documents.<br>
49.	The apparatus of claim 48, wherein at least one of the sets of storage units encodes a plurality of text characters providing a natural language word.<br>
50.	The apparatus of claim 47, wherein the specification includes interpretation information for at least one of the sets of storage units identified by the logical structure of at least one of the input and output documents, encoding respective definitions for sets of parsed characters.<br>
51.	The apparatus of claim 47, wherein the storage units comprise unparsed data.<br>
52.	The apparatus of claim 39, wherein data structures corresponding to the sets of storage units and logical structures of the input and output documents include programming objects including variables and methods according to the variant transaction processing architecture.<br>
53.	The apparatus of claim 39, wherein the variant transaction processing architectures of the transaction process comprises a process compliant with an interface description language.<br>
54.	The apparatus of claim 39, wherein the definitions of the input and output documents comprise document type definitions compliant with a standard Extensible Markup Language XML.<br><br>
55.	The apparatus of claim 41, wherein the definition of one of the input and output documents includes a reference to a document type in the repository.<br>
56.	The apparatus of claim 40, wherein the repository includes interpretation information specifying measurements of products subject of transactions.<br>
57.	The apparatus of claim 40, wherein the repository includes interpretation information specifying costs of products subject of transactions.<br>
58.	The apparatus of claim 40, wherein the repository includes interpretation information specifying features of products subject of transactions.<br>
59.	The apparatus of claim 40, wherein the repository includes interpretation information specifying financial terms of transactions.<br>
60.	The apparatus of claim 40, wherein the repository includes interpretation information specifying terms of shipment for products subject of transactions.<br>
61.	A method for programming a commercial transaction in a network, comprising:<br>
defining a machine readable definition of an input document for a node in the network including resources to execute a process in the transaction, and a machine readable definition of an output document for the node, the definitions of the input and output documents comprising respective descriptions of sets of storage units and logical structures for the sets of storage units; and<br><br>
providing interpretation information for the logical structures to the node.<br>
62.	The method of claim 61, wherein the interpretation information includes data type specifications for at least one logical structure in the definitions of the input and output documents.<br>
63.	The method of claim 61, wherein the interpretation information includes at least one data structure mapping predefined sets of storage units for a particular logical structure in the definitions of the input and output documents, to respective entries in a list.<br>
64.	The method of claim 61, the step of providing interpretation information includes providing a repository in memory accessible by at least one node in the network storing a library of logical structures, and interpretation information for logic structures.<br>
65.	The method of claim 61, including defining a machine readable specification of an interface including a document compliant with a definition of an interface document including logical structures for storing an identifier of a particular transaction, and at least one of the definitions and references to the definitions of the input and output document.<br>
66.	The method of claim 61, wherein the storage units comprise parsed data.<br>
67.	The method of claim 66, wherein the parsed data in at least one of the input and output documents comprises:<br><br>
character data encoding text characters in the one of the input and output documents, and<br>
markup data identifying sets of storage units according to the logical structure of the one of the input and output documents.<br>
68.	The method of claim 67, wherein at least one of the sets of storage units encodes a plurality of text characters providing a natural language word.<br>
69.	The method of claim 67, wherein the interpretation information for at least one of the sets of storage units identified by a particular logical structure of at least one of the input and output documents, encodes respective definitions for sets of parsed characters.<br>
70.	The method of claim 66, wherein the storage units comprise unparsed data.<br>
71.	The method of claim 61, wherein the definitions of the input and output documents comprise document type definitions compliant with a standard Extensible Markup Language XML.<br>
72.	The method of claim 61, including:<br>
providing a parser to generate event signals in response to logical structures in the definition of the input document; and<br>
providing event listener programs which respond to the event signals to execute the process.<br><br>
73.	A method for executing transactions among nodes in a network<br>
including a plurality of nodes which execute processes involved in the<br>
transactions, comprising:<br>
storing a machine-readable specification of an interface for a transaction, the specification including a definition of an input document, and a definition of an output document, the definitions of the input and output documents comprising respective descriptions of sets of storage units and logical structures for the sets of storage units;<br>
receiving data comprising a document through a communication network;<br>
parsing the document according to the specification to identify an input document;<br>
providing at least a portion of the input document in a machine-readable format to a transaction process which produces an output;<br>
forming, based on the specification, an output document comprising the output according to the definition of an output document; and<br>
transmitting the output document on the communication network.<br>
74.	The method of claim 73, including:<br>
accessing a specification of a complementary interface provided for another node in the network for the transaction, the accessed specification including a definition of an input document for the complementary interface, and a definition of an output document for the complementary interface; and<br>
establishing the stored specification of the interface by including at least part of the definition of the output document of the complementary interface in the definition of the input document of the interface in the stored specification,<br>
75.	The method of claim 74, including:<br>
finding the complementary interface in the network.<br><br>
76.	The method of claim 74, wherein the establishing the stored specification includes accessing elements of the machine-readable specification from a repository, the repository storing a library of logical structures, schematic maps for logic structures, and definitions of documents comprising logic structures used to build interface descriptions.<br>
77.	The method of claim 74, including:<br>
establishing the stored specification of the interface by including at least part of the definition of the input document of the complementary interface in the definition of the output document of the interface in the stored specification.<br>
78.	The method of claim 73, including providing access to the specification through the communication network to other nodes in the network.<br>
79.	The method of claim 73, including sending the specification of the interface to another node in the network, at which access to the specification is provided for other nodes in the network.<br>
80.	The method of claim 73, wherein the machine-readable specification includes a document compliant with a definition of an interface document including logical structures for storing an identifier of a particular transaction, and at least one of definitions and references to definitions of input and output documents for the particular transaction.<br><br>
81.	The method of claim 73, wherein the machine-readable specification includes a document compliant with a definition of an interface document including logical structures for storing an identifier of the interface, and for storing at least one of specifications and references to specifications of a set of one or more transactions supported by the interface.<br>
82.	The method of claim 81, wherein the machine-readable specification includes a reference to a specification of a particular transaction, and the specification of the particular transaction includes a document including logical structures for storing at least one of definitions and references to definitions of input and output documents for the particular transaction.<br>
83.	The method of claim 73, wherein the storage units comprise parsed data.<br>
84.	The method of claim 83, wherein the parsed data in at least one of the input and output documents comprises:<br>
character data encoding text characters in the one of the input and output documents, and<br>
markup data identifying sets of storage units according to the logical structure of the one of the input and output documents.<br>
85.	The method of claim 84, wherein at least one of the sets of<br>
storage units encodes a plurality of text characters providing a natural language<br>
word.<br><br>
86.	The method of claim 83, wherein the specification includes<br>
interpretation information for at least one of the sets of storage units identified<br>
by the logical structure of at least one of the input and output documents,<br>
*	encoding respective definitions for sets of parsed characters.<br>
87.	The method of claim 83, wherein the storage units comprise unparsed data.<br>
88.	The method of claim 73, wherein the transaction process has a variant transaction processing architecture, and including translating at least of portion of the input document into a format readable according to the variant transaction processing architecture of the transaction process.<br>
89.	The method of claim 88, wherein the translating includes producing programming objects including variables and methods according to the variant transaction processing architecture of the transaction process.<br>
90.	The method of claim 88, wherein the variant transaction processing architecture of the transaction process includes a process compliant with an interface description language.<br>
91.	The method of claim 73, wherein the definitions of the input and output documents comprise document type definitions compliant with a standard Extensible Markup Language XML.<br><br>
92.	The method of claim 73, including providing a repository of document types for use in a plurality of transactions, and wherein the definition of one of the input and output documents includes a reference to a document type in the repository.<br>
93.	The method of claim 92, wherein the repository of document types includes a document type for identifying participant processes in the network.<br>
94.	The method of claim 92, including providing a repository of interpretation information for logical structures, including interpretation information identifying parameters of transactions.<br>
95.	The method of claim 73, wherein the transaction process has variant transaction processing architecture, and including;<br>
accessing a specification of a complementary interface, the accessed specification including a definition of an input document for the complementary interface, and a definition of an output document for the complementary interface;<br>
establishing the stored specification of the interface by including the definition of the output document of the complementary interface as the definition of the input document of the interface in the stored specification; and<br>
compiling in response to the definitions of the input and output documents, data structures corresponding to the sets of storage units and logical structures of the input and output documents compliant with the transaction processing architecture of the transaction process, instructions executable by the system to translate the input document to the corresponding data structures, and instructions executable by the system to translate output of the transaction process into a form compliant with the definition of the output document.<br><br>
96.	The method of claim 95, including:<br>
establishing the stored specification of the interface by including the definition of the input document of the complementary interface as the definition of the output document of the interface in the stored specification.<br>
97.	The method of claim 73, wherein the transaction process has a<br>
variant transaction processing architecture, and wherein the establishing the<br>
stored specification includes accessing elements of the machine-readable<br>
specification from a repository, the repository storing a library of logical<br>
structures, schematic maps for logical structures, and definitions of documents<br>
comprising logical structures used to build interface descriptions; and including<br>
compiling in response to the definitions of the input and output documents, data structures corresponding to the sets of storage units and logical structures of the input and output documents compliant with the transaction processing architecture of the transaction process, instructions executable by the system to translate the input document to the corresponding data structures, and instructions executable by the system to translate output of the transaction process into a form compliant with the definition of the output document.<br>
98.	Apparatus for managing transactions among nodes in a network<br>
including a plurality of nodes which execute processes involved in the<br>
transactions, comprising:<br>
a network interface;<br>
memory storing data and programs of instructions, including a machine-readable specification of an interface for a transaction, the specification including a definition of an input document, and a definition of an output document, the definitions of the input and output documents comprising respective descriptions of sets of storage units and logical structures for the sets of storage units;<br><br>
a data processor coupled to the memory and the network interface which executes the programs of instructions; wherein the programs of instructions include<br>
logic to receive data comprising a document through a network interface;<br>
logic to parse the document according to the specification to identify an input document;<br>
logic to provide at least a portion of the input document in a machine-readable format to a transaction process which produces an output;<br>
logic to form, based on the specification, an output document<br>
comprising the output according to the definition of an output document; and<br>
logic to transmit the output document on the network interface.<br>
99.	The apparatus of claim 98, including:<br>
logic to access a specification of a complementary interface, the accessed specification including a definition of an input document for the complementary interface, and a definition of an output document for the complementary interface; and<br>
logic to establish the stored specification of the interface by including the definition of the output document of the complementary interface as the definition of the input document of the interface in the stored specification.<br>
100.	The apparatus of claim 99, wherein the logic to establish the<br>
stored specification includes logic to access elements of the machine-readable<br>
specification from a repository, the repository storing a library of logical<br>
structures, schematic maps for logic structures, and definitions of documents<br>
comprising logic structures used to build interface descriptions.<br><br>
101.	The apparatus of claim 99, including:<br>
logic to establish the stored specification of the interface by including the definition of the input document of the complementary interface as the definition of the output document of the interface in the stored specification.<br>
102.	The apparatus of claim 98, including logic to provide access to the specification through the network interface to other nodes in the network.<br>
103.	The apparatus of claim 98, including logic to send the specification of the interface to another node in the network, at which access to the specification is provided for other nodes in the network.<br>
104.	The apparatus of claim 98, wherein the machine-readable specification includes a document compliant with a definition of an interface document including logical structures for storing an identifier of a particular transaction, and at least one of definitions and references to definitions of input and output documents for the particular transaction.<br>
105.	The apparatus of claim 98, wherein the machine-readable specification includes a document compliant with a definition of an interface document including logical structures for storing an identifier of the interface, and for storing at least one of specifications and references to specifications of a set of one or more transactions supported by the interface.<br>
106.	The apparatus of claim 105, wherein the machine-readable specification includes a reference to a specification of a particular transaction, and the specification of the particular transaction includes a document including logical structures for storing at least one of definitions and references to definitions of input and output documents for the particular transaction.<br><br>
107.	The apparatus of claim 98, wherein the storage units comprise parsed data.<br>
108.	The apparatus of claim 107, wherein the parsed data in at least one of the input and output documents comprises:<br>
character data encoding text characters in the one of the input and output documents, and<br>
markup data identifying sets of storage units according to the logical structure of the one of the input and output documents.<br>
109.	The apparatus of claim 108, wherein at least one of the sets of storage units encodes a plurality of text characters providing a natural language word.<br>
110.	The apparatus of claim 107, wherein the specification includes interpretation information for at least one of the sets of storage units identified by the logical structure of at least one of the input and output documents, encoding respective definitions for sets of parsed characters.<br>
111.	The apparatus of claim 107, wherein the storage units comprise unparsed data.<br>
112.	The apparatus of claim 98, wherein the transaction process has variant transaction processing architecture, and including logic to translate at least of portion of the input document into a format readable according to the variant transaction processing architecture of the transaction process.<br><br>
113.	The apparatus of claim 112, wherein the logic to translate includes logic to produce programming objects including variables and methods according to the variant transaction processing architecture of the transaction process.<br>
114.	The apparatus of claim 112, wherein the variant transaction processing architecture of the transaction process includes a process compliant with an interface description language.<br>
115.	The apparatus of claim 98, wherein the definitions of the input and output documents comprise document type definitions compliant with a standard Extensible Markup Language XML.<br>
116.	The apparatus of claim 98, including memory'accessible by the processor storing a repository of document types for use in a plurality of transactions, and wherein the definition of one of the input and output documents includes a reference to a document type in the repository.<br>
117.	The apparatus of claim 116, wherein the repository of document types includes a document type for identifying participant processes in the network.<br>
118.	The apparatus of claim 116, including providing a repository of interpretation information for logical structures, including interpretation information identifying parameters of transactions,<br>
119.	The apparatus of claim 98, wherein the transaction process has variant transaction processing architecture, and including:<br><br>
logic to access a specification of a complementary interface, the accessed specification including a definition of an input document for the complementary interface, and a definition of an output document for the complementary interface;<br>
logic to establish the stored specification of the interface by including the definition of the output document of the complementary interface as the definition of the input document of the interface in the stored specification; and<br>
logic to compile in response to the definitions of the input and output documents, data structures corresponding to the sets of storage units and logical structures of the input and output documents compliant with the transaction processing architecture of the transaction process, to compile instructions executable by the system to translate the input document to the corresponding data structures, and to compile instructions executable by the system to translate output of the transaction process into a form compliant with the definition of the output document.<br>
120.	The apparatus of claim 119, including:<br>
logic to establish the stored specification of the interface by including the definition of the input document of the complementary interface as the definition of the output document of the interface in the stored specification.<br>
121.	The apparatus of claim 98, wherein the transaction process has a<br>
variant transaction processing architecture, and including logic to establish the<br>
stored specification by accessing elements of the machine-readable specification<br>
from a repository, the repository storing a library of logical structures,<br>
schematic maps for logical structures, and definitions of documents comprising<br>
logical structures used to build interface descriptions; and including<br>
logic to compile in response to the definitions of the input and output documents, data structures corresponding to the sets of storage units and logical<br><br>
structures of the input and output documents compliant with the transaction processing architecture of the transaction process, to compile instructions executable by the system to translate the input document to the corresponding data structures, and to compile instructions executable by the system to translate output of the transaction process into a form compliant with the definition of the output document.<br>
122.	A method for managing transactions among nodes in a network<br>
including a plurality of nodes which execute processes involved in the<br>
transactions, comprising:<br>
storing machine-readable specifications of a plurality of participant interfaces, the participant interfaces identifying transactions, the respective transactions being identified by definitions of input documents, and definitions of output documents, the definitions of the input and output documents comprising respective descriptions of sets of storage units and logical structures for the sets of storage units;<br>
receiving data comprising a document through a communication network;<br>
parsing the document according to the specifications to identify an input document and one or more transactions which accept the identified input document;<br>
providing at least a portion of the input document in a machine-readable format to transaction processes associated with the one or more identified transactions.<br>
123.	The method of claim 122, including:<br>
providing a repository storing a library of logical structures, schematic maps for logic structures, and definitions of documents comprising logic structures used to build participant interface descriptions.<br><br>
124.	The method of claim 123, including providing access to the repository through the communication network to other nodes in the network.<br>
125.	The method of claim 122, wherein the machine-readable specification includes documents compliant with a definition of a participant interface document including logical structures for storing an identifier of a particular transaction, and at least one of definitions and references to definitions of input and output documents for the particular transaction.<br>
126.	The method of claim 122, wherein the machine-readable specifications include documents compliant with a definition of a participant interface document including logical structures for storing an identifier of the participant interface, and for storing at least one of specifications and references to specifications of a set of one or more transactions supported by the participant interface.<br>
127.	The method of claim 126, wherein the documents compliant with a definition of a participant interface document include a reference to a specification of a particular transaction, and the specification of the particular transaction includes a document including logical structures for storing at least one of definitions and references to definitions of input and output documents for the particular transaction.<br>
128.	The method of claim 122, wherein the storage units comprise parsed data.<br><br>
129.	The method of claim 128, wherein the parsed data in at least one<br>
of the input and output documents comprises:<br>
character data encoding text characters in the one of the input and output documents, and<br>
markup data identifying sets of storage units according to the logical structure of the one of the input and output documents.<br>
130.	The method of claim 129, wherein at least one of the sets of storage units encodes a plurality of text characters providing a natural language word.<br>
131.	The method of claim 130, wherein the specification includes interpretation information for at least one of the sets of storage units identified by the logical structure of at least one of the input and output documents, encoding respective definitions for sets of parsed characters.<br>
132.	The method of claim 130, wherein the storage units comprise unparsed data.<br>
133.	The method of claim 122, wherein the providing at least a portion of the input document in a machine-readable format to transaction processes associated with the one or more identified transactions includes executing a routing process according to a processing architecture, and including:<br>
compiling in response to the definitions of the input and output documents in the participant interfaces, data structures corresponding to the sets of storage units and logical structures of the input and output documents compliant with the processing architecture of the transaction process,<br><br>
instructions executable by the system to translate the input document to the corresponding data structures.<br>
134.	The method of claim 122, wherein the providing at least a portion of the input document in a machine-readable format to transaction processes associated with the one or more identified transactions includes executing a routing process according to a processing architecture, and including translating at least of portion of the incoming document into a format readable according to the processing architecture.<br>
135.	The method of claim 134, wherein the translating includes producing programming objects including variables and methods according to the processing architecture of the routing process.<br>
136.	The method of claim 122, wherein providing at least a portion of the input document in a machine-readable format to transaction processes associated with the one or more identified transactions, includes routing the portion of the input document to the identified transactions.<br>
137.	The method of claim 136, wherein the routing includes sending the input document on the communication network to a node executing one of the identified transactions.<br>
138.	The method of claim 122, wherein the definitions of the input and output documents comprise document type definitions compliant with a standard Extensible Markup Language XML.<br><br>
139.	The method of claim 138, wherein the specifications of participant interfaces comprise definitions of documents according to document type definitions compliant with a standard Extensible Markup Language XML.<br>
140.	The method of claim 122, wherein the repository includes standardized document types for use in a plurality of transactions, and wherein the definition of one of the input and output documents includes a reference to a standardized document type in the repository.<br>
141.	The method of claim 140, wherein the repository includes a standardized document type for identifying participant processes in the network.<br>
142.	The method of claim 140, including providing a repository of interpretation information for logical structures, including interpretation information identifying parameters of transactions.<br>
143.	The method of claim 122, wherein the transaction processes have respectively one of a plurality of variant transaction processing architectures, and including translating at least of portion of the incoming document into a format readable according to the variant transaction processing architecture of the respective transaction processes, and routing the translated portion to the respective transaction processes.<br>
144.	The method of claim 143, wherein the translating includes producing programming objects including variables and methods according to the variant transaction processing architecture of the respective transaction processes.<br><br>
145.	The method of claim 144, wherein the variant transaction processing architectures of the transaction processes comprises a process compliant with an interface description language.<br>
146.	Apparatus for managing transactions among nodes in a network including a plurality of nodes which execute processes involved in the transactions, comprising:<br>
a network interface;<br>
memory storing data and programs of instructions, including machine-readable specifications of a plurality of participant interfaces, the participant interfaces identifying transactions, the respective transactions being identified by definitions of input documents, and definitions of output documents, the definitions of the input and output documents comprising respective descriptions of sets of storage units and logical structures for the sets of storage units;<br>
a data processor coupled to the memory and the network interface which executes the programs of instructions; wherein the programs of instructions include<br>
logic to receive data comprising a document through a network<br>
interface; logic to parse the document according to the specifications to identify<br>
an input document and one or more transactions which accept the identified input document; and logic to provide at least a portion of the input document in a machine-readable format to transaction processes associated with the one or more identified transactions.<br><br>
147.	The apparatus of claim 146, including a repository stored in memory accessible by the data processor storing a library of logical structures, schematic maps for logic structures, and definitions of documents comprising logic structures used to build participant interface descriptions.<br>
148.	The apparatus of claim 146, including logic to access a repository stored in memory through the network interface storing a library of logical structures, schematic maps for logic structures, and definitions of documents comprising logic structures used to build participant interface descriptions.<br>
149.	The apparatus of claim 146, wherein the machine-readable specification includes documents compliant with a definition of a participant interface document including logical structures for storing an identifier of a particular transaction, and at least one of definitions and references to definitions of input and output documents for the particular transaction.<br>
150.	The apparatus of claim 146, wherein the machine-readable specifications include documents compliant with a definition of a participant interface document including logical structures for storing an identifier of the participant interface, and for storing at least one of specifications and references to specifications of a set of one or more transactions supported by the participant interface.<br>
151.	The apparatus of claim 150, wherein the documents compliant with a definition of a participant interface document include a reference to a specification of a particular transaction, and the specification of the particular transaction includes a document including logical structures for storing at least<br><br>
one of definitions and references to definitions of input and output documents for the particular transaction.<br>
152.	The apparatus of claim 146, wherein the storage units comprise parsed data.<br>
153.	The apparatus of claim 152, wherein the parsed data in at least one of the input and output documents comprises:<br>
character data encoding text characters in the one of the input and output documents, and<br>
markup data identifying sets of storage units according to the logical structure of the one of the input and output documents.<br>
154.	The apparatus of claim 153, wherein at least one of the sets of storage units encodes a plurality of text characters providing a natural language word.<br>
155.	The apparatus of claim 154, wherein the specification includes interpretation information for at least one of the sets of storage units identified by the logical structure of at least one of the input and output documents, encoding respective definitions for sets of parsed characters.<br>
156.	The apparatus of claim 154, wherein the storage units comprise unparsed data.<br>
157.	The apparatus of claim 146, wherein the logic to provide at least a portion of the input document in a machine-readable format to transaction processes associated with the one or more identified transactions includes a routing process according to a processing architecture, and including:<br><br>
a compiler responsive to the definitions of the input and output documents in the participant interfaces, to compile data structures corresponding to the sets of storage units and logical structures of the input and output documents compliant with the processing architecture of the transaction process, and to compile instructions executable by the system to translate the input document to the corresponding data structures.<br>
158.	The apparatus of claim 146, wherein the logic to provide at least a portion of the input document in a machine-readable format to transaction processes associated with the one or more identified transactions includes a routing process according to a processing architecture, and including logic to translate at least of portion of the incoming document into a format readable according to the processing architecture.<br>
159.	The apparatus of claim 158, wherein the logic to translate includes producing programming objects including variables and methods according to the processing architecture of the routing process.<br>
160.	The apparatus of claim 146, wherein logic to provide at least a portion of the input document in a machine-readable format to transaction processes associated with the one or more identified transactions, includes a router to route the portion of the input document to the identified transactions.<br>
161.	The apparatus of claim 160, wherein the router includes logic to send the input document on the network interface to a node executing one of the identified transactions.<br><br>
162.	The apparatus of claim 146, wherein the definitions of the input and output documents comprise document type definitions compliant with a standard Extensible Markup Language XML.<br>
163.	The apparatus of claim 162, wherein the specifications of participant interfaces comprise definitions of documents according to document type definitions compliant with a standard Extensible Markup Language XML.<br>
164.	The apparatus of claim 147, wherein the repository includes standardized document types for use in a plurality of transactions, and wherein the definition of one of the input and output documents includes a reference to a standardized document type in the repository.<br>
165.	The apparatus of claim 147, wherein the repository includes a standardized document type for identifying participant processes in the network.<br>
166.	The apparatus of claim 146, wherein the transaction processes have respectively one of a plurality of variant transaction processing architectures, and including logic to translate at least of portion of the incoming document into a format readable according to the variant transaction processing architecture of the respective transaction processes, and to route the translated portion to the respective transaction processes.<br>
167.	The apparatus of claim 166, wherein the logic to translate produces programming objects including variables and methods according to the variant transaction processing architecture of the respective transaction processes.<br><br>
168.    The apparatus of claim 166, wherein the variant transaction processing architectures of the transaction processes comprises a process compliant with an interface description language.<br>
Dated      this     26        day       of       December     2005.<br><br></cpu_clock_speed></elemnttype></schema>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol></line.item></paymentset></line.item></exchange.description></thread.idparty.assigned.by></urn></ielement></ielement></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1DSEVOUC0yMDA1ICBBQlNUUkFDVC5wZGY=" target="_blank" style="word-wrap:break-word;">3527-CHENP-2005  ABSTRACT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1DSEVOUC0yMDA1ICBDTEFJTVMucGRm" target="_blank" style="word-wrap:break-word;">3527-CHENP-2005  CLAIMS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1DSEVOUC0yMDA1ICBDT1JSRVNQT05ERU5DRSBPVEhFUlMucGRm" target="_blank" style="word-wrap:break-word;">3527-CHENP-2005  CORRESPONDENCE OTHERS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1DSEVOUC0yMDA1ICBDT1JSRVNQT05ERU5DRSBQTy5wZGY=" target="_blank" style="word-wrap:break-word;">3527-CHENP-2005  CORRESPONDENCE PO.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1DSEVOUC0yMDA1ICBGT1JNLTEucGRm" target="_blank" style="word-wrap:break-word;">3527-CHENP-2005  FORM-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1DSEVOUC0yMDA1ICBGT1JNLTEzLnBkZg==" target="_blank" style="word-wrap:break-word;">3527-CHENP-2005  FORM-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1DSEVOUC0yMDA1ICBGT1JNLTE4LnBkZg==" target="_blank" style="word-wrap:break-word;">3527-CHENP-2005  FORM-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1DSEVOUC0yMDA1ICBGT1JNLTYucGRm" target="_blank" style="word-wrap:break-word;">3527-CHENP-2005  FORM-6.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1DSEVOUC0yMDA1ICBQRVRJVElPTlMucGRm" target="_blank" style="word-wrap:break-word;">3527-CHENP-2005  PETITIONS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1DSEVOUC0yMDA1ICBQT1dFUiBPRiBBVFRPUk5FWS5wZGY=" target="_blank" style="word-wrap:break-word;">3527-CHENP-2005  POWER OF ATTORNEY.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1jaGVucC0yMDA1LWFic3RyYWN0LmpwZw==" target="_blank" style="word-wrap:break-word;">3527-chenp-2005-abstract.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1jaGVucC0yMDA1LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">3527-chenp-2005-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1jaGVucC0yMDA1LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">3527-chenp-2005-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1jaGVucC0yMDA1LWRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">3527-chenp-2005-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1jaGVucC0yMDA1LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">3527-chenp-2005-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1jaGVucC0yMDA1LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">3527-chenp-2005-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1jaGVucC0yMDA1LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">3527-chenp-2005-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzUyNy1jaGVucC0yMDA1LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">3527-chenp-2005-form 5.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="234635-a-method-and-system-to-create-language-interoperability-environment.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="234637-spacetime-equalization-in-a-wireless-receiver.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>234636</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>3527/CHENP/2005</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>29/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>17-Jul-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>10-Jun-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>26-Dec-2005</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>OPEN INVENTION NETWORK LLC</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>PO BOX 357, POUND RIDGE, NEW YORK 10576</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>BART ALAN MELTZER</td>
											<td>530 SANTA MARGUARITA, APTOS, CALIFORNIA 95003,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>TERRY ALLEN,</td>
											<td>234 SEBASTOPOL ROAD, SEBASTOPOL, XALIFORNIA 95473, USA;</td>
										</tr>
										<tr>
											<td>3</td>
											<td>MATTHEW DANIEL FUCHS</td>
											<td>16229 JACARANDA WAY, LOS GATOS, CALIFORNIA 95032, USA;</td>
										</tr>
										<tr>
											<td>4</td>
											<td>ROBERT JOHN GLUSHKO</td>
											<td>159 MENDOSA AVENUE, SAN FRANCISCO, CALIFORNIA 94116, USA;</td>
										</tr>
										<tr>
											<td>5</td>
											<td>ANDREW EVERETT DAVIDSON</td>
											<td>1222 HOPKINS GULCH, BOULDER CREEK, CALIFORNIA 95006, USA;</td>
										</tr>
										<tr>
											<td>6</td>
											<td>SCHWARZHOFF KELLY</td>
											<td>535 ARASTRADERO ROAD, APT 204, PALO ALTO, CALIFORNIA 94306,</td>
										</tr>
										<tr>
											<td>7</td>
											<td>KENNETH PERSSON</td>
											<td>500 VILLAGE CIRCLE, SANTA CRUZ, CALIFORNIA 95060, USA;</td>
										</tr>
										<tr>
											<td>8</td>
											<td>MURRAY MALONEY,</td>
											<td>671 COWAN CIRCLE, PICKERING, ONTARIO L1W 3K6, CANADA;</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F17/60</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US99/23426</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>1999-10-08</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/173,847</td>
									<td>1998-10-16</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>09/173,854</td>
									<td>1998-10-16</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>3</td>
									<td>09/173,858</td>
									<td>1998-10-16</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/234636-documents-for-commerce-in-trading-partner-networks-and-interface-defintion-based-on-the-douments by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:21:36 GMT -->
</html>
