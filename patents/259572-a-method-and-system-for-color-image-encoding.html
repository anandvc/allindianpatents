<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/259572-a-method-and-system-for-color-image-encoding by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:24:33 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 259572:A METHOD AND SYSTEM FOR COLOR IMAGE ENCODING</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD AND SYSTEM FOR COLOR IMAGE ENCODING</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The present invention relates to the compression of color image data. A combination of hard decision pixel mapping id soft decision pixel mapping is used to jointly address both quantization distortion and compression rate while maintaining low imputaBBnal complexity and compatibility with standard decoders, such as, for example, the GIF/PNG decoder.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>Title:     METHOD, SYSTEM AND SOFTWARE PRODUCT FOR COLOR IMAGE ENCODING<br>
Field Of The Invention<br>
[0001]	The present invention relates to a method, system and software<br>
product for color image encoding.<br>
Background Of The Invention<br>
[0002]	In recent years, the volume of color image data on the Internet<br>
has been explosively increasing. In particular, due to the increasing popularity of web sites, digital cameras, and online games, color image data have become a significant portion of the Internet traffic. On the other hand, access to color images through wireless channels or via low power, small devices is still time-consuming and inconvenient, which is mainly due to the limitations of image display device, storage, and transmission bandwidth has become a bottleneck for many multimedia applications - see, for example, J. Barrilleaux, R. Hinkle, and S. Wells, "Efficient vector quantization for color image encoding," Acoustics, Speech, and Signal Processing, IEEE International Conference on ICASSP '87, vol. 12, pp. 740 -743, April 1987 (hereinafter "reference [1]"), M.T.Orchard and C.A.Bouman, "Color quantization of images," Signal Processing, IEEE Transactions on, vol. 39, no. 12, pp. 2677 -2690, Dec. 1991 (hereinafter "reference [2]"), I. Ashdown, "Octree color quantization," C/C++ Users Journal, vol. 13, no. 3, pp. 31-43, 1994 (hereinafter "reference [3]"), X. Wu, "Yiq vector quantization in a new color palette architecture," IEEE Trans, on Image Processing, vol. 5, no. 2, pp. 321-329, 1996 (hereinafter "reference [4]"), L. Velho, J. Gomes, and M. V. R. Sobreiro, "Color image quantization by pain/vise clustering,"Proc. Tenth Brazilian Symp. Comput. Graph. Image Process., L. H. de Figueiredo and M. LNetio, Eds. Campos do Jordao, Spain, pp. 203-210, 1997 (hereinafter "reference [5]") and S.Wan, P. Prusinkiewicz, and S.Wong, "Variance-based color image quantization for frame buffer display," Res. Appl., vol. 15, pp. 52-58,1990 (hereinafter "reference [6]").<br><br>
[0003]	One way to alleviate the above limitations is to apply efficient<br>
color image encoding schemes which compress, optimize, or re-encode color images. A typical color image encoding scheme consists of a color palette, pixel mapping, and lossless code. The color palette acts as a vector quantization codebook, and is used to represent all colors in the original color image. The pixel mapping then maps each pixel in the image into an index corresponding to a color in the color palette. The pixel mapping could be either a hard decision pixel mapping for which the quantization of a RGB color vector into a color of the color palette is fixed and independent of the pixel location of the RGB color vector in the image once the color palette is given, or a son decision pixel mapping for which a RGB color vector may be quantized into different colors of the color palette at different pixel locations. The index sequence resulting from the pixel mapping is finally encoded by a lossless code.<br>
[0004]	Previously, color palette design, pixel mapping, and coding were<br>
investigated separately. In the design of color palette and pixel mapping, the coding part is often ignored and the main objective is to reduce the quantization distortion, improve visual quality of quantized images, and decrease computational complexity. Several tree-structured splitting and merging color image quantization methods are proposed in the literature -see, for example, references [1] to [6] - to achieve, more or less, this objective.<br>
[0005]	On the other hand, when coding is concerned, the color palette<br>
and pixel mapping are often assumed to be given, and the objective is to design efficient codes for the index sequence so as to reduce the compression rate. For instance, an algorithm for lossy compression in the LUV color space of color-quantized images was given in A.Zaccarin and B.Liu, "A novel approach for coding color quantized image," Image Processing, IEEE Transactions on, vol. 2, no. 4, pp. 442 -453, Oct. 1993 (hereinafter "reference [7]"). Two heuristic solutions were proposed in N.D.Memon and A.Venkateswaran, "On ordering color maps for lossless<br><br>
predictive coding," IEEE Transactions on Image Processing, vol. 5, no. 11, pp. 1522-1527, 1996 (hereinafter "reference [8]"), to reorder color maps prior to encoding the image by lossless predictive coding techniques. Based on a binary-tree structure and context-based entropy coding, a compression algorithm was proposed in X. Chen, S. Kwong, and J. fu Feng, "A new compression scheme for color-quantized images,"C/rcu/fe and Systems for Video Technology, IEEE Transactions on, vol. 12, no. 10, pp. 904 -908, Oct 2002 (hereinafter "reference [9]") to provide progressive coding of color-quantized images. In these algorithms, the compression efficiency is achieved at the expense of compressed bit streams incompatible with standard decoders such as the GIF/PNG decoder.<br>
Summary Of The Invention<br>
[0006]	In accordance with a first aspect of the present invention, there<br>
is provided a method for creating, from a digitized color image with N distinct colors using a data processing system, a tree structured partitioning of all pixels in the digitized color image into M disjoint clusters, wherein M is less than or equal to N, each color in the N distinct colors is digitally represented by a plurality of P-bit bytes in a color palette, and the P-bits in each P-bit byte are ordered from most significant to least significant. The method comprises (a) providing a root node comprising all of the N distinct colors; (b) providing a first level of sibling nodes linked to the root node, wherein each color in the N distinct colors is allocated by the data processing system to an associated node in the first level of sibling nodes based on a value of a first bit in each P-bit byte in the plurality of P-bit bytes; (c) for each node in a kth level of nodes comprising more than one color, providing a plurality of sibling nodes at a (k+1)th level, wherein each color in that node is allocated by the data processing system to an associated sibling node in the plurality of sibling nodes at the (k+1)th level based on a value of a (k+1)th bit in each P-bit byte in the plurality of P-bit bytes for that color, such that for each color in the N distinct colors there is a distinct leaf node comprising that color alone; and (d) selecting and merging leaf nodes until there are only M leaf nodes left.<br><br>
[0007]	In accordance with a second aspect of the present invention,<br>
there is provided a data processing system for creating, from a digitized color image with N distinct colors, a tree structured partitioning of all pixels in the digitized color image into M disjoint clusters, wherein M is less than or equal to N, each color in the N distinct colors is digitally represented by a plurality of P-bit bytes in a color palette, and the P-bits in each P-bit byte are ordered from most significant to least significant. The data processing system comprises: (a) node-creation means for (i) providing a root node comprising all of the N distinct colors; (ii) providing a first level of sibling nodes linked to the root node, wherein each color in the N distinct colors is allocated to an associated node in the first level of sibling nodes based on a value of a first bit in each P-bit byte in the plurality of P-bit bytes; and (iii) for each node in a kth level of nodes comprising more than one color, providing a plurality of sibling nodes at a (k+l)^ level, wherein each color in that node is allocated to an associated sibling node in the plurality of sibling nodes at the (k-M)"1 level based on a value of a (k+l)* bit in each P-bit byte in the plurality of P-bit bytes for that color, such that for each color in the N distinct colors there is a distinct leaf node comprising that color alone; and (b) node merging means for selecting and merging leaf nodes until there are only M leaf nodes left<br>
[0008]	In accordance with a third aspect of the present invention, there<br>
is provided a computer program product for use on a computer system to create, from a digitized color image with N distinct colors, a tree structured partitioning of all pixels in the digitized color image into M disjoint clusters, wherein M is less than or equal to N, each color in the N distinct colors is digitally represented by a plurality of P-bit bytes in a color palette, and the P-bits in each P-bit byte are ordered from most significant to least significant. The computer program product comprises a recording medium; means recorded on the medium for instructing the computer system to perform the steps of: (a) providing a root node comprising all of the N distinct colors; (b) providing a first level of sibling nodes linked to the root node, wherein each color in the N distinct colors is allocated to an associated node in the first level of sibling nodes based on a value of a first bit in each P-bit byte in the plurality<br><br>
of P-bit bytes; (c) for each node in a kth level of nodes comprising more than one color, providing a plurality of sibling nodes at a (k+1)th level, wherein each color in that node is allocated to an associated sibling node in the plurality of sibling nodes at the (k+1)m level based on a value of a (k+1)01 bit in each P-bit byte in the plurality of P-bit bytes for that color, such that for each color in the N distinct colors there is a distinct leaf node comprising that color alone; and (d) selecting and merging leaf nodes until there are only M leaf nodes left.<br>
[0009]	In accordance with a fourth aspect of the present invention,<br>
there is provided a method for deriving a new index sequence representing a pixel mapping and a new output function representing a color palette for a new digitized color image derived from an original digitized color image both defined on n pixels, wherein the original digitized color image is provided by N distinct colors being allocated to the n pixels, the new digitized color image is provided by M distinct colors being allocated to the n pixels, the new index sequence has n index members for representing the n pixels and trie new output function is for mapping the n index members to the M colors. The method comprises (a) providing a first new index sequence by partitioning all pixels in the original digitized color image into M disjoint clusters based on a color of each pixel in the original digitized color image without regard to the location of the pixel in the original digitized color image, wherein M is less than or equal to N; (b) providing a first new output function for providing a one-to-one mapping of the M distinct colors onto the pixels in the M disjoint clusters; (c) applying a soft decision optimization process to the first new index sequence and the first new output function to provide the new index sequence and the new output function respectively based on, for each member of the first new index sequence, how a color value assigned to that member by the first new output function correlates with the color value assigned to at least one other member of the first new index sequence by the first new output function.<br><br>
[0010]	In accordance with a fifth aspect of the present invention, there<br>
is provided a data processing system for deriving a new index sequence representing a pixel mapping and a new output function representing a color palette for a new digitized color image derived from an original digitized color image both defined on n pixels, wherein the original digitized color image is provided by N distinct colors being allocated to the n pixels, the new digitized color image is provided by M distinct colors being allocated to the n pixels, the new index sequence has n index members for representing the n pixels and the new output function is for mapping the n index members to the M colors. The data processing system comprises (a) a hard decision module for (i) providing a first new index sequence by partitioning all pixels in the original digitized color image into M disjoint clusters based on a color of each pixel in the original digitized color image without regard to the location of the pixel in the original digitized color image, wherein M is less than or equal to N, and (ii) providing a first new output function for providing a one-to-one mapping of the M distinct colors onto the pixels in the M disjoint clusters; and, (b) "a soft decision module for applying a soft decision optimization process to the first new index sequence and the first new output function to provide the new index sequence and the new output function respectively based on, for each member of the first new index sequence, how a color value assigned to that member by the first new output function correlates with the color value assigned to at least one other member of the first new index sequence by the first new output function.<br>
[0011]	In accordance with a sixth aspect of the present invention, there<br>
is provided a computer program product for use on a computer system to create a pixel mapping and a new output function representing a color palette for a new digitized color image derived from an original digitized color image both defined on n pixels, wherein the original digitized color image is provided by N distinct colors being allocated to the n pixels, the new digitized color image is provided by M distinct colors being allocated to the n pixels, the new index sequence has n index members for representing the n pixels and the new output function is for mapping the n index members to the M colors. The<br><br>
computer program product comprises a recording medium; and, means recorded on the medium for instructing the computer system to perform the steps of: (a) providing a first new index sequence by partitioning all pixels in the original digitized color image into M disjoint clusters based on a color of each pixel in the original digitized color image without regard to the location of the pixel in the original digitized color image, wherein M is less than or equal to N; (b) providing a first new output function for providing a one-to-one mapping of the M distinct colors onto the pixels in the M disjoint clusters; (c) applying a soft decision optimization process to the first new index sequence and the first new output function to provide the new index sequence and the new output function respectively based on, for each member of the first new index sequence, how a color value assigned to that member by the first new output function correlates with the color value assigned to at least one other member of the first new index sequence by the first new output function.<br>
Brief Description Of The Drawings<br>
[0012]	A detailed description of preferred aspects of thelnvention is<br>
provided herein below with reference to the following drawings, in which:<br>
[0013]	Figure 1, in a block diagram, illustrates a computer system in<br>
accordance with a preferred aspect of the present invention;<br>
[0014]	Figure 2, in a graph, illustrates a octree structure in accordance<br>
with a preferred aspect of the invention;<br>
[0015]	Figure 3, in a graph, illustrates a Viterbi algorithm in accordance<br>
with a first variant of a soft-decision optimization aspect of the present invention;<br>
[0016]	Figure 4, in a graph, illustrates a Viterbi algorithm in accordance<br>
with a second variant of a soft-decision optimization aspect of the present invention; and,<br>
[0017]	Figure 5, in a block diagram, illustrates a CPU of the computer<br>
system of Figure 1.<br>
Detailed Description Of Preferred Embodiments Of The Invention<br><br>
[0018]	Referring to Figure 1, there is illustrated in a block diagram, a<br>
computer system 10 in accordance with an aspect of the invention. The computer system comprises a memory 12 for storing color image data, a monitor 14 for displaying digital color images, a CPU 16 for image processing and for providing compression of color data that jointly optimizes both quantization, distortion and compression weight while maintaining low computational complexity and compatibility with GIF/PNG decoders, and an encoder 20 such as a GIF encoder or PNG encoder for encoding the color image data prior to its transmission from the computer system 10 via transmission conduit 20.<br>
[0019]	The joint optimization problem of color image encoding can be<br>
defined as follows: Let Q = {(r,g,b)\0^r,g,b^255} be the RGB color space.<br>
Assume 0 = {o^....^ } is the color palette of an original color image which<br>
has N distinct colors. If the total number of pixels in the original image is n, we obtain an index sequence / = (i0,^,...,;„_,) by scanning the color image from top<br>
to bottom and from left to right, where ik means that the color vector of the /rth pixel is oit. If we confine ourselves to using a new color palette C with M colors (M 
where A is a Lagrangian multiplier, and d is the square error incurred by representing oit by c^:<br>
d(0i,ct) -|o, -cjf - (r, - rct)2 + (^ -8ct f + (*„ -bck )2	(1.1)<br>
[0020]	Since there is  a  one-to-one  mapping  between  a  lossless<br>
codeword length function and a lossless code, selection of a lossless codeword length function is equivalent to that of a lossless code.<br><br>
[0021]	Clearly<br>
is the total square error (TSE), which is closely related with the visual quality of the quantized color images. Note that the minimization of TSE or other similar distortion measures is the sole purpose of quantization-oriented methods considered in references [1] to [6]. Similarly, given the new color palette C and pixel mapping (hence the index sequence U), the minimization of bit rate n~ll(u) among all possible lossless codeword length functions / is the sole purpose of coding methods for color-quantized images considered in references [7] to [9]. The cost function given above brings forward the problem of joint optimization of the rate and distortion. The quantization distortion is determined by the color palette C and pixel mapping (i.e., the index sequence CO; the compression rate is determined by both the pixel mapping and the lossless codeword length function L Here, of course, the pixel mapping is a soft decision pixel mapping. Therefore, even if the lossless codeword length function / is fixed, one can still jointly optimize both the rate and distortion by changing both C and U.<br>
[0022]	There are many lossless codeword  length functions, each<br>
corresponding to a different entropy code, such as Huffman codes DAHuffman, "A method for the construction of minimum-redundancy codes," Proc. IRE, vol. 40, no. 9, pp. 1098-1101, 1952 (hereinafter "reference [12]"), Lempel-ziv codes J. Ziv and A. Lempel, "A universal algorithm for sequential data compression," IEEE Trans. On Information Theory, vol. 23, pp. 337-343, 1977 (hereinafter "reference [11]"), J. Ziv and A. Lempel IEEE Trans. Inform. Theory (hereinafter "reference [10]"), arithmetic codes I. H. Witten, M. Neal, and J. G. Cleary, "Arithmetic coding for data compression," Commun. ACM, vol. 30, pp. 520-540, June 1987 (hereinafter "reference [13]"), grammar-based codes, E.-H. Yang and J. C. Kieffer, "Efficient universal lossless data compression algorithms based on a greedy sequential grammar transform— part one: Without context models," IEEE Trans. On Information Theory, vol.<br><br>
46, no. 3, pp. 755-777, May 2000 (hereinafter "reference [14]"), J. C. Kieffer and E.-H. Yang, "Grammar based codes: A new class of universal lossless source codes," IEEE Trans, on Information Theory, vol. 46, no. 3, pp. 737-754, May 2000 (hereinafter "reference [15]"), E.-H. Yang and D.-K. He IEEE Trans, on Information Theory, vol. 49, pp. 2874-2894, 2003 (hereinafter "reference [16]"), and lossless codes designed specifically for color image encoding - see references [7] to [9]. Since we want to maintain compatibility with GIF/PNG decoder, we choose / to be the codeword length of LZ78 or its variant in the case of GIF decoder and of the LZ77 code or its variant in the case of PNG decoder, J. Miano, "Compressed image file formats: Jpeg, png, gif, xbm, bmp," ACM Press, 2000 (hereinafter "reference [17]"), which will be denoted in each case simply by l^U). Therefore, the cost function to be minimized in our case is<br>
t-o<br>
[0023]	The cost function given above is of form similar to the cost<br>
function defined in entropy-constrained vector quantization (ECVQ), P. A. Chou, T. Lookabaugh, and R. M. Gray, "Entropy-constrained vector quantization," Acoustics, Speech, and Signal Processing [see also IEEE Transactions on Signal Processing], IEEE Transactions on, vol. 37, no. 1, pp. 31 -42, Jan. 1989 (hereinafter "reference [18]"), and in particular to the cost function defined in variable-rate trellis source encoding (VRTSE), E.-H. Yang and Z. Zhang, "Variable rate trellis source encoding," IEEE Trans, on Information Theory, vol. 45, no. 2, pp. 586-608, March 1999 (hereinafter "reference [19]"). VRTSE can be viewed as a generalization of entropy-constrained scalar quantization and vector quantization [18] in the sense that it makes use of trellis structure and jointly optimizes the resulting rate, distortion, and selected encoding path. Its efficient performance, especially in low rate regions, makes VRTSE particularly applicable to color image encoding where a high compression ratio is often desired for saving storage space and transmission time.<br><br>
[0024]	Based   on  VRTSE,  we   have  developed  two   methods   in<br>
accordance with an aspect of the invention, variable-rate trellis color quantization (VRTCQ) 1 and VRTCQ 2, to jointly optimize both the quantization distortion and compression rate while maintaining low computational complexity and compatibility with GIF/PNG decoder. Both VRTCQ 1 and VRTCQ 2 use a soft decision pixel mapping, and are iterative. In addition, in accordance with a further aspect of the invention, entropy-constrained hierarchical merging quantization (ECHMQ), which uses the octree data structure for RGB colors and locally minimizes an entropy-constrained cost for the quantized color image, is developed to provide an initial color image encoding scheme for VRTCQ 1 and VRTCQ 2. On its own, ECHMQ provides an efficient way to trade off the rate and distortion of the quantized color image.<br>
Brief Review of Variable-Rate Trellis Source Encoding<br>
[0025]	Variable-rate trellis source encoding presented in [19] is an<br>
extension of fixed slope lossy coding, E. hui Yang, Z. Zhang, and T. Berger, "Fixed-slope universal lossy data compression," IEEE Trans, on Information Theory, vol. 43, no. 5, pp. 1465 -1476, Sept. 1997 (hereinafter "reference [20]"), to the case of trellis-structured decoders. For each real-valued source sequence x" = (x0,xl,.,.,xn_l)&amp;R" , it aims to find a sequence u" = (w0»"i.-"n_i) e M"el,Msel = (0,1,...,M -1} , to minimize the cost function<br>
where A is a given Lag rang ian multiplier, / is a lossless codeword length function, j8(wn) = (z0,z,,...,zn_,) is the reproduction sequence corresponding to<br>
u" , and p is the square error distortion defined by<br>
n-l	n-t<br>
i-O<br>
for any x" = (x0,xl,...,xn_l) and z" =(z0,z,,. ..,?„.,).<br><br>
[0026]	The reproduction sequence p(u] is determined from «" through<br>
a trellis-structured decoder /5 = (/,g), where /:SxM«,-»S is a state transition function, S = {$&gt;, v-^i-i} is a set of states, and g :S x M^ -» R is an<br>
output function. The functions f and g determine the trellis structure and the set of reproduction levels (similar to a color palette), respectively. Given an initial state sit , the reproduction sequence fi(u} = (ZO.ZP-»ZB-I) is computed as follows:<br>
In other words, upon receiving u", the decoder /3 outputs the reproduction sequence   /s(Mn) = (z0,z1,...,zn_l)   while  traversing  the  sequence  of states<br>
[0027]	Fix j3 . Select I to be the Wh-order static arithmetic codeword<br>
length function 1% with Mh-order transition probability function VF(U|M*) . The Viterbi algorithm can then be used to find the optimal sequence u":<br>
"B~argv'-(v0,?^	(2"4)<br>
[0028]	Fix f. The joint optimization of g, u", and z£ (or equivalently<br>
W(M|WI) ) can be described<br>
An~1^'1'^"nffl	(2-5)<br>
[0029]	An alternating algorithm was proposed in [19] to solve the joint<br>
optimization problem (2.5). The procedure of this alternating algorithm is as follows:<br>
[0030]	Step 1: Set t = 0. Select an output function g(o)and a transition<br>
probability function W(0) satisfying<br><br>
W(O)(M|M*) &gt;0 for any u£ Mset and u" E. M^.<br>
[0031]	Step 2: Fix #(/)and W(0. Use the Viterbi algorithm to find a<br>
sequence (M")(O =(MO),W{'),...,M^,) satisfying Equation (2.4) with g replaced by g(t) and w by W(l).<br>
[0032]	Step 3: Fix (u"){'}. The index sequence (M"){/) gives rise to the<br>
update of transition probability function and output function as<br>
and<br>
where wjll = «j_t...MJ_,,JIJ,j = 0,l,..Mo-l1 are the states traversed by the trellis decoder (f,g(t)) in response to (u"}(' , and ^) a   's taken over ally" satisfying<br>
slf = ^ and «^ = w .<br>
[0033]	Step 4: Repeat step 2 to 3 for t - 0,1,2,... until<br>
where £ is a prescribed small threshold, and Z^" is the Mh-order static arithmetic codeword length function associated with Wh-order transition probability function ^(H]//). Then output /+I),(M")('+I), and W('*l].<br>
[0034]	The performance of VRTSE is asymptotically close to the rate-<br>
distortion limited, as shown by Theorems 3 and 4 in reference [19]. The experimental results over Gaussian, Laplacian, Gauss-Markov sources show that VRTSE is especially suitable for low-rate coding. To apply VRTSE to color image encoding the following problems must be addressed:<br><br>
[0035]	Problem  1: The lossless codeword length function used in<br>
VRTSE is a /cth-order static arithmetic codeword length function L^ . On the other hand, in the present example of color image encoding, the lossless codeword length function is the Lempel-ziv codeword length function/^.<br>
[0036] • Problem 2: In VRTSE, the initialization step, Step 1, is unspecified. That is, how to select the initial functions #(0) and W(0) is left open in VRTSE. This translates, in our color image encoding setting, into how to design an initial color image encoding scheme.<br>
[0037]	Problem 3: To reduce its computational complexity, the index<br>
set Mset in VRTSE is often chosen to be binary with Mses = 2 so that a high order arithmetic codeword length can be used. On the other hand, in color image encoding, the cardinality M is usually relatively large, and could be as large as 256. Therefore, a new way to reduce the computational complexity is needed.<br>
[0038]	To get around Problem 1 , we will upper bound the Lempel-ziv<br>
codeword length function /^ . If /^ is the codeword length function of LZ78, then it follows from the lossless source coding literature (see, for example, [14]) that for any sequence u =(MO,UI,...,WM_I),<br><br><br><br>
.     . (2.6)<br><br>
where rk(u") is the Mh-order empirical entropy of «" in bits per symbol, qt is a<br>
constant depending only on k, and log stands for the logarithm relative to base 2. A similar upper bound is also valid if lu is the codeword length<br>
function of LZ77. Instead of minimizing  — lj(u]  subject to a distortion<br>
constraint, we will minimize rk(u"} subject to the same distortion constraint in<br>
VRTCQ 1. A different upper bound will be used in VRTCQ 2. Problems 2 to 3 are addressed below.<br>
Entropy-Constrained Hierarchical Merging Quantization<br><br>
[0039]	According to an aspect of the invention, problem 2 is addressed<br>
through an entropy-constrained hierarchical merging quantization (ECHMQ), which provides an initial color image encoding scheme for VRTSE. ECHMQ serves as the first stage, Stage 1 , for both VRTCQ 1 and VRTCQ 2.<br>
[0040]	ECHMQ  is hard-decision quantization, which  partitions  the<br>
original N colors into M non-overlapped clusters, finds a reproductive color for each cluster, and determines the reproductive color for each original color regardless of the position of the original color in the 2-dimensional image. It takes advantage of the octree data structure [3] and trades off the rate and distortion by locally minimizing an entropy-constrained cost, which is defined below.<br>
[0041]	Given   an   n   -   pixel   color   image   with   a   color   palette<br>
O = {°O'°!'-.OA'-I} and desired new color palette size M<a we use a hard-decision quantizer q to partition the n colors into m clusters cqtclt...- which satisfy for i and s af></a>
0	(3.7)<br>
The integer forms of the centroids of clusters constitute the color palette C = {CO,CI,...,CA/_I} , and the mapping from an original color to a cluster explicitly<br>
maps each pixel to an index. Let u -(m,,n,...,*u)ejlC be the index sequence obtained from mapping all pixels to indices. Then the entropy-constrained cost of the quantized image is defined as:<br>
j(q) = R(q)+*D(q)	(3.8)<br>
where A is a lagrangian multiplier. In (3.8), D(q)\s the total square error<br>
-1<br>
where F(ot), with Osi<at is the number of occurrences color o. in original image and d square euclidean distance between></at><br>
two colors in RGB space, as defined in Equation (1.1). #(4) is the codeword<br>
length of the index sequence //. Since the mapping from a color to an index is independent of the color's position in the color image, the first order entropy is used to calculate the codeword length:<br><br><br>
;    V0*)<br>
R(q),<br><br>
(3.10)<br><br>
[0042]	The cost function defined in Equation (3.8) is similar to the<br>
Lagrangian function defined in entropy-constrained vector quantization (ECVQ) in reference [18]. The main issue is to design a hard-decision quantizer q with a good rate distortion trade-off and low encoding complexity. An octree structure is used to speed up the merging and the cost function defined in Equation (3.8) to trade off the rate and distortion of the quantized image.<br>
[0043]	Unlike the on-the-fly octree building procedure which scans the<br>
color of each pixel and inserts it in the tree [3], we get the histogram of the original color image and build the initial octree once. Referring to Figure 2, there is illustrated in a graph, an octree 22, which contains all the distinct colors and their occurrences in an original color image. Root node 24, i.e. level 0, includes all the distinct colors in the color image. Since each color in the RGB color space consists of three 8-bit bytes, each of which represents a primary component, the most significant bits of the three bytes determine the position of the color in level 1. As long as more than one color passes a node, that node is an intermediate node 26 and should be further split according to the combination of the less significant RGB bits. The color passing a leaf node 28 is called a color in that leaf node 28, and the color itself is actually the centroid for that leaf node. The distance, in each color component direction, between the centroids of any two leaf sibling nodes at level k, falls into the range of (o,29"*). Obviously, the larger k is, the more similar those centroid<br>
colors are. Note that the octree 22 shown in Figure 2 is highly unbalanced and asymmetrical for two reasons: first, the number of colors that appear in an<br><br>
ordinary color image is far less than the total number of 2Mcolors available in RGB space - see reference [17]; second, a node stops splitting if there is only one color passing it.<br>
[0044]	Each distinct color o. in the original color image is now put in a<br>
distinct leaf node 0; in the octree. By repeatedly merging two leaf sibling nodes each time, we can reduce the number of leaf nodes from N toM. The integer form of the centroid of each resulting leaf node is a color in the new color palette. Note that after repeated merger of leaf sibling nodes, each leaf node corresponds to a subset of colors in the color palette of the original color image.<br>
[0045]	Assume O = {o0,0p...,ow_,} is the color palette of the original color<br>
image. Let 0,.and 0,. be two leaf sibling nodes under the parent node 0r<br>
where ®i = {oio,oii,...,oi^},j = {oj<i and e let ct be the centroid color for c number ft of occurrences node is defined as sum each in></i>
where Fit denotes the number of occurrences of the color oit in the original image. The number Fy of occurrences of the node 0y is calculated in a similar manner:<br>
F.AF,- + F, +...+ F,<br>
J—    JO	Jl	Jt-l<br>
where Fjt denotes the number of occurrences of the color ojt in the original image. By merging the two nodes 0, and 0y to a new node 0r we move all colors in 0. and ©y to the new node 0,y, i.e. Qy^QiU® j = {0,^,0^,...,o^,oh,oh,...,ojti}. Accordingly, the number of occurrences of the node 0ff is F^. =Ff + Fr Assume that real-valued colors are<br><br>
allowed. The following lemma gives the entropy-constrained cost increment resulting from merging 6,. and 6; to 0r<br>
[0046]	Lemma   1:   By  merging   nodes   9,   and   Q.,   the  entropy<br>
constrained cost is increased by<br>
(3.11)<br>
where ctj is the centroid of the node Qijt i.e.<br>
(3.12)<br>
[0047]	Proof: The minimum total square error is achieved when we<br>
reproduce all elements in a cell with the centroid of that cell. This is the centroid condition, S. P. Lloyd, "Least squares quantization in pern," IEEE Trans, on Information Theory, no. 28, pp. 127-135, March 1982 (hereinafter "reference [21]"), widely used in quantization methods. In this paper, we use the centroid of a leaf node as the quantization level, i.e. reproduction color, for all colors in that node. By this means, the entropy-constrained cost for each possible merger can be calculated without calculating the difference between the total entropy-constrained cost before the merger, and the total entropy-constrained cost after the merger.<br>
[0048]	Since Fp, - T '*"* F, o,  and Fc , = Y *~l F, o , , the centroid of the<br>
'   '       X-/-       i     '	J   J        Z-/=       J<br>
new node ©/; is<br><br>
[0049]	Equation (3.11) for the increased entropy-constrained cost A7<br>
can be proved by calculating the increased square error AD and increased codeword length A/? separately. Let D6l denote the total square error caused<br>
by using c. as the quantization level for 0,. Then DQi =^^.0^,|^ -c
 <br>
Similarly,	we	have	A», -S^oFJK ~CJ°A~C'F	and<br>
D*v = X;~XIK -C42+X-XIK -cj2. Substituting c,with the expression in Equation (3.12) and simplifying the expression for D(0tf) we get D^ -De, +Dej + Fid(ci,cij) + FJd(cJ,cii). Therefore,<br>
[0050]	Let /^  denote the total number of bits resulting from entropy<br><br>
coding all pixels with colors in node 9,.. Then PQ. =F,log— . Similarly, we<br>
Fi<br>
have KQ. =F;Iog— and /^tf =Fijlog — . Thus,<br>
Fj<br>
which, together with A£&gt;, implies (3.1 1). This completes the proof of Lemma 1.<br>
[0051]	Lemma 1 provides rules for merging two leaf sibling nodes. Our<br>
purpose at stage 1 is to produce a hard-decision quantizer that will give an efficient trade-off between the rate and distortion of the quantized image. Since the original color palette is finite, one could find a globally optimal hard-decision quantizer by searching through all possible combinations. However, such a method has high computational complexity and hence is not feasible for real time compression. Lemma 1 suggests an alternative — a greedy method to design a tree-structured hard-decision quantizer. Based on the original octree with N leaf nodes, one can repeatedly merge two leaf sibling nodes with the minimum increment of the entropy-constrained cost until M leaf nodes are left. Such a method, dubbed entropy-constrained hierarchical merging quantization (ECHMQ), is fast and gives a reasonably good trade-off between the rate and distortion of the quantized image. The detailed steps of the ECHMQ are as follows:<br><br>
[0052]	Step 1: Read the n- pixel original color image X = (xQ,xl,...,xa_l)<br>
and get the color palette O={o0,ol,...,oN_i} and the number of occurrences /, for each color of where Osi<n.></n.>
[0053]	Step 2: Build the octree by inserting each color o, into the tree<br>
as a distinct leaf node 0,. And for each leaf node 0,,Osi<jv compute its centroid ct.="o,.," tse de.="0," number of occurrences f and codeword></jv>
length J^. =F;log— .<br>
Fi<br>
[0054]	Step3:Let/c=/V.<br>
[0055]	Step 4: Compute, for every two leaf sibling nodes 0, and ©;,<br>
the centroid ctj by Equation (3.12) and the increased entropy-constrained cost by Equation (3. 11).<br>
[0056]	Step 5: Choose, among all pairs of leaf sibling nodes, the two<br>
leaf sibling nodes Qp and 0g that minimize the increased entropy-constrained<br>
cost calculated in the previous step. Merge ®p and ©9 into a new leaf node 0M which is equal to the parent node of 0p and Qq if Bp and 0? are the only<br>
siblings under their parent node, and to a new combined leaf node under the parent node of &amp;p and Qq otherwise. Compute the centroid cw of 0 M,<br>
Fqd(cq,cM), and<br>
PI<br>
[0057]	Step 6: Remove leaf nodes &amp;p and 0q from the octree.<br>
[0058]	Step 7: Decrease k by 1.<br><br>
[0059]	Step 8: Repeat steps 4 to 7 until k = M. Then assign a distinct<br>
index ie M«, to each of the remaining M leaf nodes in the final octree. The integer form of the centroid of a leaf node is a distinct color in the new color palette, and all colors in that leaf node are mapped to the index corresponding to that leaf node.<br>
[0060]	When the desired number of colors is reached, the final entropy-<br>
constrained       cost      for      quantizing      the       original      image       is<br>
Ji,  where   JN  is the  cost of the<br>
i-N<br>
original image with N distinct colors , and A/,, is the increased cost when we merge two selected leaf nodes and decrease the number of leaf nodes in the octree from / to i-l. By finding the minimum increased entropy-constrained cost each time when we merge two leaf sibling nodes in the octree, ECHMQ provides a locally optimal way to minimize the entropy-constrained cost.<br>
[0061]	ECHIMQ aims to minimize (locally) the entropy-constrained cost,<br>
rather than the pure distortion TSE. Therefore, the rate and distortion of the quantized image are controlled and traded off by the Lagrangian multiplier A. As A increases, the average distortion decreases, and the corresponding rate increases. Indeed, -A can be interpreted as the slope of the resulting rate distortion curve. Thus, in ECHMQ, we have the flexibility to use A as a tradeoff factor to vary the rate and distortion of the quantized image.<br>
[0062]	Another   advantage   of   ECHMQ   is   its   low   computational<br>
complexity. To illustrate this, suppose initially we have total 256 leaf nodes which are all located at level 8, under 32 parent nodes at level 7. To decrease the number of leaf nodes to 255, we need to calculate the increased entropy-Si<br>
constrained cost for 32 x—— = 896 pairs of leaf sibling nodes. If the octree<br>
2!x6<br>
structure   is   not  used,   we  need  to  calculate  the  increased   cost  for<br>
256!<br>
	£- = 32640 pairs, which is basically used by the pairwise clustering in [5].<br>
jilX^ijT-;<br>
Rewrite Equation (3.11) as<br><br>
we see the calculation of the increased cost for each pair of leaf sibling nodes involves 8 additions, 7 subtractions, 10 multiplications, 1 division, and 1 log operation. Compared with the high computation spent in other methods, such as the TSE-based hierarchical splitting method [21 which employs Jocobi method for each splitting, ECHMQ enjoys very low complexity. Also the palette and the pixel mapping are easily obtained at Step 8;'this again compares favorably with other methods in literature, such as those described in references [5] and [6], where a significant amount of computation is involved in palette design and pixel mapping.<br>
[0063]	If we skip the further optimization described below, the new<br>
color palette and pixel mapping obtained at the end of the ECHMQ can be encoded directly by GIF/PNG encoder. To be specific, in what follows, we will use a PNG encoder as the entropy coder. Replacing the PNG encoder with an available GIF encoder, we easily have our output compatible with a GIF decoder.<br>
VRTCQ 1<br>
[0064]	In this section, we will adopt soft-decision quantization to further<br>
jointly optimize the compression rate and distortion of a quantized color image while maintaining compatibility with GIF/PNG decoder. Using the hard-decision quantizer obtained at the end of ECHMQ as an initial color image encoding scheme, we will extend VRTSE to color image encoding, yielding VRTCQ 1.<br>
[0065]	Let us begin with the VRTSE setting of VRTCQ 1. Since we<br>
want to maintain compatibility with GIF/PNG decoder, the output function g<br><br>
can not depend on any state. In other words, the state set S consists of only s0. In this case, the state transition function / can be dropped, the output function g is simply a mapping from Msa to the RGB space, defining the correspondence between indices and colors in the color palette, and the trellis decoder is degraded to /3 - g. Given the original color image*" = (a:,,,*,,...,*„_,),<br>
I"<br>
lsa<br>
we define for any sequence w" «=. (u0,ul,...tuH_i)&amp; M"a<br>
[0066]	We will use the upper bound given in (2.6), and minimize rt(un)<br>
subject to a distortion constraint. To be specific, let k = \. However, the procedure described below can be easily extended to any k.<br>
[0067]	The initial output function g(0} and transition probability function<br>
W(0) can be derived from the color palette and pixel mapping obtained at the end of ECHMQ,-The detailed procedure of VRTCQ 1 is described as follows:<br>
[0068]	Step 1: Set * = 0. Obtain («n)(0),g(0) and W(0) from ECHMQ:<br>
(«")   = (UOO),^(O),...,M^) is the index sequence of the quantized image resulting<br>
from the hard-decision quantizer, g(0\j),Q^j<m is the color corresponding to index in new palette obtained at end of echmq and></m>
W(0)<br>
for    any    aEMset    and    wGMsel.    Also    calculate    the    initial    cost<br>
y(0) = n-<br><br>
[0069]	Step 2: Fix g(t) and W(t]. Use the Viterbi algorithm to find a<br>
I'+I)<br>
sequence   (M")I'+I) ^(u(^l),^l\...,u(^)   satisfying   Equation   (2.4)   with   g replaced by g(l} and W by W(t}.<br><br>
[0070]	Step 3: Fix («"p. The index sequence (w"P gives rise to the<br>
update of transition probability function and output function as<br>
for any a e Mtel and w e Mia, and<br>
8<br>
for any «e Mset, where ^ is taken over all i for which uf+l) = «. Note that jct.<br>
represents the color of the fth pixel in the original image.<br>
[0071]	Step 4: Compute the updated cost<br>
].<br>
[0072]	Step 5: Repeat Steps 2 to 4 for / = 0,1,2,...; until J^ -/'<br>
where f is a prescribed threshold.<br>
[0073]	Then output g(m) and (Mfl)('+1).<br>
[0074]	Step 6: Encode the color palette /+1) and the index sequence<br>
(M")('+I) using the PNG encoder described in [17].<br>
[0075]	Steps 2 to 6 can be conveniently referred to as Stage 2 of<br>
VRTCQ 1. The Viterbi algorithm used here is depicted in a graph shown in Figure 3. The increased cost from stage to stage is calculated as:<br>
•	.	(4.13)<br>
'*'<br>
where s{ = u, for any 0 
 <br>
[0076]	The optimally of Stage 2 is demonstrated by Theorem 3 in [19].<br>
Overall, VRTCQ 1 jointly optimizes the rate and distortion of the quantized color image, to some extent, while maintaining compatibility with GIF/PNG decoder. Experiments show that the convergence is reasonably fast; typically, after 2 to 3 iterations, /f) is very close to its limit.<br>
[0077]	We conclude this section considering the overall computational<br>
complexity of VRTCQ 1. In comparison with Stage 2, Stage 1 of VRTCQ 1, i.e., the ECHMQ, has much lower computational complexity. Therefore, the main computational complexity of VRTCQ 1 lies in Stage 2, particularly in the Viterbi algorithm. Since each iteration of the Vrterbi algorithm has computational complexity o(nM2}, the overall computational complexity of<br>
VRTCQ 1 may be inconveniently high for real time compression when M is large. Therefore, it is desirable to reduce computational complexity in the case of large M. This problem is addressed by VRTCQ 2.<br>
VRTCQ 2   *•<br>
[0078]	To reduce the computational complexity of VRTCQ 1 in the case<br>
of large M, we now upper bound the Lempel-Ziv codeword length function in a way different from (2.6). To this end, we define a new information quantity different from the Ath-order empirical entropy rt(«"). Let M' be an integer<br>
strictly less than M. Let £(•) be a mapping from MJW = {o,l,...,Af-l} onto M'K, = {0,l,...,Af'-l}. In terms of b, we partition M^ into M' groups j}j = Q,l,...,M'-L For any u" =(MO,^,. ..,«„_,) e 
Define<br>
,   xv   *£^&gt;(	,   x    -,<br>
^2/ 2/H': °£ * "
" j-Q i-0<br><br>
[0079]	The  quantity     w"bw"     is  called  the  conditional empirical<br>
entropy of un given b(u"). Our desired information quantity is defined as<br>
where rk(b(u")} is the Wh-order empirical entropy of b(u"). It is not hard to show that<br>
[0080]	Thus, in view of (2.6), the Lempel-Ziv codeword length function<br>
/^ can also be upper bounded by<br>
[0081]	Instead of minimizing rk(u") subject to a distortion constraint, we<br>
now minimize rk(u") subject to a distortion constraint in VRTCQ 2. Similar to the fact that nrk(un) is the minimum codeword length afforded by all /rth-order static arithmetic codeword length functions Z^.W^M") is also related to codeword length functions. Let W^-sj/) be a probability transition function from M*set to M*ut and W^wjs) a probability transition function from M'fe, to Msel. For any u" =(UO&gt;MI,. ..,«„_,)£ AC let<br>
(5- 1 5)<br>
( = 0<br>
[0082]	It is easy to see that  z!^   is a codeword length function<br>
corresponding to a lossless code via which u" is encoded by first using a Wh-order static arithmetic code with transition probability Ws to encode b(u"), and<br>
then encoding u" conditionally given &amp;(«"). Moreover, it is not hard to show that<br><br>
nr* (utt } = min L^" (MB ) + O (log n)<br>
Wi Wu       '<br>
[0083]	Accordingly, given the mapping b, the joint optimization problem<br>
in VRTCQ 2 becomes<br>
min   mmn-lLKn + A/f*^	(5-16)<br>
"	^»*V    /	&gt;6\    '	v        '<br>
[0084]	To  be  specific,  let   &amp; = 1.  Nonetheless,  all  arguments  and<br>
procedures below apply to the general k as well. Given g,Ws, and Wut the inner minimization in (5.16) can be solved by the Viterbi algorithm with complexity of o(nM'2) instead of o(nM2}. To see this is the case, note that in view of (5.15), the cost increases, each time as t increases, by<br>
[0085]	In (5.17), only the first term relies on the past through<br>
Therefore, one can build a trellis with state set SAM' xl and fulLconnection<br>
between states of two consecutive stages, and then run the Viterbi algorithm on the trellis to solve the inner minimization problem. Before running the Viterbi algorithm, we compute the minimum sub-cost<br>
cs,xA.      min<br>
for every combination oi(s,x), where .seM1^ and xeo. The minimum sub-<br>
cost and the corresponding color index u achieving the minimum sub-cost for that pair (s,x) are kept in a look-up table. The cost over the transition from a<br>
state s,_, e AT „, at Stage t- 1 of the trellis to a state s, at Stage t of the trellis is -logWj(5,|s/_,) + c(5',,j:f). Given the original image x" = (x0,xl,...Jxn_l), if s" =(s0,sl,...,sn_l)EMinsel is the optimal path through the trellis, then M" - (UO.M,,...,^,,!) , where u, E {i : 0 &amp; i 
 <br>
[0086]	Similar to VRTCQ 1, VRTCQ 2 solves the joint optimization<br>
problem (5.16) in an iterative manner. Stage 1 of VRTCQ 2 determines the mapping b, and provides the initial output function g(0} and transition probability functions W® and W5{0). Stage 2 of VRTCQ 2 then uses an alternative procedure to solve the minimization problem. The detailed procedures of VRTCQ 2 are described as follows.<br>
A.	Procedure of Stage 1<br>
[0087]	Step 1: Run ECHMQ on the original image to get an octree TM<br>
with M leaf nodes, its color palette of size M , and the corresponding hard-decision pixel mapping.<br>
[0088]	Step 2: Based on Tu , repeat Steps 4 to 7 of the ECHMQ until<br>
M1 leaf nodes are remaining.<br>
[0089]	Step 3: Determine the mapping b from the octree Tu to the<br>
octree Tu, with Af leaf nodes obtained in Step 2, which is a subtree of TM . In particular, b(i) = j,i e Miet and j e M1^ , if and only if the /th leaf node of Tu lies in the subtree of Tu rooted at the/th leaf node ofTM. .<br>
B.	Procedure of Stage 2<br>
[0090]	Step 1: SeU = 0. Obtainfr,(«')w,(j")w,g(0),Wre/w, and Wsw from<br>
Stage 1 of the VRTCQ 2, where («B)(0&gt; . (H£*,H[C',...,I«£) is the index sequence resulting from the hard -decision pixel mapping,<br>
with     0*«<m is the color></m>
corresponding to the index u, in the new color palette obtained in Step 1 of Stage 1,<br>
("«• and<br><br>
a C -ae<br>
[0091]	Also compute the initial cost<br>
[0092]	Step 2: Fix g(l) and WJ'1. Build the look-up table. For each pair<br>
of (s, x), where s£ M\et and* E O, compute the minimum sub-cost<br>
and record the color index M e {i : 0 s i 
[0093]	Step 3: Fix g('\W^, and Ws{0. Use the Viterbi algorithm to find<br>
the optimal path through the trellis (/)('+1) ^(s(^l\sf+l},...,s(^}), which, together with b and the look-up table, determines the optimal index sequence (w")(/tl) = (4'+1),Mi'+1),...,wS)) achieving the inner minimization In (5.16) with g replaced by g(0,Wy by W^, andWs by W$t}.<br>
[0094]	Step 4: Fix («")'*  and (*")'* • These two sequences give rise<br>
to the update of transition probability functions and output function as<br>
. .  (t+1)	.    u<br>
Hi:,sf '=w, Osi<n></n>
and<br><br>
where        |S taken over all / for which<br><br>
+l)<br><br>
[0095]	Step 5: Compute the the updated cost<br>
[0096]	Step 6: Repeat Steps 2 to 5 for t = 0,1,2,... until<br>
where ^ is a prescribed threshold.<br>
[0097]	Then output g(r+1) and (w")('+1).<br>
[0098]	Step 7: Encode the color palette g(f+1) and the index sequence<br>
I) by the PNG encoder from [17].<br>
[0099]	The Viterbi algorithm used in Step 3 is depicted in the graph of<br>
Figure 4. In the graph, each circle represents a group, and the black dots within a circle represent all color indices «e Mut in the group.<br>
[00100] Similar to VRTCQ 1, the major computational complexity of VRTCQ 2 is still in its Stage 2. Although in comparison with Stage 2 of VRTCQ 1, Stage 2 of VRTCQ 2 has an extra step, Step 2, this step is not computationally intensive. Indeed, its computational complexity is o(NM),<br>
which does not depend on the size n of the original image and hence is negligible as compared to the complexity of the Viterbi algorithm when n is large. The Viterbi algorithm in Step 3 of Stage 2 of VRTCQ 2 now has 0(nM'2) computational complexity, which compares favorably with the<br>
o(«M2) computational complexity of the Vrterbi algorithm used in VRTCQ 1.<br>
Thus when M'«M, VRTCQ 2 will be much faster than VRTCQ 1. In addition, once M' is fixed, the computational complexity of VRTCQ 2 is more or less independent ofM. This makes VRTCQ 2 attractive for color rich images. The price paid in VRTCQ 2 is the slight loss of compression performance in terms of the trade-off between the compression rate and distortion since a loose bound is used to upper bound the Lempel-Ziv codeword length function.<br><br>
[00101] Referring to Figure 5, there is illustrated in a block diagram, the CPU 16 of the computer system 10 of Figure 1. As shown, the CPU 16 includes a hard-decision module 40 and a soft-decision module 42. The hard-decision module 40 provides ECHMQ as described above. The soft-decision module 42 provides both VRTCQ 1 and VRTCQ 2 as described above.<br>
[00102] As described above, the hard-decision module 40 comprises a node creation sub-module for building an octree structure, a node merging sub-module for selecting and merging leaf nodes, and a cost calculation sub-module for calculating, for potential mergers of pairs of leaf nodes, the entropy-constrained cost increment for each such merger. Similar to the hard-decision module 40, the soft-decision module 42 includes a cost calculation sub-module for determining the incremental reduction in cost after each iteration of soft-decision optimization by the soft-decision module 42.<br>
[00103]        Other variations and modifications of the invention are possible. For example, as described above, ECHMQ may be used on its own, without using VRTCQ on other soft-decision optimization, to provide a hard decision pixel mapping. Alternatively, VRTCQ may be used without using ECHMQ to provide the initial hard decision pixel mapping. Instead, some other initial hard decision procedure may be provided. Further, other soft decision optimization methods may be used in combination with ECHMQ instead of VRTCQ. Further, while the foregoing description is largely directed to how to jointly address both quantization distortion and compression rate while maintaining low computational complexity and compatibility with standard decoders, such as, for example, the GIF/PNG decoder, it will be apparent to those of skill in the art that both ECHMQ and VRTCQ may be applied to the compression of color image data in other contexts as well. All such modifications or variations are believed to be within the sphere and scope of the invention as defined by the claims appended hereto.<br><br><br><br><br>
We Claim<br>
1.	A method for creating, from a digitized color image with N distinct colors using a data<br>
processing system, a tree structured partitioning of all pixels in the digitized color image into M<br>
disjoint clusters, wherein M is less than or equal to N, each color in the N distinct colors is<br>
digitally represented by a plurality of P-bit bytes in a color palette, and the P bits in each P-bit<br>
byte are ordered from most significant to least significant, the method comprising:<br>
(a)	operating a processing unit (16) to provide a root node comprising all of the N<br>
distinct colors;<br>
(b)	operating the processing unit (16) to provide a first level of sibling nodes linked to the root node, wherein each color in the N distinct colors is allocated by the data processing system to an associated node in the first level of sibling nodes based on a value of a first bit in each P-bit byte in the plurality of P-bit bytes;<br>
(c)	for each node in a kth level of nodes comprising more than one color, operating the processing unit (16) to provide, a plurality of sibling nodes at a (k+l)th level, wherein each color in that node is allocated by the data processing system to an associated sibling node in the plurality of sibling nodes at the (k+l)th level based on a value of a (k+l)th bit in each P-bit byte in the plurality of P-bit bytes for that color, such that for each color in the N distinct colors there is a distinct leaf node comprising that color alone; and<br>
(d)	operating the processing unit (16) to select and merge leaf nodes until there are only M leaf nodes left.<br><br>
2.	The method as claimed in claim 1 wherein step (d) comprises repeatedly selecting and merging pairs of leaf sibling modes until there are only M leaf nodes left.<br>
3.	The method as claimed in claim 1 wherein step (d) comprises repeatedly selecting and merging pairs of leaf sibling modes whose merger has a minimum entropy-constrained cost increment until there are only M leaf nodes left.<br>
4.	The method as claimed in claim 3 wherein step (d) comprises calculating a minimum entropy-constrained cost increment without calculating a difference between a pre-merger total entropy-constrained cost and a post-merger total entropy-constrained cost.<br>
5.	The method as claimed in claim 1 wherein the plurality of P-bit bytes for each color in the N distinct colors comprises a P-bit byte for each primary color in a plurality of primary colors.<br>
6.	The method as claimed in claim 3 wherein the plurality of primary colors comprises red, green and blue.<br>
7.	The method as claimed in claim 1 comprising operating an encoding unit (18) to create a new digitized color image with M distinct colors, wherein there is a one-to-one correspondence between the M distinct colors and the M leaf nodes left after completion of step (d).<br>
8.	A data processing system for creating, from a digitized color image with N distinct<br>
colors, a tree structured partitioning of all pixels in the digitized color image into M disjoint<br>
clusters, wherein M is less than or equal to N, each color in the N distinct colors is digitally<br>
represented by a plurality of P-bit bytes in a color palette, and the P bits in each P-bit byte are<br>
ordered from most significant to least significant, the data processing system comprising:<br>
(a)	node-creation means (51) configured to<br>
(i) provide a root node comprising all of the N distinct colors;<br>
(ii) provide a first level of sibling nodes linked to the root node, wherein each color in the N distinct colors is allocated to an associated node in the first level of sibling nodes based on a value of a first bit in each P-bit byte in the plurality of P-bit bytes; and<br>
(iii) for each node in a kth level of nodes comprising more than one color, provide a plurality of sibling nodes at a (k+1)th level, wherein each color in that node is allocated to an associated sibling node in the plurality of sibling nodes at the (k+1)th level based on a value of a (k+1)th bit in each P-bit byte in the plurality of P-bit bytes for that color, such that for each color in the N distinct colors there is a distinct leaf node comprising that color alone; and<br>
(b)	node merging means (53) configured to select and merge leaf nodes until there are<br>
only M leaf nodes left.<br>
9.	The data processing system as claimed in claim 8 wherein the node merging means (53) is operable to repeatedly select and merge pairs of leaf sibling nodes until there are only M leaf nodes left.<br>
10.	The data processing system as claimed in claim 8 comprising a cost calculation means (55) configured to calculate, for potential mergers of pairs of leaf nodes, an entropy-constrained cost increment for each such merger, wherein the cost calculation means (55) is linked to the node merging means (53) and the node merging means (53) is operable to repeatedly select and merge pairs of leaf sibling modes whose merger has a minimum entropy-constrained cost increment as determined by the cost calculation means (55) until there are only M leaf nodes left.<br>
11.	The data processing system as claimed in claim 10 wherein the cost calculation means (55) is operable to calculate a minimum entropy-constrained cost increment without calculating a difference between a pre-merger total entropy-constrained cost and a post-merger total entropy-constrained cost.<br>
12.	The data processing system as claimed in claim 8 wherein the plurality of P-bit bytes for each color in the N distinct colors comprises a P-bit byte for each primary color in a plurality of primary colors.<br>
13.	The data processing system as claimed in claim 10 wherein the plurality of primary colors comprises red, green and blue.<br>
14.	The data processing system as claimed in claim 8 comprising an encoding means (18) configured to create a new digitized color image with M distinct colors, wherein there is a one-to-one correspondence between the M distinct colors and the M leaf nodes left after selection and merger by the node merging means (53).<br>
15.	A computer program product for use on a computer system to create, from a digitized color image with N distinct colors, a tree structured partitioning of all pixels in the digitized color image into M disjoint clusters, wherein M is less than or equal to N, each color in the N distinct colors is digitally represented by a plurality of P-bit bytes in a color palette, and the P bits in each P-bit byte are ordered from most significant to least significant, the computer program product comprising:<br>
a recording medium;<br>
means recorded on the medium for instructing the computer system to perform the method as claimed in claim 1.<br>
16.	The computer program product as claimed in claim 15 wherein step (d) comprises repeatedly selecting and merging pairs of leaf sibling modes until there are only M leaf nodes left.<br>
17.	The computer program product as claimed in claim 15 wherein step (d) comprises repeatedly selecting and merging pairs of leaf sibling modes whose merger has a minimum entropy-constrained cost increment until there are only M leaf nodes left.<br>
18.	The computer program product as claimed in claim 15 wherein step (d) comprises calculating a minimum entropy-constrained cost increment without calculating a difference between a pre-merger total entropy-constrained cost and a post-merger total entropy-constrained cost.<br>
19.	The computer program product as claimed in claim 15 wherein the plurality of P-bit bytes for each color in the N distinct colors comprises a P-bit byte for each primary color in a plurality of primary colors.<br>
20.	The computer program product as claimed in claim 15 wherein the plurality of primary colors comprises red, green and blue.<br>
21.	The computer program product as claimed in claim 15 comprising creating a new digitized color image with M distinct colors, wherein there is a one-to-one correspondence between the M distinct colors and the M leaf nodes left after completion of step (d).<br>
22.	A method for deriving a new index sequence representing a pixel mapping and a new output function representing a color palette for a new digitized color image derived from an original digitized color image both defined on n pixels, wherein the original digitized color image is provided by N distinct colors being allocated to the n pixels, the new digitized color image is provided by M distinct colors being allocated to the n pixels, the new index sequence has n index members for representing the n pixels and the new output function is for mapping the n index members to the M colors, the method comprising:<br>
(a)	operating a processing unit (16) to provide a first new index sequence by partitioning all pixels in the original digitized color image into M disjoint clusters based on a color of each pixel in the original digitized color image without regard to the location of the pixel in the original digitized color image, wherein M is less than or equal to N;<br>
(b)	operating the processing unit (16) to provide a first new output function for providing a one-to-one mapping of the M distinct colors onto the pixels in the M disjoint clusters;<br>
(c)	operating the processing unit (16) to apply a soft decision optimization process to<br>
the first new index sequence and the first new output function to provide the new index<br>
sequence and the new output function respectively based on, for each member of the first new<br>
index sequence, how a color value assigned to that member by the first new output function<br>
correlates with the color value assigned to at least one other member of the first new index<br>
sequence by the first new output function.<br>
23.	The method as claimed in claim 22 wherein the new index sequence provides a soft decision pixel mapping such that, for each pixel in the new digitized color image, the color value assigned to the pixel by the new index sequence and the new output function depends on the location of the pixel in the color image.<br>
24.	The method as claimed in claim 22 wherein<br>
step (c) comprises operating the processing unit (16) to apply an iterative soft decision optimization process and to determine, after each iteration, an incremental reduction in a cost function representing compression and distortion of the original digitized color image, and<br>
step (c) terminates and the new index sequence and the new color mapping determined when the incremental reduction falls below a selected threshold.<br>
25.	The method as claimed in claim 24 wherein step (c) comprises<br>
(i) operating the processing unit (16) to set a counter k equal to one;<br>
(ii) for a kth index sequence, operating the processing unit (16) to determine a (k+1)th index sequence by optimizing the cost function, for a kth output function and a kth transition probability function, over all possible index sequences;<br>
(iii) operating the processing unit (16) to determine a (k+1)th output function and a (k+1)th transition probability function from the (k+1) th index sequence;<br>
(iv) operating the processing unit (16) to determine a (k+1)th cost from the (k+1)th index sequence, the (k+1)th output function and the (k+1 )th transition probability function; and,<br>
(v) operating the processing unit (16) to calculate a (k+1)th cost difference between the (k+1)th cost and a kth cost, and, when the (k+l)th cost difference is less than a selected threshold, to select the (k+1) th index sequence and the (k+1)th output function as the new<br>
index sequence and the new output function respectively, otherwise, to increase k by 1 and to repeat sub-steps (ii) to (v).<br>
26.	The method as defined in claim 25 wherein in step (ii), the step of operating the processing unit (16) to determine the (k+1)th index sequence by optimizing the cost function, for the given kth output function and kth transition probability function, over all possible index sequences comprises operating the processing unit (16) to use a Viterbi algorithm.<br>
27.	The method as claimed in claim 26 wherein<br>
step (a) comprises operating the processing unit (16) to group the M disjoint clusters into M' disjoint groups, M' being less than M; and,<br>
step (c) comprises operating the processing unit (16) to apply the soft decision optimization process relative to the M' disjoint groups.<br>
28.	The method as claimed in claim 27 wherein the cost function depends on both M and M'.<br>
29.	A data processing system for deriving a new index sequence representing a pixel mapping and a new output function representing a color palette for a new digitized color image derived from an original digitized color image both defined on n pixels, wherein the original digitized color image is provided by N distinct colors being allocated to the n pixels, the new digitized color image is provided by M distinct colors being allocated to the n pixels, the new index sequence has n index members for representing the n pixels and the new output function is for mapping the n index members to the M colors, the data processing system comprising:<br>
(a)	a hard decision module (40) configured to<br>
(i) provide a first new index sequence by partitioning all pixels in the original digitized color image into M disjoint clusters based on a color of each pixel in the original digitized color image without regard to the location of the pixel in the original digitized color image, wherein M is less than or equal to N, and<br>
(ii) provide a first new output function to provide a one-to-one mapping of the M distinct colors onto the pixels in the M disjoint clusters; and<br>
(b)	a soft decision module (42) configured to apply a soft decision optimization process<br>
to the first new index sequence and the first new output function to provide the new index<br>
sequence and the new output function respectively based on, for each member of the first new<br>
index sequence, how a color value assigned to that member by the first new output function<br>
correlates with the color value assigned to at least one other member of the first new index<br>
sequence by the first new output function.<br>
30.	The data processing system as claimed in claim 29 wherein the new index sequence<br>
provides a soft decision pixel mapping such that, for each pixel in the new digitized color image,<br>
the color value assigned to the pixel by the new index sequence and the new output function<br>
depends on the location of the pixel in the color image.<br>
31.	The data processing system as claimed in claim 29 wherein<br>
the soft decision module (42) is operable (i) to apply an iterative soft decision optimization process, (ii) to determine, after each iteration, an incremental reduction in a cost function representing compression and distortion of the original digitized color image, and (iii) to terminate the iterative soft decision optimization process and determine the new index sequence and the new color mapping when the incremental reduction falls below a selected threshold.<br>
32.	The data processing system as claimed in claim 31 wherein the iterative soft decision<br>
optimization process comprises<br>
(i) setting a counter k equal to one;<br>
(ii) for a kth index sequence, determining a (k+1) th index sequence by optimizing the cost function, for a kh output function and a kth transition probability function, over all possible index sequences;<br>
(iii) determining a (k+1)th output function and a (k+1)th transition probability function from the (k+1)th index sequence;<br>
(iv) determining a (k+1)th cost from the (k+1) th index sequence, the (k+1)th output function and the (k+1 )th transition probability function; and,<br>
(v) calculating a (k+1)th cost difference between the (k+1)th cost and a kth cost, and, when the<br>
(k+1)1th cost difference is less than a selected threshold, selecting the (k+1)th index sequence<br>
and the (k+1)th output function as the new index sequence and the new output function<br>
respectively, otherwise, increasing k by 1 and repeating sub-steps (ii) to (v). 33. The	data<br>
processing system as claimed in claim 32 wherein, in step (ii), the step of determining the (k+1)th index sequence by optimizing the cost function, for the given kth output function and kth transition probability function, over all possible index sequences comprises using a Viterbi algorithm.<br>
34.	The data processing system as claimed in claim 33 wherein<br>
the hard decision module (40) is operable to group the M disjoint clusters into M' disjoint groups, M' being less than M; and,<br>
the hard decision module (40) is operable to apply the soft decision optimization process relative to the M' disjoint groups.<br>
35.	The data processing system as claimed in claim 34 wherein the cost function depends on both M and M'.<br>
36.	A computer program product for use on a computer system to create a pixel mapping and a new output function representing color image is provided by M distinct colors being allocated to the n pixels, the new index sequence has n index members for representing the n<br>
pixels and the new output function is for mapping the n index members to the M colors, the computer program product comprising:<br>
a recording medium; and<br>
means recorded on the medium for instructing the computer system to perform the method as defined in claim 22.<br>
37.	The computer program product as claimed in claim 36 wherein the new index sequence provides a soft decision pixel mapping such that, for each pixel in the new digitized color image, the color value assigned to the pixel by the new index sequence and the new output function depends on the location of the pixel in the color image.<br>
38.	The computer program product as claimed in claim 36 wherein<br>
step (c) comprises applying an iterative soft decision optimization process and determining, after each iteration, an incremental reduction in a cost function representing compression and distortion of the original digitized color image, and<br>
step (c) terminates and the new index sequence and the new color mapping determined when the incremental reduction falls below a selected threshold.<br>
a color palette for a new digitized color image derived from an original digitized color image both defined on n pixels, wherein the original digitized color image is provided by N distinct colors being allocated to the n pixels, the new digitized<br>
39.	The computer program product as claimed in claim 38 wherein step (c) comprises<br>
(i) setting a counter k equal to one;<br>
(ii) for a kth index sequence, determining a (k+1) th index sequence by optimizing the cost function, for a kth output function and a k01 transition probability function, over all possible index sequences;<br>
(iii) determining a (k+1)01 output function and a (k+l)th transition probability function from the (k+1)01 index sequence;<br>
(iv) determining a (k+1)01 cost from the (k+1) th index sequence, the (k+l)th output function and the (k+1)01 transition probability function; and,<br>
(v) calculating a (k+1)01 cost difference between the (k+l)th cost and a k01 cost, and, when the (k+l)th cost difference is less than a selected threshold, selecting the (k+1)th index sequence and the (k+l)th output function as the new index sequence and the new output function respectively, otherwise, increasing k by 1 and repeating sub-steps (ii) to (v).<br>
40.	The computer program product as claimed in claim 39 wherein in step (ii), the step of<br>
determining the (k+1) th index sequence by optimizing the cost function, for the given kth<br>
output function and kth transition probability function, over all possible index sequences comprises using a Viterbi algorithm.<br>
41.	The computer program product as claimed in claim 40 wherein<br>
step (a) comprises grouping the M disjoint clusters into M' disjoint groups, M' being less than M; and,<br>
step (c) comprises applying the soft decision optimization process relative to the M' disjoint groups.<br>
42.	The computer program product as claimed in claim 41 wherein the cost function depends on both M and M'.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
		<br>
		<div class="pull-left">
			<a href="259571-a-system-for-handling-call-services-in-a-wireless-telecommunication-system.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="259573-a-fuel-contaminant-sensor-and-a-device-for-detecting-a-change-in-the-contents-of-a-fuel-water-separator.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>259572</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>6164/DELNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>12/2014</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>21-Mar-2014</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>18-Mar-2014</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>20-Oct-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SLIPSTREAM DATA INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>50 BATHURST DRIVE,SUIT 12 WATERLOO,ON N2Y2C5,CANADA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>YANG EN-HUI,</td>
											<td>203 BEAVER CREEK ROAD,WATERLOO ONTARIO N2T 2R8 CANADA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>ZENG JIANFEN</td>
											<td>ZHONGSHAN UNIVERSITY P.O BOX 950 GUANGDONG,CHINA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06T 9/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/CA2005/000573</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-04-15</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/831,656</td>
									<td>2004-04-23</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/564033</td>
									<td>2004-04-21</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/259572-a-method-and-system-for-color-image-encoding by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 01:24:34 GMT -->
</html>
