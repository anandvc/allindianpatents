<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/222197-systems-and-methods-for-dynamically-linking-application-software-into-a-running-operating-system-kernel by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:48:16 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 222197:SYSTEMS AND METHODS FOR DYNAMICALLY LINKING APPLICATION SOFTWARE INTO A RUNNING OPERATING SYSTEM KERNEL</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">SYSTEMS AND METHODS FOR DYNAMICALLY LINKING APPLICATION SOFTWARE INTO A RUNNING OPERATING SYSTEM KERNEL</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>The present invention provides systems and methods for dynamically linking mudules into a running opetation system kernel. Systems and methods described herein have the following advantage; (1)they permit an application programmer to write, compile, execute, and termicate application code that is to be loaded into a kernal as if the application code was an ordinary application program, (2) they allow a standard programming environment to be used to encapsulate application software in a familiar enviromnent, and (3) they permit automatic cleanup of errors and freeing of program resources when the application termicates.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT, 1970 <br>
(39 of 1970)<br>
&amp; <br>
THE PATENTS RULES, 2003<br>
COMPLETE SPECIFICATION<br>
[See section 10, Rule 13]<br>
SYSTEMS AND METHODS FOR DYNAMICALLY LINKING APPLICATION SOFTWARE INTO A RUNNING OPERATING SYSTEM KERNEL;<br>
FINITE STATE MACHINE LABS, INC., INCORPORATED IN THE STATE OF NEW MEXICO, WHOSE ADDRESS IS 204 NEEL AVE., BLDG. B, SOCORRO, NEW MEXICO 87801, U.S.A.<br>
THE	FOLLOWING	SPECIFICATION<br>
PARTICULARLY DESCRIBES THE INVENTION AND THE MANNER IN WHICH IT IS TO BE PERFORMED.<br>
1<br><br>
SYSTEMS AND METHODS FOR DYNAMICALLY LINKING APPLICATION SOFTWARE INTO A RUNNING OPERATING SYSTEM<br>
KERNEL<br>
COPYRIGHT NOTICE<br>
A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent files or records, but otherwise reserves all copyright rights whatsoever.<br>
COMPUTER PROGRAM LISTING APPENDIX<br>
A computer program listing appendix on a compact disc incorporating features of the present invention has been submitted with the earlier national application, U.S. Application S.N. 10/670,802, in which this patent application claims priority, and is incorporated herein by reference in its entirety.  The files contained on the disc are: (1) user.c (size = 9406 bytes, creation date = 07/10/2003); (2) Makefile (size = 737 bytes, creation date = 07/10/2003); (3) rtl_crt0.c (size = 7151 bytes, creation date = 07/10/2003); (4) <br>
example.c (size = 972 bytes, creation date = 09/24/2003); (5) rtl_mainhelper.h (size = 3847 bytes, creation date = 07/10/2003); and (6) rtl_mainhelper.c (size = 5438 bytes, creation date = 07/10/2003).  The contents of the above files are attached hereto (see "source code appendix").  The<br>
2<br><br>
computer program listing and the files contained on the compact discs are subject to copyright protection and any use thereof, other than as part of the reproduction of the patent document or the patent disclosure, is strictly prohibited.<br>
BACKGROUND OF THE INVENTION<br>
1.	Field of the Invention<br>
The present invention relates, generally, to systems and methods for dynamically linking application software into a running operating system kernel and, more specifically, to systems, software, hardware, products, and processes for use by programmers in creating such application software, and dynamically loading it into and unloading it from a running operating system kernel.<br>
2.	Discussion of the Background<br>
There are many software applications in which it is desirable to link the software or one or more modules of the software into a running operating system kernel.  For example, it is generally desirable to link device driver software into the operating system kernel because it enables the device driver software to access kernel data space.<br>
Many operating systems offer utilities for dynamically linking application software (a.k.a, "application code" or "application modules") into a running operating system kernel. Typically, these methods involve copying the application module code<br>
3<br><br>
and data into kernel memory and then resolving symbol table references.  Conventionally, application modules that are to be linked into an operating system kernel include the following sections of code: (1) a section of operating system "kernel" code, (2) a section of code to handle initialization of the module, and (3) a section of code to handle module cleanup when the module is in the process of being removed.<br>
These application modules are considered, essentially, to be dynamically loadable parts of the operating system kernel.  But operating system kernels provide a very complex and low level interface to these application software modules, complicating the process of developing such application software and requiring the programmer to directly address and write operating system kernel code, code to handle initialization/loading of the application software, and code to handle unloading/cleanup after termination.  Furthermore, there is generally no defined and stable application programming interface within an operating system, and required data structures and interfaces change especially rapidly in operating systems, such as, for example, BSD and Linux, further complicating the programmer's development and implementation of the application software. Creating and loading/unloading the modules is often complex, time consuming, and requires constant monitoring and updating of the code to ensure reliable, error-free implementation.<br>
4<br><br>
What is desired, therefore, are systems and methods to overcome the above described and other disadvantages of the conventional system and methods for dynamically linking modules into a running operating system kernel.<br>
*<br>
SUMMARY OF THE INVENTION<br>
The present invention provides systems and methods for dynamically linking modules into a running operating system kernel.  The systems and methods of the present invention overcome the above described and other disadvantages of the conventional systems and methods. For example, the systems and methods specified herein (1) permit an application programmer to write, compile, execute, and terminate application code that is to be loaded into a kernel as if the application code was an ordinary (i.e., not kernel loadable) application program, (2) allow a standard programming environment to be used to encapsulate application software in a familiar environment, and (3) permit automatic cleanup of errors and freeing of program resources when the application terminates. The present invention preserves the advantages of in-kernel programming by providing an application program access to the hardware address space seen by the kernel, as well as access to kernel data structures, internal kernel services and to privileged machine instructions.<br>
Advantageously, the present invention can be applied to a wide range of application<br>
5<br><br>
environments (what the application programmer sees) and kernel environments (the underlying programming environment). For example, we have implemented the method for the POSIX threads application environment and the RTLinux and RTCore BSD kernel environments. The RTLinux kernel environment is described in U.S. Patent No. 5,995,745, the contents of which are incorporated herein by reference.<br>
In one embodiment, the system of the present invention enables a programmer to dynamically link application code created by the programmer into a running operating system kernel , wherein the system includes the following components: (1) an environment library comprising one or more routines for insulating the application code from the operating system environment and for implementing a uniform execution environment; (2) a build system for constructing a loadable module from the application code and the environment library; (3) an execution library comprising one or more routines for encapsulating the loadable module within a standard executable program file, transparently loading the loadable module into the running operating system kernel, setting up input/output channels that may be required, passing arguments to the loadable module, and terminating and unloading the loadable module after receiving a termination signal; (4) an infrastructure library comprising one or more routines that may need to be executed prior to loading the loadable module into the running operating system kernel and/or after unloading the loadable module from the kernel (such<br>
6<br><br>
routines may include routines to allocate stable memory (memory that will need to be held after the module completes and is unloaded), routines to initialize a list of modules that will be managed, routines to free memory used by the module, and routines to close files and free semaphores and other resources used by the module); and (5) a build system for constructing the executable program from the loadable module and the execution library, wherein the executable program may be in several files or a single file.<br>
In another aspect, the present invention includes a computer readable medium, such as, for example, an optical or magnetic data storage device, having stored thereon the execution library, the environment library, the infrastructure library, and the build system.<br>
The above and other features and advantages of the present invention, as well as the structure and operation of preferred embodiments of the present invention, are described in detail below with reference to the accompanying drawings.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
The accompanying drawings, which are incorporated herein and form part of the specification, illustrate various embodiments of the present invention and, together with the description, further serve to explain the principles of the invention and to enable a person skilled in<br>
7<br><br>
the pertinent art to make and use the invention.  In the drawings, like reference numbers indicate identical or functionally similar elements. Additionally, the left-most digit(s) of a reference number identifies the drawing in which the reference number first appears.<br>
FIG. 1 is a functional block diagram that illustrates the components of a system according to one embodiment of the invention.<br>
FIG. 2 is a diagram illustrating a first function of a build system component of the invention.<br>
FIG. 3 is a diagram illustrating a second function of a build system component of the invention.<br>
'" 1	FIG. 4 is a flow chart illustrating a<br>
process 400 that may be performed by build system component of the invention.<br>
FIG. 5 is a flow chart illustrating a process performed by the "main" routine of the execution library component of the invention.<br>
FIG. 6 illustrates example pseudo-code of an example loadable module.<br>
FIG. 7 illustrates a representative computer system for implementing the systems and methods of the present invention for dynamically linking application software into a running operating system kernel.<br>
8<br><br>
DETAILED DESCRIPTION OF THE PREFERRED EMBODMENT<br>
In the following description, for purposes of explanation and not limitation, specific details are set forth, such as particular systems, computers, devices, components, techniques, computer languages, storage techniques, software products and systems, operating systems, interfaces, hardware, etc. in order to provide a thorough understanding of the present invention.  However, it will be apparent to one skilled in the art that the present invention may be practiced in other embodiments that depart from these specific details.  Detailed descriptions of well-known systems, computers, devices, components, techniques, computer languages, storage techniques, software products and systems, operating systems, interfaces, and hardware are omitted so as not to obscure the description of the present invention.<br>
FIG. 1 is a functional block diagram that illustrates the components of a system 100, according to one embodiment of the invention, for dynamically linking application code 102 into a running operating system kernel 104.  Application code 102 is code written by a user 101 of system 100.  In one embodiment, the code is written as a standard WC" program and includes the "main" function. Example application code that can be used with system 100 is provided in the file "example.c", which is included in the above referenced computer program listing appendix.<br>
9<br><br>
As shown in FIG. 1, system 100 includes an infrastructure library 110, an environment library 112, an execution library 114, and a build system 116.  As used herein, the term "library" means: "a set of one or more routines," and the term "routine" means: "a set of one or more program instructions that can be executed."  Preferably, each library 112, 114, and 116 is stored in a separate file, but this need not be the case.  The libraries could all be stored in one file, in multiple files, or in any other suitable storage architecture or arrangement.<br>
Build system 116 is configured to construct a "loadable module" 202 from application code 102 and environment library 112, as is illustrated in FIG. 2.  As used herein the term "loadable module" means "object code produced from the application code and environment library."  In one embodiment, the build system 116 includes one or more makefiles.  As further illustrated in FIG. 3, build system 116 is configured to construct an executable program 302 from loadable module 202 and execution library 114.<br>
FIG. 4 is a flow chart illustrating a process 400 that may be performed by build system 116 to create loadable module 202 and executable program 302.  Process 400 can be used when, for example, the C programming language is used in implementing the invention or with any other comparable programming language.  Process 400 begins in step 402, where build system 116 compiles application code 102 into object code.  Next (step<br>
10<br><br>
404), build system 116 links the object code with the environment library 112 object code to produce a linked object module.  Next (step 406), build system 116 converts the linked object module into a C code array. This C code array is the "loadable module." Next (step 408), build system 116 compiles the C code array produced in step 406 to produce an object file. Next (step 410), system 116 links the object file produced in step 408 with execution library 112 object code to produce the executable program 302.<br>
In one embodiment, when user 101 executes program 302, a routine from the execution library 114 sets up an input channel and an output channel by connecting the standard output and standard input of the original process to the standard output and input of the process that will insert the module, and to the fifos that connect user space to kernel space.  Setting up the input/output channels is optional if application code 102 does not use input/output channels.  Also, when program 302 is executed a routine from execution library 114 inserts loadable module 202 into the operating system address space. Once loadable module 202 is inserted into the operating system address space, loadable module 202 begins to execute.<br>
If application code 102, which is included in loadable module 202, uses input/output channels, then a routine from execution library 114 waits for loadable module 202 to connect via kernel/user channels, which are implemented as RT-fifos in this embodiment, and then connects those kernel/user<br>
I I<br><br>
channels to the input/output channels mentioned above.<br>
. -  ,    After loadable module 202 begins to execute, a routine from environment library 112 creates kernel/user channels, creates a thread to execute application code 102, and then waits for the thread to complete.  Creating the kernel/user channels is optional.  When the thread completes, a routine from environment library 112 frees resources and unloads loadable module 202.  The routines from environment library 112 may need to call routines from infrastructure library 110 for carrying out their work.  For example, environment library 112 may delegate some cleanup operations to infrastructure library 110 so that cleanup can take place after loadable module 202 has been unloaded.<br>
EXAMPLE CODE FOR IMPLEMENTING THE INVENTION<br>
The following examples of code are for the Linux, RTLinux, and/or RTCore BSD operating systems. However, the present invention is not limited to operating only within the Linux operating system. The present invention can, for example, work with other operating systems, including: Net BSD and Free BSD, Apple OS X, other UNIX type operating systems, WindRiver's VxWorks system, and Microsoft's XP and NT operating systems.<br>
Example code for implementing execution library 114 is provided in the file "user.c", which is included in the above referenced computer program listing appendix.  This code is merely an example and should not be used to limit the invention.<br>
12<br><br>
The example code for implementing execution library 114 is written in the C language and includes a "main" routine.  This main routine is the first routine that is executed after user 101 executes executable program 302.  FIG. 5 is a flow chart illustrating the process 500 performed by the main routine.  As shown in FIG. 5, the main routine collects the arguments to be passed to loadable module 202 (step 502).  Next (step 504), the main routine sets up the input and output channels.  Next (step 506), main routine creates a child process by executing the fork() routine.  The child process immediately replaces its process image with the insmod process image.  The child process does this by executing the execl() routine.<br>
Next (step 508), the main routine pipes loadable module 202 to the insmod process.  This causes the insmod process to put loadable module 202 with arguments in kernel address space.  When the application code within loadable module 202 begins running in kernel space, a routine within loadable module 202 will create kernel/user channels (e.g., RTCore "fifos") that move data between kernel and user space.<br>
The main routine waits until it can open these kernel/user channels (step 510) .  Once it can open the channels it does and then uses the channels to transfer data back and forth so that data coming from loadable module 202 is sent to the standard output of executable program 302 and data coming into the standard input of executable program 302 is<br>
13<br><br>
transmitted via the kernel/user channel to loadable module 202 (step 512).<br>
',    Example code for implementing environment library 112 is provided in the file "rtl_crt0.c", which is included in the above referenced computer program listing appendix.  This code is merely an example and should not be used to limit the invention.<br>
	As discussed above, environment library<br>
112 includes one or more routines for insulating application code 102 from the operating system environment and implementing a uniform execution environment. That is, instead of depending on a changeable and specialized operating system interface, the program can use standard WC" interfaces - or alternatively, any standard application programming interface. For example, in the current embodiment of the invention, instead of using a Linux kernel "sys_open" operation applied to some terminal device so that the program can output data, the program can simply use the standard "printf" routine. Instead of using some OS dependent routine for generating a thread, the program can use "pthread_create" - a POSIX standard function.<br>
As shown in the example code, environment library 112 includes an initialization routine called "init_module()" for performing the functions of insulating application code 102 from the operating system environment and implementing a uniform execution environment.  The init_module routine is executed as soon as the module is loaded<br>
14<br><br>
into the kernel address space and is executed in the context of the process that invokes the insert/load operation.  The init_module performs the following steps:  (1) copies in arguments that have been passed to it by the execution library and that were passed to the execution library by the user or program that invoked the process, (2) creates the kernel/user channels that connect loadable module 202 to the executable program 302, (3) requests a block of memory from the operating system and stores a "task" structure that describes the application in the module to the infrastructure library, (4) puts the data describing application code 102 on a "task" list that is used by the infrastructure library to control all the modules that it manages, and (5) creates a Linux kernel thread to run a "startup_thread" routine, which is included in the infrastructure library 110 and which is describe below.<br>
As further shown, environment library 112 may also include a cleanup routine.  The cleanup routine included in the example environment library is called "cleanup_module." The cleanup_module routine performs the following task: (1) removes from the task list the task (i.e., the data describing application code 102; (2) waits for the kernel thread to terminate; (3) closes the channels created by the init_module; (4) cleans up state by freeing memory, closing files, and releasing semaphores and possibly other resources; and (5) frees the block of memory that was used to store the task structure.<br>
15<br><br>
Example code for implementing <br>
infrastructure library 110 is provided in the files "mainhelper.c" and "mainhelper. h", which are included in the above referenced computer program listing appendix.  This code is merely an example and should not be used to limit the invention.<br>
The example infrastructure library 110 includes the "startup_thread" routine.  As discussed above, the init_module routine creates a Linux kernel thread to run the startup_thread routine.  As is illustrated from the example code, the startup_thread routine does some operating system specific setup by detaching the kernel process from any terminals ("daemonize" in Linux), and filling in information in the task structure such as the identity of the current kernel thread, and then executes application code 102 by calling the "task" function.  After executing application code 102, the startup_thread routine waits for application code 102 to terminate.  When application code 102 terminates, the startup_thread routine sends the application code 102 return value down the output channel, signals completion, and exits.  By signaling completion, the startup_thread routine causes the cleanup_module routine to execute.<br>
The example infrastructure module 110 further includes a routine called "rtl_main_wait." This routine implements the function to wait for the application kernel thread to complete. The function “rtl_main_wait" is called in the application after threads are started so that the "main" routine can<br>
16<br><br>
safely be suspended until the subsidiary threads are completed.<br>
Example code for implementing build system 116 is provided in the file "Makefile", which is included in the above referenced computer program listing appendix.  This code is merely an example and should not be used to limit the invention.<br>
EXAMPLE APPLICATIONS OF THE INVENTION<br>
In general, all of the modules described below require the addition of application code to a running or booting operating system - the basic functionality provided by loadable kernel modules. Utilizing the present invention, the modules are all (1) simpler to develop and debug, (2) simpler to connect to other components to make a useful software system, and (3) more reliable. Since development time and software reusability (connection to existing software applications) dominate the costs of producing software, the invention provides a significant economic value.  In addition, the present invention provides the programmer with a familiar, less complicated development environment, and does not require the programmer to handle complicated kernel-related initialization/loading and unloading/cleanup functions.  The invention, thus, facilitates more reliable, error-free application code.<br>
(1) A real-time data acquisition module under RTLinux:<br>
17<br><br>
The present invention enables a loadable kernel data acquisition module to be developed and tested as if the module were a standard non-kernel module.  To develop a real-time data acquisition system in RTLinux using the invention all one needs to do is write a program that runs under the UNIX operating system.  The program should include a main program and a thread.  The thread should be configured to sample data from the device from which data is to be acquired (e.g., a voltage sensor) at a fixed interval and then write the data to standard output.  The program text in pseudo-code 600 is shown in FIG. 6.<br>
This program can be tested for logical correctness under any POSIX compliant standard UNIX. After testing for logical correctness, the program can be rebuilt using build system 116 to create an executable program that can be run under RTLinux or RTCore BSD, for example. The complexity of launching the thread into the real-time operating system, connecting the thread to data streams,  and closing the module on termination is now all hidden to the application. The module can be tested on a UNIX command line with the command: % data_acquisition &gt; test_file.<br>
(2) A device driver module:<br>
As noted herein, the invention provides a means of simplifying and automating module deployment and testing. Currently, the most common use for loadable kernel modules is for device drivers that are not statically linked into the<br>
18<br><br>
operating system. Drivers in loadable kernel module form allow an operating system to configure itself on boot - adding drivers for devices it detects -and allowing users and system administrators to update systems by, for example, upgrading a disk drive or a communications device and adding a new driver without re-booting a system and interrupting other functions.<br>
However, driver modules are often very dependent on specific releases of the operating system and are notorious for failing to cooperate with other components. Using the invention, a driver developer can insulate the driver from non-relevant operating system internal changes. More importantly, a system administrator can rely on the automatic cleanup provided by the invention to improve reliability and rely on the automatic setup of communication channels to improve reports. In a Linux system, without the invention, the method for testing a loadable kernel driver module might involve the following steps: (1) the administrator logs in as root to get the correct privileges; (2) the administrator uses the "insmod" utility to attempt to load the driver; and (3) if the insmod utility works, the system administrator uses a "dmesg" utility to print out internal operating system diagnostic messages and to see if he or she can find one relevant to the driver. Suppose that the driver cannot correctly start because, for example, a prior driver for the device has not been removed. At this point, the system administrator must use the "rmmod" tool to try to remove both the<br>
19<br><br>
new driver and the prior one, and then again tries to install the new driver. The driver writer must have correctly handled the complex case of responding to an "rmmod" request.<br>
With the invention, the method for testing the loadable kernel driver is much simpler.  The method might include simply the step of running the executable program that loads the module into the kernel.  If the module needs to be unloaded from the kernel, the administrator need only execute the kill command to kill the executable program.<br>
(3)	An encryption module:<br>
This example illustrates the value of the automatic creation of input/output channels by the invention. Suppose that we have a generic operating system module that provides an encryption and security stamp facility and want to attach it to a database.  The command line for initiating secure operation of the database in a system utilizing the invention might be:<br>
%(decrypt_input | my_database | encrypt_output)&amp;<br>
so that the two security modules (i.e., wdecrypt_input" and "encrypt_output") are automatically loaded and connected to the inputs and outputs of database module, wmy_database". The entire system can be terminated and automatically unloaded with a single signal.<br>
(4)	A security module:<br>
Loadable kernel modules are themselves potentially a security weakness of an operating<br>
20<br><br>
\	1<br>
system, since modules traditionally operate within the address space and with all privileges of the operating system itself. There is generally only a check on whether the user loading the module has sufficient privileges to load a module. However, the invention makes it convenient to add more sophisticated security checking either directly in the infrastructure libraries or in a root module that controls all module loads after loading. This module can validate certificates and even provide dynamic code check.<br>
(5) A fault tolerant module:<br>
The invention provides a means of dynamically adding a fault tolerance capability to a running operating system by adding a kernel data logger. For example, the script % checkpoint_kernel | netcat 10.0.0.244:45 runs a fault tolerance module named "checkpoint_kernel" and sends the module's output to a standard program (i.e., "netcat") that directs output to a named internet site and TCP port. Using prior methods, the programmer would have had to hand code creation of an output channel in the checkpoint_kernel module and then produce further code to redirect the data to a destination and to process the destination IP and port as parameters.<br>
FIG. 7 is an illustration of a representative computer system for implementing the systems and methods of the present invention for dynamically linking application software into a running operating system kernel.  With reference to<br>
21<br><br>
FIG. 7, the method of the present invention may be advantageously implemented using one or more computer programs executing on a computer system 702 having a processor or central processing unit 704, such as, for example, a workstation, server, or embedded-single-board computer using, for example, an Intel-based CPU, such a Centrino, running one of the operating systems previously described, having a memory 706, such as, for example, a hard drive, RAM, ROM, a compact disc, magneto-optical storage device, and/or fixed or removable media, having a one or more user interface devices 708, such as, for example, computer terminals, personal computers, laptop computers, and/or handheld devices, with an input means, such as, for example, a keyboard 710, mouse, pointing device, and/or microphone.  The computer program is stored in memory 11 along with other parameters and data necessary to implement the method of the present invention.<br>
In addition, the computer system 702 may include an analog-to-digital converter, sensors, and various input-output devices, and may be coupled to a computer network, which may also be communicatively coupled to the Internet and/or other computer network to facilitate data transfer and operator control.<br>
The systems, processes, and components set forth in the present description may be implemented using one or more general purpose computers, microprocessors, or the like programmed according to the teachings of the present specification, as will<br>
22<br><br>
be appreciated by those skilled in the relevant art(s).  Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the relevant art(s). The present invention thus also includes a computer-based product which may be hosted on a storage medium and include instructions that can be used to program a computer to perform a process in accordance with the present invention.  The storage medium can include, but is not limited to, any type of disk including a floppy disk, optical disk, CDROM, magneto-optical disk, ROMs, RAMs, EPROMs, EEPROMs, flash memory, magnetic or optical cards, or any type of media suitable for storing electronic instructions, either locally or remotely.<br>
While the processes described herein have been illustrated as a series or sequence of steps, the steps need not necessarily be performed in the order described, unless indicated otherwise.<br>
The foregoing has described the principles, embodiments, and modes of operation of the present invention.  However, the invention should not be construed as being limited to the particular embodiments described above, as they should be regarded as being illustrative and not as restrictive.  It should be appreciated that variations may be made in those embodiments by those skilled in the art without departing from the scope of the present invention.  Obviously, numerous modifications and variations of the present<br>
23<br><br>
I<br>
invention are possible in light of the above teachings.  It is therefore to be understood that the invention may be practiced otherwise than as specifically described herein.<br>
Thus, the breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents.<br>
24<br><br>
Source Code Appendix:<br>
The following is an example of a loadable kernel module.<br>
/* Copyright (C) Finite State Machine Labs Inc., 1995-2003. All rights reserved. */ #include <stdio.h> #include <pthread.h> #include <unistd.h><br>
pthread_t thread;<br>
void *thread-code(void *t) {<br>
struct timespec next;<br>
clock_gettime( CLOCK_REALTIME, &amp;next );<br>
while ( 1 ) {<br>
timespec-add-ns( &amp;Next, 1000*1000 ); clock-nanosleep( CLOCK_REALTIME, TIMER_ABSTIME, &amp;next, NULL);<br>
printf("inside thread\n");<br>
}<br>
return NULL; }<br>
int main(void) { int ret;<br>
ret = pthread_create( &amp;thread, NULL, thread_code, (void *)0 ); if (ret) {<br>
printf("Error on create\n"); return -1; }<br>
/* wait for the thread to exit or an asynchronous signal to stop us */ rtl_main_wait() ;<br>
ret = pthread_cancel( thread ); if (ret) {<br>
printf("Error on cancel\n");<br>
return -2; }<br>
ret = pthread-join( thread, NULL ); if (ret) {<br>
printf("Error on join\n");<br>
return -31; }<br>
25<br><br>
return 0; }<br><br>
2.6<br><br>
#<br>
# MAKEFILE - 	RTLINUX_COPYRIGHT	<br>
#<br>
include ../rtl.mk<br>
CFLAGS := ${SYSCFLAGS}<br>
ifeq ($(CONFIG_UCLINUX),)<br>
all: rtl_crt0.o array user.o user-nostdout.o copy<br>
else<br>
all: array copy<br>
endif<br>
ifeq ($(CONFIG_RTL_BSD),y) USER_EXTRA += user-elf.o endif<br>
copy:<br>
mkdir -p ../libs<br>
-cp -f rtl_crt0.o user-nostdout.o user.o array ../libs<br>
user.o: user.c $(USER_EXTRA)<br>
$(CC) $(INCLUDE) -c user.c -o temp.o <br>
$(LD) -r -o user.o temp.o $(USER_EXTRA) , @rm -f temp.o<br>
user_nostdout.o: user.c $(USER_EXTRA)<br>
$(CC) $(INCLUDE) -DRTL_NO_STDOUT=l -c user.c -o temp.o<br>
$(LD) -r -o user_nostdout.o temp.o $(USER_EXTRA)<br>
@rm -f temp.o<br>
array: array.c<br>
$(HOSTCC) -o array array.c<br>
clean:<br>
rm -f *.o *.rtl array<br>
include ../Rules.make<br>
27<br><br>
/*<br>
* 	RTLINUX_COPYRIGHT	<br>
*/ #include <rtl-conf.h> #include <rtl-gpos.h> #include <rtl-printf.h> #include <rtl-_pthread.h> #include <rtl-_sched.h> #include <rtl-_posixio.h> #include <rtl-_mainhelper.h> #include <rtl-_unistd.h> #include <rtl-_fifo.h> #include <sys> #include <stdio.h><br>
#ifdef CONFIG_RTL_NETBSD # include  #endif<br>
#ifdef CONFIG_RTL_LINUX int stdout-_fifo = -1;<br>
/* per-task info for RTLinux to keep track of<br>
applications */<br>
extern struct per-_task-_info *info;<br>
extern int main(int argc, char **);<br>
int argc;<br>
char * argv[RTL_MAIN_MAXARGS] ;<br>
MODULE_PARM(argv, "1-"<br>
	MODULE_STRING (RTL_MAIN_MAXARGS) " S " ) ;<br>
MODULE_PARM(argc,"i");<br>
int init_module(void) {<br>
struct per_task_info *inf;<br>
/* setup our task info */<br>
if ( !(inf = (struct per_task_info *)kmalloc( sizeof(struct per_task_info), GFP_KERNEL)) )<br>
return -1;<br>
inf-&gt;modu1e = &amp;	this_modu1e;<br>
inf-&gt;mainfunc = main; /*<br>
28<br><br>
*	If we're loaded by the user with insmod instead of<br>
*	by the user program with the module built into it<br>
*	then argc/argv may not be set right.  Setup some<br>
*	safe defaults if so.  -- Cort <cort><br>
*/ if ( large ) {<br>
argc = 1;<br>
argv[0] = "this-_program"; }<br>
inf-&gt;argc = argc; inf-&gt;argv = argv;<br>
init-_completion( &amp;inf-&gt;mainwait ); init-_completion( &amp;inf-&gt;waitexit );<br>
/* create the stdout FIFO */ {<br>
int ret;<br>
char fnam[16];<br>
inf-&gt;stdout-_pid = current-&gt;pid; <br>
sprintf(fnam, "/dev/stdout.%d", inf-&gt;stdout-pid);<br>
if ( (ret = rtl-_mkfifo(fnam, 0666)) ) { printk("mkfifo() of %s failed\n",<br>
fnam) ; <br>
rtl-perror("mkfifo()"); }<br>
/* open the file for read only */ if ( (stdout_fifo = rtl-_open(fnam, RTL_0_WRONLY|RTL-0_NONBLOCK)) 
printk("open() of %s failed\n", fnam) ;<br>
rtl-_perror("open()"); }<br>
inf-&gt;stdout_fifo = stdout_fifo; }<br>
/* add this to the list */<br>
spin-lock( &amp;per-task-lock );<br>
inf-&gt;next = info;<br>
info = inf;<br>
spin-unlock( &amp;per-task-lock ) ;<br>
23<br><br>
if ( kernel-thread(startup_thread, (void *)inf, CLONE_FS | CLONE_FILES | CLONE_SIGNAL | SIGCHLD ) 
return -1; else<br>
return 0; }<br>
void c1eanup_modu1e(void) {<br>
struct per_task_info *inf, *free = NULL;<br>
/* remove entry this from the list */ spin-lock(&amp;per-task-lock) ;<br>
if (info &amp;&amp; (info-&gt;module == &amp;	this-module)) {<br>
free = info; info = info-&gt;next; <br>
} else {<br>
inf = info; while (inf) {<br>
        if (inf-&gt;next-&gt;module ==<br>
&amp;--	this-module) {<br>
free = inf-&gt;next-&gt;next; <br>
inf = inf-&gt;next; <br>
break; <br>
           } <br>
      } <br>
} <br>
spin-unlock(&amp;per-task-lock);<br>
if (!free) {<br>
rtl-printf("Did not find task on list!\n");<br>
return; }<br>
/* wakeup the GPOS task */ complete(&amp;free-&gt;mainwait);<br>
/* wait for the GPOS task to exit */ wait-_for-completion(&amp;free-&gt;waitexit);<br>
/* remove the stdout FIFO */ {<br>
char fnam[16];<br>
int ret;<br>
rtl-close(stdout_fifo);<br>
3o<br><br>
sprintf(fnam, "/dev/stdout.%d", free-&gt;stdout-pid);<br>
if ( (ret = rtl-unlink(fnam)) 
rtL-perror("unlink() ") ; <br>
     } <br>
}<br>
/* cleanup any state this module left */ rtl-cleanup-module(free);<br>
/* free the structure now that it's done */ kfree(free); }<br>
#endif /* CONFIG_RTL_LINUX */<br>
#ifdef CONFIG_RTL_NETBSD<br>
int rtl-main-split-args(const char *cmdline, char<br>
**args);<br>
void rtl-main-free-args(char **args);<br>
/* Module management functions */<br>
int rtl-main-init_module(struct per_task_info *inf)<br>
{<br>
const unsigned int buf-size = 256; struct rtl-module *module = inf-&gt;module; struct proc *pptr = curproc-&gt;p-pptr; char *cmdline; int ret;<br>
cmdline = malloc(buf-size, M_TEMP, M_WAITOK | M_ZERO);<br>
if (cmdline == NULL) return -ENOMEM;<br>
/* modload, is called via a shell script */ inf-&gt;stdout-pid = pptr-&gt;p-pid;<br>
/* split up the arguments */<br>
inf-&gt;argv[0] = NULL;<br>
inf-&gt;argc = rtl-main-split-args(inf-<br>
&gt;––	rtl-main-args, inf-&gt;argv);<br>
if (inf-&gt;argc 
31<br><br>
goto out; }<br>
if (inf-&gt;argc ==0) {<br>
/* no arguments, setup sane defaults */ snprintf(inf-&gt;argv[0], RTL_MAIN_ARGLEN, "% s", module-&gt;name);<br>
inf-&gt;argc = 1; }<br>
/* initialize completion idents */ init-completion(&amp;inf-&gt;mainwait); init-completion(&amp;inf-&gt;waitexit);<br>
/* create the stdout FIFO */ sprintf(cmdline, "/dev/stdout.%d", inf-&gt;stdout-pid);<br>
/*<br>
*	attribute this one to the core system,<br>
otherwise our<br>
*	refcount will be high, ditto for open<br>
*/<br>
if ((ret = 	rtl_mkfifo(cmdline, 0666, NULL)))<br>
{<br>
rtl-_printf ("mkfifo() of %s failed\n", cmdline);<br>
rtl-perror("mkfifo()"); }<br>
/* open the file for write only */<br>
inf-&gt;stdout_fifo = 	rtl-open(cmdline,<br>
RTL_0_WRONLY|RTL_0_NONBLOCK, NULL); if (inf-&gt;stdout_fifo  
Rtl-printf ("open() of %s failed\n", cmdline) ;<br>
Rtl-perror("open()"); }<br>
/* Add this task to the head of the global list */<br>
simple-lock(&amp;per-task-lock);<br>
SLIST_INSERT_HEAD(&amp;rtl-task-list, inf, list); simple-unlock(&amp;per-task-lock);<br>
/*<br>
*	finally, fire up our kernel thread, upon<br>
successful exit.<br>
32.<br><br>
*	inf-&gt;tsk has our task struct and we have a<br>
kernel thread<br>
*	called module-&gt;name.<br>
*/<br>
ret = kthread-createl(startup_thread, inf, &amp;inf-&gt;tsk, "%s",<br>
module-&gt;name);<br>
out:<br>
free(cmdline, M_TEMP);<br>
return ret; }<br>
int rtl-main-cleanup_module(struct per_task_info *inf)<br>
{<br>
char buf[32]; int ret;<br>
simple-lock(&amp;per-task-lock); SLIST_REMOVE(&amp;rtl-task-list, inf, per_task_info, list);<br>
simple-_unlock(&amp;per-task-lock) ;<br>
/* wakeup the GPOS task */ complete(&amp;inf-&gt;mainwait);<br>
/* wait for GPOS task completion */ wait-for-completion(&amp;inf-&gt;waitexit);<br>
/*<br>
*	remove our stdout fifo, we don't have to<br>
lock anymore because<br>
*	we're not in the rtl-task-list lock anymore<br>
*/<br>
rtl-close(inf-&gt;stdout_fifo); <br>
sprintf(buf, "/dev/stdout.%d",inf-&gt;stdout-pid);<br>
if ((ret = rtl-unlink(buf)) 
rtl-printf("unlink() of %s failed\n", buf);<br>
rtl-perror("unlink()");<br>
simple-unlock(&amp;per-task-lock);<br>
return ret; }<br>
/* cleanup any state the module left behind */<br>
33<br><br>
I<br>
rtl_cleanup_module(inf);<br>
rtl-main-free-args(inf-&gt;argv); return 0; }<br>
/*<br>
*	rtl-main-split-args - split arguments in @cmdline into an argv array<br>
*	©cmdline: the argument list<br>
*	@args: the array to store the returned arguments, the function<br>
*	will only allocate the string array.<br>
*/ int rtl-main-split-args(const char *cmdline, char **args)<br>
{<br>
const int m-flags = M_WAITOK | M_ZERO; int i, j, idx; char *buf;<br>
buf = malloc(RTL_MAIN_MAXARGS * RTL_MAIN_ARGLEN, M_TEMP, m-flags); if (!buf)<br>
return -ENOMEM;<br>
for (i = 0; i 
args[i] = buf + (i * RTL_MAIN_ARGLEN);<br>
i = 0, j = 0, idx = 0;<br>
while (cmdline[i] &amp;&amp; (idx 
{<br>
if (j &gt;= RTL_MAIN_ARGLEN) break;<br>
args[idx][j] = cmdline[i];<br>
if (isspace(cmdline[i])) {<br>
args[idx][j] = '\0■;<br>
idx++; j = 0; } else<br>
j++; i++;<br>
}<br>
return idx;<br>
}<br>
34<br><br>
void rtl_main_free_args(char **args)<br>
{<br>
free(args[0], M_TEMP); } .<br>
#endif    /* CONFIG_RTL_NETBSD */<br>
35<br><br>
/*.<br>
* 	RTLINUX_COPYRIGHT	<br>
*/<br>
#include <rtl-gpos.h><br>
#include <rtl-mainhelper.h> #include <rtl-printf.h> #include <rtl-sched.h> #include <rtl-posixio.h> #include <rtl-unistd.h> #include <posix> #include <posix><br>
#ifdef CONFIG_RTL_NETBSD #include <sys> #include <sys><br>
struct simplelock per-task-lock =<br>
SIMPLELOCK_INITIALIZER;<br>
struct rtl-task-list_s rtl-task-list =<br>
SLIST_HEAD_INITIALIZER(rtl-task-list);<br>
#endif /* CONFIG_RTL_NETBSD */<br>
#ifdef CONFIG_RTL_LINUX<br>
/* per-task info for RTLinux to keep track of<br>
applications */<br>
spinlock-t per-task-_lock = SPIN_LOCK_UNLOCKED;<br>
struct per_task_info *info = NULL;<br>
#endif /* CONFIG_RTL_LINUX */<br>
kthread_ret_t startup_thread(void *arg)<br>
{<br>
struct per_task_info *inf = (struct per_task_info *)arg;<br>
int ret, temp = -1;<br>
#ifdef CONFIG_RTL_LINUX<br>
/* detach this thread from the user/tty */ daemonize();<br>
/*<br>
*	update some per-process information, inf<br>
&gt;tsk is already<br>
*	set to curproc on NetBSD<br>
*/<br>
inf-&gt;tsk = current; #endif /* CONFIG_RTL_LINUX */<br>
36<br><br>
inf-&gt;thread = inf-&gt;module;<br>
/* call the task main routine */<br>
ret = inf-&gt;mainfunc(inf-&gt;argc, inf-&gt;argv);<br>
/* we have the return value, send it to the user-program */<br>
rtl-write(inf-&gt;stdout_fifo, &amp;temp, sizeof(temp));<br>
rtl-write(inf-&gt;stdout_fifo, &amp;ret, sizeof(ret));<br>
/* wake up the cleanup_module() routine if it's waiting on us */<br>
complete(&amp;inf-&gt;waitexit) ;<br>
/*<br>
*	We always return success here.  That way, the module<br>
*	loading always appears successful for the user-program<br>
*	unless there was an actual load problem (unresolved references,<br>
*	bad file and so on).<br>
*<br>
*	When there is an error from main() or any other operation<br>
*	inside the application then we return the error value above<br>
*	through the stdout FIFO.<br>
*	-- Cort <cort><br>
*/<br>
#ifdef CONFIG_RTL_LINUX<br>
return 0; #endif<br>
#ifdef CONFIG_RTL_NETBSD<br>
kthread-exit(0); #endif }<br>
void 	rtl_main_wait(struct rtl_module *module)<br>
{<br>
struct per_task_info *inf = NULL;<br>
#ifdef CONFIG_RTL_LINUX<br>
/* remove entry this from the list */ spin-lock(&amp;per-task-lock); <br>
inf = info;<br>
37<br><br>
while (inf) {<br>
if (inf-&gt;module == module)<br>
break; inf = inf-&gt;next; }<br>
spin-unlock(&amp;per-task-lock); #endif /* CONFIG_RTL_LINUX */<br>
#ifdef CONFIG_RTL_NETBSD<br>
simple-lock(&amp;per-task-lock); SLIST_FOREACH(inf, &amp;rtl-task-list, list) { <br>
if (inf-&gt;module == module) break;<br>
}<br>
simple-unlock(&amp;per-task-lock); #endif /* CONFIG_RTL_NETBSD */<br>
if (!inf) {<br>
rtl_printf("%s:%d !inf\n", 	FILE	,<br>
	LINE	) ;<br>
return; }<br>
/* wait for an rmmod event */ <br>
wait-for-completion(&amp;inf-&gt;mainwait); }<br>
#ifdef CONFIG_RTL_NETBSD<br>
/* sleep until completion wakeup, the -&gt;done is so<br>
that if a thread<br>
* completes before the waiter the waiter can proceed<br>
*/ void wait-for-completion{struct completion *ident) {<br>
simple-lock(&amp;ident-&gt;lock); while (ident-&gt;done ==0) {<br>
ltsleep(ident, curproc-&gt;p-priority | PCATCH,<br>
	FUNCTION	, 0, &amp;ident-&gt;lock);<br>
}<br>
simple-unlock(&amp;ident-&gt;lock); }<br>
void complete(struct completion *ident) {<br>
simple-lock(&amp;ident-&gt;lock) ;<br>
ident-&gt;done++;<br>
3S<br><br>
simple-unlock(&amp;ident-&gt;lock); wakeup(ident); }<br>
#endif<br>
/*<br>
* Cleanup after a rtlinux module that has exited<br>
*/ void rtl_cleanup_module(struct per_task_info *inf) {<br>
int i;<br>
#if 0<br>
rtl-_pthread_t t;<br>
/* cancel/join all threads for this module */ repeat:<br>
rtl-spin-lock( &amp;sched-data(i)-&gt;rtl-tasks-lock<br>
&gt;;<br>
for ( i = 0; i rtl_tasks; while( t != NULL ) {<br>
if ( t-&gt;creator == &amp;	this-module ) {<br>
rtl_printf("Canceling thread %08x\n", t);<br>
rtl-spin-unlock( &amp;sched-data(i)-&gt;rtl-tasks-lock );<br>
if ( rtl-pthread_cancel( t ) ) rtl_printf("cancel failed\n");<br>
if ( rtl-pthread_join( t, NULL ) )<br>
rtl_printf("join failed\n");<br>
goto repeat; }<br>
t = t-&gt;next; }<br>
rtl-spin-_unlock( &amp;sched-data(i)-&gt;rtl-tasks-lock );<br>
} #endif<br>
/* kill any FDs that this task opened */ for ( i = 0 ; i 
incr-_fd_usage(i); if ( (rtl-fds[i].f-op) &amp;&amp;<br>
(rtl-fds[i].creator == inf-&gt;module) ) rtl-close( i );<br>
33<br><br>
decr-fd-usage(i) ; }<br>
/* unregister any devices that this task managed */<br>
for ( i = 0 / i 
incr-dev-usage(i) ;<br>
if ( (rtl-inodes[i].valid) &amp;&amp;<br>
(rtl-inodes[i].creator == inf-&gt;thread) ) {<br>
/* find all FDs that have this file open */<br>
for ( j = 0 ; j 
incr-fd-usage(j);<br>
if ( (rtl-fds[j].f-op) &amp;&amp;<br>
(rtl-fds[j].devs-index == i) )<br>
rtl-close( j ); decr-fd-usage(j) ; }<br>
if (i &gt;= CONFIG_RTL_MAX_LEGACY_DEV) { /* need to unlink unconditionally */<br>
if (rtl-inodesfi].has-gpos-file) {<br>
rtl-gpos-unlink(rtl-inodes[i].name);<br>
rtl-inodes[i].has-gpos-file = 0;<br>
}<br>
/* The user may have pushed usage to any<br>
amount. Reset and handle now. */<br>
rtl_xchg(&amp;rtl_inodes[i].use_count,1);<br>
/* The GPOS user may still be out there.<br>
Let them go - they'll clean up. Otherwise,<br>
do it here, (the deer will drop usage 1 to 0. */<br>
if (!rtl-gpos-devices[i].active) {<br>
40<br><br>
decr_dev_usage(i);<br>
rtl_gpos_unregister_dev(rtl_inodes[i].name);<br>
rtl-unregister-dev(rtl_inodes[i].name); } } } else {<br>
decr_dev_usage(i); } }<br>
}<br>
41<br><br>
/*<br>
* 	RTLINUX_COPYRIGHT	<br>
*/<br>
#ifndef 	RTL_MAINHELPER	<br>
idefine 	RTL_MAINHELPER	<br>
#include <rtl_module.h><br>
#ifndef CONFIG_UCLINUX<br>
/* max # of arguments that can be passed into a main()<br>
*	program via argc/argv */<br>
#define RTL_MAIN_MAXARGS 5 #define RTL_MAIN_ARGLEN      64<br>
#ifdef 	KERNEL	<br>
#ifdef CONFIG_RTL_LINUX<br>
extern spinlock-t per-task-lock; struct per_task_info {<br>
struct rtl_module *module;<br>
struct rtl_module *thread;<br>
struct per_task_info *next;<br>
struct task-struct *tsk;<br>
int (*mainfunc)(int, char **);<br>
struct completion mainwait, waitexit;<br>
int argc;<br>
char **argv;<br>
int stdout_fifo, stdout_pid; };<br>
typedef int kthread_ret_t; #endif /* CONFIG_RTL_LINUX */<br>
#ifdef CONFIG_RTL_NETBSD<br>
# include <br>
struct completion {<br>
struct simplelock lock;<br>
unsigned int done; };<br><br>
/* Used to protect rtl-task-list<br>
traversal/insertion/removal */<br>
extern struct simplelock per-task-lock;<br>
struct per_task_info {<br>
struct rtl_module *module;<br>
struct rtl_module *thread;<br>
SLIST_ENTRY(per_task_info) list;<br>
struct proc *tsk;<br>
int (*mainfunc) (int, char **) ;<br>
struct completion mainwait, waitexit;<br>
int argc;<br>
char *argv[RTL_MAIN_MAXARGSJ;<br>
char *	rtl-main-args;<br>
int stdout_fifo, stdout_pid; };<br>
typedef void kthread_ret_t;<br>
SLIST_HEAD(rtl-task-list_s, per_task_info); extern struct rtl-task-list_s rtl-task-list; extern void complete(struct completion *); <br>
extern void wait-for-completion(struct completion<br>
*);<br>
#define init_completion(x)   do { simple_lock_init(&amp;(x)-&gt;lock); (x)-&gt;done = 0; \ } while (0)<br>
/*************************************************** *** *<br>
*	We only include the following in 'main'<br>
applications *<br>
**************************************************** **/<br>
#ifdef KMOD<br>
#undef RTL_MODULE #undef RTLINUX_MODULE<br>
/*<br>
*	Note the declaration of  main,' there are too<br>
many users of int main(void)<br>
*	and this only results in a warning, however<br>
really they should not be using<br>
A3<br><br>
*	that kind of a declaration for their main function. The correct definition<br>
*	being int main(int, char **) and parameter passing might have undefined side<br>
*	effects on some systems -Zwane<br>
*/<br>
#define RTLINUX_MODULE(modname) MOD_MISC(#modname) static char<br>
	-rtl-main-args[RTL_MAIN_MAXARGS*RTL_MAIN_ARGLEN] 	attribute	((section(".rtl-main-args"))); static struct rtl_module 	this-_module = {.usecount<br>
= 0, .name = #modname}; extern int rtl-main-init-module(struct per_task_info<br>
*); extern int rtl-main-cleanup-module (struct<br>
per_task_info *); static int  main();static struct per_task_info 	inf = { .mainfunc = 	main, .module  = &amp;	this-_module, .	rtl-main-args = 	rtl-main-args }; static int modname##_module_handle(struct lkm_table<br>
*lkmtp, int   cmd) (int err = 0; \ switch (cmd) {\ case LKM_E_LOAD:\ if (lkmexists(lkmtp))\ <br>
return -EEXIST;\ err = rtl-main-init_module(&amp;	inf);break;\ case LKM_E_UNLOAD:\ if (	this-module-usecount &gt; 0) { return -EBUSY; \ } err = rtl-main-cleanup_module(&amp;	inf);break;\ default:err = -EINVAL;4A<br><br>
i<br>
break;}\ return err;\ }\ int modname##-lkmentry(struct lkm_table *lkmtp, int cmd, int ver)\ (DISPATCH(lkmtp,cmd,ver,modname##_module_handle, modname##_module_handle, lkm-nofunc)\ }<br>
#define RTL_MODULE(modname) RTLINUX_MODULE(modname)<br>
/* This is defined during build to evaluate to<br>
RTL_MODULE(module) */<br>
KMOD<br>
/* The real main entry point */<br>
#define main       static  main<br>
#define stdout_fifo (	inf-stdout-fifo)<br>
#endif	/* KMOD */<br>
#endif	/* CONFIG_RTL_NETBSD */<br>
extern void rtl_cleanup_module(struct per_task_info<br>
*);<br>
extern kthread_ret_t startup_thread(void *);<br>
#endif /* 	KERNEL	 */<br>
#endif /* CONFIG_UCLINUX */<br>
#endif /* 	RTL_MAINHELPER	 */<br>
45<br><br>
y<br><br>
/*<br>
*   RTLINUX COPYRIGHT<br><br>
#include <stdio.h> #include <stdarg.h> #include <fcntl.h> #include <signal.h> #include <unistd.h> #include <errno.h> #include <sys> #include <sys> #include <sys> #include <sys> #include <sys> #include <termios.h> #include <rtl-conf.h> #include <rtl-mainhelper.h><br>
char filename[255];<br>
char *paths[] = { ■/opt/rtldk-2.0/bin/",<br>
"/opt/rtldk-1.2/bin/",<br>
"/sbin/", ,,/binn, " /usr/bin/", NULL }; char *program = NULL; <br>
void setup-signals(void); <br>
void do-printf-read(void);<br>
/* stdout FD from the module */ int f ;<br>
/* return value from the module */ int retval = 0, have-retval = 0;<br>
#ifdef CONFIG_RTL_NETBSD int loading-rtcore = 0; #endif<br>
int platform-exec(char *cmd, char *module-argc, char *args)<br>
{<br>
#if defined(CONFIG_RTL_LINUX)<br>
return execl(cmd, cmd, filename, "-o", program, module-argc, args, NULL); <br>
#elif defined(CONFIG_RTL_NETBSD)<br>
return execl(cmd, cmd, filename, NULL); #endif }<br>
46<br><br>
void prepare-arguments(int argc, char **argv, char<br>
*	argc, char *	argv)<br>
{<br>
int i;<br>
	argv[0] = 0;<br>
#if defined(CONFIG_RTL_LINUX)<br>
/* setup args for the module itself */<br>
sprintf(	argc, "argc=%d", argc);<br>
sprintf(	argv, "argv=\"%s\"", argv[0]);<br>
for ( i = 1; i 
sprintf(	argv, "%s,\"%s\"", 	argv,<br>
argv[i]);<br>
#elif defined(CONFIG_RTL_NETBSD)<br>
/* we take the arguments as-is under BSD */<br>
sprintf(	argv, "%s ", program);   /* argv[0]<br>
*/<br>
for (i = 1; i 
streat(	argv, argv[i]);<br>
streat(	argv, " ");<br>
} #endif<br>
}<br>
void handler(int signal) {<br>
char command[256];<br>
int i ;<br>
struct stat buf;<br>
/* find the right path */<br>
for ( i = 0 ; paths[i] != 0; i++ ) {<br>
sprintf(command, "%srmmod", paths[i]);<br>
if ( !stat( command, &amp;buf ) ) break; }<br>
/* error if we could not find rmmod */ if { !paths[i] ) {<br>
fprintf(stderr, "Could not find rmmod\n")<br>
exit(-1); }<br>
sprintf(command, "%s %s", command, program); i = system(command);<br>
if ( i != 0 ) {<br>
47<br><br>
fprintf(stderr,"%s: received signal but removal of module failed.\n", program);<br>
fprintf(stderr,"There may be other programs running that require this module.\n");<br>
setup-signals(); return; }<br>
#ifndef RTL_NO_STDOUT<br>
/* if we don't have the retval set, get one */<br>
while ( !have-retval ) { do-printf-read();<br>
} #endif /* RTL_NO_STDOUT */<br>
close(f); exit(retval); }<br>
void setup-signals(void) {<br>
struct sigaction act;<br>
/* setup to catch any signals that this process receives */<br>
act.sa-handler = handler;<br>
act.sa-flags = SA_RESETHAND;<br>
sigaction(SIGINT, &amp;act, NULL);<br>
sigaction(SIGQUIT, &amp;act, NULL);<br>
sigaction(SIGTERM, &amp;act, NULL); }<br>
char cmd[256], args[256], module_argc[16];<br>
#ifndef RTL_NO_STDOUT void do-printf-read(void) {<br>
/* for reading stdout data from the module */<br>
char *fmt = NULL, *string = NULL;<br>
int fmtlen = 0;<br>
int argtype, argsize;<br>
int i;<br>
/* read the size of the fmt string */ if ( read(f, &amp;i, sizeof(i)) 
fprintf(stderr, "%s: read of string length failed\n", program);<br>
^8<br><br>
■j-	perror (" read () ") ;<br>
exit(-1); }<br>
/*<br>
*	special case for when the main() routine in<br>
the kernel exits on<br>
*	its own<br>
*/<br>
if ( i == -1 ) {<br>
/* read the return value */<br>
) { retval\n"<br>
if ( read(f, &amp;retval, sizeof(retval)) 
fprintf(stderr, "%s: read of<br>
program);<br>
perror("read()");<br>
exit(-1); }<br>
}<br>
have-retval = 1; return;<br>
/* read the size of the arg */<br>
if ( read(f, &amp;argsize, sizeof(argsize)) 
{<br>
fprintf(stderr, "%s: read of arg length failed\n", program);<br>
perror("read()");<br>
exit(-1); }<br>
/* get the arg type */<br>
if ( (read(f, &amp;argtype, sizeof(argtype))) 
fprintf(stderr, "%s: read of arg type failed\n", program);<br>
perror("read()"); exit(-1); }<br>
/* if the string is too large, get more memory */<br>
if ( i+1 &gt; fmtlen ) { if ( fmt )<br>
free(fmt); fmtlen = i+1;<br>
43<br><br>
if ( (fmt = (char *)malloc(fmtlen)) 
{<br>
fprintf(stderr, "Cannot allocate memory for larger format string\n"); perror("malloc()") ; } }<br>
/* read the format string */ if ( (read{f, fmt, i)) 
fprintf(stderr, "%s: read of fmt string failed\n", program);<br>
perror(n read() ") ;<br>
exit(-l); } fmt[i] = 0;<br>
/* if there is no arg, just print the string and continue */<br>
if ( argsize == 0 ) {<br>
printf(fmt);<br>
fflush(stdout);<br>
return; }<br>
/* read the argument */ switch( (char)argtype ) { int d; char * s;<br>
unsigned long 1; double dl; case 'f' :<br>
if ( (read(f, &amp;dl, argsize)) 
perror("read() ") ; exit(-l); }<br>
printf(fmt, dl) ; fflush(stdout); break; case 'p':<br>
if ( (read(f, &amp;1, argsize)) 
perror("read()"); exit(-1); }<br>
50<br><br>
printf(fmt, 1); fflush(stdout); break; case 'd1: case 'i ' : case 'o': case ' u': case 'x': case 'X':<br>
if ( (read(f, &amp;d, argsize)) 
perror("read() ") ; exit(-1); }<br>
printf(fmt, d); fflush(stdout); break; case 'c':<br>
if ( (read(f, &amp;d, argsize)) 
perror("read()"); exit(-1); }<br>
printf(fmt, (char)d); fflush(stdout); break; case 's':<br>
/* get space for the string */ if ( (string = (char *)malloc(argsize+1)) 
fprintf(stderr,<br>
"Cannot allocate memory for string arg\n");<br>
perror("malloc()"); }<br>
if ( (read(f, string, argsize)). 
) {<br>
fprintf(stderr, "%s: read of 's' type failed\n", program);<br>
perror("read()"); exit(-1); }<br>
string[argsize] = 0; printf( fmt, string ); fflush(stdout);<br>
51<br><br>
free( string );<br>
break; } } #endif /* RTL_NO_STDOUT */<br>
int main(int argc, char **argv)<br>
{<br>
extern char 	module-data[];<br>
extern unsigned long   module size;<br>
int sysret, child, status, i;<br>
struct stat buf;<br>
fd-set readfds, writefds, exceptfds;<br>
mode-t old_umask;<br>
char *tmp-dir;<br>
/*<br>
*	strip off the extension, Linux doesn't care but<br>
*	BSD modload(8) uses it to determine the module<br>
*	entry point<br>
*/<br>
program = (char *)basename(argv[0]); strtok(program, ".");<br>
setup_signals();<br>
# ifdef CONFIG_RTL_NETBSD<br>
/* check whether we're loading rtcore */ if (!strncmp(program, "rtcore",6)) { loading_rtcore = 1; program = "rtl"; } #endif<br>
tmp-dir = (char *)getenv("TMP"); sprintf(filename, "%s/%s.o", tmp-dir ? : "/tmp", program);<br>
if ( argc &gt; RTL_MAIN_MAXARGS+1 ) {<br>
fprintf(stderr,"Cannot pass more than %d arguments\n",<br>
RTL_MAIN_MAXARGS); return -1; }<br>
old_umask = umask(0600) ;<br>
52<br><br>
r<br><br>
if ((f = open(filename, 0_CREAT | 0_WRONLY | OJTRUNC)) 
perror("open()");<br>
return -1; } umask(old_umask);<br>
prepare-arguments(argc, argv, module_argc, args); <br>
#ifdef CONFIG_RTL_NETBSD<br>
copy_module_args (	module_data, args) ;<br>
#endif<br>
/* write the module data to the file */<br>
if ( write (f, 	module-data, 	module-size)<br>
! = 	module-size ) {<br>
perror("write()") ;<br>
close(f);<br>
unlink(filename) ;<br>
return -1; }<br>
cl'ose (f) ;<br>
/* find the right path */<br>
for ( i = 0 ; paths[i] != 0; i++ ) {<br>
sprintf(cmd, "%sinsmod", paths[i]);<br>
if ( !stat( cmd, &amp;buf ) ) break; }<br>
/*■ error if we could not find insmod */ if ( !paths[i] ) {<br>
fprintf(stderr, "Could not find insmod\n");<br>
unlink(filename);<br>
return -1; }<br>
/* We do a fork and exec here so we get the PID of the insmod process<br>
*	so we are able to open the proper /dev/stdout.* file.  Also, we<br>
*	need to be careful since system/setuid and certain versions of bash<br>
*	do not cooporate well. — Cort <cort><br>
*/<br><br>
53<br><br>
if ( (child = fork() &gt; 0 ) {<br>
/* parent */ } else {<br>
/* child */<br>
/* exec the insmod */<br>
platform_exec(cmd, module_argc, args);<br>
/* we got here, things aren't looking good<br>
perror("execl"); exit(1);<br>
}<br>
/* wait for the module load to be done, remove the file */<br>
wait(&amp;status); unlink(filename);<br>
if (WEXITSTATUS(status) == 0) { #ifndef RTL_NO_STDOUT<br>
/* Try to open the stdout. We don't check for errors since<br>
*	some modules (rtcore, ckit and so on) will not produce a stdout<br>
*	FIFO — Cort <cort><br>
*/ sprintf(cmd, "/dev/stdout.%d", child); if ( (f = open(cmd, 0_RD0NLY)) 
perror("open()"); }<br>
■/*  setup select arguments */ ■if ( f &gt;= 0 ) {<br>
FD_ZERO(&amp;readfds); FD_ZER0(&amp;writefds); FD_2ERO(&amp;exceptfds); FD_SET(f, &amp;readfds); } #else<br>
f = -1; #endif /* RTL_NO_STDOUT */<br>
while( 1 ) { #ifndef RTL_NO_STDOUT<br>
if ( f &gt;= 0 ) {<br>
54<br><br>
1<br>
select( f+1, &amp;readfds, &amp;writefds, &amp;exceptfds, NULL );<br>
/* loop through here, printing when necessary */<br>
                  do-printf-read() ; /* if the last read gave us a retval, we're done */<br>
if ( have-retval ) handler(0); }<br>
else #endif /* RTL_N0_STD0UT */<br>
sleep(300);<br>
} } else {<br>
/* the 'insmod' failed for some reason */<br>
fprintf(stderr,"%s: Problem loading module\n", program);<br>
exit(-1); }<br>
handler(0) ;<br>
return 0; }<br>
55<br><br>
r<br><br>
WE CLAIM<br>
1.	A computer system configured to operate to provide for dynamically<br>
linking application source code created by a programmer into a running operating<br>
system kernel, comprising:<br>
an input device for enabling the programmer to input application source<br>
code;<br>
a memory for storing data representing said application source code; and a processor, communicatively associated with said input device and said<br>
memory, configured to operate to:<br>
(a)	run the operating system kernel;<br>
(b)	construct a loadable module from the application source code; and<br>
(c)	create an executable program,<br>
wherein the processor, based on the executable program, is further configured to operate to:<br>
(d)	set up input/output channels;<br>
(e)	insert the loadable module into address space of the running operating system kernel;<br>
(f)	once the loadable module is inserted into the address space, to execute the loadable module; and<br>
(g)	wait for the loadable module to connect via kernel/user channels and then connect those kernel/user channels to the input/output channels.<br><br>
2.	The computer system of claim 1, wherein the application source code is an ordinary application program.<br>
3.	The computer system of claim 1, wherein constructing the loadable module from the application source code consists essentially of executing a predefined makefile.<br>
4.	The computer system of claim 1, wherein the processor is further configured to operate to provide a makefile to the user, wherein the user<br><br>
constructs the loadable module by executing the makefile after the user has input the application source code.<br>
5.	The computer system of claim 1, wherein the processor is further<br>
configured to operate to:<br>
(a)	provide the user with a library comprising object code; and<br>
(b)	construct the loadable module from the application source code by compiling the application source code into object code; linking the object code with object code from the library to produce a linked object module; and converting the linked object module into a C code array.<br><br>
6.	The computer system of claim 5, wherein the processor is further configured to operate to construct the loadable module from the application source code by compiling the C code array to produce an object file.<br>
7.	The computer system of claim 6, wherein the processor is further configured to operate to:<br><br>
(a)	provide the user with a second library comprising object code; and<br>
(b)	create the executable program by linking the object file with object code from the second library.<br><br>
8.	The computer system of claim 5, wherein the library includes one or more routines to create kernel/user channels.<br>
9.	The computer system of claim 5, wherein the library includes one or more routines to create a thread to execute the executable program.<br>
10.	The computer system of claim 9, wherein the library includes one or more routines for freeing resources and unloading the loadable module when the thread completes.<br>
11.	The computer system of claim 5, wherein the library includes one or more routines for (a) copying in arguments; (b) creating communication channels that connect the loadable module to the executable program; (c) requesting a<br><br>
block of memory from the operating system and storing a structure therein that describes the application code; and (d) putting data describing the application code on a task list.<br>
12.	The computer system of claim 11, wherein the environment library further includes one or more routines for (a) removing said data describing the application code from the task list; (b) closing said communication channels that connect the loadable module to the executable program; and (c) freeing the block of memory that was requested from the operating system.<br>
13.	The computer system of claim 1, wherein the executable program is configured to set up input/output channels.<br>
14.	The computer system of claim 1, wherein the executable program is configured to execute a utility for installing the loadable module into the running operating system kernel.<br>
15.	The computer system of claim 14, wherein the utility for installing the loadable module into the running operating system kernel is the insmod program.<br>
16.	The computer system of claim 14, wherein the processor is further configured to operate to insert the loadable module into an operating system address space by creating a child process, wherein the child process replaces its image with the insmod process image.<br>
17.	The computer system of claim 16, wherein the processor is further configured to operate to insert the loadable module into an operating system address space by piping the loadable module to the insmod process.<br>
18.	In a computer system including an input device enabling the input<br>
of data, a memory for storing data, and a processor, communicatively associated<br>
with the input device and the memory, configured to run an operating system, a<br>
method for dynamically linking application source code created by a user into a<br>
running operating system kernel, said method comprising the steps of:<br><br>
constructing a loadable module from the application source code created by the user and storing said loadable module in the memory;<br>
creating an executable program, wherein the executable program is configured to transparently load the loadable module into the running operating system kernel, and storing said executable program in the memory;<br>
configuring the processor to execute the executable program, thereby loading the loadable module into the running operating system kernel; and<br>
further configuring the processor to send a termination signal to the executable program, thereby unloading the loadable module from the running operating system kernel.<br>
19.	The method of claim 18, wherein the application source code is an ordinary application program.<br>
20.	The method of claim 18, wherein the step of constructing the loadable module from the application source code consists essentially of executing a pre-defined makefile.<br>
21.	The method of claim 18, further comprising the step of providing a makefile to the user, wherein the user performs the step of constructing the loadable module by executing the makefile after the user has created the application source code.<br>
22.	The method of claim 18, further comprising the step of providing the user with a library comprising object code, wherein the step of constructing the loadable module from the application source code comprises the steps of compiling the application source code into object code; linking the object code with object code from the library to produce a linked object module; and converting the linked object module into a C code array.<br>
23.	The method of claim 22, wherein the step of constructing the loadable module further comprises the step of compiling the C code array to produce an object file.<br><br>
24.	The method of claim 23, further comprising the step of providing the user with a second library comprising object code, wherein the step of creating the executable program comprises the steps of linking the object file with object code from the second library.<br>
25.	The method of claim 22, wherein the library includes one or more routines to create kernel/user channels.<br>
26.	The method of claim 22, wherein the library includes one or more routines to create a thread to execute the executable program.<br>
27.	The method of claim 26, wherein the library includes one or more routines for freeing resources and unloading the loadable module when the thread completes.<br>
28.	The method of claim 22, wherein the library includes one or more routines for (a) copying in arguments; (b) creating communication channels that connect the loadable module to the executable program; (c) requesting a block of memory from the operating system and storing a structure therein that describes the application source code; and (d) putting data describing the application code on a task list.<br>
29.	The method of claim 28, wherein the environment library further includes one or more routines for (a) removing said data describing the application source code from the task list; (b) closing said communication channels that connect the loadable module to the executable program; and (c) freeing the block of memory that was requested from the operating system.<br>
30.	The method of claim 18, wherein the executable program is configured to set up input/output channels.<br>
31.	The method of claim 18, wherein the executable program is configured to execute a utility for installing the loadable module into the running operating system kernel.<br><br>
32.	The method of claim 31, wherein the utility for installing the loadable module into the running operating system kernel is the insmod program.<br>
33.	The method of claim 31, wherein the step of inserting the loadable module into an operating system address space includes the step of creating a child process, wherein the child process replaces its image with the insmod process image.<br>
34.	The method of claim 33, wherein the step of inserting the loadable module into an operating system address space further includes the step of piping the loadable module to the insmod process.<br>
Dated this 7th day of April, 2006.<br>
FOR FINITE STATE MACHINE LABS, INC. By their Agent<br>
(GIRISH VIJAYANAND SHETH) KRISHNA &amp; SAURASTRI<br><br>
i	I  ;<br>
ABSTRACT<br>
The present invention provides systems and methods for dynamically linking modules into a running operating system kernel. Systems and methods described herein have the following advantages: (1) they permit an application programmer to write, compile, execute, and terminate application code that is to be loaded into a kernel as if the application code was an ordinary application program, (2) they allow a standard programming environment to be used to encapsulate application software in a familiar environment, and (3) they permit automatic cleanup of errors and freeing of program resources when the application terminates.<br></cort></cort></rtl-mainhelper.h></rtl-conf.h></termios.h></sys></sys></sys></sys></sys></errno.h></unistd.h></signal.h></fcntl.h></stdarg.h></stdio.h></rtl_module.h></cort></sys></sys></posix></posix></rtl-unistd.h></rtl-posixio.h></rtl-sched.h></rtl-printf.h></rtl-mainhelper.h></rtl-gpos.h></cort></stdio.h></sys></rtl-_fifo.h></rtl-_unistd.h></rtl-_mainhelper.h></rtl-_posixio.h></rtl-_sched.h></rtl-_pthread.h></rtl-printf.h></rtl-gpos.h></rtl-conf.h></unistd.h></pthread.h></stdio.h></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtYWJzdHJhY3QoMTAtNi0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-abstract(10-6-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtYWJzdHJhY3QoMTQtNi0yMDA4KS5kb2M=" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-abstract(14-6-2008).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtYWJzdHJhY3QtMS5qcGc=" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-abstract-1.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtY2FuY2VsbGVkIHBhZ2UoMTAtNi0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-cancelled page(10-6-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtY2xhaW0oZ3JhbnRlZCktKDEwLTYtMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-claim(granted)-(10-6-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtY2xhaW0oZ3JhbnRlZCktKDE0LTYtMjAwOCkuZG9j" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-claim(granted)-(14-6-2008).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtY29ycmVzcG9uZGFuY2UtcG8ucGRm" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-correspondance-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtY29ycmVzcG9uZGFuY2UtcmVjZWl2ZWQucGRm" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-correspondance-received.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtY29ycmVzcG9uZGVuY2UoMTEtNi0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-correspondence(11-6-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtY29ycmVzcG9uZGVuY2UoaXBvKS0oOS03LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-correspondence(ipo)-(9-7-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZHJhd2luZygxMC02LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-drawing(10-6-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybSAxKDctNC0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form 1(7-4-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybSAxMyg3LTQtMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form 13(7-4-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybSAxOCgyNy03LTIwMDYpLnBkZg==" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form 18(27-7-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybSAyKGdyYW50ZWQpLSgxMC02LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form 2(granted)-(10-6-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybSAyKGdyYW50ZWQpLSgxNC02LTIwMDgpLmRvYw==" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form 2(granted)-(14-6-2008).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybSAzKDExLTYtMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form 3(11-6-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybSAzKDctNC0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form 3(7-4-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybSA1KDctNC0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form 5(7-4-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybSA2KDI1LTMtMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form 6(25-3-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybS0xMy5wZGY=" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybS0yLmRvYw==" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form-2.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybS0yLnBkZg==" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtZm9ybS1wY3QtaXNhLTIxMCgxMC02LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-form-pct-isa-210(10-6-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NDAyLW11bW5wLTIwMDYtcG93ZXIgb2YgYXR0b3JuZXkoMjktNi0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">402-mumnp-2006-power of attorney(29-6-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="222196-continuous-process-for-preparing-mononitrotoluenes.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="222198-continuously-variable-transmission-apparatus.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>222197</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>402/MUMNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>39/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>26-Sep-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>28-Jul-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>07-Apr-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>WIND RIVER SYSTEMS, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>500 WIND RIVER WAY, ALAMEDA, CA 94501, U.S.A.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>YODAIKEN, VICTOR J.</td>
											<td>914 PAISANO DRIVE, SOCORRO, NEW MEXICO 87801, USA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>Dougan, Cort</td>
											<td>115-D Abeyta Avenue, P.O. Box, Socorrow, New Mexico 87801,U.S.A.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F9/44</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2004/031371</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-09-27</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/670,802</td>
									<td>2003-09-26</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/222197-systems-and-methods-for-dynamically-linking-application-software-into-a-running-operating-system-kernel by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:48:17 GMT -->
</html>
