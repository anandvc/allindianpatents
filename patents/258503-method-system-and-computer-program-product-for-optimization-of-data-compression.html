<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/258503-method-system-and-computer-program-product-for-optimization-of-data-compression by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:22:09 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 258503:&quot;METHOD, SYSTEM AND COMPUTER PROGRAM PRODUCT FOR OPTIMIZATION OF DATA COMPRESSION&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;METHOD, SYSTEM AND COMPUTER PROGRAM PRODUCT FOR OPTIMIZATION OF DATA COMPRESSION&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A sequence of n coefficients is compressed by determining a cost-determined sequence of n coefficient indices represented by a cost-determined sequence of (run, index derivative) pairs under a given quantization table and run-index derivative coding distribution, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (i) each index in the corresponding sequence of coefficient indices is a digital number, (ii) the corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive indices of the special value, and an index-based value derived from a value of the index following the number of consecutive indices of the special value, the method comprising the steps of (a) operating the processor to use the given quantization table and run-index derivative coding distribution to formulate a cost function for a plurality of possible sequences of (run, index derivative) pairs; (b) operating the processor to apply the cost function to each possible sequence in the plurality of possible sequences of (run, index derivative) pairs to determine an associated cost; and, (c) operating the processor to select the cost-determined sequence of (run, index derivative) pairs from the plurality of possible sequences of (run, index derivative) pairs based on the associated cost of each of the plurality of possible sequences of (run, index derivative) pairs; (d) operating the processor to encode the selected cost-determined sequence of (run, size, ID) triples using Huffman coding.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>Title; METHOD, SYSTEM AND COMPUTER PROGRAM PRODUCT FOR OPTIMIZATION OF DATA COMPRESSION<br>
Related Application: This application claims the benefit of U.S. provisional application No. 60/588,380, entitled JOINT OPTIMIZATION OF RUN-LENGTH CODING, CONTEXT-BASED ARITHMETIC CODING AND QUANTIZATION STEP SIZES, which was filed by En-hui Yang and Longji Wang on July 16, 2004, and the entire content of which is hereby incorporated by reference and U.S. provisional application No. 60/587,555, entitled JOINT OPTIMIZATION OF RUN-LENGTH CODING, HUFFMAN CODING AND QUANTIZATION TABLE WITH COMPLETE BASELINE JPEG DECODER COMPATIBILITY, which was filed by En-hui Yang and Longji Wang on July 14, 2004, and the entire content of which is hereby incorporated by reference. Field Of The Invention<br>
[0001]	The present invention relates generally to data compression,<br>
and more specifically relates to the joint optimization of quantization step sizes, quantized coefficients and entropy coding based on a run-index derivative coding distribution.<br>
Background Of The Invention<br>
[0002]	JPEG as described in W. Pennebaker and J. Mitchell, "JPEG<br>
still image data compression standard," Kluwer Academic Publishers, 1993, (hereinafter "reference [1]"), G. Wallace, 'The JPEG still-image compression standard," Commun. ACM, vol. 34, pp. 30-44, Apr. 1991 (hereinafter "reference [2]"), is a popular DCT-based still image compression standard. It has spurred a wide-ranging usage of JPEG format such as on the World-Wide-Web and in digital cameras.<br>
[0003]	The popularity of the JPEG coding system has motivated the<br>
study of JPEG optimization schemes - see for example J. Huang and T. Meng, "Optimal quantizer step sizes for transform coders," in Proc. IEEE Int. Conf. Acoustics, Speech and Signal Processing, pp. 2621-2624, Apr. 1991 (hereinafter "reference [3]"), S. Wu and A. Gersho, "Rate-constrained picture-adaptive quantization for JPEG baseline coders," in Proc. IEEE Int. Conf.<br>
Acoustics, Speech and Signal Processing, vol. 5, pp. 389-392, 1993 (hereinafter "reference [4]"), V. Ratnakar and M. Livny, "RD-OPT: An efficient algorithm for optimizing DCT quantization tables", in Proc. Data Compression Conf... pp. 332-341,1995 (hereinafter "reference [5]") and V. Ratnakar and M. Livny, "An efficient algorithm for optimizing DCT quantization," IEEE Trans. Image Processing, vol. 9 pp. 267-270, Feb. 2000 (hereinafter "reference [6]"), K. Ramchandran and M. Vetterli, "Rate-distortion optimal fast thresholding with complete JPEG/MPEG decoder compatibility," IEEE Trans Image Processing, vol. 3, pp. 700-704, Sept. 1994 (hereinafter "reference [7]"), M. Crouse and K. Ramchandran, "Joint thresholding and quantizer selection for decoder-compatible baseline JPEG," in Proc. IEEE Int. Conf. Acoustics, Speech and Signal Processing, pp. 2331-2334, 1995 (hereinafter "reference [8]") and M. Crouse and K. Ramchandran, "Joint thresholding and quantizer selection for transform image coding: Entropy constrained analysis and applications to baseline JPEG," IEEE Trans. Image Processing, vol. 6, pp. 285-297, Feb. 1997 (hereinafter "reference [9]"). The schemes described in all of these references remain faithful to the JPEG syntax. Since such schemes only optimize the JPEG encoders without changing the standard JPEG decoders, they can not only further reduce the size of JPEG compressed images, but also have the advantage of being easily deployable. This unique feature makes them attractive in applications where the receiving terminals are not sophisticated to support new decoders, such as in wireless communications.<br>
Quantization table optimization<br>
[0004]	JPEG's quantization step sizes largely determine the rate-<br>
distortion tradeoff in a JPEG compressed image. However, using the default quantization tables is suboptimal since these tables are image-independent. Therefore, the purpose of any quantization table optimization scheme is to obtain an efficient, image-adaptive quantization table for each image component. The problem of quantization table optimization can be formulated easily as follows. (Without loss of generality we only consider one image<br>
component in the following discussion.) Given an input image with a target bit rateRbmlget, one wants to find a set of quantization step sizes {Qk: fc-Q,...,63}<br>
to minimize the overall distortion<br>
subject to the bit rate constraint<br>
where Num_Blk is the number of blocks, D^QJ is the distortion of the kth DOT coefficient in the n'h block if it is quantized with the step size Qk, and<br>
/^(qj	Q<a is the number of bits generated in coding nth block with></a>
quantization table<br>
[0005]	Since JPEG uses zero run-length coding, which combines zero<br>
coefficient indices from different frequency bands into one symbol, the bit rate is not simply the sum of bits contributed by coding each individual coefficient index. Therefore, it is difficult to obtain an optimal solution to (1) and (2) with classical bit allocation techniques. Huang and Meng - see reference [3] -proposed a gradient descent technique to solve for a locally optimal solution to the quantization table design problem based on the assumption that the probability distributions of the DOT coefficients are Laplacian. A greedy, steepest-descent optimization scheme was proposed later which, makes no assumptions on the probability distribution of the DOT coefficients - see reference [4]. Starting with an initial quantization table of large step sizes, corresponding to low bit rate and high distortion, their algorithm decreases the step size in one entry of the quantization table at a time until a target bit rate is reached. In each iteration, they try to update the quantization table in such a way that the ratio of decrease in distortion to increase in bit rate is maximized over all possible reduced step size values for one entry of the quantization<br>
table. Mathematically, their algorithm seeks the values of k and q that solve the following maximization problem<br>
where AD.., and A/^^, are respectively the change in distortion and that<br>
in overall bit rate when the kth entry of the quantization table, Qk, is replaced by q. These increments can be calculated by<br>
The iteration is repeated until ^R^^-^Q^'-^Q^^e, where e is the<br>
convergence criterion specified by the user.<br>
[0006]	Both   algorithms   aforementioned   are   very   computationally<br>
expensive. Ratnakar and Livny - see references [5] and [6] - proposed a comparatively efficient algorithm to construct the quantization table based on the DOT coefficient distribution statistics without repeating the entire compression-decompression cycle. They employed a dynamic programming approach to optimizing quantization tables over a wide range of rates and distortions and achieved a similar performance as the scheme in reference [4]. Optimal thresholding<br>
[0007]	In JPEG, the same quantization table must be applied to every<br>
image block. This is also true even when an image-adaptive quantization table is used. Thus, JPEG quantization lacks local adaptivity, indicating the potential gain remains from exploiting discrepancies between a particular<br>
block's characteristics and the average block statistics. This is the motivation for the optimal fast thresholding algorithm of- see reference [7], which drops the less significant coefficient indices in the R-D sense. Mathematically, it minimizes the distortion, for a fixed quantizer, between the original image X<br>
~	A<br>
and the thresholded image X given the quantized image X subject to a bit budget constraint, i.e.,<br>
 [0008]	An equivalent unconstrained problem is to minimize<br>
 [0009]	A dynamic programming algorithm is employed to solve the<br>
above optimization problem (7) recursively. It calculates J'k for each Osfrs;63, and then finds k* that minimizes this 7^, i.e., finding the best nonzero coefficient to end the scan within each block independently. The reader is referred to reference [7] for details. Since only the less significant coefficient indices can be changed, the optimal fast thresholding algorithm -see reference [7] - does not address the full optimization of the coefficient indices with JPEG decoder compatibility.<br>
Joint thresholding and quantizer selection<br>
[0010]	Since an adaptive quantizer selection scheme exploits image-<br>
wide statistics, while the thresholding algorithm exploits block-level statistics, their operations are nearly "orthogonal". This indicates that it is beneficial to bind them together. The Huffman table is another free parameter left to a JPEG encoder. Therefore, Grouse and Ramchandran - see references [8] and [9] -- proposed a joint optimization scheme over these three parameters, where Q is the quantization table, H is the Huffman table incorporated, and T is a set of binary thresholding tags that signal whether to threshold a coefficient index. The constrained minimization problem of (8) is converted into an unconstrained problem by the Lagrange multiplier as<br><br>
[0011]	Then, they proposed an algorithm that iteratively chooses each<br>
of Q,T,H to minimize the Lagrangian cost (9) given that the other parameters are fixed.<br>
JPEG Limitations<br>
[0012]	The foregoing discussion has focused on optimization within the<br>
confines of JPEG syntax. However, given the JPEG syntax, the R-D performance a JPEG optimization method can improve is limited. Part of the limitation comes from the poor context modeling used by a JPEG coder, which fails to take full advantage of the pixel correlation existing in both space and frequency domains. Consequently, context-based arithmetic coding is proposed in the literature to replace the Huffman coding used in JPEG for better R-D performance.<br>
Summary Of The Invention<br>
[0013]	In accordance with an aspect of the present invention, there is<br>
provided a method of compressing a sequence of n coefficients by determining a cost-determined sequence of n coefficient indices represented by a cost-determined sequence of (run, index derivative) pairs under a given quantization table and run-index derivative coding distribution, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (i) each index in the corresponding sequence of coefficient indices is a digital number, (ii) the corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive indices of the special value, and an index-based value<br>
derived from a value of the index following the number of consecutive indices of the special value. The method comprises the steps of: (a) using the given quantization table and run-index derivative coding distribution to formulate a cost function for a plurality of possible sequences of (run, index derivative) pairs; (b) applying the cost function to each possible sequence in the plurality of possible sequences of (run, index derivative) pairs to determine an associated cost; and, (c) selecting the cost-determined sequence of (run, index derivative) pairs from the plurality of possible sequences of (run, index derivative) pairs based on the associated cost of each of the plurality of possible sequences of (run, index derivative) pairs; and encoding the corresponding selected cost-determined sequence of (run, index derivative) pairs using entropy coding based on a run-index derivative coding distribution.<br>
[0014]	In accordance with a second aspect of the present invention,<br>
there is provided a method of compressing a sequence of n coefficients by determining an output quantization table, a cost-determined sequence of n coefficient indices represented by a cost-determined sequence of (run, index derivative) pairs, and a run-index derivative coding distribution, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (!) each index in the corresponding sequence of coefficient indices is a digital number, (ii) the corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive indices of the special value, and an index-based value (derived from a value of the index following the number of consecutive indices of the special value, and wherein a sequence of n coefficient indices, together with a quantization table, determines a sequence of n soft-decision quantized coefficients. The method comprises the steps of: (a) selecting a 0th quantization table; (b) selecting a 0th run-index derivative coding distribution; (c) setting a counter t equal to 0; (d) using a tth quantization table and run-index derivative coding distribution to formulate a tth cost function for a tth plurality of possible sequences of (run, index derivative) pairs; (e) applying the tth cost function to each possible sequence in the tth plurality of possible<br>
sequences of (run, index derivative) pairs to determine a tth associated cost; (f) selecting a tth cost-determined sequence of (run, index derivative) pairs from the tth plurality of possible sequences of (run, index derivative) pairs based on the tth associated cost; (g) if the tth cost-determined sequence of (run, index derivative) pairs together with the tth quantization table and run-index derivative coding distribution, meets a selection criterion, selecting the tth cost-determined sequence of (run, index derivative) pairs as the cost-determined sequence of n coefficient indices and the tth quantization table as the output quantization table, otherwise determining a (t+1)m quantization table and run-index derivative coding distribution from the tth cost-determined sequence of (run, index derivative) pairs, increasing t by one, and returning to step (d); and (h) encoding the corresponding selected cost-determined sequence of (run, index derivative) pairs using entropy coding based on tth run-index derivative coding distribution.<br>
[0015]	In accordance with a third aspect of the present invention, there<br>
is provided a method of compressing a sequence of sequences of n coefficients by jointly determining an output quantization table, an output run-index derivative distribution, and, for each sequence of n coefficients in the sequence of sequences of n coefficients, a final cost-determined sequence of coefficient indices represented by a final cost-determined sequence of (run, index derivative) pairs, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (i) each index in the corresponding sequence of coefficient indices is a digital number, (ii) the corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive indices of the special value, and an index-based value derived from a value of the index following the number of consecutive indices of the special value, and wherein a sequence of coefficient indices together with a quantization table determines a sequence of n soft-decision quantized coefficients. The method comprises: (a) selecting a 0th quantization table; (b) selecting a 0th run-index derivative coding distribution; (c) setting a counter t equal to 0; (d) for each<br>
sequence of n coefficients in the sequence of sequences of n coefficients, (i) using a tth quantization table and run-index derivative coding distribution to formulate a tth cost function for an associated tth plurality of possible sequences of (run, index derivative) pairs; (ii) applying the cost function to each possible sequence in the associated tth plurality of possible sequences of (run, index derivative) pairs to determine an associated cost; (iii) selecting an associated tth cost-determined sequence of (run, index derivative) pairs from the associated tth plurality of possible sequences of (run, index derivative) pairs based on the associated cost; (e) after step (d), applying an aggregate cost function to the tth associated cost-determined sequence of (run, index derivative) pairs for each sequence of n coefficients in the sequence of sequences of n coefficients, to determine a tth aggregate cost; (f) if the tth aggregate cost meets a selection criterion, selecting the tth quantization table and run-index derivative coding distribution as the output quantization table and the output run-index derivative coding distribution, and, for each sequence of n coefficients in the sequence of sequences of n coefficients, the final cost-determined sequence of coefficient indices represented by the final cost-determined sequence of (run, index derivative) pairs as the associated tth sequence of (run, index derivative) pairs; otherwise determining a (t+1)th quantization table and run-index derivative coding<br>
distribution from the selected sequence of the tth cost-determined sequences<br>
/<br>
of (run, index derivative) pairs, increasing t by one, and returning to step (d); and (g) encoding the corresponding selected sequences of (run, index derivative) pairs using Huffman coding.<br>
[0016]	In accordance with a fourth aspect of the present invention,<br>
there is provided a data processing system for compressing a sequence of n coefficients by determining a cost-determined sequence of n coefficient indices represented by a cost-determined sequence of (run, index derivative) pairs under a given quantization table and run-index derivative coding distribution, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (i) each index in the corresponding sequence of coefficient indices is a digital number, (ii) the<br>
corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive indices of the special value, and an index-based value derived from a value of the index following the number of consecutive indices of the special value. The data processing system comprises: (a) initialization means for using the given quantization table and run-index derivative coding distribution to formulate a cost function for a plurality of possible sequences of (run, index derivative) pairs; and, (b) calculation means for applying the cost function to each possible sequence in the plurality of possible sequences of (run, index derivative) pairs to determine an associated cost, and for selecting the cost-determined sequence of (run, index derivative) pairs from the plurality of possible sequences of (run, index derivative) pairs based on the associated cost of each of the plurality of possible sequences of (run, index derivative) pairs; and encoding the corresponding selected cost-determined sequence of (run, index derivative) pairs using entropy coding based on a run-index derivative coding distribution.<br>
[0017]	In accordance with a fifth aspect of the present invention, there<br>
is provided a data processing system for compressing a sequence of n coefficients by determining an output quantization table, a cost-determined sequence of n coefficient indices represented by a cost-determined sequence of (run, index derivative) pairs, and a run-index derivative coding distribution, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (i) each index in the corresponding sequence of coefficient indices is a digital number, (ii) the corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive indices of the special value, and an index-based value (derived from a value of the index following the number of consecutive indices of the special value, and wherein a sequence of n coefficient indices, together with a quantization table, determines a sequence of n soft-decision quantized coefficients. The data processing system comprises: (a) initialization means for selecting a 0th quantization table<br>
and a Oth run-index derivative coding distribution, and setting a counter t equal to 0; (b) calculation means for (i) using a tth quantization table and run-index derivative coding distribution to formulate a tth cost function for a tth plurality of possible sequences of (run, index derivative) pairs; (ii) applying the tth cost function to each possible sequence in the tth plurality of possible sequences of (run, index derivative) pairs to determine a tth associated cost; (iii) selecting a tth cost-determined sequence of (run, index derivative) pairs from the tth plurality of possible sequences of (run, index derivative) pairs based on the tth associated cost; (iv) if the tth cost-determined sequence of (run, index derivative) pairs together with the tth quantization table and run-index derivative coding distribution, meets a selection criterion, selecting the tth cost-determined sequence of (run, index derivative) pairs as the* cost-determined sequence of n coefficient indices and the tth quantization table as the output quantization table, otherwise determining a (t+1)th quantization table and run-index derivative coding distribution from the tth cost-determined sequence of (run, index derivative) pairs, increasing t by one, and returning to step (i); and (v) encoding the corresponding selected cost-determined sequence of (run, index derivative) pairs using entropy coding based on tth run-index derivative coding distribution.<br>
[0018]	In accordance with a sixth aspect of the present invention, there<br>
is provided a data processing system for compressing a sequence of sequences of n coefficients by jointly determining an output quantization table, an output run-index derivative distribution, and, for each sequence of n coefficients in the sequence of sequences of n coefficients, a final cost-determined sequence of coefficient indices represented by a final cost-determined sequence of (run, index derivative) pairs, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (i) each index in the corresponding sequence of coefficient indices is a digital number, (ii) the corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive indices of the special value, and an index-based value<br>
derived from a value of the index following the number of consecutive indices of the special value, and wherein a sequence of coefficient indices together with a quantization table determines a sequence of n soft-decision quantized coefficients. The data processing system comprises: (a) initialization means for selecting a Oth quantization table, selecting a Oth run-index derivative coding distribution and setting a counter t equal to 0; (b) calculation means for, for each sequence of n coefficients in the sequence of sequences of n coefficients, (i) using a t«i quantization table and run-index derivative coding distribution to formulate a tth cost function for an associated tth plurality of possible sequences of (run, index derivative) pairs; (ii) applying the cost function to each possible sequence in the associated tth plurality of possible sequences of (run, index derivative) pairs to determine an associated cost; (iii) selecting an associated tth cost-determined sequence of (run, index derivative) pairs from the associated tth plurality of possible sequences of (run, index derivative) pairs based on the associated cost; (iv) after steps (!) to (iii), applying an aggregate cost function to the tth associated cost-determined sequence of (run, index derivative) pairs for each sequence of n coefficients in the sequence of sequences of n coefficients, to determine a tth aggregate cost; (v) if the tth aggregate cost meets a selection criterion, selecting the tth quantization table and run-index derivative coding distribution as the output quantization table and the output run-index derivative coding distribution, and, for each sequence of n coefficients in the sequence of sequences of n coefficients, the final cost-determined sequence of coefficient indices represented by the final cost-determined sequence of (run, index derivative) pairs as the associated tth sequence of (run, index derivative) pairs; otherwise determining a (t+1)th quantization table and run-index derivative coding distribution from the selected sequence of the tth cost-determined sequences of (run, index derivative) pairs, increasing t by one, and returning to step (i); and (vi) encoding the corresponding selected sequences of (run, index derivative) pairs using Huffman coding.<br>
[0019]	In accordance with a seventh aspect of the present invention,<br>
there is provided a computer program product for use on a computer system<br>
to compress a sequence of n coefficients by determining a cost-determined sequence of n coefficient indices represented by a cost-determined sequence of (run, index derivative) pairs under a given quantization table and run-index derivative coding distribution, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (!) each index in the corresponding sequence of coefficient indices is a digital number, (ii) the corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive indices of the special value, and an index-based value derived from a value of the index following the number of consecutive indices of the special value. The computer program product comprises a recording medium, and means recorded on the recording medium for instructing the computer system to perform the steps of (a) using the given quantization table and run-index derivative coding distribution to formulate a cost function for a plurality of possible sequences of (run, index derivative) pairs; (b) applying the cost function to each possible sequence in the plurality of possible sequences of (run, index derivative) pairs to determine an associated cost; and, (c) selecting the cost-determined sequence of (run, index derivative) pairs from the plurality of possible sequences of (run, index derivative) pairs based on the associated cost of each of the plurality of possible sequences of (run, index derivative) pairs; and encoding the corresponding selected cost-determined sequence of (run, index derivative) pairs using entropy coding based on a run-index derivative coding distribution.<br>
[0020]	In accordance with a eighth aspect of the present invention,<br>
there is provided a computer program product for use on a computer system to compress a sequence of n coefficients by determining an output quantization table, a cost-determined sequence of n coefficient indices represented by a cost-determined sequence of (run, index derivative) pairs, and a run-index derivative coding distribution, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (i) each index in the corresponding sequence of coefficient indices is<br>
a digital number, (ii) the corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive indices of the special value, and an index-based value (derived from a value of the index following the number of consecutive indices of the special value, and wherein a sequence of n coefficient indices, together with a quantization table, determines a sequence of n soft-decision quantized coefficients. The computer program product comprising a recording medium and means recorded on the recording medium to instruct the computer system to perform the steps of (a) selecting a 0th quantization table; (b) selecting a Oth run-index derivative coding distribution; (c) setting a counter t equal to 0; (d) using a tth quantization table and run-index derivative coding distribution to formulate a tth cost function for a tth plurality of possible sequences of (run, index derivative) pairs; (e) applying the tth cost function to each possible sequence in the tth plurality of possible sequences of (run, index derivative) pairs to determine a tth associated cost; (f) selecting a tth cost-determined sequence of (run, index derivative) pairs from the t«i plurality of possible sequences of (run, index derivative) pairs based on the tth associated cost; (g) if the tth cost-determined sequence of (run, index derivative) pairs together with the tth quantization table and run-index derivative coding distribution, meets a selection criterion, selecting the tth cost-determined sequence of (run, index derivative) pairs as the cost-determined sequence of n coefficient indices and the tth quantization table as the output quantization table, otherwise determining a (t+1)th quantization table and run-index derivative coding distribution from the t^ cost-determined sequence of (run, index derivative) pairs, increasing t by one, and returning to step (d); and (h) encoding the corresponding selected cost-determined sequence of (run, index derivative) pairs using entropy coding based on tth run-index derivative coding distribution.<br>
[0021]	In accordance with a ninth aspect of the present invention, there<br>
is provided a computer program product for use on a computer system to compress a sequence of sequences of n coefficients by jointly determining an<br>
output quantization table, an output run-index derivative distribution, and, for each sequence of n coefficients in the sequence of sequences of n coefficients, a final cost-determined sequence of coefficient indices represented by a final cost-determined sequence of (run, index derivative) pairs, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (i) each index in the corresponding sequence of coefficient indices is a digital number, (ii) the corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive indices of the special value, and an index-based value derived from a value of the index following the number of consecutive indices of the special value, and wherein a sequence of coefficient indices together with a quantization table determines a sequence of n soft-decision quantized coefficients. The computer program product comprising a recording medium and means recorded on the recording medium to instruct the computer system to perform the steps of (a) selecting a Oth quantization table; (b) selecting a Oth run-index derivative coding distribution; (c) setting a counter t equal to 0; (d) for each sequence of n coefficients in the sequence of sequences of n coefficients, (i) using a tth quantization table and run-index derivative coding distribution to formulate a tth cost function for an associated tth plurality of possible sequences of (run, index derivative) pairs; (ii) applying the cost function to each possible sequence in the associated tth plurality of possible sequences of (run, index derivative) pairs to determine an associated cost; (iii) selecting an associated tth cost-determined sequence of (run, index derivative) pairs from the associated tth plurality of possible sequences of (run, index derivative) pairs based on the associated cost; (e) after step (d), applying an aggregate cost function to the tth associated cost-determined sequence of (run, index derivative) pairs for each sequence of n coefficients in the sequence of sequences of n coefficients, to determine a tth aggregate cost; (f) if the tth aggregate cost meets a selection criterion, selecting the tth quantization table and run-index derivative coding distribution as the output quantization table<br>
and the output run-index derivative coding distribution, and, for each sequence of n coefficients in the sequence of sequences of n coefficients, the final cost-determined sequence of coefficient indices represented by the final cost-determined sequence of (run, index derivative) pairs as the associated tth sequence of (run, index derivative) pairs; otherwise determining a (t+1)tn quantization table and run-index derivative coding distribution from the selected sequence of the tth cost-determined sequences of (run, index derivative) pairs, increasing t by one, and returning to step (d); and (g) encoding the corresponding selected sequences of (run, index derivative) pairs using Huffman coding.<br>
Brief Description Of The Drawings<br>
[0022]	A detailed description of the preferred embodiments is provided<br>
herein below with reference to the following drawings, in which:<br>
[0023]	Figure 1, in a block diagram, illustrates a JPEG encoder;<br>
[0024]	Figure 2, in a block diagram, illustrates joint optimization of<br>
quantization, run-length coding and Huffman coding in accordance with an aspect of the present invention;<br>
[0025]	Figure 3 illustrates a directed graph for representing different<br>
possible coefficient indices (or, equivalently, their run-size pairs) in accordance with an aspect of the present invention;<br>
[0026]	Figure 4 illustrates a sequence of connections and nodes from<br>
the graph of Figure 3;<br>
[0027]	Figure 5 illustrates a trellis structure for representing distinct<br>
values a DC index can take for a sequence of n coefficients in accordance with a further aspect of the present invention;<br>
[0028]	Figures 6a, 6b and 6c is pseudo-code illustrating a graph-based<br>
optimization method in accordance with an aspect of the invention;<br>
[0029]	Figure 7, in a flowchart, illustrates a process for jointly optimizing<br>
run-length coding, Huffman coding and quantization table in accordance with an aspect of the present invention;<br>
[0030]	Figure 8, in a flowchart, illustrates an initialization of an iterative<br>
process of the process of Figure 7;<br>
[0031]	Figure 9, in a flowchart, illustrates a process for determining an<br>
optimal path for a particular block in the process of Figure 7;<br>
[0032]	Figure 10, in a flowchart, illustrates a block initializing process<br>
invoked by the optimal path determination process of Figure 9;<br>
[0033]	Figure   11,   in   a  flowchart,   illustrates  a   incremental  cost<br>
calculating process invoked by the process of Figure 9;<br>
[0034]	Figure 12, in a flowchart, illustrates a process for updating a<br>
quantization table invoked by the process of Figure 7;<br>
[0035]	Figure 13, in a block diagram, illustrates a data processing<br>
system in accordance with an aspect of the present invention;<br>
[0036]	Figure 14,  in a graph, illustrates rate-distortion curves for<br>
different quantization tables;<br>
[0037]	Figure 15 is a graph showing rate-distortion curves reflecting a<br>
different number of iterations of an iterative joint optimization algorithm in accordance with an aspect of the invention;<br>
[0038]	Figure  16  plots rate-distortion  (PSNR)  curves of different<br>
configurations of optimization methods in accordance with different aspects of the present invention applied to a 512x512 Lena image;<br>
[0039]	Figure  17 plots rate-distortion  (PSNR) curves of different<br>
configurations of optimization methods in accordance with different aspects of the present invention applied to a 512x512 Barbara image;<br>
[0040]	Figure 18 plots the DC entropy rate vs. the DC distortion<br>
resulting from trellis-based DC optimization for a 512x512 Lena image in accordance with an aspect of the invention;<br>
[0041]	Figure 19, in a block diagram, illustrates a generic encoder that<br>
is not limited to JPEG syntax in accordance with an aspect of the invention;<br>
[0042]	Figure 20, in a block diagram, illustrates the generic encoder of<br>
Figure 19 applied to an uncompressed image;<br>
[0043]	Figure 21 illustrates a directed graph for representing different<br>
sequences of run-level pairs in accordance with a further aspect of the present invention;<br>
[0044]	Figures 22a to 22d list pseudo-code illustrating a graph-based<br>
optimization method in accordance with a further aspect of the invention;<br>
[0045]	Figure 23,  in a flowchart,  illustrates a process for jointly<br>
optimizing  the  run-length  coding,   context-based  arithmetic coding  and quantization step sizes in accordance with a further aspect of the invention;<br>
[0046]	Figure 24, in a flowchart, illustrates an initialization of an iterative<br>
process of the process of Figure 23;<br>
[0047]	Figure 25, in a flowchart, illustrates a process for determining an<br>
optimal path for a particular block in the process of Figure 23;<br>
[0048]	Figure 26, in a flowchart, illustrates a process of calculating a<br>
cost to a basic/regular state invoked in the flowchart of Figure 25;<br>
[0049]	Figure 27 illustrates a process for calculating the cost to an<br>
extended state invoked in the flowchart of Figure 25;<br>
[0050]	Figure 28, in a flowchart, illustrates a process for calculating a<br>
cost for a special transition designated in a step of the flowchart of Figure 25;<br>
[0051]	Figure 29, in a flowchart, illustrates a process for updating a<br>
quantization table invoked by the process of the flowchart of Figure 23;<br>
[0052]	Figure 30 plots rate-distortion curves of different configurations<br>
and optimization methods in accordance with further different aspects of the present invention applied to a 512x512 Barbara image;<br>
[0053]	Figure 31   plots rate-distortion  (PSNR) curves for different<br>
configurations of optimization methods in accordance with different aspects of the present invention applied to a 512x512 Barbara image given a scaled default quantization table; and,<br>
[0054]	Figure 32 plots rate-distortion (PSNR) curves for different<br>
configurations of optimization methods in accordance with different aspects of the present invention applied to a 512x512 Lena image given a scaled default quantization table.<br>
Detailed Description Of Aspects Of The Invention<br>
SECTION!: JOINT OPTIMIZATION OF RUN-LENGTH CODING, HUFFMAN CODING AND QUANTIZATION TABLE WITH COMPLETE BASELINE JPEG COMPATIBILITY<br>
[0055]	A JPEG encoder 20 executes three basic steps as shown in<br>
Figure 1. The encoder 20 first partitions an input image 22 into 8x8 blocks and then processes these 8x8 image blocks one by one in raster scan order (baseline JPEG). Each block is first transformed from the pixel domain to the DCT domain by an 8x8 DCT 24. The resulting DCT coefficients are then uniformly quantized using an 8x8 quantization table 26. The coefficient indices from the quantization 28 are then entropy coded in step 30 using zero run-length coding and Huffman coding. The JPEG syntax leaves the selection of the quantization step sizes and the Huffman codewords to the encoder provided the step sizes must be used to quantize all the blocks of an image. This framework offers significant opportunity to apply rate-distortion (R-D) consideration at the encoder 20 where the quantization tables 26 and Huffman tables 32 are two free parameters the encoder can optimize.<br>
[0056]	The third but somewhat hidden free parameter which the<br>
encoder can also optimize is the image data themselves. Depending on the stage where the image date are at during the whole JPEG encoding process, the image data take different forms as shown in Figure 2. Before hard decision quantization, they take the form of DCT coefficients 34; after hard decision quantization, they take the form of DCT indices 36, i.e., quantized<br>
DOT coefficients normalized by the used quantization step size; after zigzag sequencing and run-length coding, they take the form of run-size pairs followed by integers specifying the exact amplitude of DOT indices within respective categories - (run, size) codes and in-category indices 38. (For clarity, we shall refer to such integers as in-category indices.) Note that DCT indices, together with quantization step sizes, determine quantized DCT coefficients. Although the JPEG syntax allows the quantization tables to be customized at the encoder, typically some scaled versions of the example quantization tables given in the standard - see reference [1] - (called default tables) are used. The scaling of the default tables is suboptimal because the default tables are image-independent and the scaling is not image-adaptive either. Even with an image-adaptive quantization table, JPEG must apply the same table for every image block, indicating that potential gain remains from optimizing the coefficient indices, i.e., DCT indices. Note that hard decision quantization plus coefficient index optimization amounts to soft decision quantization. Since the coefficient indices can be equally represented as run-size pairs followed by in-category indices through run-length coding, we shall simply refer to coefficient index optimization as run-length coding optimization in parallel with step size and Huffman coding optimization. As described below, we not only propose a very neat, graph-based run-length code optimization scheme, but also present an iterative optimization scheme for jointly optimizing the run-length coding, Huffman coding and quantization step sizes as in steps 40,42 and 44, respectively, of Figure 2.<br>
Formal problem definition<br>
[0057]	We now formulate our joint optimization problem, where the<br>
minimization is done over all the three free parameters in the baseline JPEG. We only consider the optimization of AC coefficients in this section. The optimization of DC coefficients will be discussed below.<br>
[0058]	Given an input image /„ and a fixed quantization table Q in the<br>
JPEG encoding, the coefficient indices completely determine a sequence of run-size pairs followed by in-category indices for each 8x8 block through run-<br>
length coding, and vice versa. Our problem is posed as a constrained optimization over all possible sequences of run-size pairs (R, S) followed by in-category indices ID, all possible Huffman tables H, and all possible quantization tables Q<br><br>
where d[I0,(R,S,ID)Q] denotes the distortion between the original image /0 and the reconstructed image determined by (R,S,ID) and Q over all AC coefficients, and r[(R,S),H] denotes the compression rate for all AC<br>
coefficients resulting from the chosen sequence (R, S, ID) and the Huffman table H. In (10) and (11), respectively, rbudget and dbudgel are respectively the<br>
rate constraint and distortion constraint. With the help of the Lagrange multiplier, we may convert the rate-constrained problem or distortion constrained problem into the following unconstrained problem<br>
where the Lagrangian multiplier A is a fixed parameter that represents the tradeoff of rate for distortion, and /(A) is the Lagrangian cost. This type of<br>
optimization falls into the category of so-called fixed slope coding advocated in E.-h. Yang, Z. Zhang, and T. Berger, "Fixed slope universal lossy data compression," IEEE Trans. Inform. Theory, vol. 43, pp. 1465-1476, Sept. 1997 (hereinafter "reference [10]") and E.-h. Yang and Z. Zhang, "Variable-rate trellis source coding." IEEE Trans. Inform. Theory, vol. 45, pp. 586-608, Mar. 1999 (hereinafter "reference [11]").<br>
[0059]	It is informative to compare our joint optimization problem with<br>
the joint thresholding and quantizer selection - see references [8] and [9]. On one hand, both of them are an iterative process aiming to optimize the three parameters jointly. On the other hand, our scheme differs from that<br>
considered - see references [8] and [9] ~ in two distinct aspects. First, we consider the full optimization of the coefficient indices or the sequence (R,S,ID) instead of a partial optimization represented by dropping only<br>
insignificant coefficient indices as considered - see references [8] and [9]. As we shall see in the next subsection, it turns out that the full optimization has a very neat, computationally effective solution. This is in contrast with the partial optimization for which a relatively time-consuming and cumbersome solution was proposed - see references [7], [8] and [9]. Second, we do not apply any time-consuming quantizer selection schemes to find the R-D optimal step sizes in each iteration. Instead, we use the default quantization table as a starting point and then update the step sizes efficiently in each iteration for local optimization of the step sizes.<br>
Problem solutions<br>
[0060] The rate-distortion optimization problem (12) is a joint optimization of the distortion, rate, Huffman table, quantization table, and sequence (R,S,ID). To make the optimization problem tractable, we propose an iterative algorithm that chooses the sequence (R,S,ID), Huffman table, and<br>
quantization table iteratively to minimize the Lagrangian cost of (12), given that the other two parameters are fixed. Since a run-size probability distribution P completely determines a Huffman table, we use P to replace the Huffman table H in the optimization process. The iteration algorithm can be described as follows:<br>
1) Initialize a run-size distribution P0 from the given image 70 and a quantization table Q&gt;. The application of this pre-determined quantization table Q, to /0 is referred to as hard-quantization, in that quantization is image-independent. (As an example, the initial run-size distribution P0 could be the empirical distribution of the sequence of (run, size) pairs obtained from using a hard-decision quantizer given by<br>
the initial Q,to quantize the DOT coefficients of /„.) Set r«=0, and<br>
specify a tolerance e as the convergence criterion.<br>
2)	Fix Pt and Qt for any f*0. Find an optimal sequence (Rt,S,,IDt) that<br>
achieves the following minimum<br>
mta {/(A) - d[l0,(R,SJD)Q ] + A- r[(K,S),Pj} .<br>
Denote d[/0,te,S,,ID,)ft] + A- r[(*,,S,),P,] by /(A).<br>
3)	Fix (/?,,S,,/D,). Update Qt and Pr into Q,+1 andP,+1, respectively so that<br>
Q+1 and Pr+1 together achieve the following minimum<br>
where the above minimization is taken over all quantization tables Q and all run-size probability distributions P. Note that P,+1 can be selected as the empirical run-size distribution of (R,,S,}. 4) Repeat Steps 2) and 3) for t~ 0,1,2,... until /(A)-/'+1(A)se. Then output (*r+1,S,+1,/D,+1),Qm, and P,+1.<br>
[0061]	Since the Lagrangian cost function is non-increasing at each<br>
step, convergence is guaranteed. The core of the iteration algorithm is Step 2) and Step 3), i.e., finding the sequence (R,S,ID) to minimize the Lagrangian cost J(A) given Q andP, and updating the quantization step sizes with the new indices of the image. These two steps are addressed separately as follows.<br>
Graph-based run-length coding optimization<br>
[0062]	As mentioned above, JPEG quantization lacks local adaptivity<br>
even with an image-adaptive quantization table, which indicates that potential gain remains from the optimization of the coefficient indices themselves. This<br>
gain is exploited in Step 2). Optimal thresholding - see reference [7] - only considers a partial optimization of the coefficient indices, i.e., dropping less significant coefficients in the R-D sense. We propose an efficient graph-based optimal path searching algorithm to optimize the coefficient indices fully in the R-D sense. It can not only drop less significant coefficients, but also can change them from one category to another - even changing a zero coefficient to a small nonzero coefficient is possible if needed in the R-D sense. In other words, our graph-based optimal path searching algorithm finds the optimal coefficient indices (or equivalently, the optimal run-size pairs) among all possible coefficient indices (or equivalently, among all possible run-size pairs) to minimize the Lagrangian cost. Since given Q andP, the Lagrangian cost J(A) is block-wise additive, the minimization in Step 2) can be solved in a block by block manner. That is, the optimal sequence (R,S,ID] can be<br>
determined independently for every 8x8 image block. Thus, in the following, we limit our discussion to only one 8x8 image block.<br>
[0063]	Let us define a directed graph with 65 nodes (or states). As<br>
shown in Figure 3, the first 64 states, numbered as z-0,1,...63., correspond to the 64 coefficient indices of an 8x8 image block in zigzag order. The last state is a special state called the end state, and will be used to take care of EOB (end-of-block). Each state z(zs63) may have incoming connections from its<br>
previous 16 states j(j<i which correspond to the run r in an pair.></i>
(In JPEG syntax, R takes value from 0 to 15.) The end state may have incoming connections from all the other states with each connection from state i(i*62) representing the EOB code, i.e., code (0,0) after the i* coefficient. State 63 goes to the state end without EOB code. For a given state i(z'js63) and its predecessor i-r~l(0&amp;ral5), there are 10 parallel<br>
transitions between them which correspond to the size group, S, in an (R,s)<br>
pair. For simplicity, we only draw one transition in the graph shown in Figure 3; the complete graph needs the expansion of S. For each state i where i&gt;15, there is one more transition from state i-16 to i which corresponds to<br>
the pair (15, 0), i.e., ZRL (zero run length) code. We assign to each transition (r,s) from state i-r-1 to state i a cost which is defined as the incremental<br>
Lagrangian cost of going from state i-r-1 to state i when the i* DCT coefficient is quantized to size group s (i.e., the coefficient index needs s bits to represent its amplitude) and all the r DCT coefficients appearing immediately before the ith DCT coefficient are quantized to zero. Specifically, this incremental cost is equal to<br>
Where are the DCT coefficient, ZD,is the in-category index<br>
corresponding to the size group s that gives rise to the minimum distortion to C, among all in-category indices within the category specified by the size<br>
groups, and g, is the Ith quantization step size. Similarly, for the transition from state 62) to the end state, its cost is defined as<br>
No cost is assigned to the transition from state 63 to the end state.<br>
[0064]	It is not hard to see that with the above definitions, every<br>
sequence of run-size pairs of an 8x8 block corresponds to a path from state 0 to the end state with a Lagrangian cost. For example, the sequence of run-size pairs (0, 5), (4, 3), (15, 0), (9, 1), (0, 0) of a block corresponds to a path shown in Figure 4. On the other hand, not all paths from state 0 to the end state in the directed graph represent a legitimate sequence of run-size pairs of an 8x8 block. We shall call such paths illegitimate paths. For instance, the path consisting of a transition (0,5) from state 0 to state 1 followed by a transition (15,0) from state 1 to state 17 and a transition (0,0) from state 17 to the end state is an illegitimate path, and does not represent a legitimate sequence of run-size pairs of an 8x8 block. However, it is not hard to see that<br>
for any illegitimate path, there is always a legitimate path the total Lagrangian cost of which is strictly less than that of the illegitimate path. Therefore, the optimal path from state 0 to the end state with the minimum total Lagrangian cost among ALL possible paths including both legitimate paths and illegitimate paths is always a legitimate path. Furthermore, the optimal path, together with its corresponding in-category indices as determined in (13), achieves the minimum in Step 2) for any given Q, P and 8x8 block. As such, one can apply a fast dynamic programming algorithm to the whole directed graph to find the optimal sequence (R,S,ID) for the given 8x8 block. It should be pointed out<br>
that baseline JPEG syntax will not generate an (R, S) sequence ended by (15, 0) for an 8x8 block. Theoretically, the optimal (R, S) sequence found by our dynamic programming may end by (15,0) through state 63 even though it is very unlikely to occur in real applications (it might occur when the entropy rate of (15, 0) is less than the entropy rate of (0, 0)). However, an (R, S) sequence ended by (15, 0) through state 63 is a legitimate path and can be encoded/decoded correctly by baseline JPEG syntax.<br>
[0065]	A more elaborate step-by-step description of the algorithm<br>
follows. As an initialization, the algorithm pre-calculates A,-(-log2P(r,s) + s) for<br>
each run-size pair (r,s) based on the given run-size distribution P. It also<br>
recursively pre-calculates, for each state i, the distortion resulting from dropping the preceding 1 to 15 coefficients before the state and the remaining cost of ending the block at the state. The algorithm begins with state 0 (DC coefficient). The cost of dropping all AC coefficients is stored in 70. Then, one proceeds to state 1 (the first AC coefficient). There are ten paths to state 1 which all start from state 0. These ten paths correspond to the 10 size categories that the first AC index may fall into. The cost associated with each path is calculated using equation (13), where the first term in (13) is also pre-calculated, and IDt is determined as follows. For simplicity, we only consider<br>
positive indices here; negative indices are processed similarly by symmetry.<br>
/ Suppose ID, is the output of the hard-decision quantizer with step size qt in<br>
response to the input C,, and it falls into the category specified by s'. If s - J,<br>
i ID, is chosen as ID, since it results in the minimum distortion for C, in this<br>
size group. If s 
this largest number results in the minimum distortion in this group. Similarly, if s&gt;s', ID, is chosen as the smallest number in size group s. After the ten<br>
incremental costs have been computed out, we can find the minimum cost to state 1 from state 0 and record this minimum cost as well as the run-size pair (r,s) which results in this minimum to state 1. Then, the cost of dropping all coefficients from 2 to 63 is added to the minimum cost of state 1. This sum is stored in Jv which is the total minimum cost of this block when the first AC coefficient is the last nonzero coefficient to be sent. Proceeding to state 2, there are 110 paths to state 2 from state 0. Among them, ten paths go to state 2 from state 0 directly and 100 paths go to state 2 from state 0 through state 1 (10 times 10). The most efficient way of determining the best path that ends in state 2 is to use the dynamic programming algorithm. Since the minimum costs associated with ending at state 0 and state 1 are known, the job of finding the minimum cost path ending in state 2 is simply to find the minimum incremental costs of going from state 0 to state 2 and from state 1 to state 2. Add these two minimum incremental costs to the minimum costs of state 0 and 1 respectively; the smaller one between the two sums is the minimum cost of state 2. This minimum cost and the run-size pair (r,s) which results in<br>
this minimum cost are stored in state 2. Then, the cost of dropping all coefficients from 3 to 63 is added to the minimum cost of state 2. This sum is stored in J2, which is the total minimum cost of this block when the second AC coefficient is the last nonzero coefficient to be sent. Note that, if the minimum path to state 2 is from state 0 directly, the stored r in the stored run-size pair (r,s) of state 2 is 1, which means the first AC is quantized or forced to zero. If the minimum path to state 2 is from state 1, the stored r is 0, which means the first AC index is nonzero. The recursion continues to the third coefficient and so on until the last coefficient at position 63 is done. At this point, we<br>
compare the values of Jk,k -0,1,. ..63, and find the minimum value, say, /t.for some k*. By backtracking from k* with the help of the stored pairs (r,s) in each state, one can find the optimal path from state 0 to the end state with the minimum cost among all the possible paths, and hence the optimal sequence (R,S,ID) for the given 8x8 block. A pseudo-code of this algorithm is illustrated in Figures 6a, 6b and 6c.<br>
[0066]	The above procedure is a full dynamic programming method. To<br>
further reduce its computational complexity, we can modify it slightly. In particular, in practice, we do not have to compare the incremental costs among the 10 or 11 parallel transitions from one state to another state. Instead, it may be sufficient for us to compare only the incremental costs among the transitions associated with size group s-l, s, and 5+1, where s is the size group corresponding to the output of the given hard-decision quantizer. Transitions associated with other groups most likely result in larger incremental costs. We shall compare the complexity and performance difference of these two schemes in the experimental results described below.<br>
Optimal quantization table updating<br>
[0067]	To update the quantization step sizes in Step 3), we need to<br>
solve the following minimization problem<br>
since the compression rate does not depend on Q once (R,S,ID) is given, where /„ denotes the original input image to be compressed, and G-(^o»9i»-»fe) represents a quantization table. Let Cu denote the DCT coefficient of /„ at the ith position in the zigzag order of the J* block. The sequence (R,S,ID) determines DCT indices, i.e., quantized DCT coefficients normalized by the quantization step sizes. Let Ku denote the DCT index at the /* position in the zigzag order of the J* block obtained from (R,S,ID).<br>
Then the quantized DCT coefficient at the i* position in the zigzag order of the J* block is given by K^,. With help of Cu and K^,, we can rewrite<br>
where Num_Blk is the number of 8x8 blocks in the given image.<br>
[0068]	From (15), it follows that the minimization of rf[/0,(/?,5,ZD)fi] can<br>
be achieved by minimizing independently the inner summation of (15) for each 1 = 1,2,. ..,63. Our goal is to find a set of new quantization step size<br>
A<br>
 [0069]	Equation (16) can be written as<br><br>
[0070]	The minimization of these quadratic functions can be evaluated<br>
by taking the derivative of (17) with respect to q,. The minimum of (16) is obtained when<br>
The step sizes in Step 3) can be updated accordingly.<br>
Trellis-based DC optimization<br>
[0071]	In this subsection, we consider the joint optimization of the<br>
quantized DC coefficients with the quantization step size and Huffman table.<br>
In JPEG syntax, the quantized DC coefficients are coded differentially, using a one-dimensional predictor, which is the previous quantized DC value. Since the cost of encoding a quantized DC coefficient only depends on the previous quantized DC coefficient, a trellis can be used in the joint optimization.<br>
[0072]	Let us define a trellis with N stages, which correspond to the<br>
number of DC coefficients, i.e., the number of 8x8 blocks in a restart interval (the DC coefficient prediction is initialized to 0 at the beginning of each restart interval and each scan - see reference [1]). Each stage has M states, which correspond to the distinct values a DC index can take, and states in adjacent stages are fully connected, as shown in Figure 5. Every state in each stage is associated with a cost which is the minimum cost to this state from the initial state. The process of finding the optimal DC index sequence starts from stage 0 until stage N-l. At stage N-l, the state with the minimum cost is sorted out and the optimal path from stage 0 to stage N-l with the minimum cost is traced out backward, yielding the optimal DC index sequence.<br>
[0073]	A more elaborate step-by-step description  of the  process<br>
follows. Let x(ij) denote the j* state in stage / (0 <. i n j a m and v represent the dc index value corresponding to state x . let cost_mini denote minimum cost from initial state. costjnc incremental which is defined as></.>
5)	(19)<br>
where g0 is the quantization step size for DC coefficients, DC, is the /'" DC coefficient, 5 is the group category of the difference |KU)-v(z-l,/)| and p(s) is its probability among the 12 size categories (Os S&amp; 11). The cost associated with the initial state is set to zero. We start from stage 0. Since each state only has one incoming path, the cost to each state in stage 0 is the<br>
incremental cost from the initial state. Then, we proceed to stage 1 and start with state 0. There are M incoming paths to *(l,o) from x(q,j)(q*j * M-l).<br>
The  M  incremental costs (i.e.,  costjnc (o, 7,1,0)   are calculated using<br>
equation (19) and these M incremental costs are added to the M minimum costs associated with the M states at stage 0, respectively. The minimum is sorted out and recorded as cost^mini (1,0) for state *(l,o). The optimal predecessor is also recorded for the purpose of backtracking. In the same manner, we need to find cost__mini (},j)(l*j*M-l) and the optimal predecessors for other M-l states in stage 1. This procedure continues to stage 2 and so on until stage N-l. At this point, we can find 7* with the smallest cost_mini (N-l,j) for Q*j*M-l. This cost-mini (N-IJ*) is the minimum cost of the optimal path from the initial state to stage N-l. By backtracking from j * with the help of the stored optimal predecessor in each state, one can find the optimal path from the initial state to stage N-l, hence, the optimal DC index sequence.<br>
[0074] After the optimal sequence of DC indices is obtained, we may update p(s] and the quantization step size q0 in the same manner as<br>
discussed above. Then the optimization process is iterated as we did for the joint optimization of the quantized AC coefficients with the quantization step size and Huffman table.<br>
[0075]	A DC index can take up to 2047 different values (-1023 to 1023)<br>
in baseline JPEG, which requires 2047 states in each stage. This large number of states not only increases the complexity of the above algorithm but also demands plenty of storage locations. In practice, if a DC coefficient is soft-quantized to a value that is far from the output of a hard-decision<br>
quantizer, it most likely results in a higher cost path. Therefore, in the real implementation of the trellis-based DC optimization, we may only set a small number of states which correspond to the DC indices that are around the output of a hard-decision quantizer. For example, we may only use 33 states in each stage with the middle state corresponding to the output of a hard-decision quantizer, and the upper and lower 16 states respectively corresponding to the 16 neighboring indices that are larger or smaller than the output of the hard-decision quantizer. This reduces the computation complexity and memory requirement significantly with only a slight degradation of the performance.<br>
[0076]	A process for jointly optimizing the run-length coding, Huffman<br>
coding and quantization table in accordance with an aspect of the invention is shown in the flowchart of Figure 7. At step 52, the iterative process is initialized, as outlined in detail in the flowchart of Figure 8. At step 54, j, the index representing the jth block of N total blocks is set to 1. At step 56, the process determines the optimal path for block j, in this case, the first block. This is outlined in detail in the flowchart of Figure 9. At query 58, it is determined whether j is the final block. This is achieved by comparing j to N (the total number of blocks). Where j is less than N, j is incremented in step 60.<br>
[0077]	The process of finding the optimal path for each block j<br>
continues until j-N. When j=N, an optimal path for each of the N blocks will have been determined. The (t+1)th value of J(X) is computed in step 62 as the sum of the minimum distortions associated with each of the N blocks. This value is then compared against the tth value of J(X,) in query 64. Where the difference between the tth value of J(X) and the (t+1)th value of J(X) is less than e (the selection criterion, or more specifically, the convergence criterion), the optimization is considered complete. Where this is not the case, the joint optimization process moves to step 66 and quantization table Qt+i is updated, as outlined in detail in the flowchart of Figure 12.<br>
[0078]	At step 68, the (t+1)th probability distribution function is used to<br>
calculate the entropy rate associated with run-size pair (r,s). At step 70, index t is incremented and an additional iteration is subsequently performed. Where it was determined that the selection criterion was satisfied in query 64, the (t+1)th probability distribution function associated with run-size pair (r,s) is used to generate customized Huffman tables in step 72. Step 74 uses these customized Huffman tables to encode the run-size pairs and indices. The process for jointly optimizing the run-length coding, Huffman coding and quantization table are complete.<br>
[0079]	Referring now to the flowchart of Figure 8, the initialization of the<br>
iterative process in step 52 of the flowchart of Figure 7 is described in more detail. At step 82, a Lagrangian multiplier, X, is selected. This is a fixed parameter that represents the trade off of rate for distortion. At step 84, the convergence criterion e is selected. This is the amount by which the difference of the Lagrangian costs, J\X), of successive iterations must be below for the iteration to be deemed successful and complete.<br>
[0080]	In step 86, an initial quantization table Qo is generated. Step 88<br>
uses the given image I0 and the quantization table Qo generated in the previous step to determine the run-size distribution Po(r,s). At step 90, this run-size distribution is then used to calculate the entropy rate associated with the run-size pair (r,s). At step 92, the initial Lagrangian cost J°(X) is calculated based on the original DOT coefficients and the Lagrangian multiplier X,, the quantization table Qo, and the entropy rate associated with run-size pair (r,s). At step 94, N is set to be equal to the number of image blocks and at step 96, ID(i,0), the index to be sent for the ith DCT coefficient when the index is forced to size group 0, for 15<i is set to finally at step the iterative index t equal and process of initializing complete.></i>
[0081]	Referring now to the flowchart of Figure 9, the process for<br>
determining the optimal path for block j of step 56 in the flowchart of Figure 7 is described in more detail. At step 112, block j is initialized, as outlined in<br>
detail in the flowchart of Figure 10. At step 114, current_minicost, the variable that stores the current lowest Lagrangian cost to state i for block j is set to a large number. At step 116, variable k is assigned a value to represent the number of incoming connections from previous states. Where i&gt;15, k is assigned a value of 15. Where iss15, k=i-1. At step 118, r, the variable associated with run, is set equal to 0 and at step 120, s, the variable associated with size group, is set to 0.<br>
[0082]	At query 122, the process determines whether both of the<br>
relations s=0 and r
[0083]	From step 128, as well as from query 126 when the current cost<br>
was not less than currentjninicost and from query 122 when it was found that s=0 and r
[0084]	Referring now to the flowchart of Figure 10, the initialization for<br>
block j of step 112 of the flowchart of Figure 9 is described in more detail. In<br>
step 152, the end of block cost, eob_cost(i) is recursively calculated for Osis62. This corresponds with the cost of dropping all of the coefficients after state i. At step 154, the distortion, dist(rj) is recursively calculated for hsrsIS and 2s;is63. This refers to the mean square distortion (MSE) of dropping all of the coefficients between state i-r-1 and state i.<br>
[0085]	At step 156, a second distortion metric, d(i,s) is calculated for<br>
1sk63 and 1sss10. This is the mean square distortion (MSE) resulting from the ith DCT coefficient (1sk63) when the corresponding index is forced into size group s. At step 158, the index to be sent for the ith DCT coefficient when the index is in size group s, id(i,s), is calculated for 1^63 and IssslO. Finally, at step 160, the state index i is set equal to 1 and the initialization for block j is complete.<br>
[0086]	Referring now to the flowchart of Figure 11, the procedure for<br>
calculating the cost to state i, step 124 of the flowchart of FIGURE 9 is described in detail. Query 172 asks whether s is equal to 0. Where this is found to be true, step 174 determines the incremental distortion from state i-r-1 (where r=15) to state i as the sum of the mean square distortion of dropping all of the coefficients between state i-16 and i, and the mean square distortion of dropping the Ith DCT coefficient in the current block. Then, the cost to state i, is computed in step 176 as the sum of the cost to state i-r-1, the incremental distortion from state i-r-1 to state i and the entropy rate associated with the run size pair (15,0) scaled by A.<br>
[0087]	Where s was not equal to 0 at query 172, the incremental<br>
distortion is computed in step 178 as the sum of the mean square distortion of dropping all of the coefficients between state i-r-1 and state i and the mean square distortion resulting from the ith DCT coefficient when the corresponding index if forced into size group s. The cost to state i is then computed in step 180 as the sum of the cost to state i-r-1, plus the incremental distortion from state i-r-1 to state i, plus the entropy rate associated with the run size pair (r,s) scaled by A. When the cost for the iteration has been computed in either step 176 or step 180, the cost to state i calculation is complete.<br>
[0088]	Referring now to the flowchart of Figure 12, the process for<br>
updating the quantization table Qt-n, step 66 of the flowchart of Figure 7, is described in detail. In step 192, a numerator array, num(i) is initialized to 0 for 1si*63. Similarly, in step 194, a denominator array, den(i) is also initialized to 0 for 1siss63. In step 196, the block index j is initialized to 1. At step 198, block j is restored from its run-size and indices format to create coefficient index array Kg. At step 200, index i, representing the position in the zig-zag order of the jth block is set to 1.<br>
[0089]	In step 202, the ith value in the numerator array is computed as<br>
the sum of its current value and the product of the original Ith DCT coefficient of the jth block and the restored DCT index at the ith position in the zig-zag order of the jth block, as determined in step 198, from the run-size and indices format. In step 204, the i"1 value in the denominator array is computed as the sum of its current value and the square of the DCT index at the ith position in the zig-zag order of the jth block.<br>
[0090]	Query 206 asks whether i is less than 63.   Where l
incremented at step 208 and the numerator and denominator values associated with the new i are computed. Where i is not less than 63 in query 206, query 210 asks whether j is less than N, the total number of blocks. If j<n j is incremented in step and the numerator denominator computations are performed based on next block. otherwise sets i equal to></n>
[0091]	In step 216, the value associated with the ith position in the zig-<br>
zag order of quantization table Qt+i, qi, is computed as the value of the numerator over the denominator at position i. .Query 218 asks whether i is less than 63. Where this is true, i is incremented at step 220 and the remaining positions in the quantization table are computed. Otherwise, the updating of Qt+i is complete.<br>
[0092]	Referring to Figure 13, there is illustrated in a block diagram a<br>
data processing system 230 for implementing compression methods such as those described above in connection with Figures 7-12 in accordance with the<br>
preferred aspect of the invention. As shown, the system 230 comprises a display 232 for displaying, for example, images to be transmitted. Similarly, the memory 234 may include JPEG or MPEG files to be transmitted. On receiving instructions from a user via a user interface 236, a microprocessor 238 compresses the input image data in the manner described above using a calculation module and initialization module (not shown), before providing the compressed data to a communication subsystem 240. The communication subsystem 240 may then transmit this compressed data to network 242.<br>
[0093]	As described above, the system 240 may be incorporated into a<br>
digital camera or cell phone, while the mode of transmission from communication subsystem 240 to network 242 may be wireless or over a phone line, as well as by higher band width connection.<br>
Experimental results<br>
Optimization of AC coefficients<br>
[0094]	The graph-based run-length coding optimization algorithm and<br>
the iterative joint optimization algorithm described above can be applied to the JPEG and MPEG coding environment for decoder compatible optimization. Both of them start with a given quantization table. Since the quantization step size updating algorithm discussed above only achieves local optimality, the initial scaling of the default quantization table has a direct influence on the R-D performance if a default quantization table has to be used. As an example, Figure 14 illustrates this influence for 512x512 Barbara image using our graph-based run-length coding optimization method. Curve "a" corresponds to the default quantization table while curve "b" corresponds to a fine scale of 0.5 (i.e., halve the length of all the step sizes). The curves are obtained by sweeping the Lagrange multiplier A through all positive values in interest. For the purpose of comparison, the R-D curve obtained by scaling the quantization table only is also given as curve V. It can be seen that we may achieve the same distortion of point X from curve "a" or curve "b". From curve "a", we use a small A to get point Y. (A is placed before the rate in the<br>
implementation to reduce the complexity since it can be pre-multiplied to the entropy rate; -IIXhas the physical meaning of the slope on the R-D curve.) From curve "b", we use a comparatively large A to get point Z. Even though a binary-search method can be used to find the optimal initial scaling factor in the R-D sense, a scale determined empirically works fine and achieves most of the gain that can be obtained by the optimization scheme. The empirical method is used in our experiments.<br>
[0095]	Given the initial quantization table, the number of iterations in<br>
the iterative joint optimization algorithm also has a direct impact on the computation complexity and resulting compression performance. Figure 15 compares the R-D curves obtained from one iteration (optimizing the run-size pairs only), two iterations, and full iterations (the convergence tolerance e is set as 0.1 and the resulting average number of iterations is around 6) for 512x512 Lena image. It can be seen that most of the gain achievable from the full joint optimization is obtained within two iterations.<br>
[0096]	As  mentioned above,  the  quantization  step  size  updating<br>
algorithm only achieves local optimality. In addition to a scaled default quantization table, the proposed joint optimization algorithm can also be easily configured to start with any other quantization table such as one obtained from any schemes in references [3]-[5]. (It should be pointed out that schemes proposed in references [3]-[5] address only how to design optimal quantization tables for hard decision quantization; as such, quantization tables obtained from these schemes are not optimal for soft decision quantization we consider in this paper. Nonetheless, as an initial quantization table for our iterative joint optimization algorithm, these quantization tables are better than a scaled default quantization table.) In our experiments, we choose the fast algorithm in reference [5] to generate an initial quantization table to start with. Figure 16 and Table I compare the Peak Signal-to-Noise Ratio (PSNR) performance of different configurations of our optimization methods as well as the reference methods for 512x512 Lena image. Figure 17 and Table II compare the same performance for 512x512 Barbara image. A customized<br>
Huffman table is used in the last entropy encoding stage. Several remarks are in order. First, the optimal adaptive thresholding scheme in references [7] and [9] is a subset of the proposed run-length coding optimization. Therefore, the proposed run-length coding optimization scheme outperforms the optimal adaptive thresholding scheme for both images under any bit rates as we expected. Second, quantization table optimization plays a less important role at low bit rates since more coefficients are quantized to zero at low bit rates. The proposed joint optimization scheme with an initial scaled default quantization table achieves better results than the joint optimization scheme in reference [9] at low bit rate(s). Third, for complicated images like Barbara, since there are more nonzero coefficient indices that can be optimized on, the proposed joint optimization algorithm with an initial quantization table generated from the scheme of reference [5] outperforms the joint optimization scheme in reference [9] for all bit rates under comparison. For simple images like Lena, the proposed joint optimization algorithm still achieves better results than the scheme in reference [9] at low bit rates since quantization table optimization plays a less important role at low bit rates. However, the scheme in reference [9] still achieves better results at high bit rates for image Lena because our method does not find the optimal quantization step sizes exhaustively in each iteration. Fourth, the proposed joint optimization algorithm improves the objective PSNR significantly, as compared to the customized baseline JPEG, to the extent that the performance even exceeds the quoted PSNR results of some state-of-the-art wavelet-based image coders like Shapiro's embedded zerotree wavelet algorithm in J. Shapiro, "Embedded image coding using zerotrees of wavelet coefficients," IEEE Trans. Signal Processing, vol. 41, pp. 3445-3462, Dec. 1993 (hereinafter "reference [13]") for some complicated image like Barbara at the bit rates under comparison. Table III and IV tabulate the PSNR results of the proposed optimization algorithms for two more images (512x512 Mandrill and Goldhill).<br>
Table I. Comparison of PSNR with different optimization methods (512x512 Lena)<br><br>
			Run- 	Joint opt. 	Joint 		Baseline 	Embedded 	   <br>
Rate (bpp) 	Customized baseline 	Adaptive threshold [9] 	length coding optimiza- 	+ initial scaled default 	opt. + Initial q-table 	Joint optimiza­tion [9] 	wavelet transform coder [12] 	zerotree wavelet algorithm 	   <br>
			tion 	q-table 	from [5] 			[13] 	   <br>
.25 	31.64 	32.1 	32.19 	32.39 	32.45 	32.3 	33.17 	33.17 	   <br>
.50 	34.90 	35.3 	35.38 	35.74 	35.99 	35.9 	36.18 	36.28 	   <br>
.75 	36.56 	37.2 	37.25 	37.59 	38.05 	38.1 	38.02 	N/A 	   <br>
1.00 	37.94 	38.4 	38.58 	39.12 	39.50 	39.6 	39.42 	39.55 	 <br>
Table II Comparison of PSNR with different optimization methods (512x512 Barbara)<br>
(Table remove)Computational complexity<br>
[0097]	We now present some computational complexity results of the<br>
run-length coding optimization algorithm and the iterative joint optimization algorithm. As mentioned above, given a state and a predecessor, we may find the minimum incremental cost by comparing all the 10 size groups or 3 size groups (i.e., the size group from the hard-decision quantizer and its two neighboring groups). Our experiments show that these two schemes achieve the same performance in the region of interest. Only when A is extremely large, we see that the results of comparing 10 size groups slightly outperform the results of comparing 3 size groups. In practice, however, these large values of A will not be used since they lead to large distortions or unacceptably poor image quality. Therefore, all the experimental results in this paper are obtained by comparing 3 size groups. Table V tabulates the CPU time for the C code implementation of the proposed iterative joint optimization algorithm on a Pentium PC with one iteration with 512x512 Lena image. It can be seen that our algorithms are very efficient compared to the schemes in references [7] and [9] (the fast thresholding algorithm in reference [7] takes around 6.1 seconds for one iteration and the scheme in reference [9] takes several dozens of seconds for one iteration on a SPARC-II workstation with a 512x512 image). When the proposed iterative joint optimization algorithm is applied to web image acceleration, it takes around 0.2 seconds to optimize a typical size (300x200) JPEG color image with 2 iterations.<br>
Table V. CPU time of the proposed joint optimization algorithm with one iteration on a Pentium PC (512x512 Lena)<br><br>
Optimization of DC coefficients<br>
[0098]	The quantized DC coefficients are not optimized in previous<br>
experiments. Unlike AC coefficients, the DC coefficients are usually very large and the difference only has 12 size groups for Huffman coding in JPEG syntax (contrary to 162 different run-size pairs for AC coefficients). Consequently, the gain from the trellis-based DC optimization is limited. When the gain from DC optimization is averaged to the bit rate, the overall improvement on PSNR is negligible. To illustrate the performance improvement resulting from the trellis-based DC optimization outlined in Subsection V, Figure 18 plots the DC entropy vs. DC distortion for 512x512 Lena image. From these plots, we can clearly see the improvement of the trellis-based DC optimized algorithm over the scaled step size even though the gain is very limited.<br>
SECTION II: JOINT OPTIMIZATION OF RUN-LENGTH CODING. CONTEXT-BASED ARITHMETIC CODING AND QUANTIZATION STEP SIZES<br>
[0099]	The   foregoing   discussion   proposes   a   graph-based   joint<br>
optimization algorithm that jointly optimizes the three free parameters of a JPEG encoder: quantization step sizes, Huffman tables, and DCT indices in the format RUN-SIZE pairs. This joint optimization algorithm is computationally effective, and is also completely compatible with existing JPEG and MPEG decoders.<br>
[00100] Suppose now we consider a different scenario where the requirement of JPEG compatibility is removed, but both encoder and decoder are required to have low computational complexity, say comparable to that of JPEG encoders and decoders. (Such a scenario arises in applications like the re-encoding of JPEG compressed images.) How can we further improve the rate-distortion performance on top of the JPEG compatible joint optimization considered above?<br>
[00101] Once the requirement of JPEG compatibility is removed, any state-of-the-art image compression/optimization algorithms and schemes, such as the embedded zerotree wavelet (EZW) compression algorithm<br>
described in J. Shapiro, "Embedded image coding using zerotrees of wavelet coefficients," IEEE Trans. Signal Processing, vol. 41, pp. 3445-3462, Dec. 1993 (hereinafter "reference [13]"); set partitioning in hierarchical trees (SPIHT) described in Said and WA Pearlman, "New, fast, and efficient image codec based on set partitioning in hierarchical tress," IEEE Trans. Circuits, Syst, Video Technol, vol. 6, pp. 243-249, June 1996 (hereinafter "reference [14]"); embedded block coding with optimized truncation described in D. Taubman, "High performance scalable image compression with EBCOT," IEEE Trans. Image Processing, vol. 9, pp. 1158-1170, July 2000 (hereinafter "reference [15]"); context-based entropy encoding of wavelet coefficients or DCT coefficients described in X. Wu, "High-order context modeling and embedded conditional entropy coding of wavelet coefficients for image compression," in Proc. 31st Asilomar Conf. Signals, Systems, Computers, pp. 1378-1382, Nov. 1997; Tu, J. Liang, and T. Iran, "Adaptive Runlength Coding," IEEE Signal Processing Letters, vol. 10, pp. 61-64, Mar. 2003; and, Tu and T. Tran, "Context-Based Entropy Coding of Block Transform Coefficients for Image Compression," IEEE Trans. Image Processing, vol.11, pp. 1271-1283, Nov. 2002 (hereinafter "reference [16]", "reference [17]" and "reference [18]" respectively); pre- and post-filtering techniques described in T. Tran, J. Liang, and C. Tu, "Lapped Transform via Time-domain Pre- and Post-Filtering," IEEE Trans. Signal Processing, vol. 51, pp. 1557-1571, June 2003 (hereinafter "reference [19]"); can be possibly employed to improve the rate-distortion performance for a given image. However, due to their inherent encoding structures, these methods may not meet the stringent computational complexity requirements on both encoder and decoder.<br>
[00102] In this section a different approach is taken. To meet stringent computational complexity requirements, we replace the Huffman coding of JPEG by context-based arithmetic coding. In this way, we avoid performing the computationally expensive wavelet transform and inverse wavelet transform as well as the extra DCT transform and inverse DCT transform, especially in the case of re-encoding of JPEG compressed images. To improve the rate-distortion performance, we then jointly optimize run-length<br>
coding, context-based arithmetic coding, and quantization step sizes as shown in Figure 19 where the re-encoding of a JPEG compressed image is illustrated, and in Figure 20 where the encoding of an uncompressed image is illustrated.<br>
[00103] Figures 19 and 20 illustrate, in block diagrams, the operation of an encoder 320, in accordance with an aspect of the present invention, in different circumstances. In the situation of Figure 19, the input is a JPEG image. As described above in connection with Figure 1, this JPEG image has already been subjected to Huffman coding and quantization. Accordingly, to begin the joint optimization of quantization, run-length coding and context-based arithmetic coding, this JPEG image must first be Huffman decoded in step 322 and dequantized in step 324. Based on the resulting DOT coefficients, the joint optimization of quantization in step 326, run-length coding in step 328, and context-based arithmetic coding (in step 330) using context models 332 is then conducted.<br>
[00104] In Figure 20, the encoder 320 operates on an uncompressed image 340, instead of a JPEG image as in Figure 19. Similar to the JPEG encoder 20 of Figure 1, the encoder 320 of Figure 20 first partitions the uncompressed image 340 into 8x8 blocks and then processes these 8x8 image blocks. Each block is first transformed from the pixel domain to the DC domain by an 8x8 DOT in the DCT step 342. Based on the resulting DCT coefficients, the joint optimization of quantization table in step 326, run-length coding in step 328, and context-based arithmetic coding in step 330 using context models 332 is then conducted.<br>
Context Modeling of RUN and LEVEL<br>
[00105] JPEG standard uses run-length coding to order a block of quantized coefficients into zigzag sequence in the order of increasing frequency shown as<br>
(DC)(RUN, SIZE)(Amplitude)..(RUN, SIZE)(Amplitude)(EOB)<br>
This sequence is then Huffman encoded. In context modeling and related entropy encoding, the amplitudes of the DCT indices are usually merged into the size part to form a (RUN, LEVEL) sequence shown as<br>
(DC)(RUN, LEVEL)..(RUN, LEVEL)(EOB)<br>
where RUN still represents the number of consecutive zero AC coefficient indices prior to a nonzero one and LEVEL is the value of the nonzero coefficient index. The EOB symbol indicates that there are no additional nonzero coefficient indices in the current block.<br>
[00106] Tu et al. [17] proposed a context modeling scheme which makes use of the properties of RUN-LEVEL sequences of quantized DCT blocks such as small RUNs occurring more frequently than large RUNs, LEVELs with small magnitudes occurring more often than LEVELs with large magnitudes, etc. Then, a context-based binary arithmetic coder is used to encode RUNs and LEVELs separately (EOB is treated as a special RUN symbol). To encode a nonbinary symbol by a binary arithmetic coder, the symbol is binarized first. Since small RUNs and small LEVELs occur more frequently, shorter binary sequences should be assigned to smaller RUNs and LEVELs. A simple binarization scheme which meets this requirement, described in more detail in Tu et al. [17], is as follows: RUN is binarized as (RUN+1) "O's" followed by a "1"; EOB is considered as a special RUN and binarized as "1"; and LEVEL is binarized as (|LEVEL|-1) "O's" followed by an ending "1" in addition to a sign bit. The DC coefficient of a block is predicted from the DC values of its top and left neighbor blocks. If the predicted DC residue is nonzero, it is binarized in the same manner as that of a regular LEVEL symbol. Since the statistics of different bits may differ greatly, different models are usually used for different bits to maximize coding efficiency.<br>
Context Arithmetic Coding-Based Joint Optimization<br>
[00107] The basic idea of the context arithmetic coding-based joint optimization is similar to the JPEG compatible joint optimization problem described above in section I. It is a constrained optimization over all<br>
sequences of (RUN, LEVEL) pairs, or (R,L) for short, all possible context models M, and all possible quantization tables Q. Therefore, the optimization problem can be posed as<br>
where d[I0,(R,L)Q] denotes the distortion between the original image /0 and the reconstructed image determined by (R, L) and Q over all AC coefficients, and r[(R,L),M] denotes the compression rate for all AC coefficients resulting from the chosen (R,L) pairs and the context models M. The equivalent unconstrained optimization problem is<br>
min {./(A) - d[I0,(R,L)Q] + l-r[(R,L),M]}	<br>
where the Lagrangian multiplier A is a fixed parameter that represents the tradeoff of rate for distortion, and /(A) is the Lagrangian cost. In this section,<br>
we select suitable contexts and update (or optimize) the probability distributions under each context in each iteration. Then, the iterative algorithm of solving this unconstrained optimization problem can be described as follows:<br>
1)	Initialize a context model distribution P(M0) from the given image /„ and a<br>
quantization table Q, . Set t - 0, and specify a tolerance s as the convergence<br>
criterion.<br>
2)	Fix P(M,)and Q,  for anyf^O. Find an optimal sequence (Rt,Lt) that<br>
achieves the following minimum<br>
3) Fix OR,,!,). Update P(M,)and Q into P(MM) and Q,^, respectively so that P(jl//+1) and QM together achieve the following minimum<br>
4) Repeat Steps 2) and 3) for f-0,1,2,-- until y'(A)-/+1(A)se. Then output<br>
[00108] The core of the iterative algorithm is Step 2) and Step 3), I.e., finding the sequence (R,L)to minimize the Lagrangian cost J(A) given P(M) and Q, and updating the quantization step sizes with the new indices of the image. The same quantization step-size updating algorithm in section I can be used for the latter purpose. In what follows, we address Step 2), i.e., how to find the optimal sequence of (R,L) for each block given the distribution of the context models and quantization step sizes.<br>
Context Models Adopted<br>
[00109] The context models used below are a set of slightly modified context models for DC, RUN, and LEVEL from reference [17], which is hereby incorporated by reference.<br>
(1)	Context models for DC residues<br>
[00110] Two context models are used for the magnitude of a DC residue, which is the difference between the current DC index and the DC index of the top block neighbor, depending on whether the DC residue of the top block neighbor is zero or not.<br>
(2)	Context models for the first RUN<br>
[00111] The first RUN is conditioned on the flatness of the neighbor blocks. Five context models are used to encode the first RUN of a block. The first three are used to code the first binary bit of the first RUN corresponding to neither of, either of, or both the left and top block neighbors having nonzero<br>
AC indices. The fourth model is used for the second binary bit of the first RUN, and the fifth model is used for all the remaining binary bits.<br>
[00112] It should be pointed out that the five context models of the first RUN are used only at the last entropy encoding stage; they are not involved in the joint optimization process (in the joint optimization process, we will employ a fixed model for the first RUN). This is because the first RUN is conditioned on the flatness of the neighboring blocks, and as such, including the first RUN in the joint optimization will result in a more complicated joint optimization algorithm. Since coding the first RUN only takes a very small fraction in the bit rates, this compromise is well justified.<br>
(3)	Context models for other RUNs<br>
[00113] Other RUN symbols are conditioned on the magnitude and the zigzag order of the preceding LEVEL, denoted as m and zz, respectively. The context models are chosen as:<br>
(zz  l), (6 * zz 
(6szzl), (a* 15).	(22)<br>
[00114] In addition, different models are used for the first binary bit, the second binary bit, and all remaining binary bits. A total of 15 context models are used for other RUNs.<br>
(4)	Context models for the magnitudes of LEVELs<br>
[00115] The magnitude of the LEVEL is conditioned on zz, the zigzag order of the current LEVEL, andr, the current RUN. The context models are chosen as:<br>
(0<zz and r></zz>
(15*zzor 3*r).	(23)<br>
[00116] In addition, different models are used for the first binary bit and all the remaining bits. A total of 8 context models are used for LEVEL magnitudes.<br>
[00117] One additional single model is used for the sign bit of LEVELS and DC residues and does not enter in the joint optimization either. In total, 31 binary context models are used to encode the DOT coefficient indices.<br>
Graph-Based RUN-LEVEL Optimization<br>
[00118] A similar idea to the graph-based optimization of section I can be employed to find the optimal sequence of (R, L) in the context arithmetic coding-based joint optimization. However, since RUNs are now encoded conditionally given both the zigzag order and the magnitude of the preceding LEVEL, a graph different from that considered in section I will be utilized.<br>
[00119] From the way RUNs are encoded, it follows that the quantized magnitudes (being unity or non-unity) together with the zigzag order of the first 14 AC coefficients are used in the encoding of RUNs; however, the quantized magnitudes of the AC coefficients after the first 14 are encoded based on the zigzag order only, and not based on magnitude. To address this additional dependency, we define one more state for each of the first 14 AC coefficients. Specifically, we define a directed graph with 64 super nodes (or super states) which correspond to the 64 coefficient indices of an 8x8 image block in zigzag order and an end state (or end node) as shown in Figure 21. Each of the first 14 super states which correspond to the first 14 AC coefficients (state 0 corresponds to the DC coefficient) includes two states (or nodes): one is called a basic state indicating that the magnitude of the corresponding AC coefficient is &gt;1 (state 1' to state 141); and the other is called an extended state indicating that the magnitude of the corresponding AC coefficient is equal to 1 (state 1 to state 14). Each of the remaining super states (state 15 to 63 as well as state 0) has only one state and is called a regular state. Each non-end state may have incoming connections from its previous 16 super states, which correspond to RUN, R, in an (R,L) pair with R taking values from 0 to 15. The end state may have incoming connections from all the other states, which corresponds to the EOB code, i.e., code (0, 0). State 63 goes to state end without EOB code. For a given basic state /" (1 si's 14)and its predecessor i'-r-l(0srsl5) (although for the first 14<br>
states rs 13), there are 2m-2 parallel transitions between them where m is the maximum magnitude of LEVEL. Note that the predecessor can be either a basic state or an extended state. We assign to each transition (/•,/')<br>
(- m * I'* m,\l\ &gt; 1) from state f-r -1 to state i' a cost which is defined as the incremental Lagrangian cost of going from state f-r -1 to state f when the fth DOT coefficient is quantized to /'(|/'|&gt;1) and all the r DCT coefficients<br>
appearing immediately before the i'th DCT coefficient are quantized to zero. This incremental cost is defined as<br>
(24)<br>
where Cf and q,. are respectively the f'th DCT coefficient and the /'th quantization step size; and /(r,/1) is a length function that maps from the transition (r,/1) to an entropy rate based on the current probability distribution of the context models Af . Note that the probability distribution of r given the context models M now depends only on the predecessor i'-r - 1 , and the probability distribution of /' given the context models M depends on both r and the state i'. Similarly, for a given extended state / (lss/^14) and its predecessor z-r-1, there are two transitions, (r,l) and (r,-l), between<br>
them. Since the sign bit is treated separately, we only draw one transition in the directed graph of Figure 21 for simplicity. The incremental Lagrangian cost of these two transitions, which means the /* DCT coefficient is quantized to unity and all the r DCT coefficients appearing immediately before the /"' DCT coefficient are quantized to zero, is defined as<br><br>
[00120] For a regular state i (15 ss i' * 63) and its predecessor /-r-1, there are 2m parallel transitions between them (note that if the position of the predecessor is less than 15, then both the basic node and the extended node have 2m parallel transitions to state /). The incremental Lagrangian cost<br>
associated with the transition (r,/) (-m*l£m,l#Q) from state i-r-l to state / is similarly defined as<br>
-02+A'/(r,a  /no.	<br>
[00121]        For the transition from each super state / (both the basic state and the extended state if 1 * i &amp; 14) to the end state, its cost is defined as<br>
63C,2+A-/(0,0)	<br>
[00122] For each regular state / (/a 16), there are one or two more transitions from state i-16 to i (depending on the position of 1-16) which correspond to the pair (15, 0), i.e., ZRL (zero run length) code. Its cost is defined as<br>
where pair (15, 0) is treated as a special RUN with length of 16. With the above definitions, every sequence of (R,L) pairs of an 8x8 block corresponds to a path from state 0 to state end with a Lagrangian cost. Analogous to the method of section I, one can apply a fast dynamic programming algorithm to the whole directed graph to find the optimal sequence (R,L) for a given 8x8<br>
block. The detailed description of the fast dynamic programming algorithm is similar to that in section I and the corresponding pseudo-code is outlined in the pseudo code of Figures 22a to 22d.<br>
[00123] A process for jointly optimizing the run-length coding, context-based arithmetic coding and quantization step sizes in accordance with an aspect of the invention is shown in the flow chart of Figure 23. At step 352, the iterative process is initialized, as outlined in detail in the flow chart of Figure 24. At step 353, all context model entries are initialized to unity. Then, in step .354, the index representing the jth block of N total blocks is set to 1. At step 356, the process determines the optimal path for block j, in this first run<br>
through, the first block. This is outlined in detail in the flow chart of Figure 25. At query 358, the process determines whether j is the final block. This is achieved by comparing j to N .(the total number of blocks). Where j is less than N, j is incremented in step 360.<br>
[00124] The process of finding the optimal path for each block j continues until j equals N. When j equals N, an optimal path for each of the N blocks will have been determined. The (t+1)th value of J(X) is computed in step 362 of the method of Figure 23 as the sum of the minimum costs associated with each of the N blocks. This value is then compared against the tth value of J(X) in query 364 where if the difference between the tth value of J(X.) and the (t+1)th value of J(X,) is less than e (the selection criterion, or more specifically, the convergence criterion), the optimization is considered complete. Where this is not the case, the joint optimization process proceeds to step 366 in which the quantization table is updated into Qt+i, as outlined in detail in the flow chart of Figure 29. The context model P(Mt) could be<br>
updated to P(Mt+l) using the probability distribution of the context models at<br>
the end of iteration t as discussed in paragraph [0099]. In the practical implementation, adaptive context-based arithmetic coding is actually employed both for joint optimization and for final encoding/decoding. Adaptive context-based arithmetic coding sets the entries of the context models to unity at the beginning of each iteration as specified in step 353 and updates the context models at the end of each block as specified in step 444. At step 370, index t is incremented and an additional iteration is subsequently performed beginning once again at step 353.<br>
[00125] Where it was determined that the selection criteria was satisfied in query 364, context-based arithmetic coding is used to encode the selected (r,l) pairs in step 374. After step 374, the process for jointly optimizing the run-length coding, context-based arithmetic coding and quantization table is complete.<br>
[00126] Referring now to the flow chart of Figure 24, the initialization of the iterative process in step 352 of the flow chart of Figure 23 is described in more detail. At step 382, the Lagrangian multiplier, X, is selected. This is a fixed parameter representing the trade-off of rate for distortion. At step 384, the convergence criteria e is selected. This is the amount by which the difference of the Lagrangian costs, J'(X), of successive iterations must be below for the iteration to be deemed successful and complete.<br>
[00127] In step 386, an initial quantization table Qo is generated. In step 392, an initial Lagrangian cost J°(X) is set to be a very large number, in order to make sure that this initial Lagrangian cost exceeds the minimum cost eventually determined by the method. At step 394, N is set to be equal to the number of the image blocks, and in step 396, M is set equal to the number of transitions being compared. As described above, the number of transitions being compared will differ depending on whether the state or node in question is a basic node, an extended node, or a regular node, although this step deals with basic and regular nodes only. In step 398, the iterative index t is set equal to 0 and the process of initializing the iterative process is complete.<br>
[00128] Referring now to the flow chart of Figure 25, the process of determining the optimal path for a block j of step 356 in the flow chart of Figure 23 is described in more detail. In step 412, dist(rj); d(i,l); and, eob_dist(i) for the current block are determined: (1) dist(r,i) is the mean square distortion of dropping all the coefficients between state i-r-1 and state i; (2) d(i,l) is the mean square distortion resulting from dj when the magnitude of the corresponding index is I; and, (3) eob^dist(i) is the mean square distortion of dropping the coefficients after state i (eob stands for end-of-block). In step 416, i is set equal to 1, indicating that the method of Figure 25 begins at the first AC coefficient of block j. In step 418, the minicost for the basic state, and minicost_ext for the extended state are both set equal to large numbers, although not necessarily the same large number. In step 420, the magnitude of the i"1 coefficient index is set equal to the absolute value of the corresponding Ith DCT coefficient first divided by the current quantization<br>
step size for this coefficient in zigzag order and then rounded to the nearest integer. In step 422, variable k is assigned a value to represent the maximum possible value of the run immediately before this coefficient. Where i is greater than 15, k is assigned a value of 15. Where i is less than or equal to 15, k is set equal to 1-1. At step 424, r, the variable associated with RUN, is set equal to 0.<br>
[00129] In step 426, the cost to state i, where i is a basic or regular state, is calculated. At query 428, the process determines whether the current coefficient is one of the first 14 coefficients, for which extended states exist, or not. If the current state is one of the first 14 states, then query 428 returns the answer true and the method proceeds to step 430 in which the cost to the ith extended state is determined before the method then proceeds to query 432. If i exceeds 14, then the method proceeds directly to query 432 from query 428, skipping step 430.<br>
[00130] At query 432, the method asks whether r is less than k. Where r is less than k, r is incremented at step 434, and the iteration for calculating the cost to state i is repeated. Where r is not less than k, then the method proceeds to step 436, in which the cost of the special transition (15,0) - i.e. the zero run length code - is calculated. Of course, if i is less than or equal to 15, then there will be no special transition, and therefore, no special transition cost. The method then proceeds to query 438.<br>
[00131] Query 438 asks whether i is less than 63 - that is, whether the flow chart of Figure 25 has traversed all of the super nodes of the directed graph of Figure 21. Where i is less than 63, then query 438 returns the answer true and the method proceeds to step 440 in which i is incremented. Subsequently, the entire iteration is repeated beginning at step 418. If, on the other hand, query 438 returns the answer false, then the minimum cost to each state is deemed to have been calculated (note that the minimum cost to state 0 is 0). In step 442, the total minimum cost of this block when the ith DCT coefficient is the last nonzero coefficient to be sent, J'(j),o«/«63, is computed as the sum of the minimum cost to state i, the mean square<br>
distortion of dropping the coefficients after state i (i.e., eob_dist(i)) and the entropy rate associated with the run-level pair (0,0) (i.e., the end-of-block code) scaled by A. The total minimum cost of this block, ,/*(/'), is determined by comparing the values .7*(0,0s/*63. By backtracking from f with the help of the stored run-level pairs and the incoming state type, the optimal path in run-level pair format of block j can be determined. In step 444, the run-level pairs from the optimal path are used to update the context models and the process for finding the optimal path for block] is complete.<br>
[00132] Referring now to the flow chart of Figure 26, the calculation of the cost to the ith basic/regular state of step 426 of Figure 25 is outlined in more detail. In step 446, an offset m, representing the particular transition being considered, is initially set equal to 0. The method then proceeds to step 448, in which the incremental distortion (distjnc) is calculated to be the sum of (1) the mean square distortion resulting from dropping all of the coefficients between state i-r-1 and state i (dist(r,i)) and (2) the mean square distortion resulting from the ith DCT coefficient when the corresponding level value is forced to be l-m (dist(i,l-m)). In step 450, the cost of state i is computed as the sum of the cost to state i-r-1, the incremental distortion calculated in step 448 and the entropy rate associated with the run-level pair (r,l-m) scaled by A.<br>
[00133] The method then proceeds to query 452, which asks whether this total cost is less than the minicost term initially set to be a large number in step 418. If the cost to state i is determined to be less than minicost, then the method proceeds to step 454, in which minicost is replaced with J. In addition, r, l-m, J and the incoming state type to state i are all recorded in step 454 before the method proceeds to query 456. If query 452 returns the answer false, in that J is greater than or equal to minicost, then the method proceeds directly to query 456, bypassing step 454.<br>
[00134] In query 456, the method checks whether the preceding state is one of the first 14 basic states, or is instead a regular state. If query 456 returns the answer true, then the preceding state is a basic state, and the method proceeds to step 458, query 460 and step 462. If query 456 returns<br>
the answer false, in that the preceding state is a regular state rather than a basic state, then the method bypasses step 458, query 460 and step 462, instead proceeding directly to query 464.<br>
[00135] In step 458, the method checks the costs to state i through the preceding extended state, instead of the basic state. That is, the cost of state i is computed to be the sum of the cost to extended state i-r-1, the incremental distortion from extended state i-r-1 to state i and the entropy rate associated with the run-level pair (r, l-m). The method then proceeds to query 460, which checks whether this total cost is less than minicost. If J is less than minicost then the method proceeds to step 462, in which minicost is replaced with J. In this step, r, l-m, J, and the incoming state type to state i are also recorded. Then the method proceeds to query 464, which checks whether all of the specified transitions from the preceding state to the current state have been checked. If m is less than M-1, then not all of these transitions have been checked, and the method proceeds to step 466, in which m is incremented by 1. The method then proceeds back to step 448, for another transition. If, on the other hand, m is not less than M-1, then step 464 returns the answer false and the method of Figure 26, in which the cost to the ith basic/regular state is calculated, is complete.<br>
[00136] Referring now to the flow chart of Figure 27, step 430 of the flow chart of Figure 25, in which the cost to the ith extended state is calculated, is outlined in more detail. In step 468, the incremental distortion is computed as the sum of (1) the mean square distortion of dropping all of the coefficients between state i-r-1 and state i and (2) the mean square distortion resulting from the Ith DOT coefficient when the corresponding index is forced to have level value 1. In step 470, the cost to state i from a preceding basic state i-r-1 is computed as the sum of the cost to basic state i-r-1, the incremental distortion from basic state i-r-1 to state i and the entropy rate associated with the run-level pair (r,1) scaled by A. The method then proceeds to query 472, which checks whether the cost, J, calculated in step 470 is less than the minicostjext initially set to be a large number in step 418. If J is less thanninicost__ext, then the method proceeds to step 474 in which minicost_ext is •eplaced with J. Also in step 474, r, 1, J, and the incoming state type to state i are also all recorded. The method then proceeds to step 476. If J is greater :han or equal to minicost_ext then the method proceeds directly to step 476 Tom query 472.<br>
[00137] In step 476, the cost to state i from a preceding extended state i-'-1 is calculated as the sum of the cost to extended state i-r-1, the incremental distortion from extended state i-r-1 to state i and the entropy rate associated with the run-level pair (r, 1) scaled by A. If this cost, J, determined in step *76 is less than minicost_ext, then query 478 returns the answer true and the method proceeds to step 480, in which minicost_ext is replaced with J. The method of Figure 27, then terminates after step 480. Additionally, r, 1, J and the incoming state type to state i are all recorded in step 480. If the total cost J determined in step 476 is not less than minicost_ext, then the method of Figure 27 terminates without executing step 480.<br>
[00138] Referring to Figure 28, the calculation of the cost for the special transition (15,0) designated in step 436 of the flow chart of Figure 25 is outlined in more detail. Recall that for each regular state i (i is greater than or equal to 16), there is either one or two additional transitions from state i-16 (depending on whether or not state i-16 is one of the first 14 super states each of which includes two states). These transitions correspond to the zero run length (ZRL) code (15,0). The cost of this additional transition is determined in the method of the flow chart of Figure 28.<br>
[00139] Query 482 begins by checking whether i is less than or equal to 62 and more than or equal to 16. That is, if i is 63 then i corresponds to the last coefficient, and must be separately considered. On the other hand, if i is less than 16, then the run-length cannot, of course, be 15. Thus, if query 482 indicates that i is outside the closed interval [16,62], then the method terminates. Otherwise, the method of Figure 28 proceeds to step 484 which determines the incremental distortion from state i-r-1 (where r equals 15) to state i as the sum of (1) the mean square distortion of dropping all of the<br>
coefficients between state i-16 and state i, and (2) the mean square distortion of dropping the Ith DOT coefficient in the current block. Then the cost to state i, J, is computed in step 486 as the sum of the cost to basic or regular state i-16, the incremental distortion from state i-16 to state i and the entropy rate associated with the run-level pair (15,0) scaled by A in step 486.<br>
[00140] If the cost to state i, J, computed in step 486, is less than minicost then the method proceeds from query 488 to step 490, in which minicost is replaced with J. In addition, the run-length 15, the level value of 0 for the Ith node, the cost J and the incoming state type to state i are all recorded in step 490. The method then proceeds to query 492. If the cost calculated in step 486 is not less than minicost, then the method of Figure 28 proceeds directly from query 488 to query 492.<br>
[00141] Query 492 checks whether i is less than or equal to 30, which is significant because if i is less than or equal to 30, then the preceding node under the special transition (15,0) may be an extended node, whereas if i is greater than 30, the preceding node under the special transition (15,0) will be a regular node. If i is less than or equal to 30, then the method of Figure 28 proceeds to step 494, query 496 and step 498 before terminating, while if i is greater than 30, then the method of Figure 28 terminates after query 492.<br>
[00142] In step 494, the cost to state i is computed as the sum of the cost to extended state i-16, the incremental cost distortion from extended state i-16 to state i and the entropy rate associated with the run-level pair (15,0). If this cost, J, calculated in step 494 is less than minicost, then the method proceeds to step 498, via query 496. Alternatively, if the cost, J, is not less than minicost, then the method of Figure 28 terminates after query 496. In step 498, minicost is updated to be the cost, J, calculated in step 494. In addition, the run-length of 15, level value of 0 for the ith node, J and the incoming state type to state i (extended) is recorded. Then, the method of Figure 28 terminates.<br>
[00143] Referring to the flow chart of Figure 29, the process for updating the quantization table Qt+i, step 366 of the flow chart of Figure 23, is<br>
described in detail. In step 500, a numerator array, num(i) is initialized to 0 for 1
[00144] Query 514 asks whether i is less than 63 (that is, whether all of the coefficients in this block have been considered). If i is less than 63, then the method proceeds from query 514 to step 516 where i is incremented and the method then proceeds back to step 510 for the next coefficient. If, on the other hand, i is not less than 63, the method proceeds from query 514 to query 517, which asks whether] is less than N, the total number of blocks. If j is less than N, then j is incremented in step 518 and the numerator and denominator arrays are updated based on the next block, as the method of Figure 29 returns to step 506 described above. Otherwise, step 519 sets i=1.<br>
[00145] In step 520, the value associated with the ith position in the zigzag order of the quantization table Qt+i, qi, is computed as the value of the numerator over the denominator at position i. Query 522 then asks whether i is less than 63. Where this is true, i is incremented at step 524 and the remaining elements in the quantization table are computed. Otherwise, the updating of Qt+i, is complete and the method of Figure 29 terminates.<br>
[00146] In the rest of this section, we look at an example of calculating the entropy rate of a given transition.<br>
[00147] Example: Calculate the entropy rate of the transition from state 14 to state 16 in Figure 21 for a given / (i.e., the entropy rate of transition (1,1) from state 14 to state 16).<br>
[00148] Except for the special transitions (0, 0) and (15, 0), the entropy rate associated with any transition consists of three parts: entropy rate of RUN, entropy rate of the sign of LEVEL, and entropy rate of the magnitude of LEVEL.<br>
[00149] The entropy rate of RUN is the entropy rate of each bit of the current RUN, 1, which is binarized as three bits 001 according to the binarization scheme mentioned above. Since this RUN is not the first RUN (a RUN starting from state 0 is the first RUN), its first bit, second bit and remaining bits use different context models that can be determined from the zigzag order of the preceding LEVEL (here the zigzag order of the preceding LEVEL is 14 since this transition starts from state 14) and the magnitude of LEVEL of state 14 (since this transition starts from an extended state, the context model corresponding to the unity magnitude will be used). Once the context models are determined, we can find the corresponding entropy rate based on the current probability distribution of the context models.<br>
[00150] A fixed context model is used for the sign bit at the last entropy encoding stage. We may use one bit (properly scaled by A) as the cost of the sign bit in the calculation of incremental Lagrangian cost.<br>
[00151] The magnitude of LEVEL is binarized as (|LEVEL|-1) "O's" followed by an ending "1". The first bit and the remaining bits of the magnitude use different context models which can be determined by the zigzag order of current state (here the zigzag order of the current state is 16) and the current run (here the current run is 1). Given a LEVEL, /, the entropy rate can be determined accordingly.<br>
[00152] In practice, we do not have to compare the incremental costs among all the 2m-2 transitions between a predecessor and a basic state or 2m transitions between a predecessor and a regular state. Instead, we may<br>
only compare a few (e.g. 4) transitions among LEVEL= 1+1,1, M, 1-2, A3	<br>
where / is the absolute value of the output of the hard-decision quantizer with the latest quantization step size. Other levels most likely result in larger incremental costs. We shall compare the performance and complexity difference when the number of transitions in comparison changes in the next subsection.<br>
[00153] In accordance with still further aspects of the invention, the data processing system 230 illustrated in Figure 13 may also be used to implement compression methods such as those described above in connection with Figures 19 to 29. In these cases, the memory 234 may include Huffmann decoded images obtained from JPEG or MPEG files, as well as uncompressed images. On receiving instructions from a user via the user interface 236, the microprocessor 238 will compress the input image data in the manner described above using the calculation module and initialization module before providing the compressed data to the communication subsystem 240. The communication subsystem 240 may then transmit this compressed data to network 242.<br>
[00154] As described above in Section 1, the system 240 may be incorporated into a digital camera or cell phone, while the mode of transmission from communication subsystem 240 to network 242 may be wireless or over the phone line, as well as by high band width connection.<br>
Experimental Results<br>
[00155] As discussed in the last subsection, given a state (other than any of the extended states or the end state) and a predecessor, there are 2m or 2m-2 possible transitions where m is the maximum magnitude of LEVEL. We may find the minimum incremental cost by comparing any number of transitions up to 2m or 2m -2 between these two states. Simulation results show that comparing only two transitions achieves most of the gain a full comparison scheme can achieve. As an example, Figure 30 plots the R-D curves when the number of transitions in comparison varies for a 512x512 Barbara image. When the number of transitions in comparison is greater than<br>
4, there Is almost no difference in compression performance. In the following experiments, we only compare up to four transitions between any two states. Table VI tabulates the CPU times for the C code implementation of the context arithmetic coding-based joint optimization algorithm for one iteration on a Pentium PC with 512x512 Barbara image when the number of transitions in comparison varies.<br>
Table VI. CPU time of the proposed joint optimization algorithm on a Pentium PC (512x512 Barbara)<br><br>
[00156] The iterative algorithm outlined above in this section starts with an initial quantization table and updates the step sizes using the algorithm outlined in section I during the iteration. Since the step size updating algorithm in section I only achieves local optimality, the initial quantization tables also impact the R-D performance in certain degree. We can use a scaled default quantization from reference [1] or any other quantization tables such as one obtained from the schemes in references [3], [9] and [5] as we did in section I. In this section, we only start the algorithm with a scaled default quantization table and compare the performance between the Huffman coding-based joint optimization algorithm and context arithmetic coding-based joint optimization. Figure 31 shows the PSNR performance of context arithmetic coding-based joint optimization algorithm and Huffman coding-based joint optimization algorithm for 512x512 Barbara image. The curves are obtained by sweeping the Lagrangian multiplier A through possible values given a scaled default quantization table. For illustration purposes, also shown in Figure 31 is the PSNR performance curve generated by a mixed scheme where only the last stage of Huffman encoding in Huffman coding-based joint optimization<br>
algorithm is replaced by context-based arithmetic coding. It is easy to see that the gain of context arithmetic coding-based joint optimization algorithm over Huffman coding-based joint optimization algorithm comes from two parts. The first part comes from the gain of context-based arithmetic coding over customized Huffman coding. The second part comes from the joint optimization. Figure 32 compares the same performance for 512x512 Lena image. Tables VII and VIII tabulate the coding results at the most popular bit rates for both images where the default quantization table is linearly scaled at the beginning for each bit rate. From these tables and figures, one can see that the context arithmetic coding-based joint optimization algorithm consistently outperforms the Huffman coding-based joint optimization algorithm by a margin up to 0.5 dB, or 10~15% size reduction.<br>
TABLE VII Comparison of PSNR with different optimization methods (512x512 Barbara)<br><br><br>
(TableRemove)[00157] Other variations and modifications of the invention are possible. For example, the context models described above in section II could readily be replaced with other context models. Futher, while the aspects of the invention described above have relied on (run, size) pairs and (run, level) pairs, it will be appreciated by those of skill in the art that other (run, index derivative) pairs could be used by deriving index-based values other than size or level from the coefficient indices. All such and similar modifications or variations are believed to be within the sphere and scope of the invention as defined by the claims appended hereto.<br><br><br><br>
We Claim:<br>
1.	A method of operating a processor to compress a sequence of n coefficients by<br>
determining a cost-determined sequence of n coefficient indices represented by a cost-<br>
determined sequence of (run, index derivative) pairs under a given quantization table<br>
and run-index derivative coding distribution, wherein each sequence of (run, index<br>
derivative) pairs defines a corresponding sequence of coefficient indices such that (i)<br>
each index in the corresponding sequence of coefficient indices is a digital number,<br>
(ii) the corresponding sequence of coefficient indices includes a plurality of values<br>
including a special value, and (iii) each (run, index derivative) pair defines a run value<br>
representing a number of consecutive indices of the special value, and an index-based<br>
value derived from a value of the index following the number of consecutive indices<br>
of the special value, the method comprising the steps of:<br>
(a)	operating the processor to use the given quantization table and run-index derivative coding distribution to formulate a cost function for a plurality of possible sequences of (run, index derivative) pairs;<br>
(b)	operating the processor to apply the cost function to each possible sequence in the plurality of possible sequences of (run, index derivative) pairs to determine an associated cost; and,<br>
(c)	operating the processor to select the cost-determined sequence of (run, index derivative) pairs from the plurality of possible sequences of (run, index derivative) pairs based on the associated cost of each of the plurality of possible sequences of (run, index derivative) pairs; (d) operating the processor to encode the selected cost-determined sequence of (run, size, ID) triples using Huffman coding.<br>
2.	The method as claimed in claim 1, wherein step (b) comprises, for each<br>
possible sequence of (run, index derivative) pairs in the plurality of possible<br>
sequences of (run, index derivative) pairs:<br>
(i) operating the processor to determine a corresponding sequence of n coefficient indices;<br><br>
(ii) operating the processor to determine a corresponding sequence of n quantized coefficients using the given quantization table and the corresponding sequence of n coefficient indices;<br>
(iii) operating the processor to determine a distortion between the sequence of n coefficients and the corresponding sequence of n quantized coefficients;<br>
(iv) operating the processor to determine a total compression rate resulting from using the given run-index derivative coding distribution to encode the sequence of (run, index derivative) pairs; and<br>
(v) operating the processor to determine the associated cost of the sequence of (run, index derivative) pairs as a function of the distortion and the total compression rate.<br>
3.	The method as claimed in claim 1, wherein step (c) comprises:<br>
(i) operating the processor to provide a sequence of n super nodes, each super node comprising at least one node, in one-to-one relation with the sequence of n coefficients, such that each coefficient Ci has a corresponding ith super node wherein i is greater than or equal to 1 and less than or equal to n;<br>
(ii) operating the processor to provide an initial node preceding and an end node following the sequence of n super nodes;<br>
(iii) operating the processor to provide a plurality of connections between pairs of nodes including the initial node, super nodes, and the end node to represent a plurality of possible (run, index derivative) pairs;<br>
(iv) operating the processor to determine the associated cost of each of the plurality of possible sequences of (run, index derivative) pairs by determining an associated incremental cost for each connection in the plurality of connections;<br>
(v) operating the processor to determine a least cost sequence of connections from the plurality of connections, wherein the least cost sequence of<br><br>
connections extends from the initial node to the end node via at least one super node; and,<br>
(vi) operating the processor to determine the cost-determined sequence of (run, index derivative) pairs from the least cost sequence of connections.<br>
4.	The method as claimed in claim 3, wherein step (c)(v) further comprises operating the processor to use dynamic programming to find the least cost sequence of connections in the plurality of connections, wherein the least cost sequence of connections extends from the initial node to the end node via at least one super node.<br>
5.	The method as claimed in claim 3, wherein step (c)(iv) further comprises:<br>
(i) operating the processor to provide an incremental rate cost, for each connection, representing an associated (run, index derivative) pair, from one of the initial node and an (i-r-l)th super node to an ith super node, as a number of bits needed to encode the run value of the associated (run, index derivative) pair and the index-based value derived from the associated (run, index derivative) pair;<br>
(ii) operating the processor to provide an incremental distortion cost, for each connection from one of the initial node and the (i-r-l)th super node to the ith super node, as a distortion incurred when the coefficient Ci is quantized to a value associated with the index-based value derived from the associated (run, index derivative) pair and all r coefficients appearing from coefficient Ci-r to coefficient Ci-1 are quantized to the special value; and<br>
(iii) operating the processor to provide the associated incremental cost, for each connection from one of the initial node and the (i-r-l)th super node to the 1th super node, as a function of the incremental distortion cost and the incremental rate cost.<br>
6.	The method as claimed in claim 3, wherein each (run, index derivative)<br>
pair is a (run, level) pair such that the index-based value is defined to be a level value<br><br>
defined as the value of the index following the number of consecutive indices of the special value.<br>
7.	The method as claimed in claim 6 wherein operating the processor to<br>
provide the plurality of connections between pairs of nodes including the initial node,<br>
the super nodes, and the end node comprises:<br>
(i) for each super node in the sequence of n super nodes, and for each predecessor node including the initial node preceding that super node in the sequence of n super nodes and the initial node, wherein that super node and that predecessor node are separated by a number of intermediary nodes not exceeding a maximum run value in the plurality of possible (run, level) pairs, operating the processor to establish a number of connections connecting that super node to that predecessor node equaling up to four times a maximum level magnitude in the plurality of possible (run, level) pairs, wherein each connection between a pair of connected nodes corresponds to a different level value;<br>
(ii) for each super node other than the last super node in the sequence of n super nodes, and for each predecessor node including the initial node preceding that super node in the sequence of n super nodes, wherein the number of intermediary nodes separating that super node and that predecessor node equals the maximum run value in the plurality of (run, level) pairs, operating the processor to establish up to two further connections connecting that super node to that predecessor node; and,<br>
(iii) for each node in the sequence of n super nodes and the initial node, operating the processor to establish a single connection to the end node.<br>
8.	The method as claimed in claim 7 wherein the run value and the level value of each (run, level) pair in the cost-determined sequence of (run, level) pairs are separately encoded by the processor.<br>
9.	The method as claimed in claim 8 wherein<br>
the sequence of n coefficients comprises a first group of coefficients and a second group of coefficients disjoint from the first group of coefficients; and<br><br>
operating the processor to encode the cost-determined sequence of (run, level) pairs comprises encoding the run value of each (run, level) pair in the cost-determined sequence of (run, level) pairs based on<br>
both the level value and an ordered location of the index preceding the number of consecutive indices of the special value associated with the run in the sequence of n coefficients, if the coefficient corresponding to the index preceding the number of consecutive indices of the special value associated with the run is in the first group of coefficients, and<br>
the ordered location of the index preceding the number of consecutive indices of the special value associated with the run in the sequence of n coefficients, if the coefficient corresponding to the index preceding the number of consecutive indices of the special value associated with the run is in the second group of coefficients.<br>
10.	The method as claimed in claim 9 wherein<br>
each super node having a corresponding coefficient in the first group of coefficients comprises two associated nodes;<br>
each super node having a corresponding coefficient in the second group of coefficients comprises a single associated node; and,<br>
the plurality of connections between pairs of super nodes comprises a plurality of connections between non-associated pairs of nodes representing the plurality of possible (run, level) pairs.<br>
11.	The method as claimed in claim 10 wherein operating the processor to<br>
provide the plurality of connections between pairs of super nodes further comprises:<br>
(i) for each super node in the sequence of n super nodes, determining an output level using a hard-decision quantizer defined by the given quantization table to quantize the corresponding coefficient in the sequence of n coefficients; and<br>
(ii) for each super node in the sequence of n super nodes, and for each predecessor node including the initial node preceding that super node in the sequence<br><br>
of n super nodes and the initial node, wherein the number of intermediary nodes separating that super node and that predecessor node does not exceed the maximum run value in the plurality of possible (run, level) pairs, operating the processor to establish a reduced number of connections connecting a node in that super node to that predecessor node (being the initial node or a super node), wherein each connection between a pair of connected nodes in the reduced number of connections corresponds to a different level value within a selected difference of the output level determined for that super node.<br>
12.	A method of operating the processor to compress a sequence of n<br>
coefficients by determining an output quantization table, a final cost-determined sequence of n coefficient indices represented by a final cost-determined sequence of (run, index derivative) pairs, and a run-index derivative coding distribution, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (i) each index in the corresponding sequence of coefficient indices is a digital number, (ii) the corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive indices of the special value, and an index-based value derived from a value of the index following the number of consecutive indices of the special value, and wherein a sequence of n coefficient indices, together with a given quantization table, determines a sequence of n soft-decision quantized coefficients, the method comprising the steps of:<br>
(a)	operating the processor to select a 0th quantization table;<br>
(b)	operating the processor to select a 0th run-index derivative coding distribution<br>
(c)	operating the processor to set a counter t equal to 0;<br>
(d)	using a tth quantization table and run-index derivative coding<br>
distribution, operating the processor to formulate a tth cost function for a tth plurality<br>
of possible sequences of (run, index derivative) pairs;<br><br>
(e)	operating the processor to apply the tth cost function to each<br>
possible sequence in the tth plurality of possible sequences of (run, index derivative)<br>
pairs to determine a tth associated cost of each of the tth plurality of possible<br>
sequences of (run, index derivative) pairs;<br>
(f)	operating the processor to select a tth cost-determined sequence of (run, index derivative) pairs from the tth plurality of possible sequences of (run, index derivative) pairs based on the t' associated cost of each of the tth plurality of possible sequences of (run, index derivative) pairs;<br>
(g)	if the tth cost-determined sequence of (run, index derivative) pairs together with the t quantization table and run-index derivative coding distribution meets a selection criterion, operating the processor to select the tth cost-determined sequence of (run, index derivative) pairs as the final cost-determined sequence of (run, index derivative) pairs and the tth quantization table as the output quantization table, otherwise operating the processor to determine a (t+l)th quantization table and run-index derivative coding distribution from the tth cost-determined sequence of (run, index derivative) pairs, increase t by one, and return to step (d); and<br>
(h) operating the processor to encode the final cost-determined sequence of (run, index derivative) pairs using entropy coding based on the tth run-index derivative coding distribution.<br>
13.	The method as claimed in claim 12 wherein step (b) comprises operating the processor to quantize in a hard-decision manner the sequence of n coefficients using the 0th quantization table operating the processor to determine a starting sequence of (run, index derivative) pairs, and then selecting an initial run-index derivative coding distribution of the starting sequence of (run, index derivative) pairs as the 0th run-index derivative coding distribution.<br>
14.	The method as claimed in claim 12, wherein step (e) comprises, for each possible sequence of (run, index derivative) pairs in the tth plurality of possible sequences of (run, index derivative) pairs:<br>
(i) operating the processor to determine a corresponding sequence of n coefficient indices;<br><br>
(ii) operating the processor to determine a corresponding sequence of n quantized coefficients using the tth quantization table and the corresponding sequence of n coefficient indices;<br>
(iii) operating the processor to determine a distortion between the sequence of n coefficients and the corresponding sequence of n quantized coefficients;<br>
(iv) operating the processor to determine a total compression rate resulting from using the tth run-index derivative coding distribution to encode the sequence of (run, index derivative) pairs; and<br>
(v) operating the processor to determine the tth associated cost of the sequence of (run, index derivative) pairs as a function of the distortion and the total compression.<br>
15.	The method as claimed in claim 12 wherein step (f) comprises<br>
(i) operating the processor to provide a sequence of n super nodes, each super node comprising at least one node, in one-to-one relation with the sequence of n coefficients, such that each coefficient Ci has a corresponding i super node wherein i is greater than or equal to 1 and less than or equal to n;<br>
(ii) operating the processor to provide an initial node preceding and an end node following the sequence of n super nodes;<br>
(iii) operating the processor to provide a plurality of connections between pairs of nodes including the initial node, the plurality of super nodes, and the end node to represent a plurality of possible (run, index derivative) pairs;<br>
(iv) operating the processor to determine the tth associated cost of each of the tth plurality of possible sequences of (run, index derivative) pairs by determining an associated incremental cost for each connection in the plurality of connections;<br>
(v) operating the processor to determine a least cost sequence of connections from the plurality of connections, wherein the least cost sequence of<br><br>
connections extends from the initial node to the end node via at least one super node; and,<br>
(vi) operating the processor to determine the tth cost-determined sequence of (run, index derivative) pairs from the least cost sequence of connections.<br>
16.	The method as claimed in claim 15 wherein step (f)(iv) further<br>
comprises<br>
(i) operating the processor to define an incremental rate cost, for each connection representing an associated (run, index derivative) pair, from one of an (i-r-l)th super node and the initial node to an ith super node, as a number of bits needed to encode the run value of the associated (run, index derivative), and the index-based value derived from the associated (run, index derivative) pair;<br>
(ii) operating the processor to define an incremental distortion cost, for each connection from one of the (i-r-l)th super node and the initial node to the ith super node, as a distortion incurred when the coefficient C, is quantized to a value associated with the index-based value and all r coefficients appearing from coefficient C1-r to coefficient Ci-1 are quantized to the special value; and<br>
(iii) operating the processor to define the associated incremental cost, for each connection from one of the (i-r-l)th super node and the initial node to the ith super node, as a function of the incremental distortion cost and the incremental rate cost.<br>
17.	The method as claimed in claim 15 wherein step (f)(v) further comprises operating the processor to use dynamic programming to find the least cost sequence of connections in the plurality of connections, wherein the least cost sequence of connections extends from the initial node to the end node via at least one super node.<br>
18.	The method as claimed in claim 12 wherein the (t+l)th quantization table in step (g) is derived from the tth cost-determined sequence of (run, index derivative) pairs by the processor solving a quadratic equation.<br><br>
19.	The method as claimed in claim 12 wherein the (t+l)th run-index derivative coding distribution in step (g) is selected as an empirical run-index derivative coding distribution of the tth cost-determined sequence of (run, index derivative) pairs.<br>
20.	The method as claimed in claim 15, wherein each (run, index derivative) pair is a (run, level) pair such that the index-based value is defined to be a level value defined as a value of the index following the number of consecutive indices of the special value.<br>
21.	The method as claimed in claim 20 wherein operating the processor to provide the plurality of connections between pairs of nodes including the initial node, the super nodes, and the end node comprises:<br>
(i) for each super node in the sequence of n super nodes, and for each predecessor node including the initial node and any super nodes preceding that super node in the sequence of n super nodes and the initial node, wherein that super node and that predecessor node are separated by a number of intermediary nodes not exceeding a maximum run value in the plurality of possible (run, level) pairs, operating the processor to establish a number of connections connecting that super node to that predecessor node equaling up to four times a maximum level magnitude in the plurality of possible (run, level) pairs, wherein each connection between a pair of connected nodes corresponds to a different level value;<br>
(ii) for each super node other than the last super node in the sequence of n super nodes, and for each predecessor node including the initial node preceding that super node in the sequence of n super nodes, wherein the number of intermediary nodes separating that super node and that predecessor node equals the maximum run value in the plurality of possible (run, level) pairs, operating the processor to establish up to two further connections connecting that super node to that predecessor node; and,<br>
(iii) for each node in the sequence of n super nodes preceded by the initial node, operating the processor to establish a single connection to the end node.<br><br>
22.	The method as claimed in claim 20 wherein the run value and the level value of each (run, level) pair in the final cost-determined sequence of (run, level) pairs are separately encoded by the processor.<br>
23.	The method as claimed in claim 22 wherein<br>
the sequence of n coefficients comprises a first group of coefficients and a second group of coefficients disjoint from the first group of coefficients; and<br>
operating the processor to encode the final cost-determined sequence of (run, level) pairs comprises encoding the run value of each (run, level) pair in the final cost-determined sequence of (run, level) pairs based on<br>
both the level value and an ordered location of the index preceding the number of consecutive indices of the special value associated with the run in the sequence of n coefficients if the coefficient corresponding to the index preceding the number of consecutive indices of the special value associated with the run is in the first group of coefficients, and<br>
the ordered location of the index preceding the number of consecutive indices of the special value associated with the run in the sequence of n coefficients if the coefficient corresponding to the index preceding the number of consecutive indices of the special value associated with the run is in the second group of coefficients.<br>
24.	The method as claimed in claim 23 wherein<br>
each super node having a corresponding coefficient in the first group of coefficients comprises two associated nodes;<br>
each super node having a corresponding coefficient in the second group of coefficients comprises a single associated node; and,<br>
the plurality of connections between pairs of super nodes comprises a plurality of connections between non-associated pairs of nodes representing the plurality of possible (run, level) pairs.<br><br>
25.	The method as claimed in claim 24 wherein operating the processor to<br>
provide the plurality of connections between pairs of super nodes further comprises:<br>
(i) for each super node in the sequence of n super nodes, operating the processor to determine an output level using a hard-decision quantizer defined by the given quantization table to quantize the corresponding coefficient in the sequence of n coefficients; and<br>
(ii) for each super node in the sequence of n super nodes, and for each predecessor node including the initial node preceding that super node in the sequence of n super nodes, wherein the number of intermediary nodes separating that super node and that predecessor node does not exceed the maximum run value in the plurality of possible (run, level) pairs, operating the processor to establish a reduced number of connections connecting a node in that super node to that predecessor node (being the initial node or a super node),wherein each connection between a pair of connected nodes in the reduced number of connections corresponds to a different level value within a selected difference of the output level determined for that super node.<br>
26.	A method of operating the processor to compress a sequence of<br>
sequences of n coefficients by jointly determining an output quantization table, an<br>
output run-index derivative coding distribution, and, for each sequence of n<br>
coefficients in the sequence of sequences of n coefficients, a final cost-determined<br>
sequence of coefficient indices represented by a final cost-determined sequence of<br>
(run, index derivative) pairs, wherein each sequence of (run, index derivative) pairs<br>
defines a corresponding sequence of coefficient indices such that (i) each index in the<br>
corresponding sequence of coefficient indices is a digital number, (ii) the<br>
corresponding sequence of coefficient indices includes a plurality of values including<br>
a special value, and (iii) each (run, index derivative) pair defines a run value<br>
representing a number of consecutive indices of the special value, and an index-based<br>
value derived from a value of the index following the number of consecutive indices<br>
of the special value, and wherein a sequence of n coefficient indices together with a<br>
given quantization table determines a sequence of n soft-decision quantized<br>
coefficients, the method comprising:<br><br>
(a)	operating the processor to select a 0th quantization table;<br>
(b)	operating the processor to select a 0th run-index derivative coding distribution<br>
(c)	operating the processor to set a counter t equal to 0;<br>
(d)	operating the processor to select a sequence of tth cost-determined sequences of (run, index derivative) pairs by, for each sequence of n coefficients in the sequence of sequences of n coefficients,<br>
(i) operating the processor to use a tth quantization table and run-index derivative coding distribution to formulate a tth cost function for an associated tth plurality of possible sequences of (run, index derivative) pairs;<br>
(ii) operating the processor to apply the tth cost function to each possible sequence in the associated tth plurality of possible sequences of (run, index derivative) pairs to determine an associated cost of each of the associated tth plurality of possible sequences of (run, index derivative) pairs;<br>
(iii) operating the processor to select an associated tth cost-determined sequence of (run, index derivative) pairs from the associated tth plurality of possible sequences of (run, index derivative) pairs based on the associated cost of each of the associated t plurality of possible sequences of (run, index derivative) pairs;<br>
(e)	after step (d), operating the processor to apply an aggregate cost function to the associated tth cost-determined sequence of (run, index derivative) pairs, for each sequence of n coefficients in the sequence of sequences of n coefficients, to determine a tth aggregate cost;<br>
(f)	if the tth aggregate cost meets a selection criterion, operating the processor to select the tth quantization table and run-index derivative coding distribution as the output quantization table and the output run-index derivative coding distribution, and, for each sequence of n coefficients in the sequence of sequences of n coefficients, the associated tth cost-determined sequence of (run, index derivative) pairs as the final cost-determined sequence of (run, index derivative) pairs;<br><br>
otherwise determining a (t+l)th quantization table and run-index derivative coding distribution from the selected sequence of tth cost-determined sequences of (run, index derivative) pairs, increasing t by one, and returning to step (d); and<br>
(g) operating the processor to encode each final cost-determined sequence of (run, index derivative) pairs using entropy coding based on the tth run-index derivative coding distribution.<br>
27.	The method as claimed in claim 26, wherein step (b) comprises operating the processor to comprise, for each sequence of n coefficients in the sequence of sequences of n coefficients, quantizing in a hard-decision manner the sequence of n coefficients using the 0th quantization table to determine a sequence of starting sequences of (run, index derivative) pairs, and then selecting an initial run-index derivative coding distribution of the sequence of starting sequences of (run, index derivative) pairs as the 0th run-index derivative coding distribution.<br>
28.	The method as claimed in claim 26, wherein step (d) further comprises, for each sequence of n coefficients in the sequence of sequences of n coefficients, and for each possible sequence of (run, index derivative) pairs in the associated tth plurality of possible sequences of (run, index derivative) pairs:<br>
operating the processor to determine a corresponding sequence of n coefficient indices;<br>
operating the processor to determine a corresponding sequence of n quantized coefficients using the tth quantization table and the corresponding sequence of n coefficient indices;<br>
operating the processor to determine an associated distortion between the sequence of n coefficients and the corresponding sequence of n quantized coefficients;<br>
operating the processor to determine an associated total compression rate resulting from using the tth run-index derivative coding distribution to encode the sequence of (run, index derivative) pairs; and<br><br>
operating the processor to determine the associated cost of the sequence of (run, index derivative) pairs as a function of the distortion and the total compression rate.<br>
29.	The method as claimed in claim 26, wherein step (d) comprises, for<br>
each sequence of n coefficients in the sequence of sequences of n coefficients:<br>
providing a sequence of n super nodes, each super node comprising at least one node, in one-to-one relation with the sequence of n coefficients, such that each coefficient Ci has a corresponding ith super node, wherein i is greater than or equal to 1 and less than or equal to n;<br>
operating the processor to provide an initial node preceding and an end node following the sequence of n super nodes;<br>
operating the processor to provide a plurality of connections between pairs of nodes including the initial node, the super nodes and the end node to represent a plurality of possible (run, index derivative) pairs;<br>
operating the processor to determine the associated cost of each of the associated tth plurality of possible sequences of (run, index derivative) pairs by determining an associated incremental cost for each connection in the plurality of connections;<br>
operating the processor to determine a least cost sequence of connections from the plurality of connections, wherein the least cost sequence of connections extends from the initial node to the end node via at least one super node; and<br>
operating the processor to determine the associated tth cost-determined sequence of (run, index derivative) pairs from the least cost sequence of connections.<br>
30.	The method as claimed in claim 29, wherein step (d) further comprises,<br>
for each sequence of n coefficients in the sequence of sequences of n coefficients,<br>
operating the processor using dynamic programming to find the least-cost sequence of<br>
connections in the plurality of connections, wherein the least cost sequence of<br>
connections extends from the initial node to the end node via at least one super node.<br><br>
31.	The method as claimed in claim 29, wherein step (d) further comprises,<br>
for each sequence of n coefficients in the sequence of sequences of n coefficients,<br>
operating the processor to define an incremental rate cost, for each connection representing an associated (run, index derivative) pair from one of the initial node and an (i-r-l)th super node to an ith super node, as a number of bits needed to encode the run value of the associated (run, index derivative) pair and the index-based value derived from the associated (run, index derivative) pair using the tth run-index derivative coding distribution;<br>
operating the processor to define an incremental distortion cost, for each connection from one of the initial node and the (i-r-l)th super node to the ith super node, as a distortion incurred when the coefficient C, is quantized to a value associated with the index-based value and all r coefficients appearing from coefficient C1-r to coefficient Ci-1 are quantized to the special value; and<br>
operating the processor to define the associated incremental cost, for each connection from one of the initial node and the (i-r-l)th super node to the ith super node, as a function of the incremental distortion cost and the incremental rate cost.<br>
32.	The method as claimed in claim 29 wherein each (run, index derivative) pair is a (run, level) pair such that the index-based value is defined to be a level value defined as a value of the index following the number of consecutive indices of the special value.<br>
33.	The method as claimed in claim 32, wherein operating the processor to provide the plurality of connections between pairs of nodes including the initial node, the super nodes and the end node comprises:<br>
for each super node in the sequence of n super nodes, and for each predecessor node including the initial node preceding that super node in the sequence of n super nodes and the initial node, wherein that super node and that predecessor node are separated by a number of intermediary nodes not exceeding a maximum run value in the plurality of possible (run, level) pairs, operating the processor to establish a number of connections connecting that super node to that predecessor node equaling<br><br>
up to four times a maximum level magnitude in the plurality of possible (run, level) pairs, wherein each connection between a pair of connected nodes corresponds to a different level value;<br>
for each super node other than the last super node in the sequence of n super nodes, and for each predecessor node including the initial node preceding that super node in the sequence of n super nodes, wherein the number of intermediary nodes separating that super node and that predecessor node equals the maximum run value in the plurality of possible (run, level) pairs, operating the processor to establish up to two further connections connecting that super node to that predecessor node; and,<br>
for each node in the sequence of n super nodes and the initial node, operating the processor to establish a single connection to the end node.<br>
34.	The method as claimed in claim 26, wherein the (t+l)th quantization table in step (f) is derived from the selected sequence of tth cost-determined sequences of (run, index derivative) pairs by solving a quadratic equation.<br>
35.	The method as claimed in claim 26, wherein the (t+l)th run-index derivative coding distribution in step (f) is derived from all of the tth cost-determined sequences of (run, index derivative) pairs in the selected sequence of t cost-determined sequences of (run, index derivative) pairs.<br>
36.	The method as claimed in claim 32 wherein the run value and the level value of each (run, level) pair in each final cost-determined sequence of (run, level) pairs are separately encoded by the processor.<br>
37.	The method as claimed in claim 36 wherein<br>
each sequence of n coefficients in the sequence of sequences of n coefficients comprises a first group of coefficients and a second group of coefficients disjoint from the first group of coefficients; and<br>
operating the processor to encode each final cost-determined sequence of (run, level) pairs comprises, for each sequence of n coefficients in the sequence of<br><br>
sequences of n coefficients, encoding the run value of each (run, level) pair in the final cost-determined sequence of (run, level) pairs based on<br>
both the level value and an ordered location of the index preceding the number of consecutive indices of the special value associated with the run in the sequence of n coefficients if the coefficient corresponding to the index preceding the number of consecutive indices of the special value associated with the run is in the first group of coefficients, and<br>
the ordered location of the index preceding the number of consecutive indices of the special value associated with the run in the sequence of n coefficients if the coefficient corresponding to the index preceding the number of consecutive indices of the special value associated with the run is in the second group of coefficients.<br>
38.	The method as claimed in claim 37 wherein, for each sequence of n<br>
coefficients in the sequence of sequences of n coefficients,<br>
each super node having a corresponding coefficient in the first group of coefficients comprises two associated nodes;<br>
each super node having a corresponding coefficient in the second group of coefficients comprises a single associated node; and,<br>
the plurality of connections between pairs of super nodes comprises a plurality of connections between non-associated pairs of nodes representing the plurality of possible (run, level) pairs.<br>
39.	The method as claimed in claim 38 wherein, for each sequence of n<br>
coefficients in the sequence of sequences of n coefficients, providing the plurality of<br>
connections between pairs of super nodes further comprises:<br>
(i) for each super node in the sequence of n super nodes, operating the processor to determine an output level using a hard-decision quantizer defined by the given quantization table to quantize the corresponding coefficient in the sequence of n coefficients; and<br><br>
(ii) for each super node in the sequence of n super nodes, and for each predecessor node including the initial node preceding that super node in the sequence of n super nodes and the initial node, wherein the number of intermediary nodes separating that super node and that predecessor node does not exceed the maximum run value in the plurality of possible (run, level) pairs, operating the processor to establish a reduced number of connections connecting a node in that super node to that predecessor node (being the initial node or a super node), wherein each connection between a pair of connected nodes in the reduced number of connections corresponds to a different level value within a selected difference of the output level determined for that super node.<br>
40.	A data processing system for compressing a sequence of n coefficients by determining a cost-determined sequence of n coefficient indices represented by a cost-determined sequence of (run, index derivative) pairs under a given quantization table and run-index derivative coding distribution, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (i) each index in the corresponding sequence of coefficient indices is a digital number, (ii) the corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive indices of the special value, and an index-based value derived from a value of the index following the number of consecutive indices of the special value, the data processing system comprising a processor, memory and instructions stored on the memory for configuring the processor to perform the method of any one of claims 1 to 11.<br>
41.	A data processing system for compressing a sequence of n coefficients by determining an output quantization table, a final cost-determined sequence of n coefficient indices represented by a final cost-determined sequence of (run, index derivative) pairs, and a run-index derivative coding distribution, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (i) each index in the corresponding sequence of coefficient indices is a digital number, (ii) the corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive<br><br>
indices of the special value, and an index-based value (derived from a value of the index following the number of consecutive indices of the special value, and wherein a sequence of n coefficient indices, together with a given quantization table, determines a sequence of n soft-decision quantized coefficients, the data processing system comprising a processor, memory and instructions stored on the memory for configuring the processor to perform the method of any one of claims 12 to 25.<br>
42. A data processing system for compressing a sequence of sequences of<br>
n coefficients by jointly determining an output quantization table, an output run-index derivative coding distribution, and, for each sequence of n coefficients in the sequence of sequences of n coefficients, a final cost-determined sequence of coefficient indices represented by a final cost-determined sequence of (run, index derivative) pairs, wherein each sequence of (run, index derivative) pairs defines a corresponding sequence of coefficient indices such that (i) each index in the corresponding sequence of coefficient indices is a digital number, (ii) the corresponding sequence of coefficient indices includes a plurality of values including a special value, and (iii) each (run, index derivative) pair defines a run value representing a number of consecutive indices of the special value, and an index-based value derived from a value of the index following the number of consecutive indices of the special value, and wherein a sequence of n coefficient indices together with a given quantization table determines a sequence of n soft-decision quantized coefficients, the data processing system comprising a processor, memory and instructions stored on the memory for configuring the processor to perform the method of any one of claims 26 to 39.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctQWJzdHJhY3QtKDAxLTExLTIwMTEpLnBkZg==" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Abstract-(01-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">249-delnp-2007-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctYXNzaWdubWVudC5wZGY=" target="_blank" style="word-wrap:break-word;">249-delnp-2007-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctQ2xhaW1zLSgwMS0xMS0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Claims-(01-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">249-delnp-2007-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctQ29ycmVzcG9uZGVuY2UgT3RoZXJzLSgwMS0xMS0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Correspondence Others-(01-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctQ29ycmVzcG9uZGVuY2UgT3RoZXJzLSgwMi0wNy0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Correspondence Others-(02-07-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctQ29ycmVzcG9uZGVuY2UgT3RoZXJzLSgwNC0wMy0yMDEzKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-delnp-2007-Correspondence Others-(04-03-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctQ29ycmVzcG9uZGVuY2UgT3RoZXJzLSgwNi0wNy0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-delnp-2007-Correspondence Others-(06-07-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctQ29ycmVzcG9uZGVuY2UgT3RoZXJzLSgxOC0xMC0yMDEzKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-delnp-2007-Correspondence Others-(18-10-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctQ29ycmVzcG9uZGVuY2UgT3RoZXJzLSgyNC0wNi0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Correspondence Others-(24-06-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctQ29ycmVzcG9uZGVuY2UtT3RoZXJzLSgwMy0xMS0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-delnp-2007-Correspondence-Others-(03-11-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctQ29ycmVzcG9uZGVuY2UtT3RoZXJzLSgyNi0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Correspondence-Others-(26-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctQ29ycmVzcG9uZGVuY2UtT3RoZXJzLSgyNi0xMi0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Correspondence-Others-(26-12-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctQ29ycmVzcG9uZGVuY2UtT3RoZXJzLSg0LTEtMjAxMCkucGRm" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Correspondence-Others-(4-1-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctY29ycmVzcG9uZGVuY2Utb3RoZXJzLTEucGRm" target="_blank" style="word-wrap:break-word;">249-delnp-2007-correspondence-others-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctQ29ycmVzcG9uZGVuY2UtT3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Correspondence-Others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-delnp-2007-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctRHJhd2luZ3MtKDAxLTExLTIwMTEpLnBkZg==" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Drawings-(01-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">249-delnp-2007-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctRm9ybS0xLSgwMS0xMS0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Form-1-(01-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctZm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">249-delnp-2007-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctZm9ybS0xMy0oMjYtMDktMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">249-delnp-2007-form-13-(26-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctZm9ybS0xOC5wZGY=" target="_blank" style="word-wrap:break-word;">249-delnp-2007-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctRm9ybS0yLSgwMS0xMS0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Form-2-(01-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctZm9ybS0yLnBkZg==" target="_blank" style="word-wrap:break-word;">249-delnp-2007-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctRm9ybS0zICg0LTEtMjAxMCkucGRm" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Form-3 (4-1-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctRm9ybS0zLSgwMi0wNy0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Form-3-(02-07-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctRm9ybS0zLSgwMy0xMS0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-delnp-2007-Form-3-(03-11-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctRm9ybS0zLSgwNC0wMy0yMDEzKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-delnp-2007-Form-3-(04-03-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctRm9ybS0zLSgxOC0xMC0yMDEzKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-delnp-2007-Form-3-(18-10-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctRm9ybS0zLSgyNC0wNi0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Form-3-(24-06-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctRm9ybS0zLSgyNi0xMi0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Form-3-(26-12-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctRm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctRm9ybS01LSgwMS0xMS0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Form-5-(01-11-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">249-delnp-2007-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctR1BBLSgyNi0wOS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-GPA-(26-09-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctZ3BhLnBkZg==" target="_blank" style="word-wrap:break-word;">249-delnp-2007-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctcGN0LW5vdGlmaWNhdGlvbi5wZGY=" target="_blank" style="word-wrap:break-word;">249-delnp-2007-pct-notification.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctcGN0LXNlYXJjaCByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">249-delnp-2007-pct-search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctUGV0aXRpb24tMTM3LSgwMi0wNy0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Petition-137-(02-07-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctUGV0aXRpb24tMTM3LSgwNi0wNy0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-delnp-2007-Petition-137-(06-07-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctUGV0aXRpb24tMTM3LSgxOC0xMC0yMDEzKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-delnp-2007-Petition-137-(18-10-2013).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LURFTE5QLTIwMDctUGV0aXRpb24tMTM3LSgyNi0xMi0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">249-DELNP-2007-Petition-137-(26-12-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjQ5LWRlbG5wLTIwMDctUGV0aXRvbi0xMzctKDA0LTAzLTIwMTMpLnBkZg==" target="_blank" style="word-wrap:break-word;">249-delnp-2007-Petiton-137-(04-03-2013).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="258502-a-network-statistics-processing-device-for-a-communication-network.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="258504-a-mehod-for-administraition-of-communication-sessions-in-a-packet-oriented-communication-system.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>258503</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>249/DELNP/2007</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>03/2014</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>17-Jan-2014</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>16-Jan-2014</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>09-Jan-2007</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SLIP STREAM DATA INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>50 BATHURST DRIVE,SUITE 12 WATERLOO,ON N2Y2CS,CANADA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>YANG EN-HUI</td>
											<td>203 BEAVER CREEK ROAD, WATERLOO, ONTARIO N2T 2R8 CANADA.</td>
										</tr>
										<tr>
											<td>2</td>
											<td>WANG LONGJI</td>
											<td>207-170 WISSLER ROAD, WATERLOO, ONTARIO N2K 2V1 CANADA.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H03M 7/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/CA2005/001084</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-07-13</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/587,555</td>
									<td>2004-07-14</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/588,380</td>
									<td>2007-07-16</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/258503-method-system-and-computer-program-product-for-optimization-of-data-compression by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:22:10 GMT -->
</html>
