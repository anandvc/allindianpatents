<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/203123-method-for-modifying-root-growth by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:02:40 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 203123:METHOD FOR MODIFYING ROOT GROWTH</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD FOR MODIFYING ROOT GROWTH</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>METHOD FOR MODIFYING ROOT GROWTH</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT,   1970<br>
[39 OF 1970]<br>
COMPLETE SPECIFICATION [See Section 10; Rule 13]<br>
"METHOD FOR MODIFYING ROOT GROWTH"<br>
INTEL CORPORATION, a corporation incorporated in the State, of Delaware, of 2200 Mission College Boulevard, Santa Clara, California 95052, United States of America,<br><br>
The following specification particularly describes the nature of the invention  and the manner in  which it is to  be  performed:-<br><br>
the present invention relates to a methd for processing data.<br>
Technical Field The present invention relates to graphics systems and, in<br>
particular, to mechanisms for processing depth or z-daia for 3 dimensional (3D) graphics<br>
in a manner that is transparent to the user.<br>
Background Art. Available computer systems typically include dedicated graphics resources to support the graphics-intensive applications that are prevalent today. Graphics applications, particularly those providing 3D effects, require rapid access to large amounts of graphics data.<br>
A standard method for generating a 3D image begins with sets of primitives that represent the surfaces of each object in the image. Primitives are typically polygons such as triangles or rectangles that may be tiled to form a surface. An object that has a moderately complex shape may require thousands of primitives to represent its surface, and an image that includes multiple objects may require tens or even hundreds of thousands of primitives. Depth, color, texture, illumination and orientation data for each of these primitives must be processed and converted to pixel level data to generate a 3D image on a display device.<br>
Image processing is often Implemented through a 3D pipeline that includes a geometry or set-up phase and a rendering or scan-conversion phase. In the geometry phase, the orientation of each primitive and the location of any light sources that illuminate the primitive are determined with respect to a reference coordinate system and<br><br>
specified by vectors associated with the primitive"s vertices. This vertex data is then transformed to a viewing or camera coordinate system and rotated to a desired orientation.<br>
In the scan conversion phase, the graphics primitives for each object in an image are converted into a single set of pixel values that provide a 2D representation of the 3D image. The pixels that make up the 2D image are typically stored in the entries of a frame buffer from which the display is generated. A well-known mechanism for populating the frame buffer generates color values for each location of a primitive by interpolating the transformed vertex data for the primitive. Since primitive locations are specified in 3D space, multiple primitive locations may map to the same frame buffer entry (pixel) of the 2D display surface. The generated color value for a primitive location is stored in the frame buffer entry to which it maps or discarded, according to whether or not it is visible in the final image. During this phase, texture data may also be determined for the primitives.<br>
One technique for determining which locations of each primitive are visible in the final image employs a z-buffcr. The z-buffer includes an entry for each pixel in the frame buffer. Each z-buffer entry is initialized to zero or other reference value. Often, the reference value represents a back clipping plane of the image. During scan conversion, a z-value is determined for each location within the primitive and compared with the entry in the z-buffer to which the primitive location maps. If the value in the z-buffer is closer to the viewer than the z-value determined for the corresponding primitive location, the primitive location is not visible in the final image, and its color value is discarded. If the value in the z-buffer is further from the viewer than the z-value determined for the corresponding primitive location, the color value for the location is stored in the<br><br>
appropriate entry of the frame buffer. If the color value is not replaced be Fore scan conversion completes, it is displayed in the final image.<br>
Significant amounts of texture, color and z-data are transferred between memory and the graphics resources during the rendering stage. Since there may be tens to hundreds of pixels per primitive, these data transfers can place significant burdens on the bandwidth of the memory channel. The consequent reduction in memory bandwidth can reduce the performance of the graphics system. This is particularly true if the graphic system is implemented in a computer system that employs a unified memory architecture (UMA). For UNIA-based computer systems, the central processor unit(s) (CPU) and graphics engine have equal access to main memory. Memory demands by the graphics engine can reduce CPU performance. In addition, memory demands by one unit of the graphics engine can reduce the performance of other units. For example, any bandwidth used to transfer z-data for z-testing is unavailable to the unit that determines pixel textures, and the loss in bandwidth can reduce its performance.<br>
The present invention addresses these and other issues associated with memory bandwidth in graphics systems.<br>
According to the present invention there is provided a method for processing data comprising:<br>
storing blocks of data in entries of a first memory location, each of the blocks of data being stored in one of a cleared, compressed, or uncompressed data states;<br>
monitoring operations to the first memory location for a selected operation; and if the selected operation is detected, implementing a modified version of the selected operation that masks differences between the data states of the data blocks, wherein implementing the modified version of the selected operation includes saving a current processor state; reading one or more data blocks according to their data states in response to the selected operation; and writing the read data back into the entries of the first memory location in an uncompressed state before performing the selected operation on the data in the uncompressed state.<br>
Brief Description of the Drawings<br>
The present invention may be understood with reference to the following drawings, in which like elements are indicated by like numbers. These drawings are provided to illustrate selected embodiments of the present invention and are not intended to limit the scope of the invention.<br>
Figs. 1 is a diagram representing one mapping between the locations of a primitive and blocks of pixel-level data.<br><br>
Fig. 2 is a schematic representation of a graphics pipeline suitable for scan converting primitive data into pixel data.<br>
Fig. 3 is a block diagram of one embodiment of a computer system that implements a z-compression mechanism in accordance with the present invention.<br>
Fig. 4 is a block diagram of one embodiment of a z-compression system in which blocks of z-data and their associated status data are distributed between a local cache and a main memory.<br>
Fig. 5A is a block diagram of one embodiment of a local cache system to store both z-data values and associated status values.<br>
Fig. 5B is a block diagram representing a mechanism for updating the local cache system of Fig. 5 A on a TLB miss.<br>
Fig, 6 A is a schematic representation of another embodiment of a local cache system to store both z-data values and associated status values.<br>
Fig. 6B is a state machine representing the state changes for the entries of the local cache of Fig. 6 A.<br>
Fig. 6C is a schematic representation of a mechanism for updating the local cache system of Fig. 6 A on a TLB miss.<br>
Fig. 7 is one embodiment of a memory map that is suitable for storing status values for data blocks in a linear memory region.<br>
Figs. 8A and 8B represent embodiments of 16-bit and 32-bit z-data formats that may be compressed using a mechanism in accordance with the present invention.<br>
Fig. 9 represents one embodiment of compressed format for z-data that may be used by a system implementing the present invention.<br><br>
Figs. 10A-10C are flowcharts representing embodiments of methods for implementing memory reads, memory writes, and status updates for blocks of z-data.<br>
Fig. 11 is a flowchart representing one embodiment of a method for implementing z-compression transparently<br>
Fig. 12 is a flowchart representing one embodiment of a method for implementing accesses to the z-buffer transparently<br>
Figs. 13A-13C are flowcharts representing embodiments of different methods for clearing the z-buffer transparently.<br>
Detailed Description of the Invention<br>
The following discussion sets forth numerous specific details to provide a thorough understanding of the invention. However, those of ordinary skill in the art, having the benefit of this disclosure, will appreciate that the invention may be practiced without these specific details. In addition, various well-known methods, procedures, components, and circuits have not been described in detail in order to focus attention on the features of the present invention.<br>
Fig. 1 is a schematic representation of a graphics primitive 100 and a subset of data blocks 110(a), 110(b) (generically, "data blocks 110") to which corresponding locations (x, y) in primitive 100 are mapped in a viewing coordinate system. Multiple graphics primitives 100 are used to approximate the surface of an object that is to be represented in an image. While graphics primitive 100 is shown as a triangle, it is well know that any type of polygon may be used to represent the surface of an object. Similarly, embodiments of the present invention are illustrated with reference to data blocks 1 10<br><br>
comprising 4x4 arrays of pixels (spans), but other data block configurations may also be used.<br>
Colors, texture coordinates, and depths (c, t, z) are associated with vertices 120(a), 120(b), 120(c) of primitive 100. Other attributes, such as fog and alpha (not shown) may also be assigned to vertices. These vertex properties are then interpolated to provide values for all primitive locations (x, y), which may be mapped to the pixels of data blocks 110. For the disclosed representation, data blocks 110(b) are spans for which all component pixels are mapped from locations within primitive 100. Data blocks 110(a) are spans for which pixel values are mapped from locations that straddle one or more boundaries of primitive 100. That is, not all pixels of data blocks I 10(a) correspond to locations within primitive 100.<br>
Fig. 2 represents one embodiment of a graphics processing pipeline 200 to implement scan conversion. Z-data is read 210 from the entries of a z-buffer to which a given primitive maps. Vertex data for the primitive is interpolated 220 to generate, e.g. color, texture, and z data for each primitive location. For example, z-data for each location (x, y) of a primitive may be generated from the primitive"s vertex data, using a surface function of the form z - Co + Cx»x + Cy«y, as discussed below. Color values and texture coordinates may be generated for each location during this stage as well.<br>
In subsequent stages of pipeline 200, image-refining techniques, such as texture mapping, bump mapping, alpha-blending and the like, may be executed 230. A z-tcst 240 determines which locations of the primitive, if any, contribute their color values to the frame buffer, i.e. which portions of the primitive will be visible in the 2D image. If the z-value determined for a location passes the z-test, the appropriate entries in the frame and<br><br>
z-buffers are updated with the color and z-values, respectively, of the primitive location. Otherwise, the values are discarded.<br>
The transfer of graphics data between the graphics engine and memory locations in the frame and z-buffers, reduces the available memory bandwidth. For memory architectures like UMA, this reduction can have a detrimental effect on a computer system"s overall performance. Various methods have been proposed for reducing the bandwidth impact of texture data transfers. The present invention provides a mechanism for reducing the impact of depth-buffering and its associated data transfers on system performance.<br>
Fig. 3 is a block level diagram of one embodiment of a computer system 300 that implements z-compression in accordance with the present invention. Computer system 300 includes a processor core 310, a graphics core 320 and a memory system 330. Processor core 310 and graphics core 320 are coupled to a bus or memory channel 340 to transfer data to and from memory system 330. The dashed line indicates a boundary of an integrated circuit die 370 for an embodiment of computer system 300 in which processor core 310 and graphics core 320 are integrated on a single chip. This embodiment of computer system 300 is likely to implement a unified memory architecture (UMA), for which the features of the present invention may provide significant advantages. The present invention is not, however, limited to computer systems that employ integrated graphics and processor cores or UMA.<br>
For the disclosed embodiment of computer system 300, memory system 330 is shown straddling a boundary of die 370 to indicate that it may include on-chip and off-chip components. For example, memory system 330 typically includes one or more caches located on circuit die 370 and a main memory that is located on a separate circuit<br><br>
die. Memory system 330 further comprises a z-buffcr 350 and a z-status table (ZST) 360, portions of which may be distributed between on and off-chip memory structures (Fig. 4). As discussed below in greater detail, ZST 360 provides status information for associated entries in z-buffer 350. This status information may be used to reduce or eliminate data transfers on memory channel 340.<br>
One embodiment of ZST 360 includes entries to track a current status for each block of z-data stored in z-buffer 350. The status indicates how the corresponding z-data block is stored and maybe used to manage the transfer of data between graphics core 320 and memory 330. The status may indicate, for example, whether z-data for a particular span is in a compressed format or an uncompressed format, or whether it has a reference value that may be provided from a local storage location, such as a register. Compressed z-data may be transferred with significantly lower impact on the bandwidth of memory channel 340 than uncompressed data. Further, z-dala that is available in, e.g., a local register, need not consume any memory bandwidth at all. One or more components of graphics core 320 use ZST 350 to manage z-data transfers more efficiently and with lower impact on the bandwidth of the memory channel.<br>
For one embodiment of ZST 360, each entry stores a 2-bit status code to indicate a data status for a corresponding data block. Table 1 summarizes one set of 4-bit status codes that may be used.<br>
Table I<br><br><br>
For example, each image may be initialized with all entries of z-buffer 350 in a cleared state (00), The status values in ZST 360 may be adjusted as the initialized values in the z-buffer are updated during scan conversion. Depending on the status code, a z-buffer access may be executed normally, a compressed z-buffer access may be implemented or the z-buffer access may be avoided altogether. The last two options reduce the impact of z-data accesses on memory channel bandwidth.<br>
In the following discussion, a block of z-data in which each z-value represents a constant reference depth is referred to as "cleared". This depth may correspond to a back clipping plane in the image space. Since this value is a constant, it may be stored in a register that is local to graphics core 320. When an access targets a span having a cleared data status (00), the cleared value can be read from the local register, eliminating the z-buffer access and preserving memory channel bandwidth. If an access targets a data block that is designated as compressed (10), the targeted z-data may be retrieved in a compressed format and decompressed for use. As discussed below, compression reduces the size of the data block transferred for, e.g., z-testing, which saves memory channel bandwidth, (fan access targets a data block that is designated as uncompressed (01), the access transfers an uncompressed block of z-data and no decompression is implemented.<br>
Z-compression need not apply uniformly to all data stored in z-buffer 350. For example, a determination to write data to z-buffer 350 in compressed or uncompressed format may be made, in part, by reference to the relationship between the data block to be written and the primitive iocations that map to the data block. A data block I 10(b) that represents locations within the boundaries of primitive 100 can usually be compressed. As discussed below, exceptions may arise if the z-value also includes a stencil field or if<br><br>
certain clipping or saturation conditions prevail. A data block 1 10(a) to which locations straddling a primitive boundary are mapped, is usually not compressed. Where compression is implemented through a surface function (Eq. I), the z-values for locations on different sides of the primitive"s boundaries may be governed by different surface functions. This z-compression scheme can generate erroneous results if a location outside the primitive is compressed using a surface equation that is only suitable for locations within the primitive.<br>
Fig. 4 represents one embodiment of a z-compression system 400 that may be used to implement the present invention. Compression system 400 includes a read/write unit 410, a local cache 430, a main memory 440, and a local register 490.  Main memory 440 and local cache 430 represent, for example, off-chip and on-chip components, respectively, for one embodiment of memory system 330. Read/write unit 410 implements memory access requests that originate from various units of graphics core 320, according to the status information associated with the data block(s) targeted by the access. Local cache 430 includes local copies of the status and z-data blocks for processing memory accesses. Requests that cannot be satisfied from local cache 430 are satisfied from main memory 440.<br>
For a memory read access, read/write unit 410 determines from the status of a targeted data block whether the data block is in a compressed, uncompressed, or cleared state, and retrieves the targeted data from local cache 430, main memory 440 or local register 490 through a transfer appropriate to the indicated status. For a memory write access, read/write unit 410 uses information on the targeted data to determine whether to store it in a compressed, uncompressed, or cleared state, and it updates an associated data status accordingly.<br><br>
Also shown in Fig. 4 are a color calculation unit (CCU) 450 and an interpolation unit (ITU) 460 that may provide input to embodiments of z-compression system 400 to implement data accesses. For example, CCU 450 determines color values from vertex data, and indicates to read/write unit 410 whether a data block may be compressed. ITU 460 determines pixel level z-values from primitive vertex data and provides read/write unit 410 with parameters that may be used to compress/decompress data blocks.<br>
Fig. 5 A is a block diagram showing one embodiment of local cache system 500 that stores both z-data and data status information for cached data block entries. Storing both z-data and data status for data blocks in the same cache allows memory accesses, the form of which depends on data status information, to be processed more efficiently.<br>
The disclosed embodiment of local cache system 500 includes read/write unit 410, local cache 430 and a translation unit 510. Translation unit 510 includes a z-status cache (ZSTC) 520 and a z-translation-lookaside buffer (ZTLB) 530. ZTLB 530 stores logical-to-physical memory address translations for z-data. ZSTC 520 stores status information for the z-data to which ZTLB 530 points. For one embodiment of cache system 500, each entry of ZTLB 530 stores a translation for a page of physical memory allocated to the z-buffer and ZSTC 520 stores the status data for the z-entries stored on the page. As discussed below in greater detail, status information from ZSTC 520 is used to control the size of z-data reads and writes to main memory 440.<br>
The disclosed embodiment of local cache 430 includes a tag array 564, a data array 568 and hit/miss unit 570. Each entry 560 includes a tag field (TAG) a status field (STATUS) stored in tag array 564, and a data field (DATA) stored in data array 568. TAG stores a logical address (or portion thereof) which may be used to implement look¬ups to local cache 430. STATUS stores status bits for the data block that is indexed by<br><br>
TAG, and DATA stores the block of z-data values. The disclosed embodiment of read/write unit 410 includes a read unit 540 and a write unit 550. Main memory 440 and memory channel 340 are also shown in Fig. 5.<br>
For one embodiment of system 500, a look-up of local cache 430 is triggered in response to a memory access. For example, hit/miss unit 570 compares a logical address (or portion thereof) specified by a read access with the tag fields of entries 560. If the access hits, the value in STATUS is provided to read unit 540, which determines an appropriate data retrieval flow. For compressed data (STATUS = 10) and uncompressed data (STATUS = 01), read unit 540 retrieves the data from the hit entry, using an appropriately sized transfer. Compressed (CMP) data is decompressed and forwarded to the requestor, which may be CCU 450 for the disclosed embodiment of system 500. Uncompressed (UNC) data is forwarded to the requestor without decompression. For cleared data (STATUS - 00), read unit 540 provides the cleared data to the requestor from local register 490.<br>
For one embodiment local cache system hit/miss unit 570 considers STATUS &amp; TAG to determine whether an access "hits" or "misses" in local cache 430. For example, an access targeting uncompressed data may hit wholly or partially in local cache 430 according to the following criteria:<br>
Hit	= Tag_Match &amp; No_Blocking &amp; [(UNC &amp; QW_Match 1 CMP |<br>
CLEAR]<br>
Partial_Hit      = Tag_Match.&amp; No_Blocking &amp; (UNC &amp; IQW-mtatch)<br>
Miss	= !Tag_Match<br>
Here, Tag-Match indicates whether the tag identifying the address to be accessed matches a tag in the cache, No_B!ocking indicates whether the another access stalls the current<br><br>
access, and QVV^Match indicates which portion of a data is being sought in the cache line or data block identified by the tag. Q W_Match may be used for embodiments of local cache 430 that allow the QWs of a data block to be accessed separately. A partial hit occurs when a line is allocated for the tag in the cache (Tag_Match) but the particular quadword sought is not available in the cache.<br>
If hit/miss unit 570 determines a read access missed in local cache 430, a look-up is initiated to translation unit 510. For the disclosed embodiment of replacement unit 510, entries of ZTLB 530 include logical-to-physical address translations that are indexed by a logical address tag field, and ZSTC 520 stores status bits for each data block tracked in ZTLB 530. If the look-up hits in translation unit 510, the status bits indicate the state of the data block(s) at the indicated physical address in main memory 440. If STATUS = cleared, the z-values of the "cleared" data block are provided from local register 490, and no traffic is generated on memory channel 340. If STATUS = compressed or uncompressed, the data block is retrieved from main memory 440 by executing a partial fetch or a full fetch, respectively, to the indicated physical address. Depending on the z-data format, e.g. 32-bit or 16-bit, the partial fetch uses Vz to % of the bandwidth used by the full fetch.<br>
Fig. 5B represents a mechanism for updating translation unit 510 in the event that the look-up does not hit in ZTLB 530 ("TLB-miss"). For the disclosed embodiment, a graphics translation table (GTT) 574 is used to translate the, e.g., 4Kbyte pages of an Advanced Graphics Port (AGP) memory to physical addresses. GTT 574 includes entries for Z-buffer 350 and for ZST 360. A ZSTC Pointer Table (ZPT) 578 stores pointers to locations in ZST 360. That is, ZPT 578 operates like a TLB for ZST 360.<br><br>
On an initial TLB-miss, GTT 574 provides the missed TLB translation to ZTLB 530. Pointers from GTT 574 are also read into ZPT 57S, and the pointer associated with the missed TLB entry is used to retrieve the corresponding status data from ZST 360. The updated translation is used to retrieve the targeted data block in main memory 440 according to the updated status data. Data array 568 and tag array 564 arc updated with the retrieved z-data and its status, respectively. In general, ZSTC 520 is updated whenever the status of a data block is changed. When an entry in ZTLB 530 is replaced, the corresponding entry in ZSTC 520 is written back to memory.<br>
Fig. 6A is a block diagram of an embodiment of a local cache system 600 that includes a physicaily addressed local cache 430. The disclosed embodiment of local cache 430 includes translation unit 610, tag array 620, data array 624, hit/miss unit 630, replacement unit 634, and output selection unit 638. Read/write unit 4 10 moves data in and out of local cache 430 and register 490. CMPRS and DCMPRS compress and decompress data, respectively, for transfer to and from data array 624. Data array 624 stores data blocks that are indexed by physical addresses (or portions thereof), which are stored in tag array 620. The data block targeted by a memory access is specified through a iogical address, such as the primitive or span coordinates (x, y) of the data block.<br>
Translation unit 610 provides iogical to physical address translations that allow local cache 430 to be searched for data targeted by a memory access. Translation unit 610 includes a ZSTC 614 and a ZTLB 618, which provide functions similar to those provided by ZSTC 520 and ZTLB 530.  When an address hits in ZTLB 618, the hit entry provides the physical address to which the logical address is mapped and a corresponding entry of ZSTC 614 provides a status for the data.  Embodiments of cache system 600 may update<br><br>
tag array with status data for the entry. Hit/miss unit 630 compares the physical address with the entries in tag array 620.<br>
For accesses that miss in tag array 620, replacement unit 634 determines which of the current entries will be allocated to receive the data returned from a higher memory ~" structure. For accesses that hit in tag array 620, output selection unit 638 indicates the hit entry to data array 624 and the status information from tag array 620 determines how the data is retrieved. For an embodiment that stores one span per cache line, if the targeted data is compressed, half a cache line is retrieved from data array 660, decompressed, and forwarded to the requestor. If the targeted data is uncompressed, a full cache line is retrieved from data array 660 and forwarded to the requestor without decompression. If the targeted data is cleared, the data is retrieved from local register 490 and forwarded to the requestor.<br>
Read/write unit 410 includes a MUX 644 in read unit 640 to provide data responsive to its associated status. A MUX 648 in write unit 650 provides similar support for data being written to local cache 430. Status information is coupled to read/write unit 410 to indicate how the data being transferred should be handled.<br>
Fig. 6B shows one embodiment of a state machine representing the state changes possible for an entry of data array 624. Before the entry is allocated, it is in an invalid state 654. When the entry is allocated to a data block, its status is updated to cleared (CLR 658), compressed (CMP 660), uncompressed (UNC 664) or uncompressed_all (UNC_A 668), according to the status of the data block to which it is allocated. For the disclosed embodiment, the status is indicated by a corresponding entry in ZSTC 614.  For caches that allow less then a full line of data to be loaded, UNC and UNC_A distinguish between cache lines that are partially and fully populated, respectively, with data.  Entries that store<br><br>
data blocks in CLR 658 or CMP 660 may transition to UNC-A 668 when if the previously cleared or compressed data blocks are written back to the cache in an uncompressed state. Since only full data blocks may be CLR 658 or CMP 660, no transition is provided between these states and UNC 664.<br>
If a data block that has been altered is evicted from local cache 430, the status of the evicted data block indicates the operations to be implemented. For example, if the data block in state CLR 658 is evicted, nothing is written back to a higher memory level, and the status of the entry from which the data block is evicted is updated to indicate the status of the new data block. If a data block in state CMP 660 is evicted, the portion of the cache line storing the compressed data, e.g. half the cache line, is written back to memory. If a data block in state UNC 664 is evicted, the altered bytes are written back to memory, and if a data block in state UNC_A is evicted the full cache fine is wrinen back to memory. In each case, the entry state is updated in the ZSTC to track the status of the evicted data block. When an entry is evicted from ZTLB 618, the corresponding bits of ZSTC 614 are written back to ZST 360.Fig. 6C represents a mechanism for updating translation unit 610 if a logical address misses in ZTLB 618. For the disclosed embodiment, a miss triggers a read to a page table 690, which provides a TLB entry indicated by the access. ZTLB 618 is updated with the new TLB entry and ZSTC 614 is updated with the status data for all data blocks on the page. The targeted cache line is loaded into data array 624 from the indicated address in Z-buffer 350, and the state in tag array 620 is updated to a reflect the (storage) state of the data block.<br>
Figs. 5A, 5B and 6A-6C illustrate various features of two embodiments of a cache system that is suitable for handling mixed status and data information.  For both embodiments, the data arrays may store data in compressed and uncompressed formats (or<br><br>
not at all, in the case of cleared entries). Cache management logic moves the data in and out of the data array according to its associated status, and controls operations to an external memory according to the status.   The TLBs provide access to both the z-data blocks and their associated status. Status is stored per data block in a tag array and per memory page in the translation unit (ZSTC). While these cache systems have been described as part of a z-compression mechanism, they may also be employed in other systems that need to track different types of data.<br>
The various functional units of graphics core 320 operate on data in its UNC (or UNC_A) format. Accordingly, a data block may be written back to local cache 430 or memory 440 in a compressed (or recompressed) or an uncompressed state, or the write may be avoided altogether if the data status is cleared.    For one embodiment of local cache system 500, write unit 550 handles the write access according to a status determined for the data block targeted by the write. Different criteria for whether or not a data block may be compressed or represented by a cleared value are discussed below in greater detail.<br>
Fig. 7 is a block diagram representing one embodiment of a memory map 700 to store status data in a linear portion of memory 330.  For map 700, each status entry, Sxy, is associated with a data block that represents z-data for a 4x4 array of pixels (span). Here, Sx-y, represents the status data for the data block at a span address (x, y). One possible representation of the span address for 16 and 32-bit Z-modes is indicated at the bottom of<br>
Fig. 7.<br>
For this data block definition, a 2048 x 1024 pixel frame buffer may be represented by 512 x 256 grid of spans.  Memory map 700 organizes the spans into groups of 512 bytes each, and each byte stores status bits for a column of 4 spans.  When an access<br><br>
targeting a data block at span coordinates (x, y) misses in local cache 430, its status bits,<br>
Sx.y, may be accessed at bits Y[I:0] of byte(Byte_Index) at the memory address:<br>
Status_Bits_Base_Address + PageY-512 + PageX.Entry_Size,<br>
where<br>
Entry_Size	- 16-bit Z-mode?	32:16<br>
PageX	= 16-bit Z-mode?	X[8:5] : X[8:4]<br>
PageY	= Y[8:2]<br>
Bytejndex	= 16-bit Z-mode?	X[4:0] : X(3:0]<br>
One factor that complicates z-compression is that compression may not be<br>
desirable or feasible for certain spans. ZST 360 provides a convenient tracking<br>
mechanism for determining whether a span to be read is stored in a compressed state and<br>
whether a span to be written may be compressed before it is written. As noted above,<br>
various criteria may be applied to determine whether to compress a particular span for<br>
storage in the memory system. These criteria include, for example, whether the span falls<br>
fully within the primitive, i.e. whether all pixels of a span are written by the particular<br>
operation, and, if the span includes a stencil value, whether all spans in the primitive have<br>
the same stencil value. For example, if a span is in a cleared state, the cleared value is a<br>
constant for all pixels in the frame and may be stored in a more readily accessible register.<br>
The other criteria may be better appreciated in view of the different uncompressed and<br>
compressed formats in which the data blocks may be stored.<br>
Figs. 8A and 8B are block diagrams representing uncompressed formats 810 and 850 for 16-bit and 32-bit z-data, respectively, when it is stored as spans. For 16-bit format 810, each row corresponds to one quad word (QW) of data (4x16 bits), and for 32-bit format 850, each row corresponds to one double quad word (DQW; of data (4 x 32 bits).<br><br>
The z-values of the 16 pixels in the span are labeled Zo0 - Z3 3.  For one embodiment of 32-bit format 850, each 32-bit value may include a 24-bit z-value and an 8-bit stencil value. Stencil values are used to indicate a portion of the screen for which drawing updates are not necessary. For example, a pixel that is obscured by a window border may include a stencil value that is to be written instead of the pixel value. For one embodiment of the invention, a span whose pixels are associated with different stencil values may not be compressed.<br>
Fig. 9 represents one embodiment of a compressed data block 900, which may be generated from uncompressed formats 810, 850 or other uncompressed formats. Compressed data block 900 is one DQW, which is 50% of the size of 16-bit format 810 and 25% of the size of 32-bit format 950. The disclosed embodiment of compressed format 900 may be generated through a lossless compression method. One method is based on a functional representation of the z-values for a primitive such as that used by interpolator 460 to determine z-values for primitive locations from vertex values.<br>
For one compression method, z-values for a given primitive are represented as:<br><eq. i z y co ox cy-y></eq.>
where Co represents a Z value at a reference point, e.g. x = y = 0, Cs represents a (linearized) z-dependence in the x direction, and Cy represents a linearized z-dependence in the y-direction. When the pixel z-values for a span are parameterized through Z(x. y) or a similar function, the Z-values may be represented by the coefficients, Co, Cx, and Cy, rather than by storing the z-values themselves. Compressed data block 900 can store sixteen 24-bit z-values and an 8 bit stencil value (4DQWs) as three 40-bit coefficients and an 8-bit stencil value (1 DQW), provided all sixteen pixels have the same stencil value.<br><br>
Another mechanism for compressing z-values for a sp3n stores a z-value for one pixel of the span and the differences between this z-value and those of the other pixels of the span. Since the differences are expected to be small, they may be represented using fewer bits. For example, for 16-bit z-values, the reference z-value may be stored as a 16-bit value and differences for the remaining 15 pixels may be stored as 7-bit values. Alternatively, the 8 pixels that are closest to the reference value may be specified by 7-bit difference values, and the remaining 7 bits may be specified by 8-bit values. Other variations on this difference-based compression mechanism are possible. These mechanisms are not guaranteed to be lossless, since the differences may require greater resolution than is provided by the allotted bits. Embodiments of the mechanism may bypass compressing a data block if it appears that the compression will be not be lossless.<br>
Fig. I0A represents one embodiment of a method 1000 in accordance with the present invention for processing a read access to memory. Method 1000 may be implemented, for example, using the system of Fig. 3 or any other system that provides a mechanism to track the status (compressed, uncompressed, cleared) of the data blocks being read. According to method 1000, a read access is detected 1010 and a status for the block targeted by the read is determined 1012. In system 400, for example, the status is indicated by an entry in local cache 430 or memory 440, depending on whether the read hits or misses, respectively, in local cache 430.<br>
If the status is determined 1014 to be "cleared", the cleared value is read !0!6 from a local register and forwarded 1026 to the requestor. No fetch is issued to the memory system. If the status is determined 1018 to be "uncompressed", the data is retrieved by executing 1020 a full fetch, and the retrieved data is forwarded 1026 to the requester. For<br><br>
the disclosed embodiments, a full fetch transfers 4 quad-words (QWs) for each block of 16-bit z-data and 4 double quad-words (DQVVs) for each block of 32-bit z-data. For embodiments of local cache 430 that allow Q W or DQW granular reads, "full fetch" means a fetch of the targeted data in uncompressed form.<br>
If the status is determined 1018 to be "compressed", the data is retrieved by executing 1022 a partial fetch. For the disclosed embodiments, a partial fetch transfers one DQW for each block of 32 or 16-bit z-data. The retrieved data is decompressed 1024 and forwarded 1026 to the requestor. A copy of the compressed data may be saved temporarily. If the requestor does not modify the forwarded data, the saved copy of compressed data remains valid and may be returned to local cache 430 or memory 440. For system 400, the compressed/uncompressed data may be fetched from local cache 430 or memory 440, according to whether the read hit or missed, respectively, in local cache 430.<br>
Fig. 10B represents one embodiment of a method 1004 for processing a write access to a memory in accordance with the present invention. Method 1004 may also be implemented by system 400 or a system providing similar support for tracking the status (compressed, uncompressed, cleared) of blocks of z-data. According to method 1004, a write access is detected 1030 and a status is determined 1032 for the data block targeted by the write access, i.e. the data block to be written. Methods for determining the status are discussed in conjunction with Fig. IOC.<br>
If the status is determined 1034 to be "cleared", the block value is already represented by the reference value, and no data write is necessary (done). The status may be updated 1036 in an appropriate field of local cache 430 or an entry of memory 440 to<br><br>
reflect the "cleared" status of the write.  If the status is determined 1038 to be uncompressed, a full write is executed 1040 to write the data to the memory system in its uncompressed form, and the status is updated 1036 if necessary. For the disclosed embodiments, a full write transfers 4DQWs for each block of 32-bit data and 4QWs for each block of 16-bit data. For embodiments of local cache 430 that allow Q W or DQ W granular accesses, "full writeH means that the designated QW(s) or DQW(s) are written in uncompressed form.<br>
If the status is determined 1038 to be uncompressed, it is compressed 1042, a partial write is executed 1044 to write the data to the memory system, and the status is updated 1036 if necessary.  For the disclosed embodiments, a partial write transfers one DQW for each block of 32-bit or 16-bit data. For system 400, the data block(s) may be written to local cache 430 or memory 440 depending on whether the access hits or misses in local cache 430.<br>
Fig. 10C represents one embodiment of a method 1008 in accordance with the present invention for determining the status for a block of 16-bit data. Status updates for blocks of 32-bit data are discussed in conjunction with Table 3. For method 1008, it is determined 1060 whether z-values for all pixels in a data block are updated. For example, all pixels from a data block 110(b) of Fig. 1 fall within a primitive, and are all are updated when the primitive is processed. Pixels in data blocks 110(a) arc not all updated, since some fall outside the primitive. If all pixel values in a block are not updated 1060, the data block status is set 1064 to uncompressed.<br>
If all oixel values in a block are updated 1060, various override conditions arc considered 1068. "Override conditions" arc conditions that may preclude accurate<br><br>
compression or decompression of z-values. For example, certain graphics algorithms apply a z-bias to all z-valucs. Although relatively rare, the z-bias value may be changed if out-of-range z-values are encountered. Since certain z-compression/decompression methods depend on the z-bias value, these will provide incorrect results if a different z-bias value is used for compression and decompression. Consequently, one override condition may be indicated when z-values are clamped to the allowed range by adjusting the z-bias value. Another, potential override condition is attributable to the precision with which z-values are interpolated, which can yield z-values that falls outside the max/min z-values for an image. If these or other override conditions are detected 1068, the status is set 1064 to uncompressed.<br>
If no override condition is indicated 1068, it is determined 1070 whether all pixels of the data block have the cleared value. If all pixels are cleared 1070, the status is set 1074 to clear. If not, the status is set 1080 to compressed.<br>
The disclosed 32-bit z-data format (Fig. 8B), includes both stencil and z-data, and status assignments consider both elements. For example, compressed format 900 uses a single stencil value for ail pixels of a data block. Consequently, even if the z-data of a block can be compressed, format 900 does not allow compression if the pixels have different stencil values. Table 2 summarizes the status updates appropriate for the 32-bit format according to the type of data being updated and its previous status.<br><br>
Table 2<br><br>
*Z-data compressibility may be determined using method of Fig. IOC or a comparable method. M Both z-data &amp; stencil data (if present) meet compressibility criteria " Either z-data or stencil data or both fail to meet compressibility Criteria<br>
The z-compression/decomprcssion mechanism described above may leave the z-buffer storing data in compressed and decompressed states. This can create problems for programmers in systems that allow certain instructions to read or write the z-buffer directly, i.e. bypassing the read/write unit of system 400. Alternatives for supporting these instructions include requiring programmers to master the details of the depth-compression and write code accordingly or making z-compression transparent to the programmer. The latter alternative hides the details of the meclianism from the programmer and ensures that the data will be properly handled. This transparency may be accomplished, for example, by extending the system state to accommodate state-variables (SVs) for controlling the operation of the graphics system, providing one or more instructions to manage these SVs<br><br>
appropriately, and modifying a graphics driver to intervene when selected instructions are detected. For one embodiment of the invention, a set of graphics instructions are defined to set and update the appropriate bits of the graphics state, and the driver is designed to intervene when instructions that access the Z-buffer are detected.<br>
Table 3 represents selected status bits that may be used to control/configure one .embodiment of a graphics system in accordance with the present invention. The various bits are described and bit sizes are indicated.<br>
Table 3<br><br>
Fig. 11 is a flowchart representing one embodiment of a method 1100 for implementing z-compression transparently. Method 1100 may be implemented, for example, by a graphics driver that interprets instructions from a 3D programming environment, such as Win3D, for the underlying graphics hardware.<br>
initially, a z-buffer is allocated 1110 and it is determined 1 120 whether z-compression should be implemented.  For example, if tiled memory is not available for the<br><br>
z-buffer or if there is insufficient linear memory to accommodate the z-status table that supports the z-buffer, z-compression may not be implemented. If z-compression is not implemented I 120, a non-compression mode is entered I 124.<br>
If z-compression is to be implemented 1120, memory is allocated 1130 for a z-<br>
i     status table (ZST) and the table entries are cleared 1134. ZST may be cleared, for example, by block transferring (BLITing) zeroes to the entries of ZST. The graphic context is updated 1140 to indicate that z-compression is enabled. For one embodiment of method 1100, state variables such as those indicated in Table 3 arc set using an appropriate instruction. Once the graphics context is updated 1140, rendering proceeds<br>
I      1144 while method 1100 monitors graphics operations for selected events. This monitoring activity is indicated by the loop through blocks 1150, 1160, and 1 170.<br>
If a z-buffer clear event is detected 1150, a modified clear operation is executed 1154. If certain z-buffer access events are detected 1160, a modified access operation is executed 1164. Modified clear and access operations are discussed below in greater detaii. If a context switch is detected I 170, state variables for the new context are retrieved I 174 and the graphics context is updated 1140. Rendering 1144 and monitoring 1150, 1160, 1170 proceed on the new process. If no context switch is detected 1 170, monitoring continues on the current process.<br>
Fig. 12 is a flowchart representing an embodiment of a method 1200 for handling selected accesses to the z-buffer transparently (modified accesses 1164). The selected accesses include, for example, attempts by a user application to read the Z-buffer or to lock the Z-buffer when z-compression is enabled. Method 1200 decompresses the z-buffer contents before the selected access proceeds.<br><br>
For the disclosed embodiment of method 1200, the current graphics state is saved 1210, a bit is set 1220 to enable a fast read/write process for the pixels in a specified primitive ("Force Decompression"), and the graphics state is adjusted 1224 for decompression. For one embodiment, graphics state adjustments include enabling z-writes and alpha-testing, setting the alpha test function to NEVER, and disabling frame buffer writes. A primitive that encompasses the area to be accessed by the user application is sent 1230 to the graphics engine. When the Force Decompression bit is set in this state, each pixel within the specified primitive is read, decompressed (if necessary), and written back to its memory location. The saved graphics state is restored 1240 and the user-access is implemented! 150.<br>
Restoring the graphics state following decompression means that z-compression is once again enabled. Consequently, subsequent, non-user-initiated write accesses to the z-buffer may be compressed, if the target blocks meet the compression criteria.<br>
Fig. 13A is a flowchart representing one embodiment of a method 1300 for implementing clear operations transparently, when z-compression is enabled. Method 1300 is implemented through a BLIT operation when the full Z-buffer is cleared (Partial clears are discussed below). For the disclosed embodiment, ZST is cleared by blitting zeroes to its entries 1320 and updating 1324 the cleared stencil and z-values. Significantly, method 1300 does not access the z-buffer to implement this clear when z-compression is enabled. Only the-state variables (cleared z and stencil values) for a data block are read when ZST indicates its status is cleared, e.g. state = 00.<br>
Fig. 13B is a flowchart representing an embodiment of another method 1304 for implementing a Z-buffer clear transparently, when Z-compression is enabled. Method 1304 is implemented through a clear( ) function call when the full z-buffcr is cleared. The<br><br>
clear operation depends on whether z-values, the stencil values or both are being cleared. If both stencil and z-values are being cleared 1330 (or if the system is operating in 16-bit mode, which does not support stencils), clearing may be implemented by blitting ZST via method 1300. If only z or only stencil values are being cleared 1330, a primitive is written to the z-buffer to update the values. Since these operations alter the graphics state, the current graphics state (or the portion that will be altered) is saved 1334. In addition, various per pixel tests are disabled.<br>
If only z-values are cleared 1340, z-write is enabled and a stencil update function is disabled 1344. A primitive sized to the z-buffer (or relevant area, for partial clears) and having a vertex z-value equal to the cleared z-value, is rendered 1348. Rendering this primitive clears the entries of the z-buffer without updating the stencil values. The graphics state prior to the clear is restored 1360.<br>
If only stencil values are cleared 1340, z-write is disabled and the stencil update function is enabled 1354. A primitive sized to the z-buffer (or its relevant area, for partial clears) is rendered 1358. The updated stencil value is that specified by the cleared stencil state variable. Z-values are not modified because z-writes are disabled. Following primitive rendering 1358, the graphics state is restored 1360.<br>
Fig. 13C is a flowchart representing an embodiment of a method 1308 implementing partial clears of the Z-buffer, when Z-compression is enabled.  In the following discussion, the area of the Z-buffer to be cleared is referred to as the "targeted area", and remaining area of the Z-buffer is referred to as the "untargeted area".<br>
For the disclosed embodiment, primitives covering the targeted and untargeted areas are determined 1370. To prepare 1 372 for rendering, graphics state informrtion is saved, per pixel tests are disabled, z and stencil writes are enabled, and the stencil update<br><br>
function is set to "replace". Operations of clear method 1308 depend on whether the new cleared value specified for the targeted area (new cleared value) is the same as the cleared value specified for the untargeted aea (old cleared value).<br>
If the new and old cleared values are the same 1374, a "clearing bit" (Table 3) is set and a primitive covering the whole z-buffer is rendered using the cleared value. In this case, a uniform cleared value applies to all entries of the z-buffer, independent of whether they reside in the targeted or untargeted area. Clearing may proceed, for example, by blitting zeroes to the corresponding entries of ZST. The cleared values may be updated but, since they are the same as the old cleared values, the update may be bypassed.<br>
If the new and old cleared values are different 1374, the targeted and untargeted areas are not treated together. For the disclosed embodiment, a primitive covering the targeted area is rendered 1380, using the new cleared value.<br>
There has thus been disclosed a mechanism that reduces the portion of memory bandwidth necessary to service the z-buffer, increasing the bandwidth available to other memory operations. Z-data may be designated as being compressed, uncompressed, or having a reference value. For one embodiment, a data status indicates the designation for each data block, and this designation is checked before an access to a data block is implemented. Access that target compressed data consume less bandwidth, because only a compressed data block is transferred, and accesses that target "cleared" data blocks, may be satisfied by reference to a z-va!uc stored in a local register. Mechanisms are also provided for compressing z-data and for making these compression/decompression operations transparent to user applications, as well as cache structures suitable for supporting these mechanisms.<br><br>
The disclosed embodiments have been provided to illustrate various features of the present invention. Persons skilled in the art of graphics processing, having the benefit of this disclosure, will recognize variations and modifications of the disclosed embodiments, which none the less fall within the spirit and scope of the appended claims. For example, z-buffering is a particular form of a more general technique referred to as depth buffering. Other forms include W-buffering, which tracks pixels" z-coordinates or functions of these coordinates in a different reference system, e.g. eye space. The present invention may be applied to these and other forms of depth buffering.<br><br>
Claim:<br>
1.	A method for processing data comprising:<br>
storing blocks of data in entries of a first memory location, each of the blocks of data being stored in one of a cleared, compressed, or uncompressed data states;<br>
monitoring operations to the first memory location for a selected operation; and if the selected operation is detected, implementing a modified version of the selected operation that masks differences between the data states of the data blocks, wherein implementing the modified version of the selected operation includes saving a current processor state; reading one or more data blocks according to their data states in response to the selected operation; and writing the read data back into the entries of the first memory location in an uncompressed state before performing the selected operation on the data in the uncompressed state.<br>
2.	The method as claimed in claim 1, wherein the selected operation is a read of specified data blocks, and implementing the modified read further comprises reading the converted data blocks according to their stored states.<br>
3.	The method as claimed in claim 1, wherein the selected operation is a clear of entries of the first memory location and implementing the clear comprises setting the states of the data blocks in the first set of entries of the first memory location to the cleared state.<br>
4.	The method as claimed in claim 3, further comprising updating a cleared state variable in a current processor state.<br><br>
5. The method as claimed in claim 1, wherein the selected operation is a clear of data blocks at specified entries of the first memory location and implementing the clear comprises: setting the data states of the data blocks to the cleared state if the specified entries include all of the data blocks; and writing a primitive to the specified entries of the first memory location if the specified entries do not include all of the data blocks.<br>
.   The method as claimed in claim 5, wherein the specified portion is a depth or a stencil portion of the data blocks.<br>
.   A method for processing z-data is not implemented; and determining whether z-compression is implemented; implementing   a   selected   operation   if   z-compression   is   not implemented; and<br>
implementing a modified form of the selected operation if z-compression is implemented, wherein implementing the modified form of the selected operation comprises saving a current processor state;<br>
reading data blocks from entries of a first memory according to status bits of the data blocks; and<br>
writing the read data blocks back into the entries of the first memory in an uncompressed state before executing the selected operation on the data blocks in the uncompressed state.<br>
8.   The method as claimed in claim7, wherein determining whether z-compression is implemented comprises: allocating a first portion of memory to store z-data; determining whether a memory system can support z-compression; and allocating a second portion of the memory to store status bits<br><br>
for the z-data if the memory system can support depth-compression.<br>
The method as claimed in claim 8, wherein the z-data is organized as a plurality of data blocks and the status bits indicate an associated data block is compressed, uncompressed, or cleared.<br>
The method as claimed in claim 9, wherein the selected operation is a clear of the first memory, and implementing a modified form of the clear comprises setting the status bits in a second portion of the memory to a value that indicates the associated data is in a cleared state.<br>
Dated this 9th day of January, 2003<br>
(RITUSHKA NEGI) OF REMFRY &amp; SAGAR ATTORNEY FOR THE APPLICANTS</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1jYW5jZWxsZWQgcGFnZXMoMjktMDctMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-cancelled pages(29-07-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1jbGFpbXMoZ3JhbnRlZCktKDI5LTA3LTIwMDUpLmRvYw==" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-claims(granted)-(29-07-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1jbGFpbXMoZ3JhbnRlZCktKDI5LTA3LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-claims(granted)-(29-07-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1jb3JyZXNwb25kZW5jZSgyNy0wMy0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-correspondence(27-03-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1jb3JyZXNwb25kZW5jZShpcG8pLSgxOC0wOC0yMDA0KS5wZGY=" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-correspondence(ipo)-(18-08-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1kcmF3aW5nKDI5LTA3LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-drawing(29-07-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1mb3JtIDE5KDE1LTA3LTIwMDQpLnBkZg==" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-form 19(15-07-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1mb3JtIDFhKDA5LTAxLTIwMDMpLnBkZg==" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-form 1a(09-01-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1mb3JtIDIoZ3JhbnRlZCktKDI5LTA3LTIwMDUpLmRvYw==" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-form 2(granted)-(29-07-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1mb3JtIDIoZ3JhbnRlZCktKDI5LTA3LTIwMDUpLnBkZg==" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-form 2(granted)-(29-07-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1mb3JtIDMoMDktMDEtMjAwMykucGRm" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-form 3(09-01-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1mb3JtIDMoMjktMDctMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-form 3(29-07-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1mb3JtIDUoMDktMDEtMjAwMykucGRm" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-form 5(09-01-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1mb3JtIDUoMzAtMTItMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-form 5(30-12-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1mb3JtLXBjdC1pcGVhLTQwOSgwOS0wMS0yMDAzKS5wZGY=" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-form-pct-ipea-409(09-01-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1mb3JtLXBjdC1pc2EtMjEwKDA5LTAxLTIwMDMpLnBkZg==" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-form-pct-isa-210(09-01-2003).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1wZXRpdGlvbiB1bmRlciBydWxlIDEzNygwMi0wOC0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-petition under rule 137(02-08-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1wZXRpdGlvbiB1bmRlciBydWxlIDEzOCgwMi0wOC0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-petition under rule 138(02-08-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1wb3dlciBvZiBhdXRob3JpdHkoMDktMDEtMjAwMSkucGRm" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-power of authority(09-01-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTMtbXVtbnAtMjAwMy1wb3dlciBvZiBhdXRob3JpdHkoMjktMDctMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">53-mumnp-2003-power of authority(29-07-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="203122-a-process-for-the-preparation-of-iodixanol.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="203124-process-for-the-production-of-olefins.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>203123</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>53/MUMNP/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>15/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>13-Apr-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>27-Oct-2006</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>09-Jan-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTEL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2200 MISSION COLLEGE BOULEVARD, SANTA CLARA, CALIFORNIA 95052, U.S.A.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>DORON ORENTSTIEN AND OTHERS</td>
											<td>ALL ARE U.S.A. 2200 MISSION COLLEGE BOULEVARD, SANTA CLARA, CALIFORNIA 95052, U.S.A.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2001-06-21</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/608,619</td>
									<td>2000-06-30</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/203123-method-for-modifying-root-growth by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:02:41 GMT -->
</html>
