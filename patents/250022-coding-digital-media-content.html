<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/250022-coding-digital-media-content by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:40:01 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 250022:&quot;CODING DIGITAL MEDIA CONTENT&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;CODING DIGITAL MEDIA CONTENT&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A digital media content (e.g., image, video, audio, etc.) coding employs a spatially varying parameter to condition the application of an overlap pre-process and post-process to adjacent transform block edges for the spatial-domain lapped transform. This conditional application of the lapped transform to sub-blocks of the digital media can be signaled on an edge, block, macro-block or other granularity. Further, a restriction on use of the conditional lapped transform based on a frame-level quantization or other bit-rate related parameter minimizes the signaling overhead impact at low bit-rates of coding.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>Conditional Lapped Transform<br>
Technical Field<br>
The present invention relates to techniques for digitally encoding, decoding and processing media content signals (e.g., audio, video, image, text, speech, etc.). The invention more particularly relates to digital media codecs based on lapped transforms.<br>
Background<br>
Transform coding is a compression technique used in many audio, image and video compression systems. Uncompressed digital image and video is typically represented or captured as samples of picture elements or colors at locations in an image or video frame arranged in a two dimensional grid. For example, a typical format for images consists of a stream of 24-bit color picture element samples arranged as a grid. Each sample is a number representing color components at a pixel location in the grid within a color space, such as RGB, or YIQ, among others. Various image and video systems may use various different color, spatial and time resolutions of sampling.<br>
Uncompressed digital image and video signals can consume considerable storage and transmission capacity. Transform coding reduces the size of digital images and video by transforming the spatial-domain representation of the signal into a frequency-domain (or other like transform domain) representation, and then reducing resolution of certain generally less perceptible frequency components of the transform-domain representation. This generally produces much less perceptible degradation of the digital signal compared to reducing color or spatial resolution of images or video in the spatial domain.<br>
More specifically, a typical transform coding technique 100 shown in Figure 1 divides the uncompressed digital image's pixels into fixed-size two dimensional blocks, each block possibly overlapping with other blocks. A linear transform 110 that does spatial-frequency analysis is applied to each block, which converts the spaced samples within the block to a set of frequency (or transform) coefficients generally representing the strength of the digital signal in corresponding frequency bands over the block interval. For compression, the transform coefficients may be selectively quantized (i.e., reduced in resolution, such as by dropping least significant bits of the coefficient values or otherwise mapping values in a higher resolution number set to a lower resolution), and also entropy or variable-length coded into a compressed data stream by quantizer/entropy coder 120. After<br>
aequantization/entropy decoding 130, the transform coefficients will inversely transform 140 to nearly reconstruct the original color/spatial sampled image/video signal.<br>
While compressing a still image (or an infra-coded frame in a video sequence), most common standards such as MPEG-2, MPEG-4 and Windows Media partition the image into square tiles apply a block transform to each image tile. The transform coefficients in a given partition (commonly known as a block) are influenced only by the raw data components within the block. Irreversible or lossy operations on the encoder side such as quantization cause artifacts to appear in the decoded image. These artifacts are independent across blocks and produce a visually annoying effect known as the blocking effect. Likewise for audio data, when non-overlapping blocks are independently transform coded, quantization errors will produce discontinuities in the signal at the block boundaries upon reconstruction of the audio signal at the decoder. For audio, a periodic clicking effect is heard.<br>
Spatial-Domain Lapped Transform<br>
In order to minimize the blocking effect, cross block correlations can be exploited. One way of aclueving cross block correlation is by using a lapped transform as described in H. Malvar, "Signal Processing with Lapped Transforms," Artech House, Norwood MA, 1992. A lapped transform is a transform whose input spans, besides the data elements in the current block, a few adjacent elements in neighboring blocks. Likewise, on the reconstruction side the inverse transform influences all data points in the current block as well as a data points in neighboring blocks.<br>
For the case of 2-dimensional (2D) data, the lapped 2D transform is a function of the current block, together with select elements of blocks to the left, top, right, bottom and possibly top-left, top-right, bottom-left and bottom-right. The number of data points in neighboring blocks that are used to compute the current transform is referred to as the overlap.<br>
The lapped transform can be implemented in the transform domain, as a step that merges transform domain quantities after a conventional block transform. Else, it can be implemented in the spatial-domain by a pre-processing stage that is applied to pixels within the range of overlap. These two implementations are mathematically related and therefore equivalent.<br>
As shown in Figure 2, the spatial-domain lapped transform (SDLT) 200 is a lapped transform that is implemented as matched pre and post processing steps 210, 220 prior to the forward block transform 110, and subsequent to the inverse block transform 140, respectively. (See, e.g., Srimvasan et al., "Improvements to the Spatial-Domain Lapped<br>
Transform in Digital Media Compression," U.S. Patent Application No. 10/620,744, filed July 15, 2003 [hereafter "Improved SDLT Patent Application"].) The spatial-domain lapped transform is often used to retrofit existing block transform based compression techniques in order to improve efficiency.<br>
Summary<br>
When the SDLT is applied to all parts of an image (such as a frame in a video sequence) of other digital media content being coded in a non-predicted (i.e., Intra) manner, certain limiting issues arise:<br>
1.    The pre-filter is range-expansive; therefore certain areas of the image may saturate or clip after pre-filter on the encoder side. Likewise, there may be overflow on the decoder side.<br>
2.    The pre-filter is sharpening. The coding efficiency of certain areas of an image with local high frequency content (especially image edges aligned with block edges) therefore will decrease as a result of the lapped transform.<br>
The conditional lapped transform that is implemented using digital media signal processing and encoding/decoding techniques and systems described herein achieves better control of the overlap process to address these issues. This conditional lapped transform allows for spatial flexibility in the choice or application of the pre- and post-filters of a lapped transform, in other words, the lapped transform is conditionally applied to different areas of the digital media content (e.g., separate blocks of an image).<br>
For example, one implementation of the conditional lapped transform described herein uses a spatially-varying mode parameter to specify the application and extent of the overlap post-filter to be applied upon decoding. In a video codec, for example, this spatially-varymg mode parameter specifies to which block edges in an image the post-filter of the lapped transform is to be applied. In one implementation, the mode parameter is more efficiently coded and transmitted for infra-coded frames of a video sequence as a Boolean flag with macroblock granularity, which is more efficient than coding the mode parameter per block edge. Further, this implementation imposes a restriction on the conditional overlap mode based on a quantization parameter related to the bitrate, so as to minimize the impact of performing the conditional lapped transform at low bitrates.<br>
Additional features and advantages of the invention will be made apparent from the following detailed description of embodiments that proceeds with reference to the accompanying drawings.<br>
Brief Description of the Drawings<br>
Figure 1 is a block diagram of a typical transform coding technique in the prior art.<br>
Figure 2 is a block diagram of an encoding/decoding system based on the spatial domain lapped transform in the prior art.<br>
Figure 3 is a block diagram of a video encoder employing the conditional lapped transform described herein.<br>
Figure 4 is a block diagram of a video decoder employing the conditional lapped transform described herein.<br>
Figure 5 is a block diagram of an encoder implementing the conditional lapped transform with per adjacent block edge overlap mode signaling.<br>
Figure 6 is a sequence-level syntax diagram utilized in an encoder/decoder according to a second implementation of the conditional lapped transform with bit-rate based and per rnacroblock overlap mode signaling.<br>
Figure 7 is a frame-level syntax diagram utilized in the encoder/decoder according to a second implementation of the conditional lapped transform with bit-rate based and per macroblock overlap mode signaling.<br>
Figure 8 is a flow diagram illustrating bit-rate based and per macroblock signaling of the overlap mode flag in a second implementation of the conditional lapped transform.<br>
Figure 9 is a diagram illustrating the adjacent macroblock edges to which the overlap filler is applied for an example of signaled overlap mode flags for a set of macroblocks in an image.<br>
Figure 10 is a block diagram of a suitable computing environment for the video encoder/decoder of Figures 3 and 4.<br>
Detailed Description<br>
The following description is directed to implementations of the conditional lapped transform, in which block edge filters associated with the lapped transform are conditionally applied on a spatially varying basis over digital media content. An exemplary application of the conditional lapped transform is in an image or video encoder and decoder. However, this conditional form of spatial-domain lapped transform is not limited to image or video codecs, and can be applied to other media encoding, decoding and/or processing systems. Accordingly, the conditional lapped transform is described in the context of a generalized image or video encoder and decoder, but alternatively can be incorporated in various types of media signal encoding, decoding and/or processing systems (e.g., audio, video, image,<br>
etc.) that employ overlap filters of lapped transforms on a conditional or spatially-varying basis, whether in the spatial domain or transform domain. 1.         Generalized Video Encoder and Decoder<br>
Figure 3 is a block diagram of a generalized video encoder (300) and Figure 4 is a block diagram of a generalized video decoder (400), in which the WMV9/VC-9 transforms can be incorporated.<br>
The relationships shown between modules within the encoder and decoder indicate the main flow of information in the encoder and decoder; other relationships are not shown for the sake of simplicity. In particular. Figures 3 and 4 usually do not show side information indicating the encoder settings, modes, tables, etc. used for a video sequence, frame, macroblock, block, etc. Such side information is sent in the output bitstream, typically after entropy encoding of the side information. The format of the output bitstream can be a Windows Media Video format or another format.<br>
The encoder (300) and decoder (400) are block-based and use a 4:2:0 macroblock format with each macroblock including 4 luminance 8x8 luminance blocks (at times treated as one 16x16 macroblock) and two 8x8 chrominance blocks. Alternatively, the encoder (300) and decoder (400) are object-based, use a different macroblock or block format, or perform operations on sets of pixels of different size or configuration than 8x8 blocks and 16x 16 macrobiocks.<br>
Depending on implementation and the type of compression desired, modules of the encoder or decoder can be added, omitted, split into multiple modules, combined with other modules, and/or replaced with like modules. In alternative embodiments, encoder or decoders with different modules and/or other configurations of modules perform one or more of the described techniques.<br>
A.        Video Encoder<br>
Figure 3 is a block diagram of a general video encoder system (300). The encoder system (300) receives a sequence of video frames including a current frame (305), and produces compressed video information (395) as output. Particular embodiments of video encoders typically use a variation or supplemented version of the generalized encoder (300).<br>
The encoder system (300) compresses predicted frames and key frames. For the sake of presentation, Figure 3 shows a path for key frames through the encoder system (300) and a path for forward-predicted frames. Many of the components of the encoder system (300) are used for compressing both key frames and predicted frames. The exact operations performed by those components can vary depending on the type of information being compressed.<br>
A predicted frame [also called p-frame, b-frame for bi-directional prediction, or inter-coded frame] is represented in terms of prediction (or difference) from one or more other names. A prediction residual is the difference between what was predicted and the original frame, hi contrast, a key frame [also called i-frame, intra-coded frame] is compressed without reference to other frames.<br>
If the current frame (305) is a forward-predicted frame, a motion estimator (310) estimates motion of macroblocks or other sets of pixels of the current frame (305) with respect to a reference frame, which is the reconstructed previous frame (325) buffered in the frame store (320). hi alternative embodiments, the reference frame is a later frame or the current frame is bi-directionally predicted. The motion estimator (310) outputs as side information motion information (315) such as motion vectors. A motion compensator (330) applies the motion information (315) to the reconstructed previous frame (325) to form a motion-compensated current frame (335). The prediction is rarely perfect, however, and the difference between the motion-compensated current frame (335) and the original current frame (305) is the prediction residual (345). Alternatively, a motion estimator and motion compensator apply another type of motion estimation/compensation.<br>
A frequency transformer (360) converts the spatial domain video information into frequency domain (i.e., spectral) data. For block-based video frames, the frequency transformer (360) applies a transform described in the following sections that has properties similar to the discrete cosine transform ["DCT"]. hi some embodiments, the frequency transformer (360) applies a frequency transform to blocks of spatial prediction residuals for key frames. The frequency transformer (360) can apply an 8x8, 8x4,4x8, or other size frequency transforms.<br>
A quantizer (370) then quantizes the blocks of spectral data coefficients. The quantizer applies uniform, scalar quantization to the spectral data with a step-size that varies on a frame-by-frame basis or other basis. Alternatively, the quantizer applies another type of quantization to the spectral data coefficients, for example, a non-uniform, vector, or non-adaptive quantization, or directly quantizes spatial domain data in an encoder system that does not use frequency transformations. In addition to adaptive quantization, the encoder (300) can use frame dropping, adaptive filtering, or other techniques for rate control.<br>
When a reconstructed current frame is needed for subsequent motion estimation/compensation, an inverse quantizer (376) performs inverse quantization on the quantized spectral data coefficients. An inverse frequency transformer (366) then performs the inverse of the operations of the frequency transformer (360), producing a reconstructed prediction residual (for a predicted frame) or a reconstructed key frame. If the current frame<br>
 (305) was a key frame, the reconstructed key frame is taken as the reconstructed current frame (not shown). If the current frame (305) was a predicted frame, the reconstructed prediction residual is added to the motion-compensated current frame (335) to form the reconstructed current frame. The frame store (320) buffers the reconstructed current frame for use in predicting the next frame. In some embodiments, the encoder applies a deblocking filter to the reconstructed frame to adaptively smooth discontinuities in the blocks of the frame.<br>
The entropy coder (380) compresses the output of the quantizer (370) as well as certain side information (e.g., motion information (315), quantization step size). Typical entropy coding techniques include arithmetic coding, differential coding, Huffman coding, run length coding, LZ coding, dictionary coding, and combinations of the above. The entropy coder (380) typically uses different coding techniques for different kinds of information (e.g., DC coefficients, AC coefficients, different kinds of side information), and can choose from among multiple code tables within a particular coding technique.<br>
The entropy coder (380) puts compressed video information (395) in the buffer (390). A buffer level indicator is fed back to bitrate adaptive modules. The compressed video information (395) is depleted from the buffer (390) at a constant or relatively constant bitrate and stored for subsequent streaming at that bitrate. Alternatively, the encoder system (300) streams compressed video information immediately following compression.<br>
Before or after the buffer (390), the compressed video information (395) can be channel coded for transmission over the network. The channel coding can apply error detection and correction data to the compressed video information (395).<br>
B.        Video Decoder<br>
Figure 4 is a block diagram of a general video decoder system (400). The decoder system (400) receives information (495) for a compressed sequence of video frames and produces output including a reconstructed frame (405). Particular embodiments of video decoders typically use a variation or supplemented version of the generalized decoder (400).<br>
The decoder system (400) decompresses predicted frames and key frames. For the sake of presentation, Figure 4 shows a path for key frames through the decoder system (400) and a path for forward-predicted frames. Many of the components of the decoder system (400) are used for compressing both key frames and predicted frames. The exact operations performed by those components can vary depending on the type of information being compressed.<br>
A buffer (490) receives the information (495) for the compressed video sequence and makes the received information available to the entropy decoder (480). The buffer<br>
(490) typically receives the information at a rate that is fairly constant over time, and includes a jitter buffer to smooth short-term variations in bandwidth or transmission. The buffer (490) can include a playback buffer and other buffers as well. Alternatively, the buffer (490) receives information at a varying rate. Before or after the buffer (490), the compressed video information can be channel decoded and processed for error detection and correction.<br>
The entropy decoder (480) entropy decodes entropy-coded quantized data as well as entropy-coded side information (e.g., motion information, quantization step size), typically applying the inverse of the entropy encoding performed in the encoder. Entropy decoding techniques include arithmetic decoding, differential decoding, Huffman decoding, run length decoding, LZ decoding, dictionary decoding, and combinations of the above. The entropy decoder (480) frequently uses different decoding techniques for different kinds of information (e.g., DC coefficients, AC coefficients, different kinds of side information), and can choose from among multiple code tables within a particular decoding technique.<br>
If the frame (405) to be reconstructed is a forward-predicted frame, a motion compensator (430) applies motion information (415) to a reference frame (425) to form a prediction (435) of the frame (405) being reconstructed. For example, the motion compensator (430) uses a macroblock motion vector to find a macroblock in the reference frame (425). A frame buffer (420) stores previous reconstructed frames for use as reference frames. Alternatively, a motion compensator applies another type of motion compensation. The prediction by the motion compensator is rarely perfect, so the decoder (400) also reconstructs prediction residuals.<br>
When the decoder needs a reconstructed frame for subsequent motion compensation, the frame store (420) buffers the reconstructed frame for use in predicting the next frame. In some embodiments, the encoder applies a deblocking filter to the reconstructed frame to adaptively smooth discontinuities in the blocks of the frame.<br>
An inverse quantizer (470) inverse quantizes entropy-decoded data. In general, the inverse quantizer applies uniform, scalar inverse quantization to the entropy-decoded data with a step-size that varies on a frame-by-frame basis or other basis. Alternatively, the inverse quantizer applies another type of inverse quantization to the data, for example, a non-uniform, vector, or non-adaptive quantization, or directly inverse quantizes spatial domain data in a decoder system that does not use inverse frequency transformations.<br>
An inverse frequency transformer (460) converts the quantized, frequency domain data into spatial domain video information. For block-based video frames, the inverse frequency transformer (460) applies an inverse transform described in the following<br>
sections. In some embodiments, the inverse frequency transformer (460) applies an inverse frequency transform to blocks of spatial prediction residuals for key frames. The inverse frequency transformer (460) can apply an 8x8, 8x4, 4x8, or other size inverse frequency transforms.<br>
2.         Conditional Lapped Transform<br>
With reference again to Figure 2, the pre-process and post-process filter stages 210, 220 are applied to all adjacent block edges of an image when the typical prior spatial-domain lapped transform is performed on the image by an encoder/decoder 200. An image of size MxN pixels, coded using 8x8 blocks, has nearly M*N/32 distinct edges between adjacent 8x8 blocks for its luminance channel alone. Where the prior art encoder/decoder 200 applies the spatial-domain lapped transform to an image, the filter stages 210, 220 are applied to each of these adjacent block edges of the image.<br>
A.         Overlap Mode Signaling Per Adjacent Block Edge<br>
In a first implementation of the conditional lapped transform shown in Figure 5, the encoder sends a distinct symbol (overlap mode symbol 510) corresponding to each adjacent block edge, defining the choice of overlap filter (Mn) 520-522 (which may be a pass through filter, i.e. no filtering being applied), as shown in Figure 5 for the encoder. At the encoder, the choice of filter can be made based on various criteria, including whether any filter results are out of range, a smoothness test, a rate distortion optimization criteria, and combinations of these criteria, among others. This switch is referred to as the "mode" of overlap filter, and the mode determines a "condition" under which the pre and post filters arc applied. Figure 5 shows an overlap mode parameter that determines the switch setting, being sent for each block edge being filtered.<br>
One disadvantage of allowing for each pre and post filter to be independently flagged is the increase in overhead associated with the filtering mode. For example, assume that video of size 320x240 is being encoded at 30f/s. Further, assume that one I-frame (Intra-coded frame) is sent every second. There are thus around 3600 8x8 intra block edges in the video every second. (This number is approximate, because some blocks may be at image boundaries, and thus are not adjacent block edges). Even when a single bit overlap mode symbol (a 1 bit overhead) is sent for each edge, this results in an excess bitrate of 3.6kbps in the coded bitstream (compressed video information 195 of Figure 3), which is not insignificant.<br>
B.         Bit-Rate Based and Per Block Overlap Mode Signaling In anomer example implementation, the codec achieves a lower overhead for signaling the overlap mode using a signaling scheme that is based on the coding bit-rate and<br>
uses a per block overlap mode symbol. This signaling scheme utilizes the following syntax elements: a frame-level quantization parameter (QP), a frame-level overlap flag, and a macro-block level overlap mode flag. In codecs using other video coding syntax, the conditional overlap transform mode for individual block edges, or groups of block edges, can be encoded using other syntax schemes and elements. For example, another syntax element related to the coding bit-rate or quantization of the frame can be used.<br>
With reference to Figures 6 and 7, the compressed video bitstream 195 (Figure 3) includes information for a sequence of compressed progressive video frames or other pictures. The bitstream is organized into several hierarchical layers that are decoded by a decoder such as the decoder (400) of Figure 4. The highest layer is the sequence layer, which has information for the overall sequence of frames. Additionally, each compressed video frame is made up of data that is structured into three hierarchical layers. From top to bottom the layers are: picture, macroblock, and block.<br>
Figure 6 is a syntax diagram for the sequence layer 600, which includes a sequence header 610 followed by data for the picture layer (see Figure 7). The sequence header 610 includes several sequence-level elements that are processed by the decoder and used to decode the sequence, including a macroblock quantization (DQUANT) element 620, quantizer specifier (QUANTIZER) element 630, and overlapped transform flag (OVERLAP) element 640. DQUANT 620 is a 2-bit field that indicates whether or not the quantization step size can vary within a frame. There are three possible values for DQUANT   If DQUANT = 0, then the only one quantization step size (i.e. the frame quantization step size) can be used per frame. If DQUANT = 1 or 2, then it is possible to quantize each of the macroblocks in the frame differently.<br>
The QUANTIZER 630 is a 2-bit fixed length code ["FLC"] field that indicates the quantizer used for the sequence. The quantizer types are encoded according to the following Table 1.<br>
(Table Removed)Table 1: Quantizer Specification Overlapped Transform Flag (OVERLAP) (1 bit)<br>
n<br>
The OVERLAP 640 is a 1-bit flag that indicates whether overlapped transforms are used, as discussed further below. If OVERLAP = 1, then overlapped transforms are used, otherwise they arc not used.<br>
Figure 7 is a syntax diagram for the picture layer 700 for an interlace intra-coded frame | "interlace l-frame"]. Syntax diagrams for other pictures, such as progressive I-frames, P-pictures and B-frames have many similar syntax elements. The picture layer 700 includes a picture header 710 followed by data for the macroblock layer. The picture header 710 includes several picture-level elements that are processed by the decoder and used to decode the corresponding frame. Some of those elements are only present if their presence is signaled or implied by a sequence-level element or a preceding picture-level element.<br>
In the illustrated bistream syntax, the frame-level quantization parameter (QP) is in the form of a picture quantizer scale (PQUANT), which can be signaled implicitly or explicitly in the picture layer syntax, as specified by the sequence-level syntax element, QUANTIZER described above. In either case, the picture quantizer scale (PQUANT) is translated from a picture quantizer index (PQINDEX) element 720. PQINDEX 720 is a 5-bit field that signals the quantizer scale index for the entire frame. It is present in all picture types. If the implicit quantizer is used then PQINDEX specifies both the picture quantizer scale (PQUANT) and the quantizer (3QP or 5QP deadzone) used for the frame. Table 2 shows how PQINDEX is translated to PQUANT and the quantizer for implicit mode. (Table Removed)<br>
Alternatively, instead of the translation shown in Table 3, PQUANT is equal to PQINDBX for all values of PQINDEX from 1 through 31 when the quantizer is signaled explicitly at the sequence or frame level.<br>
The picture header further includes a conditional overlap flag (CONDOVER) element 730 and conditional overlap macroblock pattern flags (OVERFLAGS) element 740. Tins Conditional Overlap Flag element is present only in I pictures, and only when OVERLAP is on and PQUANT is within a certain range, as discussed further below. The OVERFLAGS syntax element is present only in I pictures, and only when CONDOVER has the binary value 11, OVERFLAGS is coded as a bitplane, which in raw mode requires that each macroblock carry its local information, OVERFLAGMB. Overlap Mode Rules<br>
hi this second example implementation of the conditional lapped transform, the encoder (Figure 5) limits the overhead by placing some restrictions on the overlap mode flag in intra-frames, as listed below:<br>
1.   The overlap mode is set to be a binary quantity. Value FALSE indicates that<br>
overlap filtering is not applied (i.e., the pre- and post-filters are pass through filters) and TRUE indicates that overlap filtering stages are applied as defined for the spatial-domain lapped transform in the Improved SDLT Patent Application referenced above. Jn other implementations, the number of overlap filter modes can be larger as illustrated in Figure 5, at the cost of additional overhead per macroblock.<br>
2    For a certain values of a frame-based quantization parameter (QP) (e.g., the picture quantiser scale (PQUANT) determined from table 2 or 3) greater than a quantization threshold (QTH) or QP &gt; QTH (i.e. for low to very low bitrates), the overlap condition is set to TRUE for all edges between intra blocks. In the illustrated implementation, a quantization threshold of 8 is used, but alternative implementations can use a different quantization threshold.<br>
3.   Otherwise, for a certain frame based quantization parameter values QP <qth for high to very bitrates each infra macroblock in a frame is associated with binary overlap mode flag. the filter rules this flag are enumerated ahead.></qth>
For infra-blocks and macroblocks in predictive-coded frames (P-frames), the overlap mode is implicitly derived from the quantization parameter (QP) alone. This is reasonable, since P frames allow for a greater degree of freedom in choice of coding mode than do I frames.<br>
As shown in the flow diagram of Figure 8, the overlap mode flag is encoded and decoded in this second implementation as follows:<br>
1.    No overlap mode is sent, and no overlap performed (850) if the sequence level overlap flag (OVERLAP 640 in Figure 6) at first decision block 810 is set to FALSE.<br>
2.    The overlap mode flag is implicitly TRUE when QP &gt; QTH at decision block 820, and the sequence level overlap flag (OVERLAP 640) is TRUE at decision block 810. In this case, overlap is performed for all adjacent block edges in the picture (870).<br>
3.    When at decision block 820, a frame level flag (CONDOVER 730 in Figure 7) indicating one of three possibilities (a, b or c) is sent, and operations earned out as indicated:<br>
a.    No overlap for frame (850)<br>
b.    All macroblocks overlapped in frame (870)<br>
c.    "Conditional overlap" - per macroblock overlap mode flags (OVERFLAGS 740 in Figure 7) sent (860).<br>
Tliis is broken out into two binary decisions in the flow diagram for ease of understanding.<br>
4.    When conditional overlap is indicated, the overlap mode flag is a binary flag that is sent for each intra macroblock in an intra frame (i.e., the OVERFLAGS syntax element).<br>
Conditional Overlap<br>
Since the overlap mode is signaled per macroblock, multiple edges are referenced by each conditional overlap flag. In the illustrated implementation, the macroblock size is 16x16 pixels (for the luminance channel), and the transform block size is 8x8 pixels. The chrominance channel has hall'the spatial resolution for 8x8 block size. Accordingly, the edges may be internal to a macroblock (i.e., the edges between each of the transform blocks in a macroblock for the luminance channel), or straddling two macroblocks (for around half the luminance channel edges, and all chrominance channel edges). As illustrated by the example overlap mode flags signaled for the macroblocks illustrated in Figure 9, the rules to determine whether or not to apply the pre/post filter to an edge are enumerated below:<br>
1.    No pre or post filtering is applied to the internal macroblock edges of a macroblock whose overlap mode flag is FALSE, or a macroblock which is non-intra-coded.<br>
2.     All internal 8x8 intra block edges in a macroblock are pre/post filtered if the macroblock is intra coded, and the corresponding overlap mode flag is TRUE.<br>
3.    The 8x8 block edges straddling two macroblocks are filtered only if<br>
a.    The two 8x8 block edges are intra blocks, and<br>
b.    Both overlap mode flags of the two macroblocks are TRUE. Overlap Mode Signaling<br>
All macroblocks of intra frames in this second illustrated implementation of the conditional lapped transform are intra. Since the overlap mode is sent based on the frame level quantization parameter QP, the overlap mode flag is sent either for all macroblocks, or for no macroblocks. When it is sent for all macroblocks, the overlap mode flags constitute a bitplane of size (M716)*(N/16) for an MxN image (M, N assumed to be multiples of 16).<br>
The illustrated conditional lapped transform implementation uses an efficient coding mechanism (called "bitplane" coding, described below) to send the per macroblock overlap mode flags. This relies on the assumption that the bitplane representation of the overlap mode flags has a high degree of spatial correlation - i.e., adjacent bits in the vertical or horizontal direction are equal valued with high probability. This assumption is found to be tioie for the overlap flag - it is reasonable to expect that for real-world images and video, there is sufficient spatial continuity that is apparent in the overlap mode flags as welL<br>
The bitplane coding mechanism (described more fully below) is used to encode overlap mode signaling for intra frames. The overlap mode flags for the entire frame are joint coded at the frame level using one of a collection of tilings and code tables, except for the case where they are encoded "raw" as one bit per macroblock sent together with the macroblock header.<br>
Bitplane Coding<br>
In bitplane coding, macroblock-specific binary information such as the per macroblock conditional overlap flags, may be encoded in one binary symbol per macroblock.  In these cases, the status for all macroblocks in a field or frame may be coded as a bitplane and transmitted in the field or frame header. One exception for this rule is if the bitplane coding mode is set to Raw Mode, in which case the status for each macroblock is coded as one bit per symbol and transmitted along with other macroblock level syntax elements at the macroblock level.<br>
Field/framc-level bitplane coding is used to encode two-dimensional binary arrays. The size of each array is rowMB x colMB, where rowMB and colMB are the number of macroblock rows and columns, respectively, in the field or frame in question. Within the bitstream, each array is coded as a set of consecutive bits. One of seven modes is used to encode each array. The seven modes are:<br>
1.  Raw mode - information coded as one bit per symbol and transmitted as part of MB level syntax;<br>
2.  normal-2 mode - two symbols coded jointly;<br>
3.  differential-2 mode - differential coding of the bitplane, followed by coding two residual symbols jointly;<br>
4   normal-6 mode - six symbols coded jointly;<br>
5 differential-6 mode - differential coding of the bitplane, followed by coding six residual symbols jointly;<br>
6.  rowskip mode - one bit skip to signal rows with no set bits; and<br>
7.  coiumnskip mode - one bit skip to signal columns with no set bits.<br>
The syntax elements for a bitplane at the field or frame level are in the following sequence: INVERT, MODE, and DATABITS.<br>
Invert Flag (INVERT)<br>
The INVERT syntax element is a 1-bit value, which if set indicates that the bitplane has more set bits than zero bits. Depending on INVERT and the mode, the decoder shall invert the inteipreted bitplane to recreate the original. Note that the value of this bit shall be ignored when the raw mode is used. Description of how the INVERT value is used in decoding the bitplane is provided below.<br>
Coding Mode (IMODE)<br>
The IMODE syntax element is a variable length value that indicates the coding mode used to encode the bitplane. Table 4 shows the code table used to encode the IMODE syntax element. Description of how the IMODE value is used in decoding the bitplane is provided below.<br>
Table 4: IMODE VLC Code table(Table Removed)<br>
Bitplane Coding Bits (DATABITS)<br>
The DATABITS syntax element is variable sized syntax element that encodes the stream of symbols for the bitplane. The method used to encode the bitplane is determined by the value of IMODE. The seven coding modes are described in the following sections.<br>
Raw mode<br>
In thus mode, the bitplane is encoded as one bit per symbol scanned in the raster-scan order of macroblocks, and sent as part of the macroblock layer. Alternatively, the information is coded in raw mode at the field or frame level and DATABITS is rowMB * colMB bits in length.<br>
Normal-2 mode<br>
If rowMB x colMB is odd, the first symbol is encoded raw. Subsequent symbols are encoded pair wise, in natural scan order. The binary VLC table in Table 5 is used to encode symbol pairs.<br>
Table 5: Norm-2/Diff-2 Code Table(Table Removed)<br>
The Normal-2 method is used to produce the bitplane as described above, and then the Diff' operation is applied to the bitplane as described below.<br>
Normal-6 mode<br>
In the Norm-6 and Diff-6 modes, the bitplane is encoded in groups of six pixels. These pixels are grouped into either 2x3 or 3x2 tiles. The bitplane is tiled maximally using a set of mles, and the remaining pixels are encoded using a variant of row-skip and column-skip modes. 2x3 "vertical" tiles are used if and only if rowMB is a multiple of 3 and colMB is not. Otherwise, 3x2 "horizontal" tiles are used. For a plane tiled with linear tiles along the top and left edges of the picture, the coding order of the tiles follows the following pattern. The 6-elemcnt tiles are encoded first, followed by the column-skip and row-skip encoded linear tiles. If the array size is a multiple of 2x3 or of 3x2, the latter linear tiles do not exist and the bitplane is perfectly tiled.<br>
The 6-dement rectangular tiles are encoded using an incomplete prefix code, i.e., a prefix code which does not use all end nodes for encoding. Let N be the number of set bits<br>
18<br>
in the tile, i.e. 0 <n for n a vlc is used to encode the tile. fixed length escape followed by bit code and> 3, a fixed length escape is followed by the code of the complement of the tile.<br>
The rectangular tile contains 6 bits of information. Let /cbe the code associated with the tile, where k = b, 2', b, is the binary value of the i * bit in natural scan order within the tile. Hence 0 <k a combination of vlcs and escape codes plus fixed length is used to signal k.></k>
Diff-6 mode<br>
The Normal-6 method is used to produce the bitplane as described above, and then the Diff' operation is applied to the bitplane as described below.<br>
Rowskip mode<br>
In the rowskip coding mode, all-zero rows are skipped with one bit overhead. The syntax is as follows: for each row, a single ROWSKIP bit indicates if the row is skipped; if the row is skipped, the ROWSKIP bit for the next row is next; otherwise (the row is not skipped), ROWB1TS bits (a bit for each macroblock in the row) are next. Thus, if the entire row is zero, a xero bit is sent as the ROWSKIP symbol, and ROWBITS is skipped. If there is a set bit m the row, ROWSKIP is set to 1, and the entire row is sent raw (ROWBITS). Rows are scanned from the top to the bottom of the field or frame.<br>
Columnskip mode<br>
Columnskip is the transpose of rowskip. Columns are scanned from the left to the right of the field or frame.<br>
Diff-1:: Inverse differential decoding<br>
If either differential mode (Diff-2 or Diff-6) is used, a bitplane of "differential bits" is first decoded using the corresponding normal modes (Norm-2 or Norm-6 respectively). The differential bits are used to regenerate the original bitplane. The regeneration process is a 2-D DPC'M on a binary alphabet. In order to regenerate the bit at location (i, j), the predictor bp(ij) is generated as follows (from bits b(i, j) at positions <br>
For the differential coding mode, the bitwise inversion process based on INVERT is not performed. However, the INVERT flag is used in a different capacity to indicate the value of the symbol A for the derivation of the predictor shown above. More specifically, A equal to 0 if INVERT equals to 0 and A equals to 1 if INVERT equals to 1. The actual value of the bitplane is obtained by xor'ing the predictor with the decoded differential bit value. In the above equation, b(i j) is the bit at the i jth position after final decoding (i.e. after doing Norm-2/Norm-6, followed by differential xor with its predictor).<br>
Example Overlap Filter<br>
In one example overlap filter mode used in the second implementation of the conditional lapped transform, the overlap smoothing is carried out on the undamped 16 bit reconstruction at the decoder when signaled. This is necessary because the forward process associated with overlap smoothing may result in range expansion beyond the permissible 9 bit range for pixel values. The result of overlap smoothing is clamped down to 9 bits, in line with the remainder of the pixels not touched by overlap smoothing.<br>
Vertical edges (pixels aO, al, bl, bO in the above example) are filtered first, followed by the horizontal edges (pixels pO, pi, ql, qO). The intermediate result following the first stage of filtering (vertical edge smoothing) is stored in 16 bit. The core filters applied to the four pixels straddling either edge are given below:<br>
Â»3<br>
The original pixels being filtered are (xO, xl, x2, x3). rO and rl are rounding parameters, which take on alternating values of 3 and 4 to ensure statistically unbiased rounding. The original values are filtered by the matrix with entries that are clearly easy to implement. These values, after adding the rounding factors, are bit shifted by three bits to give the filtered output (yO, yl, y2, y3).<br>
For both horizontal and vertical edge filters, the rounding values are rO = 4, rl = 3 for odd-indexed columns and rows respectively, assuming the numbering within a block to start at 1   For even-indexed columns / rows, rO = 3 and rl = 4. Filtering is defined as an in-place 16 bit operation - thus the original pixels are overwritten after smoothing. For vertical edge filtering, the pixels (aO, al, bl, bO) correspond to (xO, xl, x2, x3), which in turn get filtered to (yO, yl, y2, y3). Likewise, for horizontal edge filtering, the correspondence is with (pO, pi, q I, qO) respectively. (Table Removed)<br>
Pixels in the 2x2 comer of a block, are filtered in both directions. The order of filtering determines their final values, and therefore it is important to maintain the order -vertical edge filtering followed by horizontal edge filtering - for bit exactness. Conceptually, clamping is to be performed subsequent to the two directional filtering stages, on all pixels that are filtered. However, there may be some computational advantage to combining clamping with filtering - this is an implementation issue as long as it is done carefully to generate the correct output.<br>
3.         Computing Environment<br>
The above described implementations of the conditional lapped transform can be performed on any of a variety of devices in which image and video signal processing is performed, including among other examples, computers; image and video recording, transmission and receiving equipment; portable video players; video conferencing; Web video streaming applications; and etc. The image and video coding techniques can be implemented in hardware circuitry (e.g., in circuitry of an ASIC, FPGA, etc.), as well as in image and video processing software executing within a computer or other computing environment (whether executed on the central processing unit (CPU), or dedicated graphics processor, video card or like), such as shown in Figure 10.<br>
Figure 10 illustrates a generalized example of a suitable computing environment (1000) in which the described conditional lapped transform may be implemented. The computing environment (1000) is not intended to suggest any limitation as to scope of use or functionality of the invention, as the present invention may be implemented in diverse general-purpose or special-purpose computing environments.<br>
With reference to Figure 10, the computing environment (1000) includes at least one processing unit (1010) and memory (1020). In Figure 10, this most basic configuration (1030) is included within a dashed line. The processing unit (1010) executes computer-executable instructions and may be a real or a virtual processor. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power. The memory (1020) may be volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory, etc.), or some combination of the two. The memory (1020) stores software (1080) implementing the described conditional lapped transform.<br>
A computing environment may have additional features. For example, the computing environment (1000) includes storage (1040), one or more input devices (1050), one or more output devices (1060), and one or more communication connections (1070).<br>
21<br>
An interconnection mechanism (not shown) such as a bus, controller, or network interconnects the components of the computing environment (1000). Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment (1000), and coordinates activities of the components of the computing environment (1000).<br>
The storage (1040) maybe removable or non-removable, and includes magnetic disks, magnetic tapes or cassettes, CD-ROMs, CD-RWs, DVDs, or any other medium which can be used to store information and which can be accessed within the computing environment (1000). The storage (1040) stores instructions for the software (1080) implementing the audio encoder that that generates and compresses quantization matrices.<br>
The input device(s) (1050) may be a touch input device such as a keyboard, mouse, pen, or trackball, a voice input device, a scanning device, or another device that provides input to the computing environment (1000). For audio, the input device(s) (1050) may be a sound card or similar device that accepts audio input in analog or digital form, or a CD-ROM reader that provides audio samples to the computing environment. The output device(s) (1060) may be a display, printer, speaker, CD-writer, or another device that provides output from the computing environment (1000).<br>
The communication connection(s) (1070) enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer-executable instructions, compressed audio or video information, or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired or wireless techniques implemented with an electrical, optical, RF, infrared, acoustic, or other carrier.<br>
The transform and coding/decoding techniques herein can be described in the general context of computer-readable media. Computer-readable media are any available media that can be accessed within a computing environment. By way of example, and not limitation, with the computing environment (1000), computer-readable media include memory (1020), storage (1040), communication media, and combinations of any of the above.<br>
The conditional lapped transform herein can be described in the general context of computer-executable instructions, such as those included in program modules, being executed in a computing environment on a target real or virtual processor. Generally, program modules include routines, programs, libraries, objects, classes, components, data<br>
22<br>
structures, etc, that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer-executable instructions for program modules may be executed within a local or distributed computing environment.<br>
For the sake of presentation, the detailed description uses terms like "determine," "generate," "adjust," and "apply" to describe computer operations in a computing environment. These terms are high-level abstractions for operations performed by a computer, and should not be confused with acts performed by a human being. The actual computer operations corresponding to these terms vary depending on implementation.<br>
In view of the many possible embodiments to which the principles of our invention may be applied, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto.<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
I/ we claim:<br>
1.	A method of transform coding digital media content, the method comprising:<br>
transform coding blocks of the digital media content;<br>
signaling the overlap filter mode from encoder to decoder of the digital media content on a per macroblock basis, wherein the overlap filter mode signaling includes a per macroblock overlap flag; and<br>
conditionally applying an overlap filter to a subset of edges between transform blocks of the digital media content before transform coding on a spatially varying basis, wherein the conditionally applying an overlap filter comprises:<br>
switching between a plurality of overlap filter modes applied to edges between adjacent transform blocks of the digital media content on the spatially varying basis, wherein such switching happens with macroblock-level granularity;<br>
applying the overlap filter to intra-macroblock transform block edges of a macroblock whose overlap flag signals to apply the overlap filter: and<br>
applying the overlap filter to transform block edges between adjacent macroblocks both of whose overlap flag signal to apply the overlap filter.<br>
2.	The method as claimed in claim 1, wherein the method further comprises:<br>
restricting the switching between the overlap filter modes based on a bit-rate related<br>
parameter, wherein the bit-rate related parameter is a frame-level quantization parameter.<br>
3.	A method of decoding a coded video bitstream. the method comprising:<br>
decoding block data of a plurality of encoded blocks of a frame in the coded<br>
video bitstream;<br>
performing dequantization of the decoded block data;<br>
performing an inverse transform of transform blocks of the decoded block data;<br>
determining an overlap mode for groups of more than one adjacent transform block edge from at least one syntax element of the coded video bitstream. wherein the at least one syntax element comprises a set of overlap mode flags having macroblock granularity;<br>
switching between plural overlap filters according to the determined overlap mode; and<br>
applying the respective overlap filter, including:<br>
applying the respective overlap filter to intra-macroblock transform block edges of a macroblock whose overlap flag signals to apply the respective overlap filter: and<br>
applying the respective overlap filter to transform block edges between adjacent macroblocks both of whose overlap flag signal to apply the respective overlap filter.<br>
4.	The method as claimed in claim 3, wherein the at least one syntax element further comprises a syntax element relating to a bit rate of the coded video bitstream.<br>
5.	The method as claimed in claim 4, wherein the syntax element relating to a bit rate of the coded video bitstream is a frame level quantization parameter.<br>
6.	The method as claimed in claim 3, wherein the set of overlap mode flags is encoded using bitplane coding.<br>
7.	The method as claimed in claim 3. wherein the at least one syntax element further comprises a frame-level overlap parameter and a frame-based bit-rate related parameter, and wherein the determining the overlap mode comprises:<br>
if the bit-rate related parameter indicates a low bit rate, determining to apply an overlap filter to the adjacent transform block edges within the frame:<br>
else, if the frame-level overlap parameter specifies no overlap, determining to apply a no-overlap filter to the adjacent transform block edges within the frame;<br>
else, if the frame-level overlap parameter specifies conditional overlap, determining to apply the overlap filter specified by the overlap mode flag of a macroblock to the adjacent transform block edges within the macroblock; and<br>
else, determining to apply the overlap filter to the adjacent transform block edges within the frame.<br>
8.	The method as claimed in claim 7. wherein the at least one syntax element further<br>
comprises a sequence-level overlap parameter, and wherein the determining the overlap mode<br>
further comprises, if the sequence-level overlap parameter specifies no overlap, determining to<br>
apply the no-overlap filter to the adjacent transform block edges within all frames of a sequence.<br>
9.	A method of decoding a video bitstream coded using a conditional lapped transform,<br>
the method comprising:<br>
determining an overlap condition at least having a no overlap state in which no overlap filter is applied to adjacent transform block edges, and an overlap state in which an overlap filter is applied to adjacent transform block edges, wherein the overlap condition varies spatially over pictures in a video sequence, and wherein the overlap condition is signaled in the video bitstream by a per macroblock overlap flag; and<br>
applying the overlap filter to adjacent transform block edges when the overlap condition is in the overlap state, wherein the applying comprises:<br>
applying the overlap filter to intra-macroblock transform block edges of a macroblock whose overlap condition is signaled to be in the overlap state: and<br>
applying the overlap filter to transform block edges between adjacent macroblocks both of whose overlap condition is signaled to be in the overlap state.<br>
10.	The method as claimed in claim 9. wherein the method further comprises:<br>
restricting the determining and applying the overlap filter based on a bit-rate related<br>
parameter.<br>
11.	The method as claimed in claim 10, wherein the bit-rate related parameter is a frame-<br>
level quantization parameter.<br></n></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtQWJzdHJhY3QtKDI3LTA5LTIwMTApLnBkZg==" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-Abstract-(27-09-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">507-delnp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtQ2xhaW1zLSgxNy0wNS0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-Claims-(17-05-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtQ2xhaW1zLSgyNy0wOS0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-Claims-(27-09-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">507-delnp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtY29ycmVzcG9uZGVuY2Utb3RoZXJzIDEucGRm" target="_blank" style="word-wrap:break-word;">507-delnp-2006-correspondence-others 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtQ29ycmVzcG9uZGVuY2UtT3RoZXJzLSgxNy0wNS0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-Correspondence-Others-(17-05-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtQ29ycmVzcG9uZGVuY2UtT3RoZXJzLSgyMC0wOS0yMDA3KS5wZGY=" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-Correspondence-Others-(20-09-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtQ29ycmVzcG9uZGVuY2UtT3RoZXJzLSgyNi0wMi0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-Correspondence-Others-(26-02-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtQ29ycmVzcG9uZGVuY2UtT3RoZXJzLSgyNy0wOS0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-Correspondence-Others-(27-09-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtY29ycmVzcG9uZGVuY2Utb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">507-delnp-2006-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">507-delnp-2006-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtRHJhd2luZ3MtKDI3LTA5LTIwMTApLnBkZg==" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-Drawings-(27-09-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">507-delnp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtRm9ybS0xLSgyNy0wOS0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-Form-1-(27-09-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtZm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">507-delnp-2006-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtZm9ybS0xMy0oMDQtMDUtMjAwOSkucGRm" target="_blank" style="word-wrap:break-word;">507-delnp-2006-form-13-(04-05-2009).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtZm9ybS0xMy0oMjAtMDktMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">507-delnp-2006-form-13-(20-09-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtRm9ybS0xMy0oMjQtMDktMjAxMCkucGRm" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-Form-13-(24-09-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtZm9ybS0xMy5wZGY=" target="_blank" style="word-wrap:break-word;">507-delnp-2006-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtZm9ybS0xOC5wZGY=" target="_blank" style="word-wrap:break-word;">507-delnp-2006-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtZm9ybS0yLnBkZg==" target="_blank" style="word-wrap:break-word;">507-delnp-2006-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtRm9ybS0zLSgyNi0wMi0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-Form-3-(26-02-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtZm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">507-delnp-2006-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtRm9ybS01LSgyNy0wOS0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-Form-5-(27-09-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">507-delnp-2006-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtR1BBLSgyMC0wOS0yMDA3KS5wZGY=" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-GPA-(20-09-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LURFTE5QLTIwMDYtR1BBLSgyNy0wOS0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">507-DELNP-2006-GPA-(27-09-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtZ3BhLnBkZg==" target="_blank" style="word-wrap:break-word;">507-delnp-2006-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtcGN0LTEwMS5wZGY=" target="_blank" style="word-wrap:break-word;">507-delnp-2006-pct-101.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtcGN0LTMwMS5wZGY=" target="_blank" style="word-wrap:break-word;">507-delnp-2006-pct-301.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtcGN0LTMwOC5wZGY=" target="_blank" style="word-wrap:break-word;">507-delnp-2006-pct-308.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTA3LWRlbG5wLTIwMDYtcGN0LTMxMS5wZGY=" target="_blank" style="word-wrap:break-word;">507-delnp-2006-pct-311.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="250021-a-novel-herbal-composition-effective-as-anit-pyretic-and-to-a-process-for-the-preparation-thereof.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="250023-moulding-compositions.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>250022</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>507/DELNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>48/2011</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>02-Dec-2011</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>29-Nov-2011</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>31-Jan-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>MICROSOFT CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>BUSINESS AT ONE MICROSOFT WAY, REDMOND, WASHINGTON 98052, USA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>POHSIANG HSU</td>
											<td>ONE MICROSOFT WAY, REDMOND WA 98052 USA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>SRIDHAR SRINIVASAN</td>
											<td>ONE MICROSOFT WAY, REDMOND WA 98052 USA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04N</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2004/028969</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-09-02</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/931,885</td>
									<td>2004-08-31</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/501,081</td>
									<td>2003-09-07</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/250022-coding-digital-media-content by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 14:40:02 GMT -->
</html>
