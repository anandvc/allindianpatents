<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/224450-method-of-graphics-data-compression by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 02:17:57 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 224450:METHOD OF GRAPHICS DATA COMPRESSION</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD OF GRAPHICS DATA COMPRESSION</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Method of compression of graphics data used for coding images in points mode (bitmap data), data having a succession of addresses of a conversion table called symbols S. Storing the various symbols in a dictionary (16), coding the symbols on the basis of its address in the dictionary (16), variable-binary— resolution coding (13) the address in the dictionary serving for coding the symbol.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>The invention relates to a method of real-time<br>
coding and decoding of graphics data and a real-time<br>
graphics coder/decoder (codec). It applies more<br>
particularly to the coding/decoding of display data for<br>
screens, better known by the expression On Screen<br>
Display or OSD. This type of display is employed in<br>
video decoders, TV sets, video recorders and, in<br>
general, in all types of video apparatus.<br>
The OSD display is used in identifying TV<br>
stations, in menus for setting up an appliance and in<br>
electronic guide menus for programmes (Programme<br>
Guide) , but also in more complex applications such as<br>
the visual display of a background of a weather map. It<br>
may involve only the visual display of these data on<br>
the screen, of overlays or of superimpositions with the<br>
video images.<br>
The data relating to this OSD display may be<br>
resident data, that is to say data held permanently in<br>
memories of the video apparatus using this type of<br>
display, or it may take the form of information<br>
installed when the hardware is manufactured, or even<br>
downloaded information. These data may also be<br>
transmitted over distance with the video data stream.<br>
This involves digital decoders, for example. In the<br>
case of video digital decoders of the MPEG type, an<br>
acronym for Motion Picture Expert Group, which process<br>
coded video data streams (video bitstreams) according<br>
to this MPEG standard, the video images are received in<br>
compressed form, particularly exploiting the spatial<br>
and temporal redundancy of the video sequences by<br>
virtue of movement estimation and of the discrete<br>
cosine transform. The OSD data are not related to this<br>
processing and are incorporated into the MPEG data<br>
stream in an uncompressed form and are stored in the<br>
decoder in this form so as to be made use of in real<br>
time.<br>
The applications employing OSD display are<br>
becoming more and more complex, requiring ever larger<br>
amounts of data to be stored. The random-access<br>
memories RAM allocated to the OSD data, for reasons of<br>
cost, thus limit such applications or else cause the<br>
resolution of the images or patterns generated to be<br>
reduced, or else restrict the diversity of the menus<br>
and of the applications.<br>
The object of the present invention is to<br>
remedy the abovementioned drawbacks.<br>
Its subject is a method of compression of<br>
graphics data used for coding images in points mode<br>
(bitmap data), data consisting of a succession of<br>
addresses of a conversion table called symbols S,<br>
characterized in that it comprises the following<br>
stages:<br>
storage of the various symbols in a<br>
dictionary,<br>
- coding of the symbol on the basis of its<br>
address in the dictionary,<br>
variable-binary-resolution coding of the<br>
address in the dictionary serving for coding the<br>
symbol.<br>
According to a particular implementation, the method is<br>
characterized in that it comprises the following<br>
stages:<br>
- a run-length coding of the symbols so as, for<br>
each range of identical successive symbols, to give a<br>
number L corresponding to the number of identical<br>
symbols, associated with the symbol S,<br>
- a variable-binary-resolution coding of L as a<br>
function of the value of L.<br>
The invention also relates to a device for<br>
compressing graphics data used for coding images in<br>
points mode (bitmap data), data consisting of a<br>
succession of addresses of a conversion table called<br>
symbols S sent in a data stream, characterized in that<br>
it comprises a run-length coder which receives the data<br>
stream in order, for each run length, to supply a<br>
number L associated with a symbol S, a variable-binary-<br>
resolution coder by class for coding L, a variable-<br>
binary-resolution symbol coder comprising a dictionary<br>
for memory storage of the various symbols and a<br>
variable-binary-resolution coder of the address in the<br>
dictionary, for coding S.<br>
The invention also relates to a device for<br>
decompressing graphics data, characterized in that it<br>
comprises a memory for memory storage of the<br>
dictionary, a field-identification circuit receiving<br>
the compressed data stream for detecting the binary<br>
resolution of L and S and extracting the coded values<br>
of L and S, a symbol S extraction circuit, the<br>
extraction circuit being linked to the memory for<br>
sending the coded value of S as an address and<br>
recovering the content of the address, a run-length<br>
decoding circuit for decoding the coded value of L, a<br>
circuit for generating the sequence of symbols<br>
receiving the decoded run-length value L for the symbol<br>
S and the decoded value of the symbol S in order to<br>
send out L times the value S in the stream.<br>
The values to be compressed generally relate to<br>
data of bitmap type. These are addresses of the values<br>
of effective pixels, that is to say the luminance<br>
and/or chrominance values of the pixels visually<br>
displayed on the screen, which are stored in a palette<br>
of colours called palette. The images are then said to<br>
be palletized.<br>
The two essential stages of the compression are<br>
therefore:<br>
- variable-resolution coding of the length of<br>
every sequence of identical symbols, called run length.<br>
For each run length of identical successive symbols, of<br>
length L, the length L of each repetitive sequence<br>
detected is coded with a resolution which is variable<br>
as a function of its parent class which depends on the<br>
value of the run-length L. Coding by class makes it<br>
possible to attribute an optimal (minimal) code which<br>
is variable as a function of the parent class L. These<br>
classes are defined statistically, being based on a<br>
large population of graphics images.<br>
variable-binary-resolution coding of the<br>
symbol itself as a function of the order in which it<br>
occurs in an adaptive dictionary. This is achieved by<br>
storing the various symbols in a dictionary, as and<br>
when they are encountered, and coding the symbol on the<br>
basis of its actual address in the dictionary, which<br>
corresponds to a variable binary coding which increases<br>
with the number of colours encountered. By effective<br>
address should be understood the disregarding, for the<br>
address words, of non-activated high-order bits at<br>
zero.<br>
One characteristic of the invention is of<br>
compressing this OSD information before storing it or<br>
else storing compressed information when resident data<br>
are involved. The compression algorithm used is simple,<br>
allowing real-time applications while giving a high<br>
compression ratio by virtue of the graphics coding used<br>
for the OSD display. This is because, on the one hand,<br>
the number of colours used during such coding is<br>
limited in itself in order to reduce the amount of data<br>
to be sent to the video recorder or to be stored in<br>
this decoder. Moreover, OSD displays generally exhibit<br>
areas of uniforms colour and repetitive patterns.<br>
This algorithm therefore implements a<br>
combination of two types of coding: Run Length Coding<br>
(RLC) and variable-binary-resolution coding, both for<br>
the coding of the run lengths and for the coding of the<br>
symbols, that is to say of the addresses. By virtue of<br>
the invention, the random-access memory requirements of<br>
decoders, television receivers, video recorders, etc.<br>
are reduced. The cost of production of the hardware is<br>
reduced or, for a given cost, the applications relating<br>
to on-screen display (OSD) are of higher performance<br>
and/or the displays are of better quality.<br>
The characteristics and advantages of the<br>
present invention will emerge better from the following<br>
description, given by way of example and by reference<br>
to the attached figures in which:<br>
- Figure 1 represents a coder of bitmap data<br>
according to the invention,<br>
- Figure 2 represents a coder by class for<br>
coding L,<br>
- Figure 3 represents a symbol S coder,<br>
- Figure 4 represents a flowchart of the method<br>
of coding bitmap data,<br>
- Figure 5 shows an example of coding a stream<br>
of bitmap data,<br>
- Figure 6 represents a decoder of bitmap coded<br>
data,<br>
- Figure 7 represents a flowchart of the method<br>
of decoding bitmap coded data.<br>
Figure 8 shows an example of decoding<br>
stream of bitmap coded data,<br>
- Figure 9 represents a codec.<br>
Numerous solutions exist these days as to the<br>
definition of OSD display, memory storage and use of<br>
the corresponding data. In general, OSD data are stored<br>
in the form of bitmaps, the widely-used expression<br>
meaning that the image is coded in points mode, that is<br>
to say on the basis of data (luminance, chrominance)<br>
describing the display (the image) in terms of pixels.<br>
Memories or registers of palettes of colours contain<br>
the various colours necessary for generating the<br>
symbols and graphics. Vector-type addressing of these<br>
colours is carried out by defining these colours not by<br>
their coding proper but by their address in a register<br>
of palettes. This register of palettes is also called<br>
colour-conversion table or Colour Look Up Table (CLUT).<br>
The OSD information is generally distributed<br>
into regions or areas over an image, areas defined by<br>
coordinates. For each region, all the colours necessary<br>
for coding the pixels belonging to this region<br>
correspond to a palette of colours for this region. For<br>
each region, a bitmap allocates to each pixel of the<br>
region an address in the conversion table containing<br>
the luminance and chrominance information for these<br>
pixels, i.e. Y, U, V.<br>
An example of storage of data received by an<br>
MPEG decoder in a random-access memory RAM of this<br>
decoder, according to the prior art, is described<br>
below. A first part of the RAM memory stores the stream<br>
of compressed MPEG data, a second part stores the<br>
display specific to the OSD display (OSD data) and a<br>
third part stores, for example, the video data of the<br>
decompressed images which will be necessary, for<br>
example, for re-ordering the images according to the<br>
MPEG standard.<br>
In more detail, the memory storage of the OSD<br>
data is itself organized into three areas, a first area<br>
corresponding to the coordinates, a second area<br>
corresponding to the palette of colours and a third<br>
area corresponding to the bitmap data. In the first<br>
area of the memory allocated to the data of a defined<br>
OSD region are therefore stored the coordinates making<br>
it possible to define the place at which this region<br>
will be displayed on the screen. In the second area is<br>
stored the palette of colours necessary for<br>
representing this region, or CLUT conversion table,<br>
then, in the third area, for each pixel, the address in<br>
the conversion table (CLUT) corresponding to the coding<br>
of the pixel in terms of luminance and chrominance.<br>
These data in this third area are called bitmap data.<br>
Figure 1 represents a coder 1 implementing the<br>
method of coding and compression of OSD data before<br>
storage in the RAM memories, for example the memories<br>
of an MPEG decoder. The OSD data in question are in<br>
fact the bitmap data. These bitmap data which, as<br>
described above, represent a succession of addresses<br>
which will be called symbols S are received as input of<br>
the coder 1 represented in dashes on the figure and<br>
which groups together circuits 2 to 5. These data are<br>
forwarded to a fixed-binary-resolution run-length coder<br>
2. This coder supplies L information on a first output<br>
and S information on a second output, corresponding,<br>
for each region, to the number L of successive<br>
identical symbols S received as input. The output<br>
supplying the value L is sent to the input of a<br>
variable-binary-resolution coder by class 3 for coding<br>
this value L according to its parent class and the<br>
output supplying the value S is sent to the input of a<br>
variable-binary-resolution symbol coder 4. The outputs<br>
of the coders 3 and 4 supply respectively the coded<br>
values L and 5 of L and S and are linked to the inputs<br>
of a multiplexer 5 the output of which is the output of<br>
the coder 1.<br>
The run-length coder 2 makes use of the method<br>
of coding by extent, better known by the title Run<br>
Length Coding or RLC. The principle of run-length<br>
coding consists in calculating the Lk successive<br>
repetitions of a kth symbol Sk and in replacing the<br>
sequence of repetitions of this symbol by the pair Vk =<br>
(LK, Sk). Lk corresponds to the number of repetitions of<br>
the same symbol Sk. Each value of the pair is then coded<br>
separately using a special coding described below.<br>
The coding of the value L is carried out as a<br>
function of its parent class, by the variable-binary-<br>
resolution coder by class 3. The coding principle<br>
employed by this coder is represented in Figure 2.<br>
The information L to be coded coming from the<br>
run-length coder 2 is sent simultaneously to a class-<br>
detection circuit 6 and a variable-resolution coding<br>
circuit 7, the latter supplying the coded value of L,<br>
L, forwarded at the output of the coder 3.<br>
The class-detection circuit consists, in our<br>
example, of 5 comparators 8 specific to each of the<br>
classes and receiving, in parallel, the information<br>
sent to the input of the coder 3, that is to say the<br>
value L (binary coded). Each comparator possesses three<br>
outputs corresponding respectively to an item of<br>
information at the input of the comparator below the<br>
limits, above the limits, or within the limits of the<br>
class (or interval) specific to this comparator. The<br>
outputs of the comparators are linked to a logic<br>
circuit 9 which groups together all the information<br>
originating from the comparators. It possesses 5<br>
outputs, which are also the outputs of the class-<br>
detection circuit 6, one output for each class, linked<br>
to five inputs of the variable-binary-resolution coding<br>
 circuit 7. This coding circuit 7 consists of a<br>
transcoder 10 which receives, as input, the information<br>
corresponding to the value L (binary coded) and the<br>
five inputs indicating to which class this value<br>
belongs. The five outputs of the transcoder are linked<br>
to five inputs of a multiplexer 11 the output of which<br>
is the output of the coder 3. This output supplies a<br>
coded data stream L corresponding to the input data<br>
stream L<br>
Before detailing the functioning of the<br>
circuit, we will describe the principle of variable-<br>
binary-resolution coding applied to the coding by<br>
class.<br>
An area in which the value L can change is pre-<br>
defined on the basis of a value m such that 22m+2-l<br>
corresponds to the maximum possible value for coding L<br>
(maximum number of repetitions of the symbol) . This<br>
area is broken down into m+1 intervals of values, each<br>
interval being bounded by the values 22n and 22n+2-l, n<br>
varying from zero to m, one interval corresponding to<br>
one class. The principle of variable-binary-resolution<br>
coding by class consists in attributing a different<br>
resolution to each class. This binary resolution<br>
corresponds to the number of bits for coding L and thus<br>
depends on the class to which the value L belongs. It<br>
is a question, in fact, of taking into account, in the<br>
binary word L, only the "effective" coding bits, that<br>
is to say of ignoring the higher-order bits at zero,<br>
knowing that the non-transmission of these bits will<br>
correspond to the value zero. The coding is at low<br>
binary resolution for low values of L (n = 0, 1) and<br>
higher binary resolution for higher values (n = 2, 3,<br>
4) .<br>
The various classes are identified by means of<br>
a particular code called identification code (the<br>
binary word for coding L, without taking account of the<br>
identification bits, will be represented by the symbol<br><l>). This code, which is a number of zeros sent before<br>
the coding word <l>, makes it possible therefore to<br>
identify the number of bits over which the value of the<br>
run-length L which immediately follows is coded. The<br>
words for coding L, represented by the symbol L ,<br>
therefore consist of two parts: a first part consisting<br>
of zero and making it possible to identify the class to<br>
which the value L belongs, and a second part <l> coding<br>
this value in base 2, with the minimum number of bits<br>
necessary for this coding.<br>
An example is indicated in the table below for<br>
a value of m equal to 4, L then possibly having a<br>
maximum value of 1023:<br>
The various coding classes Rn = 22n, 22n+2 -1 are<br>
1-3, 4-15, 16-63, 64-255, 256-1023. The "coding by<br>
class" column relates to the binary word <l> used for<br>
coding the L value representing the number of<br>
repetitions of the symbol S. The "identification code"<br>
column represents the bits for identifying the class.<br>
The "resolution" column indicates the number of bits<br>
necessary for coding L (this means the complete coding<br>
word I grouping together the identification code and<br>
the coding word <l>).<br>
For example a value L = 5 is coded by a 6-bit<br>
binary word (00.0101) whereas the value 49 is coded by<br>
a 10-bit binary word (0000.110001). The point is simply<br>
an indication of the juxtaposition of two different<br>
codes, the identification code followed by the <l><br>
coding. As no L value corresponding to an <l> coding<br>
word beginning with two zeros exists (L is at least<br>
equal to 1), the identification of each of the parts,<br>
or more exactly the detection of the identification<br>
code, poses no problem in terms of the decoding.<br>
Let us return to the functioning of the device<br>
represented in Figure 2.<br>
Five comparators 8 corresponding to each of the<br>
five classes receive the L information in parallel on<br>
their input. Each comparator possesses three outputs<br>
and activates the first, second or third output<br>
according to whether the value received as input is<br>
less than, in the interval or greater than the interval<br>
corresponding to the class attributed to this<br>
comparator. This information is forwarded to the logic<br>
circuit 9 which activates the output corresponding to<br>
the class to which the L information belongs (this is<br>
obviously one embodiment example, and it could also be<br>
envisaged that the second output of each comparator be<br>
forwarded directly as output of the circuit 6) . The<br>
class detection circuit then sends the variable-<br>
resolution coding circuit 7, on one of its five<br>
outputs, information corresponding to the class to<br>
which the value L belongs. This information is received<br>
by the circuit 10 for each L value received as input of<br>
the coding circuit 7. The transcoding carried out by<br>
the transcoding circuit 10 consists first of all in<br>
obtaining <l> by carrying out a truncation of the L-<br>
coding binary word received by the coder 3 and<br>
consisting at the outset of 10 bits for coding the<br>
values 1 to 1023. This truncation makes it possible to<br>
keep the 2, 4, 6, 8 or 10 lower-order bits of this<br>
coding word, according to whether the corresponding<br>
class information is respectively the 1st, 2nd, 3rd,<br>
4th or 5th class. It then consists in adding the<br>
identification code before the binary word thus<br>
obtained, namely 0, 2, 4, 6 or 8 bits of zero value<br>
according to whether the corresponding class<br>
information is respectively the 1st, 2nd, 3rd, 4th or<br>
5th class, giving L -coding words over 2, 6, 10, 14 or<br>
18 bits. The transcoded binary words are sent to one of<br>
the inputs of the multiplexer 11 which supplies, at its<br>
output, the coding L of the information L presented at<br>
the input. The coder 3 thus delivers, as output, a<br>
succession of L-coding words corresponding to the<br>
values of L received as input.<br>
The coding of the value of the symbol S is<br>
carried out by the symbol coder 4. The principle for<br>
coding the value S is detailed in Figure 3.<br>
The input of the coder 4 is linked to the input<br>
of a generation circuit of the dictionary 1.2 and<br>
receives the binary value of the symbol S. The 7<br>
outputs of the circuit are linked to 7 inputs of a<br>
transcoding circuit 13 the output of which is the<br>
output of the symbol coder 4. The input of the coder 4<br>
is linked to a first input of a comparator 14 and to a<br>
first input of a random-access memory called dictionary<br>
15. The output of the comparator is linked to the clock<br>
input of an 8-bit counter 16. The output of this<br>
counter is linked to the address input of the random-<br>
access memory 15. It is also linked to a first input of<br>
a logic circuit 18 and to the input of a memory circuit<br>
17, the output of which is linked to the second input<br>
of the logic circuit 18. This logic circuit possesses 7<br>
outputs which are the outputs of the generation circuit<br>
of the dictionary 12. They are linked to 7 inputs of a<br>
transcoding circuit 13 which, at its output, supplies<br>
the coding of the symbol S, i.e. S.<br>
The coding procedure is based essentially on<br>
the allocation of address in the dictionary. Hence,<br>
every time a symbol is received by the generation<br>
circuit of the dictionary 12, its binary value is<br>
compared with all the values stored in memory in the<br>
dictionary 12 by means of the comparator 14. In order<br>
to do this, a management circuit, not represented in<br>
the figure, controls the counter which scrolls the<br>
addresses as input to the dictionary 15 upon each<br>
arrival of a new symbol and each memory-stored value<br>
corresponding to these addresses is compared with the<br>
binary value of the symbol received. When the result of<br>
the comparison is negative, the 8-bit counter is<br>
incremented by comparison with the address of the last<br>
symbol stored in memory and the new symbol is stored in<br>
memory at this new address and is added to the<br>
dictionary.<br>
The circuit 17 stores the highest address used<br>
for memory storage of a symbol in the dictionary and in<br>
particular the number t of "meaningful" bits over which<br>
this address is coded, that is to say the minimum<br>
number t such that 2t-1 is a greater than or equal to<br>
the binary value of the highest address, the minimum<br>
value of t being taken to be equal to 2 (the value t can<br>
therefore not reduce) . It forwards the value of t to<br>
the circuit 18 so that the latter transmits only a<br>
number of bits, those of lower order, corresponding to<br>
the number t of meaningful bits coding the address of<br>
the last symbol stored in memory. One output of this<br>
logic circuit is allocated to each value of t, t lying<br>
between 2 and 8 for a possible memory storage of 256<br>
values in the dictionary. The outputs are linked to the<br>
coding circuit 13 which carries out the following<br>
transcodings. The binary information received on the<br>
first input and thus over two bits is forwarded as it<br>
stands as output. When the binary information switches<br>
over onto the second input, indicating a coding of the<br>
address of the dictionary over 3 bits, a series of 10<br>
bits at the value zero precedes the coding of this last<br>
binary word received over 3 bits. Every time the binary<br>
information switches over from one input to the other,<br>
indicating a coding over a higher number of bits, a<br>
series of 10 bits at the value zero is added in front<br>
of the first binary word received on this input.<br>
The dictionary codes an address (a symbol) by a<br>
new address. It contains only the useful symbols, that<br>
is to say the addresses corresponding to the colours<br>
employed in the palette of colours for the OSD coding.<br>
For example, a region for which the symbol is coded<br>
over 8 bits has a palette of 256 colours. If only 64<br>
colours from among the 256 are used in this region, the<br>
dictionary then contains 64 symbols.<br>
The coding of each symbol is therefore done on<br>
the basis of its own address in the dictionary. It<br>
makes use of variable-binary-resolution coding, the<br>
information relating to this resolution being supplied<br>
by the addition of zeros. In the preceding example,<br>
there are 64 colours and the coded symbols have a<br>
binary resolution of 6 bits instead of 8 bits. By this<br>
operation alone, a saving of 25% is obtained. This is<br>
because many OSD regions use fewer than 256 colours,<br>
making this coding effective.<br>
Let us give an example of operation below:<br>
At the start of the cycle of sequential reading<br>
of the symbol, from the bitmap data, it is assumed that<br>
the OSD region has fewer than 4 different colours, the<br>
first symbol coded thus having a resolution of 2 bits.<br>
Each time a new, not already coded, symbol appears,<br>
that is to say a symbol not existing in the dictionary,<br>
it is stored in memory in the dictionary and the<br>
address is incremented. The first symbol is stored at<br>
address 0 and its code is therefore the value 00<br>
whatever the value of this first symbol. When a new<br>
symbol is read, it is stored at address 01, its code is<br>
consequently 01. The fourth new symbol is dealt with in<br>
the same way and its code is 11. If the other values<br>
read are those stored in memory in the dictionary,<br>
their code will be the address lying between 00 and 11.<br>
The binary resolution is then 2 bits instead of the 8<br>
bits over which the received symbols are coded. This is<br>
the case until a new symbol different from the four<br>
stored in memory in the dictionary is received. Then<br>
the resolution is incremented and changes to 3 bits for<br>
all the other symbols encountered. If a 6th symbol read<br>
already exists in the dictionary at address 01, its<br>
code will now be 001. The method continues until the<br>
dictionary contains more than 128 colours. From this<br>
stage, all the symbols have a resolution of 8 bits.<br>
In order to carry out decoding of the symbol<br>
without ambiguity, a special code is therefore<br>
generated every time the resolution of the address of<br>
the dictionary is incremented. In the worst case, this<br>
code will be generated six times. The code is a<br>
sequence of 10 zeros. This is because only nine<br>
consecutive zeros (including eight for the<br>
identification code) are necessary for coding by run<br>
length L, for values above 255.<br>
The algorithm for coding the symbol S is<br>
represented in Figure 4. Stage 20 consists in<br>
initializing the various parameters. A dictionary D is<br>
created with, at the outset, no data stored in memory.<br>
Notations:<br>
The symbol S is coded in the form c or z.c.<br>
z is the identification code corresponding to<br>
10 zeros,<br>
c corresponds to the binary address at which<br>
the symbol is stored in memory (variable number of<br>
bits),<br>
t is the number of bits used for coding c,<br>
i is the index of the address of the dictionary<br>
D at which the symbol received as the input of the<br>
coder is stored in memory or recovered, and<br>
n is the number of symbols (or colours) stored<br>
in memory in the dictionary.<br>
At initialization, the value t is forced to 2,<br>
the index i is set to the address 1 (binary form 01).<br>
When the first symbol a is received, its values<br>
stored in memory at address 1 of the dictionary.<br>
D(l) = a, n = 1.<br>
A new symbol is read at the following stage 21.<br>
The stage 22 verifies whether the symbol<br>
already exists in the dictionary D. If yes, the stage<br>
23 is run which will search for the value of the<br>
address i in the dictionary for which the word stored<br>
in memory corresponds to this symbol. The following<br>
stage 24 codes the symbol S with the binary value of i.<br>
c = binary form of the address i.<br>
If the symbol does not appear in the<br>
dictionary, stage 25 is run after stage 22. This stage<br>
increments the value n and the new symbol in stored in<br>
memory at address i = n. The following stage 26<br>
verifies whether the new value n requires an additional<br>
coding bit.<br>
Hence, if n is higher than the value 2t, t being<br>
the number of bits over which the address of the last<br>
symbol entered into dictionary is coded, stage 27 is<br>
carried out. The value t is incremented since the new<br>
address is coded over an additional bit. The binary<br>
resolution of c is incremented as a consequence, and an<br>
identification code z of 10 zeros precedes this value<br>
c. The following operations are carried out at stage<br>
27:<br>
generation of 10 zeros<br>
t = t+1<br>
binary resolution of c = t<br>
Stage 28 succeeds stage 27, a stage in which<br>
the index i is given the value n, and the symbol a is<br>
stored in memory in the dictionary at address i.<br>
i = n<br>
D(i) = a<br>
If, at stage 26, it is noted that n is less<br>
than or equal to the value 2t, the following stage is<br>
stage 28 directly.<br>
The stage succeeding stage 28 is stage 24 which<br>
therefore codes the value of the symbol by the binary<br>
value of the address i, preceded by 10 zeros if stage<br>
27 has been implemented.<br>
Figure 5 shows an example of coding on the<br>
basis of a bitmap data stream to be coded referenced 30<br>
in the figure. L corresponds to the number of<br>
repetitions of the symbol and S corresponds to the<br>
value of the symbol.<br>
s is the binary word for coding the symbol S.<br>
In step with the coding of the bitmap data stream 30,<br>
the dictionary D fills up with the values of the<br>
symbols S and the memory-storage addresses are used for<br>
coding the symbols. The value 32 to be coded is the<br>
fifth value differing from the preceding ones, to be<br>
stored in the dictionary. On the basis of this value in<br>
the data stream, the binary coding word S is therefore<br>
a word of at least 3 bits.<br>
L is the binary word for coding the value L.<br>
When the value of L is in the interval 1-3, the binary<br>
coding word L is a 2-bit word. When the value of L is<br>
in the interval 4-15, the binary word for coding L is a<br>
6-bit word, the first two bits at zero to indicate the<br>
resolution of the coding, here over four bits.<br>
The compressed data stream, referenced 31, is<br>
represented at the bottom of the figure. It corresponds<br>
to the succession of binary words L and S for each run<br>
length. Every time a new value of S is encountered in<br>
the data stream 30, a new L, S pair is coded. During<br>
the coding of the symbol with value 32, the binary<br>
resolution is incremented, the coding being done over 3<br>
bits from this point on. Consequently, in the binary<br>
stream, a succession of 10 zeros is sent just before<br>
the coding of the corresponding L, S pair.<br>
The decoding methods and circuits are described<br>
below.<br>
The coded bitmap data, available at the output<br>
of the above-described OSD coder, are stored in a RAM<br>
memory of the video decoder, this memory being<br>
accessible by the OSD coder and the OSD decoder<br>
integrated into this video decoder as described later.<br>
The information stored in this memory is also the<br>
palette of colours, the coordinates defining the OSD<br>
areas as received by the video decoder, and also the<br>
dictionary constructed by the OSD coder and transferred<br>
into the RAM.<br>
The decoding device 32 according to the<br>
invention is represented in Figure 6.<br>
The bus associated with the RAM memory of the<br>
video decoder is linked to a FIFO memory 33 and to a<br>
conversion table or memory 35 with a capacity of that<br>
of the above-described dictionary. The data at the<br>
output of the FIFO memory are sent to a field<br>
identification circuit 34. A first output of this<br>
circuit is sent to a run-length decoding circuit 37. A<br>
second output is linked to a first input of a symbol-<br>
extraction circuit 36. The memory 35, which also<br>
receives the information originating from the bus of<br>
the RAM memory, is linked to a second symbol-extraction<br>
circuit 36. The output of this latter circuit is linked<br>
to a second input of a circuit for generating the<br>
sequence of symbols 38. The output of the run-length<br>
decoding circuit 37 is linked to the first input of<br>
this circuit the output of which is the output of the<br>
decoder 32 represented in dashed line.<br>
Hence, in the first place, the data, from the<br>
dictionary which is created at the coder upon coding<br>
the OSD data and which are stored in memory in the RAM<br>
in the form of a conversion table, are transferred, via<br>
the RAM memory bus, to the memory 32 so as to allow the<br>
decoder to make use of this information directly from<br>
this memory when calculating the symbols, that is to<br>
say without requiring access to the RAM memory.<br>
The stream of point-mode-coded data (bitmap<br>
encoded bitstream or BEB) or coded bitmap data stored<br>
in memory in the RAM of the video decoder is sent to<br>
the FIFO memory. This memory, which has a regulating<br>
role, sends this data stream to the field-<br>
identification circuit 31. The circuit makes it<br>
possible to detect the sequences of zeros and to<br>
identify the coding fields.<br>
The FIFO memory supplies a data stream<br>
consisting of three successive parts, according to the<br>
above-described compression protocol:<br>
- a code field<br>
- a run-length field<br>
- a symbol field<br>
These fields are of variable size. The code<br>
field which has a maximum size of 19 bits corresponds<br>
to the sequence of 10 zeros inserted in order to<br>
indicate the change of binary resolution of c (coding<br>
of S) followed by the code for identification of the<br>
class (8+1 zeros at most), indicating the binary<br>
resolution of <l> (coding of L) . It thus makes it<br>
possible to determine the number of bits n1 over which<br>
the value of L is coded and that, ns, over which the<br>
address of the symbol is coded.<br>
When the number of zeros in the code field is<br>
less than 10, the corresponding sequence of zeros, for<br>
example p zeros, relates only to the coding of L when<br>
this number is higher than 10, the first 10 zeros<br>
indicate that the binary resolution of c is incremented<br>
and the number p of remaining zeros of the sequence<br>
relates to the coding of L.<br>
The value of p indicates the number of bits n±<br>
over which the run length is coded:<br>
- if p is even, n± = p+2<br>
- if p is odd, n1 = p.<br>
Once the values of n1 and ns have been<br>
calculated, the symbol and run-length fields can be<br>
identified. The values corresponding to these fields<br>
can then be extracted.<br>
Hence, the field-identification circuit 34<br>
extracts the coded binary words from the stream<br>
corresponding to the coding of the run length in order<br>
to send them, on a first output, to the run-length<br>
decoding circuit 37 and the coded binary words of the<br>
stream corresponding to the coding of the symbol so as<br>
to send them on a second output to the symbol-<br>
extraction circuit 36. The run-length decoding circuit<br>
supplies the value L at its output. The symbol-<br>
extraction circuit will seek, on the basis of the<br>
address received from the field-identification circuit<br>
34, the binary value of the symbol S stored in memory<br>
at this address in the memory 35. The circuit for<br>
generating the sequence of symbols 38 receives these L<br>
and S values and, on its output, gives the data stream<br>
corresponding to each value of S repeated L times.<br>
A decoding algorithm employed by this OSD<br>
decoder is represented in Figure 7.<br>
A first stage 40 consists in reading and<br>
transferring the dictionary stored in the RAM memory of<br>
the video decoder to the memory 32 of the OSD decoder.<br>
The number of bits t for coding the symbol c is<br>
initialized at 2. The following stage 41 detects the<br>
sequence of zeros in the data stream sent by the FIFO<br>
memory and stores the number n of successive zeros in<br>
memory as long as this number is less than 10. As soon<br>
as this number is equal to 10 or as soon as the<br>
sequence of zeros is terminated, stage 42 is triggered<br>
which will distinguish these two cases:<br>
- if n has reached the value 10, the following<br>
stage 43 increments the value of t used for coding c,<br>
then the stage 41 is followed and measures the new<br>
number of zeros n remaining after the first 10 zeros<br>
detected.<br>
- if n is less than 10, stage 44 carries out<br>
run-length decoding. To do this, the number of zeros<br>
less than 10 or the number of zeros remaining if stage<br>
43 has been gone through, a number previously called p,<br>
is used to determine the number of bits, successive to<br>
these zeros, to be taken into account for decoding L,<br>
this number being a function of the parity of p as<br>
indicated above.<br>
After decoding the value of the run length L,<br>
the following stage 45 reads the number of bits t which<br>
follow the bits for coding the run length in order to<br>
determine the value c. Stage 46 will then search, in<br>
the memory 32, for the content of the address c which<br>
is the value of S.<br>
Figure 8 gives an example of decoding the data<br>
stream coded according to the invention, the data<br>
stream being referenced 47 in the figure.<br>
At the outset, the value ns is initialized at 2.<br>
The code field corresponds to a single zero.<br>
Consequently, the value of ns remains equal to 2 and the<br>
value of n1 is equal to 1 (p = 1). The run-length field<br>
contains the value 1 and the symbol field contains the<br>
value 00. Consequently, the value of L is equal to 1<br>
and the value of S is the content of the dictionary at<br>
the address 00, i.e. 6. The following code field<br>
contains a single zero value, the lengths of the fields<br>
are therefore unchanged and the value of the symbol is<br>
found at address 01 of the dictionary. When a<br>
succession of zeros greater than or equal to 10 is<br>
encountered, the binary resolution for coding L<br>
changes. In our example a succession of 13 zeros<br>
appears. Hence, ns is incremented and S is read over 3<br>
bits. The 3 zeros succeeding the 10 bits at zero<br>
indicate that the run-length field has a dimension of 3<br>
bits. L is therefore coded by the 3 bits 101 and S by<br>
the following 3 bits 100. Hence, the value 32 found at<br>
address 100 is repeated 5 times.<br>
The decoded data stream thus obtained is<br>
represented at the bottom of the figure under the<br>
reference 48. It corresponds to the succession of S<br>
binary words as received by the video decoder, that is<br>
to say before OSD coding and memory storage in the RAM.<br>
Figure 9 gives an example configuration of a<br>
codec consisting of an OSD coder and of an OSD decoder<br>
installed in a video decoder. The codec 50 represented<br>
in the figure in dashed line is linked to the RAM<br>
memory 4 9 of the video decoder via a memory bus.<br>
The bitmap data, the coordinates of the OSD<br>
regions and the palette of colours, data received by<br>
the video decoder and relating to the OSD information,<br>
are sent to an input of the OSD codec, for example via<br>
an interface of a microcontroller of the video decoder,<br>
not represented in the figure. This input is linked to<br>
the input of a bus controller circuit 51 and this OSD<br>
information passes through the bus controller circuit<br>
51 which directs the bitmap data, via a first output,<br>
to the OSD coder 52 and the palette of colours and the<br>
OSD coordinates, via a second output, to a first input<br>
of an input/output circuit 53. The output of the OSD<br>
coder 52 is linked to a second input of the<br>
input/output circuit 53. This circuit 53, by means of a<br>
bidirectional link, exchanges the data with the part<br>
outside the codec, in particular the RAM memory. The<br>
circuit 53 is linked, via a first output, to the OSD<br>
decoder 54 and, via a second output, to a first output<br>
of the codec 50. The output of the OSD decoder 54 is<br>
linked to a second output of the codec 50. The first<br>
output of this codec 50 is linked to a first input of a<br>
memory 55 of the video decoder. The second output of<br>
this codec 50 is linked to a second input of the memory<br>
55. Finally, this memory 55 is linked to a circuit for<br>
generating luminance and chrominance signals 56 which<br>
supplies the Y, U, V information as output.<br>
Hence the bitmap data received by the video<br>
decoder are sent to the OSD coder 52 via the bus<br>
controller 51 and the coded data at the output of this<br>
coder are sent, via the input/output circuit 53, to the<br>
RAM memory of the video decoder to be stored there. The<br>
other OSD data relating to the palette and the<br>
coordinates are also sent to the RAM memory via the bus<br>
controller and the input/output interface to be stored<br>
there in memory areas. The dictionary which was created<br>
in the coder is also transferred to the RAM memory. All<br>
this information, compressed in the case of the bitmap<br>
data, not compressed in the case of the palette, the<br>
coordinates and the content of the dictionary, are made<br>
use of by the OSD decoder 54. The latter, via the<br>
input/output interface 53, receives the coded bitmap<br>
data stream or BEB (bitmap encoded bitstream), as well<br>
as the dictionary. These data are decoded by this OSD<br>
decoder 54 which sends, as output to the CLUT memory 55<br>
and for each pixel i, an address (now not coded) which<br>
is the address of the palette containing the colour<br>
corresponding to this pixel. This palette, stored in<br>
memory in the RAM, has been sent to this memory 55,<br>
prior to the decoding of the bitmap data, via the<br>
input/output interface 53. The digital luminance and<br>
chrominance data are sent as output from the memory 55<br>
to the display circuit (Display Unit) 56 which<br>
additionally receives the video information.<br>
A codec has been described in the case in which<br>
the OSD information are sent to the decoder. In the<br>
case in which this information is resident, the<br>
resident bitmap data may be bitmap data coded<br>
elsewhere, and it is not necessary to install an OSD<br>
coder in the video decoder. Then, only the OSD decoder<br>
is necessary in the video decoder for the invention to<br>
function.<br>
The invention has been described in the context<br>
of an MPEG II video decoder. This relates, obviously,<br>
to one embodiment example, and any installation of such<br>
a codec in any decoder of any sort, television set,<br>
video recorder or other would not depart from the scope<br>
of the invention.<br>
We Claim<br>
1. Method of compression of graphics data used for coding images in points<br>
mode (bitmap data), data having a succession of addresses of a<br>
conversion table called symbols S, characterized by the steps of:<br>
- storing the various symbols in a dictionary (16),<br>
- coding the symbols on the basis of its address in the dictionary<br>
(16),<br>
- variable-binary-resolution coding (13) the address in the dictionary<br>
serving for coding the symbol.<br>
2. Method as claimed in Claim 1, comprising:<br>
- a run - length coding (2) of the symbols enabling each range of<br>
identical successive symbols, to give a number L corresponding to<br>
the number of identical symbols, associated with the symbol s,<br>
- a variable - binary - resolution coding of L (3) as a function of the<br>
value of L.<br>
3. Method as claimed in Claim 1, wherein the graphics data are OSD data<br>
and wherein the images are palletized images.<br>
4. Method as claimed in Claim 2, wherein the compression of the bitmap<br>
data produces a coded data stream comprising:<br>
- a variable - dimension code field consisting of a first field defining<br>
the dimensions of a run - length field and a second field defining<br>
the dimensions of a symbol field,<br>
- a run - length field for coding L, the dimensions of which<br>
corresponds to the binary resolution for coding L,<br>
- a symbol field for coding S, the dimensions of which correspond to<br>
the binary resolution for coding S.<br>
5. Method as claimed in Claim 4, wherein:<br>
- the binary resolution for coding L is defined by sending, before the<br>
bits for coding L, of zeroes the number of which is a function of the<br>
number of bits over which the value L is coded, and wherein the<br>
change of binary resolution for coding the symbol on the basis of<br>
the address in the dictionary is defined by sending, before the bits<br>
for coding the address, of a predefined number of zeroes (27), the<br>
value of which is higher than the maximum number of successive<br>
zeroes used for coding L.<br>
6. Device for compressing graphics data used for coding images in points<br>
mode (bitmap data), data having a succession of addresses of a<br>
conversion table called symbols S sent in a data stream, characterized in<br>
that the device having a run - length coder (2) which receives the data<br>
stream in order, for each run length, to supply a number L associated with<br>
a symbol S; a variable - binary - resolution coder by class (3) for coding<br>
L, a variable - binary - resolution symbol coder (4) having a dictionary<br>
(15) for memory storage of the various symbols; and a variable - binary -<br>
resolution coder (13) of the address in the dictionary, for coding S.<br>
7. Device for decompressing graphics data compressed according to the<br>
method as claimed in Claim 2, characterized in that the device having a<br>
memory (35) for storage of the dictionary; a field - identification circuit<br>
(34) receiving the compressed data stream for detecting the binary<br>
resolution of L and S and extracting the coded values of L and S; a symbol<br>
S extraction circuit (36), the extraction circuit being linked to the memory<br>
(35) for sending the coded value of S as an address and recovering the<br>
content of the address; a run - length decoding circuit (37) for decoding<br>
the coded value of L; and a circuit for generating the sequence of symbols<br>
(38) receiving the decoded run - length value L for the symbol S and the<br>
decoded value of the symbol S in order to send out L times the value S in<br>
the stream.<br>
8. Digital video decoder comprising a graphics - data compression device (1)<br>
as claimed in Claim 6, and a graphics - data decompression device (32) as<br>
claimed in damn 7.<br>
9. Digital video decoder comprising a graphics - data decompression device<br>
as claimed in Claim 7 and a RAM memory capable of storing the bitmap<br>
data compressed according to the method as claimed in Claim 1.<br>
Method of compression of graphics data used for coding<br>
images in points mode (bitmap data), data having a succession of<br>
addresses of a conversion table called symbols S. Storing the<br>
various symbols in a dictionary (16), coding the symbols on the<br>
basis of its address in the dictionary (16), variable-binary—<br>
resolution coding (13) the address in the dictionary serving for<br>
coding the symbol.</l></l></l></l></l></l></l></l></l></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LUNBTC0xOTk5LUZPUk0tMjcucGRm" target="_blank" style="word-wrap:break-word;">768-CAL-1999-FORM-27.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtY29ycmVzcG9uZGVuY2UucGRm" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-correspondence.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtZXhhbWluYXRpb24gcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtZm9ybSAxLnBkZg==" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtZm9ybSAxOC5wZGY=" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtZm9ybSAyLnBkZg==" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-form 2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtZm9ybSAzLnBkZg==" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtZm9ybSA1LnBkZg==" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtcGEucGRm" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-pa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtcHJpb3JpdHkgZG9jdW1lbnQucGRm" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-priority document.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtcmVwbHkgdG8gZXhhbWluYXRpb24gcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-reply to examination report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtc3BlY2lmaWNhdGlvbi5wZGY=" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-specification.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NzY4LWNhbC0xOTk5LWdyYW50ZWQtdHJhbnNsYXRlZCBjb3B5IG9mIHByaW9yaXR5IGRvY3VtZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">768-cal-1999-granted-translated copy of priority document.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="224449-an-yttria-stabilized-zirconia-coated-thermal-resistant-copper-tuyers-for-use-in-iron-blast-furnace.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="224451-pay-per-use-communication-device-with-double-descrambling-in-particular-for-television-pictures.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>224450</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>768/CAL/1999</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>42/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>17-Oct-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>14-Oct-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>08-Sep-1999</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>THOMSON MULTIMEDIA</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>46, QUAI A. LE CALLO, F-92100 BOULOGNE-BILLANCOURT</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>BOUSLEIMAN ELIAS</td>
											<td>2A ALLEE RAYMOND CORNON, F-35000 RENNES</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06T 9/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>9811627</td>
									<td>1998-09-17</td>
								    <td>France</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/224450-method-of-graphics-data-compression by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 02:17:58 GMT -->
</html>
