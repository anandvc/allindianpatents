<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/199532-improved-interface-for-flash-eeprom-memory-arrays by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:09:58 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 199532:&quot;IMPROVED INTERFACE FOR FLASH EEPROM MEMORY ARRAYS&quot;</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">&quot;IMPROVED INTERFACE FOR FLASH EEPROM MEMORY ARRAYS&quot;</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A device level interface for connecting a flash EEPROM memory array to other components of a computer system which interface is designed to provide signals which directly relate to the primitive operations of a flash EEPROM memory array. The interface is adapted to use a fixed command set which allows a query command to be used to determine the functionality of the array. The values returned may be used to initialize software drivers used for accessing the array in primitives which relate to the flash EEPROM memory array.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>Field Of The Invention<br>
This invention relates to flash electrically-erasable prograimiaÂ£t5ie read only memory ("EEPROM") and, moreparticularIy,(tomethodsahfian apparatus for providing an interface for flash EEPROM memcMry arrays that allows determination of the characteristics of the memory array.<br>
Background of the Invention<br>
Flash EEPROM memory arrays are being used for many purposes in present day digital systems (e.g., computers) because of the ability of flash EEPROM memory arrays to retain data when power is removed and to be easily reprogrammed without being removed from a system. A flash EEPROM memory array is comprised of floating gate field effect transistor devices arranged in row and column fashion. The charge stored on the floating gate of such a memory transistor may be changed by programming, and the state of the charge may be detected by ^nsing voltage across the device. Because these flash EEPROM arrays may be easily reprogrammed, they are being used as substitutes for normal EPROM arrays to provide read-only memory that may be easily updated.<br>
A flash memory array is accessed for reading and writing in the same manner as are dynamic random access memory (DRAM) arrays using row and column addressing in byte, word, or larger sequences of bits. However, because of the manner in which data is stored, a flash memory array, unlike a typical DRAM device, cannot be overwritten without first erasing the devices. Flash memory arrays used as substitutes for EPROM arrays are typically erased in large blocks (that may constitute the entire anay) before being reprogrammed.<br>
Flash EEPROM memory arrays are also being used to provide smaller lighter functional equivalents of electro-mechanical hard disk drives. Flash memory arrays designed to replace hard disk drives (referred to herein as "flash disk drives") operate more reliably and are not as sensitive to physical damage as electro-mechanical hard disk drives. Because of these characteristics, flash disk drives are especially useful in portable computers where space is at a premium and weight is important.<br>
Electro-mechanical disk drives have historically used an industry standard interface referred to as an "ATA interface." The ATA interface was specifically designed to provide communication between a computer system and a rotating electro-mechanical disk drive. Because of this, the ATA interface was defined in terms of primitive functions that are directly applicable to rotating electromechanical disk drives. An electromechanical hard disk drive is a directly-overwritable, block read/write, rotating media that is capable of primitive functions including "do a slow seek for a logical address or a cylinder head sector," "read a sector or multiple sectors," and "write a sector."<br>
Flash EEPROM array primitive functions include, for example, "read and write at the byte, word, or small block level" and "erase at a large block level." The ATA interface does not communicate in flash memory array primitives. When a flash disk drive replaces an electro-mechanical disk drive, it uses the ATA interface to communicate with other computer components. Therefore, it has been necessary to provide circuitry by which the signals used by a computer to access electro-mechanical hard disk drives may be understood by the flash disk drive. The process of translating electro-mechanical rotating disk drive functions to flash disk drive functions has required a substantial amount of hardware and software overhead.<br>
For example, one type of flash disk drive interposes a command user interface on the same silicon substrate (chip) with the flash memory array    to interpret the commands provided at the ATA interface. The flash disk drive command user interface accepts the ATA signals and controls the operations necessary to access the flash disk drive. The flash disk drive command user interface typically includes state machines that receive commands intended for a rotating disk, decode those commands, and generate commands adapted to carry out the purposes of the ATA commands within a flash disk drive.<br>
Recently, there has appeared a lower cost alternative to a flash disk drive that combines disk emulation software running on a host computer with a low cost flash memory device array. The flash memory device array comprises one or more flash memory devices contained in one of several system packaging options, including a removable memory card, a system-resident single-in-line-memory module (SIMM), and a resident flash array, devices mounted directly on the system motherboard. The combination of any one of these plain flash memory device subsystems with disk emulation software is referred to in this specification as a flash disk emulator.<br>
Many of the operations necessary for either a command user interface or a flash disk emulator to translate from commands phrased in primitives of a rotating disk are quite complicated. For example, in some flash disk drives and other flash storage devices, data is first written to empty blocks of the memory array chosen under control of the command user interface; and then the physical address at which the data is stored is recorded in lookup tables along with the rotating disk addresses provided externally. This allows the data to be recovered when the rotating addresses are provided.<br>
Early flash memory arrays addressed data in single bytes. As flash memory arrays have evolved, addressing in words and double words have become possible, often in the same array. The ability to provide these different forms of addressing have complicated the operations of the device  command user interface. Recently, flash disk drives have been devised that use buffering to allow the transfer of large amounts of data even though the array cannot immediately handle that data because of its slower combined erasing and writing speed. These enhancements increase the complexity of flash disk drive and flash emulator operations.<br>
The basic flash need to erase in large blocks further complicates operations that flash disk drives and flash disk emulators must carry out. When data is updated, stale data that cannot be overwritten must be marked invalid, the new data must be written to empty array space, and the address tables must be updated to provide a new physical address. This method of updating causes the data in a file to be written to discontiguous positions. When a sufficient amount of data in a large block becomes invalid, the remaining valid data must be copied to empty array space in some other block, the address tables must be updated, and the block must be erased to recover the array space.<br>
The writing of flash EEPROM devices is slower than writing DRAM memory because storing data on the floating gate of a transistor requires substantial voltages and relatively long charging times. Both the writing process and the copy process are thus too long to be competitive with DRAM write times. A write state machine is typically positioned on the chip to assist a command user interface and is used to conduct write and copy operations so that data is accurately stored without overwriting other data in the array. Moreover, the erase process (a process not required by DRAM or electro-mechanical memory) is typically slow, as long as one-half second for some flash drives. Because of this, the erase process is typically conducted as a background process run by the write state machine or by additional on-chip state machines under control of the flash disk drive firmware or flash disk emulator software operating beneath their respective command user interfaces. The time required to conduct erase operations is such that some flash memory device command user interfaces<br>
accepts commands that suspend the erase operation to allow various other operations to occur.<br>
Recently, flash memory arrays have been devised that allow the storage of more than one bit of data in a single memory cell. This has substantially increased the complication of the circuitry required to translate commands and data between the flash memory array and the ATA (flash disk drive) and flash disk emulator interfaces. As will be understood, all of this overhead is expensive and slows the operation of the flash memory array.<br>
The ATA interface hides the complexity of the underlying flash disk drive internal software (firmware). A host-system typically employs a single ATA device driver that translates instructions from the disk file system maintained by the operating system such as the boot parameter block/file allocation table ("BPB/FAT") file system in the Microsoft DOS and Windows operating systems. This driver is used by all ATA-compatible devices, both rotating and flash-based. The ATA interface was designed to provide forward and backward compatibility for all ATA devices without requiring software updates to the host system device driver. However, the ATA interface, as presently constituted, eliminates the ability to use the flash disk devices for many operations for which transistor memory is especially well suited. For example, even though a flash memory array may inherently be accessed as rapidly as dynamic random access memory, direct random access is not possible using the ATA interface because of the translation overhead and because of the manner in which data is stored. Because the cells of flash memory arrays cannot be over-written and consequently store file data in discontigous positions of the flash array, a data file that is read from a flash memory array must be reassembled in main memory before it can be used. Because memory management of the flash memory array makes it necessary to reconstruct files read from flash storage devices in DRAM memory before use, direct<br>
execution of applications has been foreclosed in flash disk drives with an ATA interface.<br>
Even if it were possible to store the portions of an application contiguously in a flash memory device, executing an application direcdy from a flash memory device would be very difficult. First, the ATA interface does not provide any direct access to the memory array for direct execution of instructions in the access time that a basic flash memory itself provides for read operations. Moreover, there is simply no manner of determining the characteristics of the particular flash memory device with which communication is being attempted so that communications can be carried on directly in terms by which the data in the array may be manipulated.<br>
Because of these problems, flash disk drives have typically been used for long term storage of data where the ability to read and write data rapidly is not crucial.<br>
Currently a flash disk emulator has strengths and weaknesses that contrast with those of an ATA-compatible flash drive. The flash disk emulator consists of a two-layer software driver and a memory card or other flash array. The upper level driver layer is referred to as a flash translation layer ("FTL") driver (PCMCIA specification release date May 1996) while each low level driver ("LLD") is usually designed by an original equipment manufacturer and is unique to the flash memory device and card combination. In addition to supporting disk emulation, the memory card or array can be partitioned in one or more additional regions that can support direct random memory access. Thus, a "plain" flash memory card or flash array allows the host system and its user to take advantage of fast direct access to the flash memory device contents in support of direct code execution.<br>
The disadvantage of current flash disk emulator implementations is the custom nature of the low level driver. A low level driver currently reads a    device identifier ("device ID") and refers to a lookup table to determine both a command sequence or algorithm and a set of card and/or device geometry and system interface parameters such as voltage and timing to be used with that device.<br>
Such a driver has no way of determining the characteristics of any particular flash memory device with which it is associated except through the lookup table. Consequently, when a new flash memory device is introduced to the host system, the host cannot recognize the new device identifier and therefore cannot use the ncv/ card/device combination. This prevents forward compatibility and creates hardship for the typical flash card user who cannot easily find or implement the new required device driver. Because each low level driver must be written to include the particular disk emulator, each time an enhanced version of a flash memory device appears the low level driver must be rewritten to include the new features that the flash memory device offers. For example, drivers must be rewritten to include larger data words, increased buffer transfer size, and the like.<br>
Furthermore, when a new device driver is being made available for the host system, the software writer faces code size and complexity constraints that may lead to a decision to drop older device algorithms. Hence, the new driver may sacrifice backward compatibility.<br>
Summary Of The Invention<br>
It is desirable to provide an interface for a flash storage device that allows communications with the flash memory array in the primitive terms used to control the flash memory array within such a flash storage device so that the device may be used for purposes fur which transistor memory arrays are especially suited.It is also desirable for devices using flash memory arrays to include a compatible interface by which the characteristics of the devices may be determined to provide initialization values for software drivers.<br>
A device is described that includes a memory array, a query memory, and an interface. The memory array includes a plurality of blocks of flash EEPROM memory devices arranged to be accessed in rows and columns. The query memory stores data defining characteristics of the flash memory device. The interface receives data and commands addressed to the flash memory devices. The interface generates signals for effecting the purpose of the commands within the flash memory devices. The interface includes circuitry for receiving a command and responding by returning the data stored in the query memory as an output.  The present invention relates to a method of initializing a software drive for a flash memory system comprising:<br>
interrogating a query memory residing within the flash memory device to determine a characteristic of the flash memory device;<br>
returning data stored in the query memory defining the characteristic of the flash memory device; and<br>
setting values for the software driver based on the characteristic provided as a result of the interrogation.<br>
The invention also relates to a method of communicating with a flash memory device comprising:<br>
interrogating a query memory residing within the flash memory device; returning data defining a characteristic of the flash memory device stored in the query memory initializing a software driver based on the query response translating a command from a disk file system command to a command directly executable by the flash memory device; and sending the command to the flash memory device.<br>
Still, the invention relates to a machine readable media having stored thereon a sequence of commands which when executed by a processor cause the processor to perform the following:<br>
interrogating a query memory residing within a flash memory device to determine a characteristic of the flash memory device;<br>
receiving data stored in the query memory defining the characteristic of the flash memory device; and<br>
setting values for a software driver based on the characteristic provided as a result of the interrogation.<br>
Further, the invention also relates to a memory system comprising: a flash memory device;<br>
a query memory residing within the flash memory device which stores data defining a characteristic of the flash memory device;<br>
a memory storing software, the software configured to receive data and commands in a disk file system format and convert the commands into commands directly executable by the flash memory device by providing an algorithm used form interfacing with the flash memory device based on the characteristic of the flash memory device stored in the query memory, the algorithm setting values for the software based on the characteristic of the flash memory device.<br>
Other objects, features, and advantages of the present invention will be apparent from the accompanying drawings and from the detailed description that follows below.<br>
Brief Description Of The Drawings<br>
The present invention is illustrated by way of example and not limitation in the figures of the accompanying drawings, in which the references indicate similar elements, and in which:<br>
Figure i is a block diagram of a computer system with a flash memory device array.<br>
Figure 2 is a block diagram of a prior art electromechanical hard disk drive, a prior art flash disk drive, and a flash memory device array designed in accordance with one embodiment of the present invention.<br>
Figure 3 is a block diagram of a flash memory device.<br>
Figure 4 is a diagram illustrating signals that may be returned in response to a query command with respect to a flash memory device.<br>
Detailed Description<br>
As described in more detail below, an embodiment of the invention includes an interface for connecting a long term memory device including a flash EEPROM memory device array designed to accept a query command from other components of a computer system and return data that defines the physical properties and the functions of the flash memory device in tenns that directly relate to a flash EEPROM memory array. The data derived by a query command may be used to initialize a system device driver to provide commands that most effectively manipulate data in the flash memory device.<br>
Figure 1 is a block diagram of a computer system 10 configured in accordance with one embodiment of the present invention. For one embodiment, computer system 10 is a personal computer or a laptop computer. For other embodiments, computer system 10 resides within a cellular telephone, a digital camera, a personal digital assistant, or other apparatus under computer control. The system 10 illustrated includes a central processing unit ("CPU") 11 that executes the various instructions provided to control the operations of the system 10. For one embodiment, CPU 11 is a microprocessor. For other embodiments, CPU 11 is a microcontroller or other type of processor. CPU 11 is joined by a processor bus to a bridge circuit 14 that controls access to an input/output bus 12 adapted to carry infomation between the various components of the system 10. The bridge 14 is also joined by a memory bus to main memory 13 that is typically constructed of dynamic random access memory arranged to store infomation during a period in which power is provided to the system 10. In Figure 1, the bus 12 is preferably a peripheral component interface ("PCT") bus or other local bus adapted to provide especially fast transfers of data.  For other embodiments, other<br>
types of buses may be used. Various input/output devices are connected as bus master and bus slave circuits to the bus 12. Flash memory device array 18 is connected to PCI bus 12. For an alternative embodiment, flash memory device array 18 is joined to a secondary bus (not shown), such as an Industry Standard Association ("ISA") bus or an Extended Industry Standard Association ("EISA") bus. For one embodiment, flash memory device anay 18 uses the interface described in more detail below to connect to a bus.<br>
Flash memory device array 18 is a long term memory. Flash memory device array 18 may be a flash memory card or other type of flash memory array such as a single-in-line-memory module or a resident flash array. In the past, long term memory would typically be an electro-mechanical hard disk drive. However, a flash EEPROM memory array in the form of a flash disk drive or a flash memory device array may be used in place of such a hard disk drive as the long term memory. In order to illustrate differences from the prior art, Figure 2 shows three types of long term memories coupled to bus 12, namely, a prior art electromechanical hard disk drive 16, a prior art flash disk drive 17, and a flash memory device array 18, the latter being one embodiment of the present invention. Flash memory device array 18 may be used as the long term memory in place of electromechanical hard disk drive 16. Flash memory device array 18 or any flash memory array may be one in which a memory cell stores a single bit of data or a multi-level memory system in which a memory cell may store more than one bit of data. A flash disk drive may include an array of one or more flash memory devices each having circuitry for reading, programming (writing), and erasing the cells of that flash memory device and circuitry external to the flash memory device for controlling the operations of the entire memory array. A flash disk emulator typically employs a flash memory device array that includes an array of one or more flash memory devices in which the circuitry for reading, programming,<br>
and erasing the cells of each flash memory device is contained completely within each such device.<br>
Figure 2 illustrates a system software/hardware interface provided at a bus 12 to which are coupled an ATA compatible electromechanical hard disk drive 16, the flash disk drive 17, and flash memory device array 18. Figure 2 illustrates a software application program located in system memory executing on a computer microprocessor with the assistance of an operating system that controls access to various input/output devices of the computer. The operating system includes an operating system kernel that maintains a software disk file system in memory through which the various files are maintained. The operating system uses the disk file system to store and retrieve data from files kept in the memory system of the computer. When a file is stored on the electromechanical disk drive 16, the operating system transfers control to a software IDE/ATA device driver that is used to access the drive 16 and is maintained as a part of the operating system.<br>
Similarly, if a file is stored on a flash disk drive 17, access is obtained through the operating system using the same IDE/ATA device driver. In the arrangement illustrated, the flash disk drive 17 receives comniands and data related thereto from the ATA device driver defined in terms that are directly useful to a rotating electromechanical hard disk drive. Because an ATA device driver is designed to provide information for an electromechanical hard disk drive, the commands transferred to the flash disk drive 17 from the ATA device driver may direct that a seek operation for a particular rotating hard disk drive sector should be accomplished, that a read of one of more such sectors should occur, or that similar sector-related operations should take place.<br>
The prior art flash disk drive 17 illustrated in Figure 2 includes an array 23 of flash EEPROM memory devices that is designed to be accessed using chip, block, row, and column addressing. To deal with commands<br>
designed for a rotating disk device in accessing a row and column device, the flash disk 17 includes external command user interface ("GUI") circuitry for receiving and handling commands addressed to a plurality of silicon chips that together constitute a flash memory array 23. In one embodiment, this external command user interface circuitry includes an ASIC logic block 20 that receives commands furnished by die ATA device driver on the PCI bus 12. The logic block 20 is assisted by a processor 21 having associated random access memory and read only memory for assisting its operation. These together form what is in effect a small general purpose computer for carrying out the various operations directed to the flash disk drive 17. The logic block 20 accepts commands directed to that drive 17 and with the help of the processor 21 translates those commands and the associated addresses into information that is useful for accessing a row and column array. The logic block 20 and the processor 21 may be considered to function as an overall command user interface for the flash disk drive 17.<br>
The flash memory array 23 shown includes flash EEPROM devices 24 each having a number of blocks 25 of memory transistors. One embodiment includes thirty-two individual large blocks, each having sixty-four kilobytes of flash EEPROM memory cells. Each device 24 also includes circuitry for controlling the application of signals and voltages to accomplish the read, write, copy, and erase functions in the individual blocks. Each flash EEPROM device 24 of the array 23 includes a command user interface ("CUI") including one or more state machines. A typical flash device command user interface is designed to receive all commands addressed to the individual flash device 24 from the logic block 20 no matter what their address on the device and use those commands to cany out the different operations commanded. The flasli device GUI often uses a write state machine to control write, copy, and erase operations and certain other internal operations of the memory devices of the flash device.without necessitating the rewriting of the low level device drivers used with such devices.<br>
In the foregoing specification, the invention has been described with reference to specific exemplary embodiments thereof. It will, however, be evident that various modifications and changes may be made therein without departing from the broader spirit and scope of the invention as set forth in the appended claims. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.<br>
Thus, the command user interfaces within each of the flash memory devices 24 are typically used for erasing the blocks 25 of cells and reading or writing data in row and column addresses while the ATA command user interface (including logic block 20 and processor 21) external to the devices 24 deals in cylinder/head/sector or logical block address representative of a mechanical disk drive.<br>
Prior art flash disk emulators (although not shown in Figure 2) include a low level driver between the IDE/ATA device driver and the emulator that performs the functions performed in the device 17 by the external command user interface made up of the logic block 20 and the processor 21 and associated memory for translating the ATA commands to commands that may be carried out by a row and column array. As pointed out above, such a low level driver is not forward compatible and thus will not function with new flash disk emulators as they appear.<br>
In accordance with one embodiment of the present invention, an apparatus and a method are provided for directly defining the characteristics of flash storage devices in terms of flash EEPROM primitives rather than rotating disk primitives as they have been defined in prior art arrangements. This allows direct access of a flash memory array for reading and executing the data stored therein using software drivers initialized by values obtained as a result of a query function provided by the flash storage device.<br>
In Figure 2, a new high level software driver 35 is provided as a part of the operating system. This softwiue driver (called a flash translation layer (FFL) driver) uanslates the information provided from the disk file system to flash EEPROM primitives. The high level driver 35 provides addresses and data to a low level driver 36 particularly adapted to function with the flash device provided. The low level driver 36 provides many of the functions heretofore provided by by command user interface 20 of the flash disk drive 17.As may be seen in Figure 2, the flash memory device array 18 includes a plurality of individual flash EEPROM memory devices 27 and a decoder 29 for directing commands to memory cells in blocks of particular devices 27. The flash memory device array 18 and the two software drivers 35 and 36 together form the flash disk emulator of the present invention (shown enclosed in dotted lines in the figure). As explained with respect to prior art flash disk emulators, various of the functions included in hardware in the flash disk drive 17 have been replaced by functions within the high and low software drivers.<br>
Figure 3 illustrates of a flash memory device 27 built in accordance with one embodiment the present invention. The flash memory device 27 of Figure 3 includes a device command interface 40 with address decode circuitry 43 and state machines 44. An additional write state machine 41 is associated with the command user interface to assist in programming and erasing the cells of blocks of flash EEPROM memory cells 48. A write buffer 45 is provided by which data is furnished to the blocks of flash memory cells 48. A status register 46 provides operational status of the device 27 and a data multiplexor 47 controls transfer of data out of the device 27.<br>
The flash memory device 27 also includes an identification/query mode read only memory ("ROM") 31 in which are stored details of the characteristics of the particular flash memory cell technology and control circuitry of each flash memory device 27. The identification/query mode ROM 31 responds to a query command provided as a portion of the high level device driver software 35 and decoded by the device command user interface 40.<br>
The device drivers 35 and 36 provide an algorithm for interfacing with the flash memory device 27 that may include a command set. The commands of the basic command set may include a query command, a read command, a write command, a read status command, an erase command, and a<br>
suspend command. The command set may also include additional commands adapted to be carried out by the various circuitry under control of these device drivers.<br>
A query command directed to an address decoder 29 causes the ROM 31 to provide data that indicate the physical parameters of the flash disk device. Figure 4 illustrates data that may be returned by a query command.<br>
For one embodiment of the flash memory device 27, the high level driver 35 receives commands that are translated and sent to the low level driver 36. All of this command data is provided to the low level driver 36 by the high level driver 35 in terms of flash memory device primitives that require no further translation to be used with a flash memory device.<br>
Normally the low level driver 36 maintains the flash memory device 27 in an array read mode. However, a valid command may switch any device 27 to another mode. When a read query command is directed to the low level driver 36, the driver sends a query command to the device command user interface 40 that causes the interrogation of the query mode ROM 31 and the return of the query data. Typically, the query data returned in response to the query command is provided in serial sequence. This data may then be used to initialize the high and low level software drivers 35 and 36 used with the flash memory device array 18 so that the commands used by the drivers match the capabilities of the flash memory device 27. This allows uniform drivers to be implemented that may be updated by improved versions of flash memory device arrays as those improved arrays are devised.<br>
Figure 4 illustrates one embodiment of data that may be stored in a query ROM 31 and returned in response to a query command received at the command user interface 40. The data may be returned in a serial string in which a first sixteen bytes are reserved for the transfer of data specific to a particular flash memory vendor. A next eleven bytes are used to transfer<br>
data describing a particular command set available to be used with the flash array. Of this eleven bytes of data, a first three bytes are used to transfer a query string indicator such as the ASCII value for "QRY." This indicates to the computer that the array is able to accept and is responding to the query command. A next two bytes are used to transfer a sixteen bit identification code defining a specific generic vendor command set used by this particular flash memory device 27. In general, such a command set is a defined command set that is available as a standard to any vendor for use in a device driver. Such a command set may be used by one or more than one vendor but specifies exactly the basic commands with which the interface functions. The next two bytes then transfer an address for an extended portion of generally unlimited extent that may add to the command set defined by the last two bytes. This address allows a vendor to extend the primary command set by commands that the vendor desires as a part of the command set for the flash memory device 27. In general, such additional commands are defined in the same manner as are the commands available in generic command sets of the device drivers. In Figure 4, two sections referred to as "Offset address P" and "Offset address A" provide variable length space for transferring data defining primary and alternate extended query tables elements. In this manner, a vendor may add additional commands specific to the flash storage device to be implemented by the device driver. A next two bytes are used to transfer sixteen bits of data indicating a second generic command set that may be implemented by the flash memory device 27. A last two bytes are used to transfer the address for extensions to this alternate command set for the flash memory device 27.<br>
This arrangement allows a vendor to use a primary basic set of commands for operating the array, to add additional commands to the primary basic set of commands for carrying out the functions of the array, to use a second basic set of commands for operating the array, and to add additional commands to the second basic set of commands for carrying out<br>
the functions of the array. This allows a vendor to add additional commands as improvements are added to the flash memory device 27. The data transferred in response to the query command then allows a device driver to be modified to provide the correct command set for implementing the operations of the array.<br>
Figure 4 also illustrates a second twelve bytes that provide a description of the system interface and are returned in response to a query command. For the embodiment illustrated, a first byte defines the minimum power supply voltage used with the array in its normal operating condition. A second byte defines the maximum power supply voltage used with the array in its normal operating condition. A third byte defines the minimum power supply voltage used with the array in its programming condition. A fourth byte defines the maximum power supply voltage used with the array in programming condition. The next eight bytes define various system timing parameters for different operations.<br>
These values allow the initialization of device drivers to provide correct values for each of the particular operations that the array implements in caiTying out its read, write, copy, and erase functions.<br>
Figure 4 also illustrates an additional ten bytes that may be used for the embodiment illustrated to transfer data defining the particular geometry of the flash memory device 27. For this embodiment, a first byte is used to define the flash memory device size. A second two bytes are used to describe the interface, e.g., asynchronous 8 bits, asynchronous 16 bits, or both. A third two bytes defines the maximum number of bytes in a multi-byte write. In one embodiment of the invention, erase blocking is used to make the one or more blocks within an erase block region of the array "read only." Erase blocks of different sizes may exist. A fourth byte defines the number of such erase block regions in a device. A fifth four bytes defines the size and number of erase blocks in an erase block of an array. By defining the number and sizes of different erase blocks that exist<br>
in the array, a software driver may be apprised of different areas that may be made "read only" or that may be erased in a single operation.<br>
All of these values are also used to initialize the driver used with the ptirlicular flash memory device 27 so that it may efficiently deal with the array.<br>
Once the device drivers have been initialized to the values of the particular flash memory device 27, various commands may be used and the flash memory device 27 will accept those commands. The write, read, and erase commands cause similar operations as with the flash disk device 17 of Figure 2 as the flash translation layer driver translates such disk commands into flash primitive commands executable by the low level driver. The proper translation of requests for data transfer of specific disk-primitive units, or sectors, into variable flash device specific block erasure and byte or buffer write commands is facilitated by the knowledge of the software drivers of the flash storage device of erase block sizes, erase block region sizes, write buffer size, and the size of the entire device array. The information provided by reading out the contents of the query ROM 31 allows the device drivers of the flash disk emulator to emulate various sizes of disk drives such as the electromechanical drive 16 or the flash disk drive 17 using any of combination of different flash memory devices 27 within a flash memory card or other flash memory array used within a flash disk emulator. Moreover, this infomiation is even useful for simplifying the firmware within a flash disk drive 17 containing flash memory devices 27 implemented in the manner of the current invention such that the same fimiware will allow the flash disk drive to be manufactured at a later date using newer flash memory devices with upgraded features or larger capacities.<br>
The flash memory device commands also allow a portion of the array to be made "read only" for particular operations. Data stored in a "read only" erase block region of the array may then be read directly from the array in a<br>
mode in which data is accessed on a row and column basis. Such a "read only" portion of the array may be used to execute programs directly from the array.<br>
In such a case, data is written to the flash memory device 27 in the typical manner through a device command interface 40 shown in Figure 3 that includes state machines for accomplishing the various accessing and control operations. Interface 40 is associated with a write state machine 41 used with each chip for writing, copying, and erasing the blocks of flash memory. However, when the data for direct code execution is written, the blocks 48 in which the data is stored are marked as "read only." This causes the application instructions in the blocks to remain in file order ratler than to become discontiguously arranged. Consequently, the file need not be reassembled externally before the instructions are executed. Then a read of the instructions constituting an application takes place in a separate read array mode of the flash memory device 27. This mode may be initiated by a read array command that causes the flash memory device 27 to function in the read array mode. Alternatively, a separate read array pin may be provided. The read array mode selection allows a processor or other bus master to directly read data from the flash memory device 27 by providing the appropriate chip, block, row, and column read addresses with the command.<br>
When in this read array mode, the instructions stored in the array may be read from the array as rapidly as instructions are typically read from DRAM memory. For this reason, the array may be used not only to replace long tenn memory such as a rotating disk drive, but also to replace certain of the main memory functions where data is not rapidly changing but need only be read form the array.<br>
In addition to the commands provided by the embodiment described lierein, other commands might also be used with a flash memory device 27 or by other devices that use a flash memory array and return query data in<br>
accordance with the present invention. For example, the query command may also return data indicating whether read and write may take place at the byte level, the internal bus width, and the size of the input buffer 28. The query command may also return data indicating whether erase, write, and copy functions may be suspended and for what other operations they may be suspended. Additional data that may be provided include whether a ready/busy signal is present. If the array is adapted to provide multibit cell storage, a query command may return data relating to the type of multibit storage including the number of bits per cell, whether error correction coding is used, and other characteristics. Other data returned by a query command may indicate that the array is functioning in a single bit mode, that the array is capable of functioning in a two-state mode or in another multi-bit mode, and the number of bits stored in each cell in any such multi-bit mode. In this way, the interface may be used with flash storage devices that allow a single bit or a plurality of bits to be stored by a memory cells. A query response might also indicate to a processor whether the array implements error detection and correction in storing and retrieving data. Other responses to a query command might indicate the type of logical drive the array constitutes, e.g., the array is a PCMCIA or other type of drive.<br>
By using a query command that returns data indicating the physical properties of the array, the interface allows array device driver initialization so that the plurality of commands that are generated by a processor are adapted to cause operations to take place in the manner best suited to the physical properties of the array. The central processing unit in a system using a flash storage device with such an interface may read the results of the query command to determine how it is to interface to any flash storage device placed in the system. By utilizing a command set that is fixed, a query command provides responses that may be used by all vendors in an induslry.  Even though the command set is fixed in meaning, it also provides means by which it may be updated to include future devices<br><br><br><br><br><br>
WE CLAIM:<br>
1.	An apparatus for producing an interface for flash EEPROM memory<br>
arrays comprising:<br>
a flash memory device (27);<br>
a query memory (31) residing within the flash memory device which stores data defining a characteristic of the flash memory device; and a software drivers (35, 36), the software drivers configured to receive data and commands in a disk file system format and convert the commands into commands directly executable by the flash memory device (27) by providing an algorithm used for interfacing with the flash memory device based on the characteristic of the flash memory device stored in the query memory, the algorithm setting values for the software drivers based on the characteristic of the flash memory device.<br>
2.	The apparatus as claimed in claim 1, wherein the said flash memory<br>
device has a device command interface having address decode<br>
circuitry and state machines; a write state machine configured to<br>
assist in writing and erasing cells of blocks of flash memory; a write<br>
buffer configured to furnish data to blocks of flash memory cells; a<br>
status register configured to provide operational status of the flash<br>
memory device; and a data multiplexor configured to control the<br>
transfer of data in and out of the flash memory device.<br>
3.	A method for providing an interface for flash EEPROM memory arrays<br>
by communicating with the flash memory device using the apparatus<br>
as claimed in any of the preceding claims, comprising:<br>
interrogating the  query memory residing within the flash  memory<br>
device;<br>
returning data denning the characteristic of the flash memory device stored in the query memory;<br>
initializing   the    software    driver    based    on    the    query    response translating   a   command   from   a   disk   file   system   command   to   a command directly executable by the flash memory device; and sending the command to the flash memory device.<br>
4.	The method as claimed in claim 3, wherein said returning data stored in the query memory comprises returning data defining a physical parameter of the flash memory device technology.<br>
5.	The method as claimed in any of the preceding claims, wherein returning data stored in the query memory comprises returning extensions to the first command set comprising additional commands that added to the first command set.<br>
6.	The method as claimed in any of the preceding claims, wherein returning data stored in the query memory comprises returning a second command set comprising a second set of basic commands used to communicate with the flash memory device.<br>
The method as claimed in claim 3, wherein translating the command comprises using a flash translation layer to translate the command into the command directly executable by the flash memory device.<br>
A method of initializing the software drivers for the flash memory<br>
device, using the apparatus as claimed in any of the preceding claims,<br>
comprising:<br>
interrogating the query memory residing within the flash memory<br>
device to determine a characteristic of the flash memory device;<br>
returning data stored in the query memory defining the characteristic<br>
of the flash memory device; and<br>
setting values for the  software  driver  based  on  the  characteristic<br>
provided as a result of the interrogation.<br>
The method as claimed in claim 8, wherein the said values for the software driver are initialization values.<br>
The method as claimed in claim 8, wherein the said values are determined from the date stored in the query memory.<br>
The method as claimed in claim 8, wherein the said values are designed to permit direct access to the flash memory device.<br>
12.	The method as claimed in claim 8, wherein said interrogating the query memory comprises sending a query command from the software driver to the query memory.<br>
13.	The method as claimed in claim 8, wherein said returning data stored in the query memory comprises returning data describing a physical parameter of the flash memory device.<br>
14.	An apparatus for producing an interface for flash EEPROM memory arrays substantially as herein described with reference to and as illustrated in the accompanying drawings.<br>
15.	A method for providing an interface for flash EEPROM memory arrays by communicating with a flash memory device substantially as herein described with reference to and as illustrated in the accompanying drawings.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">3317-del-1997-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">3317-del-1997-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1jb21wbGV0ZSBzcGVjaWZpY2F0aW9uIChncmFudGVkKS5wZGY=" target="_blank" style="word-wrap:break-word;">3317-del-1997-complete specification (granted).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1jb3JyZXNwb25kZW5jZS1vdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">3317-del-1997-correspondence-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1jb3JyZXNwb25kZW5jZS1wby5wZGY=" target="_blank" style="word-wrap:break-word;">3317-del-1997-correspondence-po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">3317-del-1997-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">3317-del-1997-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1mb3JtLTEucGRm" target="_blank" style="word-wrap:break-word;">3317-del-1997-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1mb3JtLTEzLnBkZg==" target="_blank" style="word-wrap:break-word;">3317-del-1997-form-13.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1mb3JtLTE5LnBkZg==" target="_blank" style="word-wrap:break-word;">3317-del-1997-form-19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1mb3JtLTIucGRm" target="_blank" style="word-wrap:break-word;">3317-del-1997-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1mb3JtLTMucGRm" target="_blank" style="word-wrap:break-word;">3317-del-1997-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1mb3JtLTYucGRm" target="_blank" style="word-wrap:break-word;">3317-del-1997-form-6.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1ncGEucGRm" target="_blank" style="word-wrap:break-word;">3317-del-1997-gpa.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1wY3QtMjEwLnBkZg==" target="_blank" style="word-wrap:break-word;">3317-del-1997-pct-210.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1wY3QtMjIwLnBkZg==" target="_blank" style="word-wrap:break-word;">3317-del-1997-pct-220.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1wY3QtNDA5LnBkZg==" target="_blank" style="word-wrap:break-word;">3317-del-1997-pct-409.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1wY3QtNDE2LnBkZg==" target="_blank" style="word-wrap:break-word;">3317-del-1997-pct-416.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1wZXRpdGlvbi0xMzcucGRm" target="_blank" style="word-wrap:break-word;">3317-del-1997-petition-137.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1wZXRpdGlvbi0xMzgucGRm" target="_blank" style="word-wrap:break-word;">3317-del-1997-petition-138.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzMxNy1kZWwtMTk5Ny1wZXRpdGlvbi1vdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">3317-del-1997-petition-others.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="199531-tuft-feeding-apparatus.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="199533-coherent-jet-injector-lance.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>199532</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>3317/DEL/1997</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>33/2010</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>13-Aug-2010</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>17-Nov-2006</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>19-Nov-1997</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTEL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2200 MISSION COLLEGE BOULEVARD SANTA CLARA, CALIFORNIA 95052, UNITED STATE OF AMERICA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>KURT BRIAN ROBINSON</td>
											<td>2216 NAVAS LANE, NEWCASTLE, CALIFORNIA 95658, U.S.A.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 12/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>08/773,167</td>
									<td>1996-12-26</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/199532-improved-interface-for-flash-eeprom-memory-arrays by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:09:59 GMT -->
</html>
