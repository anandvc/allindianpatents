<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/198932-a-front-structure-for-a-vehicle by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:46:53 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 198932:A FRONT STRUCTURE FOR A VEHICLE</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A FRONT STRUCTURE FOR A VEHICLE</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>ABSTRACT The method and system of the present invention provides improved access to databases in a computer system. The present invention includes a plurality of data sources, the data sources including at least one non-relational data source; a server coupled to the plurality of data sources, the server capable of providing client access to the plurality of data sources; and a store place data access layer (SPDAL) coupled to the server and the at least one non-relational data source, the SPDAL providing relational features to the at least one non-relational data source. In the preferred embodiment, the relational features provided include a two-phase commit process; a process for performing Structured Query Language (SQL) operations from within a single application; a referential integrity process; and a process for providing indices for non-relational data source files. These features allow the computer system to perform data changes across multiple database sources within a single operation; perform SQL operations from a single application across heterogeneous file systems; provide referential integrity of data in both relational and non-relational databases; and perform ad-hoc queries of data and other queries efficiently in non-relational databases. By adding these features, significant flexibility is added to the computer system.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
The present invention relates to computer systems, and more particularly to the access of databases in the computer system.<br>
BA€R6ROUND^F TIIE INVENTION-<br>
Databases are an important tool for the storage and management of information for businesses. Both relational and non-relational databases exist for this purpose. Examples of relational databases include ORACLE, DB2, AND INFORMIX. Examples of nonrelational databases include custom databases created with the 4690 operating system, developed by INTERNATIONAL BUSINESS MACHINES CORPORATION. The 4690 operating system allows programmers to created custom databases which support keyed, sequential, and binary file types. Database Management Systems (DBMS) provide users the capabilities of controlling read/write access, specifying report generation, and analyzing usage.<br>
Some businesses, particularly large organizations, maintain multiple database types, both relational and non-relational. The simultaneous access to these databases then becomes an issue. For example, a company may wish to combine and compare customer preference information in the marketing department's ORACLE database with the current customer issues tracked in the customer service department's DB2 database. One conventional way of accessing these databases is through the DB2 DATAJOINER ("DataJoiner") products,<br><br>
developed by INTERNATIONAL BUSINESS MACHINES CORPoWriON. DataJoiner is a multi-database server which uses the Structured Query Language (SQL) and Open Database Connectivity ( ODBC), to provide client access to diverse data sources that reside on different platforms.<br>
Figure 1 illustrates a computer system which uses DataJoiner. The computer system 100 comprises clients 102 in various platforms, a DataJoiner server 104, and data sources 106 of various types. The Data Joiner server 104 allows the clients 102 to transparently access data from the different data sources 106.<br>
Figure 2 is a block diagram illustrating the basic architecture of DataJoiner. DataJoiner 202 is a DBMS which includes ODBC software and drivers for a variety of data sources. DataJoiner 202 allows for transparent access to multiple data sources in a heterogeneous environment. The Generic Access Applications Programming Interface (API) 204 allows for customized access to home-grown or other data sources 208 not already supported by DataJoiner. Generic Data Access Modules 206 containing Custom ODBC compliant drivers for these data sources may be written and installed on the same system as DataJoiner 202 and used by DataJoiner 202 to access the data sources 208. The Generic Access API 204 defines the calls which must be provided by the custom ODBC drivers in order for DataJoiner 202 to access the custom data source 208.<br>
However, DataJoiner is not able to provide certain features for access to the nonrelational databases. In particular, DataJoiner 202 does not provide (1) a two-phase commit, (2) performance of SQL operations from within a single application across heterogeneous file systems, (3) referential integrity, and (4) indices for queries across heterogeneous file systems<br><br>
which include non-relational data sources, such as 4690 keyed, sequential, and binary file systems.<br>
Two-Phase Commit<br>
DataJoiner can perform data changes across multiple databases sources within a single operation, while guaranteeing that changes to one source can be rolled back if changes to another source within the same transaction fail. The two-phase commit is the mechanism for implementing this. For example, someone may be trying to wire some money electronically to another location. A debit would need to be written against one account maintained by a first DBMS, and a credit would have to be reflected in another account maintained by a second DBMS. The two-phase commit protocol ensures that either all of the DBMS involved commit the changes required by the transaction or none do. However, keyed, sequential, and binary file systems cannot participate in this function.<br>
SOL Operations From Within a Single Application<br>
Conventional relational DBMS's employ two underlying data storage concepts in order to facilitate relational operations on that data: (1) data is stored in tables with each table having a fixed number of columns; and (2) system catalogs, or data dictionaries, are generated for each table. These data dictionaries (metadata) describe the column layout, index' structure, and other data access information. These concepts allow one application to create data, and other applications totally unrelated to the first, to analyze and update the data. However, with keyed, sequential, and binary file systems, there are several inhibitors that prevent these file systems from having the above flexibility. These include: (1) data is not held in a fixed table format; (2) data access is via a buffer that passes the entire record, with no public or obvious field delineation available; and (3) the structure, or field layout, of keyed, sequential, and binary records is not stored in a publicly available catalog. With these<br><br>
inhibitors, relational operations cannot be performed on the keyed, sequential, and binary file systems, making SQL operations from within a single application across heterogeneous file systems which include these file systems difficult or impossible.<br>
Referential Integrity<br>
Referential integrity is a technique where the consistency of data within a DBMS is ensured<br>
by referring to one piece of data during an operation on another piece of data. An example<br>
would be to refer to a department table to ensure that a valid department number is being<br>
used when a new employee is being added to the database. Referential integrity is<br>
incorporated in many of the conventional relational DBMS and is being enforced at the<br>
database level to ensure that all applications adhere to any constraints and thus ensure the<br>
integrity of the data.<br>
However, the concept of referential integrity, and a file system mechanism to enforce it, does<br>
not exist for keyed, sequential, and binary file systems. Without this function, heterogeneous<br>
DBMS can not implement referential integrity between the relational and non-relational data.<br>
Using the above example, if the valid department list is in a keyed file system and the new<br>
employee data was to be stored in a relational database, there would be no way that the<br>
underlying data stores could enforce the referential integrity during the employee add<br>
operation.<br>
Indices for Queries<br>
A need often arises to access keyed and sequential data based on data selection criteria<br>
different from the key or record number traditionally used to access the data. Queries based<br>
on this type of selection criteria are referred to as ad-hoc queries. For instance, instead of<br><br>
retrieving an employee record by an employee number mere may oe a need to retrieve all of the employees who are employed in department "X". The employee records are keyed by an employee identification number yet the selection criteria is based on the department number in which the employee is employed.<br>
For relational databases, ad-hoc queries may be efficiently satisfied since indices of the data may be created for data elements other than the key or record number. Once created, these indices may be used as an alternative form of data access which provides a more efficient processing of the query.<br>
However, to satisfy queries using conventional file access mechanisms available for hash-keyed or sequential files, every record in the file must be read and compared to the selection criteria since indices are not available for these files. This causes performance problems both in accessing the file and in creating the network traffic when the querying application resides on a machine other than the source data files.<br>
Accordingly, there exists a need for a method and system for improved access to non-relational databases in a computer system. The method and system should increase the flexibility and efficiency of access to the databases. The present invention addresses such a need.<br>
SUMMARY OF THE INVENTION<br>
The method and system of the present invention provides improved access to databases in a computer system. The present invention includes a plurality of data sources, the data sources including at least one non-relational data source; a server coupled to the plurality of data sources, the server capable of providing client access to the plurality of data sources; and a store place data access layer (SPDAL) coupled to the server and the at least one non-relational data source, the SPDAL providing relational features to the at least one non-relational data source. In the preferred embodiment, the relational features provided include a two-phase commit process; a process for performing Structured Query Language<br><br>
(SQL) operations from within a single application; a referential integrity process; and a process for providing indices for non-relational data source files. These features allow the computer system to perform data changes across multiple database sources within a single operation; perform SQL operations from a single application across heterogeneous file - systems; provide referential integrity of data in both relational and non-relational databases; and perform ad-hoc queries of data and other queries efficiently in non-relational databases. By adding these features, significant flexibility is added to the computer system.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
Figure 1 is a diagram illustrating a computer system which uses DataJoiner.<br>
Figure 2 is a block diagram illustrating the basic architecture of DataJoiner.<br>
Figure 3 is a block diagram illustrating a preferred embodiment of the architecture of the method and system in accordance with the present invention.<br>
Figure 4 is a block diagram illustrating the X/OPEN DTP model used in accordance with the present invention.<br>
Figure 5 is a flow chart illustrating the two-phase commit process provided by the method and system in accordance with the present invention.<br>
Figure 6 is a block diagram illustrating an example of a two-phase commit performed in accordance with the present invention.<br>
Figure 7 is a preferred embodiment of metadata tables provided for non-relational databases in accordance with the present invention.<br>
Figure 8 is a flow chart illustrating the referential integrity process provided by the method and system in accordance with the present invention.<br>
Figure 9 is a block diagram illustrating a preferred embodiment of the Index Manager in accordance with the present invention.<br><br>
Figure 10 is a flow chart illustrating the creation of indices by the Index Manager in accordance with the present invention.<br>
Figure 11 is a flow chart illustrating the use of the indices in satisfying a user query in accordance with the present invention.<br>
DETAILED DESCRIPTION OF THE INVENTION<br>
The present invention relates to a method and system for providing improved access to non-relational databases in a computer system. The following description is presented to enable one of ordinary skill in the art to make and use the invention and is provided in the context of a patent application and its requirements. Various modifications to the preferred embodiment will be readily apparent to those skilled in the art and the generic principles herein may be applied to other embodiments. Thus, the present invention is not intended to be limited to the embodiment shown but is to be accorded the widest scope consistent with the principles and features described herein.<br>
The present invention provides improved access to non-relational databases through an expansion upon the capabilities of Data Joiner. Figure 3 is a block diagram illustrating a preferred embodiment of the architecture of the method and system of the present invention. The Store Place Data Access Layer (SPDAL) architecture 300 comprises an Open Database Connectivity Applications Programming Interface 302 (ODBC API) which functions with DataJoiner 304. The SPDAL ODBC API 302 works with the Generic Access API 306 of DataJoiner 304 to provide a single access point for heterogeneous data source manipulations. An ODBC Driver 308 may be created to function with the SPDAL ODBC API 302 to access keyed, sequential, and binary file types, such as a 4690 data source 316. The ODBC Driver<br><br>
308 comprises an ODBC Driver Manager 310, a Generic Driver 312, and a SQL Engine 314. In the preferred embodiment, the ODBC Driver Manager 310 is an ODBC Driver Manager, known in the art.<br>
SPDAL 300 improves access to non-relational databases by providing the following capabilities: (1) true two-phase commit, (2) performance of SQL operations from within a single application across heterogeneous file systems, (3) referential integrity, and (4) indices for queries.<br>
Two-Phase Commit<br>
A two-phase commit process for keyed, sequential, and binary file systems is provided by the preferred embodiment of the method and system of the present invention. The two-phase commit is provided with an X/OPEN Distributed Transaction Processing (DTP) model using "XA interface" in SPDAL 302. X/OPEN, and its XA interface, is a standard protocol for access to databases.<br>
Figure 4 is a block diagram illustrating the X/OPEN DTP model used in accordance with the present invention. The X/OPEN DTP model comprises three software components:<br>
•	An application program 402 which defines transaction boundaries and specifies actions that constitute a transaction.<br>
•	Resource managers 404 which provide access to shared resources.<br>
•	A transaction manager 406 which assigns identifiers to transactions, monitors their progress and takes responsibility for transaction completion and for failure<br>
recovery.<br>
*.<br>
In the preferred embodiment, the XA Interface 408 is implemented with the X/OPEN DTP model as an intercept layer in the Generic Driver 312. The intercept layer would act as a<br><br>
resource manager for each file system, i.e., it would assume th^role of a data source. DataJoiner 304 would act as the transaction manager. This would make the keyed, sequential, or binary file system appear to DataJoiner 304 as a fully functional relational database implementing an XA interface 408. The XA Interface 408 implements XA calls which allow for interaction between the transaction manager/Data Joiner 304 and the data source 316. This two-phase commit protocol provided by the present invention can be used to manage data changes across multiple data base sources within a single operation. Figure 5 is a flow ehart illustrating the two-phase commit process provided by the method and system in accordance with the present invention. For this illustration, assume that a first database is a non-relational database and a second database is a relational database and a request requires a two-phase commit between them. First, DataJoiner 304, as the transaction manager, sends a request to the non-relational database, via step 510, through the intercept layer in the Generic Driver 312. The intercept layer implements the appropriate XA calls to facilitate interaction between DataJoiner 304 and the non-relational database. The non-relational database replies to the request and waits, via step 520. DataJoiner 304 also sends a request to the relational database, via step 530. The relational database replies to the request and waits, via step 540. If both the non-relational and relational databases commit to the request, via step 550, the request is performed, via step 560. Otherwise, the transaction fails, via step 570. Examples of functions for each XA API call comprise the below:<br>
•	xa_close: Frees any dedicated two-phase commit resources.<br>
•	xacommit: Unlock the section of the file previously locked, this will make    the data changes available to other applications.<br><br>
•	xacomplete: Used by the transaction manager to wait for asynchronous operations. Return control to the transaction manager when the operation identified by the handle is complete.<br>
•	xa_end: Free any dedicated resources acquired during xajstart processing.<br>
•	xa_forget: Release resources associated with a xid.<br>
•	xa_open: Initialize any dedicated two-phase commit resources.<br>
•	xa_prepare: Obtain a write lock on the portion of the keyed, sequential, or          binary file that will be changed. By acquiring a write lock, the resource manager intercept layer can guarantee that the subsequent write and commit	will occur. The prepared write instruction (location in the file and buffer to        write) should be saved in case a rollback is required.<br>
•	xa_recover: Return to the transaction manager any prepared but not committed transactions.<br>
•	xa_rollback: Undo the write operation staged with xa_prepare.<br>
•	xa_start: Initialize any dedicated resources required for a transaction.<br>
Figure 6 illustrates an example of a two-phase commit performed in accordance with the<br>
present invention. In this example, assume that a request is received by DataJoiner to transfer<br>
$1000 from a first account at a first bank to a second account in a second bank. The first<br>
bank maintains its accounts in a non-relational database 602 (DS1), such as a 4690 data<br>
source. The second bank maintains its accounts in a relational database 604 (DS2), such as a<br>
DB2 data source. The banks do not want to perform the credit without also performing the<br>
debit and vice versa. In completing this transaction, first the transaction manager, DataJoiner<br>
304, sends a request to the 4690 Keyed File, DS1 602, to debit $1000 from the first account,<br>
via step 510. The request is sent through the Generic Access API 306 to the Intercept Layer<br>
in the Generic Driver 312. The Intercept Layer implements the appropriate XA calls to<br>
facilitate the portion of the transaction involving DS1 602. DS1 602 replies to the XA calls<br><br>
ana waits, via step DZU. DS1 's 602 reply is sent to the transaction manager by the Intercept Layer. The transaction manager also sends a request to DS2 604 to credit the second account $1000, via step 530. DS2 604 replies and waits, via step 540. This ends phase one of the two-phase commit process.<br>
If either DS1 602 or DS2 604 indicates that they are unable to make the requested credit/debit, i.e., if either data source fails to commit, via step 550, the transaction fails, via step 570, and the transaction manager moves on to the next transaction. If both DS1 602 and DS2 604 indicate they are able to make the requested credit/debit, i.e., both data sources commit, via step 550, then the credit and debit are performed, via step 560. This ends phase two of the two-phase commit process.<br>
In the above manner, a two-phase commit process is provided by the method and system of the present invention.<br>
SOL Operations From Within a Single Application<br>
With the preferred embodiment of the method and system of the present invention, the ability to perform SOL operations from within a single application is provided. The present invention implements this capability by providing additional metadata tables in a database in addition to the metadata tables of DataJoiner 304. These additional metadata tables describe the keyed, sequential, and binary file content such that the files within those file systems can be accessed by the SPDAL ODBC API 302 of the present invention, and manipulate it using relational operations. In addition, the metadata content itself is described and held as a relational table, so that this data is publicly available to all users and applications, and can be used in conjunction with DataJoiner 304 to perform single relational operations across relational data sources and keyed, sequential, and binary file data concurrently.<br><br>
The metadata information of the present invention is used by Data Joiner 304 via the SPDAL<br>
ODBC API 302 to service requests from applications, thus removing the burden of individual<br>
applications to code to the specifics of the data's physical design and location.<br>
A summary of the metadata tables of the present invention follows, A more detailed<br>
description of fields in the metadata tables are provided in Figure 7:<br>
LogicalEntity Table: maps a LogicalEntityName to one or more physical entities, (See Table L Figure 7)<br>
PhysicalEntitv Table: describes metadata information that is defined for each relational database table or keyed, sequential, and binary file. (See   Table 2, Figure 7&gt;<br>
RecordDescription Table: describes the metadata information for records that exist within keyed, sequential, or binary files. (See Table 3. Figure 7)<br>
Attribute Table: describes the metadata information for all fields in a      keyed,<br>
sequential, binary file. The definition of a field provides the physical	layout<br>
structure that an application would use to process the data within the	field. (See<br>
Table 4, Figure 7)<br>
ValidAttributeValuesTable: describes the discrete values that are valid within an attribute. (See Table 5, Figure 7)<br>
ForeignKey Table: describes the metadata information for parent-child<br>
relationships. These relationships are used to enforce referential integrity    across all<br>
SPDAL data, as will be described in more detail later in this	specification. This<br>
includes relational databases as well as non-relational	databases. Relationships can<br>
be established between attributes within the same file system (for example between two relational tables) or between   attributes across different file systems (for example between a relational      table and a keyed file), (See Table 6, Figure 7)<br>
Index Table: describe, set, and maintain indexes on keyed, sequential.,     binary files. The use of this table will be described in more detail later in   this specification. (See Table 7. Figure 7)<br>
Although the present invention is described with the metadata tables as illustrated in Figure 7, one of ordinary skill in the art will understand that other access mechanisms for keyed, binary, and sequential file types may be used without departing from the spirit and scope of the present invention.<br>
When DataJoiner 304 receives a SQL query which involves both a relational and a non-relational data source. DataJoiner 304 "splits" the query. It passes "as is" to the SPDAL ODBC API 302 the portion of the query which deals with the non-relational data source 316. and it passes the other portion to the relational data source through its native ODBC driver.<br><br>
ine SUL engine 314 then interprets the SQL query into the low level calls for access to the non-relational data source 316. The requested data is returned in response to these low level calls. This result is then returned to DataJoiner 304. which combines it with the result returned from the relational data source. Data Joiner 304 then returns the combined result to the SQL query.<br>
By providing the metadata in accordance with the present invention, advanced relational concepts, such as referential integrity, can be used across relational database management systems, and keyed, sequential, and binary file systems in the same operation. In addition, the metadata content structure is described as standard relational tables, making the metadata publicly available to any user or application. Finally, the metadata allows for a logical view for access to the underlying keyed or sequential file data. This enables an application to code to a logical model without having to be concerned with the underlying physical data store, or changes to the underlying physical data store.<br>
Referential Integrity<br>
The method and system of the present invention provides for referential integrity across both relational and non-relational databases. In the preferred embodiment, referential integrity is implemented in the SPDAL ODBC API 302 by combining the metadata described above with a relational database engine that can process the results of relational operations from outside data sources to ensure referential integrity across both the relational database and keyed, sequential, and binary file systems. The relational database engine is a SQL engine 314 which has the ability to perform queries which implement referential integrity, as described below.<br>
The metadata is used to describe the referential constraints within the keyed, sequential, and binary file systems, and between these file systems and the relational file systems. The metadata is implemented by providing the following information in its ForeignKey Table:<br>
Parent/child relationships between files<br>
Primary key fields<br>
Cardinality between the parent and child<br>
List of fields that comprise a foreign key<br>
Delete rules Table 6 in Figure 7 provides in more detail the above listed information. Figure 8 is a flowchart illustrating the referential integrity process provided by the method and system of the present invention. In the preferred embodiment, the database access is through ODBC or X/OPEN CLI interfaces. Both are widely accepted and implemented by conventional competitive relational database management systems. First, the SPDAL ODBC API 302 captures an end user query before it is passed to DataJoiner 304, via step 810. The query is preprocessed in the SPDAL ODBC API 302 based on information in the metadata tables, via step 820, specifically, the information in the ForeignKey Table. In the preprocessing, the SPDAL ODBC API 302 determines if the end user query requires any referential integrity processing, via step 822.   Is so, the SPDAL ODBC API 302 would formulate the queries to execute and enforce the referential constraints, via step 824. Then, the end user query is passed to DataJoiner 304 for processing, via step 840. DataJoiner 304 determines if the query requires non-relational data, via step 850. If not, DataJoiner processes the query for the relational data, via step 860, and returns the result, via step 870. If so, then<br><br>
the query is processed on the non-relational data source, via step 880. In this processing, the queries which execute and enforce the referential contraint is passed to the SQL Engine 314, via step 826. The SQL Engine 314 translates these queries to commands compatible with the non-relational data source 316, via step 828. The SQL Engine 314 next executes these commands, via step 830. DataJoiner also processes the query for the relational data, via step 860. The results from both the relational and non-relational data sources are returned, via step 870.<br>
The following is a summary of ODBC calls which may be made by the ODBC API 302 to implement referential constraints in accordance with the method and system of the present invention:<br>
DELETE: Use the delete rules specified in the metadata to delete restrict, set null, or cascade. The ODBC driver of the present invention may need to make several calls into the relational DBMS in order to complete the requested    action.<br>
INSERT: Issue a SELECT ODBC call on the parent table to ensure that each<br>
row conforms to the referential constraint prior to passing the INSERT to the<br>
original relational DBMS ODBC driver. If the constraint does not pass, then	the<br>
ODBC driver of the present invention will generate an error message and   return control directly to the application program. From the application's viewpoint, it looks as if the underlying relational DBMS detected the      referential constraint violation and returned the error.<br>
UPDATE: Issue a SELECT ODBC call on the parent table to ensure that each<br>
row conforms to the referential constraint prior to passing the UPDATE to the original<br>
relational DBMS ODBC driver. If the constraint does not pass,      then the ODBC<br>
driver of the present invention will generate an error message	and return control<br>
directly to the application program. From the application's viewpoint, it looks as if the underlying relational DBMS detected the      referential constraint violation and returned the error.<br>
In this manner, referential integrity is provided within a keyed, sequential, or binary file system in accordance with the method and system of the present invention. The present invention provides dynamic real-time enforcement of the referential integrity constraints, at the data store level, across both relational databases and keyed, sequential, and binary file systems.<br>
Indices for Queries<br>
The method and system of the present invention provides a more efficient performance of queries, including ad-hoc queries, for non-relational databases. The efficiency is increased through the creation of an Index Manager which allows for the creation of indices for hash-keyed and sequential files. The indices are created based on the data selection criteria commonly used to satisfy user-defined ad-hoc queries. The user decides, based on the<br><br>
frequency that the query will be issued, along with the required response time to oDtain tne<br>
result set, which indices should be created.<br>
As illustrated in Figure 9, the Index Manager 902 is located next to the SQL Engine 314.<br>
The Index Manager 902 is accessed by the SQL Engine 314 during the satisfying of an end<br>
user query. In the preferred embodiment, the Index Manager comprises the following:<br>
Index Manager API 904: allows users to maintain their indices and access the data contained within the indices. This interface is available for use by external application programs that require access to the indices.<br>
Index Manager Hash-keyed and Sequential File Interface 906: provides a<br>
means of updating indices to reflect additions, updates, and deletions of data	from<br>
indices when the corresponding source data files change. This interface      is context sensitive in that it depends on the file maintenance mechanism        available on the data source.<br>
Index Manager B-Tree Function 908: index entries are maintained in a B-<br>
Tree structure within the Index Manager to maintain the index entries. B-   Tree<br>
structures are well known in the art and will not be discussed further	here.<br>
Index Manager Support Functions 910: include error logging and audit<br>
logging facilities, as well as a means of obtaining information about the data	being<br>
indexed, i.e., the meta data.<br>
Figure 10 is a flow chart illustrating the creation of indices by the Index Manager 802 in accordance with the present invention. First, hash-keyed and/or sequential files are created, via step 1010. Next, the Index Manager API 904 is used to specify an index or indices to be created on a field or fields within a file, via step 1020. The Index Manager 902 then creates an index on the specified field or fields, via step 1030. This index is kept up to date when changes are occurring in the source data files via the Index Manager Hash-keyed and Sequential File Interface 906.<br>
Figure 11 is a flowchart illustrating the use of the indices in satisfying a user query in accordance with the present invention. When the user executes a query, via step 1110, the query is sent to the SQL Engine 314, via step 1120. The SQL Engine 314 then accesses the Index Manager 902 via the Index Manager API 904 to see whether an index exists that helps satisfy the query, via step 1130. If so, the Index Manager API 904 makes function calls to retrieve the indexed data, via step 1140. If not, then eveiy record in the file needs to be read and compared to the selection criteria, via step 1150. Once the index data is retrieved, the Index Manager 902 determines if the index alone satisfies the query, via step 1160. If it does, then the result of the query is returned to DataJoiner 304 via the SQL Engine 314, via step 1170. If not, the rows based on the keyed file keys or binary sequential file offsets found in the index are also retrieved via the SQL Engine 314, via step 1180. Then the result is returned, via step 1170.<br><br>
With the Index Manager 902 of the present invention, indexing capabilities are provided to hash-keyed, sequential and binary files. The efficiency in the execution of other queries is also greatly improved. By allowing the query application processing to only retrieve data that is known based on indices to satisfy the user defined query, there will be less network traffic when the application issuing the query resides on a machine other than the one where the source data files are stored. In addition, the cost of disk space to store indices is lowered. A method and system for improved access to non-relational databases in a computer system has been disclosed. The method and system provides capabilities for a two-phase commit, performance of SQL operations from within a single application across heterogeneous file systems, referential integrity, and indices for ad-hoc and other queries for non-relational databases. These capabilities allow the computer system to perform data changes across multiple database sources within a single operation; perform SQL operations from a single application across heterogeneous file systems; provide referential integrity of data in both relational and non-relational databases; and perform ad-hoc queries of data and other queries efficiently when some or all of the data is stored in non-relational databases. By adding these capabilities, significant flexibility is added to the computer system. Although the present invention has been described in accordance with the embodiments shown, one of ordinary skill in the art will readily recognize that there could be variations to the embodiments and those variations would be within the spirit and scope of the present invention. Accordingly, many modifications may be made by one of ordinary skill in the art without departing from the spirit and scope of the appended claims.<br><br><br><br>
1.        A system for improved access to databases in a computer system, comprising:<br>
a plurality of data sources, the data sources including at least one non-relational data source;<br>
a server coupled to the plurality of data sources, the server capable of providing client access to the plurality of data sources; and<br>
a store place data access layer (SPDAL) coupled to the server and the at least one non-relational data source, the SPDAL providing relational features to the at least one non-relational data source.<br>
2.	The system of claim 1, wherein the relational features comprise:<br>
a two-phase commit process;<br>
a process for performing Structured Query Language (SQL) operations from within a single application;<br>
a referential integrity process; and<br>
a process for providing indices for non-relational data source files.<br>
3.	The system of claim 1, wherein the server is a DB2 Data Joiner.<br>
4.	The system of claim 3, wherein the DB2 DataJoiner comprises a Generic Access Applications Programming Interface (API) which allows for customized access to data sources not already supported by DataJoiner.<br>
5.	The system of claim 1, wherein the SPDAL comprises:<br>
a SPDAL Open Database Connectivity (ODBC) API coupled to the server;<br><br>
an ODBC Driver Manager coupled to a Generic Access API; a Generic Driver coupled to the ODBC Driver Manager; and a SQL Engine coupled to the Generic Driver.<br>
6.	The system of claim 5, wherein the Generic Driver comprises:<br>
an intercept layer, the intercept layer functioning as a resource manager for the at least one non-relational database during a two-phase commit process.<br>
7.	The system of claim 5, further comprising:<br>
an index manager coupled to the SQL Engine, the index manager allowing for the creation of indices for the at least one non-relational data source.<br>
8.	The system of claim 7, wherein the index manager comprises:<br>
an index manager API;<br>
a hash-keyed and sequential file interface; a B-Tree function; and a support function.<br>
9.	A system for improved access to databases in a computer system, comprising:<br>
a plurality of data sources, the data sources including at least one non-relational data source;<br>
a server coupled to the plurality of data sources, the server capable of providing client access to the plurality of data sources; and<br>
a SPDAL coupled to the server and the at least one non-relational data source, the SPDAL providing relational features to the at least one non-relational data source, wherein the relational features comprises:<br>
a two-phase commit process;<br><br>
a process for performing SQL operations from within a single application;<br>
a referential integrity process; and<br>
a process for providing indices for non-relational data source files.<br>
10.	The system of claim 9, wherein the server is a DB2 DataJoiner.<br>
11.	The system of claim 10, wherein the DB2 DataJoiner comprises a Generic Access API which allows for customized access to data sources not already supported by DataJoiner.<br>
12.	The system of claim 9, wherein the SPDAL comprises:<br>
a SPDAL ODBC API coupled to the server;<br>
an ODBC Driver Manager coupled to a Generic Access API; a Generic Driver coupled to the ODBC Driver Manager; and a SQL Engine coupled to the Generic Driver.<br>
13.	The system of claim 12, wherein the Generic Driver comprises:<br>
an intercept layer, the intercept layer functioning as a resource manager for the at least one non-relational database during a two-phase commit process.<br>
14.	The system of claim 12, further comprising:<br>
an index manager coupled to the SQL Engine, the index manager allowing for the creation of indices for the at least one non-relational data source.<br>
15.	The system of claim 14, wherein the index manager comprises:<br>
an index manager API;<br>
a hash-keyed and sequential file interface; a B-Tree function; and a support function.<br>
16.	A system for improved access to databases in a computer system, comprising:<br><br>
a plurality of data sources, the data sources including at least one non-relational data source;<br>
a server coupled to the plurality of data sources, the server capable of providing client access to the plurality of data sources; and<br>
a SPDAL coupled to the server and the at least one non-relational data source, the SPDAL providing relational features to the at least one non-relational data source, wherein the relational features comprises:<br>
a two-phase commit process;<br>
a process for performing SQL operations from within a single application;<br>
a referential integrity process; and a process for providing indices for non-relational data source files;<br>
wherein the SPDAL comprises:<br>
a SPDAL ODBC API coupled to the server;<br>
an ODBC Driver Manager coupled to a Generic Access API;<br>
a Generic Driver coupled to the ODBC Driver Manager, the Generic Driver comprising an intercept layer, the intercept layer functioning as a resource manager for the at least one non-relational database during the two-phase commit process;<br>
a SQL Engine coupled to the Generic Driver; and<br>
an index manager coupled to the SQL Engine, the index manager allowing for the creation of indices for the at least one non-relational data source.<br>
17.	The system of claim 16, wherein the server is a DB2 DataJoiner, the DB2 DataJoiner comprising a Generic Access API which allows for customized access to data sources not already supported by DataJoiner.<br>
18.	The system of claim 16, wherein the index manager comprises:<br><br>
an index manager API;<br>
a hash-keyed and sequential file interface;<br>
a B-Tree function; and<br>
a support function. 19.      A method for performing a two-phase commit process in a computer system, the computer system including a plurality of data sources, the plurality of data sources including at least one non-relational data source, comprises the steps of:<br>
(a)	sending a first request to the at least one non-relational data source for commitment to a transaction;<br>
(b)	receiving a first reply from the at least one non-relational data source in response to the first request;<br><br>
(c)	sending a second request to another of the plurality of data sources for commitment to the transaction;<br>
(d)	receiving a second reply from the other of the plurality of data sources in response to the second request;<br>
(e)	determining if the first and second replies both indicate a commitment to the transaction; and<br>
(f)	performing the transaction if the first and second replies both indicate a commitment to the transaction.<br>
20.       The method of claim 19, further comprising:<br>
(g)	indicating a failure of the transaction if the first and second replies do not both<br>
indicate a commitment to the transaction.<br><br>
21.	A method for performing SQL operations in a computer system, the computer system<br>
including a plurality of data sources, the plurality of data sources including at least one<br>
non-relational data source, comprising the steps of:<br>
(a)	providing a plurality of metadata tables, the metadata tables describing a content of the at least one non-relational data source; and<br>
(b)	utilizing the metadata tables to gain access to the at least one non-relational data source and the other data source wherein the SQL operation is performed from within a single application.<br>
22.	A method for performing referential integrity in a computer system, the computer<br>
system including a plurality of data sources, the plurality of data sources including at least<br>
one non-relational data source, comprising the steps of:<br>
(a)	capturing an end user query;<br>
(b)	preprocessing the end user query based upon information in metadata tables, the metadata tables describing a content of the at least one non-relational data source;<br>
(c)	returning the end user query to the server.<br>
23.	The method of claim 22, wherein the preprocessing step (b) comprises:<br>
(bl)     determining referential integrity is required for the end user query;<br>
(b2)     formulating at least one query to execute and enforce referential constraint for the end user query.<br>
24.	The method of claim 22, further comprising the steps of:<br>
(d)	processing the end user query on the at least one non-relational data source; and<br>
(e)	returning a result of the end user queiy.<br><br>
25.	The method of claim 24, wherein the processing step (jd) comprises:<br>
(dl)     translating the at least one queiy to a command understandable by the at least one non-relational data source; and<br>
(d2)     executing the command.<br>
26.	A method for performing referential integrity in a computer system, the computer<br>
system including a plurality of data sources, the plurality of data sources including at least<br>
one non-relational data source, comprising the steps of:<br>
(a)	capturing an end user query;<br>
(b)	determining referential integrity is required for the end user query;<br>
(c)	formulating at least one query to execute and enforce referential constraint for the end user query;<br>
(d)	returning the end user query to the server;<br>
(e)	determining if the end user query requires data from the at least one non-relational data source;<br>
(f)	translating the at least one query to a command understandable by the at least one non-relational data source if data from the at least one non-relational data source is required;<br>
(g)	executing the command; and<br>
(h)       returning a result of the end user query to the server.<br>
27.	A method for providing indices in a computer system, the computer system including<br>
a plurality of data sources, the plurality of data sources including at least one non-relational<br>
data source, comprising the steps of:<br>
(a)       creating indices for the at least one non-relational data source; and<br><br>
(b)       utilizing the indices in executing a query.<br>
28.	The method of claim 27, wherein the creating step (a) comprises:<br>
(al)     creating hash-keyed and sequential files for the at least one non-relational data source;<br>
(a2)     specifying at least one field of the hash-keyed and/or sequential files; and (a3)     creating an index for the at least one field,<br>
29.	The method of claim 27, wherein the utilizing step (b) comprises:<br>
(bl)     determining if an index exists which assists the performance of a query; (b2)     retrieving the index if the index exists; (b3)     determining if the index alone satisfies the query; and (b4)     retrieving additional data from the at least one non-relational data source based upon the index if the index alone does not satisfy the queiy.<br>
30.	A method for providing indices in a computer system, the computer system including<br>
a plurality of data sources, the plurality of data sources including at least one non-relational<br>
data source, comprising the steps of:<br>
(a)	creating hash-keyed and sequential files for the at least one non-relational data source;<br>
(b)	specifying at least one field of the hash-keyed and/or sequential files;<br>
(c)	creating an index for the at least one field;<br>
(d)	determining if an index exists which assists the performance of a query;<br>
(e)	retrieving the index if the index exists;<br>
(f)	determining if the index alone satisfies the queiy; and<br><br>
(g)       retrieving additional data from the at least one non-relational data source based upon the index if the index alone does not satisfy the query.<br>
31.	A computer readable medium with program instructions for performing a two-phase<br>
commit process in a computer system, the computer system including a plurality of data<br>
sources, the plurality of data sources including at least one non-relational data source,<br>
program instructions for:<br>
(a)	sending a first request to the at least one non-relational data source for commitment to a transaction;<br>
(b)	receiving a first reply from the at least one non-relational data source in response to the first request;<br><br>
(c)	sending a second request to another of the plurality of data sources for commitment to the transaction;<br>
(d)	receiving a second reply from the other of the plurality of data sources in response to the second request;<br>
(e)	determining if the first and second replies both indicate a commitment to the transaction; and<br>
(f)	performing the transaction if the first and second replies both indicate a commitment to the transaction.<br>
32.	A computer readable medium with program instructions for performing SQL<br>
operations in a computer system, the computer system including a plurality of data sources,<br>
the plurality of data sources including at least one non-relational data source, program<br>
instructions for:<br><br>
(a)	providing a plurality of metadata tables, the metadata tables describing a content of the at least one non-relational data source; and<br>
(b)	utilizing the metadata tables to gain access to the at least one non-relational data source and the other data source wherein the SQL operation is performed from within a single application.<br>
33.	A computer readable medium with program instructions for performing referential<br>
integrity in a computer system, the computer system including a plurality of data sources, the<br>
plurality of data sources including at least one non-relational data source, program<br>
instructions for:<br>
(a)	capturing an end user query;<br>
(b)	preprocessing the end user query based upon information in metadata tables, the metadata tables describing a content of the at least one non-relational data source;<br>
(c)	returning the end user query to the server.<br><.></.>
34.	A computer readable medium with program instructions for performing referential<br>
integrity in a computer system, the computer system including a plurality of data sources, the plurality of data sources including at least one non-relational data source, program instructions for:<br>
(a)	capturing an end user queiy;<br>
(b)	determining referential integrity is required for the end user query;<br>
(c)	formulating at least one query to execute and enforce referential constraint for the end user query;<br>
(d)	returning the end user query to the server;<br><br>
(e)	determining if the end user query requires data from the at least one<br>
non-relational data source;<br>
(f)	translating the at least one query to a command understandably by the at least one non-relational data source;<br>
(g)	executing the command; and<br>
(h)       returning the end user query to the server. 35.       A computer readable medium with program instructions for providing indices in a computer system, the computer system including a plurality of data sources, the plurality of data sources including at least one non-relational data source, program instructions for:<br>
(a)	creating indices for the at least one non-relational data source; and<br>
(b)	utilizing the indices in executing a queiy.<br>
36.     A system for improved access to databases in a computer system,  substantially as herein  described  with reference to  the accompanying drawings.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDUwMS1tYXMtMjAwMSBhYnN0cmFjdCBncmFudGVkLnBkZg==" target="_blank" style="word-wrap:break-word;">0501-mas-2001 abstract granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDUwMS1tYXMtMjAwMSBjbGFpbXMgZ3JhbnRlZC5wZGY=" target="_blank" style="word-wrap:break-word;">0501-mas-2001 claims granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDUwMS1tYXMtMjAwMSBkZXNjcmlwdGlvbihjb21wbGV0ZSkgZ3JhbnRlZC5wZGY=" target="_blank" style="word-wrap:break-word;">0501-mas-2001 description(complete) granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MDUwMS1tYXMtMjAwMSBkcmF3aW5ncyBncmFudGVkLnBkZg==" target="_blank" style="word-wrap:break-word;">0501-mas-2001 drawings granted.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTAxLW1hcy0yMDAwLWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">501-mas-2000-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTAxLW1hcy0yMDAwLWFzc2lnbm1lbnQucGRm" target="_blank" style="word-wrap:break-word;">501-mas-2000-assignment.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTAxLW1hcy0yMDAwLWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">501-mas-2000-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTAxLW1hcy0yMDAwLWNvcnJlc3BvbmRlbmNlIG90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">501-mas-2000-correspondence others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTAxLW1hcy0yMDAwLWNvcnJlc3BvbmRlbmNlIHBvLnBkZg==" target="_blank" style="word-wrap:break-word;">501-mas-2000-correspondence po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTAxLW1hcy0yMDAwLWRlc2NyaXB0aW9uIGNvbXBsZXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">501-mas-2000-description complete.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTAxLW1hcy0yMDAwLWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">501-mas-2000-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTAxLW1hcy0yMDAwLWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">501-mas-2000-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTAxLW1hcy0yMDAwLWZvcm0gMTkucGRm" target="_blank" style="word-wrap:break-word;">501-mas-2000-form 19.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTAxLW1hcy0yMDAwLWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">501-mas-2000-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=NTAxLW1hcy0yMDAwLWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">501-mas-2000-form 5.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="198931-a-one-part-adhesive-composition-containing-an-isocyanate-functional-prepolymer.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="198933-a-milk-cooker.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>198932</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>501/MAS/2001</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>23/2006</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>09-Jun-2006</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>21-Feb-2006</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>21-Jun-2001</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>M/S. HONDA GIKEN KOGYO KABUSHIKI KAISHA</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>1-1 MINAMI-AOYAMA 2-CHOME, MINATO KU, TOKYO 107-8556,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>KOUSUKE AKASAKA</td>
											<td>C/O HONDA R&amp;D CO., LTD, 4-1 CHUO 1-CHOME, WAKO-SHO, SAITAMA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>B62D 25/20</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>2000-192364</td>
									<td>2000-06-27</td>
								    <td>Japan</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/198932-a-front-structure-for-a-vehicle by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 05:46:54 GMT -->
</html>
