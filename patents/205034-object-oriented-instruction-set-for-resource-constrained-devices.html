<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/205034-object-oriented-instruction-set-for-resource-constrained-devices by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:04:07 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 205034:OBJECT-ORIENTED INSTRUCTION SET FOR RESOURCE-CONSTRAINED DEVICES</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">OBJECT-ORIENTED INSTRUCTION SET FOR RESOURCE-CONSTRAINED DEVICES</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A resource-constrained device comprising: a memory(54) for storing an application software program comprising an object-oriented, verifiable, type-safe and pointer-safe sequence of instructions, the instructions comprising operation codes and operands, the instructions previously converted from at least one class file, the conversion transforming at least one reference to a constant pool to inline data in the instructions; a random access memory (50) having a capacity of no more than about 64 kilo-bytes; and a virtual machine (49) implemented on a microprocessor (48) coupled to said memory and to said random access memory wherein the virtual machine is adapted to execute the sequence of instructions.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT,  1970                                  [39 OF 1970]                                              &amp;                                                              THE PATENTS RULES, 2003 COMPLETE SPECIFICATION<br>
[See Section 10; rule 13]<br>
'RESOURCE-CONSTRAINED DEVICE"<br>
SUN MICROSYSTEMS, INC., of 901 San Antonio Road, M/S PAL01-521, Palo Alto, California 94303, United States of.America,<br>
The following specification particularly describes the nature of the invention and the manner in which it is to be performed:-<br><br><br>
BACKGROUND<br>
The present invention relates, in general, to object-oriented, architecture-neutral programs for use with resource-constrained devices such as smart cards and the like.<br>
A virtual machine is an abstract computing machine generated by a software application or sequence of instructions which is executed by a processor. The term "architecture-neutral" refers to programs, such as those written in the Java™ programming language, which can be executed by a virtual machine on a variety of computer platforms having a variety of different computer architectures. Thus, for example, a virtual machine being executed on a Windows™-based personal computer system will use the same set of instructions as a virtual machine being executed on a UNIX   -based computer system. The result of the platform-independent coding of a virtual machine's sequence of instructions is a stream of one or more bytecodes, each of which is, for example, a one-byte-long numerical code.<br>
Use of the Java programming language has found many applications including, for example, those associated with Web browsers.<br>
The Java programming language is object-oriented. In an object-oriented system, a "class" describes a collection of data and methods that operate on that data. Taken together, the data and methods describe the state of and behavior of an object.<br>
Java also is verifiable such that, prior to execution of an application written in the Java programming language, a determination can be made as to whether any instruction sequence in the program will attempt to process data of an improper type for that bytecode or whether execution of bytecode instructions in the program will cause underflow or overflow of an operand stack.<br>
A Java™ virtual machine executes virtual machine code written in the Java programming language and is designed for use with a 32-bit architecture. However, various resource-constrained devices, such as smart cards, have an 8-bit or 16-bit architecture.<br>
Smart cards, also known as intelligent portable data-carrying cards, generally are made of plastic or metal and have an electronic chip that includes an embedded microprocessor to execute programs and memory to store programs and data. Such devices, which can be about the size of a credit card, typically have limited memory capacity. For example, some<br><br>
smart cards have less than one kilo-byte (IK) of random access memory (RAM) as well as limited read only memory (ROM), and/or non-volatile memory such as electrically erasable programmable read only memory (EEPROM). The limited architecture and memory make it impractical or impossible to implement the full Java Virtual Machine on the device.<br>
Furthermore, smart cards come with a variety of processors and configurations. Thus, it is desirable to provide a platform-independent programming language that can be executed on such a resource-constrained device.<br>
SUMMARY In general, a verifiable, object-based, type-safe and pointer-safe instruction set is described for application software programs which can be downloaded to and executed on a range of resource-constrained devices.<br>
According to one aspect, an application software program.includes an object-oriented, verifiable, type-safe and pointer-safe sequence of instructions residing on a computer-readable medium. The program can be loaded to and executed by a resource-constrained device that is based on an architecture of fewer than 32 bits, such as a 16-bit or 8-bit architecture.<br>
According to another aspect, an application software program includes an object-oriented, verifiable, type-safe and pointer-safe sequence of instructions residing on a computer-readable medium. The program can be loaded to and executed by a resource-constrained device having random access memory with a capacity of no more than about 64K.<br>
Various implementations include one or more of the following features. For example, each instruction can include an 8-bit operation code, and the sequence of instructions can be hardware platform-independent. In some implementations, the sequence includes instructions that were previously converted from at least one Java class file with at least some references to a constant pool transformed to inline data. For example, the instructions can include operation codes and operands. Some references to the constant pool can be inlined into operands, and some references to the constant pool can be inlined into operation codes.<br>
Similarly, in some embodiments, the instructions can be executed by a device that supports multiple data types. The sequence of instructions can include data manipulation   instructions each of which is specific to a particular data type. In some implementations, the data type associated with each data manipulation instruction is selected from among one of the following types: an 8-bit signed two's complement integer numeric type, a 16-bit signed two's complement integer numeric type and a 32-bit signed two's complement integer numeric type. Additionally, the instructions can be executed by a device that supports multiple reference<br><br>
types each of which is selected from among one of the following types: a class type, an interface type and an array type. Furthermore, the program can include one or more composite instructions for performing an operation on a current object.<br>
According to another aspect, a resource-constrained device includes memory for storing an application software program comprising an object-oriented, verifiable, type-safe and pointer-safe sequence of instructions. The device also includes a virtual machine implemented on a microprocessor. The virtual machine is capable of executing the sequence of instructions. In various embodiments, the device may be based on a limited architecture or may have a limited amount of memory. For example, in some implementations, the device includes random access memory having a capacity of no more than about 64K. In other embodiments, the microprocessor is based on an architecture of less than 32 bits, for example, a 16 or 8-bit architecture.<br>
In other embodiments, an application-specific integrated circuit (ASIC) or a combination of a hardware and firmware can be used instead of a virtual machine running on a microprocessor.<br>
In one particular application of the invention, the resource-constrained device is a smart card. The smart card can include a virtual machine implemented on a microprocessor, wherein the virtual machine is capable of executing a sequence of instructions such as those described above.<br>
According to another aspect, methods are disclosed for using an application software program including an object-oriented, verifiable, type-safe and pointer-safe sequence of instructions. The software program can be received in a resource-constrained device having, for example, either limited memory or based on a limited architecture. The sequence of instructions then can be executed on the resource-constrained device. In some implementations, the software program can be accessed over a computer network such as the Internet prior to downloading it onto the device. When the program is downloaded to the resource-constrained device, constant pool indices that appear in the received set of instructions can be transformed to corresponding data values.<br>
Various implementations include one or more of the following advantages. By supporting many, although not all, of the features of the Java language and by using the same semantics as the Java class files, platform-independent virtual machine code can be written to be executed by a smart card or other resource-constrained device.<br>
The instruction set can inline certain data, which would otherwise appear as part of a constant pool, directly into operation codes or operands. Thus, the instruction set itself can<br><br>
incorporate certain information that would otherwise be stored in and obtained from a constant pool if one were using the Java class file format. By inlining some of the information directly into the instruction set, the size of the constant pool can be reduced, which can help reduce the amount of memory required to store the constant pool and can improve the execution speed of the bytecode. In some cases, inlining the information directly into an operation code can reduce the number of operands required for a particular instruction. Further inlining of information from a constant pool when the program is downloaded to the resource-constrained device can either eliminate the need to retain the constant pool on the device or reduce the size of the constant pool.<br>
Other features such as composite instructions for performing operations on the current object and the explicit handling of 16-bit arithmetic can further reduce the length of a bytecode program.<br>
Other features and advantages will be readily apparent from the following detailed description, the accompanying drawings and the claims.<br>
BRIEF DESCRIPTION OF THE ACCOMPANYING DRAWINGS <br>
FIG. 1 illustrates an exemplary system including a virtual machine residing on a smart card according to the invention.<br>
FIG. 2 is a flow chart illustrating a method of providing executable code to a smart card according to the invention.<br>
FIGS. 3 A and 3B illustrate, respectively, an exemplary format of virtual machine instruction and an inner loop of execution of the virtual machine according to the invention.<br>
FIGS. 4A and 4B are tables of an exemplary set of operation codes for the virtual machine listed in numerical order by operation code and in alphabetical order by mnemonic, respectively.<br>
FIG. 5 is a list of data types which are supported by operation codes that exist for multiple data types according to the invention.<br>
FIG. 6A illustrates the format of an "iipush" instruction according to the invention, and<br>
FIG. 6B illustrates the format of a corresponding "ldc" instruction in the Java class file format.<br>
FIG. 7 A illustrates the format of a "checkcast" instruction in the Java class file format, and<br><br>
FIG. 7B illustrates the format of a "checkcast" instruction according to the invention.<br>
FIG. 8A illustrates the format of a family of "getfield "T" instructions according to the invention, and<br>
FIG. 8B illustrates the format of a corresponding "getfield" instruction in the Java class file format.<br>
FIG. 9A and 9B illustrate how an implementation program on the smart card prepares virtual machine code for installation on the smart card according to one embodiment of the invention.<br>
FIGS. 10A and I OB illustrate alternative instructions for obtaining the same result according to the invention.<br>
FIG. 11A illustrates bytecodes for carrying out a mathematical expression using the Java class file format, and<br>
FIG. 11B illustrates bytecodes for carrying out the same mathematical expression according to the invention.<br>
FIG. 12 is partial, non-exclusive list of resource-constrained devices with which the invention can be used.<br>
DESCRIPTION A verifiable, object-based, type-safe and pointer-safe instruction set is described below for application software programs which can be downloaded to and executed on a range of resource-constrained devices. Resource-constrained devices are generally considered to be those that are relatively restricted in memory and/or computing power or speed, as compared to conventional desktop computers and the like. Although the particular implementation discussed below is described in reference to a smart card, the invention can be used with other - resource-constrained devices including, but not limited to, cellular telephones, boundary scan devices, field programmable devices, personal digital assistants (PDAs) and pagers, as well as other miniature or small footprint devices.<br>
Programs written with the instruction set described below are capable of being   downloaded to and executed on resource-constrained devices having about sixty-four kilo¬bytes (64K) of RAM or less. Some of the resource-constrained devices in which such programs can be executed may have no more than about sixteen kilo-bytes (16K) of RAM and others may have no more than about four kilo-bytes (4K) of RAM. Many of the devices also have limited amounts of other memory, such as no more than about twenty-four kilo-bytes (24K) of ROM, or no more than about 16K of non-volatile memory such as EEPROM.<br><br>
Similarly, some resource-constrained devices are based on an architecture designed for fewer than 32 bits. For example, some of the devices which can be used with the invention are based on an 8-bit or 16-bit architecture, rather than a 32-bit architecture. Of course, applications using the instruction set described below are upward compatible and can be executed, for example, on other Java platforms provided equivalent device support is present.<br>
Referring to FIGS. 1 and 2, development of an applet for a resource-constrained device, such as a smart card 40, begins in a manner similar to development of other Java programs. In other words, a developer writes one or more JAVA classes (step 60) and compiles the source code with a JAVA compiler to produce one or more class files 10 (step 62). The applet can be run, tested and debugged, for example, on a workstation using simulation tools to emulate the environment on the card 40. When the applet is ready to be downloaded to the card 40, the class files 10 are converted to a converted applet (CAP) file 16 by a converter 14 (step 64). The converter 14 can be implemented as a Java application being executed by a desktop computer. The converter 14 can accept as its input one or more export files 12 in addition to the class files 10 to be converted. An export file 12 contains naming or linking information for the contents of other packages that are imported by the classes being converted.<br>
In general, the CAP file 16 includes all the classes and interfaces defined in a single Java package and is represented by a stream of 8-bit bytes. All 16-bit and 32-bit quantities are constructed by reading in two or four consecutive 8-bit bytes, respectively. Among other things, the CAP file 16 includes a constant pool component 18 which is packaged separately from a method component 20. The constant pool component 18 can include various types of constants, ranging from numerical literals known at compile time to method and field references which are resolved either when the program is downloaded to the smart card 40 or at the time of execution by the smart card. The method component 20 specifies the set of instructions to be downloaded to the smart card 40 and subsequently executed by the smart card. Further details of the structure of an exemplary CAP file 16 are discussed in a publication by Sun Microsystems, Inc. entitled "Java Card Runtime Environment (JCRE) 2.1 Specification," (1998) which is incorporated herein by reference in its entirety.<br>
After conversion, the CAP file 16 can be stored on a computer-readable medium 17 such as a hard drive, a floppy disk, an optical storage medium, a flash device or some other suitable medium.<br>
The CAP file 16 then can be copied or transferred to a terminal 22 (step 66) such as a desktop computer with a peripheral card acceptance device (CAD) 24. In some<br><br>
embodiments, the terminal 22 can be connected to a network (not shown), such as the Internet,<br>
local area network (LAN) or a'wide area network (WAN), which communicates with other<br>
omputing devices such as a server. In such situations, the CAP file 16 can be accessed and<br>
ransmitted to the terminal 22 over the network. The CAP file 16 also can be provided to the<br>
erminal 22 using a carrier wave, such as a network data transmission.<br>
The CAD 24 allows information to be written to and retrieved from the smart card 10. The CAD 24 includes a card port (not shown) into which the smart card 40 can be nserted. Once inserted, contacts from a connector press against the surface connection area on he smart card 40 to provide power and to permit communications with the smart card, although, in other implementations, contactless communications can be used. The terminal 22 ilso includes an installation tool 26 which loads the CAP file 16 for transmission to the card 40 Step 68).<br>
The smart card 40 has an input/output (I/O) port 42 which can include a set of :ontacts through which programs, data and other communications are provided. The card 40 also includes an installation tool 46 for receiving the contents of the CAP file 16 and preparing the applet for execution on the card 40 (step 70). The installation tool 46 can be implemented, for example, as a Java program and can be executed on the card 40. The card 40 also has memory, including volatile memory such as RAM 50. The card 40 also has ROM 52 and non¬volatile memory, such as EEPROM 54. The applet prepared by the controller 44 can be stored in the EEPROM 54.<br>
In one particular implementation, the applet is executed by a virtual machine 49 running on a microprocessor 48 (step 72). The virtual machine 49, which can be referred to as the Java Card™ Virtual Machine, need not load or manipulate the CAP file 16. Rather, the Java Card Virtual Machine 49 executes the applet code previously stored as part of the CAP file 16. The division of functionality between the Java Card Virtual Machine 49 and the installation tool 46 allows both the virtual machine and the installation tool to be kept relatively small.<br>
In general, implementations and applets written for a resource-constrained platform such as the smart card 40 follow the standard rules for Java platform packages. The Java Virtual Machine and the Java programming language are described in T. Lindholm et al., The Java Virtual Machine Specification (1997), and K. Arnold et al., The Java Programming Language Second Edition, (1998), which are incorporated herein by reference in their entirety. Application programming interface (API) classes for the smart card platform can be written as Java source files which include package designations, where a package includes a number of<br><br>
compilation units and has a unique name. Package mechanisms are used to identify and control access to classes, fields and methods. The Java Card API allows applications written for one Java Card-enabled platform to run on any other Java Card-enabled platform. Additionally, the Java Card API is compatible with formal international standards such as ISO 7816, and industry-specific standards such as Europay/MasterCard/Visa (EMV).<br>
The smart card platform of the present invention supports dynamically created objects including both class instances and arrays. A class is implemented as an extension or subclass of a single existing class and its members are methods as well as variables referred to as fields. A method declares executable code that can be invoked and that receives a fixed number of values as arguments. Classes also can define or implement Java interfaces. An interface is a reference type whose members are constants and abstract methods.<br>
Individual instructions stored in the CAP file 16 and subsequently downloaded to the smart card 40 include an 8-bit operation code (opcode) followed by either zero, one or multiple 8-bit operands (FIG. 3A). Some instructions have no operands and consist only of an<br>
	opcode. The general form of the inner loop of execution of the Java Card Virtual Machine 49<br>
is illustrated in FIG. 3B. When a method is invoked, the Java Card Virtual Machine 49<br>
allocates a frame which has a set of local variables and contains an operand stack. Many of the<br>
operation codes discussed below take one or more values from the operand stack of the current<br>
frame, operate on them, and return results to the same stack. The operand stack also is used to<br>
-	pass arguments to methods and receive method results.<br>
Values from the operand stack must be operated upon in ways that are appropriate to their types. The Java Card Virtual Machine 49 supports two kinds of data types: primitive types and reference types. The numeric primitive types supported by the Java Card Virtual Machine 49 are: (1) "byte", whose values are 8-bit signed two's complement integers; (2)<br>
"   "short", whose values are 16-bit signed two's complement integers; and, optionally, (3) "int", whose values are 32-bit signed two's complement integers. The Java Card Virtual Machine 49 also supports a "retumAddress" type, whose values are pointers to the operation codes in the instructions for the virtual machine. The reference types supported by the Java Card Virtual<br>
 Machine 49 are (1) "class" types; (2) "interface" types; and (3) "array" types. Those reference types are the same as the reference types used in the Java Virtual Machine. The Java Card Virtual Machine 49 is defined in terms of an abstract storage unit, which can be referred to as a word, which is sufficiently large to hold a value of the type "byte," "short," "reference," or "retumAddress." Two words are sufficiently large to hold a value of the type "int." Multiple-byte operand data is encoded in big-endian order, in other words, with the high-order byte first.<br><br>
Various keywords, which cannot be used as identifiers or names of declared entities, are supported by the Java Card Virtual Machine 49. The function and use of those keywords is the same as the corresponding keywords in the Java programming language. The operation codes which form the executable program stored in the method component 20 of the CAP file 16 are designed to use the same semantics as that used in the class files 10 written in the Java language. Thus, for example, mathematical results and class hierarchies are preserved when the converter 14 transforms the Java class files 10 into the CAP file 16. Nevertheless, as will be evident from the following description, a sequence of instructions that can be executed by the Java Card Virtual Machine 49 differs from programs " intended solely to be run by a system incorporating the Java Virtual Machine. Some of the differences are due to the more limited support of data types present in the instruction set discussed below. Other differences result from the fact that the instruction set discussed below is designed to be executable by a virtual machine residing on a resource-constrained device. Some details of the instruction set are intended to optimize the size or performance of either - the Java Card Virtual Machine 49 or the programs running on it. Such details include inlining constant pool data directly into die operation codes or operands, adding multiple versions of a particular instruction to handle different data types, creating composite instructions for operations on the current object, and explicitly handling 16-bit arithmetic.<br>
Referring to FIGS. 4A and 4B, an exemplary instruction set is provided for programs to be executed by the Java Card Virtual Machine 49. Each instruction is identified by a corresponding operation code (opcode) mnemonic and numerical representation. With the exception of two reserved opcodes, impdepl and impdep2, all of the opcodes typically can be used in a CAP file such as the CAP file 16. The instructions corresponding to the two reserved opcodes provide backdoors or traps to implementation-specific functionality implemented in software and hardware, respectively. Accordingly, the two reserved opcodes typically do not properly appear in the CAP file 16. They are typically used only in representations of programs that were placed on the smart card 40 by means other than receipt of a CAP file.<br>
As previously mentioned, each instruction includes an operation code followed by zero, one, or more operands. In other words, the instructions have the following general format:<br>
operation code<br>
operandi<br>
operand2<br><br>
Each word in the instruction format represents a single 8-bit byte or "bytecode." The instruction's opcode is its numeric representation. Each instruction also has a corresponding mnemonic which is its name. However, only the numeric representation is present in the virtual machine code in a CAP file such as the CAP file 36.<br>
Each data manipulation instruction is specific to a particular data type. The instruction set corresponding to the operation codes listed in FIG. 4A supports a subset of the features supported by the Java programming language. By supporting many, although not all, of the features of the Java language and by using the same semantics as the Java class files 10, platform-independent virtual machine code can be written to be executed by the smart card 40    or other resource-constrained device.<br>
As mentioned above, the instruction set for the Java Card Virtual Machine inlines certain data, which would otherwise appear as part of the constant pool 18, directly into the operation codes or operands. Thus, the instruction set itself incorporates certain information that would otherwise be stored in and obtained from a constant pool if one were using the Java  class file format. Thus, when the one or more Java class files 10 are converted to the CAP file 16, at least some references to a constant pool are transformed to inline data in the bytecodes associated with the CAP file.<br>
For example, if the virtual machine 49 supports the data type "int," then the "iipush" operation code can be used to push an integer value onto the operand stack. The   general format for the "iipush" instruction is illustrated in FIG. 6A, and the format of a<br>
corresponding "ldc" instruction from the Java class file format is shown in FIG 6B. The "ldc" instruction includes the operand "index" which is an unsigned byte that is an index into a constant pool. In contrast, the "iipush" instruction, which is executable by the Java Card Virtual Machine 49, eliminates the need to refer to the constant pool when executing that      instruction. Although the "iipush" instruction includes four operands, thereby increasing the length of the instruction, the slightly longer program can be offset by the savings in memory space which is achieved by eliminating the need to store additional information in the constant pool 18.<br>
Similarly, the "checkcast" operation code can be used to check whether an object is     of a particular type. The general format for the "checkcast" instruction for the Java Card Virtual Machine 49 is illustrated in FIG. 7 A, and the format of a corresponding "checkcast" instruction from the Java class file format is shown in FIG 7B. The data type for the Java Card Virtual Machine 49 has been inlined directly into the instruction, in contrast to the corresponding Java instruction in which the data type is obtained from a constant pool. By<br><br>
inlining some of the information directly into the instruction set, the size of the constant pool 18 that is stored in the CAP file 16 can be reduced.<br>
The foregoing examples illustrate how the instruction set for the Java Card Virtual Machine 49 inlines some information directly into an operand. In some cases, an additional<br>
  form of inlining is provided by inlining information that would otherwise be stored in the constant pool 18 directly into an operation code. Thus, for example, the instruction set for the Java Card Virtual Machine adds multiple versions of several instruction to handle different data types so that those instructions appear as members of a family of related instructions which share a single description, format and operand stack diagram. Each instruction in such a family of instructions implicitly specifies the data type in the operation code itself. The table in FIG. 5 provides a list of the data types which are supported by instructions that exist for multiple data types. Wide and composite forms of instructions are not listed. Referring to FIG. 5, a specific instruction, with the data type incorporated into me operation code, is obtained by replacing the "T" in the instruction template in the opcode column by the letter<br>
   representing the type in the type column. Where the column for a particular instruction is left blank, then no instruction exists supporting the particular operation on that data type. For example, there is a "load" instruction for the data type "short," but there is no "load" instruction for the data type "byte."<br>
With instructions that implicitly incorporate the data type into the operation code, the program can operate more quickly and with less data on the smart card 40 than would otherwise be required. Those advantages arise because the data type is directly encoded in the instructions rather than being obtained from an entry in the constant pool. For example, consider the family of "getfieldT" instructions, which includes the instructions "getfield_a," "getfield_b," "getfield_s" and "getfield_i "  The general format of the "getfield_T" instructions for use with the Java Card Virtual Machine 49 is illustrated in FIG. 8A, which contrasts with the format of the corresponding "getfield" instruction in the Java class file format as shown in FIG. 8B. In the instructions for the Java Card Virtual Machine 49 (FIG. 8A), the data type has been inlined not only into the instruction, but it has been inlined directly into the operation code. On the one hand, such features can reduce the amount of information stored in the CAP file 16 and also can reduce the number of operands required for the particular instruction. On the other hand, those features expand the number of distinct operation codes.<br>
Whereas the type of inlining discussed with respect to the "iipush" and "checkcast" opcodes can be advantageous for instructions that tend to be less frequently used, the type of<br><br>
inlining discussed with respect to the "getfield_t" family of instructions can be advantageous particularly for instructions that tend to be used more frequently.<br>
The foregoing examples illustrate how the instruction set for the Java Card Virtual Machine 49 inherently inlines certain information. Another form of inlining information can occur when the CAP file 16 is downloaded to the smart card 40, as explained below.<br>
The installation tool 46 on the smart card 40 can be platform-specific and allows the actual storage of the contents of the CAP file 16 to be determined based on the particular platform receiving and preparing the virtual machine code for execution. Thus, in some implementations, the CAP file 16 may be stored on the smart card 40, or other resource-constrained device, in a manner that differs from the manner in which it was received by the smart card. For example, in some cases, when the CAP file 16 is installed on the card 40, the installation tool 46 can link the contents of the CAP file so that the size of the constant pool 18 can be reduced, and in some cases, so that the constant pool need not be retained or stored on the card. That can be accomplished by converting the constant pool indices that appear as part of the code in the CAP file 18 to the corresponding data at the time of installation, as illustrated in FIGS. 9A and 9B. For example, an index to the constant pool 16 can be replaced by an index to the appropriate field in the object. Thus, the virtual machine code stored on the card 40 will already have the data incorporated within it prior to the time of execution. The virtual machine code, with the constant pool 18 removed, reduces some of the indirection inherent in a   program which uses a constant pool. The amount of memory required to store the bytecodes on the smart card 40 can, therefore, be reduced, and the execution time for the program also can be reduced. Of course, in other implementations, the installation tool 46 may retain the constant pool 18 when the CAP file 16 is downloaded to the smart card 40.<br>
As previously mentioned, the instruction set for the Java Card Virtual Machine also -   includes composite instructions for performing operations on the current object. In other words, some of the instructions that are executable by the Java Card Virtual Machine 49 allow multiple instructions to be collapsed into a single instruction. In particular, instructions that include a "this" operation, such as the family of "getfield_T_this" instructions and the family of "putfield_T_this" instructions, effectively concatenate multiple instructions. In general, the   "this" operation operates on the current object. For example, to fetch a field from the current object, one could use a combination of the "aloadO" instruction and a "getfield_a" instruction as shown in FIG. 10A. Alternatively, one can use the single instruction "getfield_T_this" as illustrated in FIG. 10B. Use of the latter instruction can result in a smaller and faster program<br><br>
code. As previously noted, such features are particularly advantageous in resource-constrained devices such as the smart card 40.<br>
The instruction set for the Java Card Virtual Machine also handles 16-bit arithmetic explicitly. To illustrate how 16-bit arithmetic is handled, consider a situation in which "a," "b" and "c" have been declared as "short" type variables, and the expression "c = (short) a + b;" is to be compiled. The bytecodes written in the Java class file format are shown in FIG. 11 A. As can be seen from FIG. 11 A, five opcodes are used to load the values "a" and "b," to add the values "a" and "b," to convert the resulting integer type into a short type, and to store the result. In contrast, only four opcodes are needed to obtain and store the result using the instruction set for the Java Card Virtual Machine 49 which obviates the need to convert the integer type result into a short type. Furthermore, in addition to using fewer bytecodes, the size of the stack can be reduced by as much as fifty percent because the Java Card Virtual Machine operates on 16-bit quantities rather than 32-bit quantities.<br>
An object-oriented, verifiable instruction set is, therefore, provided and allows a file with virtual machine bytecode to be stored on a computer-readable medium. Such a file can be downloaded to the resource-constrained device so that the bytecode can be executed by the resource-constrained device.<br>
Although a virtual machine 49 running on a microprocessor 48 has been described as one implementation for executing the bytecodes on the smart card 40, in alternative implementations, an application-specific integrated circuit (ASIC), or a combination of hardware and firmware can be used as a controller for executing downloaded code instead.<br>
Furthermore, although the invention can be implemented using the operation codes listed in FIGS. 4A and 4B, other operation codes and corresponding instruction sets having certain characteristics are suited for implementing the invention as well. Such characteristics include verifiability, type safety, pointer safety, object-oriented, dynamically linked, virtual lachine-based, platform-independence, and use of the same semantics as the Java language, Ithough not all of those characteristics need to be present in a particular implementation.<br>
As previously discussed, the Java Card instruction set can be used with a variety of ifferent resource-constrained devices, some of which are listed in FIG. 12.<br>
Other implementations are within the scope of the following claims.<br><br>
WE CLAIM:<br>
A resource-constrained device comprising:<br>
a memory(54) for storing an application software program comprising an<br>
object-oriented, verifiable, type-safe and pointer-safe sequence of<br>
instructions, the instructions comprising operation codes and operands,<br>
the instructions previously converted from at least one class file, the<br>
conversion transforming at least one reference to a constant pool to inline<br>
data in the instructions;<br>
a random access memory (50) having a capacity of no more than about 64<br>
kilo-bytes; and<br>
a virtual machine (49) implemented on a microprocessor (48) coupled to<br>
said memory and to said random access memory wherein the virtual<br>
machine is adapted to execute the sequence of instructions.<br>
The device as claimed in claim 1 wherein the microprocessor is based on an 8-bit architecture.<br>
The device as claimed in claim 1 wherein the microprocessor is based on a 16-bit architecture.<br>
The device as claimed in claim 1 wherein each instruction includes an 8-bit operation code.<br>
The device as claimed in claim 1 wherein the sequence of instructions is<br><br>
hardware platform independent.<br>
The device as claimed in claim 1 wherein the instructions were converted<br>
from at least one Java class file and wherein at least some references to a<br>
constant pool, are transformed to inline data.<br>
i<br>
7.	The device as claimed in claim 6 wherein the instructions comprise<br>
operation codes and operands and wherein at least same references to the<br>
constant pool are inlined into operands in at least some of the instructions.<br>
8.	The device as claimed in claim 6 wherein the instructions comprise<br>
operation codes and operands and wherein at least some references to the<br>
constant pool are inlined into operation codes in at least some of the<br>
instructions.<br>
9.	The device as claimed in claim 1 wherein the virtual machine supports<br>
multiple data types, wherein the sequence of instructions includes data<br>
manipulation instructions, and wherein each data manipulation instruction<br>
is specific to a particular data type.<br>
10.	The device as claimed in claim 28 wherein the program includes at least one<br>
composite instruction for performing an operation on a current object.<br>
11.   A resource-constrained device comprising:<br>
a memory for storing an application software program comprising an object-<br><br>
oriented, verifiable, type-safe and pointer-safe sequence of instructions, the instructions Comprising operation codes and operands, the instructions previously converted from at least one class file, the conversion<br>
transforming at least one reference to a constant pool to inline data in the<br>
instructions; and a virtual machine implemented on a microprocessor coupled to said<br>
memory that is based on an architecture of less than 32 bits, wherein the virtual machine is adapted to execute the sequence of instructions.<br>
A resource-constrained device comprising:<br>
a memory for storing an application software program comprising an object-oriented, verifiable, type-safe and pointer-safe sequence of instructions, the instructions comprising operation codes and operands, the instructions previously converted from at least one class file, the conversion transforming at least one reference to a constant pool   to inline data in the instructions; a random access memory having a capacity of no mare than about 64 kilo¬bytes; and<br>
a processor coupled to said memory and to said random access memory and adapted to execute the sequence of instructions.<br>
The resource-constrained device as claimed in Claim 1 wherein said virtual machine implemented on a processor comprises an application-specific integrated circuit (ASIC)<br><br>
The resource constrained device as claimed in Claim 28 wherein said resource<br><br>
constrained device is a smart card.<br>
Dated this  01st day of  August,  2001.<br>
(RANJNA MEHTA-DUTT)<br>
OF REMFRY &amp; SAGAR<br>
ATTORNEY FOR APPLICANTS<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWNsYWltcyhncmFudGVkKS0oMTktMDctMjAwNSkuZG9j" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-claims(granted)-(19-07-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWNsYWltcyhncmFudGVkKS0oMTktMDctMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-claims(granted)-(19-07-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWNvcnJlc3BvbmRlbmNlKDIyLTAzLTIwMDYpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-correspondence(22-03-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWNvcnJlc3BvbmRlbmNlKGlwbyktKDEzLTAzLTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-correspondence(ipo)-(13-03-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWRyYXdpbmcoMTktMDctMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-drawing(19-07-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWZvcm0gMSgwMS0wOC0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-form 1(01-08-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWZvcm0gMTkoMjctMDQtMjAwNCkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-form 19(27-04-2004).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWZvcm0gMWEoMTktMDctMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-form 1a(19-07-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWZvcm0gMihncmFudGVkKS0oMTktMDctMjAwNSkuZG9j" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-form 2(granted)-(19-07-2005).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWZvcm0gMihncmFudGVkKS0oMTktMDctMjAwNSkucGRm" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-form 2(granted)-(19-07-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWZvcm0gMygxOS0wNy0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-form 3(19-07-2005).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWZvcm0gMygzMS0wNy0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-form 3(31-07-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWZvcm0gNSgwMS0wOC0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-form 5(01-08-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLWZvcm0tcGN0LWlwZWEtNDA5KDAxLTA4LTIwMDEpLnBkZg==" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-form-pct-ipea-409(01-08-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLXBvd2VyIG9mIGF1dGhvcml0eSgwNS0xMC0yMDAxKS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-power of authority(05-10-2001).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=aW4tcGN0LTIwMDEtMDA5MjMtbXVtLXBvd2VyIG9mIGF1dGhvcml0eSgxOS0wNy0yMDA1KS5wZGY=" target="_blank" style="word-wrap:break-word;">in-pct-2001-00923-mum-power of authority(19-07-2005).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="205033-a-process-for-preparing-a-comb-copolymer.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="205035-wedge-clamp-type-termination-for-elevator-tension-member.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>205034</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>IN/PCT/2001/00923/MUM</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>25/2007</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>22-Jun-2007</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>13-Mar-2007</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>01-Aug-2001</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>SUN MICROSYSTEMS, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>901 SAN ANTONIO ROAD, M/S PALO1-521, PALO ALTO, CALIFORNIA 94303, UNITED STATES OF AMERIACA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>JUDITH E. SCHWABE</td>
											<td>1600 EAST THIRD AVENUE, #2708, SAN MATEO, CALIFORNIA 94401, USA</td>
										</tr>
										<tr>
											<td>2</td>
											<td>JOSHUA B. SUSSER</td>
											<td>216 DORLAND STREET, SAN FRANCISCO, CALIFORNIA 94114, USA</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G 06 F 9/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US00/02711</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2000-02-02</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09 / 243,101</td>
									<td>1999-02-02</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/205034-object-oriented-instruction-set-for-resource-constrained-devices by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 08:04:08 GMT -->
</html>
