<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/252226-receivers-and-methods-for-reduced-complexity-ldpc-decoding by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:29:10 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 252226:RECEIVERS AND METHODS FOR REDUCED COMPLEXITY LDPC DECODING</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">RECEIVERS AND METHODS FOR REDUCED COMPLEXITY LDPC DECODING</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Systems and methods for generating check node updates in the decoding of low-density parity-check (LDPC) codes use new approximations in order to reduce the complexity of implementing a LDPC decoder, while maintaining accuracy. The new approximations approximate the standard float-point sum-product algorithm (SPA), and can reduce the approximation error of min-sum algorithm (MSA) and have almost the same performance under 5 bits fix-point realization as the float-point sum-product algorithm (SPA).</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT, 1970 (39 of 1970)<br>
&amp; <br>
THE PATENTS RULES, 2003<br>
COMPLETE SPECIFICATION<br>
[See section 10, Rule 13]<br>
SYSTEMS AND METHODS FOR REDUCED COMPLEXITY LDPC DECODING;<br>
VIA TELECOM , INC., A CORPORATION ORGANIZED AND EXISTING UNDER THE LAWS OF UNITED STATES OF AMERICA, WHOSE ADDRESS IS 3390 CARMEL MOUNTAIN ROAD, SAN DIEGO, CA 92121, U.S.A..<br>
THE	FOLLOWING	SPECIFICATION<br>
PARTICULARLY	DESCRIBES	THE<br>
INVENTION AND THE MANNER IN WHICH IT IS TO BE PERFORMED.<br><br>
RELATED APPLICATION INFORMATION <br>
This application claims priority under 35 U.S.C. §119(e) to U.S. Provisional Patent Application Ser. No. 60/827,353, filed September 28, 2006, entitled "Reduced-Complexity Algorithm for Decoding LDPC Codes' which is incorporated herein by reference in its entirety as if set forth in full.<br>
BACKGROUND<br>
1.	Field of the Invention<br>
The embodiments described herein are related to methods for Low-Density Parity-Check decoding and more particularly to methods for achieving reduced complexity Low-Density Parity-Check decoders.<br>
2.	Background of the Invention<br>
A Low-Density Parity-Check (LDPC) code is an error correcting code that provides a method for transferring a message over a noisy transmission channel. While LDPC techniques cannot guaranty perfect transmission, the probability of lost information can be made very small. In fact, LDPC codes were the first to allow data transmission rates at close to the theoretical maximum, e.g., the Shannon Limit. LDPC techniques use a sparse parity-check matrix, e.g., a matrix populated mostly with zeros, hence the term low-density. The sparse matrix is randomly generated subject to the defined sparsity constraint.<br><br><br>
LDPC codes can be defined as both a matrix and in graphical form. An LDPC matrix will have a certain number of rows (M) and columns (N). The matrix can also be defined by the number of l's in each row (wr) and the number of l's in each column (wc). For a matrix to be considered low-density the following conditions should be met: wc N and wr« M. An LDPC matrix can be regular or irregular. A regular LDPC matrix, is one in which wc is constant for every column and wr= wc * (N/M) is also constant for every row. If the matrix is low-density but the number of 1 's in each row or column is not constant, then such codes are called irregular LDPC code.<br>
It will also be understood that an LDPC code can be graphically defined by its corresponding Tanner graph. Not only do such graphs provide a complete representation of the code, they also help to describe the decoding algorithm as explained in more detail below. A Tanner graph comprises nodes and edges. The nodes are separated into two distinctive sets, or types, and the edges connect the two different types of nodes. The two types of nodes in a Tanner graph are called the variable nodes (v-nodes) and check nodes (c-nodes), or parity check nodes. Thus, the Tanner graph will consist of M check nodes (the number of parity bits) and N variable nodes (the number of bits in a code word). A check node will then be connected to a variable node if there is a 1 in the corresponding element of the LDPC matrix.<br>
The number of information bits can be represented as (K). A Generator Matrix (GKXN) can then be defined according to the following:<br>
CNXI =GNxKdicxi, where<br>
dKx1= a message or data word, and<br><br><br>
CNXI - a code word.<br>
As can be seen, the code word cNx1 is generated by multiplying the message by the generator matrix. The subscripts are matrix notation and refer to the number of rows and columns respectfully. Thus, the data word and code word can be represented as single column matrices with K and N rows respectfully.<br>
The parity check Matrix can be defined as HMXNCNXI = 0.<br>
Accordingly, figure 1 is a diagram illustrating a system 100 that includes a transmitter and a receiver. A portion 102 of the transmitter and a portion 110 of the receiver are shown for simplicity. Referring to figure 1, an encoder 104 converts a data word dicxi into a code word CNXI via application of the generator matrix GKXN- Modulator 106 can be configured to then modulate the code word CNXI onto a carrier so that the code word can be wirelessly transmitted across channel 108 to the receiver.<br>
In receive portion 110, demodulator 112 can be configured to remove the carrier from the received signal; however, channel 108 will add channel effects and noise, such the signal produced by demodulator 112 can have the form:  <br>
 WNX1, where r is a multilevel signal. As a result of the noise and channel effects, some of data bits d will be lost in the transmission. In order to recover as much of the data as possible, decoder 114 can be configured to use the parity check matrix HMXN to produce an estimate d'Kx1 of the data that is very close to the original data dKx1. It will be understood that decoder 114 can be a hard decision decoder or a soft decision decoder. Soft decision decoders are more accurate, but also typically require more resources.<br><br><br>
In order to illustrate the operation of LDPC codes, the following example is<br>
presented:<br><br><br><br><br>
As can be seen, the example parity check matrix H is low density, or sparse. The first row of matrix H defines the first parity check node, or equation. As can be seen, the first parity check node will check received samples ro, r2, and r4, remembering that r is the multilevel signal produced by demodulator 112 in the receiver. The second parity check node, i.e., the second row of H, checks for received samples n, r3, and rs, and the third parity check node checks samples ro, n, and r5. In this example, there are three parity check nodes and six samples. The first and second parity check nodes are considered orthogonal, because they involve mutually exclusive sets of samples.<br>
If it is assumed that K = 3 and M =3, then the following is true:<br><br><br><br><br><br><br><br>
This produces the following equations:<br><br><br><br><br><br><br>
Thus, for example, if d = [0;1;0], then p = [0;0;1] and c = [0;1;0;0;0;1].<br>
Figure 2 is a Tanner Graph illustrating the operation of H in the example above. As can be seen, the graph of figure 2 has three parity check nodes 202, 204, and 206, and 6 variable nodes 208, 210, 212, 214, 216, and 218, which correspond to the bits of c. Parity check nodes 202, 204, and 206 are connected with variable nodes 208, 210, 212, 214, 216, and 218, via edges 220, 222, 224, 226, 228, 230, 232, 234, and 236 as dictated by the entries in H. In other words, each edge 220, 222, 224, 226, 228, 230, 232, 234, and 236 should correspond to a 1 in H.<br>
In an LDPC decoder, the operations of the parity check and variable nodes can be implemented by processors. In other words, each parity check node can be implemented by a parity check processor, and each variable check node can be implemented by a variable node processor. An LDPC decoder is then an iterative decoder that implements a message passing algorithm defined by H.<br>
Unfortunately, conventional LDPC decoding techniques result in a high complexity, fully parallel decoder implementations where all the messages to and from all<br><br><br>
the check, node processors have to be computed at every iteration in the decoding process. This leads to large complexity, increased resource requirements, and increased cost.<br>
Hence, there are many current efforts devoted to reducing the complexity of check node message updating, while keeping the performance loss as small as possible. The most common simplification is the min-sum algorithm (MSA), which has greatly reduced the complexity of check node updates, but incurs a 0.3-0.4 dB degradation in performance relative to standard sum-product algorithm (SPA) check node implementations. To combat this performance degradation, modifications of the MSA using a normalization term and an offset adjustment term have also been proposed. Such solutions do have reduced performance loss compared with the more conventional MSA implementations, but there is still significant performance loss. In addition, two-dimensional MSA schemes have been proposed that can further improve the performance of MSA with some additional complexity. Thus, in conventional implementations, there is a constant trade-off between complexity and performance.<br>
SUMMARY <br>
Systems and methods for generating check node updates in the decoding of low-density parity-check (LDPC) codes are described below. The systems and methods described below use new approximations in order to reduce the complexity of implementing a LDPC decoder, while maintaining accuracy. The new approximations approximate the standard sum-product algorithm (SPA), and can reduce the approximation<br><br><br>
error of min-sum algorithm (MSA) and has almost the same performance as sum-product algorithm (SPA) under both floating precision operation and fixed-point operation.<br>
In one aspect, a receiver can include a demodulator configured to receive a wireless signal, remove a carrier signal from the wireless signal and produce a received signal, and a Low Density Parity Check (LDPC) processor configured to recover an original data signal from the received signal. The LDPC processor can include a plurality of variable node processors configured to receive the received signal and generate variable messages based on the received signal, and a parity node processor configured to receive the variable messages and generate soft outputs based in the variable messages<br>
In another aspect, a receiver comprises a demodulator configured to receive a wireless signal comprising an original data signal and a carrier signal, remove the carrier signal from the wireless signal, and produce a received signal, and a Low Density Parity Check (LDPC) processor coupled with the demodulator, the LDPC processor configured to recover the original data signal from the received signal. The LDPC processor comprises a plurality of variable node processors configured to generate variable messages based on the received signal, and a check node processor coupled with the plurality of variable node processors, the check node processor configured to implement an approximation of a sum product algorithm (SPA) using base 2 logarithm operations.<br>
In still another aspect, the check node processor is configured to implement an approximation of a sum product algorithm (SPA) using base 2 logarithms and rounding all operand and results to the nearest integer.<br><br>
In still another aspect, the check node processor comprises binary hardware circuits.<br>
In  still  another  aspect,  the   integers  produced  are   limited  to  within<br><br><br>
In still another aspect, the check node processor comprises v fixed point circuits including 1 bit for the signs of the integers and v-1 bots for the absolute value.<br>
These and other features, aspects, and embodiments of the invention are described below in the section entitled "Detailed Description."<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
Features, aspects, and embodiments of the inventions are described in conjunction with the attached drawings, in which:<br>
Figure 1 is a diagram illustrating an example communication system that uses LDPC codes;<br>
Figure 2 is a diagram illustrating the operation of an exemplary parity check matrix;<br>
Figure 3 is a diagram illustrating an exemplary parity node processor;<br>
Figure 4 is a diagram illustrating the operation of an exemplary parity node processor;<br>
Figure 5 is a diagram illustrating the operation of an exemplary variable node processor;<br><br><br>
Figure 6 is a graph illustrating the simulated frame error rate (FER) performance under AWGN channel for float-point SPA float-point MSA and our proposed method with different quantization bits.<br>
Figure 7 is a graph illustrating the simulated frame error rate (FER) performance under AWGN channel for float-point SPA float-point MSA and our proposed method with different quantization bits.<br>
Figure 8 is a flow chart illustrating an example method of for performing a modified LDPC decoding.<br>
DETAILED DESCRIPTION<br>
In the descriptions that follow, certain example parameters, values, etc., are used; however, it will be understood that the embodiments described herein are not necessarily limited by these examples. Accordingly, these examples should not be seen as limiting the embodiments in any way. Further, the embodiments of an LDPC decoder described herein can be applied to many differnet types of systems implementing a variety of protocols and communication techniques, such as Bi-Phase Shift Keying (BPAK) modulation techniques, Quadrature Phase Shift Keying (QPSK) modulation techniques, or Quadrature Amplitude Modulation (QAM) techniques. Accordingly, the embodiments should not be seen as limited to a specific type of system, architecture, protocol, air interface, etc. unless specified.<br>
A check node processor 302 of degree n is shown in figure 3. At each iteration, the outgoing soft messages {li = I, 2, ...n} are updated with the incoming soft<br><br><br>
messages {ui,i = 1,2,...n}. The outgoing soft message is defined as the logarithm of the ratio of probability that the corresponding bit is 0 or 1.<br>
With the standard sum-product algorithm, the outgoing message is determined as follows:<br>
 	(1)<br><br>
The outgoing soft messages are then  fed  back to the variable node<br>
processors for use in generating outputs u1 during the next iteration; however, a soft<br>
message Abased on a variable node output from a particular node are not returned to that<br><br>
node. Thus,thej * i constraint in the following term of (1):  <br><br>
This can also be illustrated with the aide of figure 4, which is a diagram illustrating the operation of parity node processor 202. First, the LDPC decoder will initialize the variable data bits uo, u1, U2 . . . u6 of variable node processors 208, 210, 212, 214, 216, and 218 with ro, n, r2, . . . r6.  Referring to figure 4,                                     are the<br>
variable messages sent from variable nodes 208, 212, and 216 to parity node processor 202. Parity node processor 202 operates on these messages and computes its messages Xk. For example, lk (0 —&gt; 2) represents the message sent from parity node 202 to variable node 212 at the kth iteration.<br><br><br>
The messages produced by parity node processor 202 can be defined using the following equations:<br><br><br><br><br><br><br>
Thus parity node processor 202 can be configured to implement the above equations (2). The soft messages produced by the parity nodes, e.g., parity node 202, are then fed back to variable nodes 208, 210, 212, 214, 216, and 218, for use in the next iteration.<br>
For example, figure 5 is a diagram illustrating the operation of variable node processor 208. Referring to figure 5, variable node processor 208 receives as inputs messages from parity node processors 202 and 206 and produces variable messages to be sent back to the same parity node processors 202 and 206. In the example of figure 4 and figure 5, hard decisions are taken on the multilevel variable ukn and checked to see if they<br>
meet the parity node equations defined above.  If there is a match, or if a certain defined number of iterations is surpassed, then the decoder can be stopped.<br>
Variable node processor 208 can be configured to implement the following equation:<br><br>
 	(3)<br>
where uch,o is the message from the channel, which does not change with each iteration<br>
It will be understood that the decoder described above can be implemented using hardware and/or software configured appropriately and that while separate parity check processors and variable node processors are described, these processors can be implemented by a single processor, such as a digital signal processor, or circuit, such as an Application Specific Integrated Circuit (ASIC); however, as mentioned above, implementation of a LDPC processor such as that described with respect to figures 2-5 can result in large complexity, stringent memory requirements, and interconnect complexity that can lead to bottlenecks. These issues can be exacerbated if multiple data rates are to be implemented. In other words, practical implementation if such a decoder can be limited.<br>
Accordingly, using the systems and method described above, the resources, i.e., complexity, required to implement a parity node can be reduced, while still maintaining a high degree of precision. In certain embodiments, the complexity can be reduced even further through degree reduction techniques. In other words, the number of inputs to the parity node can be reduced, which can reduce the resources required to implement the parity node. It should also be noted that in many parity node implementations, the sign and the absolute value of the outgoing soft message are calculated separately.<br><br><br>
Thus, a LDPC code with parity check matrix H of size MxN has M check nodes and N variable nodes. In the decoder, soft messages are propagated and updated iteratively between variable nodes and check nodes until they agree at a valid codeword. Otherwise, the decoding will terminated with failure. The updating algorithm at a variable node involves two kinds of input messages, the message from channel observation and the message from check nodes.<br>
The   soft   message   is   defined   as  the   logarithm   ratio   of probability:<br><br><br><br><br><br><br>
  where m refers to the w-th variable node, i.e. the w-th bit in the codeword.<br>
L(m)  is the soft message from channel observation, p0[m) is the a<br>
posterior probability that the bit is 0 conditioned on the channel observation y(m).<br>
C(m) in (5) is the set of check nodes connected to the m-th variable node. p'c. (m) is the probability estimated by check node / in C(m) that the m-th bit is 0.<br>
For BPSK modulation and AWGN channel with unit gain and noise variance u1, L(m) becomes:<br><br><br>
The variable node send message ut {m) to check node /. ul (m) is defined in the same way as in (4):<br><br><br>
Where p] {m) is the probability estimated by variable node that the m-th bit is 0.<br>
The updating algorithm at a variable nodes can be described as:<br><br><br>
Where C(m)\i denotes the subset of C(m) with /' excluded.<br>
The outgoing message from a check node to a variable node is a function of all incoming messages from all variable nodes connected to this check node except the one that the message will be send to, i.e.:<br><br>
 where V(j) is the set of the variable nodes connected to the j-th check node.<br>
The standard updating algorithm for / in (9) is the sum-product algorithm(SPA) described above and presented again here:<br><br><br><br><br><br><br><br>
The right hand of (11) stands for \V(j) -1 successive ©operations, which is a binary operator defined as:<br><br>
 	(12)<br><br>
for x,y real numbers. It can be shown that the ©operator is commutative and associative.<br>
The variable node updating algorithm (8) only involves summations. Thus most of the decoding complexity comes from the check nodes which need large amount of the evaluation of logarithms and exponentials. A simplified version for SPA is min-sum algorithm (MSA) which uses a simple approximation to evaluate the © operation:<br>
 	(13)<br>
Though MSA is simple enough to be efficiently implemented with hardware, it has some performance loss compared with SPA. The amount of loss depends on the specific code structure and code rate, generally on the order of 0.3~0.4dB. Many more improvements have been published in the literature with better performance, even lossless compared with SPA.<br>
Certain embodiments described herein modify SPA by replacing the base e logarithm In in equations (3),(4) and (7) with base 2 logarithm log2, then (6) will become:<br><br><br><br>
and (12) becomes:<br><br><br><br><br><br><br>
All operands and results involved in the decoding algorithm described herein can be rounded to the nearest integers. Equations (14) and (15) then become:<br><br><br><br><br><br>
Where Round( ) denotes rounding the operand to the nearest integer.<br>
The right hand of (16) and (17) are approximations due to the round off error, which is smaller than 0.5.<br>
Note that with (16), (8) and (17), the whole decoding algorithm only use integer operations. In particular, the integer power of 2 and the integer logarithm in (17) can be easily implemented with binary hardware circuits. Thus, the complexity of standard SPA implementations can be greatly reduced. Simulation results are produced below to show that the performance loss is within 0.1 dB.<br>
Further, it can be shown that (17) is exactly equivalent to the following:<br><br>
where<br><br><br><br><br>
Compare (18) and (19) with the MSA in (13), and it can be seen that the complexity is only slightly increased. It should be noted that in hardware implementations, decreasing by 1 is less complex than normal subtraction and testing of £ 1 and &gt; 1 only requires some bit testing logic.<br>
If all  the  integers   involved   in  the  algorithm  are   limited  to  within<br>
                              , then the algorithm can be directly implemented with v bits fix point<br>
circuits where 1 bit for signs and v-1 bits for the absolute value. Except that (19) should be modified to:<br><br><br><br>
This is because when one input is Amax, the real value may range in [Amax,+0°], thus the real value for [a-b]is highly likely to be greater than one.<br>
Accordingly, using the systems and method described above, the resources, i.e., complexity, required to implement a check node can be reduced, while still maintaining a high degree of precision. In certain embodiments, the complexity can be reduced even further through degree reduction techniques. In other words, the number of inputs to the check node can be reduced, which can reduce the resources required to implement the check node. It should also be noted that in many check node implementations, the sign and the absolute value of the outgoing soft message are calculated separately.<br><br><br>
Figure 6 and figure 7 are graphs illustrating respectively the simulated frame error rate (FER) and bit error rate (BER) performance under AWGN channel for float-point SPA, float-point MSA and the method described herein with different quantization bits. The LDPC code is the irregular (1152, 576) 1/2-rate LDPC codes constructed according to 802.16eD12. The decoder use layered decoding with maximum iteration number as 30. The curves labeled as 'SPA2' refers to the proposed algorithm where all the operations are integer operation. The curve labeled as 'SPA2 unlimited' refers to the case where                     In computer simulation, this is in fact limited by the<br>
largest integer of the system. This curve reflects the impacts of round error in (17) and (18). It can be shown that the performance loss caused by round off error is less than 0.1 dB and limiting the integer to 5bits (Ama}i =15) will cause almost no further loss.<br>
It should be noted that we are comparing with the float-point SPA and float-point MSA are being compared. These two algorithms require about 8bits to keep the same performance if they are directly implemented with fixed-point circuits.<br>
Figure 8 is a flow chart illustrating an example method for performing LDPC decoding as described above. First, in step 802, a signal can be received. In step 804, the signal can be demodulated. In step 806, the variable messages can be generated from the demodulated signal as an estimate of the data bits. In step 808, an operation can be performed on the variable messages to approximate the value of the original signal. This approximation is based a sum product algorithm (SPA) using base 2 logarithm operations and rounding the resulting values, as described above. This approximation can be performed in accordance with equations 16 and 17.  In step 810, the result of step 808<br><br><br>
can be evaluated to determine if the variable message matches the parity node equations. If there is a match or if a certain number of iterations is surpassed then the LDPC decoder can stop.<br>
While certain embodiments of the inventions have been described above, it will be understood that the embodiments described are by way of example only. Accordingly, the inventions should not be limited based on the described embodiments. Rather, the scope of the inventions described herein should only be limited in light of the claims that follow when taken in conjunction with the above description and accompanying drawings.<br><br><br>
WE  CLAIM<br>
1.	A receiver, comprising:<br>
a demodulator configured to receive a wireless signal comprising an original data signal and a carrier signal, remove the carrier signal from the wireless signal, and produce a received signal; and<br>
a Low Density Parity Check (LDPC) processor coupled with the demodulator, the LDPC processor configured to recover the original data signal from the received signal, the LDPC processor comprising:<br>
a plurality of variable node processors configured to generate variable messages based on the received signal, and<br>
a check node processor coupled with the plurality of variable node processors, the check node processor configured to implement an approximation of a sum product algorithm (SPA) using base 2 logarithm operations.<br>
2.	The receiver of claim 1, wherein the check node processor is further configured to implement an approximation of a sum product algorithm (SPA) using base 2 logarithms and rounding all operand and results to the nearest integer.<br>
3.	The receiver of claim 1, wherein the check node processor is further configured to implement an approximation of a sum product algorithm (SPA) which is equivalent to<br><br><br><br><br><br>
4.	The receiver of claim 1, wherein the check node processor comprises binary hardware circuits.<br>
5.	The receiver of claim 2, wherein the integers produced are limited to within  <br>
6.	The receiver of claim 5, wherein the check node processor comprises v fixed point circuits including 1 bit for the signs of the integers and v-1 bits for the absolute value.<br>
7.	The receiver of claim 1, wherein the LDPC processor is implemented in a single processor.<br>
8.	The receiver of claim 1, wherein the received signal is modulated using any combination of the following techniques:<br>
Bi-Phase Shift Keying (PBSK);<br>
Quadrature Phase Shift Keying (QPSK); and<br>
Quadrature Amplitude Modulation (QAM).<br><br><br>
9.	A Low Density Parity Check (LDPC) processor, comprising:<br>
a plurality of variable node processors configured to generate<br>
variable messages based on the received signal, and<br>
a check node processor coupled with the plurality of variable node processors, the check node processor configured to implement an approximation of a sum product algorithm (SPA) using base 2 logarithm operations.<br>
10.	The LDPC processor of claim 9, wherein the check node processor is further configured to implement an approximation of a sum product algorithm (SPA) using base 2 logarithms and rounding all operand and results to the nearest integer.<br>
11.	The LDPC processor of claim9, wherein the check node processor is further configured to implement an approximation of a sum product algorithm (SPA) which is equivalent to<br><br><br><br><br><br>
12.	The LDPC processor of claim 9, wherein the check node processor comprises binary hardware circuits.<br>
13.	The LDPC processor of claim 11, wherein the integers produced are limited to within ±Amax <br>
14.	The receiver of claim 13, wherein the check node processor comprises v fixed point circuits including 1 bit for the signs of the integers and v-1 bots for the absolute value.<br>
15.	A method for processing a received signal using a parity node processor included in a LDPC decoder, the method comprising:<br>
receiving a signal;<br>
demodulating the signal;<br>
generating a variable message; and<br>
generating a soft output based on the variable message using an approximation of a sum product algorithm (SPA) using base 2 logarithm operations.<br>
16.	The method of claim 15, further comprising refining the soft<br>
output variable message iteratively until either the soft output variable<br>
message matches a parity node equation or a maximum number of iterations<br>
has occurred.<br><br><br>
17.	The method of claim 15, wherein the soft output is further generated by rounding all operand and results to the nearest integer.<br>
18.	The method of claim 15, wherein the soft output generated is equivalent to<br><br><br><br><br><br>
19.	The method of claim 15, wherein the integers produced are limited to<br>
within  <br>
20. The method of claim 15, wherein the signal is modulated using any combination of the following techniques:<br>
Bi-Phase Shift Keying (PBSK);<br>
Quadrature Phase Shift Keying (QPSK); and<br>
Quadrature Amplitude Modulation (QAM).<br><br><br><br><br><br>
ABSTRACT<br>
Systems and methods for generating check node updates in the decoding of low-density parity-check (LDPC) codes use new approximations in order to reduce the complexity of implementing a LDPC decoder, while maintaining accuracy. The new approximations approximate the standard float-point sum-product algorithm (SPA), and can reduce the approximation error of min-sum algorithm (MSA) and have almost the same performance under 5 bits fix-point realization as the float-point sum-product algorithm (SPA).<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1hYnN0cmFjdC5kb2M=" target="_blank" style="word-wrap:break-word;">1913-mum-2007-abstract.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1hYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">1913-mum-2007-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1NVU0tMjAwNy1DTEFJTVMoQU1FTkRFRCktKDI2LTMtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">1913-MUM-2007-CLAIMS(AMENDED)-(26-3-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1NVU0tMjAwNy1DTEFJTVMoTUFSS0VEIENPUFkpLSgyNi0zLTIwMTIpLnBkZg==" target="_blank" style="word-wrap:break-word;">1913-MUM-2007-CLAIMS(MARKED COPY)-(26-3-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1jbGFpbXMuZG9j" target="_blank" style="word-wrap:break-word;">1913-mum-2007-claims.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1jbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">1913-mum-2007-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1jb3JyZXNwb25kZW5jZSgxNi0xLTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">1913-mum-2007-correspondence(16-1-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1jb3JyZXNwb25kZW5jZS1yZWNlaXZlZC5wZGY=" target="_blank" style="word-wrap:break-word;">1913-mum-2007-correspondence-received.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1kZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">1913-mum-2007-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1kcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">1913-mum-2007-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1mb3JtIDEoMjEtMTEtMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">1913-mum-2007-form 1(21-11-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1NVU0tMjAwNy1GT1JNIDEoMjYtMy0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">1913-MUM-2007-FORM 1(26-3-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1mb3JtIDE4KDEzLTEyLTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">1913-mum-2007-form 18(13-12-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1NVU0tMjAwNy1GT1JNIDIoVElUTEUgUEFHRSktKDI2LTMtMjAxMikucGRm" target="_blank" style="word-wrap:break-word;">1913-MUM-2007-FORM 2(TITLE PAGE)-(26-3-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1mb3JtIDIodGl0bGUgcGFnZSktKDI3LTktMjAwNykucGRm" target="_blank" style="word-wrap:break-word;">1913-mum-2007-form 2(title page)-(27-9-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1NVU0tMjAwNy1GT1JNIDMoMTItOS0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">1913-MUM-2007-FORM 3(12-9-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1mb3JtIDMoMTYtMS0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">1913-mum-2007-form 3(16-1-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1mb3JtLTEucGRm" target="_blank" style="word-wrap:break-word;">1913-mum-2007-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1mb3JtLTIuZG9j" target="_blank" style="word-wrap:break-word;">1913-mum-2007-form-2.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1mb3JtLTIucGRm" target="_blank" style="word-wrap:break-word;">1913-mum-2007-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1mb3JtLTMucGRm" target="_blank" style="word-wrap:break-word;">1913-mum-2007-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1mb3JtLTUucGRm" target="_blank" style="word-wrap:break-word;">1913-mum-2007-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1mb3JtLTkucGRm" target="_blank" style="word-wrap:break-word;">1913-mum-2007-form-9.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1NVU0tMjAwNy1QRVRJVElPTiBVTkRFUiBSVUxFIDEzNygxMi05LTIwMTEpLnBkZg==" target="_blank" style="word-wrap:break-word;">1913-MUM-2007-PETITION UNDER RULE 137(12-9-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1tdW0tMjAwNy1wb3dlciBvZiBhdHRvcm5leSgyMi0xMS0yMDA3KS5wZGY=" target="_blank" style="word-wrap:break-word;">1913-mum-2007-power of attorney(22-11-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1NVU0tMjAwNy1SRVBMWSBUTyBFWEFNSU5BVElPTiBSRVBPUlQoMTItOS0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">1913-MUM-2007-REPLY TO EXAMINATION REPORT(12-9-2011).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1NVU0tMjAwNy1SRVBMWSBUTyBFWEFNSU5BVElPTiBSRVBPUlQoMjYtMy0yMDEyKS5wZGY=" target="_blank" style="word-wrap:break-word;">1913-MUM-2007-REPLY TO EXAMINATION REPORT(26-3-2012).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTkxMy1NVU0tMjAwNy1VUyBQQVRFTlQgRE9DVU1FTlQoMTItOS0yMDExKS5wZGY=" target="_blank" style="word-wrap:break-word;">1913-MUM-2007-US PATENT DOCUMENT(12-9-2011).pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="252225-processes-for-the-production-of-xylitol.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="252227-wide-angle-position-transmitter-for-large-linear-movement.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>252226</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1913/MUM/2007</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>18/2012</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>04-May-2012</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>02-May-2012</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>27-Sep-2007</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>VIA TELECOM, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>3390 CARMEL MOUNTAIN ROAD, SAN DIEGO, CA 92121,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>GUOHUI SUN</td>
											<td>ROOM 1807, NO.29 BUILDING, BEIJING UNIVERSITY OF POSTS AND TELECOMMUNICATIONS, BEIJING, 100876</td>
										</tr>
										<tr>
											<td>2</td>
											<td>HONGWEN YANG</td>
											<td>65-701, YUXIN, HAIDIAN DISTRICT, BEIJING 100876,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H03M13/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/827,353</td>
									<td>2006-09-28</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/252226-receivers-and-methods-for-reduced-complexity-ldpc-decoding by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 13:29:11 GMT -->
</html>
