<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/200830-a-method-for-determining-a-minimal-set-of-components-necessary-for-an-object-oriented-application-being-created-to-execute by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:02:11 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 200830:A METHOD FOR DETERMINING A MINIMAL SET OF COMPONENTS NECESSARY FOR AN OBJECT ORIENTED APPLICATION BEING CREATED TO EXECUTE</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD FOR DETERMINING A MINIMAL SET OF COMPONENTS NECESSARY FOR AN OBJECT ORIENTED APPLICATION BEING CREATED TO EXECUTE</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>ABSTRACT PACKAGING ALGORITHM FOR PROVIDING OBJECT ORIENTED APPLICATIONS HAVING REDUCED FOOTPRINTS A packaging algorithm for providing software applicatioriS having reduced footprints is presented. The algorithm determines the minimum required set of methods and classes from the development environment necessary for the application to run. The application is then packaged with only those necessary methods and classes. The resulting application has a reduced footprint which serves to reduce memory requirements needed to store the application and enhance performance of the application at run-time.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
Field of the Invention<br>
The present invention relates to improvements in data processing systems and, more particularly, to a packaging algorithm for object oriented application development software which permits object oriented applications to be packaged without including extraneous classes or methods.<br>
Description of the Related Art<br>
The use of object oriented languages for writing or developing software applications has been gaining popularity in recent years. Object oriented technology has several advantages over procedural language technology, including relative ease of use, ease of modification, superior potential for reusability of components from application to application, etc. Object oriented software applications are typically developed by a software developer using an object oriented development environment. An object oriented development environment (such as VisualAge for Smalltalk from the IBM Corporation) typically includes the object oriented language, such as Smalltalk or C++, a variety of development tools, such as<br><br><br>
browsers, version management capabilities, and debuggers, and a set of reusable object oriented classes, components, parts and/or frameworks which provide different functions which a developer may desire for an application. The Smalltalk language includes an underlying engine known as the virtual machine which includes base functionality required to execute finished applications on a computer (and is typically packaged with applications) , as well as a rich set of reusable object oriented classes, components, parts and frameworks. A developer basically pulls together instances of desired classes (objects) from the available classes, components, parts, and frameworks in order to create an application having desired function.<br>
One aspect of object oriented languages is that the classes are typically interdependent and may possess a characteristic known as inheritance. Also, function is typically provided in that portion of an object known as a method. Thus, a method for one particular object may rely on a method in a different object or class to provide function. This characteristic of object oriented languages provides challenges to packaging schemes that sesk efficiency.<br>
To date, packaging of finished applications has never been an exact science. To be on the safe side, applications are packaged with complete standard class libraries with minimal discrimination together with the underlying engine to produce a run-time version<br><br>
of the application which can be executed by the computers of end-users. One drawback in object oriented languages has been that in order to make sure the application executes properly, packagicg algorithms of the prior art have not been very discriminatory in which classes they include from the reusable class libraries in tie development environment. Accordingly, the size of packaged object oriented applications has been relatively large, thereby placing large memory requirements on the end-user's computer. Also, tae relatively large size of the applications can result in slower than desired performance when the applications are executed.<br>
Accordingly, a need exists for a packaging algorithm for use in for application development tools which more precisely selects classes from the development environment for inclusion in packaged applications, so as to reduce memory requirements and enhance performance.<br>
SUMMARY  OF  THE   INVENTION<br>
Accordingly, an object of the present invention is to provide an enhanced packaging algorithm for reducing the mencry requirements of applications.<br>
Another object of the present invention is to provide an enhanced packaging algorithm which results in enhanced performance of applications packaged using the packaging algorithm.<br><br>
Yet another object of the present invention is to provide a packaging algorithm for application development environments which includes only those methods and classes which are necessary for execution of  the application.<br>
Other objects and advantages of the present invention will be set forth in part in the description and the drawings whicii folio*, and, in part, will be obvious from the description, or may be learned by practice of  the invention.<br>
To achieve the foregoing objects, and in accordance with uie purpose of the invention as broadly described herein, compurer readable code is provided for determining a set of code from a development environment required to execute an application, comprising first subprocesses for identifying a known component required to execute the application; second subprocesses for identifying components required by the known component for execution of the application; and third subprocesses for identifying components required by the ccxr^jonents identified in the second subprocesses and the third subprocesses  for execution.<br>
The first subprocesses may permit a user to identify at least one known component, or may query a coit^wnent of the application to identify itself and uses the identified con5)onent as che known component. The application may be an object oriented application under development,   the computer readable code may further compr:.se<br><br>
fourth subprocesses for packaging the application to include only the known component and the identified components. Preferably, only a single instance of the identified components is included in the packaged application. The computer readable code may further comprise fifth subprocesses for identifying common components required to execute any application. The application may be an object oriented application comprising methods and classes, the known component being a method, wherein the second subprocesses further comprise identifying methods and classes referenced by the known method.<br>
Additionally, the present invention provides a system in a computing environment for determining a required set of components from an application development environment for an application being created, comprising means for identifying a first component required to execute the application; means for identifying a first set of components referenced by name or required by the first component for inclusion in the application; and means for identifying a second set of components referenced by name or otherwise required by individual components of the first second set of components and by individual ones of the secone set of components after the individual ones are identified for inclusion in the application; and means for creating a list of required components from the first component, the first set of components and the second set of components. The system may further comprise means for including each of the required components only ones on<br><br>
the list.<br>
Accordingly, the present invention provides a method for determining a minimal set of components necessary for an object oriented application being created to execute, comprising the steps of: (a) identifying a known component from the object oriented application and adding the identified component to a first list; (b) selecting a component firom the first list and deleting the selected component from the first list; (c) determining if the selected component is included in a required component list, and if so, repeating said selecting step for a new component; (d) if said determining step determines that the selected component is not on the required component list, adding the selected component to the required component list; (e) creating a referenced component list for components referenced by the selected component; (f) determining, relative to each of the referenced components, whether each of the referenced component is included in the required component list, and adding each of the referenced components to the first list if it is not in the required component list; and (g) repeating said steps (a) through (f) until the first list is empty.<br><br>
The present invention will now be described with reference to the following drawings, in which like reference numbers denote the same element throughout.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
Figure 1 is a block diagram of a representative hardware environment in wh^ich the present invention may be' practiced;<br>
Figure 2 is a diagram of the architecture of an object oriented application development environment;<br>
Figure 3 illustrates an object oriented object;<br>
Figure 4 is a diagram of a typical hierarchical relationship between related classes of an object oriented language; and<br>
Figure 5 is a flowchart illustrating the logical steps of the packaging algorithm of the present invention.<br>
DESCRIPTION OF THE PREFERRED EMBODIMENT<br>
The present invention as described may be performed in an of a variety of object oriented development languages,  such as<br><br>
Smalltalk,      C++,      ScriptX,      etc.	Figure      1      illustrates      a<br>
representative hardware environment in which the present invention may be practiced. The environment of Figure 1 is representative of a conventional single user of a computer workstation, such as a personal computer and related peripheral devices. The environment includes a microprocessor 10 and a bus 12 employed to connect and enable communication between the microprocessor 10 and the components of the workstation in accordance with known techniques. The workstation will typically include a user interface adapter 14, which connects the microprocessor 10 via the bus 12 to one or more interface devices, such as a keyboard 16, a mouse 18, and/or other interface devices 20, which can be any user interface device, such as a touch sensitive screen, digitized pea entry pad, etc. The bus 12 also connects a display device 22, such as an LCD screen or monitor, to the microprocessor 10 via a display adapter 24. The bus 12 also connects the microprocessor 10 to memory 26, w^hich can include ROM,  RAM,   etc.<br>
Sof tware programming code which eii5)ioys the present invention is typically stored in the memory 26 of the standalone workstation environment. In a client/server environi&amp;ent, the software program code may be stored with memory associated with the server. The software program code may be embodied on any of the variety of known media for use with a data processing system, such as a diskette or CD-ROM. The software progra-i code may be distributed on such media,   or may be distributed tc users   from the memory of<br><br>
one computer system over network of some type to other computer systems for use by users of such other systems. Such techniques and methods for embodying software code on physical media or distributing software code via networks are well-known and will not be further discussed herein.<br>
The present invention is described below in its preferred embodiment, which is as part of a Smalltalk development environment. The Smalltalk development environment may operate on any of a variety of combinations of operating systems and hardware, and will be described independent of any specific operating system and hardware. Smalltalk is a dynamic object oriented language and is referred to as a pure object oriented language since it conforms to all the basic definitions of an object oriented language, such as inheritance, polymorphism, etc. These concepts will not be discussed herein. Some other object oriented languages, such as C++, differ somewhat in architecture. However, the same packaging problem described herein is also present in most other object oriented languages, and the solution described herein is also directly applicable to those other object oriented languages.<br>
Figure 2 illustrates the basic architecture of a Smalltalk • object oriented development environment, such as VisualAge for. Smalltalk from IBM. The object oriented development environment 40 is itself an application which runs on an underlying operating system 42. The portion of the development environment 40 known as<br><br>
a virtual machine 44 interacts with the operating system 42. The Smalltalk development environment is hierarchical, and an image portion 46 of the development environment 40 continues hierarchies of classes tied into the virtual machine 44 and can be viewed as logically running on top of the virtual machine 44. The image 46 is the portion of the development environment 40 with which a developer interacts to develop an object oriented application. The image portion 46 of the development environment 40 includes a variety of classes provided in different hierarchies, which provide functions at many different levels. At a high level, an entire set of classes may comprise a framework which provides a substantially complete function desired by the developer, which a developer may pull into the application being developed. On the other hand, the function may not be provided in such a neat package as a framework by the development environment, thus requiring the developer to combine relatively low level classes or individual classes or to write new classes in order to create the desired function for the application being developed.<br>
The image 46 also includes application development tools, which differ in different environments. The tools may include a class browser for viewing classes and methods, version control systems for permitting incremental development and saving of applications under development, debuggers for debugging applications created using the development environment 40, etc. The development environment also includes a Smalltalk compiler<br><br>
which links and compiles portions of the application. Smalltalk being an interpreted language, portions of the application will remain in byte-code form, which are interpreted by the run-time engine during execution.<br>
Figure 3 is an industry standard representation of an objecc 50. Methods 52 of the object 50 provide function, while a data portion 54 includes data associated with the object 50. An objecc is an instantiation of a class from the hierarchy of classes which a developer has designated for use in an application. The saiDe class may be used many times in an application.<br>
Figure 4 illustrates a hierarchy 60 of classes 62. Object oriented hierarchies employ the concept of superclasses and subclasses. A class inherits all variables and methods from classes which are higher in the hierarchy of classes (super classes) . The inheriting class is referred to as a subclass of its super classes.<br>
In view of this architecture, prior art packaging algorithms have dealt with packaging very conservatively. Prior algorithms tend to be relatively indiscriminate as to which classes they include when packaging applications. While the approach seldon misses necessary classes, this insistence of erring on the side of safety results in applications having unwieldy size and thus having large memory requirements  and  sometimes  less  than optimal<br><br>
performance.<br>
As with the prior art, when a developer has finished developing an application in the development environment, the developer implements the packaging function within the development environment. The packaging algorithm determines which clas^Sjes are to be included with the run-time engine in the executable application. The packaging algorithm of the present invention will now be described relative to the flowchart of Figure 5.<br>
The packaging algorithm of the present invention analyzes the code in the application and its associated reusable code libraries to determine a minimum subset of the code that is required to allow the application to be executed. The algorithm is employed in the linking or packaging step, and it determines a minimum defined set of classes and/or methods required for the application to be executed. The minimum defined classes and methods are referred to as the 'required classes' and • required methods' in the description which follows. The present invention utilizes the fact that an object oriented application executes in such a manner that the instances of the classes (objects) send messages to each other. Thus, many of the required classes and methods are interrelated. The packaged application will include the required classes and methods from the development environment which span the virtual machine, image, and class libraries, as well as code from the virtual machine required to execute the application at run-time.<br><br>
The code required for execution from the virtual machine typically remain static for all Smalltalk applications.<br>
An initial "starting method' from the image portion of the application being packaged may need to be defined by the developer, depending on the implementation and language. From the starting method, the algorithm traverses all references to classes and other methods in the application and reusable class libraries to determine the set of required methods and classes.<br>
Accordingly, when a developer has finished developing an application, the developer inputs a command to the development environment to initiate packaging (Step 100) . Thereafter, the program creates a number of variables, including a Required Methods set, a Required Classes set, a Knovm Methods set, and a Check Methods dictionary. All these elements are initially en^ty (Step 104) . As the algorithm determines that methods and classes from the development environment are necessary for execution of the application, they are added to the Required Methods set and Required Classes set, respectively. The application will subsequently be packaged with only those methods and classes defined in these sets. The methods contained in the Known Methods set will be added to the Required Methods set (if not already included) and processed in accordance with the algorithm to identify classes and other methods which are also necessary and/or should be processed themselves to identify other necessary classes<br><br>
and methods. The Check Methods dictionary is employed to help identify necessary methods. Other variables will also be employsd by the algorithm,   as discussed below.<br>
A starting method or methods identified by a user or by tiie program itself in an automatic query are added to the Known Methods set (Step 106) . As discussed previously, in Smalltalk, a knoim portion of the virtual machine and image are required to execute the application code for any application. Generally, the methods and classes required to execute the run-time application are known. Accordingly, the required run-time methods are added to the Known Methods set (Step 108) and required classes for run-time execution are added to the Required Classes  set   {Step 110) .<br>
In some cases, some classes which are required by tiie application code do not exist within the application development environment itself and are not identifiable by method name. For example, such classes may exist in a persistent store which tiie application might read during execution. However, without a specific reference to the methods in the persistence store, tie algorithm will not search for such methods or classes, and thus will not identify them for packaging. Accordingly, all such necessary classes are added to the Required Classes set at tiiis time (Step 112) . Most often, the location of these classes will be provided by the application developer; however, an automatic query may be built  in to  the packaging  step wnereby  locations   for  such<br><br>
classes may be found so that such classes are automatically added to the required classes set.<br>
The algorithm initiates its search for the minimum defined set of classes and methods using the contents of the Known Methods set. When it is finally determined that the known methods set is empty in Step 114, the minimum defined set of classes and methods will have been defined, and the application can be packaged including only the methods and classes from the Required Methods set and the Required Classes set (Step 116) . However, initially, as the Known Methods set has been seeded with starting methods either by the user or automatically in Step 106, the Known Methods set will not be empty, and processing will proceed to Step 118. In Step 118, a method is selected from the methods in the Known Methods set and deleted therefrom. The method may selected randomly from the set or be the first method listed in the Known Methods set. The Required Methods set is then checked to see if it already includes the selected method (Step 120) . If so, processing returns to Step 114. If the selected method is determined to not already be included in the Required Methods set in Step 120, processing proceeds to Step 122, in which the selected method is added to the Required Methods set. Next, a list is created of all the methods invocable by the selected method (Step 124). Given the nature of Smalltalk, a typical method sends messages to one or more other methods in order to perform processing during execution. The list created in Step 124 consists of these other methods. In situations<br><br>
where the selected method does not invoke any other method or after the entire list of methods has been processed, the list will be found to be empty in Step 126, and processing will jump to Step 140. However, until the list is actually determined to be empty in Step 126, the first or next method in the list is assigned to a Referenced Method variable and is removed from the list (Step 128) . In Step 130, it is then determined if the Required Classes set already contains the class that implements the method which is contained in the Referenced Method variable. If so, the referenced method is added to the Known Methods set and removed from the Referenced Method variable (Step 138). Processing then returns to Step 126 for the next method in the list, if any.<br>
If it is determined in Step 130 that the Required Classes set does not contain the class that implements the referenced method, it is then determined whether an entry exists in the Check Methods dictionary corresponding to the implementing class (Step 132) . If it is determined in Step 132 that no such entry exists, an empty set is added to the Check Methods dictionary for the implementing class (Step 134) . If it is determined in Step 132 that an entry does exist for the implementing class, or after an entry corresponding to the implementing class is created in Step 134, the referenced method is added to the entry in the Check Methods dictionary for the implementing class (Step 136). The referenced method is removed from the variable and processing then returns to Step 126 for the remaining methods in tiie list, if any.<br><br>
When it is determined in Step 126 that the list is empty, processing proceeds to Step 140, in which a list of all classes referenced by the selected method (from Step 118) is created. In Smalltalk, separate from the reference to other methods (which are processed by Steps 124-138), a method may also reference a number of classes. The processing described below identifies those referenced classes and their parent or super classes which have not already been added to the Required Classes set.<br>
It is first determined in Step 142 whether the selected method references any classes (or if the list has become exhausted by processing) . If so, processing returns to Step 114 to process the next method in the Known Method set. If the list contains a reference for at least one class, one of the classes in the list is assigned to a Referenced Class variable and deleted from the list {Step 144). Next, the Referenced Class variable is updated to include the referenced class and all of its super classes. The technique for determining super classes for a given class is well-known and need not be discussed herein.<br>
Step 148-160 then process the classes now listed in the Referenced Class variable. After the processing of Steps 150-160 has exhausted the list. Step 148 causes processing to Step 142. While the list of classes in the Referenced Class variable still contains classes, processing proceeds to Step 150, whereby the first or next element or class in the Referenced Class variable<br><br>
assigned to a aReferenced Class variable and deleted from the Referenced Class variable (Step 150) . in Step 152, it is then determined if the class in the aReferenced Class variable is already contained in the Required Classes set. If so, processing returns to Step 148 for the next class in the Referenced Class variable, if any. If it is determined in Step 152 that the class is not already in the Required Classes set, then the class is added to the Required Classes set (Step 154). in Step 156, processing then determines whether or not an entry exists for the class in the aReferenced Class variable in the Check Methods dictionary (Step 156) . If no such entry exists, processing returns to Step 148. If it is determined in Step 156 that such an entry does exist in the Check Methods dictionary, then processing proceeds to Step 158, in which all methods in the corresponding entry in the Check Methods dictionary are added to the Known Methods set. The entry corresponding to the class in the aReferenced Class variable and its methods are then removed from the Check Methods dictionary and the class is removed from the aReferenced Class variable (Step 160). Processing then returns to Step 148 for any remaining classes in the Referenced Class variable.<br>
When it is determined in Step 148 that no more classes are listed in the Referenced Class variable, processing proceeds back to Step 142 for remaining classes in the list of classes referenced by the selected method. When it is determined in Step 142 that the list is empty, processing then returns to Step 114 for processing<br><br>
relative to the next method in the Known Methods set. At the time when processing returns to Step 114 and no further methods exist in the Known Methods set, the algorithm will have identified the required minimum set of classes and methods- These classes and methods will be listed in the Required Classes set and Required Methods set, respectively. Packaging of the application is then carried out in accordance with known techniques as per Step 116, such that the only methods and classes included in the packaged application are those methods and classes identified in the Required Methods set and Required Classes set; The specific processing techniques for packaging an application will not be discussed herein as they are well-known and practiced presently in the art.<br>
While the algorithm has been presented specifically for Smalltalk, it is also generally applicable to the packaging step of other languages in which procedures or routines are called by name. While it is clearly applicable to other object oriented languages, such as C++ and ScriptX, it may also be applicable to packaging of C code  libraries and the like.<br>
While the preferred embodiment of the present invention has been described, additional variations and modifications in that embodiment may occur to those skilled in the art once they learn of the basic inventive concepts. Therefore, it is intended that the appended claims  shall be construed  to include  both  the preferred<br><br><br>
embodiment and also variations and modifications as fall within the<br>
spirit and scope of the invention.<br><br><br>
WE CLAIM :<br>
1. A method for determining a minimal set of components necessary for an object oriented application being created to execute, comprising the steps of:<br>
(a)	identifying a known component from the object oriented application and adding the identified component to a first list;<br>
(b)	selecting a component from the first list and deleting the selected component from the first list;<br>
(c)	determining if the selected component is included in a required component list, and if so, repeating said selecting step for a new component;<br>
(d)	if said determining step determines that the selected component is not on the required component list, adding the selected component to the required component list;<br>
(e)	creating a referenced component list for components referenced by the selected component;<br>
(f)	determining, relative to each of the referenced components whether each of the referenced component is included in the required component list, and adding each of the referenced components to the firs list if it is not in the required component list; and<br><br>
(g)     repeating said steps (a) through (f) until the first list is empty.<br>
A method for determining a minimal set of components necessary for an object oriented application being created to execute, substantially as herein described with reference to the accompanying drawings.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBhYnN0cmFjdCBkdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">2091-mas-1996 abstract duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBhYnN0cmFjdC5wZGY=" target="_blank" style="word-wrap:break-word;">2091-mas-1996 abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBjbGFpbXMgZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">2091-mas-1996 claims duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBjbGFpbXMucGRm" target="_blank" style="word-wrap:break-word;">2091-mas-1996 claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBjb3JyZXNwb25kZW5jZSBvdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">2091-mas-1996 correspondence others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBjb3JyZXNwb25kZW5jZSBwby5wZGY=" target="_blank" style="word-wrap:break-word;">2091-mas-1996 correspondence po.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBkZXNjcmlwdGlvbiAoY29tcGxldGUpIGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">2091-mas-1996 description (complete) duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBkZXNjcmlwdGlvbiAoY29tcGxldGUpLnBkZg==" target="_blank" style="word-wrap:break-word;">2091-mas-1996 description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBkcmF3aW5ncy5wZGY=" target="_blank" style="word-wrap:break-word;">2091-mas-1996 drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBmb3JtLTIucGRm" target="_blank" style="word-wrap:break-word;">2091-mas-1996 form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBmb3JtLTI2LnBkZg==" target="_blank" style="word-wrap:break-word;">2091-mas-1996 form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBmb3JtLTQucGRm" target="_blank" style="word-wrap:break-word;">2091-mas-1996 form-4.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBmb3JtLTYucGRm" target="_blank" style="word-wrap:break-word;">2091-mas-1996 form-6.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBvdGhlcnMucGRm" target="_blank" style="word-wrap:break-word;">2091-mas-1996 others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjA5MS1tYXMtMTk5NiBwZXRpdGlvbi5wZGY=" target="_blank" style="word-wrap:break-word;">2091-mas-1996 petition.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="200829-hinge-for-an-opening-door-or-window-frame.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="200831-uniflow-rotary-valve-for-internal-combusion-engines-operating-on-four-stroke-cycle.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>200830</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2091/MAS/1996</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>30/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>24-Jul-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td></td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>22-Nov-1996</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>INTERNATIONAL BUSINESS MACHINES CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>ARMONK, NEW YORK, NY 10504</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>MARTIN PAUL NALLY</td>
											<td>705 STALEY CT. RALEIGH, NORTH CAROLINA 27609</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F9/45</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>08/576,730</td>
									<td>1995-12-21</td>
								    <td>U.K.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/200830-a-method-for-determining-a-minimal-set-of-components-necessary-for-an-object-oriented-application-being-created-to-execute by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 03:02:12 GMT -->
</html>
