<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/220729-portable-data-storage-device-using-a-memory-address-mapping-table by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:25:31 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 220729:PORTABLE DATA STORAGE DEVICE USING A MEMORY ADDRESS MAPPING TABLE</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">PORTABLE DATA STORAGE DEVICE USING A MEMORY ADDRESS MAPPING TABLE</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A portable data storage device includes a USB controller (2), a master control unit (7) and a NAND flash memory (9) device. The master control unit (7) receives data to be written to logical addresses, and instructions to read data from logical addresses. It uses a memory address mapping table to associate the logical addresses with the physical addresses in the memory device (9), and writes data to or reads data from the physical address corresponding to the logical address. The mapping is changed at intervals, so that different ones of the physical address regions are associated at different times with the logical addresses. This increases the speed of the device, and also means that no physical addresses are rapidly worn out by being permanently associated with logical addresses to which data is written relatively often.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT, 1970                          (39 of 1970)<br>
&amp;                                          THE PATENTS RULES, 2003<br>
COMPLETE SPECIFICATION<br>
[See section 10, Rule 13]<br>
PORTABLE.DATA STORAGE DEVICE USING A MEMORY ADDRESS MAPPING TABLE;<br>
TREK 2000 INTERNATIONAL LTD., A COMPANY ORGANIZED AND EXISTING UNDER THE LAWS OF SINGAPORE, WHOSE ADDRESS IS 30 LOYANG WAY #07-13/14/15, LOYANG INDUSTRIAL ESTATE, SINGAPORE 508769.<br><br>
THE	FOLLOWING	SPECIFICATION<br>
PARTICULARLY	DESCRIBES	THE<br>
             GRANTED<br>
INVENTION AND THE MANNER IW WHICH IT !S TO BE PERFORMED.<br><br><br>
18-3-2008<br>
ORIGINAL<br><br>
Field of the invention<br>
The present invention relates to portable data storage devices, and methods of employing the devices for storing and retrieving data written to them.<br>
Background of Invention<br>
During the past couple of years, there has been much interest in providing a data storage devices containing a flash memory and which can be connected to the serial bus of a computer. A leading document in this field is WO 01/61692, which describes a one-piece device subsequently marketed under the trade mark "Thumbdrive". In one of the embodiments described inthis document a male USB plug mounted on the housing of the device connects directly to a female USB socket in a computer, so that the computer is able to transfer data to and from the flash memory of the portable storage device under the control of a USB controller. Various improvements have been proposed to this device. For example, WO03/003282 discloses that the device may be provided with a fingerprint sensor, and that access to data stored within the device is only allowed in the case that the fingerprint sensor verifies the identity of a user by comparing the user's scanned fingerprint to pre-stored data. The disclosure of both of these documents is incorporated herein by reference.<br>
The structure of such a portable storage device may be as shown in Fig. 1. The portable storage device is labelled 1 having a housing shown dashed. It includes a USB controller 2 which controls a USB interface 3 (e.g. a USB plug) which directly connects to the USB interface 4 (e.g. a USB socket) of a host computer 5. Data transferred to the USB interface 3 from the host computer 5 passes through the USB controller 2 to a master control iinit 7.<br><br>
Data packets are of various sorts. They include WRITE data packets, which contain WRITE instructions to write an amount of data which is a multiple of 512 bytes to a specific logical address. They include also READ data packets which contain a READ instruction to read data from a specific logical address. The WRITE instruction typically contains a logical address of the location at which the first part of the data hastobe written, an indication of how much data is to be written, and then the data which is to be written. It may take several data packets to communicate one WRITE instruction. Similarly, a READ instruction indicates a logical address from which to start reading, and an indication of how much memory is to be read starting there.<br>
The master control unit 7 implements these instructions by controlling a NAND flash memory 9. The master control unit 7 controls the NAND flash memory 9 by command symbols which are passed by one or more lines shown schematically as 12. Typically these lines 12 include a line which sends a WRITE signal when data is to be written to the flash memory 9, a line which sends a READ signal when the flash memory is to send data to the master control unit 7, lines which send an address signal indicating a location in the memory to which data should be written or from which data should be read, and an ENABLE signal which has to take a certain value for the flash memory to operate at all.<br>
When the master control unit 7 needs to store data in the flash memory 9, it sends it there via an 8-bit bus'8, at the same time as a WRITE command, ENABLE signal, and address are sent. The address is a physical address (i.e. a specific address in the memory unit 9) corresponding to the logical address according to a mapping stored in RAM memory in or accessed by the master control unit 7. When in response to a READ command, data is transferred out of the device, it passes in 512 byte packets from the NAND flash memory 9, through the 8-bit but. 8, to the master control unit 7. The master control unit<br><br><br>
sends the 512 byte packets to the USB controller 2, which sends them out of the device 1 through the USB interface 3 to the host 5.<br>
The device is conventionally powered through the USB interface 3, so that when the USB interface 3 is unplugged from the USB socket of the computer, the device powers down. All data stored in the RAM of the master control unit 7 is lost.<br>
Fig. 2 shows the memory space of the NAND flash memory 9. The device is configured to store 512 byte sections of data in respective "pages" 6 (note that other possibilities exist, such as each page storing 2kilobytes), each of which also contains a respective control data storage sector 11 which stores control data (typically up to 16 bytes). The data is arranged in "blocks" 10 (i.e. the respective rows of Fig. 2), with for example 64 pages 6 to each block 10. Conventional NAND flash memories have three limitations:<br>
1.	Any given page is either in an "erased" state, in which data can be written into it, or a "non-erased" state in which data is stored in the page and different data cannot be written into theipage. Pages can only be changed from the non-erased state to the erased state on a block-by-block basis, i.e. all the non-erased pages of a given block must be erased at once, losing all the data stored there.<br>
2.	A given block or page has a limited life-cycle, in other words, it can only be changed from the erased to the non-erased state a1 limited number of times, such as 10,000 or 10,000 times. This limits the lifetime of the memory device.<br>
3.	The NAND flash memory contains occasional blocks which are "bad': in the sense that data cannot be reliably written there.<br>
As mentioned above, the address in the NAND memory device 9 into which data is written, or from which data is read, is determined by a logical address<br><br><br>
encoded in a data packet received through the USB interface 3. Conventionally, the master control unit has access to a table storing a mapping between addresses in the logical address space and locations in the physical memory space which are within blocks of the memory device which are not in the dirty table (i.e. the "physical address" within the memoty). Specifically, each block is mapped to a respective region of the logical address space having a number of addresses equal to the number of pages. This mapping is fixed. Thus, the bad blocks are not associated with any of the logical addresses.<br>
Apart from the bad blocks, there are other blocks which are not associated with the logical addresses. These are "reserved" blocks which are used for storing other data the portable storage device may need. For example, the dirty address table itself is stored in the reserved blocks.<br>
The master control unit 7 includes a file management system, including a block allocation table, which indicates whether and how much of each of the blocks are in the erased state or the non-erased state. When the master control unit 7 receives data to be written to a location in the memory which is within one of the blocks, the master control unit 7 uses the block allocation table to find whether the block is in the erased state. If it finds that the block is in the non-erased state, it conventionally copies any data in the block which is not to be overwritten to a different location, erases the block, and then writes back to the block both the new data which is to be stored in the memory and the data copied to the different location.<br><br><br>
Summary of the Invention<br>
The present invention aims to provide a new and useful portable data storage<br>
device.<br>
In general terms, -the present invention proposes that the mapping between'<br>
regions of the logical address space and regions in the physical memory<br>
space is changed during the operation of the device. In other words, there<br>
remains a one-to-one mapping between logical address regions and physical<br>
memory regions, but this mapping-changes overtime.<br><br>
This has a number of advantages.	<br>
Firstly, the present inventors have noticed that generally the logical addresses generated! by a conventional operating system on the host-computer-tend to be statistically correlated, which means that if the logical addresses have a fixed relationship to the physical addresses, then some physical addresses are used much more frequently than others and therefore tend to wear out<br><br>
quickly.<br>
(furthermore; being able to vary the relationship between logical and physical addresses means that the number of write operations which are required to write data is reduced. Essentially, when an instruction is received to write data into a page for which, according to the present mapping of logical and physical addresses, is in the non-erased state, the mapping of logical and physical addresses can be 'changed so that a new block in the erased state is associated with that logical [address. The new data is written to the new block, and any data stored in the old block that is not to be erased is also written to the new block. Thus the old data only has to be copied once, not twice as in the conventional method discussed above. This makes the total operation of the device faster.<br><br>
The temporary mapping between the logical and the physical addresses is defined by a memory address mapping table. For speed of operation the memory address mapping table is preferably stored in RAM memory (e.g. in the master control unit itself). But the mapping data which defines it is also preferably stored in the flash memory device itself, so that it is not lost in a power-down situation.<br>
In particular, the control data storage sector of one or more pages of a given block may store data indicating which logical address region the block is presently associated with. When the device is connected to a host computer, and the master control unit is powered, the master control unit uses this data to generate the mapping table (which may be stored in its cache memory). As the mapping is changed, such that the physical address corresponding to a given logical address region changes from a first block to a second block, the data in the mapping table and the corresponding data stored in the flash memory device are kept updated. In the case of the data stored in the flash memory, this may simply be by copying the data defining the mapping from the first block to the second block before the first block is erased.<br>
As mentioned above, in conventional systems the logical address space is<br>
smaller than the physical address space, since there are blocks which are not<br>
associated with any of the logical addresses. These are the reserved blocks<br>
and the bad blocks. In embodiments of the present invention, in addition to<br>
the reserved blocks and bad blocks, there are at any time a set of further<br>
blocks (here referred to as "queuing blocks") which are available to become<br>
mapped to one of the logical address regions in place of blocks which are<br>
presently mapped to that logical address region. When the mapping is to be<br>
varied, one of the queuing blocks is selected to become associated with one<br>
of the logical address regions. The queuing blocks are preferably in the<br>
erased state while they queue, rather than being erased just before they<br>
become associated with one of the logical address regions.<br><br><br>
The updating of the memory address-mapping (i.e. the selection of an erased second block to replace a first block in the mapping) may be performed whenever a new WRITE instruction is received to write data to a location in the physical address which is not in the erased state.<br>
It may be. performed-as soon as this WRITE instruction is-received. Alternatively, in a preferred refinement of the present invention, a write operation performed by the master control unit based on a given WRITE instruction may be suspended for a certain period, and performed only provided that no instruction meeting a predefined similarity criterion with the first instruction is received during that period. Just as the concept of the variable address mapping table discus;sed above is -motivated partly by the<br>
observation that logical addresses are statistically correlated, this refinement<br>
is motivated   by the observation that frequently  instructionss wnich  are<br>
received during a relatively short period of time are sufficiently strongly<br>
correlated that they can  be  more efficiently  processed  together ;than<br>
separately, thus improving the speed and/or lifetime of the portable' data<br>
storage device. This concept of suspending a write operation to determine<br>
whether another, correlated WRITE instruction am'ves, constitutes another<br>
-independent aspect of the invention, which may be used within the scope of<br>
the invention other than in combination with the variable mapping table.<br>
A first such correlation is that frequently successive write instructions specify that data is to be written into consecutive the same logical region. To address this, when the master control device receives a first instruction specifying that data is to be written into a logical address region corresponding under the memory address mapping to a given first block of the physical memory, the master control device preferably suspends at least one of the operations which cause data stored in the first block which is not to be overwritten to be copied into the second block. If during that period, the master control device receives no packet containing an instruction to write data into the successive<br><br><br>
page of the block, then it may continue with the operation of copying the data in the first block into the second block. Alternatively, if during the period it receives one of more packets specifying other data to be written into other locations in the same logical gddress region, then it can write the data from ail of the packets into the block, and in this case only needs to copy the data from other portions of the first block into the second block.<br>
A second such correlation is that, as the present inventors have noticed, frequently the master control device will receive within a short space of time packets containing WRITE-instructions specifying exactly the same logical address. Rather than j at once resetting the memory address mapping whenever each of these instructions is received, embodiments of the present invention preferably suspend this operation during a time period. During this period the data is stored in a data cache operated by the master control device (e.g. its internal RAM cache memory). If no instruction relating to the same logical address is received during the time period, then the master control device proceeds with writing the data to the flash memory as discussed above. However, if, during the period, a WRITE instruction is received |(tor, in alternative embodiments, not one relating to the same logical address), the master control device instead writes the data to its cache memory (and normally resets its clock). If during the period a READ instruction is received in respect of the same logical address, that data is read<br>
from the cache memory, not from the flasn; memory device.<br><br>
Optionally, the cache memory may be large enough to store data in respect of multiple logical addresses. That is the cache memory may be divided into a plurality of sections, each being for storing data in respect of a corresponding logical address, and each being associated with a respective timer for measuring the time since a WRITE instruction in respect of that logical address has been received.<br>
t<br><br><br>
Preferably, the data storage device is capable of distinguishing which logical addresses are particularly likely to have data written to them very often (i.e. it performs a pattern recognition algorithm based on the input instructions), so that it can select a set of one or more logical address for which it is worth performing the caching operation described in the preceding two paragraphs.<br>
The description above assumes that there is a respective mapping for each of the blocks which are to be associated with logical address regions, but this would require the memory address mapping table to have at least as many element as the number of blocks which are available for storing data. An alternative is to associate logical-address regions with respective groups of blocks For example, the blocks may be grouped in groups, of (say) four<br>
blocks (thus a total of, for-example, 4x64=256 pages), and logical address regions would be larger by the corresponding factor (e.g. four). The memory address mapping table would in this case define a one-to-one mapping between each of these groups and a respective one of the logical address<br>
regions.<br>
I'   ..<br>
The groups may simply be consecutive ones of the blocks, but in the case that there are any bad blocks, a more sophisticated way of setting blocks is preferable in which the blocks which are not bad are grouped. The groups of blocks-can-then be treated as the regions of physical memory which are associated with regions of the logical address space! The master control unit has access to a grouping table indicating this grouping, so that given a logical address it can use the memory address table to determine a corresponding<br>
group and the grouping table to identify the blocks constituting this group.<br>
Since bad blocks are relatively rare, the majoiity of the groups could be set according to a simple rule (e.g. that the groups are respective sets of four consecutive blocks), and the grouping table would only store aata in respect<br><br>
of blocks which failed to follow this rule. This would reduce the required size of the grouping table.<br>
Conveniently, the fact that a given logical address region is associated with one of these exceptional groups could be included as a flag in the mapping address table. Thus, the memory mapping address table would indicate when it is necessary to consult the grouping table to determine the physical address associated with a given logical address.<br>
The master control unit may associate logical addresses in a given logical address region with the blocks of the corresponding group, such that consecutive logical addresses correspond to "columns" of pages. This concept of providing groups of blocks to correspond to logical address regions, and to associate consecutive logical addresses within a logical address region with columns of pages, constitutes another independent aspect of the invention, which may be used within the scope of the invention other than in combination with the variable mapping table.   <br>
One specific expression of the first aspect of the invention is a portable data  storage device including:<br>
(i) a data interface for transferring data packets into and out of the device,<br>
(ii) an interface controller,<br>
(iii) a master control unit, and<br>
(iv) at least one NAND flash memory unit,<br>
the interface controller being arranged to send data received through the interface to the master control unit, and<br><br><br>
the master control unit being arranged to recognise certain data packets as encoding READ instructions and other data packets as encoding WRITE instructions:<br>
(a)	upon receiving a READ instruction indicating a logical address, to<br>
access a memory address mapping table which associates-logical-address<br>
regions within a logical memory space with respective first physical address<br>
regions within the memory unit, to read data from a physical address in the<br>
memory unit corresponding to the logical address according ito the address<br>
mapping table, and to-transmit to the data interface pne or moredata packets<br>
including the data which was read, and<br><br>
(b)	upon! receiving WRITE instruction indicating a logical address and<br>
datato bewritten to thatipgical address to detefmine ifthe physical address <br>
corresponding to! the logical address according ito the memory address<br>
.mapping table is in the erased state and:	<br><br>
if so, to write the data to that physical address, or<br>
if not, to modify the address mapping table to associate a second physical<br>
address region with the logical address region containing the logical address,<br>
to write the data to a physical address corresponding to the logical address<br>
according to the modified memory address mapping table, and to copy any<br>
data  stored   in  other  potions  of the first  physical   address   region   to<br>
corresponding locations of the second physical address region.<br>
It is to be understood that within the context of the intention there may be WRITE instructions which contain data to be stored in multiple ones of the pages, or READ data packets which request data from multiple pages. In other words, the address mentioned ;above may for example be the starting address of a multi-page portion of a physical address region.<br><br><br>
Brief Description of The Figures<br>
Preferred features of the invention will now be described, for the sake of illustration only, with reference to the following figures in which:<br>
Fig. 1 shows a first configuration of a known portable data storage<br>
device;<br>
i<br>
Fig. 2 shows the physical memory space of a NAND flash memory device of the known device of Fig. 1;<br>
Fig. 3 shows a memory address mapping table in a first embodiment of the invention;<br>
Fig. 4 is a flow diagram of the steps performed in the first embodiment   of the invention;<br>
Fig. 5 shows the memory address mapping table of Fig. 3 after a certain data write operation";<br>
Fig. 6, which is composed of Fig. 6(a) to 6(e), shows a second embodiment of the invention;<br>
Fig. 7, which is composed of Figs. 7(a) to 7(e), shows the state of a physical memory of a third embodiment of the inventidn at respective times;<br>
Fig. 8 is a flow diagram of the operation of the embodiment of Fig. 7; and<br>
Fig. 9, which is composed of Figs. 9(a) to 9(c), illustrates a fourth embodiment of the invention.<br>
Detailed Description of the embodiments<br>
A first embodiment of the invention will now be described. It may have the same physical structure as shown in Fig. 1, and for that reason the corresponding elements of the embodiment will be given the-same refarence numerals as used in Fig. 1. All the elements shown may be contained in a single housing, e.g. one on which the USB connector 3 is mounted. The USB<br><br><br>
connector 3 (e.g. USB plug) may be connected directly to a host computer (e.g. a personal computer (PC)) by plugging in to a USB socket 4 of the host computer 5. Alternatively, a cable may be attached between them. It should be noted that this device may have many features which are not shown explicitly in Fig. 1, but which are known in other publicly-available-portable data storage devices, subh as password protection, access controlled by fingerprint verification, etc. The implementation of such features will be clear to one skilled in the art<br>
.'■.'	.	.	'	•	'<br>
1<br>
Fig. 3 shows the; memory address mapping table used by the first j embodiment This-table is.stored in the volatile RAM memory of the master control unit 7. On the left column 21 |are indices labelling logical address regions, and on the right 23 are digits labelling the blocks of the physical address space which are one-to-one mapped to those logical address regions. For simplicity, it will be assumed that the number of logical address regions is 8 (labelled by the indices 0 to 7), and that the number of blocks is 16 (labelled the indices 0 to 15). In reality, both of these numbers will be very much higher). Thus, the amount of data which can be stored in each of the —logical address regions is 512 bytes (assuming-that this-is the size of the pages) times the number of pages per block (e.g. 64). Each row of the right column stores only an index labelled a corresponding block. The number of logical address regions corresponds to the number blocks which will be used forstoringdataat any one time.<br>
For example, since it is assumed that there are 64 pages per block, the logical address 67 relates to a page in logical address region 1. This is because the pages of logical address region 1 have logical addresses 0,1, ...63 and the pages of logical address region 1 have logical addresses 64, 65,...127, so logical address 67 is the fourth address in logical address region 1. Under the mapping shown in Fig. 3, the logical address region 1 is mapped to block 10.<br><br><br>
In addition to the blocks which are mapped to the logical address regions, the physical address space includes a number of other blocks (8 in the example shown above). These include blocks 6,12 and 13 which are reserved, and bad block 7 which is "bad" (not functional). Thus, these addresses do not appear in the mapping table of Fig. 3 (though preferably the embodiment does also have a dirty block table and a table of reserved blocks, which may be used in conventional ways to perform other operations conventional in portable storage device). This leaves a number of blocks (four in this example) which are available to become mapped to the logical address regions.<br><br>
These blocks, referred to as "'queuing blocks", are shown as 25 irilthe memory<br><br>
address mapping table of Fig. 3] These blocks are in the erased state. When<br><br>
a block is removed from the top of the queue all the other blocks are moved<br>
up by one; a new block is then inserted into the bottom row of the: section 25.<br>
Conveniently, this may be implemented by arranging for four locations in a<br>
memory to each store one of the indices and to have a pointer indicating one<br>
of the four locations. The location' to which the pointer points is logically<br>
I equivalent to the "top row" of the section 25. Removing the index and the "top<br>
row" of the section 25 and writing a new index into the "bottom row" of the<br>
section, thus corresponds to overwriting the new index into the location to<br>
which the pointer points and changing the pointer in a round-robin 'manner to<br>
point at a next one of the locations.<br>
The control data storage sector 11 of the first page of each block which is mapped to a corresponding logical address region includes the index of the corresponding logical address region (if the number of bits required to store this index is greater than the number of bits available in the sector 11 of the first page, the index may be coded and stored in the sectors 11 of more than<br><br><br>
one page of the corresponding block). Thus, if the device is powered-down<br>
(so that the memory address mapping table of Fig. 3 is lost from the RAM),<br>
when the device is powered again the master control unit 7 can regenerate<br>
the memory address mapping table in its RAM using the indices stored in the<br>
 control data storage sectors 11.<br><br>
We now consider the operation of the first embodiment, with reference to the flow diagram shown in Fig. 4. In step 1 an instruction is received, and in step 2 the master control unit 7 determines whether it is a READ instructionor a WRITE instruction.<br><br>
Suppose the' instruction is a READ instructionto read data starting! from logical<br>
address 67 instep-3-the_mastei control unit 7 uses the memory address<br>
mapping table of Fig. 3 to determine the corresponding block corresponding<br>
to the logical address region containing the logical address (i.e. block 10), and<br>
within that block the page(s) Icorresponding to the logical address (i.e. the<br>
fourth page). Then in step 4 the read operation, is performed accordingito the<br>
known technique: the master control unit 7 issues  a command to the memory<br>
unit 9 to extract the data stored fourth page from block 10; this data is<br>
transmitted from the memory unit 9 to the master control unit 7 via the bus 6;<br>
the master control unit forms this into one or more packets andtransm'rts it out<br>
of the device.	<br>
Suppose the master control unit receives a WRITE instruction to write certain data beginning at the logical address 67. In step 5 the master control unit 7 determines the block and page corresponding to the logical address (as in step 3), and in step 6 the master control unit determines whether this page is in the erased or non-erased state. This may be done using a file management system (e.g. employing a block allocation table as in the prior aa described above).<br><br>
If the fourth page of block 10 is erased, then the master control unit 7 just sends a write instruction to the memory 9 to cause the memory to store the data in the fourth page of block 10, according to conventional techniques.<br>
Alternatively, if the fourth page of the block 10 is not-erased, then in step 8 the master control unit instructs the memory unit to copy any data stored in the first three pages of block 1C and in the last 60 pages of block 10 to a new block. This new block is the first of the queuing blocks 25, that is block 4. Then in step 9 the data included in the WRITE instruction is written to page 4 of block 4. Then in step 10 the memory address table is reset to the'form shown in Fig. 5. That is, the block 4 is now associated with the logical address region 1. The block 10.is erased, and placed at the back of the queue 25. Since there are four blocks in the queue, the block 10 will be reused on the next-but-three time that the master control unit is instructed to write data to a page which is non-erased. Note that the operations of steps 8 to 10 may be performed in any other order, according to the implementation.<br>
  Note that an alternative to using a file management system is for the device to     omit steps 6 and 7, and to proceed straight from step 5 to step 8  in other words, every time a write instruction is received, the copying steps 8 to 10 would be performed.<br>
Fig. 6 shows a second embodiment of the invention. Whereas in the first embodiment, each of the 8 logical address regioris is mapped to a respective block, in the second embodiment each of the logical address regions (still 8 in this example) is mapped to a corresponding group of blocks (in this example, four blocks). In this example, the number of blocks is equal to 64, labelled by an index 0 to 63. Blocks 60: 61, 62 and 63 are taken as reserved. Blocks 9, 17, 10, and 27 are assumed to be bad. The bad groups are given in a "dirty table" which is shown in Fig. 6(a). This table may be generated the first time<br><br><br>
the device is powered by testing all the blocks and finding the bad ones; following this the reserved blocks can be defined ensuring that they do not include bad blocks. The bad block table is then typically stored in one or more of the reserved blocks; alternatively it may be regenerated whenever the device is powered.<br>
The memory address mapping table is shown in Fig. 6(b). In this case each of<br>
the logical address regions 0 to 7 (in the left column 31) is shown mapped to a<br>
group number (in the middle column 33). There are 12 groups available to be<br>
mapped-to-respective ones of the logical address regions, and these groups ;<br><br>
arelabelled by the respective g roup indices 0 to 11. |<br>
Most groups, having an index of say /, are composed of the set of blocks 4/-4,<br>
4/-3, 4/-2and-4/-1 -However, there are blocks which are an .exception to this,<br>
simple rule, because if the rule were followed that group would include one or<br>
more blocks which were bad. The blocks which define such groups are given<br>
in a "clean table", shown in Fig. 6(c).<br>
For example, group 1 is simply the first four blocks 0; 1, 2 and 3. Group 2 is the second set of four blocks 4, 5, 6, 7. Group 3, however, is not blocks 8, 9, 10 and 11, however because as mentioned above block 9 is bad. Instead, the clean-table, of Fig. 6(c) indicates that group 3 is made up of blocks 8, 59, 10 and 11. Group 4 is, according to the usual rule, the blocks 12, 13, 14, 15. Group 5 is, again, an exception to the general rule (because blocks 17 and 18 are bad), and according to the clean table is made up of blocks 16, 58, 57, 19. Group 6 is again regular, i.e. blocks 20, 21, 22 and 23. Group 7 is again irregular (since block 27 is bad), and according to the clean table it is blocks 24, 25, 26 and 56. Groups 8 to 11 are according to the usual rule.<br>
Thus, the clean table defines the members of only three groups in this example: groups 3, 5 and 7. In fact, in more typical embodiments the proportion of bad groups is very iow, so that the clean table is much smaller<br><br><br>
than the memory address mapping table. The maximum number of rows of the clean table is the number of bad groups.<br>
To indicate that group 3 is not according to the rule, the memory address mapping table contains a flag in the third column 37, and a corresponding indication in the fourth column. 38 of.which row of the clean table of Fig. 6(c) to refer to obtain the exact membership of the group (in Fig. 6(b) the values in the fourth column 38 are respectively 0, 1, 2, and these three values labelling respectively the three rows of the clean table of Fig. 6(c)).<br>
When the master control unit receives a WRITE instruction instructing it to write certain data to logical address 67, in this case it identifies that the logical address is within the logical address region 0 (since logical address region 0 is logical addresses 0 to 255). The mapping between logical addresses and groups in Fig. 6(b) shows that the corresponding group is group 2. The corresponding flag of column 37 is not set, so it is not necessary to consult the clean table to identify the blocks corresponding to group 2: the rule gives them as 4, 5, 6 and 7. The logical address 67 is thus the fourth page in block 5.<br>
If this page is in the erased condition then the data from the WRITE instruction is written into that page.<br>
If this page is not in the erased condition, then the delta in the WRITE instruction is written into the fourth page of the second block of the group at the head of the queue 25, which happens to be group 7. The memory address mapping table of Fig. 6(b) is then updated to be Fig. 6(d) by moving the group number at the head of the queue (i.e. group number 7) into the column 33 at the row corresponding to logical address region 0, and also copying the flag indicating that block 7 is irregular into the same row of the third column 37, and the corresponding data indicating a row of the clean table into :he new row of the fourth column 38. Any'data stored in other pages of the blocks 4, 5,<br><br><br>
6 and 7 is copied respectively to the corresponding pages of the group 7 (i.e. the respective pages of the blocks 24, 25, 26 and 56 respectively).<br>
If subsequently a read instruction is received for the logical memory address 67, the master control unit 7 again determines that this corresponds to logical region 0, and therefore examines-the corresponding-row in the memory address mapping table of Fig. 6(d). This time it finds from column 33 that corresponding group is 7, and the flag in column 37 indicates that this group is irregular. Column 38 indicates that the group is in row 2 (i.e. the last row) of the clean table of Fig. 6(c). The master control unit therefore~extracts the blocks of this row (i.e. blocks 24, 25, 26, 56) from the clean table of Fig. 6(c). It read the data from the fourth page of the second block of group 7 (i.e. block _25), generates one or more data packets encoding that data, and transmits the packet(s) out of the device via the interface 3.<br>
If again a write instruction is received for the logical memory address 67, the master control unit 7 again examines the corresponding position in the memory address mapping table of Fig. 6(d). This time it finds that corresponding group is 7, and the flag in column 37 indicates that this group is irregular. The master control unit therefore extracts from column 38 the corresponding row number (i.e. 2), and obtains to the blocks of this row (i.e. blocks 24, 25, 26, 56) from,the clean table of Fig. 6(c). It inspects the fourth page of the second block of group 7 (i.e. block 25) to see 'if data is stored there (which of course, given the history explained above, there is). It therefore, moves all the stored data in the other pages of the group to the corresponding pages of the group which is now at the head of the queue 35 (i.e. group 4) and writes the data of the WRITE instruction to the fourth page of the second block of this group. Then inserts the number 4 into column 33 at the top row, copies the (blanK) flag corresponding to group 4 into column 37 at the top row, copies the (blan 
<br><br>
(having moved the other rows up one),copies the corresponding flag into the bottom row of column 37, arid copies the corresponding data into the bottom row of column 38.<br>
Note that the flow corresponding to this process is almost identical to that of Fig. 4. However, it should be understood that steps 3 and 5 now are now more sophisticated. Instead of the block being determined just from the logical address and the memory address mapping table (e.g. of Fig. 3), it is determined by obtaining using the memory address mapping table (e.g. of Figs. 6(b) and 6(d)) to obtain a corresponding group, and determining the blocks of the group (from the rule, or if a flag is present in column 37 of the memory address mapping table, from the row indicated in column 38 of the clean table of Fig. 6(c)). Also, in steps 8, 9 the reference to the first queuing, block should in this case be understood as a reference to the corresponding block of the first queuing group (i.e. the group at the top of section 35 of the memory address mapping table).<br>
This describes how the second embodiment operates the mapping between logical address regions and respective groups of blocks. A logically! separate issue is how the embodiment maps logical addresses within any given logical address region to respective pages in the corresponding group of blocks.<br>
One possibility is for the correspondence to be what we will call "horizontal". This means that the consecutive pages of the blocks to correspond to consecutive logical addresses. The final page of each block (except the last block of the group) corresponds to the logical address consecutively before the logical address corresponding to the first page of trie next block of the group. Thus, for example, an amount of data which is slightly larger than the number of pages of a single block, will be written to the memory such that the beginning of the data is written to a page specified by a logical address, then<br><br><br>
consecutive pages of the block are written to until the block is exhausted, then the remaining portion of the data is written to the first pages of the next block.<br>
However, this is not the only possibility. In a preferred form of the second embodiment of the invention, the master control unit may operate such that the logical correspondence of addresses to pages of-the-group of blocks is "vertical". Specifically (assuming, for the sake of example, that there are four blocks in a given group) the first four logical addresses may be mapped to the first pages of each of the blocks (i.e. the first logical address to the first page of the first block of the group; the second logical address to the first page of the second block of the group; and so on), the next four logical addresses may be mapped to the second pages of each of the blocks (i.e. the fifth logical address to (the second page of the first block of the group; the sixth logical address;to-the second page of the second block of the group; and so on)..<br>
To put this another way, the master control unit 7 treats sets of four consecutive logical addresses as corresponding respectively to respective   pages of the respective blocks The pages associated with a given set of logical addresses all have the same offset value, measured counting horizontally along the pages of ,the respective block (i.e. these pages form a "column" in the physical address space).<br>
Fig. 6(e) shows what happens when a certain amount of data is to be written<br>
to a location to group 2 (i.e. blocks 4, 5, 6 and 7). The logical address to which<br>
i<br>
the beginning of the data is written has an offset of 17 relative to the logical address which corresponds to the first page of block 4. That is, the logical address to which the beginning of the data is written is the 17 pages after the first page of the group. These pages are counted vertically in Fig. 6(c) (i.e. first down the first column of pages, then down the next column). Thus, the page with an offset of 17 is the one indicated by "A".<br><br>
In the writing operation, data from the old group is copied to locations in group 2 indicated by the hashed area 32. Then the data in the write packet is written to the pages in the hashed area 34 (i.e. starting at location A). Then any data in the old block which is in the unhashed region 36 following the region 34 is copied to region 34.<br>
We now turn to a third embodiment of the invention. The third embodiment resembles the first embodiment, but with one (important) difference. In the third embodiment, following a WRITE instruction which causes the mapping defined in the memory address mapping table to be changed, and data ' contained in the WRITE instruction to be written into a location of the new blockwhich becomes associated with the logical address, the operation of copying data from the rest of the old block into the new block is partially suspended for a pre-defined time to see whether any new WRITE instructions in respect of the same region of the memory space are received.<br>
Specifically, suppose that a WRITE instruction is received indicating that data A is to be written a certain logical address. Suppose that that logical address is in a logical address region presently corresponding to block 0. Suppose further that the logical address corresponds to page 4 of block 0. Further suppose that the erased block at the top of the queue 25 (of Fig. 3) is block 3. Fig. 7(a) shows a portion of the physical memory including blocks 0 and 3. That is, block 0 has data labelled as X stored at page 0 to 3, data labelled as Y stored at page 4, data labelled Z at pages 5 to 7 and then the rest of the block is in the erased condition (shown as "0").<br>
According to the first embodiment, this WRITE instruction would immediately cause the physical memory in blocks 1 and 3 to be as shown in Fig. 7(b). That is, the new data A is stored at page 4, and the data X and Z is stored at the pag3s of block 3 corresponding to their previous pages in block 0. Block 0<br><br><br>
would be erased (and an index representing it would be at the bottom of section 25 of Fig. 3).<br>
However, in the third embodiment of the invention the physical memory is instead initially rewritten to be as shown in Fig. 7(c). That is, the data A is written to page 4 of block 3r and-the-data X is copied-to pages 0 to 3, but the data Z is not yet copied to pages 5 to 7 of block 3. The system remains in this configuration for a time period given by a timer. If by the end of this period no further WRITE signal has been received in respect of the logical address corresponding to page 5 of block 3, then the write operation is completed to give the data storage shown in Fig. 7(b). However, if during this period a new WRITE instruction is received which indicates that data B is to be stpred at the-logical address now corresponding to page 5 of block 3, then this data B is written to page 5 of block 3, giving the data storage shown in Fig. 7(d). The timer is then started again to define a new time period.<br>
If by the end of this period no further WRITE signal has been received in<br>
respect of the logical address corresponding to page 6 of block 3, then the<br>
write operation is completed to give the data storage shown in Fig. 7(e).<br>
However, if during this period a new WRITE instruction is received which<br>
indicates that data C is to be stored at the logical address now corresponding<br>
                                                                                                                                to page 6 of block 3, then this data B is written to page 6 of block 3, and the timer is started again.<br><br>
This process may be continued until the last page of the block 3 is reached, or a time period goes by without a WRITE instruction being received indicating data to be stored at the page following the location specified by the preceding WRITE instruction. Note that it means that data A, B , ... can be written to the memory device much more quickly than in the first embodiment, since there is much reduced need to copy data. For example, during the sequence of steps described above, the data X only needs to be copied once at the very<br><br><br>
beginning no matter how many WRITE instructions are subsequently received in respect of consecutive pages.<br>
The flow diagram is shown in Fig. 8, and differs from Fig. 6 only in that in<br>
steps 8 to 10 are replaced by steps 8 to 13. In step-8-of Fig. 8,-only the pages<br>
in the old block (i.e. block 0) before the page in respect of which the WRITE<br>
instruction was received, are copied to the new block (i.e. block 3), and the<br>
data in the WRITE instruction is written to the   page in the new block<br>
corresponding to the" logical address. In step 9 it is determined whether the<br>
last page of the new block has now been written to. If so, the device proceeds<br>
to step 13. in step 10 the device determines whether, within the<br>
predetermined time, a new WRITE instruction is received in respect of the<br>
next consecutive page of the new block. If so, the embodiment writes the data<br>
                                                                                                                         there in step 11 and loops back to step 9. If not, in step 12 the embodiment<br>
copies the rest of the pages of the old block (i.e. all the pages, if any, after the<br>
last page in respect of which a WRITE instruction was received). Step 13<br>
corresponds to step 10 of Fig. 4: the old block (block 0) is erased and the<br>
memory mapping address table is updated.<br>
Note that if, at a time when the embodiment is in step 10, a READ instruction is received in respect of a logical address in a logical address region which is currently the subject of the flow of Fig. 8, then the device should read the data from the correct place in the physical memory (i.e. from the new block if the logical address corresponds to the addresses written to in step 8, or if the logical address corresponds to an address which was written to in a preceding step 9; otherwise from the old biock).<br>
In certain forms of this embodiment, the device may proceed from step 10 to step 12 also in the case that in step 10 if it determined that a new VVKI I'E instruction is received which instructs data to be written to any logical address other than the next consecutive page of the new  block. In this case the<br><br><br>
processing of the new WRITE instruction can be begun after the flow of Fig. 4 is completed.<br>
Note that the timer is typically set to a period of a few milliseconds, such as about 3ms. If the device is disconnected from the host within the predetermined period after the last WRITE instruction is received, then there is a danger of data being lost. However, by setting the predetermined period to be of the order of milliseconds, this should not occur, and thus all the data will be securely stored. Note that the third embodiment of the invention<br>
reduces to the first embodiment in the limit of the predetermined period going<br><br>
to zero<br><br>
We turn now to a fourth embodiment of the invention. Like the third<br>
i<br>
embodiment, the fourth embodiment employs a timer.<br>
The. master control unit 7 in this case includes a pattern recognition unit which" receives the logical addresses extracted by the master control unit from WRITE instructions. If, during a certain phase of operation, the pattern recognition unit notices that a certain logical address appears much more frequently than would be expected, then it writes that logical memory address into a "frequently used logical address" space, e.g. defined in the RAM memory of the master control-unit. More generally, the frequently used logical address space may contain a plurality of such identified logical addresses having a high frequency. The pattern recognition unit may be programmed to strike logical addresses out of this space when their frequency reduces, and/or to replace it in the space whenever a logical address is identified having a yet higher frequency of usage. Thus, the space continually stores the logical addresses which occur most frequently in WRITE instructions.<br>
The master control unit 7 maintains a cache RAM memory for each iccation in the frequently used address space. Upon receiving a WRITE instruction in respect of one of the addresses stored in the frequently used logical address<br><br>
space, the master control unit does not initially write the data contained in the WRITE instruction into the flash memory device. Instead, it writes that data into the corresponding cache. The master control unit 7 then waits for a time determined by the timer. If, during that time, no further WRITE instruction is received (or, in one form of the embodiment, if a packet is received in respect .of a different block), then the master control unit writes the data in the cache into the flash memory according to the process described above in relation any of the first to third embodiments of the invention. If, on the other hand, during the predetermined period another WRITE instruction is received in respect of the same logical address, then the master control unit writes the data contained in that WRITE instructionto the same location its caci is \i.e. overwriting the data which was written there due to the first write packet). The timer is then restarted.<br>
Thus, ft will be seen that if the device 1 receives a large number of WRITE instructions in respect of the same logical memory address, spaced apart by an average time which is lower than the predetermined time set by the timer, the number of those WRITE instructions which will cause a (computationally expensive) write operation to the memory device 9 will be low.<br>
The structure of part of the master control unit 9 is shown schedule in Fig. 9. The master control unit 9 contains a section 51 for separating a WRITE instruction into a logical address and data to be written to that logical address. The logical address is sent to a pattern recognition unit 53, which uses ft is to keep updated a frequently used address space 55. The master control unit has a switch 57 which determines whether the logical address of the WRITE instruction just received is in the frequently used address space 55. If not, the data and logical address are written at once to a unit 57 which writes them to the flash memory 9 according to the method of the first embodiment. If so, the data is written to a cache memory 59 and a timer in timing unit 61 is set running. If the timer in timing unit 61 reaches the end of the predetermined<br><br><br>
period without being reset again, the data and corresponding logical address are passed by switch 57 from cache 59 to the unit 57. Note that although Fig. 9(a) shows only a single timing unit 61, that timing unit 61 typically contains a respective timer for each respective logical addresses in the frequently units logical address space, and for each of these logical addresses there is a respectivecache memory location.<br>
If a READ instruction is received, a unit 63 determines whether the logical<br>
address is one of the ones stored in the frequently used address space, and if<br>
so determines whether the corresponding timer is running. If so, it reads the<br>
data from the corresponding cache memory 59; otherwise it uses a unit 67 to<br>
read the data from the flash memory 9 according to the correspondence<br>
defined by the memory address mapping table (i.e. according to the method<br>
of the first embodiment), in either case, it encodes the data into a packet<br>
which is transmitted out of the device through the interface 3.<br><br>
The flow diagram of the embodiment is that of Fig. 3, except that the steps of Fig. 9(b) are inserted between steps 2 and 3 in Fig. 3 (and performed byjthe units 51 and 57), and the steps of Fig.9(c) are inserted between steps 2 and 5 of Fig. 3 (and performed by the unit 63). In steps 7 and 9 the data which is written to the page is the data in the last WRITE instruction received in respect of that logical address.<br>
Whenever the unit 53 removes a logical address from the frequently used<br>
J<br>
logical address space (i.e. updates unit 55), the data in the corresponding location of the cache 59 is written to the memory 9 according to the steps 5 to 10 of Fig. 3.<br>
In either the third and/or fourth embodiments of the invention, the timer may be arranged such that the predetermined period which is only a few milliseconds, such as about 3ms. If the device is disconnected from the host within the predetermined period after the last WRITE instruction is received,<br><br>
then there is a danger of data being lost. However, by setting the predetermined period to be of the order of milliseconds, this should not occur, and thus all the data will be securely stored. Note that the third and fourth embodiments of the invention each reduce to the first embodiment in the iimit of the predetermined period going to zero.<br>
Note that none of the embodiments described above require a block allocation table (although other embodiments are possible which do use such a table).<br>
Although only a few embodiments of the invention have been described in<br>
detail here, many variations are possible within the scope of the invention as<br>
will be clear to a skilled reader. For example, the features of the second, third<br>
and fourth embodiments can readily be combined in any combination, and<br>
indeed the combination of all the features described (including the vertical<br>
filling of the pages of the groups of blocks) is preferred. Thus, an embodiment<br>
l	■    •<br>
of the invention can be formed in which logical address regions are mapped to<br>
respective groups composed of a plurality of blocks, in which the logical<br>
addresses within a given logical address region correspond to column within a<br>
group of blocks, in which a first timer signal is used to suspend copying of<br>
data from an old group to a new group, and in which a second (optionally<br>
different) timer signal is used to suspend the writing of data contained in a<br>
WRITE instruction to the flash memory device 9.<br>
Furthermore, in the embodiments above there is only a single NAND flash memory device. However, the invention is not limited in this respect, and there may be more than one NAND flash memory device which is operated according to the principles of the invention described above. For example, each of the NAND memory devices may be associated with a particular respective portion of the logical address space, and there may be a variable mapping for each NAND memory device betv/een blocks of that memory<br><br>
device and respective regions of the corresponding portion of the logical address space.<br>
As mentioned above, the invention may be implemented via a USB connection - although it is not limited in this respect. It is preferred that the USB standard employed by the USB controller is version USB2.0, but the present invention may be implemented with any other versions of the USB standard, such as any versions which are introduced in the future.<br>
The total memory capacity of the device is not limited within the scope of the invention, but is preferably at least 1Mbyte, and more typically at least 10Mbytes, at least 100Mbytes or even at least 1Gbyte.<br><br>
WE CLAIM:-<br>
1.        A portable data storage device including:<br>
(i) a data interface for transferring data packets into and out of the device,<br>
(ii) an interface controller,<br>
5	(iii) a master control unit, and<br>
(iv) at least one NAND flash memory unit,<br>
the interface controller being arranged to send data received through the interface to the master control unit, and<br>
the master control unit being arranged to recognise certain data packets as         10     encoding READ instructions and other data packets as encoding WRITE instructions:<br>
(a)	upon receiving a READ instruction indicating a logical address, to access<br>
a memory address mapping table which associates logical address regions within a<br>
logical memory space with respective first physical address regions within the at least<br>
one NAND flash memory unit, to read data from a physical address in the at least<br>
15   one NAND flash memory unit corresponding to the logical address according to the memory address mapping table, and to transmit to the data interface one or more data packets including the data which was read, and<br>
(b)	upon receiving a WRITE instruction indicating a logical address and data<br>
to  be  written  to  that  logical  address,  to  determine  if the  physical  address<br>
20    corresponding to the logical address according to the memory address mapping table is in the erased state so that data can be written into the physical address, and:<br>
if so, to write the data to that physical address, or<br>
if not, to modify the memory address mapping table in accordance with a<br>
block queue listing one or more queuing physical address regions, to associate a<br>
25     second physical address region which, with the logical address region containing the<br>
logical address, is the queuing physical address region at the head of the block<br><br><br>
queue, to write the data to a physical address corresponding to the logical address according to the modified memory address mapping table, and to copy any data stored in other potions of the first physical address region to corresponding locations of the second physical address region,<br>
5       wherein data defining the memory address mapping table is stored as mapping data in   the at least one NAND flash memory unit, the master control unit being arranged to modify the mapping data upon modifying the memory address mapping table; and wherein the master control unit is arranged, upon being initiated, to extract the mapping data from the at least one NAND flash memory unit and generate the                                                              <br>
10     memory address mapping table within RAM memory.<br>
2.	A device according to claim 1 in which the portion of the mapping data<br>
defining the mapping between each respective physical address region and a logical<br>
address region is stored within that physical address region.<br>
4<br>
3.	A device according to claim 2 in which the mapping data relating to a given<br>
15     physical address region is stored in the control data storage sector of one or more<br>
pages of the physical address region.<br>
4. A device according to any preceding claim in which following said modification of the address mapping table, the block queue is modified to place the first physical address region at the rear of the block queue.<br>
20      5. A device according to any of the preceding claims in which the queuing physical memory regions are in the erased state.<br>
6. A device according to any of the preceding claims in which the physical<br>
memory space further includes reserved physical memory regions which cannot<br>
become associated with the logical addresses under the operation of the master<br>
25     control unit which modifies the memory address mapping table.<br>
7.	A device according to any preceding claim in which the physical address<br>
regions are respective blocks of the memory unit.<br><br>
8.	A device according to any of claims 1 to 6 in which the physical address<br>
regions are groups of blocks in the memory unit, the groups being defined according<br>
to a grouping table.<br>
9.	A device according to claim 8 in which the majority of groups of blocks are<br>
5     defined according to a rule, and the grouping table defines groups which are<br>
exceptions to the rule.<br>
10.	A device according to claim 9 in which the memory address mapping table<br>
contains a flag in respect of any logical address region which is associated with one<br>
of the groups which are exceptions to the rule.<br>
10    11. A device according to any of claims 8 to 10 in which the master control unit associates consecutively following logical addresses within a logical address region with respective pages in different ones of the blocks.<br>
12.	A device according to claim 11 in which the master control unit associates<br>
consecutive logical addresses into sets, each of the sets of logical addresses having<br>
15     a number of members equal to the number of blocks in each group, and for each given set the master control unit associates the logical addresses of that set with corresponding pages of the respective blocks.<br>
13.	A device according to any preceding claim in which the master control unit is<br>
arranged, in response to receiving a first WRITE instruction to implement the write<br>
20    instruction only upon determining that, within a predefined period, a second WRITE instruction is not received obeying a predefined similarity criterion.<br>
14.	A device according to claim 13 in which, following a modification of the<br>
memory address modification table in relation to a given logical address region, and<br>
prior to said copying of the data from the first physical address region to the new<br>
25   second physical address region, said criterion is whether the second WRITE instruction relates to a logical address corresponding to the location within the given logical address region of the data to be copied, and in the case that such a WRITE instruction is received aborting said copying operation and instead writing data<br><br><br>
specified by the second WRITE instruction to the location of the second physical address region.<br>
15.	A device according to claim 13 in which the master control unit has access to<br>
a data cache and in response the first WRITE instruction writes the data to the data<br>
5 cache, said criterion being that the second WRITE instruction relates to the same logical address as the first WRITE instruction, in the case that the determination is positive the data specified in the second WRITE instruction being written to the data cache.<br>
16.	A device according to claim 13 in which the master control unit has access to<br>
10     a data cache and in response to the first WRITE instruction writes the data to the<br>
data cache provided that the first WRITE instruction relates to one or more selected logical addresses, said criterion being that the second WRITE instruction relates to the same logical address as the first instruction, in the case that the determination is positive the data specified in the second WRITE instruction being written to the data                                              15     cache.<br>
17.	A device according to claim 16 in which there are a plurality of said selected logical addresses.<br>
18.	A device according to claim 16 or 17 further including a pattern recognition unit for recognising logical addresses encoded in the first and second WRITE<br>
20     instructions which arise with relatively high frequency, and for setting said recognised logical addresses as said selected logical addresses.<br>
Dated this 27th day of July, 2006<br>
FOR TREK 2000 INTERNATIONAL LTD 25<br>
By their Agent<br>
30<br>
(GIRISH VIJAYANAND SHETH) KRISHNA &amp; SAURASTRI</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtYWJzdHJhY3QoMTgtMDMtMjAwOCkuZG9j" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-abstract(18-03-2008).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtYWJzdHJhY3QoMTgtMDMtMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-abstract(18-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtYWJzdHJhY3QuZG9j" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-abstract.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtYWJzdHJhY3QucGRm" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtY2FuY2VsbGVkIHBhZ2VzKDE4LTAzLTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-cancelled pages(18-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtY2xhaW1zKGdyYW50ZWQpLSgxOC0wMy0yMDA4KS5kb2M=" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-claims(granted)-(18-03-2008).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtY2xhaW1zKGdyYW50ZWQpLSgxOC0wMy0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-claims(granted)-(18-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtY2xhaW1zLmRvYw==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-claims.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtY2xhaW1zLnBkZg==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtY29ycmVzcG9uZGFuY2Utb3RoZXJzLnBkZg==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-correspondance-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtY29ycmVzcG9uZGFuY2UtcmVjZWl2ZWQucGRm" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-correspondance-received.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtY29ycmVzcG9uZGVuY2UoMTgtMDMtMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-correspondence(18-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtY29ycmVzcG9uZGVuY2UoaXBvKS0oMDMtMDQtMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-correspondence(ipo)-(03-04-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZGVzY3JpcHRpb24gKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZHJhd2luZygxOC0wMy0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-drawing(18-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZHJhd2luZ3MucGRm" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybSAxKDE5LTEwLTIwMDYpLnBkZg==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form 1(19-10-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybSAxKDI3LTA3LTIwMDYpLnBkZg==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form 1(27-07-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybSAxOCgyNy0wNy0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form 18(27-07-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybSAyKGdyYW50ZWQpLSgxOC0wMy0yMDA4KS5kb2M=" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form 2(granted)-(18-03-2008).doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybSAyKGdyYW50ZWQpLSgxOC0wMy0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form 2(granted)-(18-03-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybSAzKDIwLTEyLTIwMDcpLnBkZg==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form 3(20-12-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybSAzKDI3LTA3LTIwMDYpLnBkZg==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form 3(27-07-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybSA1KDI3LTA3LTIwMDYpLnBkZg==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form 5(27-07-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybS0xLnBkZg==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybS0yLmRvYw==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form-2.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybS0yLnBkZg==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybS0zLnBkZg==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybS01LnBkZg==" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtZm9ybS1wY3QtaXNhLTIxMCgyNy0wNy0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-form-pct-isa-210(27-07-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtcGN0LXNlYXJjaCByZXBvcnQucGRm" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-pct-search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=ODk3LW11bW5wLTIwMDYtcG93ZXIgb2YgYXR0b3JuZXkoMjctMDctMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">897-mumnp-2006-power of attorney(27-07-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLi5qcGc=" target="_blank" style="word-wrap:break-word;">abstract1..jpg</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="220728-method-and-system-for-analysing-respiratory-tract-air-flow.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="220730-method-for-the-production-of-a-fancy-yarn.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>220729</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>897/MUMNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>42/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>17-Oct-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>03-Jun-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>27-Jul-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>TREK 2000 INTERNATIONAL LTD.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>30 LOYANG WAY #07-13/14/15 LOYANG INDUSTRIAL ESTATE, SINGAPORE.</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>POO Teng Pin</td>
											<td>Blk 44 Bedok South Road #11-763, Singapore 460044</td>
										</tr>
										<tr>
											<td>2</td>
											<td>LIM Lay Chuan</td>
											<td>Block 322, Bukit Batok Street 33, #03-04, Singapore 650322</td>
										</tr>
										<tr>
											<td>3</td>
											<td>TAN HENRY</td>
											<td>1 PLAM DRIVE, SINGAPORE 456458.</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G11B11/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/SG2004/000017</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-01-19</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td></td>
									<td></td>
								    <td>NA</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/220729-portable-data-storage-device-using-a-memory-address-mapping-table by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:25:32 GMT -->
</html>
