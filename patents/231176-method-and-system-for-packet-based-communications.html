<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/231176-method-and-system-for-packet-based-communications by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:01:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 231176:METHOD AND SYSTEM FOR PACKET BASED COMMUNICATIONS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD AND SYSTEM FOR PACKET BASED COMMUNICATIONS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A compression context for a plurality of packets is established with a receiving device. Each of these packets is associated with one or more reliable multicast protocols, such as the Layered Coding Transform (LCT) protocol, the Asynchronous Layered Coding (ALC) protocol, the FLUTE protocol, the MUPPET protocol, and the NACK-Oriented Reliable Multicast (NORM) protocol. Upon establishment of the compression context, a compressed packet is generated for one of the plurality of packets and transmitted to the receiving device. The compressed packet has a reduced number of bits in its header. Upon receipt, the receiving device decompresses the compressed packet based on the compression context.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
METHOD AND SYSTEM FOR HEADER COMPRESSION<br>
This international application claims priority to U.S. Application Serial No. 10/739,066, filed December 19, 2003, entitled, "Method and System for Header Compression," of which the entire specification is incorporated herein by reference.<br>
FIELD OF THE INVENTION<br>
The present invention relates to packet-based communications. More particularly, the present invention relates to techniques for compressing packets.<br>
BACKGROUND OF THE INVENTION<br>
In wireless communications systems, such as cellular networks, bandwidth is often a valuable resource that should be conserved. Thus, there is a need for compression techniques. Currently, there are known compression techniques that are suitable for the compression of arbitrary data units, such as protocol packet payloads. These techniques involve compression algorithms, which vary from being mathematical (e.g., gzip) to grammatical (e.g., SDP dictionaries translating text fields to a bit encoded format).<br>
In the case of Internet Protocol (IP) based communications, overhead associated with packet headers consumes a considerable amount of communications bandwidth. For instance, an Internet Protocol, version 4 (IPv4) packet header requires 20 bytes, while an Internet Protocol, version 6 (IPv6) packet header requires 40 bytes. To address the amount of bandwidth consumed by packet headers, specialized compression schemes have been developed that are more effective on packet headers than general-purpose compression algorithms. In particular, specialized schemes have been developed for UDP/BP, ESP/IP and RTP/UDP/IP packets. For instance, one known header compression scheme is Robust Header Compression (ROHC). Another known header compression scheme is disclosed in M. Degermark et al.â€ž "IP Header Compression," RFC 2507, The Internet Society, February 1999 ("RFC 2507"). This document is incorporated herein by reference in its entirety and may be downloaded from http://www.ietf.org/rfc/rfc2507.txt.<br>
However, existing work on packet header compression has focused on audio/video streaming services such as Voice over IP employing RTP/UDP/IP transport.<br><br>
To this end, header compression is a known technique, especially for IP streaming where RTP/UDP/IP headers may be compressed from around 60 bytes to below 5 bytes.<br>
The Reliable Multicast Transport (RMT) Working Group of the Internet Engineering Task Force (IETF) is in the process of standardizing two categories of error-resilient multicast transport protocols. In the first category, reliability is provided through the use of forward error correction (FEC). In the second category, reliability is provided through the use of receiver feedback. Asynchronous Layered Coding (ALC) is a protocol instantiation belonging to the first category, while the NACK-Oriented Reliable Multicast (NORM) protocol belongs to the second category. These protocols employ UDP and IP protocols and may be used in various types of wireless multiple-access networks such as UMTS, WLAN, DVB-T and DVB-S.<br>
The ALC and NORM protocols are designed for the delivery of discrete binary objects, such as downloadable files. When deployed on wireless networks, it is desirable for these protocols to conserve bandwidth. Packet payload compression schemes such as gzip can be readily used for RMT protocols. However, the current options for compressing the headers of these protocol packets are limited. At best, ROHC only compresses UDP/IP portions of these packets. Also, the IP header compression scheme of RFC 2507 only compresses the headers of the IP protocol. In addition, this protocol has problems with transmission errors. Another compression mechanism, known as DEFLATE also causes problems with transmission errors because it does not provide any support for error recovery.<br>
SUMMARY OF THE INVENTION<br>
The present invention is directed to a method, system, and computer program product for the transmission of packets. The method, system, and computer program product establish with a receiving device a compression context for a plurality of packets. Each of these packets is associated with one or more reliable multicast protocols and includes a header having a plurality of header fields. Upon establishment of the compression context, a compressed packet is generated and transmitted to the receiving device. The compressed packet has a reduced number of bits in its header.<br>
The reliable multicast protocol(s) may include, for example, the Layered Coding Transform (LCT) protocol, the Asynchronous Layered Coding (ALC) protocol, the<br><br>
FLUTE protocol, the MUPPET protocol, and the NACKOriented Reliable Multicast (NORM) protocol<br>
The method, system, and computer program product may also identify one or -more header fields as compressible. For instance, each of a plurality of header fields may be placed into one of a plurality of categories. These categories may include a first category for header fields that do not change at all, a second category for header fields that change only occasionally, and a third category for header fields that change from packet-to-packet<br>
The present invention is further directed to a method, system, and computer program product for the reception of packets. This method, system, and computer program product establish a compression context for a plurality of packets with a transmitting device. These packets are each associated with a reliable multicast protocol (e.g., LCT, ALC, FLUTE, MUPPET, and/or NORM). Upon establishment of the compression context, a compressed packet having a reduced number of bits in its header is received from the transmitting device. This compressed packet is then decompressed based on the compression context.<br>
The present invention advantageously provides for the efficient utilization of communications bandwidth. Further features and advantages of the present invention will become apparent from the following description and accompanying drawings.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
In the drawings, like reference numbers generally indicate identical, functionally similar, and/or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit(s) in the reference number. The present invention will be described with reference to the accompanying drawings, wherein:<br>
FIGs. 1 and 2 are block diagrams of exemplary operational environments;<br>
FIG. 3 is a diagram showing ROHC compression of a UDP packet;<br>
FIG. 4 is a diagram showing ROHC compression of an RTP packet;<br>
FIG. 5 is a diagram illustrating ROHC operational states;<br>
FIG. 6 is a diagram of an Layered Coding Transform (LCT) header;<br><br>
FIG. 7 is a diagram of an Asynchronous Layered Coding (ALC) header;<br>
FIG. 8 is a diagram of a File Delivery over Unidirectional Transport (FLUTE) header;<br>
FIG. 9 is a diagram showing the compression of ALC/LCT packet header fields;<br>
FIG. 10 is a flowchart of a transmitting device employing header compression in one embodiment of the present invention;<br>
FIG. 11 is a diagram illustrating operational states machine for a compressor, according to the present invention;<br>
FIG. 12 is a flowchart of a receiving device employing header compression in one embodiment of the present invention; and<br>
FIG. 13 is a diagram of an exemplary computer system. DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS<br>
I.	Operational Environment<br>
Before describing the invention in detail, it is helpful to describe environments in which the invention may be used. Accordingly, FIGs. 1 and 2 are block diagrams of operational environments where header compression techniques are employed to conserve communications bandwidth.<br>
FIG. 1 shows an environment in which a first host 102a transmits packets across a packet-based network 104 to a second host 102b. To conserve the bandwidth of network 104, header compression is performed on these packets. This compression may be in accordance with various techniques, such as the ones described herein. Accordingly, host 102a compresses the protocol headers of one or more of the packets sent to host 102b. Upon receipt, host 102b decompresses these headers,<br>
FIG. 1 shows that host 102a includes an Internet Protocol (IP) packet source 106, a compressor 108, a sender 110, and a compression context database 112. Host 102b includes a receiver 114, a decompressor 116, an IP packet sink 118, and a compression context database 120.<br><br>
IP packet source 106 places information into one or more IP packets 130. This information may be received, for example, from higher layer protocols or an application (not shown). Accordingly, packets 130 may include one or more headers, each header being associated with a particular protocol. Examples of such protocols include ALC, LCT, FLUTE, MUPPET, NORM, UDP, and IP.<br>
As shown in FIG. 1, compressor 108 receives packets 130 and compresses them to produce compressed packets 132. Sender 110 encapsulates compressed packets 132 into one or more layer two (i.e., link layer) packets or frames 136, which are transmitted across network 104 to host 102b.<br>
Host 102b includes a receiver 114, a decompressor 116, an IP packet sink 118, and a context database 120. Receiver 114 extracts the encapsulated compressed packets 132 from link layer packets 136. Decompressor 116 performs header decompression on these compressed packets to recover IP packets 130. IP packet sink 118 may include one or more higher layer protocols and applications (not shown), which process packets 130.<br>
Network 104 provides a connection between hosts 102a and 102b. Accordingly, network 104 may include a wireless local area network (WLAN) link or an Ethernet switch.<br>
In the environment of FIG. 1, the operation of both compressor 108 and decompressor 116 are controlled by compression-related state information, known as compression contexts. These contexts are stored in context databases 112 and 120.<br>
The environment of FIG. 2 is similar to the environment of FIG. 1. However, this environment includes hosts 202a and 202b, which do not perform header compression and decompression. Rather, in this environment, header compression/decompression operations are performed by gateways 204a and 204b.<br>
As shown in FIG. 2, each host 202 communicates with a corresponding gateway 204 via an access network 206. More particularly, host 202a communicates with gateway 204a via an access network 206a, while host 202b communicates with gateway 204b via an access network 206b. Gateways 204a and 204b communicate across a packet-based network 208.<br>
Host 202a includes an IP packet source 210, which places information into one or more IP packets 240. This information may be received, for example, from higher layer<br><br>
protocols or an application (not shown). Host 202a also includes a sender 212 to encapsulate packets 240 into one or more layer two (i.e., link layer) packets or frames 242, which are transmitted across access network 206a to gateway 204a.<br>
As shown in FIG. 2, gateway 204a includes a receiver 218, a compressor 220, a compression context database 222, and a sender 224. Receiver 218 receives packets 242 from access network 206a and extracts encapsulated IP packets 240 from them. Compressor 220 compresses IP packets 240 to produce compressed packets 244. Sender 224 encapsulates compressed packets 244 into one or more layer two packets or frames 246, which are transmitted across network 208 to gateway 204b.<br>
Gateway 204b includes a receiver 226, a decompressor 228, a compression context database 230, a decompressor 228, and a sender 232. Receiver 226 receives packets 246 from network 208 and extracts compressed packets 244 from them. Decompressor 228 decompresses compressed packets 244 into IP packets 240. Sender 232 encapsulates IP packets 240 into link layer packets 248, which are sent to host 202b.<br>
Host 202b includes a receiver 214 and an IP packet sink 216. Receiver 214 extracts the encapsulated IP packets 240 from link layer packets 248. IP packet sink 216 may include one or more higher layer protocols and applications (not shown), which process packets 240.<br>
In the environment of FIG. 2, the operation of both compressor 220 and decompressor 228 are controlled by compression contexts, which are stored in context databases 222 and 230.<br>
Hie environments of FIGs. 1 and 2 are described in the context of one host 102 or gateway 204 acting in a compression role, while another host 102 or gateway 204 acts in a decompression role. However, each host 102 or gateway 204 may act in either or both of these roles. Moreover, in the environments of FIGs. 1 and 2, networks 104, 206, and 208 may involve various types of technologies. For example, one or more of these networks may include local area networks (LANs), such as Ethernet and/or larger network infrastructures, such as the Internet. Also, one or more of these networks may utilize wireless technologies. For instance, these networks may include wireless LANs (e.g., IEEE 802.11) and/or other short-range' communications networks, such as Bluetooth.   Further, these networks may include cellular-based infrastructures, such as<br><br>
GSM, Enhanced Data GSM Environment (EDGE), IS-95, and/or General Packet Radio Service (GPRS).<br>
EL       ROHC Compression<br>
RObust Header Compression (ROHC) is a technique for reducing the amount of headers transmitted over bandwidth limited channels. ROHC is described in C. Burmeister et al., "RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed/5 RFC 3095? The Internet Society July 2001 ("RFC 3095")- This document is incorporated herein by reference in its entirety and may be downloaded from http://www.ietf.org/rfc/rfc3095.txt.<br>
FIG. 3 is a diagram showing ROHC compression of a UDP packet. This compression begins with an uncompressed IP packet 302, which includes an IP header 308, a UDP header 310, and a UDP payload 312. Through ROHC compression techniques, a compressed ROHC packet 304 is generated from IP packet 302. As shown in FIG. 3, compressed ROHC packet 304 includes an ROHC header 314 and UDP payload 312. ROHC header 314 is generated by compressing one or more fields in IP header 308 and UDP header 310.<br>
In order to transmit compressed ROHC packet 304 across a network, a layer two packet 306 is generated from compressed ROHC packet 304. Layer two packet 306 includes UDP payload 312, a layer two header 316, and a layer two trailer 318.<br>
FIG. 4 is a diagram showing ROHC compression of an RTP packet. This compression begins with an uncompressed EP packet 402. As shown in FIG. 4, IP packet 402 includes an IP header 408, a UDP header 410, an RTP header 412, and an RTP payload 414. Through ROHC compression techniques, a compressed ROHC packet 404 is generated from IP packet 402. FIG. 4 shows that compressed ROHC packet 404 includes an ROHC header 416 and RTP payload 414. ROHC header 416 is generated by compressing one or more fields in EP header 408, UDP header 410? and RTP header 412.<br>
From compressed ROHC packet 404, a layer two packet 406 is generated for transmission. Layer two packet 406 includes RTP payload 414, a layer two header 418, and a layer two trailer 420.<br><br>
RFC 3095 defines four different profiles: an uncompressed profile , an RTP profile, a UDP profile and an ESP profile. In addition, RFC 3095 defines three operational modes. These modes are a unidirectional mode, a bidirectional optimistic mode, and a bidirectional reliable mode. The employed mode controls the logic of transitions between various states as well as actions performed in each of these states. These states described below with reference to FIG. 5.<br>
When operating in the unidirectional mode, packets are only sent in the direction from a compressor to a decompressor. This mode therefore makes ROHC suitable for communications environments where a return path from a decompressor to a compressor is not available.<br>
ROHC is based on defining a compression context for both the compressor (also referred to herein as a transmitter or sender) and its corresponding decompressor (also referred to herein as a receiver). This context includes a static part that does not change for a stream of packets and a dynamic part that may change for a stream of packets. The dynamic part includes header fields that change from packet to packet. Such header fields must be sent in every packet. Depending on a dynamic field's compression possibilities, it may be transmitted in compressed form or "as is". In contrast, the static part includes header fields that are either constant or change in a predictable manner. Accordingly, the static part may be compressed or even eliminated.<br>
FIG. 5 is a diagram illustrating various ROHC operational states. As shown in FIG. 5, an ROHC compressor may operate in three states. These states include an initialization and refresh (IR) state 502, a first order (FO) state 504, and a second order (SO) state 506. FIG. 5 also shows various transitions between these states. In the unidirectional mode, transitions between the states of FIG. 5 only occur when certain time periods have elapsed or when certain irregularities in the header fields exist. This is because the decompressor provides no feedback to the compressor in the unidirectional mode.<br>
During operation, the compressor starts in IR state 502, the compressor sends packets with the complete header information (both static and dynamic fields). In addition, the compressor may optionally analyze the packet headers to determine which header fields can be compressed. By observing the packets transmitted in IR state 502, the compressor and decompressor are able to store information, such as header field<br><br>
reference values as well as patterns of change for header fields. These reference values and patterns of change establish a compression context for the compressor and decompressor.<br>
This compression context is identified by a compression context identifier (CID). The CID may be included in header-compressed packets to differentiate between multiple compression contexts used on the same transport channel. However, the CID may be left out of these packets if only one context is used on a transport channel The CID may be delivered in several different ways, either in-band (in the compressed headers) or out-of-band.<br>
After sending enough packets to allow the receiver to learn the values of the static fields and the pattern of change in dynamic fields, the transmitter enters either FO state 504 or SO state 506.<br>
In FO state 504, the compressor sends one or more packets (referred to herein as FO packets) containing a sequence number and information on one or more (typically not all) changed header fields. Most of this information is in the form of "deltas" between the value of the field in the current and the most recently transmitted packet. These deltas are usually at least partially compressed. However, in FO state 504, some information (such as irregularities) are transmitted in uncompressed form. Decompressors are able to reproduce any fields not included in an FO packet (such as static fields) based on the compression context or the combination of the compression context and the packet's sequence number.<br>
The compressor enters FO state 504 when irregular or infrequent changes occur in some header fields. As a result of such changes, the compression context is updated at the compressor and the decompressor. After sending enough packets to allow the decompressor to learn the new change pattern in header fields, the compressor typically transits from FO state 504 to SO state 506. However, when error conditions occur, the compressor enters IR state 502.<br>
In SO state 506, the compressor provides an optimal header compression by just sending a sequence number instead of the actual values of the packet header fields. In this state, decompressors are able to reproduce static fields based on the compression context, and dynamic fields based on the combination of the compression context and the<br><br>
sequence number. Accordingly, SO state 506 can only be used when there are no unexpected changes in any of the header fields.<br>
The compressor remains in SO 506 state until the expiration of a timer or a sequence counter, or until a major change occurs in the header patterns of the packets being transmitted. From SO state 506, the compressor may enter either FO state 504 or IR state 502. A transition to the IR state 502 may be triggered by packet loss rates that are estimated by the compressor or reported by decompressors.<br>
ROHC basically defines five types of packets to provide flexible communication tools to transfer the dynamic and static parts of header information. These packet types are IR packets, IR dynamic (IR-DYN) packets, type 0 packets, type 1 packets, and type 2 packets.<br>
IR packets are the largest of the packet types and contain all the static information of the header fields. IR packets may also contain the dynamic part, but this is not required. These packets are used in the beginning to initialize the context and after the periodical transitions to IR state. IR dynamic (IR-DYN) packets contain all the dynamic data of the headers.<br>
Type 0 packets are the most compressed packets defined for ROHC. These, packets contain only a compressed RTP (or ROHC specific in non RTP profiles) sequence number, a cyclical redundancy check (CRC), and generally a context ID that specifies the particular context. The context ID is left out of the header if its value is zero. Thus, in this case, absence of the field tells the decompressor the correct value.<br>
Type 1 packets are longer than type 0 packets. Type 1 packets are used if the compressed sequence number needs more bits than available in the type 0 header, or if an irregular change occurs in either the IPv4 Identification (IP-ID) field or the RTP timestamp. The header contains also (possible) context ID and longer CRC than type 0 header. It is also possible to include extensions to one subtype of this packet (the one containing IP-ID) if other fields need updates. More details on this packet can be found in RFC 3095.<br>
Type 2 packets are the largest of these compressed packets. This packet type has even more bits available for the compressed sequence number, has even larger CRCs, and contains either a compressed update of the IP-ID or the RTP timestamp. All the subtypes<br><br>
of the packet can have extensions attached.  More information about the type 2 packets and the available extensions are disclosed in RFC 3095.<br>
After initializing the context and the first transition to. SO state 506, the compressor should always select the packet type that sends all the necessary7 information but does not contain anything redundant. The only exception to this rule exists in the unidirectional mode. More particularly, the unidirectional mode involves periodical transitions to IR state 504 and FO state 506 so that the compressor may send initialization data in case the decompressor has lost the context (there is no return path and hence no feedback from the decompressor to the compressor).<br>
According to ROHC, compressed headers are encoded for transmission using a minimal or reduced number of bits for each compressed field compared to the original field. For static fields, the length of the compressed field is zero bits. However, for other compressed fields, the compressor may employ variable length encoding (VLE). VLE encodes the length of the field in the field itself.<br>
VLE is based on the observation that fields from consecutive headers often tend to have the same most significant bits (MSBs) and differ only by their least significant bits (LSBs). Accordingly, VLE is achieved by transmitting only the differing least significant bits from a header field.<br>
A specific VLE example employs a mathematical function dependent on a number of transmitted LSBs and a reference value. This reference value may be based on a previous header field value, such as the header field value from the most recently transmitted packet. Such a function is shown below in Equation (1).<br>
f(k,v_ref) = (v1, v_2,.. , v_2k)       (1)<br>
In Equation (1), k represents a transmitted number of bits in a VLE compressed header field, and v__ref represents a reference value for the corresponding header field. Each combination of k and vjref provides a set of possible header field values (i.e., v_l, v_2, . . . v_2k). Upon receipt of a VLE compressed field, the receiver may employ the function of Equation (1) to determine the header field value corresponding to the transmitted k-bits. This determination may involve finding the header field value of Equation (1) having k LSBs that match the transmitted k-bits.   Examples of such VLE.<br><br>
compression techniques are described in International Publication Number WO 01/35534 A2 (incorporated herein by reference in its entirety).<br>
In embodiments, VLE .compressed header fields may be further compressed through techniques, such as Huffman encoding. Huffman encoding is a statistical based compression technique in which the probability of a symbol (i.e., one or more bits) has a direct bearing on the length of its compressed representation.<br>
For each compression context, the transmitter typically sends a series of packets, providing an identifier such as a sequence number for identifying the position of each transmitted packet within a sequence. Such a sequence is called a compression window. One or more packets in the beginning of a compression window are transmitted without header compression (i.e., in IR state 502). This provides an initial reference for the compressed packet headers.<br>
As more packets are transmitted, previously transmitted packets are used as the reference for header compression. Typically, such a reference packet is the packet transmitted just before the current packet. However, any of the packets transmitted within a given compression window can be used as a reference.<br>
The sequence number for enumerating packets within a compression window may be provided in various ways. For instance, the sequence number may be provided explicitly in the ROHC header. Alternatively, the sequence number may be provided by a sequence counter field in any of the protocol headers being compressed (e.g., the sequence count field of RTF or FLUTE). In ROHC, the sequence number itself is compressed using techniques such as VLE.<br>
The length of the compression window is inversely proportional to the efficiency of compression. Thus, to increase compression efficiency, the size of the compression window must be periodically reduced. This may be achieved by either discarding the oldest packets in the sequence or by entering IR state 502 to start a new sequence. In ROHC, older packets are discarded from the compression window as the receiver acknowledges the reception of those packets.<br><br>
III.      Multicast Transmission<br>
The present invention provides for header compression techniques for various reliable multicast protocols. Four such multicast protocols are Asynchronous Layered Coding (ALC), File Delivery over Unidirectional Transport (FLUTE), Internet Media Guide Unidirectional Point-to-Multipoint Transport (MUPPET), and NACK-Oriented Reliable Multicast (NORM).<br>
A.       ALC<br>
ALC is a protocol described in M. Luby et al., "Asynchronous Laj'ered Coding (ALC) Protocol Instantiation," RFC 3450, The Internet Society, December 2002 ("RFC 3450"). This document is incorporated herein by reference in its entirety and may be downloaded from http://www.ietf.org/rfc/rfc3450.txt.<br>
ALC provides congestion controlled reliable asynchronous delivery of content to an unlimited number of concurrent receivers from a single sender. This is performed by utilizing a Layered Coding Transport (LCT) building block, a multiple rate congestion control building block, and a Forward Error Correction (FEC) building block. ALC is designed to be used with the IP multicast network service and does not require feedback packets from receivers to the sender. Information, referred to as objects, are transferred from a sender to one or more receivers in an ALC session.<br>
ALC can support several different reliable content delivery sendee models. One such model is called the push service model, involves the concurrent delivery of objects to a selected group of receivers. Another model is called the on-demand content delivery service model. In this model, a sender transmits an object (e.g., software) for a time period. During this time period, receivers may join the session and recover the object. This time period may be much longer in duration than the time required for a receiver to download the object. Thus, receivers join the session during such a time period and leave the session when they have received enough packets to recover the object. Such sessions are identified by a session description, which may be obtained, for example, through a web server.<br>
ALC uses a packet format that includes a UDP header followed by an LCT header, an FEC payload ID, and a packet payload. This arrangement is shown in FIGs. 6 and 7.<br><br>
LCT is described in Luby, et ah, "Layered Coding Transport (LCT) Building Block", RFC 3451, The Internet Society, December 2002. This document may be downloaded from http://www.ietf.org/rfc/rfc3451.txt. LCT provides transport level support for reliable content delivery and stream delivery protocols.<br>
An LCT session includes one or more related LCT channels that originate at a single sender. The channels are used for a period of time to convey packets containing LCT headers. These packets may be received by one or more receivers. Although LCT requires a connection from a sender to receiver(s), it does not require a connection from the receivers) to the sender. Accordingly, LCT may be used for both unicast and multicast delivery.<br>
FIG. 6 is a diagram of an LCT header, showing that the LCT header includes various fields. These fields are described in Table 1, below.<br><br><br><br><br><br>
Table 1 indicates that the CCI field is used to cany congestion control information, such as layer numbers, logical channel numbers, and sequence numbers. The CCI field may include various elements, such as a packet sequence number (PSN) that is incremented between each consecutive ALC/LCT packet, a current time slot index (CTSI) that is incremented periodically with a constant time interval, and a channel number (CN) that conveys a label varying within the range of at most 255 different values. In embodiments of the present invention, these fields may be handled by an ROHC mechanism.<br>
FIG. 7 is a diagram of an ALC header. As described above, ALC utilizes LCT as a building block. Accordingly, this diagram shows that the ALC header includes the LCT fields of FIG. 6, as well as an FEC payload ID field. FEC payload ID field identifies the encoding symbol(s) in the payload of the packet. This field is in a format described in Luby et al., "Forward Error Correction (FEC) Building Block", RFC 3452, The Internet Society, December 2002. This document is incorporated herein by reference in its entirety and ma)' be downloaded from http://www.ietf.org/rfc/rfc3452.txt. A brief description of this field is provided below in Table 2.<br><br><br>
B.        FLUTE<br>
FLUTE is a protocol that builds on ALC to provide for the unidirectional delivery of files over the Internet. FLUTE is described in the Internet Draft by Paila; et ah, entitled "FLUTE - File Delivery over Unidirectional Transport," November 14, 2003. This document is incorporated herein by reference and may be downloaded from http:/Avww.ietÂ£org/intemet-drafts/draft-ietf-rmt-flute-06.txt.<br>
In particular, FLUTE provides for the signaling and mapping of properties of files to ALC concepts so that receivers may assign those parameters for received objects. According to FLUTE, files may be transferred to one or more receivers during a file delivery session. These files may include file delivery tables. A file delivery table describes various attributes associated with a particular file. For a given file, examples of such attributes include an object identifier value representing the file, forward error correction encoding information, file location, file name, MIME media type of the file, size of the file, and encoding of the file.<br>
To start receiving a file delivery session, the receiver obtains transport parameters associated with the session. The receiver then joins the session's channel(s) to receive ALC/LCT packets associated with the session. These ALC/LCT packets are demultiplexed according to their object identifiers and stored so that the corresponding files may be recovered. At least one of these files is an FDT, which is stored in the receiver's FDT database. When other files are received, the receiver accesses its FDT database to assign properties according to the corresponding FDT database entry.<br>
FIG. 8 is a diagram showing various fields of a FLUTE header. These fields include LCT and ALC header fields of FIGs. 6 and 7. In addition, the FLUTE header includes an FEC Object Transmission Information Extension portion 802, an FDT Instance Extension portion 804, and an FDT Instance Compression Extension portion 806.<br>
FDT Instance Extension portion 804 is used to indicate the transmission of FDT information. FEC Object Transmission Information Extension portion 802 is used to convey FEC coding information, such as the employed FEC coding method.<br>
As shown in FIG. 8, FEC Object Transmission Information Extension portion 802, FDT Instance Extension portion 804, _and FDT Instance Compression Extension<br><br>
portion 806 each include multiple fields. Descriptions of these fields are provided below â€¢ in Table 3.<br><br>
In FLUTE, the FEC Encoding ID (8 bits) is carried in the Codepoint field of the ALC/LCT header. FEC Encoding IDs 0, 128 and 130 are presently specified by FLUTE. As indicated in Table 3, the FEC Instance ID field is optional. This field is used for FEC Instance ED. However, it is only present if the value of the FEC Encoding ID is in the range of 128-255. When the value of the FEC Encoding ID is in the range of 0-127, this field is set to 0. Different FEC encoding schemes will need different sets of encoding parameters. Thus, the structure and length of this field depends on the FEC Encoding ID.<br><br>
C.	MUPPET<br>
MUPPET is a unidirectional point-to-multipoint transport protocol for the delivery of Internet Media Guide (IMG) metadata. MUPPET is described in the Internet Draft by J. Luoma, entitled "MUPPET: Internet Media Guide Unidirectional Point-to-Multipoint Transport,55 June 30, 2003. This document is incorporated herein by reference and may be downloaded from http://www.watersprings.org/pub/id/draft-luoma-mmusic-img-muppet-02.txt.<br>
MUPPET is based on ALC and uses IP multicast delivery to provide an IMG descriptor transport service. More particularly, MUPPET provides an IMG sender with unidirectional transport for its IMG metadata within an IMG session, which includes one or more IMG channels. Each IMG channel is implemented as a separate ALC session. MUPPET re-uses the packet format of ALC. Thus, the payload of the MUPPET protocol (e.g., IMG descriptor tables and IMG objects), are conveyed as ALC encoding symbols.<br>
D.	NORM<br>
NACK-Oriented Reliable Multicast Protocol (NORM) provides reliable transport of bulk data objects or streams over generic IP multicast routing and forwarding services. NORM uses a selective, negative acknowledgement mechanism for transport reliability and offers additional protocol mechanisms to conduct reliable multicast sessions with limited "a priori" coordination among senders and receivers. NORM also provides congestion control feature to promote sharing of network bandwidth with other transport protocols such as Transmission Control Protocol (TCP).<br>
NORM is described in the Internet Draft by B. Adamson, entitled "NACK-Oriented Reliable Multicast Protocol (NORM)," March, 2003. This document is incorporated herein by reference and may be downloaded from http://watersprings.org/pub/id/draft-ietf-mit-pi-norm-06.txt.<br>
IV.      Multicast Header Compression<br>
As described above, the present invention provides header compression for reliable multicast transport protocols, such as ALC, FLUTE, MUPPET, and NORM. As an example of such compression, FIG. 9 is a diagram showing header compression of an<br><br>
ALC/LCT packet according to the present invention. This compression begins with an uncompressed ALC/LCT packet 902, which includes an IP header 908, a UDP header 910, an ALC/LCT header 912, and an ALC/LCT payload 914. Through header compression techniques, a header-compressed packet 904 is generated from IP packet 902. As shown in FIG. 9, header-compressed packet 904 includes a compressed header 916 and ALC/LCT payload 914. Compressed header 916 is generated by compressing one or more fields in IP header 908 and UDP header 910, and ALC/LCT header 912 according to a compression context. This compression may be based on ROHC techniques and/or further multicast header compression techniques described herein.<br>
In order to transmit header-compressed packet 904 across a network, a layer two packet 906 is generated from header-compressed packet 904. As shown in FIG. 9, layer two packet 906 includes ALC/LCT payload 914, a layer two header 918, and a layer two trailer 920.<br>
FIG. 10 is a flowchart of a packet transmission technique according to the present invention. This technique may be performed by various communications devices, such as host 102a and gateway 204a. Furthermore, this technique may be employed with various protocols. For instance, this technique may be employed with ALC/LCT/UDP/IP packets, FLUTE/ALC/LCT/UDP/IP packets, MUPPET/ALC/LCT/UDP/IP packets, and NORM/UDP/IP packets.<br>
The flowchart of FIG. 10 is described with reference to a transmitting device that transmits packets to one or more receiving devices. Accordingly, this technique may be employed in the operational environments of FIGs. 1 and 2. For example, in the environment of FIG. 1, host 102a operates as a transmitting device, while host 102b operates as a receiving device. However, in the environment of FIG. 2, gateway 204a operates as a transmitting device, while gateway 204b operates as a receiving device, hi addition to the environments of FIGs. 1 and 2, the technique of FIG. 10 may be employed in further environments.<br>
The flowchart of FIG. 10 includes a step 1002. In this step, before passing one or more packets to a Layer 2 protocol for transport, the transmitting device analyses headers of multiple protocol layers to discover any redundant information. This step may comprise identifying fields of one or more packet headers  containing redundant<br><br>
information. These redundancies may be between multiple fields within a single packet header and/or between the same fields in different packet headers.<br>
In a'step 1006, the transmitting device designates the fields containing redundant information as compressible fields. This step may include assigning header fields to various categories. Such categories may indicate, for example, how often the corresponding fields change.<br>
In a step 1008, the transmitting device establishes a context with one or more receiving devices. This may be established by transmitting one or more of the packets Avith uncompressed headers to the receiving device(s). Such transmissions may rely on an underlying layer 2 protocol. To establish a context, step 1008 may include the transmitting device storing current values for one or more packet header fields. In addition, this step may include the transmitting device identifying one or more patterns of change in header fields.<br>
In a step 1009, the transmitting device compresses the headers of one or more packets. This results in compressed packets having headers with a reduced number of bits.<br>
ha a step 1010, the transmitting device transmits packets with compressed headers. These compressed headers have a reduced number of bits. This compression may be implemented in various ways. For instance, the transmitting device may only transmit changes in compressible field values between successive packets. Also, the transmitting device may reduce or eliminate redundant information between two or more fields in a single packet. These two or more fields may be within a single protocol header or within multiple protocol headers.<br>
Through the compression and transmission of packets in steps 1009 and 1010, the transmitting device and the receiving device(s) maintain state information for each of the header fields. This state information is used by the receiving device(s) to recover the header information transmitted in compressed form. With reference to the environments of FIGs. 1 and 2, this information may be stored in compression context databases 112, 120, 222, and 230. This information may be stored as one or more variables. For example, in embodiments, each variable corresponds to a particular header field.<br><br>
Periodically, the transmitting device (or the receiving device) may desire to reinitialize the context information. Accordingly, in a step 1012, the transmitting device determines whether to reinitialize the compression context. This determination may be based various factors, such as the number of packets transmitted or the time elapsed since establishing the context in step 1008. If the transmitting device desires to re-initialize the compression context, then operation returns to step 1008. With reference to the states of FIG. 5, this step may comprise a transition to IR state 502 from either FO state 504 or SO state 506. If Hie transmitting device does not desire to re-initialize the context, it continues to compress and transmit packets in steps 1009 and 1010.<br>
The technique of FIG. 10 advantageously improves bandwidth efficiency and robustness of downlink packet flow, for example, in multicast applications such as file delivery (discrete media transfer). Moreover, this technique significantly improves the suitability of protocols, such as FLUTE (ALC file delivery) and MUPPET (IMG announcement) to wireless mobile applications.<br>
V.       Classification of Fields<br>
As described above with reference to FIG. 10, a transmitting device may designate certain fields as compressible fields in step 1006. This step may comprise placing each header field into one or more compressible categories. Thus, the present invention provides a classification technique for header fields. According to this technique, each header field may be classified as a Class 1 field, a Class 2 field, or a Class 3 field. Class 1 fields are header fields that do not change at all for a sequence of packets (e.g., during an LCT session). Class 2 fields are header fields that change only occasionally for a sequence of packets. Class 3 fields are header fields that change from packet-to-packet for a sequence of packets. Thus, according to the present invention, Class 1 fields may be compressed most of the time, Class 2 fields may be compressed some of the time, and Class 3 fields must be sent as is.<br>
An exemplary classification of the ALC and LCT fields of FIGs. 6 and 7 is provided below in Table 4. Also, an exemplary classification of FLUTE header fields of FIG. 8 is provided below in Table 5. However, other classifications are within the scope of the present invention.<br><br><br><br><br>
VI.      Compression States<br>
The present invention provides for compression of multicast headers, such as ALC, LCT, FLUTE, and NORM headers, by employing ROHC techniques. Accordingly, in embodiments, a compressor may operate in various operational states. For instance, a compressor may operate according to the states of FIG. 5. With reference to the header field classifications described above, a transmitting device transmits packets with complete header information (both static and dynamic fields) in IR state 502 to store information on the reference values and pattern of change in header fields. This establishes a compression context with the transmitting device and one or more receiving devices. As described above with refernce to FIG. 10, such a compression context is established in step 1008.<br>
In ALC/LCT, header fields are more likely to be similar when the same value of Transport Object Identifier (TOI) is used compared to when the TOI value differs in ALC/LCT packets transmitted consecutively by the same transmitting device. For example, the FEC parameters are guaranteed to remain unchanged within each TOI of an ALC/LCT session, but may differ between different TOIs. Thus, in embodiments of the present invention, a distinct compression context for each TOI in the same ALC/LCT session are used to improve the efficiency of ALC/LCT header compression, compared to using just a single context for all the TOIs.<br>
In further embodiments of the present invention, a distinct compression context for each Transport Session Identifier (TSI) in the same ALC/LCT session may be used to<br><br>
improve the efficiency of ALC/LCT header compression. This is because there also tends to be similarity between packet header of the same session.<br>
After sending enough packets to allow the receiving device to learn the values of the static fields and the pattern of change in dynamic fields, the transmitter enters either FO state 504 or SO state 506.<br>
In FO state 504, the transmitting device transmits one or more packets (referred to herein as FO packets) containing a sequence number and information on one or more (typically not all) changed header fields. As described above, most of this information is in the form of "deltas" between the value of the field in the current and the previous consecutive packet. These deltas are usually at least partially compressed. However, in FO state 504, some information (such as irregularities) are transmitted in uncompressed form. Decompressors are able to reproduce any fields not included in an FO packet (such as static fields) based on the compression context or the combination of the compression context and the sequence number. Using the three header field categories described above, various approaches may be employed in FO state 504. For instance, Class 1 header fields may be eliminated, Class 2 fields may be compressed as deltas, and Class 3 fields may be sent "as is." However, other approaches may be employed. In embodiments of the present invention, header fields may be compressed according to VLE and/or Huffman encoding techniques, as described above.<br>
Other states may be used as alternatives to the compressor states of FIG. 5. An example of such an alternative is shown in FIG. 11. FIG. 11 is a diagram operational states for a compressor according to embodiments of the present invention. As shown in FIG. 11, a compressor may operate in five states: a first state 1102, a second state 1104, a third state 1106, a fourth state 1108, and a fifth state 1110. FIG. 11 also shows various transitions between these states that may occur.<br>
In first state 1102, all header fields are transmitted. However, transmission of certain trivial header fields may be skipped. Thus, during state 1102, the compressor signals a compression context to one or more decompressors through in-band transmissions. Accordingly, state 1102 corresponds to IR state 502.<br>
In second state 1104, class 1 fields are eliminated from the headers. However, the remaining fields are compressed as far as possible.<br><br>
In third state 1106, Class 1 fields are eliminated from headers. In addition, some or all of the class 2 fields may be eliminated from the headers. Any remaining fields are compressed and transmitted to update the context at the receiving decompressor(s). This ensures correct decompression.<br>
In fourth state 1108, all Class 1 and Class 2 fields are eliminated from the headers, while any Class 3 fields are compressed as far as possible.<br>
In fifth state 1110, all header fields are eliminated and reduced to just a compressed sequence number field. Currently there are no sequence numbers defined for LCT or ALC. However, in embodiments of the present invention, a sequence number field is added to the ALC and/or LCT headers. Such fields advantageously provide for more efficient header compression. ROHC already defines a method to include this kind of ROHC sequence number for its UDP profile in which no sequence number is initially included in the UDP and IP headers. Such a sequence number field (ROHC or otherwise) may be a compressed form of the CCI field from the LCT header.<br>
As described above, ROHC provides for sequences of packets called compression windows. The lengths such windows may be periodically reduced to increase compression efficiency. This may be achieved by either discarding the oldest packets in the sequence or by entering IR state 502 to start a new sequence. According to one technique, older packets may be discarded from the compression window as the receiving device acknowledges the reception of those packets. This acknowledgement-based techniques may be employed for multicast protocols, such as NORM, because NORM is a feedback-oriented protocol in which receipt of transmissions are acknowledged. For protocols, such as ALC, FLUTE, and MUPPET, such acknowledgement-based techniques may be employed in network environments that provide for bidirectional transmission.<br>
In unidirectional network environments (such as typical DVB networks), receiving devices are not able to acknowledge the receipt of compressed packets. Accordingly, in embodiments involving unidirectional transmissions (e.g., ALC packets), the compressor may automatically advance the trailing edge of the compression window with each packet once the window has grown to a pre-defined size. This size may be determined according to various techniques. For instance, window size may be detennined according to packet loss estimates calculated by the compressor.<br><br>
Moreover, in unidirectional environments, the compressor may maintain a timer or a packet counter that periodically causes it to revert to IR state 502 as in the unidirectional (U) mode of ROHC, or state 1102. This allows all receiving devices (including those lacking an uplink connection) to resynchronize to one or more reference headers transmitted in uncompressed form.<br>
VII.    Receiver Techniques<br>
FIG. 12 is a flowchart of a packet reception technique according to the present invention. This technique may be performed by various communications devices, such as host 102b and gateway 204b. Furthermore, this technique may be employed with various protocols. For instance, this technique may be employed with ALC/LCT/UDP/IP packets, FLUTE/ALC/LCT/UDP/IP packets, MUPPET/ALC/LCT/UDP/IP packets, and NORM/UDP/DP packets.<br>
The flowclwt of FIG. 12 is described with reference to a receiving device that receives packets from a transmitting device. This flowchart includes a step 1202 in which the receiving device establishes a compression context with a transmitting device. This step may include receiving one or more packets having uncompressed headers from the transmitting device. From these uncompressed headers, the receiving device may identify and store current values for one or more packet header fields. These current values may be used as reference values for decompressing packets. In addition, step 1202 may include the receiving device identifying and storing one or more patterns of change in packet header fields. In the environments of FIGs. 1 and 2, these values and patterns may be stored, for example, in context databases 120 and 230.<br>
In a step 1204, the receiving device receives one or more packets having compressed headers. These headers may be compressed according to the ROHC techniques described above. Accordingly, the headers may include fields compressed as "deltas." Such fields may also be compressed according to VLE and Huf&amp;nan encoding techniques.<br>
In step 1206, the receiving device decompresses the header fields. This step may comprise determining values for compressed fields. Such determinations may be made according to various techniques. For instance, for static fields, this step may simply comprise replacing an omitted field value.   For fields based on a predictable pattern of<br><br>
change, this step may comprise based on simply updating a previous value according to the predictable pattern (e.g., incrementing the previous value by a predetermined quantity).<br>
If a receiving device fails to receive one or more packets belonging to a compression window, it will not be able to decompress the header fields of subsequently received packets belonging to the same compression window. To prevent a loss of synchronization, the receiving device may employ ^synchronization techniques in step 1206. Such techniques may include the use of extrapolation functins to estimate the values of the missing header fields.<br>
As described herein, compression contexts may be based on observed patterns in header fields. For instance, values of sequence number fields and time stamp fields may increase in a linear manner for successive packets. However, other patterns, such as nonlinear patterns may be observed for values of fields.<br>
Accordingly, to perform decompression in environments where packets are lost, a receiving device may establish one or more extrapolation functions. Each of these extrapolation functions corresponds to a particular field, by mathematically representing the pattern in which the field's values change. In the environments of FIGs. 1 and 2, these extrapolation functions may be stored, for example, in context databases 120 and 230.<br>
When a receiving device fails to receive one or more packets, it may use such extrapolation functions to decompress a subsequently received packet based on, for example, the sequence number of the subsequently received packet. Examples of such VLE compression techniques are described in International Publication Number WO 01/28180 A2 (incorporated herein by reference in its entirety).<br>
VIII.   Compression Context Example<br>
As described above with reference, for example, to steps 1008 and 1204, a<br>
compression context is established between a transmitting and a receiving device. Such a<br>
context may include header field values. The following is an example of a compression<br>
context involving FLUTE (indicated by field names on the left and their corresponding<br>
values on the right) according to the present invention.	<br><br>
Version	1<br>
A flag	0<br>
B flag	0<br>
Codepoint (FEC Encoding ID)	0<br>
Congestion control information (CCI)	0 (Not used)<br>
Transport Session Identifier (TSI)	Oxl 1111111<br>
Transport Object Identifier (TOI)	0x00000005<br>
Transfer Length	0X0000000DBC00<br>
FEC Encoding ID specific format:<br>
Encoding Symbol Length	0x03E8<br>
Maximum Source Block Length        0x00OO61A8<br>
Version of FLUTE	1<br>
FEC Payload ID related information<br>
A context may also include information about the logical channels (e.g., ALC/LCT channel) associated with a file delivery session. Thus, a compression context may include the channels, as well as information about static (class 1) and infrequently changing (class 2) packet header fields.<br>
If "Codepoint" (FEC Encoding ID in FLUTE) is used to refer to an Under-Specified FEC scheme, "FEC Instance ID" should also be included in the compression context. This inclusion defines that "Small Block, Large Block and Expandable FEC Codes(128)" are being used. The specific instance for this case is "Digital Fountain LT Code" (FEC Instance ID 0).<br>
IX,      Computer System<br>
As described above with reference to FIGs. 1 and 2, the techniques of the present<br>
invention may be employed in various environments by devices, such as hosts and gateways. These devices may be implemented in hardware, software, and/or firmware. Such implementations may include one or more computer systems. An example of a computer system 1301 is shown in FIG. 13. Computer system 1301 represents any single or multi-processor computer. Single-threaded and multi-threaded computers can be used. Unified or distributed memory systems can be used.<br>
Computer system 1301 includes one or more processors, such as processor 1304. One or more processors 1304 can execute software implementing the techniques described above, for example, with reference to FIGs. 10 and 12. Each processor 1304 is connected to a communication infrastructure 1302 (for example, a communications bus,<br><br>
cross-bar, or network). Various software embodiments are described in terms of this exemplary computer system. After reading this description, it will become apparent to a person skilled in the relevant art how to implement the invention using other computer systems and/or computer architectures.<br>
Computer system 1301 also includes a main memory 1307 which is preferably random access memory (RAM). Computer system 1301 may also include a secondary memory 1308. Secondary memory 1308 may include, for example, a hard disk drive 1310 and/or a removable storage drive 1312, representing a floppy disk drive, a magnetic tape drive, an optical disk drive, etc. Removable storage drive 1312 reads from and/or writes to a removable storage unit 1314 in a well known manner. Removable storage unit 1314 represents a floppy disk, magnetic tape, optical disk, read only memory (ROM), flash memory, etc., which is read by and written to by removable storage drive 1312. As will be appreciated, the removable storage unit 1314 includes a computer usable storage medium having stored therein computer software and7or data.<br>
In alternative embodiments, secondary memory 1308 may include other similar means for allowing computer programs or other instructions to be loaded into computer system 1301. Such means can include, for example, a removable storage unit 1322 and an interface 1320. Examples can include a program cartridge and cartridge interface (such as that found in video game devices), a removable memory chip (such as an EPROM, PROM, or flash memory) and associated socket, and other removable storage units 1322 and interfaces 1320 which allow software and data to be transferred from the removable storage unit 1322 to computer system 1301.<br>
Computer system 1301 may also include one or more communications interfaces<br>
1324. Communications interface 1324 allows software and data to be transferred<br>
between computer system 1301 and external devices via communications path 1327.<br>
Examples of communications interface 1327 include a modem, a network interface (such<br>
as Ethernet card), a communications port, etc. Software and data transferred via<br>
communications interface 1327 are in the form of signals 1328 which can be electronic,<br>
electromagnetic, optical or other signals capable of being received by communications<br>
interface 1324, via communications path 1327. Note that communications interface 1324<br>
provides a means by which computer system 1301 can interface to a network such as the<br>
Internet.	........<br><br>
The present invention can be implemented using software running (that is, executing) in an environment similar to that described above with respect to FIG. 13. In this document, the term "computer program product" is used to generally refer to removable storage units 1314 and 1322, a hard disk installed in hard disk drive 1310, or a signal carrying software over a communication path 1327 (wireless link or cable) to communication interface 1324. A computer useable medium can include magnetic media, optical media, or other recordable media, or media that transmits a carrier wave or other signal. These computer program products are means for providing software to computer system 1301.<br>
Computer programs (also called computer control logic) are stored in main memory 1307 and/or secondary memory 1308. Computer programs can also be received via communications interface 1324. Such computer programs, when executed, enable the computer system 1301 to perform the features of the present invention as discussed herein. In particular, the computer programs, when executed, enable the processor 1304 to perform the features of the present invention. Accordingly, such computer programs represent controllers of the computer system 1301.<br>
The present invention can be implemented as control logic in software, firmware, hardware or any combination thereof. In an embodiment where the invention is implemented using software, the software may be stored in a computer program product and loaded into computer system 1301 using removable storage drive 1312, hard drive 1310, or interface 1320. Alternatively, the computer program product may be downloaded to computer system 1301 over communications path 1327. The control logic (software), when executed by the one or more processors 1304, causes the processor(s) 1304 to perform the functions of the invention as described herein.<br>
In another embodiment, the invention is implemented primarily in firmware and/or hardware using, for example, hardware components such as application specific integrated circuits (ASICs). Implementation of a hardware state machine so as to perform the functions described herein will be apparent to persons skilled in the relevant art(s).<br><br>
X-       Conclusion<br>
While various embodiments of the present invention have been described above, it should be understood that they have been presented by way of example only, and not in limitation.<br>
Accordingly, it will be apparent to persons skilled in the relevant art that various changes in form and detail can be made therein without departing from the spirit and scope of the invention. Thus, the breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents.<br><br><br><br><br><br><br>
WHAT IS CLAIMED IS:<br>
1.-    -  A packet transmission method, comprising:<br>
(a)	establishing with a receiving device a compression context for a plurality of packets, the plurality of packets associated with at least a reliable multicast protocol, wherein each of the plurality of packets includes a header having a plurality of header fields;<br>
(b)	generating a compressed packet for one of the plurality of packets, the compressed packet having a reduced number of bits in its header; and<br>
(c)	transmitting the compressed packet to the receiving device.<br><br>
2.	The method of claim 1_, wherein step (a) comprises transmitting one or more of the packets with uncompressed headers to the receiving device.<br>
3.	The method of claim 1, wherein step (a) further comprises storing a current value for one or more packet header fields.<br>
4.	The method of claim 1? wherein step (a) further comprises identifying one or more patterns of change in header fields.<br>
5.	The method of claim 1, wherein each of the plurality of packets are associated with the Layered Coding Transform (LCT) protocol.<br>
6	The method of claim 5, wherein each of the plurality of packets are further<br>
associated with the Asynchronous Layered Coding (ALC) protocol.<br>
7.	The method of claim 6, wherein each of the plurality of packets are further associated with the FLUTE protocol.<br>
8.	The method of claim 6? wherein each of the plurality of packets are further associated with the MUPPET protocol.<br><br>
9.	The method of claim 1, wherein each of the plurality of packets are associated with the NACK-Oriented Reliable Multicast (NORM) protocol.<br>
10.	The method of claim 5, wherein the plurality of packets each have the same Transport Object Identifier (TOI) flag,<br>
11.	The method of claim 5, wherein the plurality of packets each have the same Transport Session Identifier (TSI) flag.<br>
12.	The method of claim 1, further comprising:<br>
(d) identifying one or more header fields as compressible.<br>
13.	The method of claim 12, wherein step (d) comprises placing each of the header<br>
fields into one of a plurality of categories, the plurality of categories including:<br>
a first category for header fields that do not change at all for the plurality of packets,<br>
a second category for header fields that change only occasionally for the plurality of packets, and<br>
a third categoiy for header fields that changes for each of the plurality of packets.<br>
14.	The method of claim 13, wherein step (b) comprises:<br>
eliminating any header fields corresponding to the first category; and<br>
compressing any header fields corresponding to the second category.<br>
15.	The method of claim 1, wherein step (b) comprises replacing a field in the header of the one packet with a compressed header field having a reduced number of bits.<br>
16.	The method of claim 15, wherein the compressed field represents a change in value from a corresponding header field in a previous packet.<br>
17.	The method of claim 15, wherein step (b) further comprises performing variable length encoding on the compressed header field.<br><br>
18.	The method of claim 15, wherein step (b) further comprises performing Huffman encoding on the compressed header field.<br>
19.	The method of claim 1, wherein step (c) comprises encapsulating the compressed packet in a transmission frame of a layer two protocol.<br>
20.	A packet reception method, comprising:<br><br>
(a)	establishing with a transmitting device a compression context for a plurality of packets, the plurality of packets associated with at least a reliable multicast protocol, wherein each of the plurality of packets includes a header having a plurality of header fields;<br>
(b)	receiving a compressed packet from the transmitting device, the compressed packet having a reduced number of bits in its header; and<br>
(c)	decompressing the compressed packet based on the compression context.<br><br>
21.	The method of claim 20, wherein step (a) comprises receiving one or more of the packets with uncompressed headers from the transmitting device.<br>
22.	The method of claim 20, wherein step (a) further comprises storing a current value for one or more packet header fields.<br>
23.	The method of claim 20, wherein step (a) further comprises identifying one or more patterns of change in header fields.<br>
24.	The method of claim 20, wherein each of the plurality of packets are associated with the Layered Coding Transform (LCT) protocol.<br>
25       The method of claim 24, wherein each of the plurality of packets are further associated with the Asynchronous Layered Coding (ALC) protocol.<br>
26.      The method of claim 25, wherein each of the plurality of packets are further associated with the FLUTE protocol<br><br>
27.	The method of claim 25, wherein each of the plurality of packets are further associated with the MUPPET protocol.<br>
28.	The method of claim 20, wherein each of the plurality of packets are associated with the NACK-Oriented Reliable Multicast (NORM) protocol.<br>
29.	The method of claim 24, wherein the plurality of packets each have the same Transport Object Identifier (TOI) flag.<br>
30.	The method of claim 24, wherein the plurality of packets each have the same Transport Session Identifier (TSI) flag.<br>
31.	The method of claim 20, wherein step (c) comprises performing variable length decoding on the compressed packet.<br>
32.	The method of claim 20, wherein step (c) comprises performing Huffman decoding on the compressed packet.<br>
33.	A system, comprising:	(<br>
a context database for storing a compression context for a plurality of packets, the plurality of packets associated with at least a reliable multicast protocol, wherein each of the plurality of packets includes a header having a plurality of header fields;<br>
a compressor for generating a compressed packet for one of the plurality of packets, the compressed packet having a reduced number of bits in its header; and<br>
a sender for transmitting the compressed packet to a receiving device.<br>
34.	The system of claim 33, wherein each of the plurality of packets are associated<br>
with the Layered Coding Transform (LCT) protocol.<br>
35       The system of claim 34, wherein each of the plurality of packets are further associated with the Asynchronous Layered Coding (ALC) protocol.<br><br>
36.	The system of claim 35, wherein each of the plurality of packets are further associated with the FLUTE protocol<br>
37.	The system of claim 35, wherein each of the plurality of packets are further associated with the MUPPET protocol.<br>
38.	The system of claim 33, wherein each of the plurality of packets are associated with the NACK-Oriented Reliable Multicast (NORM) protocol.<br>
39.	A system, comprising:<br>
a context database for storing a compression context for a plurality of packets, the plurality of packets associated with at least a reliable multicast protocol, wherein each of the plurality of packets includes a header having a plurality of header fields;<br>
a receiver for receiving a compressed packet from a transmitting device, the compressed packet corresponding to one of the plurality of packets and having a reduced number of bits in its header; and<br>
a decompressor for generating an uncompressed packet from the compressed packet based on the compression context.<br>
40.	Tlie system of claim 39, wherein each of the plurality of packets are associated<br>
with the Layered Coding Transform (LCT) protocol.<br>
41        The system of claim 40, wherein each of the plurality of packets are further associated with the Asynchronous Layered Coding (ALC) protocol.<br>
42.	The system of claim 41, wherein each of the plurality of packets are further associated with the FLUTE protocol.<br>
43.	The system of claim 41, wherein each of the plurality of packets are further associated with the MUPPET protocol.<br>
44.	The system of claim 39, wherein each of the plurality of packets are associated with the NACK-Oriented Reliable Multicast (NORM) protocol.<br><br>
45.	A computer program product comprising a computer useable medium having<br>
computer program logic recorded thereon for enabling a processor in a computer system<br>
of a device to transmit packets, the computer program logic comprising:<br>
program code for enabling the processor to establish with a receiving device a compression context for a plurality of packets, the plurality of packets associated with at least a reliable multicast protocol, wherein each of the plurality of packets includes a header having a plurality of header fields;<br>
program code for enabling the processor to generate a compressed packet for one of the plurality of packets, the compressed packet having a reduced number of bits in its header; and<br>
program code for enabling the processor to transmit the compressed packet to the receiving device.<br>
46.	A computer program product comprising a computer useable medium having<br>
computer program logic recorded thereon for enabling a processor in a computer system<br>
of a device to receive packets, the computer program logic comprising:<br>
program code for enabling the processor to establish with a transmitting device a compression context for a plurality of packets, the plurality of packets associated with at least a reliable multicast protocol, wherein each of the plurality of packets includes a header having a plurality of header fields;<br>
program code for enabling the processor to receive a compressed packet from the transmitting device, the compressed packet having a reduced number of bits in its header; and<br>
program code for enabling the processor to decompress the compressed packet based on the compression context.<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2IGFic3RyYWN0IGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">2631-chenp-2006 abstract duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1DSEVOUC0yMDA2IEFCU1RSQUNULnBkZg==" target="_blank" style="word-wrap:break-word;">2631-CHENP-2006 ABSTRACT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2IGNsYWltcyBkdXBsaWNhdGUucGRm" target="_blank" style="word-wrap:break-word;">2631-chenp-2006 claims duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1DSEVOUC0yMDA2IENPUlJFU1BPTkRFTkNFIE9USEVSUy5wZGY=" target="_blank" style="word-wrap:break-word;">2631-CHENP-2006 CORRESPONDENCE OTHERS.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1DSEVOUC0yMDA2IENPUlJFU1BPTkRFTkNFIFBPLnBkZg==" target="_blank" style="word-wrap:break-word;">2631-CHENP-2006 CORRESPONDENCE PO.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2IGRlc2NyaXB0aW9uIChjb21wbGV0ZSkgZHVwbGljYXRlLnBkZg==" target="_blank" style="word-wrap:break-word;">2631-chenp-2006 description (complete) duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2IGRyYXdpbmdzIGR1cGxpY2F0ZS5wZGY=" target="_blank" style="word-wrap:break-word;">2631-chenp-2006 drawings duplicate.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">2631-chenp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2LWFzc2lnbmVtZW50LnBkZg==" target="_blank" style="word-wrap:break-word;">2631-chenp-2006-assignement.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">2631-chenp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">2631-chenp-2006-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2LWRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">2631-chenp-2006-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">2631-chenp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">2631-chenp-2006-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2LWZvcm0gMTgucGRm" target="_blank" style="word-wrap:break-word;">2631-chenp-2006-form 18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2LWZvcm0gMjYucGRm" target="_blank" style="word-wrap:break-word;">2631-chenp-2006-form 26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">2631-chenp-2006-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">2631-chenp-2006-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MjYzMS1jaGVucC0yMDA2LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">2631-chenp-2006-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="231175-self-diverting-foamed-system.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="231177-a-printer-cartridge-for-an-inkjet-printer.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>231176</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>2631/CHENP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>27-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>03-Mar-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>19-Jul-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>NOKIA CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>Keilalahdentie 4, FI-02150 Espoo,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>WALSH, Rod</td>
											<td>Kelkkakatu 4 B 12, FI-33580 Tampere,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>LUOMA, Juha-Pekka</td>
											<td>Puutarhakatu 18 C 43, FI-33210 Tampere,</td>
										</tr>
										<tr>
											<td>3</td>
											<td>SAARANEN, Anne</td>
											<td>Siirtolapuutarhankatu 11 A 8, FIN-33900 Tampere,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F15/16</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/IB2004/004098</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-12-13</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/739,066</td>
									<td>2003-12-19</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/231176-method-and-system-for-packet-based-communications by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 12:01:46 GMT -->
</html>
