<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/222004-method-and-system-for-providing-seamless-self-refresh-for-directed-bank-refresh-in-volatile-memories by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:01:04 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 222004:METHOD AND SYSTEM FOR PROVIDING SEAMLESS SELF-REFRESH FOR DIRECTED BANK REFRESH IN VOLATILE MEMORIES</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">METHOD AND SYSTEM FOR PROVIDING SEAMLESS SELF-REFRESH FOR DIRECTED BANK REFRESH IN VOLATILE MEMORIES</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A memory system is provided. The system includes a volatile memory having a number of banks and configured to engage in one of a number of operating modes including an auto-refresh mode and a self-refresh mode, and a memory controller configured to direct the volatile memory to engage in one of the operating modes. Upon the memory controller directing the volatile memory to engage in the self-refresh mode, the memory controller is further configured to provide an entry bank address to the volatile memory, the entry address corresponding to the first bank that is to be refreshed during the self-refresh mode. Upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to make an exit bank address available to the memory controller, the exit bank address corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT, 1970<br>
(39 of 1970)<br>
&amp;<br>
THE PATENTS RULES, 2003<br>
COMPLETE SPECIFICATION<br>
(See section 10, rule 13)<br>
"METHOD AND SYSTEM FOR PROVIDING SEAMLESS SELF-REFRESH FOR DIRECTED BANK REFRESH IN VOLATILE<br>
MEMORIES"<br>
QUALCOMM INCORPORATED,<br>
an American company of 5775 Morehouse Drive , San Diego, California 92121-1714, United States of America<br>
The following specification particularly describes the invention and the manner in which it is to be performed.<br><br>
WO 2005/11%92	PCT/US2005/018917<br>
METHOD AND SYSTEM FOR PROVIDING SEAMLESS SELF-REFRESH FOR DIRECTED BANK REFRESH IN VOLATILE MEMORIES<br>
BACKGROUND<br>
Related Applications<br>
[0000]	This application claims priority to U.S. Provisional Application Serial<br>
Number 60/575,335 filed May 27, 2004.<br>
Field<br>
[0001]	The present disclosure relates generally to memory devices, and more<br>
specifically, to methods and systems for providing seamless self-refresh for directed bank refresh in volatile memories.<br>
Background<br>
[0002]	Volatile memory is a storage medium that is generally structured as a<br>
number of arrays (or banks). Each bank is further arranged as a matrix of "memory cells" in rows and columns, with each column being further divided by the input/output (I/O) width of the memory. Locations within the memory are uniquely specified by bank, row and column. A memory controller may be used to retrieve data from the memory by indicating the data's bank, row and column location. For example, for a quad-bank 128Mb memory with a 16-bit external data bus, a possible logical address mapping includes a 9-bit column address, a 2-bit bank address and a 12-bit row address.<br>
[0003]	Prior to reading or writing a memory location, the corresponding row<br>
must first be opened. The process of opening a row requires a minimum number of clock cycles, tRCD, which represents the row-to-column delay. Once a row is open, column addresses within that row can be read or written as desired. For some dynamic random access memories (DRAMs), such as synchronous DRAMs (SDRAMs), only one row per bank can be kept open at any one time; a subsequent memory access to be performed within the same bank but at a different row requires closing the current row and opening the new one.<br>
[0004]	In the case of dynamic volatile memories, each cell must be refreshed, or<br>
re-energized, periodically at an average interval, tREFi, in order to maintain data integrity. The cells have to be refreshed because they are designed around capacitors that store electrical charges, which may discharge over time.  Refresh is the process of<br><br>
WO 2005/119692	3	PCT/US2005/01S917<br>
recharging, or re-energizing, the cells in memory. Cells are generally refreshed one row at a time. A number of methods currently exist that are designed to refresh volatile memores. Some, if not all, of these methods incur high cost in performance and/or power. For example, there are two common methods or techniques that are generally used to control the refresh of volatile memories in modem digital systems. One method relies on the memory to keep track of the row and bank that need to be refreshed using built-in refresh mechanisms that are available on the memory; the other method relies on the memory controller to keep track of the row and bank that need to be refreshed.<br>
[0005]	The first commonly used method is utilized by the auto-refresh and self-<br>
refresh functions of the volatile memories. These functions use the built-in refresh address of the memory. During active use of the memory, if a refresh cycle is required, the memory controller precharges all the banks, and then uses the auto-refresh command to tell the memory to issue an internal refresh cycle. Upon receiving the auto-refresh command, the memory increments the internal refresh address counter and executes the internal refresh cycle. In auto-refresh mode, the memory uses the refresh address in its internal refresh address counter to determine which rows/banks to perform the refresh cycle and cycle through the relevant rows. In one implementation, the internal refresh address counter includes a row address register and a bank address register. The internal refresh address counter is controlled by a refresh clock. The bank address register is incremented to cycle through each of the memory banks with the carry-out of the bank address register causing the row address register to increment. Other implementations do not have a bank address register as all banks are simultaneously refreshed.<br>
[0006]	A   disadvantage   of   present   non-simultaneous   bank   auto-refresh<br>
implementations is that because the memory controller does not know which internal bank will be refreshed, the memory controller is required to close all open rows prior to issuing an auto-refresh command. As a result, the memory data bus availability during an auto-refresh sequence is zero. At best, this sequence requires tRp+tRpc+tRCD cycles, where tRP represents a row-precharge delay, tRFc represents refresh cycle time and tRCD represents the row-to-column delay. For a 133 MHz memory, this could be 16 clock cycles (120 ns). These cycles are sometimes referred to as dead cycles since the memory data bus is not available during this period.<br><br>
WO 2005/119692	4	PCT/US2005/018917<br>
[0007]	During periods of non-use, the memory controller may place the memory<br>
in the self-refresh mode. In the self-refresh mode, the memory uses its own internal clock and refresh address counter to generate refreshes to refresh the row(s) of the memory. This method is good for saving power during idle states since the self-refresh mode can be used. The self-refresh state uses a small amount of power and maintains the contents of the memory by refreshing the memory. Due to the small amount of power needed, this method is typically used for low power applications.<br>
[0008]	A second method is sometimes used to avoid the dead cycles on the<br>
memory data bus mentioned above. According to this second method, control of the refresh is effected via the memory controller. This method does not use any of the built-in refresh mechanisms that are available on the memory. Under this method, at regularly given intervals (T REFI)), the memory controller explicitly generates refreshes by opening and closing rows in a sequential manner using bank/row address combinations. The refresh clock, which determines the refresh rate, and the bank/row address combinations are internal to the memory controller. This method is best for high speed/high performance applications. This method allows the memory controller to refresh a particular memory bank while permitting other memory banks to remain open for access, resulting in higher performance; reads and writes to other banks can generally continue in parallel and uninterrupted. The downside to this method is that during system power down or long idle states, when the memory controller is not refreshing the memory, the memory cannot be kept in a self-refresh state. As mentioned above, the self-refresh state is a built-in function of most volatile memories. Since the self-refresh function of the memory increments a refresh address (i.e., the row/bank address) stored in a refresh address counter in the memory, independent of the memory controller, the refresh address maintained by the memory is not consistent or synchronized with the memory controller.<br>
[0009]	Refresh operations can reduce performance of memory subsystems<br>
because each refresh cycle forces the memory into an idle state, during which data access is not available. For example, if a refresh cycle is required for a particular memory bank while such bank is in an active state, the bank has to be shut down to allow the refresh operation to take place. Shutting down the bank means that whatever<br><br>
WO 2005/119692<br><br>
PCT/US2O05/018917<br><br>
5<br>
data operations that were to be performed have to be delayed, hence, affecting system performance.<br>
[0010]	Some existing schemes are available to reduce the performance impact of<br>
refresh operations. Such schemes typically involve using a higher than required refresh rate, so that more memory banks can be refreshed within a predetermined refresh period. By having more memory banks refreshed, the chances of having to shut down an active memory bank for refresh are reduced. Using a higher refresh rate, however, has its drawbacks. For example, an increase in refresh rate means more power is needed which, in turn, results in lower performance. Also, merely using a higher refresh rate does not always obviate the need to shut down an active memory bank when refresh is required; in some situations, an active memory bank has to be shut down regardless, thus, negating any benefits from using a higher refresh rate.<br>
[0011]	Hence, it would be desirable to provide more efficient methods and<br>
systems for providing seamless self-refresh for directed bank refresh in volatile memories.<br>
SUMMARY<br>
[0012]	In one aspect of the present invention, a memory system includes a<br>
volatile memory having a plurality of banks and configured to engage in one of a plurality of operating modes including an auto-refresh mode and a self-refresh mode, and a memory controller configured to direct the volatile memory to engage in one of the plurality of operating modes, wherein upon the memory controller directing the volatile memory to engage in the self-refresh mode, the memory controller is further configured to provide an entry bank address to the volatile memory, the entry bank address corresponding to the first bank that is to be refreshed during the self-refresh mode, and wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to make an exit bank address available to the memory controller, the exit bank address corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode.<br>
[0013]	In another aspect of the present invention, a memory system includes a<br>
volatile memory having an entry bank address latch, an exit bank address latch and a plurality of banks, and a memory controller configured to direct the volatile memory to<br><br>
WO 2005/119692	6	PCT/US2005/018917<br>
engage in one of a plurality of operating modes including an auto-refresh mode and a self-refresh mode, wherein upon the memory controller directing the volatile memory to engage in the self-refresh mode, the memory controller is further configured to load an entry bank address into the entry bank address latch, the entry bank address corresponding to the first bank that is to be refreshed during the self-refresh mode, and wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to load an exit bank address into the exit bank address latch, the exit bank address corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode, and wherein the exit bank address latch is accessible to the memory controller.<br>
[0014]	In yet another aspect of the present invention, a memory system includes<br>
a volatile memory having a plurality of banks, first storage means configured to store an entry bank address and second storage means configured to store an exit bank address, and a memory controller configured to direct the volatile memory to engage in one of a plurality of operating modes including an auto-refresh mode and a self-refresh mode, wherein upon the memory controller directing the volatile memory to engage in the self-refresh mode, the memory controller is further configured to load the entry bank address into the first storage means, the entry bank address corresponding to the first bank that is to be refreshed during the self-refresh mode, and wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to load the exit bank address into the second storage means, the exit bank address corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode, and wherein the second storage means is accessible to the memory controller.<br>
[0015]	In one aspect of the present invention, a memory system includes a<br>
volatile memory having a plurality of banks, an entry bank address latch, an exit bank address latch, a refresh clock and a refresh counter, the refresh counter further having a row address counter and a row increment counter, wherein the refresh clock is configured to control the refresh counter and the entry bank address latch, wherein the row increment counter is configured to increment the row address counter, and a memory controller configured to control the volatile memory to engage in an auto-refresh mode or a self-refresh mode, the memory controller further configured to load a bank address for a target bank into the entry bank address latch, wherein the memory<br><br>
WO 2005/119692	7	PCT/US2005/018917<br>
controller is further configured to direct the volatile memory to engage in the auto-refresh mode to perform an auto-refresh operation on the target bank, wherein the row increment counter is configured to be incremented each time an auto-refresh operation is performed, wherein the row increment counter is further configured to increment the row address counter after a predetermined number of auto-refresh operations have been performed, wherein the row address counter includes a row address that is usable to identify a row in the target bank for the auto-refresh operation, wherein upon the volatile memo y entering into the self-refresh mode, the volatile memory is furtner configured to perform one or more self-refresh operations using the bank address stored in the entry bank address latch, wherein the volatile memory is further configured to increment the entry bank address latch after each self-refresh operation, and wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is configured to load the current value of the entry bank address latch into the exit bank address latch, the value in the exit bank address latch corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode.<br>
[0016]	In yet another aspect of the present invention, a memory system includes<br>
a volatile memory having an entry bank address latch, an exit bank address latch, a plurality of banks, a plurality of refresh row counters, each refresh row counter associated with a corresponding bank and configured to store a target row address, and a memory controller configured to direct the volatile memory to engage in an auto-refresh mode, the memory controller further configured to load a target bank address into the entry bank address latch, wherein the volatile memory is configured to perform an auto-refresh operation in the auto-refresh mode, the auto-refresh operation being performed on a target bank identified by the target bank address using the target row address stored in the refresh row counter associated with the target bank, wherein the memory controller is further configured to direct the volatile memory to engage in a self-refresh mode, wherein the volatile memory is further configured to cycle through the plurality of banks in the self-refresh mode by incrementing the entry bank address latch to generate the current target bank address, and wherein during each self-refresh operation, the volatile memory is further configured to refresh the bank identified by the current target bank address based on the target row address stored in the associated refresh row counter, and wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to load the value stored in the entry bank address<br><br>
WO 2005/119692	8	PCT/US2005/018917<br>
latch into the exit bank address latch, the value in the exit bank address latch corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode.<br>
[0017]	In a further aspect of the present invention, a method for controlling<br>
memory refresh for a volatile memory having a plurality of banks, includes forwarding an entry bank address to the volatile memory, directing the volatile memory to engage in a self-refresh mode to perform one or more self-refresh operations based on the entry bank address, the entry bank address corresponding to a target bank where the one or more self-refresh operations is to begin, and directing the volatile memory to make available an exit bank address upon the volatile memory exiting the self-refresh mode, the exit bank address corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode.<br>
[0018]	In yet a further aspect of the present invention, a method for controlling<br>
memory refresh for a volatile memory having an entry bank address latch, an exit bank address latch and a plurality of banks, includes loading an entry bank address into the entry bank address latch, directing the volatile memory to retrieve the entry bank address from the entry bank address latch, directing the volatile memory to engage in a self-refresh mode to perform one or more self-refresh operations based on the entry bank address, the entry bank address corresponding to a target bank where the one or more self-refresh operations is to begin, and storing an exit bank address into the exit bank address latch upon the volatile memory exiting the self-refresh mode, the exit bank address corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode.<br>
[0019]	It is understood that other embodiments of the present invention will<br>
become readily apparent to those skilled in the art from the following detailed description, wherein various embodiments of the invention are shown and described by way of illustration. As will be realized, the invention is capable of other and different embodiments and its several details are capable of modification in various other respects, all without departing from the spirit and scope of the present invention. Accordingly, the drawings and detailed description are to be regarded as illustrative in nature and not as restrictive.<br><br>
WO 2005/119692	9	PCT/US2005/018917<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[0020]	Aspects of the present invention are illustrated by way of example, and<br>
not by way of limitation, in the accompanying drawings, wherein:<br>
[0021J	FIG. 1 is a simplified block diagram illustrating an arrangement that can<br>
be used to practice the seamless refresh method according to the present disclosure;<br>
[0022]	FIG. 2 is a simplified block diagram illustrating one embodiment of a<br>
volatile memory that can be used to practice the seamless refresh method according to the present disclosure;<br>
[0023]	FIG. 3 is a simplified timing diagram illustrating various signals during<br>
operation of the refresh method according to the present disclosure;<br>
[0024]	FIG. 4 is a simplified block diagram illustrating another embodiment of a<br>
volatile memory that can be used to practice the seamless refresh method according to the present disclosure;<br>
[0025]	FIG. 5 is a simplified block diagram illustrating another embodiment of a<br>
volatile memory that can be used to practice the seamless refresh method according to the present disclosure; and<br>
[0026]	FIG. 6 is a simplified block diagram illustrating another embodiment of a<br>
volatile memory that can be used to practice the seamless refresh method according to the present disclosure.<br>
DETAILED DESCRIPTION<br>
[0027]	The detailed description set forth below in connection with the appended<br>
drawings is intended as a description of various embodiments of the present invention and is not intended to represent the only embodiments in which the present invention may be practiced. The detailed description includes specific details for the purpose of providing a thorough understanding of the present invention. However, it will be apparent to those skilled in the art that the present invention may be practiced without these specific details. In some instances, well-known structures and components are shown in block diagram form in order to avoid obscuring the concepts of the present invention.<br><br>
WO 2005/119692	   10	PCT/US2005/018917<br>
[0028]	Various embodiments of a memory system will now be described.   In<br>
one embodiment, a seamless refresh method is provided which allows a specific bank to be identified for the first self-refresh operation upon a memory entering self-refresh mode; the refresh method also allows information relating to the last refreshed bank to be conveyed to a memory controller upon the memory exiting self-refresh mode. FIG. 1 shows an arrangement 100 that can be used to practice the seamless refresh method. As shown in FIG. 1, the seamless refresh method may be practiced with a volatile memory 110 and a memory controller 120 configured to control the volatile memory 110. The volatile memory 110 can be, for example, a DRAM (dynamic random access memory), a SDRAM (synchronous DRAM), and various other types of DRAM, etc. Based on the disclosure and teachings provided herein, a person of ordinary skill in the art will appreciate how to practice the present disclosure with other types of memories which require refresh operations. In one embodiment, the seamless refresh method is effected via control logic or a processor (not shown) which controls the memory controller 120 and the volatile memory 110. It should be understood that the control logic or processor may be implemented as an independent module or integrated as part of another component, such as, the memory controller 120.<br>
[0029]	FIG. 2 illustrates one embodiment of the volatile memory 110 that can be<br>
used to practice the seamless refresh method. The volatile memory 110 may further include a number of banks 200, an entry bank address latch 210 and an exit bank address latch 220. The seamless refresh method optimizes the transition between auto-refresh cycles and self-refresh cycles. When the memory controller 120 commands the volatile memory 110 to enter self-refresh mode, the memory controller 120 signals to the volatile memory 110 which bank to refresh next by using a target bank address. The target bank address is loaded into the entry bank address latch 210.<br>
[0030]	FIG. 3 shows that in Cycle "2" the memory controller 120 issues the<br>
command to place the volatile memory 110 in self-refresh mode indicating that the memory's first self-refresh cycle is to be performed on a specific bank, BankX. Then, at Cycle "m+1", the volatile memory 110 exits self-refresh mode and loads the bank address of the last refreshed bank, BankY, into the exit bank address latch 220. The memory controller 120 retrieves the content of the exit bank address latch 220 and then uses it to identify the last bank that the volatile memory 110 refreshed prior to exiting<br><br>
WO 2005/119692	PCT/US2O05/O18917<br>
11<br>
self-refresh mod;. Since the memory controller 120 does not know when this last bank was refreshed, the memory controller 120 directs the volatile memory 110 to perform an auto-refresh operation on the next bank, BankY+1, that is due for refresh as soon as practicable.<br>
[0031]	In another embodiment as shown in FIG. 6, the volatile memory 110 may<br>
further include an exit row address latch 230. Prior to exiting the self-refresh mode, the row address of the last refreshed row may be loaded into the exit row address latch 230. The contents of the exit row address latch 230 are accessible to the memory controller 120 (see FIG. 1). Hence, after the volatile memory 110 exits the self-refresh mode, information relating to the bank address and the row address of the last refreshed row and bank is available to the memory controller 120 from the exit row address latch 230 and the exit bank address latch 220. The memory controller 120 can then utilize this information for future operations accordingly.<br>
[0032]	Based on the disclosure and teachings provided herein, a person of<br>
ordinary skill in the art will appreciate how to apply the seamless refresh method disclosed herein to different volatile memory arrangements in accordance with the concepts disclosed in the present disclosure. For example, the seamless refresh method can be used in connection with two approaches which have been proposed that allow a memory controller to direct refreshes to a specific bank in a memory in auto-refresh mode.<br>
[0033]	In the first approach, a memory controller is able to provide a target bank<br>
address for a specific bank to a volatile memory for auto-refresh operation in auto-refresh mode. FIG. 4 shows one embodiment of the volatile memory 110 that can be used to practice a directed refresh method under the first approach. The volatile memory 110 may further include a refresh counter 400 having a row address counter 450 and a row increment counter 420, a refresh trigger 440, the entry bank address latch 210 and a number of banks 410.<br>
[0034]	The refresh trigger 440 may be used to control both the refresh counter<br>
400 and the entry bank address latch 210. The refresh trigger 440 is used by the volatile memory 110 to initiate a refresh operation either in the auto-refresh mode or self-refresh mode.    For example, upon receiving an auto-refresh command from the memory<br><br>
WO 2005/119692	12	PCT/US2005/01H917<br>
controller 120 (see FIG. 1), the volatile memory 110 may direct the refresh trigger 440 to initiate the auto-refresh operation. The refresh trigger 440 can be, for example, a clock or other timing mechanisms.<br>
[0035]	The row address counter 450 may be used to store the target row address<br>
for the row that is to be refreshed. The entry bank address latch 210 may be used to store the target bank address for the specific bank containing the row that is to be refreshed.<br>
[0036]	The memory controller 120 may direct the volatile memory 110 to auto-<br>
refresh a specific memory bank within the volatile memory 110 while other memory banks remain available for access. For each auto-refresh cycle initiated by the memory controller 120, the bank address 470 may be loaded by the memory controller 120 (see FIG. 1) into the entry bank address latch 210. The bank address 470 is used to select one of the banks 410 for refresh. Because the memory controller 120 (see FIG.l) is aware of the specific bank to be refreshed, access to the other internal banks may continue without interruption. This tends to maximize the memory data bus utilization, reduces power consumption by avoiding unnecessary row close/open sequences, and serves to minimize transfer latency.<br>
[0037]	The row increment counter 420 may be initialized upon power-up or<br>
reset. The initialized value for the row increment counter 420 can be arbitrary. The row increment counter 420 causes the row address counter 450 to be incremented after a predetermined number of auto-refresh operations have been performed. The row address counter 450 contains the target row address for a row that is to be refreshed. The row address counter 450 points to the same row in all the banks 410.<br>
[0038]	The memory controller 120 initiates each auto-refresh cycle by issuing<br>
an auto-refresh command to the volatile memory 110 and loading the bank address 470 for the bank to be refreshed into the entry bank address latch 210. Upon receiving the auto-refresh command, the volatile memory 110 uses the refresh trigger 440 to initiate each auto-refresh operation. The refresh trigger 440 causes the row increment counter 420 to increment. Cyclically, the row address counter 450 is incremented by a carry-out signal 460 from the row increment counter 420. For example, the row increment counter 420 may be a 2-bit counter, which means the row increment counter 420 repeats<br><br>
WO 2005/119692	13	PCT/US2005/018917<br>
itself every four (4) refresh clock cycles; conversely, the row address counter 450 is incremented after every 4th auto-refresh operation. The target row address stored in the row address counter 450 and the bank address stored in the entry bank address latch 210 are then used to refresh a specific row in the identified bank.<br>
[0039]	Since  the   target   row  address   changes  periodically  based  on   the<br>
predetermined number of auto-refresh operations and the memory controller 120 does not know when the row address counter 450 will be incremented, the memory controller 120 (see FIG. 1) issues auto-refresh commands in a consistent, sequential order with respect to the banks 410; in other words, the memory controller 120 loads the bank addresses of the banks 410 into the entry bank address latch 210 one at a time in a sequential manner during each auto-refresh cycle. As a result, the banks 410 are refreshed sequentially in successive auto-refresh cycles. For example, for the four (4) banks shown in FIG. 4, the refresh bank order could be either "3-2-1-0-3-2-1-0" or "0-1-2-3-0-1-2-3". One order does not have an advantage over the other. Therefore, either one can be used. In one implementation, the sequence "0-1-2-3-0-1-2-3-..." may be used. As will be further described below, choosing this sequence simplifies the transition into self-refresh mode.<br>
[0040}	The operation of the volatile memory 110 as shown in FIG. 4 is further<br>
illustrated in an example as follows. In this example, the initial value in the row increment counter 420 is assumed to be zero (0) and the carry-out signal 460 of the row increment counter 420 is activated after every 4th auto-refresh operation. The memory controller 120 (see FIG. 1) issues an auto-refresh command to the volatile memory 110 and loads the bank address 470 for the bank 410a into the entry bank address latch 210 to initiate a first auto-refresh cycle. Upon receiving the auto-refresh command, the volatile memory 110 directs the refresh trigger 440 to initiate an auto-refresh operation. During the auto-refresh operation, the row increment counter 420 is incremented to a value of one (1). In this instance, the carry-out signal 460 is not activated and the row address counter 450 is not incremented. The target row address and the bank address currently stored in the row address counter 450 and the entry bank address latch 210 respectively are then used to refresh a specific row in the bank 410a.<br>
[0041]	Subsequently, the memory controller 120 (see FIG. 1) issues another<br>
auto-refresh command to the volatile memory 110 and loads the bank address 470 for<br><br>
WO 2005/119692	14	PCT/US2005/018917<br>
the bank 410b into the entry bank address latch 210 to initiate a second auto-refresh cycle. Similarly, upon receiving the second auto-refresh command, the volatile memory 110 directs the refresh trigger 440 to initiate another auto-refresh operation. During this auto-refresh operation, the row increment counter 420 is incremented to a value of two (2). Again, the carry-out signal 460 is not activated and the row address counter 450 is not incremented. The target row address and the bank address currently stored in the row address counter 450 and the entry bank address latch 210 respectively are then used to refresh a specific row in the bank 410b. It should be noted that since the row address counter 450 is not incremented, the target row address used in this auto-refresh operation is the same as the one used in the last auto-refresh operation. However, for this auto-refresh operation, the bank address stored in the entry bank address latch 210 is different in that a different bank 410b is identified. As a result, the same row in a different bank 410b (as opposed to bank 410a) is refreshed.<br>
[0042]	Similarly, it will be appreciated that for the 3d and 4th auto-refresh<br>
cycles, the row address counter 450 is not incremented (since the carry-out signal 460 of the row increment counter 420 is not activated). Consequently, the same row in different banks 410c and 410d are refreshed during the 3rd and 4th auto-refresh cycles.<br>
|0043]	For the 5th auto-refresh cycle, the bank address 470 loaded by the<br>
memory controller 120 (see FIG. 1) into the entry bank address latch 210 points back to the bank 410a. Furthermore, the carry-out signal 460 of the row increment counter 420 is now activated since four (4) auto-refresh operations have already been performed. The carry-out signal 460, in turn, increments the row address counter 450 thereby moving the target row address to a new row for refresh. This same new row is then refreshed for all four (4) banks 410 during successive auto-refresh cycles.<br>
[0044]	When the volatile memory 110 is commanded into self-refresh mode, the<br>
volatile memory 110 begins to generate refreshes internally using the bank address currently stored in the entry bank address latch 210 from the point where the memory controller 120 left off issuing the last auto-refresh command to the volatile memory 110. This is rendered possible because, as previously mentioned, the memory controller 120 issues auto-refresh commands in a sequential manner.<br><br>
WO 2005/119692	15	PCT/US2005/018917<br>
[0045]	Subsequently, following each refresh in self-refresh mode, the output of<br>
the entry bank address latch 210 is incremented. In effect, the entry bank address latch 210 becomes a counter. Hence, when in the self-refresh mode, the entry bank address latch 210 is incremented periodically and used to cycle through the banks 410; and the row increment counter 420 is also incremented periodically which, in turn, increments the row address counter 450 containing the target row address for a row to be refreshed, thereby allowing rows to be cycled through in the banks 410.<br>
[0046]	The volatile memory 110 as shown in FIG. 4 may further include the exit<br>
bank address latch 220 to effect the seamless refresh method described above. The bank address for the last bank that was refreshed in self-refresh mode is loaded into the exit bank address latch 220 by the volatile memory 110 and is available to the memory controller 120. Since the bank address of the last bank that was refreshed in self-refresh mode is now available to the memory controller 120, the memory controller 120 is able to pick up where the self-refresh mode left off and issue auto-refresh commands to refresh specific locations in the volatile memory 110. Hence, the volatile memory 110 is not required to reset the row increment counter 420 upon exiting the self-refresh mode, nor is the volatile memory 110 required to issue a number of auto-refreshes within one (1) average refresh period (tREFi) after exiting the self-refresh mode.<br>
[0047]	In another embodiment, the exit row address latch 230 (see FIG. 6) may<br>
be used with the volatile memory 110 as shown in FIG. 4. The volatile memory 110 may further load a row address from the row address counter 450 into the exit row address latch 230. The row address represents the last row that was refreshed prior to the volatile memory 110 exiting the self-refresh mode. Contents of the exit bank address latch 220 and the exit row address latch 230 are available to the memory controller 120 (see FIG. 1). As a result, the memory controller 120 may utilize the information relating to the last refreshed bank and row for future operations accordingly.<br>
[0048]	In the second approach, a memory controller is able to issue refreshes in<br>
any order to a volatile memory for auto-refresh operations in auto-refresh mode and some banks in the volatile memory can be refreshed ahead more than others.<br><br>
WO 2005/J19692	16	PCT/US2005/018917<br>
[0049]	FIG. 5 illustrates one embodiment of the volatile memory 110 that can be<br>
used to practice the independent refresh method under the second approach. The volatile memory 110 may further include the entry bank address latch 210, a refresh trigger 530, a number of refresh row counters 510a-d and a number of banks 520a-d. The entry bank address latch 210 is used to store the target bank address for the specific bank that is to be refreshed. The banks 520a-d are each associated with their corresponding refresh row counters 510a-d. The initial values for the refresh row counters 510a-d are initialized upon power-up or reset. For example, the refresh row counter 510a is associated with the bank 520a. The refresh row counters 510a-d are used to maintain target row addresses for rows that are to be refreshed in the respective banks 520a-d. The target row addresses stored in the refresh row counters 510a-d are independent of each other. The refresh trigger 530 is used to control the entry bank address latch 210 during self-refresh mode, as will be further described below. The refresh trigger 530 can be, for example, a clock or other timing mechanisms.<br>
[0050]	The memory controller 120 (see FIG. 1) can direct the volatile memory<br>
110 to enter into auto-refresh mode and auto-refresh a specific bank, e.g., the bank 520a, within the volatile memory 110 while other banks (such as, banks 520b-d) remain available for access. To initiate an auto-refresh cycle, the memory controller 120 (see FIG. 1) issues an auto-refresh command to the volatile memory 110 and loads the bank address 540 into the entry bank address latch 210. The bank address 540 is used to identify one of the banks 520a-d that is targeted for refresh. The bank address 540 is also used to identify the corresponding refresh row counter associated with the bank to be refreshed. Hence, with the bank address stored in the entry bank address latch 210 and the target row address stored in the corresponding refresh row counter, a specific row in a specific bank can be identified for refresh. After the refresh operation is performed, the refresh row counter associated with the bank that has just been refreshed is incremented by control logic (not shown). Because the memory controller 120 is aware of the specific bank to be refreshed, access to the other banks can continue without interruption. This maximizes the memory data bus utilization, reduces power consumption by avoiding unnecessary row close/open sequences, and serves to minimize transfer latency.<br><br>
WO 2005/119692	17	PCT/US2005/018917<br>
[0051]	In addition, because the banks 520a-d have their own refresh row<br>
counters 510a-d, the memory controller 120 has the flexibility to post independent refreshes to a specific bank. In other words, the banks 520a-d can be refreshed independent of each other. For example, in one instance, the memory controller 120 may issue auto-refresh command(s) to the volatile memory 110 to auto-refresh the bank 520a. One or more rows in the bank 520a are then refreshed beginning with the target row address stored in the refresh row counter 510a associated with the bank 520a. In another instance, the memory controller 120 may issue auto-refresh command(s) to the volatile memory 110 to auto-refresh a different bank, bank 520c. One or more rows in the bank 520c are then refreshed beginning with the target row address stored in the refresh row counter 510c associated with the bank 520c. It should be noted that the target row addresses stored in the refresh row counters 510a and 510c respectively can be the same or different.<br>
[0052]	By allowing each bank to be refreshed independently, the memory<br>
controller 120 is able to utilize those time periods when a given bank is idle to issue auto-refresh command(s) to the volatile memory 110 so that advanced refresh(es) can be performed on the idle bank ahead of schedule before they are due. Consequently, the availability of the banks 520a-d is increased since scheduled refresh(es) are performed less frequently when the banks 520a-d are active. In one example, if the bank 520a is idle for an extended period, additional advanced refresh(es) can be performed on the bank 520a; subsequently, scheduled refresh(es) for the bank 520a can be skipped while the bank 520a is active. In another example, if the bank 520b is idle for a shorter period, the memory controller 120 may choose to initiate fewer advanced refresh(es).<br>
[0053]	Having the ability to refresh ahead of schedule allows the banks 520a-d<br>
to operate more efficiently during periods of high data traffic. For example, if a given bank is n refreshes ahead of schedule, the memory controller 120 can avoid the overhead of issuing n regularly scheduled refreshes to that bank but can instead continue to carry out memory access operations. This maximizes memory data bus utilization, reduces power consumption by avoiding unnecessary row close/open sequences, and serves to minimize transfer latency.<br>
[0054]	Furthermore, the memory controller 120 may direct the volatile memory<br>
110 to enter into self-refresh mode.   When entering the self-refresh mode, the volatile<br><br>
WO 2005/119692	18	PCT/US2005/018917<br>
memory 110 begins with the most recent bank address stored in the entry bank address latch 210. The most recent bank address is generally the bank address used in the latest auto-refresh operation. By using the bank address currently stored in the entry bank address latch 210, the volatile memory 110 is able to pick up where the memory controller 120 left off after the last auto-refresh operation.<br>
[0055]	During each self-refresh operation, a target bank to be refreshed is<br>
identified by the bank address currently stored in the entry bank address latch 210. A specific row in the target bank that is to be refreshed is further identified by the target row address currently stored in the refresh row counter associated with the target bank. Hence, a refresh operation can be performed on the specific row in the target bank.<br>
[0056]	Furthermore, during each self-refresh operation, the entry bank address<br>
latch 210 is incremented by the refresh trigger 530. By incrementing the entry bank address latch 210, the bank address is updated to identify the next target bank to be refreshed. In addition, the refresh row counter associated with the bank that has just been refreshed is also incremented by control logic (not shown) to provide an updated target row address for that bank; the updated target row address will be used next time that bank is to be refreshed.<br>
[0057]	The next self-refresh operation is then performed using the updated bank<br>
address in the entry bank address latch 210 and the corresponding refresh row counter associated with the bank identified by the updated bank address.<br>
[0058]	As a result, when the volatile memory 110 enters the self-refresh mode,<br>
the banks 520a-d are cycled through using their corresponding refresh row counters 510a-d.<br>
[0059]	Alternatively, when the volatile memory 110 enters self-refresh mode, all<br>
the banks 520a-d can be refreshed concurrently using the target row addresses stored respectively in the corresponding refresh row counters 510a-d. The concurrent refresh of all the banks 520a-d and related operations of the refresh row counters 510a-d can be achieved via control logic (not shown). Based on the disclosure and teaching provided herein, a person of ordinary skill in the art will appreciate how to effect the concurrent refresh in accordance with the concepts disclosed in the present disclosure.<br><br>
WO 2005/119692	PCT/US2005/018917<br>
19<br>
[0060]	The volatile memory 110 as shown in FIG. 5 may further include the exit<br>
bank address latch 220 to effect the seamless refresh method described above. Upon entry into the self-refresh mode, the bank address for the target bank where the self-refresh cycle should begin is loaded into the entry bank address latch 210. Upon exit out of the self-refresh mode, the bank address for the last bank that was refreshed in self-refresh mode is loaded into the exit bank address latch 220 by the volatile memory 110 and is available to the memory controller 120. By having the entry and exit bank address latches 210 and 220, the memory controller 120 is no longer required to direct the volatile memory 110 to perform additional refreshes prior to entering the self-refresh mode. Without using the seamless refresh method to synchronize the memory controller 120 and the volatile memory 110, additional advanced refreshes would have been needed for each bank prior to the volatile memory 110 entering into the self-refresh mode because for each of the banks 520 advanced refreshes could be needed when entering and exiting the self-refresh mode.<br>
[0061]	In another embodiment, the exit row address latch 230 (see FIG. 6) may<br>
be used with the volatile memory 110 as shown in FIG. 5. The volatile memory 110 may further load a row address from one of the refresh row counters 510 into the exit row address latch 230. The row address represents the last row that was refreshed prior to the volatile memory 110 exiting the self-refresh mode. Contents of the exit bank address latch 220 and the exit row address latch 230 are available to the memory controller 120 (see FIG. 1). As a result, the memory controller 120 may utilize the information relating to the last refreshed bank and row for future operations accordingly.<br>
[0062]	The   methods   or   algorithms   described   in   connection   with   the<br>
embodiments disclosed herein may be embodied directly in hardware, in a software module executable by a processor, or in a combination of both, in the form of control logic, programming instructions, or other directions. A software module may reside in RAM memory, flash memory, ROM memory, EPROM memory, EEPROM memory, registers, hard disk, a removable disk, a CD-ROM, or any other form of storage medium known in the art. A storage medium may be coupled to the processor such that the processor can read information from, and write information to, the storage medium. In the alternative, the storage medium may be integral to the processor.<br><br>
WO 2005/119692	20	PCT/US2005/018917<br>
[0063]	The previous description of the disclosed embodiments is provided to<br>
enable any person skilled in the art to make or use the present invention. Various modifications to these embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments without departing from the spirit of scope of the invention. Thus, the present invention is not intended to be limited to the embodiments shown herein, but is to be accorded the full scope consistent with the claims, wherein reference to an element in the singular is not intended to mean "one and only one" unless specifically so stated, but rather "one or more". All structural and functional equivalents to the elements of the various embodiments described throughout this disclosure that are known or later come to be known to those of ordinary skill in the art are expressly incorporated herein by reference and are intended to be encompassed by the claims. Moreover, nothing disclosed herein is intended to be dedicated to the public regardless of whether such disclosure is explicitly recited in the claims. No claim element is to be construed under the provisions of 35 U.S.C. §112, sixth paragraph, unless the element is expressly recited using the phrase "means for" or, in the case of a method claim, the element is recited using the phrase "step for".<br><br>
WO 2005/119692	   21	                                                      PCT7US2005/018917<br>
WHAT IS CLAIMED IS:<br>
1.	A memory system comprising:<br>
a volatile memory having a plurality of banks and configured to engage in one of a plurality of operating modes including an auto-refresh mode and a self-refresh mode; and<br>
a memory controller configured to direct the volatile memory to engage in one of the plurality of operating modes;<br>
wherein upon the memory controller directing the volatile memory to engage in the self-refresh mode, the memory controller is further configured to provide an entry bank address to the volatile memory, the entry bank address corresponding to the first bank that is to be refreshed during the self-refresh mode; and<br>
wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to make an exit bank address available to the memory controller, the exit bank address corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode.<br>
2.	The system of claim 1 wherein the memory controller is further configured to issue an auto-refresh command to the volatile memory to refresh a bank that follows the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode after the memory controller receives the exit bank address.<br>
3.	The system of claim 1 wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to make an exit row address available to the memory controller, the exit row address corresponding to the last row that was refreshed prior to the volatile memory exiting the self-refresh mode.<br>
4.	The system of claim 1 wherein the volatile memory is one of a dynamic random access memory (DRAM) or a synchronous DRAM.<br>
5.	A memory system comprising:<br>
a volatile memory having an entry bank address latch, an exit bank address latch and a plurality of banks; and<br><br>
WO 2005/119692	22	PCT/US2005/018917<br>
a memory controller configured to direct the volatile memory to engage in one of a plurality of operating modes including an auto-refresh mode and a self-refresh mode;<br>
wherein upon the memory controller directing the volatile memory to engage in the self-refresh mode, the memory controller is further configured to load an entry bank address into the entry bank address latch, the entry bank address corresponding to the first bank that is to be refreshed during the self-refresh mode; and<br>
wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to load an exit bank address into the exit bank address latch, the exit bank address corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode, and wherein the exit bank address latch is accessible to the memory controller.<br>
6.	The system of claim 5 wherein the memory controller is further configured to issue an auto-refresh command to the volatile memory to refresh a bank that follows the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode after the memory controller retrieves the exit bank address from the exit bank address latch.<br>
7.	The system of claim 5 wherein the volatile memory further includes an exit row address latch, the exit row address latch being accessible to the memory controller; and<br>
wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to load an exit row address into the exit row address latch, the exit row address corresponding to the last row that was refreshed prior to the volatile memory exiting the self-refresh mode.<br>
8.	The system of claim 5 wherein the volatile memory is one of a dynamic<br>
random access memory (DRAM) or a synchronous DRAM.<br><br>
WO 2005/119692	23	   PCT/US2005/018917<br>
9.	A memory system comprising:<br>
a volatile memory having a plurality of banks, first storage means for storing an entry bank address and second storage means for storing an exit bank address; and<br>
a memory controller configured to direct the volatile memory to engage in one of a plurality of operating modes including an auto-refresh mode and a self-refresh mode;<br>
wherein upon the memory controller directing the volatile memory to engage in the self-refresh mode, the memory controller is further configured to load the entry bank address into the first storage means, the entry bank address corresponding to the first bank that is to be refreshed during the self-refresh mode; and<br>
wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to load the exit bank address into the second storage means, the exit bank address corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode, and wherein the second storage means is accessible to the memory controller.<br>
10.	The system of claim 9 wherein the memory controller is further<br>
configured to issue an auto-refresh command to the volatile memory to refresh a bank<br>
that follows the last bank that was refreshed prior to the volatile memory exiting the<br>
self-refresh mode after the memory controller retrieves the exit bank address from the<br>
second storage means.<br>
11.	The system of claim 9 wherein the volatile memory further includes a<br>
third storage means for storing an exit row address; and<br>
wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to load the exit row address into the third storage means, the exit row address corresponding to the last row that was refreshed prior to the volatile memory exiting the self-refresh mode, the third storage means being accessible to the memory controller.<br>
12.	The system of claim 10 wherein the volatile memory is one of a dynamic<br>
random access memory (DRAM) or a synchronous DRAM.<br><br>
WO 2005/119692	24	PCT/US2005/018917<br>
13.       A memory system comprising:<br>
a volatile memory having a plurality of banks, an entry bank address latch, an exit bank address latch, a refresh clock and a refresh counter, the refresh counter further having a row address counter and a row increment counter, wherein the refresh clock is configured to control the refresh counter and the entry bank address latch, wherein the row increment counter is configured to increment the row address counter; and<br>
a memory controller configured to control the volatile memory to engage in an auto-refresh mode or a self-refresh mode, the memory controller further configured to load a bank address for a target bank into the entry bank address latch;<br>
wherein the memory controller is further configured to direct the volatile memory to engage in the auto-refresh mode to perform an auto-refresh operation on the target bank;<br>
wherein the row increment counter is configured to be incremented each time an auto-refresh operation is performed;<br>
wherein the row increment counter is further configured to increment the row address counter after a predetermined number of auto-refresh operations have been performed;<br>
wherein the row address counter includes a row address that is usable to identify a row in the target bank for the auto-refresh operation;<br>
wherein upon the volatile memory entering into the self-refresh mode, the volatile memory is further configured to perform one or more self-refresh operations using the bank address stored in the entry bank address latch and contents stored in the refresh counter;<br>
wherein the volatile memory is further configured to increment the entry bank address latch and the refresh counter where appropriate after each self-refresh operation; and<br>
wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is configured to load the current value of the entry bank address latch into the exit bank address latch, the value in the exit bank address latch corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode.<br><br>
WO 2005/119692<br><br>
PCT/US2005/018917<br><br>
25<br>
14.	The system of claim 13 wherein the exit bank address latch is accessible<br>
to the memory controller; and<br>
wherein the memory controller is further configured to issue an auto-refresh command to the volatile memory to refresh a bank that follows the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode after the memory controller retrieves the value stored in the exit bank address latch.<br>
15.	The system of claim 13 wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to not reset the row increment counter.<br>
16.	The system of claim 13 wherein upon the volatile memory exiting the self-refresh mode, the memory controller is further configured to not issue any additional refresh within an average refresh period.<br>
17.	The system of claim 13 wherein the volatile memory further includes an exit row address latch; and<br>
wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is configured to load the current value of the row address counter into the exit row address latch, the value in the exit row address latch corresponding to the last row that was refreshed prior to the volatile memory exiting the self-refresh mode.<br>
18.	The system of claim 13 wherein the volatile memory is one of a dynamic random access memory (DRAM) or a synchronous DRAM.<br>
19.	A memory system comprising:<br>
a volatile memory having an entry bank address latch, an exit bank address latch, a plurality of banks, a plurality of refresh row counters, each refresh row counter associated with a corresponding bank and configured to store a target row address; and<br><br>
WO 2005/119692	PCT/l! S2005/018917<br>
a memory controller configured to direct the volatile memory to engage in an auto-refresh mode, the memory controller further configured to load a target bank address into the entry bank address latch;<br>
wherein the volatile memory is configured to perform an auto-refresh operation in the auto-refresh mode, the auto-refresh operation being performed on a target bank identified by the target bank address using the target row address stored in the refresh row counter associated with the target bank;<br>
wherein the memory controller is further configured to direct the volatile memory to engage in a self-refresh mode;<br>
wherein the volatile memory is further configured to cycle through the plurality of banks in the self-refresh mode by incrementing the entry bank address latch to generate the current target bank address; and<br>
wherein during each self-refresh operation, the volatile memory is further configured to refresh the bank identified by the current target bank address based on the target row address stored in the associated refresh row counter; and<br>
wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to load the value stored in the entry bank address latch into the exit bank address latch, the value in the exit bank address latch corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode.<br>
20.	The system of claim 19 wherein the exit bank address latch is accessible<br>
to the memory controller; and<br>
wherein the memory controller is further configured to issue an auto-refresh command to the volatile memory to refresh a bank that follows the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode after the memory controller retrieves the value stored in the exit bank address latch.<br>
21.	The system of claim 19 wherein the volatile memory is further<br>
configured to not perform any advanced refreshes prior to the volatile memory entering<br>
into the self-refresh mode.<br><br>
WO 2005/119692	PCT/US2005/018917<br>
27<br>
22.	The system of claim 19 wherein the volatile memory further includes an<br>
exit row address latch, the exit row address latch being accessible to the memory<br>
controller; and<br>
wherein upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to load the value stored in the refresh row counter associated with the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode into the exit row address latch.<br>
23.	The system of claim 19 wherein the volatile memory is one of a dynamic random access memory (DRAM) or a synchronous DRAM.<br>
24.	A method for controlling memory refresh for a volatile memory having a plurality of banks, comprising:<br>
forwarding an entry bank address to the volatile memory;<br>
directing the volatile memory to engage in a self-refresh mode to perform one or more self-refresh operations based on the entry bank address, the entry bank address corresponding to a target bank where the one or more self-refresh operations is to begin; and<br>
directing the volatile memory to make available an exit bank address upon the volatile memory exiting the self-refresh mode, the exit bank address corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode.<br>
25.	The method of claim 24 further comprising:<br>
directing the volatile memory to engage in an auto-refresh mode to perform an auto-refresh operation on a bank that follows the bank identified by the exit bank address.<br>
26.	The method of claim 24 further comprising:<br>
directing the volatile memory to make available an exit row address upon the volatile memory exiting the self-refresh mode, the exit row address corresponding to the last row that was refreshed prior to the volatile memory exiting the self-refresh mode.<br><br>
WO 2005/119692<br><br>
PCT7US2005/018917<br><br>
28<br>
27.	A method for controlling memory refresh for a volatile memory having<br>
an entry bank address latch, an exit bank address latch and a plurality of banks,<br>
comprising:<br>
loading an entry bank address into the entry bank address latch;<br>
directing the volatile memory to retrieve the entry bank address from the entry bank address latch;<br>
directing the volatile memory to engage in a self-refresh mode to perform one or more self-refresh operations based on the entry bank address, the entry bank address corresponding to a target bank where the one or more self-refresh operations is to begin; and<br>
storing an exit bank address into the exit bank address latch upon the volatile memory exiting die self-refresh mode, the exit bank address corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode.<br>
28.	The method of claim 27 further comprising:<br>
retrieving the exit bank address from the exit bank address latch; and directing the volatile memory to engage in an auto-refresh mode to<br>
perform an auto-refresh operation on a bank that follows the bank identified by the exit<br>
bank address.<br>
29.	The method of claim 27 wherein the volatile memory further includes an<br>
exit row address latch, the method further comprising:<br>
storing an exit row address into the exit row address latch upon the volatile memory exiting the self-refresh mode, the exit row address corresponding to the last row that was refreshed prior to the volatile memory exiting the self-refresh mode.<br><br>
Dated this 7th day of December, 2006<br><br>
S.AFSAR  <br>
OF K &amp; S PARTNERS AGENT FOR THE APPLICANTS<br><br>
ABSTRACT<br>
"METHOD AND SYSTEM FOR PROVIDING SEAMLESS SLEF REFRESH FOR DIRECTED BANK REFRESH<br>
IN VOLATILE MEMORIES"<br>
A memory system is provided. The system includes a volatile memory having a number of banks and configured to engage in one of a number of operating modes including an auto-refresh mode and a self-refresh mode, and a memory controller configured to direct the volatile memory to engage in one of the operating modes. Upon the memory controller directing the volatile memory to engage in the self-refresh mode, the memory controller is further configured to provide an entry bank address to the volatile memory, the entry bank address corresponding to the first bank that is to be refreshed during the self-refresh mode. Upon the volatile memory exiting the self-refresh mode, the volatile memory is further configured to make an exit bank address available to the memory controller, the exit bank address corresponding to the last bank that was refreshed prior to the volatile memory exiting the self-refresh mode.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWFic3RyYWN0KDAzLTA3LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-abstract(03-07-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWFic3RyYWN0LTEucGRm" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-abstract-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWFic3RyYWN0LmRvYw==" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-abstract.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWNhbmNlbGxlZCBwYWdlcygwMy0wNy0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-cancelled pages(03-07-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWNsYWltcyhncmFudGVkKS0oMDMtMDctMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-claims(granted)-(03-07-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWNsYWltcy5kb2M=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-claims.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWNvcnJlcG9uZGVuY2UgcmVjZWl2ZWQucGRm" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-correpondence received.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWNvcnJlc3BvbmRlbmNlKDAzLTA3LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-correspondence(03-07-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWNvcnJlc3BvbmRlbmNlKGlwbyktKDE1LTA3LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-correspondence(ipo)-(15-07-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWRlc2NyaXB0aW9uIChjb21wbGV0ZSkucGRm" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-description (complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWRyYXdpbmcoMDMtMDctMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-drawing(03-07-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0gMSgzMC0wNi0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form 1(30-06-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1NVU1OUC0yMDA2LUZPUk0gMTYoMjQtOS0yMDEwKS5wZGY=" target="_blank" style="word-wrap:break-word;">1514-MUMNP-2006-FORM 16(24-9-2010).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0gMTgoMTEtMTItMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form 18(11-12-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0gMihncmFudGVkKS0oMDMtMDctMjAwOCkucGRm" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form 2(granted)-(03-07-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0gMjYoMTEtMTItMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form 26(11-12-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0gMygwMy0wNy0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form 3(03-07-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0gMygxMS0xMi0yMDA2KS5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form 3(11-12-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0gMygyMy0wNC0yMDA3KS5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form 3(23-04-2007).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0gMygzMC0wNi0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form 3(30-06-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0gNSgzMC0wNi0yMDA4KS5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form 5(30-06-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0tMS5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0tMTgucGRm" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0tMi5kb2M=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form-2.doc</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0tMi5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0tMjYucGRm" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form-26.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0tMy5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form-3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0tNS5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form-5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0tcGN0LWliLTMwNC5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form-pct-ib-304.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0tcGN0LWliLTMxMS5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form-pct-ib-311.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0tcGN0LWliLTMzMi5wZGY=" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form-pct-ib-332.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0tcGN0LWlzYS0yMTAoMTEtMTItMjAwNikucGRm" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form-pct-isa-210(11-12-2006).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0tcGN0LWlzYS0yMjAucGRm" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form-pct-isa-220.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LWZvcm0tcGN0LWlzYS0yMzcucGRm" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-form-pct-isa-237.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LXBjdC1zZWFyY2ggcmVwb3J0LnBkZg==" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-pct-search report.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MTUxNC1tdW1ucC0yMDA2LXBldGl0aW9uIHVuZGVyIHJ1bGUgMTM3KDAzLTA3LTIwMDgpLnBkZg==" target="_blank" style="word-wrap:break-word;">1514-mumnp-2006-petition under rule 137(03-07-2008).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=YWJzdHJhY3QxLmpwZw==" target="_blank" style="word-wrap:break-word;">abstract1.jpg</a></p>
		<br>
		<div class="pull-left">
			<a href="222003-method-and-plant-for-the-heat-treatment-of-solids-containing-iron-oxide.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="222005-a-porous-polymeric-membrane.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>222004</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>1514/MUMNP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>39/2008</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>26-Sep-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>15-Jul-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>11-Dec-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 Morehouse Drive, San Diego, California 92121-1714,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>REMAKLUS, Perry, Willmann Jr.</td>
											<td>American citizen of 5313 Inglwood Lane, Raleigh, NC 27609</td>
										</tr>
										<tr>
											<td>2</td>
											<td>WALKER, Robert, Michael</td>
											<td>American citizen of 9000 Deerland Grove Drive, Raliegh, NC 27615</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G11C11/406</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US2005/018917</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-05-26</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/575,335</td>
									<td>2004-05-27</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>10/982, 277</td>
									<td>2004-11-05</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/222004-method-and-system-for-providing-seamless-self-refresh-for-directed-bank-refresh-in-volatile-memories by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:01:05 GMT -->
</html>
