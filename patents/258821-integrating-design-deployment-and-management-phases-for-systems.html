<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/258821-integrating-design-deployment-and-management-phases-for-systems by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 04:19:20 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 258821:INTEGRATING DESIGN, DEPLOYMENT, AND MANAGEMENT PHASES FOR SYSTEMS</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">INTEGRATING DESIGN, DEPLOYMENT, AND MANAGEMENT PHASES FOR SYSTEMS</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Integrating design, deployment, and management phases for a system in accordance with certain aspects includes using a system definition model to design a system. The system defmition model is subsequently used to deploy the system on one or more computing devices and, after deployment of the system, the system defmition model is used to manage the system deployed on the one or more computing devices.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FORM 2<br>
THE PATENTS ACT 1970<br>
[39 OF 1970]<br>
COMPLETE SPECIFICATION<br>
[See Section 10; rule 13]<br>
"INTEGRATING  DESIGN,  DEPLOYMENT,  AND  MANAGEMENT PHASES  FOR<br>
SYSTEMS"<br>
MICROSOFT CORPORATION, a Corporation of the State of Washington having<br>
a place of business at One Microsoft Way, Redmond, Washington 98052-6399,<br>
United States of America,<br>
The following specifïcation particularly describes the nature of the<br>
invention and the marmer in which it is to be performed:-<br><br><br>
RELATED APPLICATIONS<br>
 This application claims the benefit of U.S. Provisional Application No.<br>
60/452,736, filed March 6, 2003, entitled "Architecture for Distributed Computing<br>
System and Automated Design, Deployment, and Management of Distributed<br>
Applications", which is hereby incorporated herein by reference.<br>
This application is related to the following US patent applications (all of<br>
which are incorporated by reference herein):<br>
US Patent Application Serial No. 10/382,942, filed on March 6, 2003, titled<br>
"Virtual Network Topology Generation", which is hereby incorporated herein by<br>
reference.<br>
US Patent Application Serial No. 09/695,812, filed on October 24, 2000,<br>
titled "System and Method for Distributed Management of Sbared Computers",<br>
which is hereby incorporated herein by reference.<br>
US Patent Application Serial No. 09/695,813, filed on October 24, 2000,<br>
titled "System and Method for Logical Modeling of Distributed Computer<br>
Systems", which is hereby incorporated herein by reference.<br>
US Patent Application Serial No. 09/695,820, filed on October 24, 2000,<br>
titled "System and Method for Restricting Data Transfers and Managing Software<br>
Components of Distributed Computers", which is hereby incorporated herein by<br>
reference.<br>
US Patent Application Serial No. 09/695,821, filed on October 24, 2000,<br>
titled "Using Packet Filters and Network Virtualization to Restrict Network<br>
Communications", which is hereby incorporated herein by reference.<br>
US Patent Application Serial No. 097696,707, filed on October 24, 2000,<br>
titled "System and Method for Designing a Logical Model of Distributed<br>
i<br>
l<br><br>
Computer System and Deploying Physical Resources According to the Logical<br>
Model", which is hereby incorporated herehi by reference.<br>
US Patent Application Serial No. 09/696,752, filed on October 24, 2000,<br>
titled "System and Method Providing Automatic Policy Enforcement in a Multi-<br>
Computer Service Application", which is hereby incorporated herein by reference.<br>
TECHNICAL FIELD<br>
The invention relates to an architecture for a distributed computing system.<br>
BACKGROUND<br>
Internet usage has exploded over the past several years and continues to<br>
grow. People have become very comfortable with many services offered on the<br>
World Wide Web (or simply "Web"), such as electronic mail, online shopping,<br>
garthering news and information, listening to music, viewing video clips, looking<br>
for jobs, and so forth. To keep pace with the growing demand for Internet-based<br>
services, there has been tremendous growth in the computer systems dedicated to<br>
hosting Websites, providing backend services for those sites, and storing data<br>
associated with the sites.<br>
One type of distributed computer system is a data center (such as an<br>
Internet data center (IDC) or an Enterprise Data Center (EDC)), which is a<br>
specifïcally designed complex that houses many computers for hosting network-<br>
based services. Data centers, which may also go by the names of "Webfarms'1 or<br>
"server farms", typically house hundreds to thousands of computers in climate-<br>
controlled, physically secure buildings. Data centers typically provide reliable<br>
Internet access, reliable power supplies, and a secure operating environment.<br>
2<br><br>
Today, large data centers are complex and often called upon to host<br>
Multiple applications. For instance, some websites may operate several thousand<br>
computers, and host many distributed applications. These distributed applications<br>
often have complex netwerking requirements that require operators to physically<br>
connect computers to certain network switches, as well as manually arrange the<br>
wiring configurations within the data center to support the complex applications.<br>
As a result, this task of building physical network topologies to conform to the<br>
application requirements can be a cumbersome, time consuming process that is<br>
prone to human error. Accordingly, there is a need for improved techniques for<br>
designing and deploying distributed applications onto the physical computing<br>
system.<br>
SUMMARY<br>
Integrating design, deployment, and management phases for systems is<br>
described herein.<br>
In accordance with certain aspects, a system defnition model is used to<br>
design a system. The system defmition model is subsequently used to deploy the<br>
system on one or more computing devices. After deployment of the system, the<br>
system defmition model is used to manage the system deployed on the one or<br>
more computing devices.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
The same numbers are used throughout the drawings to reference like<br>
features.<br>
Fig. l illustrates an example network setting.<br>
3<br><br><br>
Fig. 2 is a block diagram illustrating an example architecture using the<br>
SDM definition model<br>
Fig. 3 illustrates an example layered setting.<br>
Fig. 4 is a flowchart illustrating an example process for using the system<br>
definition model (SDM) across the entire lifecycle of a system,<br>
Fig. 5 illustrates an example architecture using an SDM runtime.<br>
Fig. 6 illustrates an example SDM document.<br>
Fig. 7 illustrates an base definition and members.<br>
Fig. 8 illustrates an example member.<br>
Fig. 9 illustrates example setting values and value lists.<br>
Fig.   10   illustrates   an   example  lifecycle   of an   SDM   application   in<br>
accordance with certain embodiments.<br>
Fig. 11 shows an example mapping of a web application to a web server<br>
host.<br>
Fig. 12 illustrates an example built-in datatype hierarchy.<br>
Fig. 13 illustrates an example of implicit extension of an abstract object<br>
definition.<br>
Fig.   14   illustrates   an   example   of implicit  extension   of  an   abstract<br>
relationships.<br>
Fig. 15 illustrates an example of a change request.<br>
Fig. 16 illustrates an example process of loading new defmitions into the<br>
runtime.<br>
Fig. 17 illustrates an example of carrying out change requests.<br>
Fig. 18 illustrates examples of connected members.<br>
Fig. 19 illustrates example structures with regard to connections.<br>
4<br><br>
Fig. 20 illustrates an example UML diagram that provides an overview of<br>
  the instance space.<br>
Fig. 21 illustrates a general computer environment which can be used to<br>
implement the techniques described herein.<br>
DETAILED DESCRIPTION<br>
The following disclosure describes a number of aspects pertaining to an<br>
architecture for designing and implementing a distributed computing system with<br>
large-scale application services. The disclosure includes discussion of a system<br>
defmition model (SDM), which may also be referred to as a service definition<br>
model (SDM), and an SDM runtime environment. The SDM provides tools and a<br>
context for an application architect to design distributed computer applications and<br>
data centers in an abstract marmer. The model defines a set of elements that<br>
represent functional units of the applications that will eventually be implemented<br>
by physical computer resources and software. Associated with the model elements<br>
is a schema that dictates how functional operations represented by the components<br>
are to be specified.<br>
As used herein, the term "wire" may also be referred to as "connections",<br>
"communication", or "communication relationship". Also, the term "system"<br>
may be referred to as "module" and the term "resource space" may be referred to<br>
as "resources". Additionally, the term "application space" may also be referred to<br>
as "applications", and the term "instance space" may also be referred to as<br>
"instances". Further, the term "class" may also be referred to as "abstract<br>
defmition", the term "port" may also be referred to as "endpoint", and the term<br>
"type" may also be referred to as "defmition".<br>
5<br><br>
Fig. l illustrates an example network 100. In setting 100, multiple (x)<br>
- computing devices 102(1), 102(2), . . ., 102(x) are coupled to a network 106.<br>
Network 106 is intended to represent any of a variety of conventional network<br>
topologies and types (including wire and/or wireless networks), employing any of<br>
a variety of conventional network protocols (including public and/or proprietary<br>
protocols). Network 106 may include, for example, a local area network (LAN), a<br>
wide area network (WAN), portions of the Internet, and so forth. Setting 100<br>
represents any of a wide variety of settings, including, for example, data centers<br>
(e.g., Internet data centers (IDCs)), office or business settings, home settings,<br>
educational or research facilities, retail or sales settings, data storage settings, and<br>
so forth.<br>
Computing devices 102 can be any of a variety of conventional computing<br>
devices, including desktop PCs, werkstations, mainframe computers, server<br>
computers, Internet appliances, gaming consoles, handheld computers, cellular<br>
telephones, personal digital assistants (PDAs), etc. One or more of devices 102<br>
can be the same types of devices, or alternatively different types of devices.<br>
Additionally, even if multiple devices are the same types of devices, the multiple<br>
devices may still be confïgured differently (e.g., two devices 102 may be server<br>
computers, but may have different hardware confïgurations, such as different<br>
processors, different amounts of RAM, different sizes of hard disk drives, and so<br>
forth).<br>
One or more computing devices 102 may also be re-configured after being<br>
added to setting 100. For example, a particular computing device 102 may operate<br>
for a period of time (e.g., on the order of minutes, hours, days, months, etc.)<br>
performing one function, and then an administrator may decide that a different<br>
6<br><br>
fiunction is desirable (e.g., change from being a server computer to a workstation<br>
computer, from a web server to a local file server, etc.).<br><br>
Fig. 2 is a block diagram illustrating an example architecture 200 using the<br>
system defïnition model. The SDM is designed to be used across the entire<br>
lifecycle of a system. A system is a set of related software and/or hardware<br>
resources that can work together to accomplish a common function. One example<br>
of such a system is an application, which refers to a set of instructions that can be<br>
run or executed by a computing device to perform various functionality. Examples<br>
of applications include entertainment applications such as games, productivity<br>
applications such as word processors, reference applications such as electronic<br>
encyclopedias, distributed applications such as may be used for web services or<br>
fmancial analysis, and so forth. Another example of such a system is an<br>
environment on which an application (or another environment) can be deployed.<br>
An environment refers to the software and/or hardware resources on which an<br>
application (or another environment) is deployed. Such environments can be<br>
layered, as discussed in more detail below.<br>
The lifecycle of a system typically includes three primary phases (also<br>
referred to as stages): a design or development phase, followed by a deployment<br>
or installation phase, followed by an operations or management phase. As the<br>
model applies to all three phases of the lifecycle of a system, the model can thus<br>
be seen as an integration point for the various phases in the lifecycle of a system,<br>
and facilitates each of these phases. Additionally, by using the model knowledge<br>
can be transferred between these phases, such as: knowledge regarding<br>
management of the system (e.g., being fed back to the design and development<br>
team, allowing the design and development team to modify the system, such as for<br>
7<br><br>
future verslons or to improve the performance of the current version); knowledge<br>
of the structure, deployment requirements and operational behavior of the system;<br>
knowledge of the operational environment from the desktop to the data center;<br>
knowledge of the service level as observed by the end user; and so forth.<br>
Generally, during the design phase, development tools leveragirtg the SDM<br>
are used to defme a system comprised of communicating software and hardware<br>
components. A system definition conrains all information necessary to deploy and<br>
operate a distributed system, including required resources, confïguration,<br>
operational features, policies, etc. During the deployment phase, the system<br>
definition is used to automatically deploy the system and dynamically allocate and<br>
configure the software and hardware (e.g., server, storage and networking)<br>
resources required. The same system definition can be used for deployments to<br>
different host environments and to different scales. During the management<br>
phase, an SDM Service in the operating system provides a system-level view for<br>
managing the system. This enables new management tools to drive resource<br>
allocation, confïguration management, upgrades, and process automation from the<br>
perspective of a system.<br>
The architecture 200 employs the SDM definition model as well as a<br>
schema that defines functional operations within the SDM definition model. The<br>
definition model includes various different kinds of data structures which are<br>
collectively referred to as "definitions". Functionaliry of the SDM is exposed<br>
through one or more platform services, such as application program interfaces<br>
(APIs).<br>
During the design phase for a system, a development system 202 generates<br>
a document that contains the system definition, such as an SDM document 204.<br>
8<br><br>
Development system 202 can be any of a variety of development systems, such as<br>
the Visual Studio® development system available from Microsoft® Corporation<br>
of Redmond, Washington. SDM document 204 defmes all Information (also<br>
referred to herein as knowledge) related to the deployment and management of the<br>
system. Any knowledge necessary for or used when deploying the system or<br>
managing the system is included in SDM document 204. Although described<br>
herein as a single document, it is to be appreciated that the knowledge could<br>
aïternatively be spread out and maintained in multiple documents.<br>
A system definition defmes a system in terms of one or more of resources,<br>
endpoints, relationships and sub-systems. A system defmition is declared in an<br>
SDM document (e.g., an XML document). Resources may be hardware resources<br>
or software resources. Endpoints represent Communications across systems.<br>
Relationships defme associations between systems, resources and endpoints. Sub-<br>
systems can be treated as complete systems and are typically part of a larger<br>
system.<br>
A system defmition captures the basic structure of a dynamic system. It<br>
can be viewed as the skeleton on which all other information is added. This<br>
structure is typically specified during the development process, by architects and<br>
developers, and typically does not change frequently. In addition to the structure,<br>
the SDM can contain deployment information, installation processes, schemas for<br>
configuration, events and instrumentation, automation tasks, health models,<br>
operational policies, etc. Other information can be added by the operations staff,<br>
by vendors, and/or by management systems across the lifetime of a distributed<br>
system.<br>
9<br><br>
SDM document 204 includes one or more constraints (also referred to as<br>
requirements) of the system that an environment in which the system is to be<br>
deployed and/or run must satisfy. The environment itself is also described using<br>
an SDM document. Such environments can be single computing devices, or<br>
alternatively collections of computing devices (e.g., data centers), application<br>
hosts, etc. Different systems can be installed to different environments. For<br>
example, a data center may include fifty computing devices, and one system may<br>
be deployed to five of those computing devices, while another system may be<br>
deployed to thirty five of those computing devices. These requirements can take a<br>
variety of forms, such as: hardware requirements regarding the computing<br>
device(s) on which the system is to be deployed (e.g., a minimum processor speed,<br>
a minimum amount of memory, a minimum amount of free hard drive space, a<br>
minimum amount of network bandwidth available, particular securiry mechanisms<br>
available, and so forth), software requirements regarding the computing device(s)<br>
on which the system is to be deployed (e.g., a particular operating system, one or<br>
more other applications that also must be installed, specifications regarding how a<br>
particular system and/or the operating system is to be confïgured, a particular type<br>
of security or encryption in use, and so forth), other requirements regarding the<br>
computing device(s) on which the system is to be deployed (e.g., particular<br>
security keys available, data center policies that must be enforced, authentication<br>
that is used, environment topology, etc.).<br>
Requirements can also go in the other direction - that is, the environment<br>
can have constraints or requirements on the configuration of the system that is to<br>
be installed (e.g., to implement the standards or policies of the environment).<br>
These can be "explicit" requirements that are created by the operator of the<br>
10<br><br>
environment, such as particular settings or configurations the system must have,<br>
particular functionality the system must provide or support, particular security<br>
mechanisms the system must support, and so forth. These can also be "implicit"<br>
requirements that that arise because of a particular configuration of the<br>
environment. For example, if a host computing device in the environment is using<br>
a particular type of file system then it may not be possible for some actions to be<br>
performed using that file system (although it may be possible for those same<br>
actions to be performed using another file system).<br>
During the design and development phase of the system, SDM document<br>
204 can be used to validate the system for one or more particular environment(s).<br>
This is a two-way validation: the system is validated for the environment and the<br>
environment is validated for the system, The environment can be validated for the<br>
system by comparing the requirements identifïed in the SDM document 204 with<br>
the environment and determining whether all of the requirements are satisfied by<br>
the environment.  The system can be validated for the environment by comparing<br>
the requirements identifïed in an SDM document for the environment with the<br>
system and determining whether all of the requirements are satisfied by the<br>
system. If all of the requirements are satisfied by the environment and the system,<br>
then the designer or developer knows that the system can be deployed in and with<br>
run in the environment. However, if all of the requirements are not satisfied by the<br>
environment and/or the system, then the designer or developer is optionally<br>
informed of the requirements that were not satisfied, thereby informing  the<br>
designer or developer of what changes should be made to the SDM document 204<br>
(and correspondingly to the system) and/or to the environment in order for the<br>
system to be deployed and run in that environment.<br>
11<br><br>
The knowledge regarding deployment of the systern that is included in the<br>
SDM document 204 describes how the system is to be deployed in one or more<br><br>
environments.   The SOM document 204 is made available to a controller 206,<br>
which includes a deployment module 208 and a management module 210. In<br>
certain embodiment, the SDM document 204 as well as all of the files of the<br>
system (e.g., binaries, data, libraries, etc.) needed to install the system are<br>
packaged together into a single container (e.g., a single fïle) referred to as an SDU<br>
(System Defmition Unit). Controller 206 can be one or more of computing<br>
devices 102 of Fig. 1. For example, a single device 102 of Fig. l may be the<br>
controller for a particular data center, or alternatively the controller responsibilities<br>
may be distributed across multiple devices 102.<br>
Deployment module 208 includes services that are used to deploy the<br>
system in the environment(s). In Fig. 2, the environment in which the system is<br>
deployed is (or is deployed on) one or more target devices 212. Systems may also<br>
be deployed to controller 206. These services of deployment module 208 include<br>
one or more functions that can be called or invoked to install or deploy one or<br>
more systems in the environment.<br>
Different knowledge for deployment in different environments may be<br>
included in the SDM document 204. This deployment knowledge describes any<br>
changes that need to be made to the in the environment (e.g., changes to a system<br>
registry; folders, directories, or files that need to be created; other setting or<br>
configuration parameters of the computing device that need to be set to particular<br>
values; and so forth), as well as what files (e.g., program and/or data files) that<br>
need to be copied to the computing device(s) in the environment and any<br>
operations that need to be performed on those files (e.g., some files may need to be<br>
12<br><br>
decompressed and/or decrypted). In many implementations, the deployment<br>
knowledge in the SDM document 204 includes, for example, information<br>
analogous to that presently found in typical setup or installation programs for<br>
systerns.<br>
During the deployment process, controller 206 generates a record or store<br>
of the software and hardware resources involved in the deployment as well as the<br>
relationships between them. This record or store can subsequently be used by<br>
controller 206 during the management phase.<br>
Management module 210 includes services that are used to manage the<br>
system once it is installed in the environment(s). These services of management<br>
module 210 include one or more functions that can be called or invoked to manage<br>
the systems in the environment. The knowledge regarding management of the<br>
system that is included in the SDM document 204 describes how the system is to<br>
be managed in one or more environments.<br>
Different knowledge for managing a system in different environments may<br>
be included in the SDM document 204. The management knowledge includes any<br>
knowledge used in the management or operation of the system. Management<br>
involves, for example, configuration (and optionally subsequent reconfiguration),<br>
patching and upgrading, maintenance tasks (e.g., backup), health or performance<br>
monitoring, and so forth.<br>
Changes to deployed systems are made through management module 210.<br>
The services of management module 210 include one or more functions that can<br>
be called or invoked to make changes to one or more systems deployed in the<br>
environment. By making such changes through the management module 210,<br>
several benefits can be realized. One such benefit is that controller 206 can<br>
13<br><br>
maintain a record of the changes that have been made.    Controller 206 may<br>
miaintain a copy of the SDM document 204 for the system and record in the SDM<br>
document 204 any changes that are made to the system.  Alternatively, controller<br>
206 may maintain a separate record of the changes made to the system.<br>
This record of changes maintained by controller 206 can simplify<br>
subsequent operations, such as solving problems with the system and/or<br>
environment, or when having to reinstall the system due to a hardware failure<br>
(allowing the system to be reinstalled and returned to running with the same<br>
parameters/settings as it had at the time of failure). By having such changes made<br>
through controller 206 and by having controller 206 maintain the record, some<br>
human error can be removed from the environment (e.g., if the administrator<br>
making the change is supposed to log the change in a book but forgets to do so<br>
there would be no record of the change - this problem is solved by having<br>
controller 206 maintain the record).<br>
Furthermore, by making changes to systems through controller 206, as well<br>
as deploying systems through controller 206, controller 206 can serve as the<br>
repository of knowledge about the environment, the systems deployed in the<br>
environment, and interactions between them. Knowledge regarding the<br>
environment and/or systems deployed in the environment can be readily obtained<br>
from controller 206. This knowledge can be used to ensure the consistency of the<br>
controlled environment by validating that the controlled devices in the<br>
environment reflect the state stored in the central controller 206.<br>
It should be noted that in some situations changes may be made to a system<br>
and/or environment but are not made through controller 206. For example, a<br>
computing device may be accidentaliy turned off or may fail. In these situations,<br>
14<br><br>
attempts are made to reflect such changes in controller 206. These changes may<br>
be reflected in controller 206 automatically (e.g., a system may run that attempts<br>
to detect device failures and use the services of management module 210 to notify<br>
controller 206 of such failures) or may be reflected in controller 206 manually<br>
(e.g., an administrator may use the services of management module 210 to notify<br>
controller 206 of such changes). Altematively, the changes that were made could<br>
be reversed to bring the system and/or portion of the environment back into line<br>
with the desired state of the system as recorded by controller 206.<br>
The SDM document 204 can thus be viewed as a "live" document - it can<br>
be constantly changing based on changes to the environment and/or changes to the<br>
system throughout the lifecycle of the system.<br>
The SDM enables the functional composition of systems across a horizontal<br>
and vertical axis. Composition along the horizontal axis is done with systems and<br>
subsystems. Composition along the vertical axis is done with "layers".<br>
Applications, services, network topologies, and hardware fulfill a role in a<br>
distributed system, but are typically defined independently and owned by different<br>
teams or organizations. Layering is accomplished by components defïning a set of<br>
constraints on a host and vice versa.<br>
Fig. 3 illustrates an example layered setting. Four layers are illustrated in<br>
Fig. 3: layer 302, layer 304, layer 306, and layer 308. Although four layers are<br>
shown in Fig. 3, the actual number of layers can vary, and can be greater or less<br>
than four. Additionally, the content of different layers can vary in different<br>
embodiments. As can be seen in Fig. 3, the different layers are situated above<br>
and/or below other layers (e.g., layer 306 is above layer 304 but below layer 308).<br>
15<br><br>
Different systems and subsystems within a layer can interact with one<br>
another, and also can interact with systems and subsystems of different layers. For<br>
example, a subsystem 310 in layer 308 can interact with a subsystem 312 in layer<br>
308, as well. as a subsystem 314 in layer 306. Additionally, each layer can be<br>
viewed as the environment for the next higher layer. For example layer 306 is the<br>
environment for systems and subsystems in layer 308, while layer 304 is the<br>
environment for systems and subsystems in layer 306. Each layer 302, 304, 306,<br>
and 308 has its own associated SDM document.<br>
The different layers 302, 304, 306, and 306 can represent different content.<br>
In certain embodiments, layer 302 is a hardware layer, layer 304, is a netwerk<br>
topology and operating systems layer, layer 306 is an application hosts layer, and<br>
layer 308 is an applications layer. The hardware layer represents the physical<br>
devices (e.g., computing devices) on which the layered system is built (e.g.,<br>
devices 102 of Fig. 1). The network topology and operating systems layer<br>
represents the network topology of the computing devices (e.g., network setting<br>
100 of Fig. 1) as well as the operating systems installed on those computing<br>
devices. The application hosts layer represents applications installed on the<br>
computing devices that can host other applications (e.g., SQL Server, IIS, and so<br>
forth). The application layer represents applications that are installed on the<br>
computing devices that do not host other applications (e.g., entertainment<br>
applications such as games, productivity applications such as word processors,<br>
reference applications such as electronic encyclopedias, distributed applications<br>
such as may be used for web services or fmancial analysis, and so forth).<br>
16<br><br>
Fig, 4 is a flowchart illustrating an example process 400 for using the <br>
across the entire lifecycle of a system.  The various acts of process 400 of Fig. 4<br>
can be implemented in software, firmware, hardware, or combinations thereof.<br>
Initially, the system is designed based on the SDM (act 402). The system is<br>
designed to incïude requirements that an environment(s) must satisfy in order for<br>
the system to be deployed and run in the environment, as well as additional<br>
knowledge that is used for the deployment and management of the system. This<br>
knowledge is included in an SDM document associated with the system. Once<br>
designed, the system can optionally be validated using the SDM (act 404). This<br>
validation allows the designer or developer to verify that the system will be able to<br>
be deployed and run in the environment being validated against. As discussed<br>
above, not only is the system validated against the environment in which it is to be<br>
deployed, but that environment is also validated against the system. If the<br>
validation fails for a particular environment, then additional design steps can be<br>
taken to alter the system so that the system can be run in that environment (or<br>
alternatively steps can be taken to alter the environment).<br>
Once validated, the system can be deployed using the SDM (act 406).<br>
When deploying the system in an environment, the system is installed in that<br>
environment so that it can be subsequently run in the environment. The<br>
knowledge used to install the system is included in the SDM document associated<br>
with the system. Once deployed, the system is monitored and/or managed using<br>
the SDM (act 408). Knowledge in the SDM document associated with the system<br>
identifies how the system is to be monitored and/or managed, and the system is<br>
monitored and/or managed within the environment in accordance with this<br>
knowledge.<br>
17<br><br>
Process 400 of Fig. 4 can be used with systems that are applications as well<br>
as systems that are environments. For example, an application can be validated<br>
against the SDM of its environment (e.g., an application in layer 308 of Fig. 3 is<br>
validated against the environment of layer 306 of Fig. 3). By way of another<br>
example, an operator or system architect can design environments (e.g., layer 306<br>
or layer 304 of Fig. 3) and validate those environments against the environments<br>
they are to be deployed in (e,g., layers 304 and 302, respectively).<br>
The constraints on a system and/or the environment can also be used during<br>
runtime (while the system is being monitored and/or managed) to validate changes<br>
to the system and/or the environment during runtime. Such runtime validation<br>
allows, for example, an operator of an environment to determine how changes to<br>
the environment may affect a running system, or a system designer to determine<br>
how changes to the system may affect its running in the environment.<br>
In the discussions to follow, reference is made to flow and setting flow with<br>
respect to the runtime. Flow is used to pass configuration information between<br>
parts of a distributed system (e.g., allowing a developer to specify the<br>
configuration information in one place or allowing an operator to only provide a<br>
single entry). Flow is also used to determine the impact of changes to<br>
configuration by following the flow of setting data between parts of the system.<br>
Fig. 5 illustrates an example architecture 500 using an SDM runtime.<br>
Architecture 500 is an example of architecture 200 of Fig. 2 using an SDM<br>
runtime 510 as well as the example implementation of the SDM discussed below<br>
in the section "Example SDM Implementation". The SDM runtime 510 contains a<br>
set of components and processes for accepting and validating SDM files, loading<br>
SDUs (System Definition Units - which are packages of one or more SDM files<br>
18<br><br>
and their related  files),  creating  and executing  SDM  Change Requests  and<br>
deploying   SDM   based   systems   into   target   environments.      The   runtime<br>
functionality allows systems described using the SDM to be defmed and validated,<br>
deployed to a set of computing devices, and managed.<br>
The SDM, which is discussed in more detail below in the section "Example<br>
SDM Implementation" is designed to support description of the configuration,<br>
interaction and changes to the components in a distributed system (the modeled<br>
system). SDM is based on an object-relational model. "Definitions" describe<br>
entities that exist in a system and "relationships" identify the links between the<br>
various entities. Definitions and relationships are further defmed to capture<br>
semantic information relevant to the SDM. In particular, defmitions are divided<br>
into components, endpoints and resources. Relationships are divided into the<br>
following: connections (also referred to as communication), containment, hosting,<br>
delegation and reference. Further details regarding defmitions and relationships<br>
are provided below.<br>
The SDM includes "abstract defïnitions" that provide a common<br>
categorization of system parts, provide tooi support for a wide range of systems<br>
and provide the basis for defmition checking at design time. A set of abstract<br>
defmitions provide a comprehensive basis for service design. "Concrete<br>
defmitions" represent parts of an actual system or data center design. A concrete<br>
defmition is generated by selecting an abstract defmition and providing an<br>
implementation that defmes the concrete defmition's members and setting values<br>
for its properties. Distributed applications are generated using collections of these<br>
concrete defïnitions.<br>
19<br><br>
The SDM also includes "constraints" that model restrictions based on the<br>
allowed set of relationships in which an instance of a relationship can participate.<br><br>
Constraints are useful in describing requirements that depend on the confïguration<br>
of objects involved in a reïationship. For example, a constraint may be used to<br>
determine whether participants on each end of a communication protocol are using<br>
compatible security settings.<br>
In order to effect change on a target system, SDM uses a declarative<br>
description of the required changes called a "change request" or CR. SDM defines<br>
the process that is used to expand, validate and execute a change request as part of<br>
the "SDM execution model".<br>
The "instance space" captures both the desired and current state of the<br>
managed application. Changes in the instance space are tracked and associated<br>
with the change request that initiated the change. The instance space is stored in<br>
an SDM runtime and reflects the current state of the modeled system, The runtime<br>
contains a complete record of the instances that have been created and the<br>
relationships between these instances. Each instance has an associated version<br>
history where each version is linked to a change request. The process of creating<br>
new instances is initiated by a change request. The change request defïnes a set of<br>
create, update and delete requests for defmitions and relationships associated with<br>
specific members of an existing instance.<br>
The following is a brief, functional discussion of how the components in<br>
Fig. 5 work together. An operator or administrator is able to describe an<br>
environment into which applications can be deployed, such as the topology of a<br>
data center. The operator or administrator produces an SDM file describing the<br>
environment, the file being referred to as the "logical infrastructure" (LIM) 502, or<br>
20<br><br>
as a data center description or data center model. This SDM file can be generaled<br>
using any of a variety of development systems, such as the Visual Studio®<br>
development   system   available   from   Microsoft®   Corporation   of  Redmond,<br>
Washington.<br>
Additionally, an application developer is able to design and develop their<br>
application using any of a variety of development systems, such as the Visual<br>
Studio® development system. As the developer defïnes components of the<br>
application and how these components relate to one another, the developer is able<br>
to validate the application description against the datacenter description 502. This<br>
is also referred to as "Design Time Validation".<br>
Once the application is complete, the developer saves the description in an<br>
SDM and requests that the application be packaged for deployment as an SDU<br>
504. The SDU includes the application SDM as well as the application binaries<br>
and other referenced files used to install the application.<br>
The LIM 502 and SDU 504 are fed to deployment tooi 506 of a controller<br>
device 520 for deployment. Deployment tooi 506 includes a user interface (UI) to<br>
enable an operator to load the desired SDU 504. Deployment tooi 506 works with<br>
create CR module 530 to install the application associated with the SDU 504 in<br>
accordance with the information in the SDM within SDU 504. Additionally, SDM<br>
defmitions and instances from SDU 504 are populated in a store 508 of the SDM<br>
runtime 510. SDUs are managed in SDM runtime 510 by SDU management<br>
module 540, which makes the appropriate portions of the SDUs available to other<br>
components of runtime 510 and target(s) 522.<br>
The operator can also specify what actions hè or she wants to take on the<br>
targets 522 (e.g., target computing devices) on which the application is being<br>
21<br><br>
deployed. The operator can do this via a deployment file, which is also referred to<br>
herein as a Change Request (CR). The CR is run through one or more engines<br>
512, 514, 516, and 518. Generally, expand CR engine 512 expands the CR to<br>
identify all associated components as well as their connections and actions, flow<br>
values engine 514 flows values for the components (such as connection strings),<br>
check constraints engine 516 checks constraints between the environment and the<br>
application, and order actions engine 518 specifies the order for all of the<br>
necessary actions for the CR.<br>
To initiate change to the system (including deploying an application) or<br>
validation of a model, an operator or process submits a CR. The CR contains a set<br>
of actions that the operator wants performed over the instances in the runtime 510.<br>
These actions can be, for example, create actions, update actions, and/or delete<br>
actions.<br>
In addition to user or operator initiated change requests, there may also be<br>
expansion/automatically generaled change requests that are generated as part of<br>
the expansion process, discussed in more detail below. Regardless of their source,<br>
the change requests, once fully expanded and checked, are executed by sending<br>
actions to the targets 522, such as; discover, install, uninstall and change a target<br>
instance.<br>
The CR is treated as an atomic set of actions that complete or fail as a<br>
group. This allows, for example, the constraint checking engine 516 to consider<br>
all actions when testing validity.<br>
In design time validation, the CR will be created by the SDM Compiler 528<br>
and will contain one or the minimum of each SDM component in the SDM file.<br>
This CR of create instance commands will flow through the expansion engine 512,<br>
22<br><br>
the flow values engine 514, and the constraint checking engine 516.  Errors found<br>
in these three phases wil! be returned to the user via the development system hè or<br>
she is using.<br>
In deployment, the operator wil! create a CR with the UI presented by<br>
deployment tooi 506. The CR will flow through all the engiries 512, 514, 516, and<br>
518 in the SDM runtime 510, and the appropriate actions and information will be<br>
sent by CR module 532 to the appropriate target(s) 522, where the request is<br>
executed (e.g., the application is installed). The appropriate target(s) 522 for a<br>
particular installation are typically those target(s) on which the application is to be<br>
installed.<br>
When beginning to process a CR, in a defmition resolution phase, create<br>
CR module 530 resolves all defmitions and members that are referenced in the<br>
change request. The change request will assume that these are already loaded by<br>
the runtime 510; create CR module 530 initiates a load/compile action if they do<br>
not exist. Create CR module 530 also implements a path resolution phase where<br>
references to existing instances and instances defmed by create actions within the<br>
change request are resolved.<br>
The expansion performed by expansion engine 512 is a process where,<br>
given a change request, all the remaining actions required to execute the request<br>
are populated. In general, these actions are construction and destruction actions<br>
for defmition and relationship instances. The operator could optionally provide<br>
details for all the actions required to construct or destroy an instance, or<br>
alternatively portions of the process can be automated: e.g., the operator provides<br>
key information about the changes he or she wants by identifying actions on<br>
members (e.g., byReference members), and the remainder of the actions are filled<br>
23<br><br>
in on nested members (e.g., byReference and byValue members) and relationships.<br>
By way of another example, automated expansion can also refer to external<br>
resource managers that may make deployment decisions based on choosing<br>
devices with available resources, locating the application close to the data it<br>
requires, and so forth.<br>
Expansion engine 512 also performs "auto writing". During auto writing,<br>
engine 512 analyzes the scale invariant grouping of components and compound<br>
components specified in the SDM and determines how the components should be<br>
grouped and interconnected when scaled to the requested level.<br>
Expansion engine 512 also performs value member expansion, reference<br>
member expansion, and relationship expansion.<br>
Value member expansion refers to identification of all of the non-reference<br>
definition members. The cardinality of these members are noted and, since all the<br>
required parameters are known, for each member create requests are added to the<br>
change request for those members whose parent is being created. If the change<br>
request contains destruction operations, then destruction operations are added for<br>
all their contained instances.<br>
Reference member expansion refers to reference members (as opposed to<br>
non-reference defmition members). The cardinality of reference members is often<br>
undefined and they can have deployment time settings that require values in order<br>
for the instance to be constructed. So the process of expanding a reference<br>
member (e.g., a byReference member) can require more information about the<br>
instance than the runtime is in a position to provide.<br>
Related to reference member expansion is a process referred to as<br>
discovery, which is a process used to find instances that have already been<br>
24<br><br>
deployed. Discovery is an action typically initiated by an operator of the<br>
environment, For example, during an install request, expansion engine 512<br>
determines if the instance already exists, if so determines what exists and if not<br>
then creates it. An instance manager (IM) 534 on the controller 520<br>
communicates with the instance managers 526 on the target device 522 to initiate<br>
a discovery process'. The discovery process returns data regarding the instance<br>
from the target device 522 to the controller 520.<br>
The process of discovery populates reference defmition members as part of<br>
a construction or update action. Typically, only reference members with object<br>
managers (instance managers that also do discovery) that support discovery<br>
participate in this process.<br>
When a new instance is discovered a check is made that the instance does<br>
not already exist in the SDM database using instance specific key values. Once it<br>
is known that it is a new instance, the instance is classified according to the<br>
definitions of the members being discovered. If the instance does not match a<br>
member or there is an ambiguous match then the member reference is left blank<br>
and the instance is marked as offline and incomplete.<br>
Relationship expansion refers to, once all the defmition instances that will<br>
be constructed are known, creating relationship instances that bind the defmition<br>
instances together. If defmition instances are being destroyed, all relationship<br>
instances that reference the defmition instances are removed.<br>
To create the relationships the member space is used to identify the<br>
configurations of the relationships that should exist between the instances. Where<br>
the defmition members have cardinality greater than one the topology of the<br>
relationships is inferred from the base relationship defmition. For example, for<br>
25<br><br>
communication   relationship   an   "auto   wiring"   can   be   done,   and   for  host<br>
-relationships a host is picked based on the algorithm associated with the hosting<br>
relationship.<br>
During a flow stage, flow values engine 514 evaluates flow across all the<br>
relationship instances. Flow values engine 514 may add update requests to the<br>
change request for instances that were affected by any altered parameter flow.<br>
Engine 514 evaluates flow by determining the set of instances that have updated<br>
settings as a result of the change request. For each of these, any outgoing settings<br>
flows that depend on the rnodified settings are evaluated and the target nodes<br>
added to the set of changed instances. The process continues until the set is empty<br>
or the set contains a cycle.<br>
After the flow stage, a process of duplicate detection is performed, The<br>
duplicate detection may be performed by one of the engines illustrated in Fig. 5<br>
(e.g., flow values engine 514 or check constraints engine 516), or alternatively by<br>
another engine not shown in Fig. 5 (e.g. a duplicate detection engine may be<br>
included in SDM runtime 510). The process of duplicate detection matches<br>
expanded instances against instances that already exist in the SDM data store, For<br>
example, the process detects if another application has installed a shared file.<br>
When an instance that already exists is detected, one of several actions can be<br>
taken depending on the version of the existing instance; the install can be failed;<br>
the instance can be reference counted; the instance can be upgraded; or the<br>
installation can be performed side-by-side.<br>
Check constraints engine 516 implements a constraint evaluation phase in<br>
which all the constraints in the model are checked to see if they will still be valid<br>
after the change request has been processed.<br>
26<br><br>
After check constraints engine 516 finishes the constraint evaluation phase,<br>
a complete list of actions is available.   So, order actions engine 518 can use the<br><br>
relationships between components to determine a valid change ordering. Any of a<br>
variety of algorithms can be used to make this determination.<br>
Once order actions engine 518 is finished determining the ordering,<br>
deployment can be carried out by distributing subsets of the ordered set of actions<br>
that are machine specific. Once the actions have been ordered and grouped by<br>
machine, the actions as well as a copy of the necessary portion of the SDM<br>
runtime store 508 with instance information are sent to a target computing device<br>
522. The SDM can be stored temporarily at the target device in a store cache 538.<br>
The target computing device includes a target portion 536 of the SDM<br>
runtime that communicates with SDM runtime 510. The target computing device<br>
522 also includes an agent that contains an execution engine 524 and can<br>
communicate with the appropriate instance managers (IMs) 526 on the target<br>
device to make changes on the target, such as create, update, and delete actions.<br>
Each action is sent as an atomic call to the instance manager 526 and the instance<br>
manager 526 returns a status message and for some actions, also returns data (e.g.,<br>
for discovery). Once all the actions are completed on target 522, the target's agent<br>
returns any errors and status to the controller 520. The controller 510 then uses<br>
this information to update the SDM .runtime store 508.<br>
As discussed above, change is carried out by breaking the change requests<br>
down into disrributable parts based on the relationships that are affected. Once all<br>
the parts are completed (or after one or more has failed) the results are collated in<br>
the runtime 510 and a summary retumed to the operator. In the event of a failure,<br>
27<br><br>
all the actions can be "rolled back" and the system returned to the state it was in<br>
before the change was initiated.<br>
In certain embodiments, during design time validation discussed above, an<br>
SDM Compiler 528 receives an SDM file,, creates a test CR, runs the test CR<br>
through the expand, flow values and check constraints engines of the SDM<br>
runtime, and returns any errors to the development system. This process provides<br>
SDM validation for deployment during design time for the developer.<br>
The public interface to SDM runtime 510 and/or controller 520 is through<br>
an object model (APIs) library. The library is a managed code object model and<br>
allows the following to be performed:<br>
•	Manage the SDMs in the runtime - SDM files can be loaded into the<br>
runtime,   SDMs are immutable and are loaded one at a time (i.e., an<br>
SDM file can be loaded rather than only parts of the file (e.g., individual<br>
ones of the individual definitions, classes or mappings from the SDM<br>
file)).   SDMs can be deleted from the runtime and an XML document<br>
for an SDM in the runtime can be produced.<br>
•	Manage the SDU known by the runtime,<br>
•	Manage SDM defmitions - fmd and reflect on SDM elements (from an<br>
SDM loaded in the runtime).    There is no public API provided for<br>
authoring a new SDM (i.e., this is a read only. .object model over the<br>
immutable  elements   of the  SDM).     This  includes  SDMs,   SDUs,<br>
identities,    versions,    classes,    defmitions,    binding/mappings    and<br>
versioning policy.<br>
•	Manage SDM instances - fmd and reflect on instances of components,<br>
endpoints, resources  and relationships.    In the instance space each<br>
28<br><br>
instance can be identified by a GUID, a stable path or an array based<br>
path. The paths are strings and can be relative. These identifiers,<br>
including relative paths allows instances to be foimd and referenced in<br>
documents such as the change request document.<br>
Manipulate instances - make changes to SDM instances, including<br>
creating, changing topology, upgrading, changing settings and deleting.<br>
Instance changes are made within the bounds of a change request which<br>
provides an atomic unit of update so that any errors or constraint<br>
violations will result in the entire request failing. Instance requests also<br>
allow for instances to exist temporarily without a binding to a host, as<br>
an instance must have a host when the request is committed. It also<br>
allows for many operations that will affect a single component's<br>
installation or settings to be performed and have the installation or<br>
settings update deferred until cornmit so that a single update occurs on<br>
the component. The SDM model checking is performed prior to or at<br>
change request cornmit time and the commit will fail on any model or<br>
constraint violations.<br>
Load a change request - a change request is a document, for example an<br>
XML file, that represents a set of instance space operations. This<br>
document can take advantage of relative paths to be a reusable 'script'<br>
for creating or deleting application instances.<br>
Find and reflect on change requests - including getting the<br>
installation/update tasks and all error information, and retrying the<br>
installation/update of components affected by the request.<br>
29<br><br>
•	Generale a change request document from a change request in the<br>
database. Such documents are somewhat portable.<br>
•	Subscribe to events on change request tasks, such as progress, log or<br>
status updated, .The lifetime of these event subscriptions limited by the<br>
lifetime of the process that loaded the cliënt library (i.e. these are<br>
regular CLR events).<br>
The SDM runtime engine performs the reasoning on the SDM model and<br>
the functions surfaced by the APIs. The library communicates to the runtime<br>
engine as a web service with fairly coarse calls such as load SDM, create<br>
component instance and get entire SDM (for reflecting on SDM entities). The<br>
format of many of the parameters for this web service is XML with the same<br>
schema for SDM files. The engine may also perforrn checks on permissions.<br>
The controller 520 can make use of Instance Managers (IMs), which can be<br>
associated with any definition or relationship in the model. IMs may perform one<br>
or more of the following roles:<br>
•	Support deployment of the instance.<br>
•	Support validation of the instance once it has been deployed (auditing).<br>
•	Support discovery of already deployed instances that were not deployed<br>
through the runtime.<br>
•	Support flow of setting values.<br>
•	Support evaluation of constraints.<br>
•	Support expansion of a change request.<br>
•    Support presentation of the instance to a user as a CLR class through the<br>
API.<br>
30<br><br>
For deployment, an instance manager (IM) plug-in on controller 520 is<br>
Associated with a class host relation and is separate from the plug-in used in the<br>
development system that provides the design experience for the classes and<br>
produces the associated binaries in the SDU 504 and the settings schema. Instance<br>
managers are supplied to the SDM runtime 510 as CLR classes (e.g., in a dll<br>
assembly) that implement an instance manager interface or inherit from abstract<br>
class. An SDM Instance Manager, also referred to as an Instance Manager (IM)<br>
plug-in, provides the following functions to the controller 520:<br>
•	Generales the files and commands (tasks) to install, uninstall or reinstall<br>
component instances on their hosts - When a change request results in a<br>
new component instance, removal of a component instance or a change<br>
to a component that requires an uninstall and reinstall, it is the instance<br>
manager that takes the settings for the instance, the host instance, the<br>
defmitions associated with the component and the binaries associated<br>
with those defmitions in the SDU 204 and produces the files and<br>
commands needed to perform the install or uninstall on a target server<br>
ready for either manual  execution or dispatch via the deployment<br>
engine.<br>
•	Generales the files and commands (e.g., tasks) to update a component<br>
instance when its settings change or when the view from one of its<br>
endpoints changes (e.g., due to communication relationship topology<br>
changes or a visible endpoint has settings change)<br>
•	Maps   the   endpoint   instances   visible   on   a   component   instance's<br>
endpoints to settings on component instance - In the SDM a component<br>
instance has endpoint instances that, as a result of some communication<br>
31<br><br>
relationship topology, can see other endpoint instances, The details of<br>
the other endpoint instances are mapped to settings that the component<br>
instance can fetch at runtime, usually so that it can bind to it. For<br>
example, a web site may have a database cliënt endpoint instance so a<br>
communication relationship can be established with a database. When<br>
correctly established its database cliënt endpoint is able to see a single<br>
database server endpoint instance and the settings on that server<br>
endpoint, This information is used by the instance manager to place a<br>
connection string for the server in a configuration file under the name of<br>
the cliënt endpoint. The end result is that code simply reads the<br>
connection string for the database from its configuration settings.<br>
•	Generales the files and commands (tasks) to audit a component instance<br>
- Auditing confirms existence, correct settings. This may apply to host<br>
instance settings also.<br>
•	For any task will report status - The IM will translate the output<br>
captured, either partial or complete, and provide the status of the task as<br>
success,   failure   or   incomplete   and   optionally   offer   progress   on<br>
incomplete (% or last response), details on failure (error message) and a<br>
human readable log on any status.    By going back to the instance<br>
manager to interpret the output of a task, the instance manager is free to<br>
have its tasks log structured information (for example, as XML or even<br>
SOAP) rather than trying to have to produce sufficient logging for<br>
diagnosis while keeping it human readable.<br>
32<br><br>
• The instance managers may also provide code that does the constraint<br>
checking between hosts and their guests. Installers may use a common<br>
constraint language, for example based on XML, XPath and XQuery.<br>
33<br><br>
Example SDM Implementation<br>
         The following discussion describes an embodiment of the schema that defines the<br>
elements of the SDM.<br>
1    Definitions<br>
Term	Definition<br>
Change Request       A declarative document that describes a set of changes to a modeled system<br>
Fully qualified	A change request that has passed through the model evaluation stages and is now ready<br>
cnange request         to be executed against the target system<br>
Abstract type	A type that is used to define the settings required to act on a modeled system object<br>
Concrete type	A reusable definition of a modeled system object that contains definitions for member<br>
types and relationships.<br>
Relationship	An sdm object that is used to describe the interaction between modeled system elements<br>
System Definition      An xml document that contains definitions for abstract objects, concrete types and<br>
Model (SDM)	relationships<br>
Document<br>
Software	The combination of a set of SDM documents and the associated binary information (files)<br>
Distribution Unit         required to deploy those types to an SDM managed system<br>
(SDU)<br>
SDM Layer	A layer is a set of abstract objects that are specific to the objects modeled in that layer. For<br>
example the application layer types may tnclude Web applicaöon and Database, while the<br>
operating system tayer may include types for file systems and network devices. Some<br>
types wil! not be assigned to layers and witl instead be usabie across a range of layers.<br>
SDM Instance     '     A set of concrete type and relationship instances that represent the modeled system<br>
space<br>
34<br><br>
2   Architectural Overview<br>
The System Deftnition Mode! (SDM) is designed is to support description of the configuration,<br>
interaction and changes to the components in a distributed system (the mode/ed system).<br>
SDM is based on an object-relational model. We use objects to describe entities thai exist in the<br>
system and relationships to identify the links between them. The SDM further refines objects and<br>
relationships to capture semantics that are important to the SDM. In particular, we divide objects into<br>
systems, endpoints and resources and we divide relationships into communication, containment.<br>
hosting, delegation, and reference.<br>
We use abstract definitions to provide a common categorization of system parts allowing tooi support<br>
for a wide range of apptications and providing the basis for type checking at design time. We expect the<br>
set of abstract definitions to provide a comprehensive basis for system design and we expect that they<br>
will change slowly over time.<br>
We build concrete object definitions that represent parts of an actual appiication or datacenter design.<br>
We take an abstract object definition and provide an implementation that defines the concrete type's<br>
members and setting values for its properties. We then build systems from colSections of these<br>
definitions.<br>
Constraints are used to model restrictions over the allowed set of relationships that an instance can<br>
participate in. We use constraints to capture fine grained requirements that depend on the configuration<br>
of objects involved in a relationship. For example, a constraint may be used to validate that participants<br>
on each end of a communication protocol are using compatible security settings.<br>
!n order to effect change on the target system, SDM uses a declarative description of the required<br>
changes called a change request. SDM defines the process that is used to expand, validate and<br>
execute a change request as part of the SDM execution model.<br>
The instance space captures both the desired and current state of the managed appiication. We track<br>
changes in the instance space and associate them with the change request that initiated the change.<br>
The following umi diagrams capture the broad interactions between the objects in the sdm model. For<br>
simplicity some of these interactions have been defined between base types where the actual<br>
interaction exists between derived types and as a result is more specialized. For example,<br>
communication relationships may only reference abstract endpoint definitions.<br>
An Sdrn document contains information that describes the document, managers for the definitions in<br>
the document, import statements that reference other documents and a set of definitions.<br>
Fig. 6 illustrates an example document.<br><br>
AlI sdm definititions derive from a common base definition and may contain members as shown in Fig.<br>
7. The relationship between definitions and members can be more complex than is shown on the<br>
foliowing diagrams.<br>
35<br><br>
Members are divided by the kind of definition that they reference as shown in Fig. 8.<br>
Setting declarations reference a setting definition. Setting values and value lists provide values for<br>
settings as shown in Fig. 9.<br>
2.1 THE LIFECYCLE OF AN SDM APPLICATION<br>
An example lifecycle of an SDM application in accordance with certain embodiments is shown in Fig.<br>
10.<br>
The application is designed and implemented within the visual studio environment (biock 1002).<br>
Developers implement components and then combine them within compound components. The<br>
application is described within an SDM file. In order to verify that their appltcation will deploy within a<br>
particular datacenter a developer will bind their application to a representation of the datacenter also<br>
described in an SDM file (block 1004). This representation will include definitions for the hosts of their<br>
application components and constraints on the configuration of their application. If the binding fails,<br>
then the developer can revise their application design.<br>
Once a developer is happy with their application, they can sign and publish the application so that there<br>
is nowa strong name and version associated with the application (block 1006). The published form of<br>
an application is called a Software distribution Unit (SDU). The operator takes the SDU from the<br>
developer and loads the application into the SDM runtime (block 1008). In the process of loading the<br>
application, the operator chooses the model of the datacenter to which they want to bind the<br>
application. When the operator chooses to deploy an application they supply deployment time<br>
parameters to the application and they determine the scale of the application (block 1010). This is<br>
done using a change request.<br>
Once an application is deployed, the operator can interact with the runtime tö determine the<br>
configuration of the application and the setting for each part of the application (block 1012). The<br>
runtime can also verify that the actual configuration of the application matches the desired configuration<br>
as recorded in the runtime. The operator can remove a deployed application by submitting a change<br>
request (block 1014). The operator can also rollback individual changes made to the running<br>
application such as removing a service pack. In block 1016, the configuration of a running application<br>
can be changed by adding or removing parts of the deployed application such as to web frontends.<br>
The application can also be upgraded by installing newer versions of one or more of the application<br>
components.<br>
Z2 ABSTRACT OBJECT AND RELAT1ONSHIP DEFINITIONS<br>
Abstract object definitions defme the building blocks that we need in order to check application<br>
configuration at design time and then to deploy and manage an application at run time. These building<br>
blocks represent entrties that exist in the modeled system. For example, we use abstract object<br>
definitions to model files and directories, the configuration inside a web server or the databases inside a<br>
sql server.<br>
36<br><br>
We use abstract relationship definitions to model the interactions that can occur between abstract<br>
object definitions. Relationships are binary and directed, identifying the object definition that defines the<br>
instances that participate in manifestations of the relationship. Relationships provide a way of tying<br>
objects together so that we can model containment, construction and communication links between<br>
objects.<br>
Constraints are then used by objects to constrain the relationships they participate in and by<br>
relationships to constrain the objects that can be linked. These constraints can target both the definition<br>
and the settings of participants in a relationship. This allows a constraint to narrow the participants in a<br>
relationship to instance that are derived from a particular definition and to require that the instance have<br>
setting values that fa!l in a particular range.<br>
We divide Object definitions into three categories: systems, endpoints and resources.<br>
Abstract system definitions are used to describe self-contained independently deployable parts of an<br>
application. These definitions represent parts of an application that interact through well defined<br>
communication channels that can cross process and machine boundaries.<br>
Abstract endpoint definitions are used to describe the communication endpoints that a system may<br>
exposé. These are used to model afl forms of communication that the system should be aware of in<br>
order to verify system connectivity at design time and to enable connections at runtime.<br>
Abstract resource definitions describe behavior that is contained within a system. Resource definitions<br>
may have strong dependencies on other resource definitions. These dependencies can include<br>
requiring a specific instaliation order and initiating runtime interaction through undocumented<br>
communication mechanisms.<br>
All abstract object definitions share the ability to exposé settings. These settings are simple name-value<br>
pairs that use xml schema to define the type of the setting. Settings can be dynamic or static, if they are<br>
static then they can only be set during the deployment process, if they are dynamic, then they can be<br>
changed after deployment. The code responsible for applying settings values to the running system is<br>
hosted in the SOM runtime.<br>
The SDM supports inheritance over abstract object definitions. A derived definitions can extend the<br>
properties exposed by its parent and can set values for its parents properties. A derived definition can<br>
participate in any of the relationships that identify its parent as a participant.<br>
Relationship definitions are divided in five categories: communication, .containment, delegation, hosting,<br>
and reference.<br>
Communication relationships are used to capture potenttal communication interactions between<br>
abstract endpoint definitions. The existence of a communication relationship indicates that it may be<br>
possible for systems that exposé endpoints of the identified definition to communicate. The actual<br>
establishment of the link is subject to constraints on the endpoints and the exposure of the endpoints.<br>
Containment relationships describe that ability for an abstract object definition to contain members of<br>
another abstract object definition. More specrfically, a containment relationship between two abstract<br>
object definitions A and B allows a concrete object definition that implements A to contain a mernber of<br>
a concrete object definition that implements B.<br>
37<br><br>
We use containment to model the natural nesting structures that occurwhen developers build<br>
applications. By containing a member object, the parent is able to control the lifetime and vtsibility of the<br>
contained object. All object instances in the run time space exist as rnembers of other object instances,<br>
forming a completely connected set of instances. Thus, the set of containment relationship describes<br>
the atlowed containment pattems that occur in the instance space.<br>
Delegation relationships are used to selectively exposé contained object members; in particular, we<br>
use delegation to exposé endpoint rnembers from system definitions. By delegating a endpoint from a<br>
subsystem, the outer system exposes the ability to communicate on a particular protocol without<br>
exposing the implementation behind the protocol.<br>
Hosting and reference relationships are two forms of dependency relationship. A hosting relationship<br>
describes a primary dependency between abstract objects that should exist before an insiance of a<br>
concrete object can be created. Every instance should participate as a guest in exactly one hosting<br>
relationship, resulting in the hosting relationships also forming a completely connected tree over the<br>
instance space. Reference relationships capture additiona! dependencies that can be used for<br>
parameter flow and for construction ordering.<br>
2.3 CONCRETE OBJECT AND RELATIONSHIP DEFINITIONS<br>
We build concrete object definitions from abstract object definitions and concrete relationship definitions<br>
from abstract relationship definitions,<br>
The combination of abstract object definitions and abstract relationship definitions defines a schema for<br>
modeling the target system. The role of a concrete object definition is to use a subset of the abstract<br>
definition space to create a reusable conftguration based on one or more abstract definitions. As a<br>
simple analogy, the abstract definition space can be compared to the schema for database; the<br>
concrete object definition would then represent a reusable template for a set of rows in the database.<br>
The rows are ónly created in the database when an instance of the concrete object is created. To<br>
perform design time validation we can vaiidate a concrete object definition against the abstract<br>
definition space in the same way that we would vatidate the rows in the database against the<br>
constraints of the schema (for example foreign keys, etc).<br>
Each concrete object definition provides an implementation for a specific abstract object definition. The<br>
implementation includes extensions to the settings schema, values for settings and declarations for<br>
object member, relationship members and constraint members and flow members. The behavior of the<br>
concrete object follows the definition of the abstract object: abstract system definition become concrete<br>
system definitions, abstract endpoint definitions become concrete endpoint definitions and abstract<br>
resource definitions become concrete resource definitions.<br>
Each concrete relationship definition provides an implementation for a specific abstract relationship<br>
definition. The implementation can include settings declarations and values, nested members of the<br>
same relationship category (hosting, containment, cornmunication etc), and constraints on the types<br>
that can participate in the relationship.<br>
38<br><br>
Concrete hosting relationships are used to define a mapping of the members of one concrete object<br>
onto another concrete object. For example, a concrete hosting relationship can be used to identify the<br>
bindings between a web application and the I(S host that it will be deployed to. More than one concrete<br>
hosting relationship can exist for a given type allowing the developer to define different deployment<br>
configurations for specific topologies<br>
2A MEMBERS<br>
A concrete type can declare members of other concrete or abstract objects - we call these object<br>
members. These members are then referenced trom relationship members that define the relationships<br>
between the object members.<br>
Object members are used to create instances of a particuiar object definition. Settings flow can be used<br>
to provide values for the object. When dedaring an object memoer, the user can decide whether the<br>
object member is created at the same time the outer system is created (value semantics) or is created<br>
by an explicit new operation that occurs at some later time (reference semantics).<br>
Relationship members define the relationships that object members wil! participate in when they are<br>
created. If an object member is contained by its parent, then a containment relationship member will be<br>
declared between the type member and the outer type. If the object member is delegated, then a<br>
delegation relationship member would be defined between the object member and a nested object<br>
member. Communication relationship members can be dedared between endpoints on object<br>
members and dependency relationship members (reference and hosting) can be declared between<br>
object members or nested object members.<br>
Relationship constraints are used to narrow the set of relationships that a particuiar object is willing to<br>
participate in. They identify constraints on a particuiar relationship and on the participants at the other<br>
end of the relationship.<br>
Z5 INSTANCE SPACE<br>
The instance space stored in the SDM runtime reflects the current state of the modeled system. The<br>
runtime contains a complete record of the instances that have been created and the relationships<br>
between these instances. Each instance has an associated version history where each version is<br>
linked to a change request.<br>
The process of creating new instances is initiated by a change request. The change request defines a<br>
set of create, update and delete requests for types and relationships associated with specific members<br>
of an existing instance; the root is a special case.<br>
The change request is expanded by the runtime, verified against aft constraints, and then constructed.<br>
The expansion process identifies object and relationship instances that are constructed implicitly as<br>
part of the construction request of the containing object and then settings flow is then evaluated across<br>
all relationships. The verification step checks that al! required relationships exist and that the<br>
relationships fulfill all constraints. Finally, the construction process determines an apprapriate ordering<br>
over the deployment, update or removal of each instance and then in the correct sequence passes<br>
each instance to an instance manager to perform the appropriate action.<br>
39<br><br>
2.6 LAYERING<br>
The goal of the SDM model is to allow a separation of concerns between the developers of<br>
applications, the designers of the software infrastructure and the architects of the datacenter. Each of<br>
these groups focuses on particular services and has a differing set of dependencies.<br>
For example, developers mainly care about the confïguration and connectivtty between the hosts that<br>
they depend on such as SQL, IIS and the CLR. Designers of the host configuration care about the<br>
network tcpology and the OS configuration, while the architects developing the network topology, OS<br>
configuration and storage mapping need to know about the hardware that exists in the datacenter.<br>
To support this separation of concerns, SDM exposes a concept of layering. Layering is the use of<br>
hosting relationships to bind an application to the services that it depends on without decfaring those<br>
services as part of the containment structure of the application,<br>
We identify four layers as part of the SDM mode!...<br>
Application layer<br>
•	The application layer supports the construction of applications in a constrained context. The<br>
context is defined by the configuration of the hosts identified in the host layer<br>
•	Examples of system definitions in the application layer include web services, databases and<br>
biztalk schedules.<br>
Host Layer<br>
•	Build datacenters out of software components. Configure the connections between<br>
components. Some of these components act as hosts for the appiication layer.<br>
•	Examples of system definitions in this layer- I!S, SQL, AD, EXCHANGE, DNS and Biztalk.<br>
Network / OS / Storage layer<br>
•	Build data center networks and platforms. Configure the network security model and the<br>
operating system platform configuration. Add storage to operating system configurations.<br>
•	Examples of system definitions in this layer - VLAN, Windows, Filter, Storage.<br>
Hardware layer<br>
The hardware layer identifies the types of machines that exist in the datacenter and the physical<br>
connections that exist between these machines.<br>
Fig. 11 shows the example mapping of a layer 4 web application to a layer 3 web server host. The<br>
outer box at each tayer represents a system, the boxes on the boundary represent endpoints and the<br>
boxes on the inside represent resources. We map each of these elements via a hosting relationship to<br>
a host at the layer below.<br>
in order to satisfy the relationships required of a system we bind that system to a host system that has<br>
matching capabilities. We cal! this process placement. At design time, we construct a concrete hosting<br>
relationship that represents a possible placement. At deployment time, we instantiate an instance of the<br>
concrete hosting relationship to bind the guest system instance to the host system instance.<br>
40<br><br>
2.7 MODEL EVALUAT1ON<br>
Associated with the SDM model is well-defined process for managing change to a distributed system.<br>
Each change is driven by a declarative change request that passes through several processing steps<br>
before the actions in the request are distributed and then executed against target systems.<br>
3   Impleméntation Details<br>
3.1 NAMING<br>
There are a number of places in the SDM where we need a strong naming system for identifying<br>
objects. The following naming system allows the creator of a type to sign the definition in such a way<br>
that that the user of the definition can be sure that it is the same as the one that developer originally<br>
published.<br>
The following header is an exampie of an identifier for an sdm namespace:<br><sdrn name="FileSystem"></sdrn>
version="0.1.0.0"<br>
publicKeyToken="AAAABBBBCCCCDDDD"<br>
cutture="neulral"<br>
platform="neutral"<br>
publicKey="aLongKey"<br>
stgnature=TheHashOfTheFileContents'&gt;<br><br>
To reference a type in another namespace you need to import the namespace:<br>
«import alias ="FileSystern" name="FileSystem" version="0.1.0,0" publicKeyToken="AAAABBBBCCCCDDDD7&gt;<br>
Then you can use the alias to refer to types within the namespace;<br>
File System file<br>
3.1.1   Identity<br>
SDM names are scoped by the namespace in which they are defined. A namespace is identified by a<br>
name, version, language and a public key token and is contained within a single file.<br>
The base form of identity includes name, version, culture, platform and a public key token.<br><attributegroup name><br><xs name="name" type="simp!eNameH use=" required7><br><artribute name- type="fourPartVersionType" use="required"></artribute><br><attribute name="publicKeyToken" type="publicKeyTokenType" use="optional"></attribute><br><attribule name="cullure" type="xs:string" use="optionarY&gt;&lt;br/&gt;
&lt;xs:attribute name=" platform></attribule><br>'xs:attributeGroup&gt;<br>
41<br><br>
Attribute / element	Description<br>
name	The name of the sdm file is a friendly name that a developer can use<br>
to reference the contente of the file. The name in combination with<br>
the public key token provides a strong name for the file.<br>
version	Version is used to identify The version of the contents of the file. All<br>
elements of the file adopl the same version number<br>
publicKeyToken	Public key token is a short name for the public key associated with<br>
the file.<br>
culture	The culture of the binaries. Defaults to neutra!<br>
platform	The supported platform for the binaries.<br>
The base tdentity can be used to reference an existing identity or in conjunctton with a signature and a<br>
public key, to create a new strong identity. The document wil! be signed using the private key, aKowing<br>
the user of the document to verify its contents using the public key.<br><attributegroupname><br><attributegroup ref="ldentity*V&gt;&lt;br/&gt;
&lt;xs:artribute na me=" sig nature type="xs:string" use="optionar/&gt;&lt;br/&gt;
&lt;:xs;attribute name=" publickey publickeytokentype><br><annotation><br><documentation>Pub1ic Key Token; 16 hex digits in size</documentation><br></annotation><br><restriction base="xs:string"><br><pattemvalue></pattemvalue><br></restriction><br>&gt;cs:simpleType&gt;<br>
42<br><br>
3.1.2	Version<br>
A file version is defined by a four part number of the form N.N.N.N where O 
convention the numbers referto Major.Minor.Build.Revision.<br><simp name='^ourPartVersionType"'><br><restriction base="xs:string"><br>
.     <pattern value="([0-9]{1,4}|[0-5][0-9K4}|64[0-9]{3}|655[0-2i[0-9]|6553[0-5J)^.{[0-9K1,4}|[0-5][0-9]{4}|64[0-9]CT!555[0-.&lt;br/&gt;
2j[0-9]|6553[0-5])X3}}"></pattern><br></restriction><br><br>
3.1.3	Simpler.ames<br>
Simple names are made up of alpha-numeric characters and limited punctuation. The name should<br>
start with a non-numeric character.<br><simpletype name="simpleName"><br><annotation><br><documentalion>name of a type or member<br></documentalion></annotation></simpletype></simp></attributegroup></attributegroupname></xs><br><xs base="xs:string"><br><pattem value="H[a-zA-ZK1XP-9,a-z1A-Zjn"><br><br><br>
We plan to conform to the C# definition for ïdentifiers; the appropriate section (2.4.2) has been inserted<br>
below. The spec can be found at:<br>
hUp://devdiv/SDecTool/Docüments/WhidbevA/CShan3/Formal%20Lanquaqe%20Specification/CSharD<br>
%20LanguaQe%20SDecification.doc<br>
Note we will not support "@" prefixed names in the sdm model.<br>
The rules for identifiers given in this section correspond exactly to those recomrnended by the<br>
Unicode Standard Annex 15, except that underscore is allowed as an inttial character (as is<br>
traditional in the C programming language), Unicode escape sequences are permitted in<br>
identifiers, and the "@" character is allowed as a prefix to enable keywords to be used as<br>
identifiers.<br>
identifier:<br>
avaÜable-identifier<br>
&amp;  identifier-or-keyword<br>
ava ilable-identifier:<br>
An identifier-or-keyword that is not a keyword<br>
identifier-or-keyword:<br>
identifier-start-character   identifier-part-charactersop{<br>
identifier-start-character:<br>
letter-character<br>
_ (the underscore character U+005F)<br>
identifier-part-characters:	<br>
43<br><br>
identifier-part-character<br>
identifier-part-characters   identifier-part-character<br>
l"entifier-part-character:<br>
letter-character<br>
decimal-digit-chara eter<br>
connecting-character<br>
combining-character<br>
formatting-character<br>
' vt'fer-cfiaracfer. •<br>
A Unicode character of classes Lu, LI, Lt, Lm, Lo, or NI<br>
A unicode-escape-sequence representing a character of classes Lu, LI, Lt, Lm, LO or<br>
NI<br>
combining-character<br>
A Unicode character of classes Mn or Mc<br>
A unicode-escape-sequence representing a character of classes Mn or Mc<br>
decimal-digit-character;<br>
A Unicode character of the class Nd<br>
A unicode-escape-sequence representing a character of the class Nd<br>
connecting-character:<br>
A Unicode character of the class Pc<br>
A unicode-escape-sequence representing a character of the class Pc<br>
formatting-character:<br>
A Unicode character of the class Cf<br>
A unicode-escape-sequence representtng a character of the class Cf<br>
for information on the Unicode character dasses mentioned above, see The Unicode<br>
standard, Version 3.0, section 4.5.<br><br>
"rïte example:<br>
d^ss @dass<br>
publïc static voïd @static(boo1 @bool) {<br>
if (@bool)<br>
System.Console.WriteLine("tnje");<br>
else<br>
System.Console.WrileLinerïatee");<br>
44<br><br>
)<br>
class Classl<br>
{<br>
static void M() {<br>
Cl\u0061ss.st\u0061tic(true);<br>
&gt;<br>
}<br>
definesaclassnamed"c1ass" with a staticmethod named "static" thattakesa<br>
.. parameter named "boo")". Note that since Unicode escapes are not permitted in<br>
keywords, the token "cl \u0061ss" is an identifter, and is the same identifier as<br>
"@class".<br>
Two identifiers are considered the same if they are identical after the folfowing<br>
transfoimations are applied, in order:<br>
•	The prefix "@", if used, is removed.<br>
•	Each unicode-escape-sequence is transformed into its corresponding Unicode character.<br>
•	Myformatting-characters are removed.<br>
Identifiers containing two consecutive underscore characters (U+005F) are reserved for<br>
use by the impiementation. For example, an implementation might provide extended<br>
keywords that begin with two underscores.<br>
3.1.4  Reserved names<br>
The following is a list of reserved names that we will prevent users from using wrien creating names for<br>
objects in an SDM model.<br>
Within certain contexts certain names will be reserved<br>
Context	Name<br>
Abstract and concrete definitions	thïs<br>
Abstract and concrete hosting	guest, host<br>
Relationship definitions<br>
Abstract and concrete containmerrt       parent, member<br>
relationship definitions<br>
Abstract and concrete	cliënt, server<br>
communication relationship<br>
definitions<br>
Abstract and concrete reference	source, dependent<br>
relationship definitions<br>
45<br><br><br><br>
3.1.5	References to other namespaces<br>
	We allow namespaces to reference other namespaces by importing them into the current namespace<br>
	and then associating an alias with the namespace. The imported namespace is referenced by name,<br>
version and public key loken. Versioning wift be described in section 3.A6.<br><cornp1extype name="nimporf"><br><attribute nam6="alias" type="simpleName" use="required"></attribute><br><attributegroup ref-><br><br>
Attribute / element	Description<br>
alias	The alias used to reference the extemal sdm file within the scope of<br>
the current sdm file.<br>
3.1.6	Qualified Paths<br>
Qualifted paths are then either names that refer to definitions or managers defined in the current<br>
namespace or in an aliased namespace.<br>
[<alias> :] <simplename> (. <simplename>)*<br>
The alias is defined in an import statement. The foliowing simple names identify a type or in the case of<br>
a path, a nested type.<br><simpletypename><br><restrict base="xs:siring"><br><pattemvalue></pattemvalue>
Z.J)T"/&gt;<br><br><br>
3.1.7	Definition and Member Paths<br>
A path is a sequence of names that identifies a member or setting. A path should begin with a well-<br>
known name or member name that is defined by the object or relationship associated with the path.<br><simplename>(.<simp1ename>)*<br><simpletype name="path"><br><restriction base="xs:string"><br><pattemvalue></pattemvalue><br></restriction><br></simpletype><br>
3.1.8	Instance Paths<br>
Paths in the instaace space are based on xpaths where the element names in the xpath correspond to<br>
member names and attributes in the xpath correspond to settings.<br>
	47	<br><br>
3.1.9   Name Resolution<br>
Names that do nol begin with an afias are not fully qualifïed. This means that the scope in which they<br>
are evaluated can change the resutting binding. An example of thts is nested definitions. When<br>
resolving a nested definition name, definitions in local scope hide definitions in a broader scope.<br>
3.2 SETTINGS<br>
Alt definitions can exposé settings declarations. These settings are used to describe the values that can'<br>
be provided when a concrete definition is created from an abstract definition, or when a definition is<br>
references from a member within another definition.<br>
To define a setting you first need to define the definition of the setting using xsd.<br><schema><br><simpletype name="registryValueType"><br><restriction base="xs:strir&gt;g"><br><enumeratfon vaiue="b'nary7&gt;&lt;br/&gt;
&lt;xs:enumeraton value=" integer></enumeratfon><br><enumerafon value="long"></enumerafon><br><enumerafon value="expandString'/&gt;&lt;br/&gt;
&lt;xs:enumeration value=" multistringn></enumerafon><br><enumeration value="string"></enumeration><br></restriction><br><br></simpletype></schema><br>
You can then declare a setting that uses the definition and includes a set of attributes to define the<br>
behavior of the setting.<br><settingdeclaration name="valueType" type="registryValueType" access="readwrite" dynamic="false" required="true"></settingdeclaration><br>
Once you have a setting dedaration you can provide a value for the setting.<br><settingvalue name="valueType" fixed="frue">)ong<br>
3.2.1   Setting Definitions<br>
We use XSD schemas to define the setting definitions used by setting declarations. We support the use<br>
of simple and complex types from a schema though otner schema elements may exist to support the<br>
definition of those types.<br>
The settings definition section should contain a complete xml schema induding namespace declaration<br>
and namespace imports. We will check that the imports in the xsd schema match the imports in the<br>
sdm file with the exception of the xsd schema namespace. This means that all referenced types should<br>
be defined in another sdm file; the schema cannot reference types that are defined in arbitrary xsd files.<br><xs-.complextypename></xs-.complextypename><sequence><br><element ref="xs:schema"></element><br></sequence><br>
	48	<br><br><attribute name="manager lype=" qualifiedname use="optiona(7&gt;&lt;br/&gt;
&lt;xs:attribute name=sclrNamespace" type="xs:string'1 use^'optional"></attribute><br>
Attribute / element	Description<br>
xs:scbema	A schema in the http://www.w3.org/2001 /XMLSchmg namespace.<br>
manager	The dr assembly that contains helper classes for this schema<br>
clrNamespace	The dr namespace in which these dasses are defined. All setting<br>
type will rescbve to a ór baseö or&gt; Ihei? rr&amp;ppng Sbroupb CLR<br>
serialization.<br>
Settings should be resolvable from three separate namespaces:<br>
a)	The sdm namespace - when we refer to setting types within system, resource, endpoint,<br>
relationship, constraint or fiow types.<br>
b)	The dr namespace - when we refer to settings using strongly typed classes within the dr and<br>
when setting types are built on other setting types.<br>
c)	The XSD namespace - when setting types are built using other setting types.<br>
For this to work, we should place a number of restrictions on the way we dedare settings:<br>
a)	All settings should be in the same groupings within each of the dr, sdm and xsd<br>
namespaces. That is, if two settings are together in one namespace, they should be<br>
together in all three namespaces.<br>
b)	Imported namespaces within an xsd schema definttion should match the imported<br>
namespaces in an SDM file and the imported namespaces in the associated helper<br>
assembly.<br>
c)	Wfth the exception of the xsd namespace, al! imported namespaces in an xsd schema<br>
should be defined within an sdm file.<br>
XSD types from imported SDM documents are accessible using QNames:<br><alias>: <fype-name><br>
Hence, for example, if Foo.sdm imports Bar.sdm, the setting types of Bar.sdm may be referenced in<br>
the settingTypes element of Foo.sdm as this example illustrates:<br><br>
«import a!ïas="bar" !ocation="Bar.s<lm></lm><br><settingtypes><br>
49<br><br><xs name="D"><br><restriction base="bar;B" ...></restriction><br><br></xs></settingtypes><br></fype-name></alias></settingvalue></simp1ename></simplename></restrict></simpletypename></simplename></simplename></alias></attributegroup></cornp1extype></pattem></xs></attributegroup></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
		<br>
		<div class="pull-left">
			<a href="258820-a-method-of-welding-a-workpiece-and-welding-apparatus-thereof.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="258822-a-method-or-device-for-enhancing-the-security-of-a-voicemail-system.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>258821</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>216/MUM/2004</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>07/2014</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>14-Feb-2014</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>10-Feb-2014</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>23-Feb-2004</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>MICROSOFT CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>ONE MICROSOFT WAY, REDMOND, WASHINGTON 98052-6399</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>GALEN C HUNT</td>
											<td>2967 162ND AVENUE SE, BELLEVUE, WASHINGTON 98008</td>
										</tr>
										<tr>
											<td>2</td>
											<td>GEOFFREY OUTHRED</td>
											<td>4028 BAGLEY AVENUE N., SEATTLE, WASHINGTON 98103</td>
										</tr>
										<tr>
											<td>3</td>
											<td>BASSAM TABBARA</td>
											<td>4119 BAKER AVENUE NW, SEATTLE, WASHINGTON 98107</td>
										</tr>
										<tr>
											<td>4</td>
											<td>KEVIN GREALISH</td>
											<td>4035 DAYTON AVENUE N., SEATTLE, WASHINGTON 98103</td>
										</tr>
										<tr>
											<td>5</td>
											<td>ROB MENSCHING</td>
											<td>10507 164TH AVENUE NE, REDMOND, WASHINGTON 98052</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F15/177</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/452,736</td>
									<td>2003-03-06</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>10/693,838</td>
									<td>2003-10-24</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/258821-integrating-design-deployment-and-management-phases-for-systems by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 04:19:21 GMT -->
</html>
