<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/230076-scaling-and-quantizing-soft-decision-metrics-for-decoding by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:49:10 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 230076:SCALING AND QUANTIZING SOFT-DECISION METRICS FOR DECODING</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">SCALING AND QUANTIZING SOFT-DECISION METRICS FOR DECODING</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Soft metrics for multiple bursts transmitted at different times for a data packet are scaled, quantized, and rescaled prior to decoding. As each burst is received, input soft metrics for the burst are scaled with a scaling factor S(i), quantized based on a quantization scale factor Q(i), and stored in a buffer. The scaling factor and quantization scale factor are computed based on the statistics for the burst. After all bursts for the data packet have been received, the quantized soft metrics for each burst are rescaled based on the quantization scale factor Q(i) for that burst and a common scale factor to properly weight the soft metrics in the decoding process. The common scale factor is determined based on the quantization scale factors Q(i) for all&#x27; bursts. The rescaled soft metrics for all bursts are requantized, deinterleaved, and decoded to obtain decoded data for the packet.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>SCALING AND QUANTIZING SOFT-DECISION METRICS FOR DECODING<br>
BACKGROUND<br>
I. Related Applications<br>
[1001] This application claims priority to U.S. Provisional Application No. 60/491,332 filed July 29,2003.<br>
II.	Field<br>
[1002] The present invention relates generally to communication, and more specifically to techniques for scaling and quantizing soft-decision metrics for decoding in a wireless communication system.<br>
III.	Background<br>
[1003] In a wireless communication system, a transmitter encodes and interleaves traffic data, typically one data packet at a time, to obtain interleaved data. The transmitter may further partition each packet of interleaved data into multiple output blocks for transmission at different times. The transmitter then modulates and transmits these output blocks over a wireless channel at the designated times. If the transmission for these output blocks is not continuous, then the transmission appears as "bursts", one burst for each output block. The wireless channel distorts each transmitted burst with a particular channel response and further degrades each transmitted burst with noise and interference.<br>
[1004] A receiver receives the transmitted bursts and processes each received burst to obtain soft-decision metrics (or simply, "soft metrics") for the burst. A soft metric is a multi-bit value obtained by the receiver for a single-bit (or "hard") value sent by the transmitter. In one conventional method, the receiver scales the soft metrics for all received bursts for a given data packet with a single scaling factor to obtain scaled soft metrics for these bursts. The scaling factor is selected such that soft metrics with the proper amplitude are provided for subsequent processing. Typically, the scaling factor is derived based on a signal-to-noise-and-interference ratio (SNR) estimate for the<br><br>
bursts. The scaled soft metrics are then deinterleaved and decoded to obtain decoded data for the packet.<br>
[1005] Scaling all of the received bursts for a data packet with a single scaling factor effectively gives these bursts equal weight in the decoding process. This is acceptable if the wireless channel is relatively static and the bursts are received with similar signal quality. However, if the bursts are transmitted at different times, then these bursts may experience different channel conditions and achieve different SNRs. In this case, scaling all bursts for a data packet with a single scaling factor results in sub-optimal decoding performance.<br>
[1006] In another conventional method, the scaling is performed based on an average SNR obtained for multiple prior bursts. For an additive white Gaussian noise (AWGN) wireless channel with flat fading, the SNR may not change much from burst to burst, and good performance may be achieved by scaling the current burst based on the average SNR for the prior bursts. However, for a fading and interference wireless channel, the channel conditions are not static, the statistics of the soft metrics can change from burst to burst, and the SNR for the current burst may not correlate well with the average SNR for the prior bursts. Furthermore, the average SNR is not available for the first burst of a transmission or may be quite unreliable after a long period of no transmission, such as for a discontinuous transmission (DTX). Thus, decoding performance may be poor under uncertain conditions for this method. [1007] There is therefore a need in the art for techniques to more properly scale soft metrics for bursts transmitted at different times and possibly having different statistics and signal quality.<br>
SUMMARY<br>
[1008] Techniques for scaling, quantizing, and rescaling soft metrics for multiple bursts transmitted at different times are provided herein. These techniques may be used for various wireless communication systems and can provide good performance for various types of wireless channel (e.g., an AWGN channel, a fading and interference channel, and so on),<br>
[1009] For the scaling and quantizing, as each burst is received, input soft metrics for the burst are scaled with a scaling factor S(i) to obtain scaled soft metrics. The scaling factor S(i) is determined based on the statistics for the burst.   The scaled soft<br><br>
metrics for the burst are quantized based on a quantization scale factor Q{i) to obtain quantized soft metrics, which are stored in a buffer. The quantization scale factor 0(i) is computed based on the statistics for the burst and is also saved. The scaling adjusts the values of the input soft metrics for different bursts observing different channel conditions, and quantization is such that the scaled soft metrics can be stored in minimal memory. The same processing is performed for each of NB bursts transmitted for a data packet (e.g., for a message), where NB &gt; 1.<br>
[1010] For the rescaling, after all NB bursts for the same data packet (or message) have been received, the quantized soft metrics for each burst are rescaled based on the statistics for that burst as well as the statistics for all bursts to properly weight the soft metrics in the decoding process. In one rescaling scheme, a common scale factor is determined for all NB bursts based on the quantization scale factors Q(i) for these bursts. The quantized soft metrics for each burst are then rescaled based on the quantization scale factor 0(i) for that burst and the common scale factor. The rescaled soft metrics for all NB bursts are requantized, deinterleaved, and decoded to obtain decoded data for the packet.<br>
[1011] Various aspects and embodiments of the invention are described in further detail below.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
[1012]       The features and nature of the present invention will become more apparent<br>
from the detailed description set forth below when taken in conjunction with the<br>
drawings in which like reference characters identify correspondingly throughout and<br>
wherein:<br>
[1013]       FIG. 1 shows a base station and a terminal in a wireless system;<br>
[1014]       FIG. 2 shows a channel organization for the traffic channels in GSM;<br>
[1015]       FIG. 3 shows a transmit (TX) data processor at the base station and a receive<br>
(RX) data processor at the terminal;<br>
[1016]       FIG. 4 illustrates the processing and transmission of a data packet in GSM;<br>
[1017]       FIG. 5 shows a process for scaling, quantizing, and rescaling NB bursts of<br>
soft metrics for the data packet;<br>
[1018]       FIG. 6 shows a process for scaling and quantizing one burst of soft metrics;<br><br>
11019]       FIG. 7 shows a process for rescaling the quantized soft metrics for the NB<br>
bursts of the data packet; and<br>
[1020]       FIG. 8 shows a process for deriving a common scale factor for rescaling.<br>
DETAILED DESCRIPTION<br>
[1021] The word "exemplary" is used herein to mean "serving as an example, instance, or illustration." Any embodiment or design described herein as "exemplary" is not necessarily to be construed as preferred or advantageous over other embodiments or designs.<br>
[1022] The techniques described herein for scaling, quantizing, and rescaling soft metrics may be used for various wireless communication systems in which a data packet for a message is divided it into multiple blocks and each transmitted block may face different channel condition. For example, these techniques may be used for a Time Division Multiple Access (TDMA) system, a Code Division Multiple Access (CDMA) system, a Frequency Division Multiple Access (FDMA) system, an orthogonal frequency division multiplexing (OFDM) based system, and so on. A TDMA system may implement one or more TDMA standards such as Global System for Mobile Communications (GSM). A CDMA system may implement one or more CDMA standards such as Wideband CDMA (W-CDMA), IS-2000, IS-856, IS-95, and so on. These standards are well known in the art.<br>
[1023] The scaling, quantizing, and rescaling techniques may be used for data transmission on the downlink and uplink. The downlink (i.e., forward link) is the communication link from a base station to a terminal, and the uplink (i.e., reverse link) is the communication link from the terminal to the base station. These techniques may be used for user-specific transmission sent on a traffic channel as well as overhead transmission sent on a control channel. For clarity, these techniques are specifically described below for user-specific transmission on the downlink in a GSM system. [1024] FIG. 1 shows a block diagram of a base station 110 and a terminal 150 in a wireless communication system 100. On the downlink, at base station 110, a TX data processor 120 receives traffic data for terminal 150 as well as other terminals. TX data - processor 120 formats, codes, and interleaves the data for each terminal based on the coding and interleaving schemes selected for the terminal and provides interleaved data for the terminal.  A modulator (MOD) 122 then modulates the interleaved data for all<br><br>
terminals and provides modulated data. A transmitter unit (TMTR) 124 processes the modulated data to generate a downlink signal, which is then transmitted via an antenna 126 and over a wireless channel to the terminals.<br>
[1025] At terminal 150, an antenna 152 receives the downlink signal transmitted by base station 110 and provides a received signal to a receiver unit (RCVR) 154. Receiver unit 154 conditions and digitizes the received signal and provides a stream of data samples. A demodulator (DEMOD) 156 processes the data samples and provides demodulated data. An RX data processor 160 next deinterleaves and decodes the demodulated data to recover the traffic data transmitted by base station 110 for terminal 150. The processing by demodulator 156 and RX data processor 160 is complementary to the processing by modulator 122 and TX data processor 120, .respectively, at base station 110.<br>
[1026] Controllers 130 and 170 direct the operation at base station 110 and terminal 150, respectively. Memory units 132 and 172 store program codes and data used by controllers 130 and 170, respectively. Buffer 174 stores data for RX data processor 160. For simplicity, FIG. 1 only shows the processing units for downlink transmission and does not show all of the processing units normally present at base station 110 and terminal 150.<br>
[1027] GSM uses different types of channels to send different types of data. In particular, user-specific data is sent on traffic channels (TCH), broadcast data is sent on a broadcast control channel (BCCH), and control data and other data (e.g., paging messages) are sent on a common control channel (CCCH).<br>
[1028] FIG. 2 shows an exemplary channel organization for the traffic channels in GSM. The timeline for downlink transmission is divided into multiframes. For the traffic channels, each multiframe includes 26 TDMA frames, which are labeled as TDMA frames 0 through 25. The traffic channels are sent in TDMA frames 0 through 11 and TDMA frames 13 through 24 of each multiframe. A control channel (SACCH/T) is sent in TDMA frame 12 and is used to carry inband signaling such as (1) measurement reports sent by terminals on the uplink and (2) timing advances for the terminals sent by the base station on the downlink. No data is sent in the idle frame, which is used by the terminals to make measurements for neighbor base stations. [1029] Each TDMA frame is further partitioned into 8 time slots, which are labeled as time slots 0 through 7. Each active terminal/user is assigned one time slot index for<br><br>
the duration of a call. User-specific data for each terminal is sent in the time slot assigned to that terminal and in TDMA frames used for the traffic channels (those labeled with "T" in FIG. 2). The transmission in each time slot is referred to as a "burst" in GSM. The channel organization for the traffic channels in GSM is described in detail in a document 3GPP TS 05.01, which is publicly available. [1030] FIG. 3 shows a block diagram of a TX data processor 120a at base station 110 and an RX data processor 160a at terminal 150. TX data processor 120a is an embodiment of TX data processor 120 in FIG. 1 and performs the transmitter processing for a traffic channel for a terminal (e.g., terminal 150). RX data processor 160a is an embodiment of RX data processor 160 in FIG. 1 and performs the receiver processing for the traffic channel. In GSM, data to be sent on a traffic channel is coded in groups of four data blocks, with each data block containing a specified number of information bits. Each group of four data blocks may be viewed as one data packet that contains all of the information bits for the four data blocks.<br>
[1031] Within TX data processor 120a, a block encoder 310 performs block encoding on a packet of information bits for terminal 150 and generates parity bits for the packet. The parity bits are used for error detection by terminal 150. A convolutional encoder 312 performs convolutional encoding on the output from block encoder 310 and provides a packet of code bits. The coding scheme is determined by base station 110 based on the state (e.g., idle or traffic mode) of terminal 150 as well as the type of call (e.g., circuit switched call or packet switched call). For a packet switched call, the coding scheme may also be determined by measurements sent by terminal 150. An interleaver 314 reorders the code bits in the packet based on an interleaving scheme and provides a packet of interleaved bits. A partitioning unit 316 partitions the interleaved data packet into NB output blocks, where NB may be 4, 8, or 22 depending on the channel type (e.g., voice, circuit switched, paging, or control channel). The partitioning and interleaving may be performed in various manners. For example, the coded data may be interleaved first and then partitioned into output blocks, as shown in FIG. 3. Alternatively, the coded data packet may be partitioned first into blocks and then interleaved. The partitioning and interleaving may also be performed in one operation.<br>
[1032] Modulator 122 modulates each output block based on a modulation scheme (e.g., GMSK or 8-PSK) selected for terminal 150 to obtain NB symbol blocks.  These<br><br>
symbol blocks are subsequently transmitted in an assigned time slot of NB TDMA frames used for the traffic channel. For simplicity, the processing by other units between modulator 122 and demodulator 156 is not shown in FIG. 3. [1033] FIG, 4 illustrates the processing and transmission of a data packet in GSM. Block encoder 310 processes a packet 408 of information bits and provides a block 410 containing information bits, parity bits, and tail bits. Convolutional encoder 312 then processes block 410 in accordance with a (e.g., rate 1/2, 1/3, 1/4, or 1/5) convolutional code and provides a block 412 of coded data. Interleaver 314 interleaves the code bits in blocks 412 and provides a block 414 of interleaved bits. Partitioning unit 316 then partitions block 414 into NB output blocks 416a through 416n.<br>
[1034] As shown in FIG. 4, first output block 416a is transmitted in time slot x of TDMA frame n and is denoted as burst 0, second output block 416b is transmitted in time slot x of TDMA frame n + 1 and is denoted as burst 1, and so on, and the last output block 416n is transmitted in time slot x of TDMA frame w + NB -1 and is<br>
denoted as burst NB -1. Here, x is the time slot assigned to terminal 150 and n is the<br>
TDMA frame index. As shown in FIGS. 3 and 4, a data packet is encoded, interleaved, and transmitted in NB bursts. These bursts may experience different channel conditions and achieve different SNRs.<br>
[1035] Referring back to FIG. 3, at terminal 150, demodulator 156 obtains data samples from receiver unit 154. Each data sample is a complex value with an inphase (I) component and a quadrature (Q) component. Each component is digitized to L bits (e.g., L = 16). Demodulator 156 processes the data samples in accordance with an equalizer design and provides "input" soft metrics zin(i,k), where / denotes the z-th<br>
burst and k denotes the £-th soft metric for the burst. Demodulator 156 may perform equalization based on a maximum likelihood sequence estimator (MLSE) followed by soft-decision generation (or simply, a "soft-output MLSE"), as described by Ono, S. et al. in "An MLSE Receiver for the GSM Digital Cellular System," Proc. of the 44th IEEE Vehicular Technology Conference, June 8-10, 1994, pp. 230-233. Demodulator 156 may also perform equalization based on a minimum mean square error (MMSE) equalizer or some other type of equalizer. The equalization attempts to mitigate intersymbol interference (ISI), which is a phenomenon whereby each symbol in a received signal acts as distortion to subsequent symbols in the received signal. ISI is caused by frequency selective fading, which is characterized by a frequency response<br><br>
that is not flat across the system bandwidth. Demodulator 156 may alternatively or additionally perform matched filtering.<br>
[1036] A soft metric is a multi-bit value that is indicative of a single-bit (or "hard") value sent by a transmitter. For example, a soft metric may be derived by a receiver for each code bit transmitted by the transmitter. A soft metric is commonly expressed as a log likelihood ratio (LLR), which is the logarithm of the ratio of the probability of a transmitted bit being a "1" over the probability of the transmitted bit being a "0", where the probabilities are conditioned on the data samples obtained at the receiver (i.e., the "observed" data samples). A soft metric may also be expressed in other forms, and this is within the scope of the invention. For example, the soft metric may simply be equal to a received symbol obtained by the receiver for a transmitted symbol sent by the transmitter.<br>
[1037] RX data processor 160a obtains the input soft metrics from demodulator 156. Within processor 160a, a sealer/quantizer 360 scales and quantizes the input soft metrics ziIt(i,k)  for each burst and provides quantized soft metrics zgn(i,k)  to buffer 174.<br>
After all NB bursts for the data packet have been received, a rescaler 370 rescales the quantized soft metrics zqn(i,k)  for all NB bursts and provides rescaled soft metrics<br>
zrs(*&gt;*) &gt; which are requantized (not shown in FIG. 3 for simplicity).<br>
[1038]       A deinterleaver 378 receives and deinterleaves the requantized soft metrics<br>
z (i9k) for all NB bursts and provides deinterleaved soft metrics to a Viterbi decoder<br>
380. Viterbi decoder 380 performs convolutional decoding on the deinterleaved soft metrics and provides decoded bits. A block decoder 382 performs error detection on the decoded bits and provides a recovered data packet. Block decoder 382 also provides the status of the recovered data packet, which is "good" if the packet is decoded correctly and "bad" or "erased" if the packet is decoded in error.<br>
[1039] The scaling/rescaling and deinterleaving may be performed in various manners. For clarity, FIG, 3 shows the deinterleaving being performed on the rescaled soft metrics after all NB bursts have been received. In a more efficient implementation, the deinterleaving is performed prior to the rescaling. For this implementation, the quantized soft metrics z  {i9k) for each burst can be stored in deinterleaved order in<br>
buffer 174. Alternatively, the quantized soft metrics zqn{Uk) can be retrieved from buffer 174 in deinterleaved order and provided to rescaler 370.    In any case, the<br><br>
deinterleaving can be performed by storing or retrieving the quantized soft metrics to/from the proper locations in buffer 174. Buffer 174 can thus (1) store NB bursts of quantized soft metrics for subsequent processing and (2) facilitate deinterleaving. [10401 For GSM, the soft metrics for the Viterbi decoder are spread across NB bursts that are transmitted at different times and may achieve different SNRs. Furthermore, the soft metrics are obtained after equalization at the receiver, and the statistics of the soft metrics for each burst may not directly correspond to the SNR for the burst. Ideally, the scaling should be performed on the soft metrics for the bursts after all NB bursts have been received. However, the soft metrics provided by demodulator 156 may have many bits of resolution (e.g., 16 bits), and buffer 174 may not have sufficient capacity to store these soft metrics in its original form. In this case, the soft metrics for each burst need to be scaled and quantized to a specified number of (M) bits as the burst is received. The scaling and quantizing should be done in a manner such that system performance is minimally degraded.<br>
[1041] To achieve good performance, the soft metrics for each burst are scaled and quantized based on the .statistics obtained for the burst, as described below. This allows the soft metrics for each burst to be stored using the full resolution of the M bits. After all NB bursts have been received, the soft metrics for each burst are rescaled based on the statistics for that burst and the statistics for all NB bursts, as described below. This allows the soft metrics for each burst to be given appropriate weight in the decoding process.<br>
[1042]       FIG. 5 shows a process 500 for scaling, quantizing, and rescaling NB bursts of soft metrics for a data packet. Block 510 is performed for each burst as the burst is received. Block 520 is performed after all NB bursts have been received. [1043]       As a burst i is received, the input soft metrics zin(i,k)  for the burst are<br>
scaled with a scaling factor S(i) to obtain scaled soft metrics zsc(i,k) (block 512). The<br>
scaling factor S(i) is determined based on the statistics for the burst. The scaled soft metrics zsc(i,k) for burst i are quantized based on a quantization scale factor Q(i) to<br>
obtain quantized soft metrics zqn(i9k), which are stored to buffer 174 (block 514). The<br>
quantization scale factor Q(i) is also computed based on the statistics for the burst. Blocks 512 and 514 may be performed as described below.<br>
[1044] A determination is then made whether or not all NB bursts for the data packet have been received (block 516).  If the answer is no, then the process returns to block<br><br>
512 to process the next burst. Otherwise, a common scale factor QCOm is determined for all NB bursts based on the statistics for these bursts (block 522). The quantized soft metrics zgn(i,k) for each burst are then rescaled based on the quantization scale factor<br>
Q(i) for the burst and the common scale factor Qcom for all bursts (block 524). The rescaled soft metrics zn{i9k) for all NB bursts are then requantized, deinterleaved, and<br>
decoded to obtain decoded data for the packet (block 526). Each of the blocks in FIG. 5 is described in further detail below.<br>
[1045] FIG. 6 shows a process 510a for scaling and quantizing one burst of soft metrics. Process 510a maybe used for block 510 in FIG. 5. Initially, pertinent statistics for the burst are obtained (block 612). The soft metrics can take on both positive and negative values when expressed as LLRs. The statistics may include the mean and variance of the absolute value of the input soft metrics for the burst, which can be expressed as:<br><br>
where N,- is the number of soft metrics for burst i;<br>
//,„(/) is the mean of the absolute value of the input soft metrics for burst i; and<br>
a? (i) is the variance of the absolute value of the input soft metrics for burst L<br>
[10461 The scaling factor S(i) for the burst is then determined based on its statistics (block 614), as follows:<br><br>
The scaling factor S(i) in equation (3) is based on an assumption that the statistics of the<br>
noise in the input soft metrics is approximately Gaussian.<br>
[1047]       Each input soft metric zitt(i,k) for the burst is scaled by the scaling factor<br>
S(i) to obtain a corresponding scaled soft metric zsc(i,k) (block 616), as follows:<br><br><br><br>
For simplicity, the rounding to obtain an integer value for zqn(i,k) is not shown in<br>
equation (8). Equation (8) also shows the quantized soft metrics being obtained with a division by Q(i).   Division is more computationally intensive than multiplication in hardware and software. Thus, the inverse of Q(i) can be computed instead of (2(0- The quantized soft metrics can then be obtained by multiplication with the inverse of Q(i). [1051]       The quantized soft metrics z  (i9k) as well as the quantization scale factor<br>
Q(i) for the burst are stored in buffer 174 (block 628).<br>
[1052] FIG. 6 shows a specific scheme for scaling and quantizing the input soft metrics for a burst. The scaling factor S(i) and the quantization scale factor Q(i) may be derived in other manners, and this is within the scope of the invention. For example, scaling factor S(i) may be a function of the mean (but not the variance). The scaling and quantizing may also be performed in other manners, and this is within the scope of the invention.<br>
[1053] The manner in which the scaling and quantizing can be performed efficiently may be influenced by the design of demodulator 156. As an example, for the soft-output MLSE (i.e., the MLSE with soft-decision generation), the mean-to-variance ratio<br>
is equal to the inverse of the noise power for the burst, i.e., Min(i)fo?l(i) = lfo'*(i)9<br>
where 
convolving the output of the MLSE with a channel impulse response estimate for the wireless channel to obtain estimated soft metrics z&amp;t{i9k), (2) subtracting the input soft<br>
metrics from the estimated soft metrics to obtain the noise, i.e., n(i9k) = zest(i,k) -2in(hk)9 and (3) computing the power of the noise n(i9k) to obtain<br>
of (z). If the burst noise power is already computed by demodulator 156 for other uses and is available, then the scaling factor S(i) can be computed based on the burst noise power as £(z) = l/o£(i), instead of based on the mean juin(i) and variance crfn(i) of the<br>
input soft metrics. If the mean ///B(/) and variance of„(i) are not computed (e.g., because the scaling factor S(i) is computed based on the burst noise power), then the mean //„(/) and variance <r2sc can be computed for the scaled soft metrics as shown></r2sc>
in equations (5) and (6). The mean /ix(i) and variance cr]c(j) are then used to determine the quantization scale factor Q(i) for the burst, as shown in equation (7).<br><br>
[1054] For clarity, the scaling and quantizing of the soft metrics are shown as separate blocks in FIG. 6. The scaling and quantizing may also be performed in one step.   In this case, the quantization scale factor for each burst may be computed as<br>
Q'(0 = ~^ = Y' Mini}) • Tte quantization may be performed directly on the input soft S(i)<br>
metrics zitt(i,k) with Q\i) to obtain the M-bit quantized soft metrics zgn(i,k), as shown in equation (8) with zin(i,k) substituting for z5c(i,k) and Q\i) substituting for<br>
O(0-  The quantization scale factor may also be computed as 2/(0==//m(0 + a*°&amp;(0<br>
or in some other manner, and this is within the scope of the invention. [1055] After all of the NB bursts have been received, the quantized soft metrics for these bursts are rescaled to obtain rescaled soft metrics for subsequent processing. The soft metrics for each burst are initially scaled and quantized (1) based only on the statistics for that burst and without regard to the statistics for the other bursts and (2) in a manner to occupy the full range of the M bits. The rescaling is performed to properly weight the soft metrics for the NB bursts in the decoding process. [1056] In an embodiment, the rescaling is performed based on a common scale factor Qcom, which is one of the factors that determine the weight that will be given to the soft metrics for each burst. The common scale factor Qcom is obtained based on (as a function of) the statistics for all NB bursts and may be derived in various manners. In general, more weight should be given to soft metrics for bursts with high signal quality and less or no weight should be given to soft metrics for bursts with low signal quality. [1057] For clarity, an exemplary scheme for deriving the common scale factor Qcom is described below. For this scheme, bursts with low signal quality below a predetermined threshold (e.g., SNR 
 <br>
(1058] FIG. 7 shows a process 520a for rescaling the quantized soft metrics for the NB bursts of one packet. Process 520a may be used for block 520 in FIG. 5. [1059] Initially, the good bursts among the NB bursts are identified and counted (block 712). A burst may be deemed as good if its quantization scale factor Q(i) is equal to or greater than a predetermined threshold Qgood,th, i.e., burst i is deemed as good if (2(f) &gt; Qgood th. The number of good bursts is denoted as No- The maximum, average,<br>
and minimum of the quantization scale factors Q(i) for the NG good bursts are determined and denoted as Qmax, Qavg, and Omin, respectively (block 714). The common scale factor Qcom is then derived based on the parameters NB, NG, Qmax, Qavg, and Qmin (block 716).<br>
[1060] FIG. 8 shows a process, 716a for deriving the common scale factor Qcom for rescaling. Process 716a may be used for block 716 in FIG. 7. A determination is first made whether or not the number of good bursts is less than a threshold number of good bursts (Nth) (block 812). The threshold number Nth may be set equal to half the number of bursts (e.g., N^ =NB/2) or to some other value.  If the answer is cyes' for block<br>
812, then the common scale factor is set equal to the maximum quantization scale factor (i.e., Qcom = Qmax) (block 816). If the number of good bursts is small, where "small" for<br>
this parameter is quantified by Nth&gt; then these good bursts are given greater weight in the decoding process by setting Qcom = Omax.<br>
[1061] If at least Nth good bursts were received (i.e., the answer is "no" for block 812), then a determination is made whether or not the ratio of the maximum quantization scale factor to the minimum quantization scale factor (QmaxIQmin) for the<br>
good bursts is less than a threshold value Qvar,th (block 822).   The ratio QmaxIQmin is<br>
indicative of the variability in the quality or SNRs of the good bursts. If the variability is sufficiently small, where "small" for this parameter is quantified by Qvar^ then the common scale factor is set equal to the average quantization scale factor for all of the good bursts (i.e., Qcom =Qavg) (block 826).   This would give good bursts with lower<br>
signal quality equal weight in the decoding process. The Qvar,th threshold may be set to six (e.g., Qvarth = 6) or some other value.<br>
[1062] If the variability in quality is not sufficiently small (i.e., the answer is "no" for block 822), then a determination is made whether or not the average quantization scale factor is greater than a threshold value Qavgjh (block 824).    The average<br><br>
quantization scale factor is indicative of the average quality of the good bursts. If the average quality is sufficiently high, where "high" for this parameter is quantified by Qavg.th, then the common scale factor is set equal to the average quantization scale factor for the NG good bursts (i.e., Qcom =Qavg) (block 826).   Otherwise, the common scale<br>
factor is set equal to the maximum quantization scale factor (i.e., Qcom ~Qmax) (block<br>
816). The QQvg,th threshold may be set to three (e.g., QaygJh = 3 ) or some other value.<br>
[10631 FIG. 8 shows a specific embodiment for deriving the common scale factor Qcom for rescaling. OCOm may also be derived in other manners and based on other functions of the statistics of the NB bursts, and this is within the scope of the invention. In general, the derivation of Qcom may (1) take into account the parameters described above (NB, NG, Qmax. Qavg, Qmin, Qvar,th and QQvgtth) and/or other parameters, (2) consider the criteria described above (e.g., relative number of good bursts, variability in the quality of the good bursts, and absolute value of the average quality) and/or other criteria, and (3) use other functions of the parameters and criteria. [1064] Referring back to FIG. 7, a rescaling factor R(i) is computed for each burst based on the quantization scale factor O(0 for that burst and the common scale factor Qcom (block 722), as follows:<br><br>
The rescaling factor R(i) for a bad burst is set to zero to give that burst no weight in the decoding process.  In equation (9), a burst is considered "bad" if its quantization scale factor 0(i) is less than the Q%0odtth threshold value. [1065]       Each quantized soft metric zqn{i,k) for each burst is retrieved from buffer<br>
174 and rescaled by the rescaling factor R(i) for that burst to obtain a corresponding rescaled soft metric zn(i9k) (block 724), as follows:<br>
zrs(iyk)^R{i)'Z^(i9k) ,  far* = l...tff .	Eq(10)<br>
[1066]       Each rescaled soft metric zn(i,k) is then requantized to the required number of bits (block 726).   Typically, the rescaled soft metrics are requantized to the same<br><br>
number of bits with which the soft metrics were stored in buffer 174, which is M bits. In this case, the requantization can be achieved by saturating the rescaled soft metrics to M bits.  If Q    -O    , then all of the rescaled soft metrics will be M bits or less and<br>
saturating is not needed.  If Qcom = Qavg, then the rescaled soft metrics for bursts with<br>
2(0 &gt; Qav maY need t0 be saturated to obtain M-bit rescaled soft metrics.<br>
[1067]       The requantized soft metrics zrq(i7k) for all NB bursts are deinterleaved and<br>
decoded to obtain the decoded data for the packet (block 728). Since the rescaling factors for bad bursts are set to zero for the embodiment described above, only the requantized soft metrics for the NG good bursts are used for the decoding process. [10681 The techniques described herein may advantageously be used for incremental redundancy (IR) transmission whereby portions of a data packet are retransmitted due to errors at the receiver. As an example, each of the Ng bursts may include an error detection value (e.g., a CRC value, a checksum, and so on) that allows the receiver to determine whether or not the burst was correctly received by the receiver. The receiver can signal to the transmitter which bursts have been incorrectly received, and the transmitter can retransmit these bursts. The receiver can process the transmitted and retransmitted bursts in various manners to decode the packet. [1069] In one scheme, the receiver substitutes the error bursts with the retransmitted bursts and discards the error bursts. Each retransmitted burst can be scaled and quantized based on its statistics, in the same manner as for a transmitted burst. All of the NB bursts (where zero, one, or multiple bursts can be retransmitted bursts) are then rescaled based on their statistics, requantized, deinterleaved, and decoded, as described above.<br>
[1070] In another scheme, the receiver combines the transmitted version and retransmitted versions (if any) for each of the NB bursts to obtain a composite burst. The combining of all versions of a given burst i can be expressed as:<br><br>
where Nver,i is the number of versions available for burst i;<br>
zinJ(j,k) is the input soft metrics for thej-th version/transmission of burst i;<br>
Sj(i) is the scaling factor for thej-th version of burst i; and<br><br>
z'sc{i,k) is the scaled soft metrics for composite burst i.<br>
The scaling factor S (z) for each version of burst i is determined based on the statistics for that version, as follows:<br><br>
where  /iin .(/) is the mean of the absolute value of the input soft metrics for the 7-th<br>
version of burst /; and a)n (/) is the variance of the absolute value of the input soft metrics for thej-th<br>
version of burst L<br>
All of the NB bursts (where zero, one, or multiple bursts can be composite bursts) are then rescaled based on their statistics, requantized, deinterleaved, and decoded, as described above.<br>
[1071] In yet another scheme, the receiver combines a current retransmitted version and a prior combined version (if any) for each of the NB bursts to obtain a new combined version for the burst. For the first transmission, the receiver performs scaling, quantization, and rescaling for the NB bursts in accordance with a common scale factor, Qcom.u derived for the first transmission, as described above. The rescaled soft metrics zin j (z, /c) for the first transmission are then decoded. If there is a decoding failure, then<br>
the rescaled soft metrics zinl(J.,k) and the common scale factor QCOm,\ are stored.  For<br>
the first retransmission, the receiver performs scaling, quantization, and rescaling for the bursts in the retransmission in accordance with a common scale factor, Qcom^ derived for the retransmission, in the same manner as for the first transmission. The receiver then scales the rescaled soft metrics zinl(i,k) for the first transmission and the rescaled<br>
soft metrics z^2 (*',&amp;) f°r ^e ^rs* retransmission based on a function of the common<br>
scale factors QCom,\ and QCOmt2- As an example, the rescaled soft metrics z-m;i(i9fc) may<br>
be scaled by Qcomll(QcomX +£?com&gt;2) to obtain z^,(z,£), and the rescaled soft metrics<br>
zin,20'&gt;*) may be scaled by QcomaKQcomtl +Qcom,2) to obtain z^z,*). Other functions<br>
of Qcom,\ and QComa maY dso ^e used-   The receiver then combines z'^fak) and<br><br>
z'ia2{i9k) to obtain combined rescaled soft metrics z*M(Uk) , which are then decoded. If there is a decoding failure, then the combined rescaled soft metrics z"n2(i,k) and a combined common scale factor,   are stored.    For the next<br>
retransmission, the receiver processes the bursts in the new retransmission and combines these bursts with the stored bursts in similar manner as for the first retransmission.<br>
[1072] The scaling, quantizing, and rescaling techniques described herein provide good performance for a transmission sent as bursts that observe different channel conditions and achieve different signal quality. The scaling and quantizing of each burst (as it is received) based on its statistics allow the soft metrics to be stored (1) with a limited number of (M) bits, thereby reducing storage requirement, and (2) with the full resolution available for these M bits. The rescaling of the quantized soft metrics for all bursts based on their statistics allows these soft metrics to be given appropriate weight in the decoding process, thereby improving performance.<br>
[1073] The techniques described herein can provide better performance than the conventional method that scales all bursts with a single scaling factor and the conventional method that scales each burst based on the average SNR of multiple prior bursts. These techniques can also provide improved performance for messages received following a discontinuous transmission (DTX), such as paging messages that are commonly sent in cellular systems.<br>
[1074] The scaling, quantizing, and rescaling techniques described herein may be implemented by various means. For example, these techniques may be implemented in hardware, software, or a combination thereof. For a hardware implementation, the processing units used to perform scaling, quantizing, and rescaling may be implemented within one or more application specific integrated circuits (ASICs), digital signal processors (DSPs), digital signal processing devices (DSPDs), programmable logic devices (PLDs), field programmable gate arrays (FPGAs), processors, controllers, micro-controllers, microprocessors, other electronic units designed to perform the functions described herein, or a combination thereof.<br>
[1075] For a software implementation, the scaling, quantizing, and rescaling techniques may be implemented with modules (e.g., procedures, functions, and so on) that perform the functions described herein. The software codes may be stored in a memory unit (e.g., memory unit 172 in FIG. 1) and executed by a processor (e.g.,<br>
controller 170). The memory unit may be implemented within the processor or external to the processor, in which case it can be communicatively coupled to the processor via various means as is known in the art.<br>
[1076] The previous description of the disclosed embodiments is provided to enable any person skilled in the art to make or use the present invention. Various modifications to these embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments without departing from the spirit or scope of the invention. Thus, the present invention is not intended to be limited to the embodiments shown herein but is to be accorded the widest scope consistent with the principles and novel features disclosed herein.<br>
[10771       WHAT IS CLAIMED IS:<br><br>
CLAIMS<br>
1. A method of processing a data transmission sent as a plurality of bursts<br>
in a wireless communication system, comprising:<br>
scaling input soft metrics for each of the plurality of bursts based on statistics for the burst to obtain scaled soft metrics for the burst; and<br>
rescaling the scaled soft metrics for each of the plurality of bursts based on the statistics for the burst and the statistics for the plurality of bursts to obtain rescaled soft metrics for decoding.<br>
2. The method of claim 1, wherein the input soft metrics are log likelihood ratios (LLRs).<br>
3. The method of claim 1, wherein the input soft metrics are multi-bit values obtained for transmitted code bits.<br>
4. The method of claim 1, wherein the statistics for each of the plurality of bursts include a mean for the input soft metrics for the burst.<br>
5. The method of claim 4, wherein the statistics for each of the plurality of bursts further include a variance for the input soft metrics for the burst.<br>
6. The method of claim 1, further comprising:<br>
determining a scaling factor for each of the plurality of bursts based on a mean of the input soft metrics for the burst, and wherein the input soft metrics for each burst are scaled based on the scaling factor for the burst.<br>
7. The method of claim 6, wherein the scaling factor for each of the<br>
plurality of bursts is further determined based on a variance of the input soft metrics for<br>
the burst.<br><br>
8. The method of claim 1, further comprising:<br>
quantizing the scaled soft metrics for each of the plurality of bursts based on the statistics for the burst to obtain quantized soft metrics for the burst, and wherein the rescaling is performed on the quantized soft metrics.<br>
9. The method of claim 8, wherein the scaling and quantizing are performed with one arithmetic operation on the input soft metrics using one scale factor.<br>
10. The method of claim 1, wherein the rescaling includes<br>
determining a common scale factor based on the statistics for the plurality of bursts,<br>
determining a scale factor for each of the plurality of bursts based on the statistics for the burst, and<br>
rescaling the scaled soft metrics for each of the plurality of bursts based on the scaling factor for the burst and the common scale factor.<br>
11. The method of claim 8, wherein the rescaling includes<br>
determining a common scale factor based on the statistics for the plurality of bursts,<br>
determining a quantization scale factor for each of the plurality of bursts based on the statistics for the burst, and<br>
rescaling the quantized soft metrics for each of the plurality of bursts based on the quantization scale factor for the burst and the common scale factor.<br>
12. The method of claim 1, further comprising:<br>
storing rescaled soft metrics for a first transmission of the plurality of bursts;<br>
deriving rescaled soft metrics for a second transmission of the plurality of bursts; and<br>
scaling and combining the rescaled soft metrics for the first transmission and the rescaled soft metrics for the second transmission to obtain combined rescaled soft metrics for decoding.<br>
13. The method of claim 1, wherein the wireless communication system is a Global System for Mobile Communications (GSM) system.<br>
14. The method of claim 1, wherein the plurality of bursts are transmitted in non-continuous time intervals.<br>
15. An apparatus in a wireless communication system, comprising:<br>
a scaling unit operative to scale input soft metrics for each of a plurality of bursts based on statistics for the burst to obtain scaled soft metrics for the burst, wherein the plurality of bursts are for a data transmission received via a wireless channel; and<br>
a rescaling unit operative to rescale the scaled soft metrics for the plurality of bursts based on the statistics for the burst and the statistics for the plurality of bursts to obtain rescaled soft metrics for decoding.<br>
16. The apparatus of claim 15, further comprising:<br>
a quantizing unit operative to quantize the scaled soft metrics for each of the plurality of bursts based on the statistics for the burst to obtain quantized soft metrics for the burst, and wherein the rescaling unit is further operative to rescale the quantized soft metrics.<br>
17. An apparatus in a wireless communication system, comprising:<br>
means for scaling input soft metrics for each of a plurality of bursts based on statistics for the burst to obtain scaled soft metrics for the burst, wherein the plurality of bursts are for a data transmission received via a wireless channel; and<br>
means for rescaling the scaled soft metrics for the plurality of bursts based on the statistics for the burst and the statistics for the plurality of bursts to obtain rescaled soft metrics for decoding.<br>
18. The apparatus of claim 17, further comprising:<br>
means for quantizing the scaled soft metrics for each of the plurality of bursts based on the statistics for the burst to obtain quantized soft metrics for the burst, and wherein the rescaling is performed on the quantized soft metrics.<br>
19. A processor readable medium for storing instructions operable in a<br>
wireless device to:<br>
scale input soft metrics for each of a plurality of bursts based on statistics for the burst to obtain scaled soft metrics for the burst, wherein the plurality of bursts are for a data transmission received via a wireless channel; and<br>
rescale the scaled soft metrics for the plurality of bursts based on the statistics for the burst and the statistics for the plurality of bursts to obtain rescaled soft metrics for decoding.<br>
20. A method of processing a data transmission sent as a plurality of bursts<br>
in a wireless communication system, comprising:<br>
determining a scaling factor for each of the plurality of bursts based on statistics for the burst;<br>
scaling input soft metrics for each of the plurality of bursts with the scaling factor for the burst to obtain scaled soft metrics for the burst;<br>
quantizing the scaled soft metrics for each of the plurality of bursts based on a quantization scale factor for the burst to obtain quantized soft metrics for the burst;<br>
determining a common scale factor based on quantization scale factors for the plurality of bursts; and<br>
rescaling the quantized soft metrics for each of the plurality of bursts based on the quantization scale factor for the burst and the common scale factor to obtain rescaled soft metrics for decoding.<br>
21. The method of claim 20, wherein the scaled soft metrics for each of the plurality of bursts aTe quantized to M bits, where M is an integer greater than one.<br>
22. The method of claim 21, wherein the quantization scale factor for each of the plurality of bursts is selected to quantize the scaled soft metrics for the burst to full range of the M bits.<br>
23. The method of claim 20, wherein the scaling factor and quantization scale factor for each of the plurality of bursts are determined based on a mean of the input soft metrics for the burst.<br><br>
24. The method of claim 23, wherein the scaling factor and quantization<br>
scale factor for each of the plurality of bursts are further determined based on a variance<br>
of the input soft metrics for the burst.<br>
25. The method of claim 20, wherein the scaling and quantizing for each of<br>
the plurality of bursts are performed with one arithmetic operation on the input soft<br>
metrics for the burst using one composite scale factor that includes the scaling factor<br>
and the quantization scale factor for the burst.<br>
26. The method of claim 20, wherein the common scale factor is equal to a<br>
maximum quantization scale factor for the plurality of bursts if the number of bursts<br>
with signal quality above a predetermined threshold is less than a threshold number.<br>
27. The method of claim 20, wherein the common scale factor is set based on<br>
an average of quantization scale factors for bursts with signal quality above a<br>
predetermined threshold.<br>
28. The method of claim 20, further comprising:<br>
requantizing the rescaled soft metrics for the plurality of bursts to obtain requantized soft metrics; and<br>
deinterleaving and decoding the requantized soft metrics for the plurality of bursts.<br>
Dated this 27 day of January 2006</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
		<br>
		<div class="pull-left">
			<a href="230075-a-secondary-amino-anilinic-piperidine-compound.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="230077-a-process-for-preparing-an-optically-clear-vitamin-supplement.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>230076</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>355/CHENP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>13/2009</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>27-Mar-2009</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>24-Feb-2009</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>27-Jan-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>QUALCOMM INCORPORATED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>5775 MOREHOUSE DRIVE, SAN DIEGO, CALIFORNIA 92121,</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>CHAUDHURI, ARUNAVA</td>
											<td>9505 EASTER WAY, #6, SAN DIEGO, CA 92121,</td>
										</tr>
										<tr>
											<td>2</td>
											<td>NADAKUDITI, RAJ</td>
											<td>195 BINNEY STREET, #4311, CAMBRIDGE, MA 02142,</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>H04L1/00</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US04/24589</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2004-07-28</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>10/787,003</td>
									<td>2004-02-24</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/491,332</td>
									<td>2003-07-29</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/230076-scaling-and-quantizing-soft-decision-metrics-for-decoding by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 10:49:11 GMT -->
</html>
