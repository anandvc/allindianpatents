<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/256687-resource-management-in-a-multicore-architecture by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:16:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 256687:RESOURCE MANAGEMENT IN A MULTICORE ARCHITECTURE</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">RESOURCE MANAGEMENT IN A MULTICORE ARCHITECTURE</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>Abstract Resource management in a multicore architecture A resource management and task allocation controller for installation in a multicore processor having a plurality of interconnected processor elements providing resources for processing executable transactions, at least one of said elements being a master processing unit, the controller being adapted to communicate, when installed, with each of the processor elements including the master processing unit, and comprising control logic for allocating executable transactions within the multicore processor to particular processor elements in accordance with pre-defined allocation parameters. #226261</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td> <br><br>
Resource management in a multicore architecture<br>
This invention relates to a method and apparatus for resource management in a multicore architecture.<br>
Today, semiconductor devices incorporating complex heterogeneous multicore architectures are put to use in a wide variety of systems and devices, from the ubiquitous desktop computer, to the latest in modern electronic devices, such as mobile telephones, Personal Digital Assistants and high speed telecoms or network switching equipment.<br>
Whatever the intended use of any computer processor, the processor manufacturers continue to strive to increase the performance of current processors, whilst maintaining or reducing their unit "cost".<br>
The "cost" of a processor can be measured using a variety of parameters. Although in many cases, the cost will be a purely financial one, in many applications, especially in the embedded processor market, the cost calculation also includes ancillary considerations such as power consumption, cooling requirements, efficiency and time to bring to market.<br>
The absolute capacity for any processor to perform useful functions may be characterised in terms of the MIPS (millions of instruction per second) ratio achievable, and thus the "price-performance" ratio of any processor may be characterised in terms of the MIPS/mm2, MIPS/$, or MlPS/mW, for example.<br>
In practice however, not all instructions achieve the same amount of useful work, therefore "pure" MIPS ratings are not easily comparable. Thus, while a Digital Signal Processor (DSP) is well suited to solving the mathematically intensive processing near the wireless interface of a mobile phone, it is very inefficient at running the web browser that runs on the phone's screen. Effectively this means that processors can be more usefully classified in terms of "application available" price-performance.<br><br>
Furthermore, an additional reduction in the effective performance can be caused by the inefficiency of the programming, i.e. software, tools that must be used to control and customise the processor to implement a particular application. The final level of performance that can be extracted from a processor for a particular application can thus be viewed as the level of usable or "achievable application available" price-performance.<br>
In the semiconductor companies1 drive to improve processor application available price-performance, a new class of processor, the multicore device, has been developed. Multicore devices are highly integrated processors that are built from a variety of elements (cores), each of which may be highly specialised, in order to provide the maximum level of useful price performance for a particular aspect of an application that can be executed by the processor. Such devices may be "heterogeneous", i.e. incorporating multiple, dissimilar cores, or "homogenous", i.e. incorporating multiple similar cores.<br>
Most multicore devices may also be classified as System on Chip (SoC) devices, since the integration includes not only the multiple processing cores, but also the memory, 10 and other system "cores" that are required to handle most (if not all) of the hardware requirements for any particular product. Although not all SoC devices have multiple processing cores, the terms multiple core and SoC are often interchanged. A good example of a multicore SoC can be found in many mobile phones, where one will find a single processor containing one or more DSPs to run the wireless interface, and a general purpose processor to run the user applications on the phone.<br>
The emergence of multicore devices has been enabled by Moore's Law, which states that the number of transistors that can be fitted into any given area of silicon will double every 18 months due to improvements in the manufacturing process. Moore's Law therefore allows for more individual transistors to be fitted into any given area on the silicon die, making it technically and economically viable to manufacture ever more complex devices on a single piece of silicon. Equally, by reducing the size of the transistors, they are capable of being switched at ever higher speeds.<br><br>
Historically, Moore's Law was used to manufacture a new generation of processors at smaller sizes which were faster or more cost effective in terms of silicon used, without any major changes to the underlying architecture (i.e. the improvements were improvements in manufacturing process and the device's physical micro-architecture rather than of device's logical macro-architecture).<br>
Effectively, the trend towards multicore/SoC processors can be seen as a macro-architectural shift to higher levels of integration which first started with the introduction of 10 (communications) functionality onto the silicon die itself; now the 10, the memory, and the functionality of multiple processing units, DSPs and co-processors can be integrated onto the same silicon die. These processors should reduce the manufacturing costs of end products by providing the lowest cost, highest performing processor for a particular class of application. Also, by integrating most of the system components onto a single processor, the part count can be reduced, therefore increasing reliability and lowering power consumption.<br>
A key problem is how the use of the underlying hardware in such multicore devices can be optimised, in order to achieve the highest possible "application available" price-performance.<br>
There are many ways in which processor and system designers may leverage parallelism within the application software (application level parallelism), and within the instruction stream (instruction level parallelism). The various manifestations differ in where the parallelism is managed and whether it is managed when the system is executing/at "run-time11 (dynamic systems), or when the application software is being compiled/at compile time (static )     systems). In practice, the partition between dynamic and static systems and hardware intensive and software intensive solutions is not distinct and techniques from one discipline are often borrowed by the other.<br><br>
At the level of the individual processing core, the concept of multiple issue processors, or machines which operate on many instructions from a single stream in parallel, is well established in the art. They come in two basic types; superscalar and Very Long Instruction Word (VLIW) processors. Superscalar processors issue varying numbers of instructions per clock cycle identified either at run-time (dynamically scheduled) or at compile time (statically scheduled). VLIW processors issue a fixed number of instructions, forming a very long instruction word, as defined by the compiler. Typically, the programmer is completely unaware of this process as the programming model of the system is a standard, single processor abstraction.<br>
Super-threading and Hyper-threading are both technologies which emulate multiple processors by multiplexing multiple threads of execution amongst multiple virtual processors. Typically, these virtual processors share certain resources which, statistically, would not be used by a single thread all of the time. Super and Hyper-threading architectures appear as multiple independent processors and therefore require a level of application parallelism to be present in order to work efficiently. Typically hardware limitations in the processor core limit the number of threads which may be supported to substantially less than 100.<br>
Furthermore, several system-architectural options exist for the exploitation of the inherent parallelism in many applications. Multiple Instruction Multiple Data (MIMD) machines, where each processor executes its own instructions and operates on its own set of data whilst cooperating with its peers through some shared resource (for example memory and/or interconnect), have become popular due their ability to address a wide variety of applications.<br>
As performance demands increase, embedded systems are increasingly )     making use of multicore MIMD architectures, using multiple dissimilar or similar processing resources, to deliver the required level of silicon efficiency. Typically, these are a class of MIMD machine called centralised shared memory architectures, i.e. a single address space (or a proportion thereof) is<br><br>
shared amongst the multiple processing resources, although more application specific hybrid architectures are also commonly found.<br>
Although each processing resource of a MIMD array may exploit Instruction '
Threading is a concept that has been used within the software community for many years, as a high level expression of parallelism. A thread defines an autonomous package of work containing an execution state, instruction stream and dataset, which, by definition, may execute concurrently with other threads. The complexity of the instruction stream is unimportant. A thread may describe anything from a simple transfer of data to a complex mathematical transform.<br>
Traditionally, operating systems have assisted in the provision of system management, including thread allocation functions, which enable an application to be run on a certain configuration of a multicore architecture without the software engineer requiring detailed understanding of the underlying device architecture. However, existing software techniques for thread management within a uni-core device cannot be readily adapted to multicore architectures in a consistent way. Solutions to date have been proprietary, requiring bespoke solutions on a design by design basis and have typically compromised performance and scalability.<br>
Historically, in the case of heterogeneous multi-core systems (that is, systems having broadly dissimilar processing resources), many varying approaches have been employed to enable the disparate processing resources to work together However, broadly these may be split into two categories, "proxy host" and "co-operative" (also known as "peer to peer"). In the former case, a designated general purpose host processor (which in a bus-based system .s<br><br>
often referred to as a CPU) governs the system overall, brokering tasks across the system and synchronising access to resources such as memory and devices. Such system supervision is typically operated in an operating system kernel and competes for slices of time with the system application and the processing of asynchronous events on the host processor. In other words, this general purpose processor must act as a centralised proxy thread manager for all the processing resources on the multicore device, as well as act as a key application processor.<br>
When used in this configuration, the general processor must maintain queues of threads ready for execution for each processing resource, depending on a predefined scheduling policy, i.e. their priority (i.e. dispatch or ready queues), as well as queues of threads awaiting some event, or the return of another thread's results, before they can themselves start to be executed (i.e. pending and timing queues). These are in addition to other system overheads, such as processor configuration prior to thread execution.<br>
Whenever the general purpose processor diverts its processing time from a thread it is currently executing, to the administration of the system (including thread management), for example, as a result of an interrupt issued due to the completion of a thread (and therefore the freeing up of the processing resource that has just completed that thread), the general processor must make a context change.<br>
A context change involves storing the current progress of the thread being halted into memory, fetching instructions relevant to the administration routines for the servicing of the other threads/processing resources, then carrying out those instructions, including any configuration requirements. A further context change must be carried out to return to the original, halted thread. These context changes are typically executed on receipt of an interrupt, and in embedded systems, these interrupts are often both frequent and asynchronous to the application code executing on the general purpose processor. Therefore, the system as a whole exhibits significant degradation<br><br>
of performance. Context switches also have a negative impact upon the effectiveness of host processor caches (the so-called "cold-cache" effect)<br>
In the case of a co-operative system, each processing resource runs a separate instance of an operating system, part of which enables inter-resource communications. Such an arrangement accordingly has a relatively rigid architectural partitioning, as a result of a specific routing of interrupts between peers. Although this type of system offers the primitives required to produce an application, the performance of the implementation still suffers from frequent context switches associated with operating system kernel activity.<br>
In summary, current designs and methodologies for the realisation of system management in traditional architectures (general purpose processors, software executives etc.) are inappropriate for the system and thread management of complex heterogeneous multi-core architectures. Indeed the general purpose processor is poorly optimised at both the micro (instruction set) and a macro (caches, register file management) architectural level. Although the interconnect of a multicore processor provides a physical medium for interoperation between the separate processing resources, there is no system wide task management and communication layer shared amongst all the processing resources enabling a coherent approach to system management. In the worst case this may lead to a distinct problem associated with every possible communication channel between every processing resource, each of which must be traditionally separately solved in software on an ad-hoc basis.<br>
Thus, there is a need for an efficient method of system management of these very complex multicore architectures. Software abstraction alone cannot provide the requisite level of performance of complex multicore architectures.<br>
Summary of the Invention<br><br>
According to a first aspect of the present invention, there is provided a resource management and task allocation controller for a multicore processor as defined in claim 1.<br>
In a preferred embodiment, the controller of claim 1 is dedicated to resource management and task allocation and does not provide further processing resources.<br>
In embodiments of the invention, the "traditional" Master Processing Unit (i.e. the general processing resource that in the absence of the resource management and task allocation controller of the present invention would carry out the task allocation as well as serving as one of the available processing resources) may start off at system turn on as the master, with the resource management and task allocation controller assuming master status from the MPU during the initialisation sequence.<br>
Embodiments of the invention also provide functionality for heterogeneous multicore processors that enables the allocation of tasks to processing resources that would otherwise be ignored for use in processing a particular task. In such a way, the controller of the present invention allows more efficient use of the available resources.<br>
By providing a separate resource management and task allocation controller, the invention provides an improved task allocation and management system for a multicore processor, enabling the more efficient allocation of tasks between the available processing resources. The controller abstracts the elements of system management and exception handling into a dedicated, efficient, hard-coded embodiment.<br>
Embodiments of the invention employ controller clients along with the controller, rather than enforcing the role of a "proxy agent". The controller clients may be implemented in hardware or software. Such an arrangement efficiently masters the "run-time" activities of the underlying system. In particular, the controller continually ("greedily") maintains the correctness of<br><br>
the system thread states and scheduling decisions based upon the range of pre-defined allocation parameters.<br>
The architecture of preferred embodiments accordingly provides significant benefits in terms of the division of work between the constituent components and the autonomy of individual processing resources, regardless of complexity. All processing resources become slave devices, which are by default "lazy", i.e. they wait to be explicitly instructed by the resource management and task allocation controller to perform tasks, via, in preferred embodiments, dedicated interrupts. Equally, in other embodiments, poll based communications may be used between the resource management and task allocation controller and processing resources.<br>
In systems employing the controller of the present invention, all asynchronous events instigated from outside the architecture, either directly through a pin or indirectly through external manipulation of one of the processing resources (i.e. an 10 device), are in preference routed to the controller, where they are compared using a set of scheduling policies, configured at "boot-time", with the currently executing task on the target processing resource. The processing resource is only interrupted if an interrupt service thread (1ST) associated with the external event presides over the currently executing transaction (thread or task), thereby obviating unnecessary context switching in any processing resource as was a problem in the art. Furthermore, the controller clients of preferred embodiments enable processing resources of arbitrary complexity to perform basic system management operations on shared resources and the controller itself (create thread, issue synchronisation primitive, delete thread, memory copy etc), avoiding the need for an instruction set based machine to execute these tasks by proxy.<br>
In a further aspect of the invention, there is provided a multicore processor comprising such a controller.<br>
The invention also extends to a method of controlling and allocating resources in a multicore processor as defined in claim 40.<br><br>
Further advantageous and features are defined in the dependent claims appended hereto.<br>
Brief description of the drawings<br>
The present invention may be put into practise in a number of ways, and some embodiments will now be described by way of example only and with reference to the accompanying drawings, in which:<br>
Figure 1 shows a schematic block diagram of the logical layout of system incorporating a resource management and task allocation controller in accordance with an embodiment of the present invention;<br>
Figure 2 shows a schematic block diagram of one exemplary implementation of the logical layout of Figure 1, wherein the controller embodying the present invention is incorporated within a general purpose, multicore processor architecture, along with a dedicated memory device and a controller client;<br>
Figure 3 shows, again in block diagram form, an example of a contemporary System on Chip (SoC) bus-based architecture incorporating the elements of Figure 2;<br>
Figure 4 shows a more detailed view of external connections to the controller of Figures 1, 2 and 3;<br>
Figure 5 shows a more detailed view of the memory device of Figures 2 and 3;<br>
Figure 6 shows a more detailed view of the internal composition of the controller of Figures 2, 3 and 4;<br>
Figure 7 shows a schematic block diagram of a controller client as shown in Figures 2 and 3;<br><br>
Figure 7B shows a schematic block diagram of the system in the case of a single controller client acting as a proxy for multiple processing resources.<br>
Figure 8 shows a more detailed schematic block diagram of a hardware controller client;<br>
Figures 9a and 9b show a generic descriptor and its associated fields; Figures 9c and 9d show a thread descriptor and its associated fields; Figures 9e and 9f show a scheduler tier descriptor and its associated fields; Figures 9g and 9h show a dispatch queue descriptor and its associated fields Figures 9i and 9j show a pending queue descriptor and its associated fields; Figures 9k and 91 show a skip list descriptor and its associated fields;<br>
Figure 10 shows a typical relationship between a thread descriptor, the system management controller, a processing resource and the shared system memory;<br>
Figure 11 illustrates the principle of indirection in the arrangement of Figure 10, where two dissimilar processing resources are present;<br>
Figure 12 shows a typical overall view of thread management within the controller of Figure 4;<br>
Figure 13 shows a typical pending queue structure; Figure 14 shows a typical pending queue skip list; Figure 15 shows a typical timer queue;<br><br>
Figure 16 shows a typical Ready queue structure for two processing resources;<br>
Figure 17 shows an exemplary embodiment of a typical single dispatch queue structure;<br>
Figure 18 shows a two tier scheduling hierarchy, including thread bundling; and<br>
Figure 19 shows an exemplary simplified queue structure that might commonly be found in a communications system;<br>
Detailed Description of the Preferred Embodiment.<br>
Figure 1 shows a logical view of a system framework 10 incorporating features that are in accordance with an embodiment of the present invention. The framework 10 comprises a plurality of processing resources 150, each of which may be similar or dissimilar to others of the processing resources 150, and each of which may be of arbitrary complexity. Each processing resource shares access to a common system memory 140 where shared data is stored via an interconnect 160. It will be understood that not all system memory 140 is necessarily common to all processing resources 150, of course.<br>
The system framework also comprises a centralised task allocation and management system 20 in accordance with an embodiment of the present invention. The centralised task allocation and management system 20 includes a system management controller 130 and a dedicated tightly coupled memory interface 180, connected to a dedicated tightly coupled memory 190. Each processing resource 150 is able to access the controller 130 via an interconnect 115. It is to be understood that no particular interconnection strategy (that is, the arrangement by which the controller 130 communicates with each processing resource 150 and vice versa, and the arrangement by which each processing resource 150 communicates with the system memory<br><br>
140) is required in the implementation of the arrangement of Figure 1; in particular, point to point links, a central system bus or even a pipelined architecture may equally be employed, save only that each of the processing resources should be able to communicate directly or indirectly (i.e. via other processing resources or otherwise) with the controller 130.<br>
Figure 2 shows a multicore processor implementing the logical arrangement of Figure 1, again by way only of an example. The multicore processor of Figure 2 employs a plurality of the processing resources 150, each connected via a system interconnect 160. The system interconnect 160 communicates in turn with the system management controller 130 via input interfaces 100, and output interfaces 110. In the example of Figure 2 the system interconnect 160 is laid out as a traditional central bus which connects each of the processing resources 150 with one another and with the controller 130, and also with the shared system resources such as a system memory 140. Interfacing with the memory 140 may be achieved via any one of a number of currently available interface technologies. The memory may consist of any of the currently available central computer memory technologies, for example Static Random Access Memory (SRAM), or Double Data Rate Random Access Memory (DDR RAM).<br>
As seen in Figure 2, each of the multiple processing resources 150 has an associated system management controller client 120 configured to receive control information from the central controller 130, and to administer the processing resources 150 in accordance with the control information received. The function and purpose of the controller clients 120 is described in more detail in connection with figures 7 and 8 below. Each processing resource also has an associated interconnect agent 170 for communication with the controller 130 via the system interconnect 160. The interconnect agent 170 provides a generic interface to the controller client 120, which is independent of the underlying interconnect protocol in use on the system interconnect 160, i.e., it provides protocol translation between the communication protocols in use on the system interconnect 160 and the communication protocol in use by<br><br>
the controller client 120. Due to the use of an interconnect agent 170, the controller clients 120 of embodiments of the present invention may be used with any system interconnect protocol currently available.<br>
The multicore processor, as a whole, is configured to execute a target application, which may be broken down into a number of individual tasks, called threads. Each processing resource 150 is allocated a suitable thread by the controller 130, according to a number of parameters, including, but not limited to, the priority of the thread in question, the availability of each processing resource 150 and the suitability of a particular processing resource to the execution of a particular thread. This will again be described in more detail below.<br>
It is however to be understood that the addition of the system management controller 130 and its dedicated memory 190 do not otherwise require a redesign of the layout of the processor 10.<br>
One specific arrangement is shown in Figure 3 which shows a typical System on Chip (SoC) architecture, in block diagram form, and which illustrates the various processing resources that might be placed under the resource management of the controller 130 in a practical application. It will be noted that the processing resources may in particular be of relatively general capability, such as a DSP, or may of relatively limited functionality, such as a peripheral IO.<br>
System Management Controller Interface groups<br>
Figure 4 shows the controller 130 and its associated interface groups 200 -<br>
250, located on the periphery of the controller 130.<br>
The system control group 200 comprises the two system input signals required to ensure the correct operation of the system management controller 130.    The two system inputs comprise a CLK input, which is connected to the system clock, and a RST input. All output signals from the system management controller 130 are synchronous to the system clock and all input<br><br>
signals to the system management controller 130 are sampled using this clock. The RST input is a synchronous reset signal, for resetting the system management controller 130.<br>
The external interrupt group 210 consists of a group of synchronous external interrupts sourcecl from outside the system management system. These signals must be synchronised to CLK prior to their attachment to the system management controller 130 periphery. Signals in the external interrupt group 210 may be driven from, for example, input interfaces with the outside world or directly from outside the multicore processor via pins. The number of external interrupt inputs is defined during the multicore processor 10 design phase.<br>
The internal control group 220 consists of a single synchronous interrupt for each controller client 120 and its associated processing resource 150. Therefore the number of groups of signals will typically correspond with the number of processing resources 150 within the system and will be defined during the multicore processor 10 design phase. The internal interrupt signal is indicative of a thread ready for execution, and that is being assigned to the particular processing resource 150 associated with that controller client 120.<br>
The tightly coupled memory interface group 180 interfaces the system management controller 130 to its own dedicated tightly coupled memory resource 190. Figure 5 shows a typical structure of the dedicated tightly coupled memory 190. The width of the address path and the datapath are defined during the multicore processor 10 design phase. The dedicated tightly coupled memory interface includes a memory address bus 191, a memory read data bus 192, a memory write data bus 193 and write 194 and read 196 enable signals.<br>
The attached memory is assumed to be a synchronous SRAM device. The dedicated tightly coupled memory 190 contains an integer number of controller memory elements 195, as defined during the multicore processor 10 design phase, according to the needs of the target application. In the<br><br>
currently preferred embodiment, each controller memory element 195 consumes 256 bits of memory space. Again in the currently preferred embodiment, the controller supports a maximum of 65536 controller memory elements (i.e. a 16Mb memory). Although queue descriptors, as described later, do consume controller memory elements 195, in a typical system the number of controller memory elements 195 required would be dominated by thread support requirements. For example, a system capable of supporting 400 threads simultaneously within the system management controller 130 would require approximately 128kb of attached memory.<br>
The interconnect interface group 230 of Figure 4 conforms to the chosen interconnect protocol used in the multicore processor 10, and the interconnect agent 170, which is defined during the multicore processor design phase.<br>
Controller Subblock description and functions<br>
Figure 6 shows the main logical components of the system management<br>
controller 130. The functionality of the controller 130 is split amongst four<br>
primary internal parallel processing subblocks, performing the following<br>
functions:<br>
1.       A Thread Input Manager (TSIM) 300, configured to maintain a list of free controller memory elements 195 within the dedicated tightly coupled memory 190, and to oversee controller memory element 195 recovery.<br>
;     2.        A Thread Synchronisation Manager (TSPM) 310, configured to<br>
maintain Pending lists and a timer queue within the dedicated tightly coupled memory 190 and to perform synchronisation between threads, and to perform promotion of threads to Ready queue structures within the dedicated tightly coupled memory 190, as required. The Thread Synchronisation manager 310<br>
)     maintains the integrity of the pending and timer queue structures via insertion and extraction of pending thread descriptors within the dedicated tightly coupled memory 190.<br><br>
3.       A Thread Output Manager (TSOM) 320, configured to maintain Ready queue structures within the dedicated tightly coupled memory 190, and Dispatch queues for each processing resource 150 within the dedicated tightly coupled memory 190. The Thread Output Manager (TSOM) 320 is further configured to generate the interrupts 220 sent to the controller clients 120. Maintenance of the integrity of the ready queue structures is performed by insertion and extraction of thread descriptors held in controller memory elements 195, within the dedicated tightly coupled memory 190.<br>
i     4.       A Thread Schedule Manager (TSSM) 330, configured to provide scheduling decisions for each processing resource 150 within the ready queue structures located within the dedicated tightly coupled memory 190.<br>
Additionally a number of secondary processing subblocks provide support functions:<br>
5.	A Thread Memory Manager (TSMM) 340, configured to provide<br>
aggregate access to the attached dedicated tightly coupled memory 190,<br>
including mutual exclusivity and locking.<br>
6.	An Interrupt Manager (TSIC) 350, configured to convert incoming<br>
external system interrupts into internal synchronisation primitives.<br>
7.	A Time Manager (TSTC) 360, configured to provide timer functions for<br>
synchronisation purposes and watchdog timer functionality to each processing<br>
resource 150.<br>
8.	A System Interface (TSIF) 380, configured to provide interconnect<br>
interfacing and configuration and run-time access to the multicore processing<br>
resources 150.<br>
There now follows a detailed description of the interaction of the above primary and secondary processing subblocks within the system management controller 130.<br><br>
Each sub-block presents a set of functions to other sub-blocks, enabling each to instruct its peers to execute manipulations on their respective maintained structures within the dedicated tightly coupled memory 190. Functions are called by a particular subblock, on receipt of a similar command received at a controller software Application Programming Interface (API).<br>
Thread Input manager functions:<br>
The thread input manager 300 provides three public functions to other sub-blocks within the system management controller 130.<br>
The FreeListStatus function returns the head pointer and number of elements within the controller memory element 195 free list. The free list is a list of the controller memory elements 195 that are currently unused. This function can only be called by the system interface 380, on receipt of a similar command at the controller 130 software API<br>
The PushFreelndex function is used to push a liberated controller memory element 195 index back onto the free list. This function can only be called by the Thread Schedule Manager 330.<br>
The PopFreelndex function is used to pop a free controller memory element 195 index from the free list. It is typically called from within the API call service routine within the system interface 380.<br>
Thread Synchronisation Manager functions:<br>
The Thread Synchronisation Manager 310 provides seven public functions to<br>
the other sub-blocks within the system management controller 130.<br>
The following five functions can only be called by the system interface 380, in response to similar commands received by the controller 130 software API.<br>
The PushPendingDescriptor function is used during the boot process to add a pending queue descriptor to the list of pending queue descriptors.<br><br>
The PushThread function is used during runtime to add a dependant thread to a given pending queue.<br>
The SetTimerStatus sets the head pointer and number of elements within the timer queue.<br>
The GetTimerStatus function returns the head pointer and number of elements within the timer queue.<br>
The SetPendingStatus function sets the status of the pending queue descriptor list.<br>
The GetPendingStatus function returns the head pointer and number of elements within the pending descriptor queue.<br>
The SyncEvent function is used to issue a synchronisation primitive to a given pending queue. This function is called by the thread interrupt manager 350 and the system management controller 380.<br>
The TimeEvent function is used to issue a timer based synchronisation primitive to the timer queue. This function is only called by the time manager 360.<br>
Thread Output Manager functions:<br>
The Thread Output Manager 320 provides five public functions to the other<br>
sub-blocks within the system management controller 130.<br>
The Push function places a thread descriptor within the ready queue structure. The method may be called with high priority to expedite processing speed (for example, to handle interrupts). Where threads are independent (immediately ready) the call will be made from the system interface 380, where the thread descriptor originally had dependencies the call is made from the thread synchronisation manager 310.<br><br>
The following three functions can only be called by the system interface 380, in response to the receipt of a similar command at the controller 130 software API<br>
The GetDispatchQueueStatus function returns the head pointer and number of elements within the dispatch queue list.<br>
The SetDispatchQueueStatus function sets the head pointer and number of elements within the dispatch queue list.<br>
The DispatchQueuePop function pops a thread descriptor from a the head of a dispatch queue.<br>
The DispatchWorkQueuePush function pushes a dispatch queue onto the thread output manager 320 work queue. This function can only be called by the thread schedule manager 330, which uses this function to inform the output manager 320 of changes required within the dispatch queue as a result of schedule updates.<br>
Thread Schedule Manager functions:<br>
The Thread Schedule Manager 330 provides three public functions to the Thread Output Manager 320 and System Interface (TSIF) 380, located within the system management controller 130.<br>
The PushPushWorkEvent function is called by the thread output manager 320, immediately after it adds a thread descriptor to a ready queue structure.<br>
The PushPopWorkEvent function is called by the thread output manager 320, immediately after it removes a thread descriptor from a ready queue structure.<br>
A Freelndex function enables the liberation of a controller memory element 195 to be properly synchronised with scheduling activities ongoing within the Thread Schedule Manager 330. The call may be issued on receipt of a<br><br>
similar command at the controller 130 software API, or as a result of a pop operation within the Thread Output Manager 320<br>
Controller Client<br>
As described earlier, the term processing resource 150 is applied to any resource that may execute an instruction, regardless of how rudimentary the instruction may be. Therefore resources that have a fixed function, such as an input/output module, are also included. Depending on the type of processing resource 150, the connection between the system interconnect 160 and the processing resource 150, via the system management core client 120 may be either uni-directional or bi-directional.<br>
Figure 7 shows an exemplary schematic block diagram of a controller client 120 for use with the system management controller 130.<br>
On appropriate processing resources 150, for example general purpose processors or Digital Signal Processors, the controller client 120 will typically be implemented in software. However, where the processing resource 150 is of limited function, the controller client 120 may require a hardware component.<br>
When a hardware component is used between the system interconnect 160 and the processing resource 150, the controller client 120 still interfaces to the processing resource 150 using the same interface. That is to say, the controller client presents an identical interface to the interconnect agent 170 as that of the processing resource 150 to the controller client. In some cases, it is appropriate to treat the data path into the processing resource as distinct from the data path out of the processing resource, for example in the case of an Input/Output device.<br>
In addition to the main interface, the controller client 120 also provides out of band interfaces for use as outputs for run-time and debug events. Where a software controller client 120 is used, these are provided using standard interrupts, calling appropriate service routines.<br><br>
Controller Client Mode of Operation:<br>
Each controller client 120 is fully interrupt driven. Upon receipt of an internal interrupt from the controller 130, the controller client 120 pops the thread descriptor from the head of the dispatch queue associated with that particular processing resource 150, which is held in the dedicated tightly coupled memory 190. The unique reference within the thread descriptor is then used to read further thread control information, the Thread Control Block (TCB), from the main memory resource 140. The information contained within the TCB may be any of:<br>
1.	Controller client 120 configuration content. This information may be<br>
used to configure controller client 120 system resource usage policing,<br>
data presentation mode, and the like.<br>
2.	Processing Resource 150 Configuration content. This is information<br>
required to prepare the processing resource 150 for execution of a particular<br>
thread. This may include recovery from a previous partial execution of this<br>
thread or configuration of a specialist hardware accelerator, such as an audio<br>
CODEC.<br>
3.	Instruction content. In the case of a fixed function hardware<br>
accelerator, the "instruction" will be implicit in the targeted hardware<br>
processing resource 150, for example an output instruction when the<br>
processing resource 150 is an output module, and any required specialisation<br>
or configuration will be accommodated within the configuration information. In<br>
the context of a software controller client 120, this will typically be a pointer to<br>
the function code associated with the thread.<br>
4.	Data content. This content may define the start address or multiple<br>
addresses in the system memory 140 and range of data over which the thread<br>
may operate.<br><br>
5.        Controller client 120 post-processing content. This content determines the actions of the controller client 120 after the completion of the thread execution.<br>
There are three distinct phases of operation of the controller client 120:<br>
1.	Configuration phase, where the processing resource 150 and the<br>
controller client 120 are prepared for execution of a particular thread. In the<br>
simplest case the configuration phase will be null.<br>
2.	Execution phase, where the thread is being executed and the controller<br>
client 120 may be supplying data and/or monitoring resource utilisation.<br>
3.	Completion phase. Completion of processing may result in no action,<br>
the creation of another thread, the issuance of a synchronisation primitive or a<br>
combination of thread creation and synchronisation. Furthermore, the<br>
controller client 120 may also be required to set or update scheduler metrics<br>
and terminate threads. In the event that, during execution of the thread,<br>
further memory is required to store results, the controller client 120 must also<br>
execute this method.<br>
In circumstances where an individual hardware controller client 120b makes full use of the available system interconnect 160 bandwidth during active periods, an optimised solution would allow a controller client 120b to operate as a proxy for multiple hardware processing resources 150. Such an arrangement is shown in figure 7B. As in the previous case, the proxy controller client 120b is interrupt driven, however, whereas in the previous example only a single interrupt was routed from the controller 130, in the proxy controller client model, there is an interrupt per processing resource 150. According to the index of the interrupt received from the controller 130, the proxy controller client 120b executes the same steps on the identified processing resource 150. In the proxy controller client model, where system interconnect 160 usage policing is required, a hardware adaptor 120c will<br><br>
remain between the processing resource 150 and the system interconnect 160.<br>
As mentioned previously, the controller client 120 may be implemented in software. In this case some of the functionality of the controller client 120, for example shared resource usage policing, will typically make use of existing hardware components which may already be present in the processing resource 150 hardware (for example, a memory management unit (MMU)).<br>
Consequently, the software controller client 120 architecture and implementation is processing resource 150 specific.<br>
Hardware controller clients 120 may also have specialist requirements according to the idiosyncrasies of the associated processing resource 150. The following section describes a generic architecture which will be suitable in the majority of cases.<br>
General Example of a Hardware Controller Client<br>
The basic structure of the hardware controller client 120 is shown in Figure 8. At the functional heart of the design is the controller client Finite State Machine (FSM) 500. This Finite State Machine (FSM) 500 may be active during all three phases. The controller client FSM 500 is activated by an interrupt 220 from the controller 130.<br>
Firstly the controller client FSM 500 masters the system interconnect 160 to read the TCB from the shared memory resource 140, which contains a reference to its own instructions. During the configuration phase the controller client 120 may master the processing resource interface, interpreting configuration commands and translating them into write cycles issued to the processing resource 150. Furthermore, the controller client 120 configures its own resource policing. The manner in which the transition from the configuration state to the executing state is processing resource 150 specific, but may be marked by an explicit execute primitive or merely an entry into a data transferral state.<br><br>
From a controller client 120 perspective the simplest architecture has an identical interface protocol on both the processing resource 150 and the system side. In this case, during the execution phase, processing resource 150 read and write cycles are simply mapped across to the system interface with checking where appropriate.<br>
The simplest controller client 120 implementation would require a FIFO style interface in both the system to processing resource 510 and processing resource to system 520 paths. During the execution phase of a controller client 120 of this nature, data can be presented to a processing resource 150 by message or streaming modes. Message mode, where the entire dataset is accumulated locally within the controller client 120 prior to processing, engenders a more coarse grain blocky interconnect behaviour which may facilitate more complex interconnect arbiters. Streaming mode, where data is streamed directly from the system memory into the processing resource 150, presents a more silicon efficient solution requiring more careful consideration of hand-shaking and exhibiting fine grained interconnect transactions and tight coupling to interconnect performance.<br>
The transition from the execution to the completion phase may be inferred, by measuring the presentation of data to the processing resource 150, or explicitly signalled by the processing resource 150 itself. During the completion phase, the controller client 120 once again executes from the set of instructions provided by the original thread control block.<br>
Note that, in some cases, it is appropriate to treat the datapath into the processing resource 150 (for example an input/output device) and the path out of the processing resource 150 as distinct. In contrast it will be natural in some cases (for example, algorithmic accelerators such as DSPs) to couple the consumer and the producer of data within the same controller client 120 framework.<br><br>
In order to provide a level of decoupling between the processing resource 150 and the other system resources, a number of additional facilities may also be provided by the controller client 120:<br>
a)	Addresses generated by the processing resource 150 may be checked<br>
against expected behaviour as defined by a base address and offset<br>
definition, by using a comparator 530 and a comparison address register 540.<br>
b)	Addresses generated by the processing resource 150 may be offset,<br>
using a subtractor 550 and offset address register 560, enabling the<br>
processing resource 150 to have a normalised view of the address map for<br>
any given thread, typically normalised around address 0x0.<br>
Objects<br>
Instances of datatypes used within the system management controller 130 are divided into public (visible from and manipulated by the system at large) and private visibility (visible only within the system management controller 130 and manipulated only by the system management controller 130 sub-blocks). To ensure portability of the design across multiple end applications, all thread, queue and aggregated queue descriptors are stored within the dedicated tightly coupled memory 190 using a common base class, the controller memory element 195.<br>
Controller Memory Elements<br>
Each controller memory elements 195 may represent any of seven descriptor<br>
types:<br>
1.	Free List Element. This element is free for usage by any of the other<br>
descriptor types. No user initialisation or runtime manipulation is required.<br>
2.	Thread descriptor (TD). This is a data structure representative of an<br>
application/OS thread. This descriptor may exist in either a pending queue, a<br>
Ready queue or a dispatch queue within the dedicated tightly coupled<br>
memory 190. No user initialisation is required, but runtime manipulation is<br>
required.<br><br>
3.	Scheduler Root Descriptor (SRD). This is the top descriptor of a<br>
scheduler hierarchy. User initialisation is required, but no runtime<br>
manipulation is required. The root descriptor has no parent, but children can<br>
be any of: an SSTD, a DSTD or a TD.<br>
4.	Static Scheduler Tier Descriptor (SSTD). This is a static scheduler tier<br>
descriptor, whose parent may be either an SRD or another SSTD. The<br>
SSTD's children can be any of: another SSTD, a DSTD or a TD.<br>
5.	Dynamic Scheduler Tier Descriptor (DSTD). This is a dynamic<br>
scheduler tier descriptor. User initialisation is not required, but runtime<br>
manipulation is required. The parent of a DSTD may be either an SRD or an<br>
SSTD, but a DSTD may only have TD children.<br>
6.	Dispatch Queue Descriptor. This type of descriptor describes a list of<br>
thread descriptors, which are waiting for pop operations from the associated<br>
processing resource 150. User initialisation is required, but no runtime<br>
manipulation is required.<br>
7.	Pending Queue Descriptor. This type of descriptor describes a list of<br>
thread descriptors, which are awaiting a synchronisation event. User<br>
initialisation is required, but no runtime manipulation is required.<br>
These descriptors are described in greater detail in the following sections.<br>
The various forms of the Controller Memory Elements 195, and their respective are shown in figures 9a to 91.<br>
Thread representation<br>
Where a descriptor requires initialisation or run-time manipulation, operations are done through the controller 130 API. The centralised task allocation and management system is designed to ensure that real-time interaction is suitable/simplistic enough for a hardware implementation.<br><br>
Figure 10 shows a typical relationship between a thread descriptor, the system management controller 130, a processing resource 150 and the shared system memory 140. Each thread primitive contains a unique reference, pReference. This reference is not interpreted or modified by the system management controller 130. pReference provides a pointer to a data structure in system memory 140 defining the task to be executed. Typically this would be a controller client control block 125, and would contain at least the following elements: a Function pointer (shown in Figure 10 as a processing resource instruction block 145), a Stack Pointer and an Argument Pointer (shown together in Figure 10 as a data block 135). Additional fields may be defined which provide in-band configuration or security over shared system resources.<br>
However, according to the application and/or target processing resource 150 the complexity of the controller client control block 125 may vary. In particular, note that further levels of indirection may be included which, given appropriate "control" instruction code and corresponding "datapath" code, may enable disparate processing resources 150 to execute the same functions on the same data under certain circumstances.<br>
Figure 11 shows an example where a scheduling hierarchy load balances tasks across two dissimilar processing resources (Type I and Type II in Figure 11) 150a and 150b. The pReference field (within the thread descriptors which are queued to this hierarchy) references a controller client control block 125 as before, except here there are pointers for each type of processing resource corresponding to the particular instruction stream required by the dissimilar instruction sets of each . The controller client 120 selects the appropriate instruction stream (instruction block 145a or 145b) according to flags within the Controller client control block 125.<br>
This feature may be useful, for example, in conjunction with the power-down feature of certain processing resources. In the case where the optimal processor for a given task is powered down, it may be desirable for a sub-optimal processor to execute the task rather than incur a costly reboot cycle.<br><br>
Furthermore, under exceptional loads it may enable a lightly loaded general purpose processor, for example, to relieve the burden on a heavily loaded DSP.<br>
When a processing resource 150 is ready to deal with a thread, it is popped from the appropriate dispatch queue uniquely associated with that processing resource 150. The pop operation returns an object containing pReference, the scheduler metrics that resulted in the scheduling event, and a set of flags including an indication of whether the thread became Ready due to a timeout or a synchronisation primitive. The controller memory element 195 used for the thread descriptor is automatically returned to the free list for use by future thread descriptors.<br>
Public Objects<br>
This section describes the objects visible to the system through the controller 130 API. Typically these objects are manipulated by the centralised task allocation and management system, comprising the controller 130 and the clients 120 and their associated processing resources 150, at runtime.<br>
The runtime controller 130 API enables the application to introduce new threads, introduce new dynamic scheduler elements, issue synchronisation primitives, pop scheduled threads, push pre-empted threads or remove threads.<br>
Figure 12 shows a typical overall view of thread management within the system management controller 130.<br>
Thread Primitives<br>
The format of a thread primitive is shown in figures 9c and 9d. According to its dependencies, a thread descriptor may be placed in the pending queue structure or directly into the Ready queue structure. If a thread is to be placed within the pending queue structure the application must define the dependencies of the thread. Dependence upon an external event manifests itself as a dependency reference. The controller 130 does not interpret this<br><br>
dependency reference; it is maintained for comparison to the incoming synchronisation primitives to determine when to transition the thread descriptor into the Ready queue structure.<br>
For dependant threads a timeout may be specified, in conjunction with a null dependency reference this facility may be used as a thread based hardware-timing facility. Regardless of the dependency reference, timeouts cause the thread to be scheduled at a particular time.<br>
Threads are tagged according to the synchronisation event (timer or primitive) that causes them to be promoted to the Ready queue structure.<br>
Synchronisation Primitives<br>
Synchronisation primitives interface with the pending queues and may cause the transition of one or more thread descriptors from the pending queue structure to the Ready queue structure.<br>
Each synchronisation primitive contains a unique reference which is compared with the dependency reference stored within each thread descriptor i     in the identified pending queue. The comparison continues in the order of priority identified by the thread primitives.<br>
According to its type, a synchronisation may wake either the highest priority matching thread descriptor or all matching thread descriptors within a pending i     queue. Furthermore, a special broadcast primitive wakes all matching thread descriptors within all pending queues.<br>
Interrupt Processing<br>
An Interrupt Service Thread (1ST) methodology provides a valuable means of )     minimising the load imposed on processing resources 150 by asynchronous events. Furthermore, the accelerated real-time response in systems based on the present invention enables more widespread use of ISTs with minor system modifications.<br><br>
The controller 130 automatically creates synchronisation primitives from external interrupt inputs 210 on the controller periphery. Preconfigured interrupt service thread descriptors within the pending queues will be promoted to a Ready queue structure upon reception of these interrupt synchronisation primitives.<br>
The application will normally configure the thread descriptor associated with the external interrupt 210 at system initialisation and again within each execution of the associated interrupt service thread.<br>
This facility effectively removes the need for any other dedicated interrupt servicing processing resource 150 within the system. Furthermore it processes these external interrupts 210 through the same priority structure and according to the same policies used for all processor tasks, precluding the need for context switches within processing resources already executing higher priority tasks. An arbitrary number of nested interrupts are supported by the ability to push the currently executing thread back onto the ready queue using the normal pre-emption routines.<br>
Timer based interrupts (watchdogs and periodic events) are handled in a similar manner. Time based tasks (periodic or one-shot) must be inserted onto the timer queue and are handled in a similar manner to threads with a timeout dependency. By design, this methodology precludes time based exceptions with no useful processing requirement.<br>
Interrupt priority may be set such that interrupt routines are allowed to preempt currently executing tasks for fast response times.<br>
Private Objects<br>
Private objects are typically configured at boot-time, i.e. during system initialisation after a power down cycle. Processing resources 150 rarely interact directly with internal objects during runtime.<br><br>
The internal objects are primarily queuing structures. The system management controller 130 administers four primary types of queue: Pending Queues, a Timer Queue, Ready Queues and Dispatch Queues.<br>
Additional secondary queues exist within the system management controller 130 to facilitate internal operations. Movement of thread descriptors between queues takes place with pointer manipulations only. Thread descriptors are never copied.<br>
Pending Queue Structure<br>
Threads may be promoted from a pending queue structure to the ready queue structure through either a synchronisation event or a timer event. A thread may be sensitive to both, or just one of these classes of events. In the case where a thread is sensitive to both, the thread is present in both the pending and the timer queues.<br>
Pending queues hold dependent threads awaiting a synchronisation event. Threads are removed from these structures through either a synchronisation primitive, from a processing resource 150, or by a timer event internally generated by the time manager 360. A configurable number of pending queues are available to the application programmer to support multiple contention scopes and interrupt service threads; elements within each pending queue must be processed according to their priority. There are two alternatives to processing according to priority, sort on insertion and sort on extraction. Sort on insertion defines a process by which the pending list is stored in strict priority order and new threads are inserted into a position within the list according to their priority. Sort on extraction makes an arbitrary choice of where to insert a new thread and performs priority based sorting of eligible thread descriptors after synchronisation. The preferred embodiment of the present invention employs the sort on insertion technique.<br>
Figure 13 shows a typical structure of the pending queues. Entries are stored in strict priority order. The speed with which the insertion of a new thread may be achieved is accelerated by the use of skip lists, and Figure 14 shows a typical pending queue skip list.<br><br>
As previously stated, threads may be blocked awaiting synchronisation or timer events. Some threads will be exclusively awaiting a synchronisation event and similarly, some threads will be exclusively awaiting a timer event. In each case, the thread will only be present in a single queue. Each thread contains two sets of pointers, nominally associated with both the pending and timer queues. In these cases the provisioned timer queue and pending queue pointers respectively are spare. Skip lists may take advantage of these spare pointers - for example, if the thread does not appear in the timer queue, these pointers may be reused to indicate a possible jump ahead in the pending queue. This enables an otherwise sequential search to jump blocks of thread descriptors whilst iteratively approaching a correct insertion point for a new dependant thread.<br>
An alternative is a skip node descriptor and one example of this is shown in Figure 9k, along with its associated fields (Figure 91). The skip node descriptor may periodically be inserted into the pending and timer queue structures according to a predefined metric. Skip node descriptors are inserted according to a defined maximum observed number of thread descriptors between skip node descriptors or participating thread descriptors. Skip node descriptors may simultaneously form a part of a pending queue and a timer queue skip list.<br>
Each new dependant thread must be inserted according to its priority. The process will typically commence by traversing the skip list until the new thread's priority is higher than that of the skip list node. Thereafter, the search will continue, from that skip list node, on a thread descriptor by thread descriptor basis until the correct insertion point is found. This enables the otherwise linear search to skip blocks of pending threads when homing in on the correct insertion point for a new dependant thread.<br>
Synchronisation events have three distinct types:<br><br>
Unicast: The synchronisation event triggers a state transition on the first<br>
(highest priority) appropriate dependant thread found in the specified pending<br>
queue.<br>
Multicast: The synchronisation event triggers state transitions on all<br>
appropriate dependant threads in the specified pending queue.<br>
Broadcast: The synchronisation event triggers state transitions on all<br>
appropriate dependant threads in all pending queues.<br>
Pending queues are defined by pending queue descriptors, as shown in Figures 9i and 9j. Pending queue descriptors are configured once during system initialisation and consume a single controller memory element 195. Pending queues only contain dependant thread descriptors and skip list nodes.<br>
Timer Queue Structure<br>
A single system wide timer queue is provided, which stores thread descriptors awaiting a timeout event. Figure 15 shows an exemplary embodiment of a timer queue.<br>
Skip lists are also used to expedite the insertion of threads into the timer queue structure as described above. However, in this case it is threads that only have temporal dependency (if any) which are used for skip lists.<br>
The timer queue descriptor is stored within registers, enabling a concurrent compare to proceed between the head of the timer queue and the current time. This greatly reduces the impact of timer ticks on memory bandwidth.<br>
Ready Queue Structures<br>
Ready queue structures hold threads that are ready for execution. These<br>
threads were created with independent thread primitives, or they have<br>
received the synchronisation primitive upon which they were dependant.<br>
Synchronised threads have previously transitioned from a pending queue<br>
structure.<br><br>
The Ready queue structures may contain scheduler node descriptors and independent and synchronised thread descriptors. The structure is largely defined during system initialisation although thread descriptors and dynamic scheduler tier descriptors are allowed to come and go in real time.<br>
Ready queues may schedule threads to a specific processing resource 150, or a pool of processing resources 150. This enables load balancing across multiple processing resources 150 whilst maintaining the ability to target specific tasks at specific processing resources 150, for example hardware accelerators or IO devices.<br>
Figure 16 shows a typical Ready queue structure for two processing resources 150. Note that dynamic scheduler tier 2 is available to both root scheduler tiers. This enables the system management controller 130 to load balance threads beneath dynamic tier 2 between the processing resources 150 associated with root tiers 1 and 2.<br>
Scheduler Tiers<br>
Scheduler tiers define the hierarchy used to schedule thread descriptors. Each scheduler tier typically defines a scheduling algorithm, some metrics used to determine scheduling decisions and a list of child elements that may be further scheduler tiers or thread descriptors. There are three types of scheduler tier descriptor; root, static and dynamic. The format of scheduler tier memory elements is shown in Figures 9e and 9f.<br>
Root scheduler descriptors have a one-to-one mapping with dispatch queues. They represent the ultimate node in the Ready queue structure. Scheduler root descriptors are configured during system initialisation and exist in perpetuity.<br>
Static Scheduler Descriptor exist beneath root nodes in the scheduling hierarchy. The parents of static scheduler descriptors may be other static scheduler descriptors or root descriptors. They compete with sibling nodes according to their parents' defined scheduler algorithm and their scheduler<br><br>
metrics. Static scheduler descriptors are configured during system initialisation and exist in perpetuity. During operation, the system management controller 130 maintains the scheduler metrics according to the selected scheduling algorithm, for example Round Robin scheduling.<br>
Dynamic Scheduler Descriptors exist beneath root and possibly static nodes in the scheduling hierarchy. The parents of dynamic scheduler descriptors may be either static scheduler descriptors or root descriptors. They compete with sibling nodes according to their parents1 defined scheduler algorithm and their own scheduler metrics. Dynamic Scheduler descriptors may be configured at any time and may be retired under specific circumstances. This enables the system to support a far higher number of scheduling tiers than would be possible with a purely static provision. The system management controller 130 achieves this by capitalising on the likelihood that, although over all time a large number and diversity of threads and dynamic scheduler tiers are used, during a finite period, the transient demand is smaller. For example, in a networking system with attached memory supporting a maximum of 4000 dynamic elements (threads and dynamic scheduler descriptors) it may be possible to support 16000 connections as at any instant in time, dataunits from only a fraction of the overall connection space will be resident in the controller. This flexibility is achieved with a small penalty in performance, since, if a dynamic scheduler descriptor is not present, it must be created prior to the addition of child thread descriptors.<br>
During operation, the system management controller 130 maintains the scheduler metrics according to the selected scheduling algorithm. Under certain circumstances the dynamic scheduler descriptors will be released back to the controller memory element 195 free list. This is achieved by storing the pReference from the last thread to be processed within that tier within the dynamic scheduler tier descriptor. The controller 130 API supports the interrogation of controller memory elements 195 to determine whether a dynamic scheduler descriptor has persisted between subsequent similar threads.<br><br>
Dispatch Queues<br>
Dispatch queues hold scheduled thread descriptors in a First In First Out (FIFO) queue awaiting service from the associated processing resource 150. A maximum of 32 dispatch queues are allowed, in the currently preferred embodiment. Dispatch queues are defined by dispatch queue descriptors, shown in figure 9g and 9h. Dispatch queue descriptors are configured during system initialisation.<br>
The process of transitioning a thread descriptor from a Ready queue structure to a dispatch queue structure is performed in hardware and requires no controller 130 API interaction.<br>
Figure 17 shows an exemplary embodiment of a typical single dispatch queue structure embodying features of the present invention. The Dispatch queue descriptor defines a full threshold. A dispatch queue length is only allowed to exceed the full threshold where a thread bundle is being scheduled or a preempted thread push is taking place.<br>
Elements are removed from the dispatch queue via a pop operation called through the controller 130 API by a processing resource.<br>
A priority field is included in the dispatch queue descriptor. When a thread is popped from the dispatch queue, the priority field is populated with the priority of the now-executing thread. A further API call enables the priority to be reset to another value by the executing processor, in order to avoid priority inversions. Priority inversion involves at least 3 threads of differing priority and describes a conflict between synchronisation and scheduling requirements. Priority inversion allows a lower priority thread to block a higher priority thread indefinitely. For example, a low priority thread locks a shared resource, and is then pre-empted by a higher priority thread. The higher priority thread then blocks on the resource that is locked by the low priority thread. Since the high priority thread is now blocked, normally the low priority thread would resume, were it not for the third medium thread, which is independent of the locked resource and is now free to run. The low priority thread never gets the<br><br>
opportunity to unlock the shared resource and therefore the high priority thread is blocked indefinitely. "Priority ceiling" protocol means that while a thread owns a shared resource, it runs at a specified priority. This ensures that the "low" priority thread as defined above, assumes a "high" priority whilst it owns the resource shared with the high priority thread.<br>
Thread bundles describe a group of thread descriptors that originate from the same scheduler tier. A parameter is present in each scheduler descriptor defining the number of threads that may be transitioned from that tier of the ready queue to the dispatch queue before the scheduling decision is forced to update. By making use of this capability, and arranging that members of scheduler tiers share commonality, the processing resources 150 can be presented with blocks of threads that exhibit significantly higher cache locality than would otherwise be observed, resulting in a reduction in cache-misses and an increase in system performance.<br>
Figure 18 shows an exemplary two tier scheduling hierarchy, including thread bundling, according to an embodiment of the invention. The tier furthest from the root tier, the child tier, is using a FIFO scheduling algorithm. The root tier scheduler algorithm is configured as a round robin. In the embodiment, elements within each of the FIFO queues exhibit high levels of cache locality with other members of the same queue.<br>
Figure 18(a) shows the scheduling results where the child tiers thread bundle limit is set to 1. The results are perfectly interleaved. This scheme presents minimum latency to each queue; however, it is the least memory conscious (i.e. the most likely to exhibit poor cache performance). Context switches are necessary after each scheduled thread. Should the root tier be associated with a processing resource 150 that uses caches, compulsory cache misses could impact system performance.<br>
Figure 18(b) shows the scheduling results where the child tiers thread bundle limit is set to 4. The scheduler exhibits a courser grain update characteristic, which manifests itself as blocks of threads being scheduled from the same<br><br>
queues with a limit set by the thread bundle limit. Although this bursty behaviour may not be ideal in some circumstances, it exhibits a far better cache performance, as contexts switches are required comparatively infrequently. The resultant effect emulates the superior cache performance of a coarse grain multithreading whilst maintaining the superior programming model of the fine-grained approach.<br>
It is likely that the bursty nature of thread bundling will be most undesirable where the system interacts with the outside world. However, thread bundling is only a benefit where the target processing resource 150 uses caches, therefore specialist processing resources 150, that interact with the outside world, for example an IO device, are unlikely to use cache technology and therefore will not make use of thread bundling.<br>
Returning to figure 17, elements are removed from the dispatch queue via a pop operation called through the controller 130 API by a processing resource 150. Elements may be pushed back onto the ready queue in the event of preemption.<br>
A priority field is included in the dispatch queue descriptor that enables implementation of the priority ceiling protocol, preventing priority inversions with shared data. Each processing resource 150 has a unique dispatch queue.<br>
Scheduling<br>
The requirements of scheduling for applications and systems vary widely and, indeed, may only become clear after testing in real operating environments. To accommodate this, the system management controller 130 delivers flexibility in both scheduling policy and the scheduling algorithms used, which may be modified and tuned throughout the multicore processor design phase.<br>
Scheduling policies may be split into three types:<br>
1.       A cooperative scheduler relies on currently executing tasks to release<br>
the processing resource 150 prior to scheduling a new one. Although this<br><br>
type of system is consistent with minimisation of cold-cache effects (e.g. where the cache local to the processing resource 150 does not contain the required instruction, therefore must load the missing instruction in from a slower higher level memory), and fixed-function hardware accelerators it may not be suitable for more complex embedded applications.<br>
2.	A static algorithm-driven scheduler can pre-empt the currently<br>
executing task in order to execute a task of higher eligibility. The most eligible<br>
thread, according to pre-defined scheduling parameters and algorithms, is<br>
always the executing thread in these systems. The eligibility of any given task<br>
is fixed before the system begins execution.<br>
3.	A dynamic algorithm -driven scheduler can redefine eligibilities at run<br>
time. As before, the currently running process is still of the highest eligibility,<br>
but the eligibility metrics may have been changed since the task commenced<br>
execution.<br>
The system management controller 130 caters for all three scheduling policies via appropriate configuration and run-time interaction with the target application.<br>
The system management controller 130 supports many scheduling algorithms found within both the operating system and communications communities. For example, first in first out queuing, priority queuing or weighted fair queuing. An appropriate choice of scheduling algorithm will exhibit demonstrable advantages, particularly where subjective quality metrics are involved.<br>
Two scheduler metrics are provided within thread descriptors to support the scheduling behaviour within the system management controller 130. The first represents the priority of the thread in all cases and is used within a pending queue structure, priority based schedulers and a dispatch queue structure. Where necessary, the second is used to select between the individual thread and its peers. Furthermore either metric may be used to update metrics within the parent descriptor. The value placed within the second primitive of a thread descriptor must reflect the types of scheduling encountered in its scheduler hierarchy.<br><br>
These two scheduler metrics are used in both the scheduler descriptors, and the thread descriptors. However, although thread metrics are calculated within the processing resources 150, this is not possible for scheduler tiers. Consequently, sufficient parameters must be passed from a given tier's scheduled thread to enable the scheduler tier to update its own metric. A set of instructions is defined for each scheduler tier which define how the metrics are propagated from child to parent.<br>
With some attention to the overall scheduler hierarchy, complex combinations of scheduler algorithms may be easily created to provide sophisticated traffic and task management capabilities in application systems.<br>
Parameter Inheritance Example<br>
Figure 19 shows an exemplary embodiment of a simplified queue structure that might commonly be found in a communications system. The structure represents an output queue for an IO device. All threads sharing a FIFO queue are on the same connection, so this is a per connection queuing structure. The second scheduling tier uses a weighted fair queuing (WFQ) algorithm in this example. This algorithm calculates the finish time of a given task based on its length and a weighting factor. It then selects the packet with the earliest finish time. Although WFQ is reliant on knowledge of the length of the packet that the thread represents, the initial FIFO queue is independent of this information. In this case, the application programmer must ensure that the length of the packet is present in the scheduler metrics for each thread. Scheduler tiers higher in the hierarchy inherit this parameter for their own scheduling algorithms.<br><br>
For WFQ the following variables are required:<br>
P	- Fraction of pipe bandwidth allocated to the connection<br>
I	- Length of packet<br>
B	- Overall pipe bandwidth<br>
c	- Connection bandwidth<br>
d	- Scheduler tier deadline<br>
The equation for calculating the connection bandwidth, c, is:<br>
P*B=c<br>
If we normalise the channel to a bandwidth of 1, then p becomes equal to c.<br>
The finish time of the processing of the packet, t, is then given by:<br><br>
The metrics required are then 1/p and /. Since p was originally a fraction, both (1/p and I) of these values are integers. The length of the scheduled packet is passed up through the scheduler hierarchy, progressively updating the tier's deadline. In full, the calculation performed within each update is:<br><br>
Where d and 1/p (the weight) are stored within the scheduler tier descriptor and I is passed through the hierarchy during a schedule update. This calculation is performed within the scheduler manager 330.<br>
Whilst a specific embodiment of the invention has been described, it is to be understood that this is by way of example only and that various modifications may be considered. Moreover, the invention is of general application in any device or application that employs a multicore processor, such as, but not limited to, a mobile telephone or voice over Internet Protocol (VoIP) for example. Therefore, the specific embodiment is not to be seen as limiting of the scope of protection which is to be determined by the following claims.<br><br><br><br>
CLAIMS:<br>
1.	A resource management and task allocation controller for installation in<br>
a multicore processor having a plurality of interconnected processor elements<br>
providing resources for processing executable transactions, at least one of<br>
said elements being a master processing unit;<br>
the controller being adapted to communicate, when installed, with each of the processor elements including the master processing unit, and comprising control logic for allocating executable transactions within the multicore processor to particular processor elements in accordance with predefined allocation parameters.<br>
2.	The controller of claim 1, wherein the range of predefined allocation<br>
parameters included within the control logic of the controller contains a<br>
plurality of transaction scheduling rules, for scheduling the timing and/or order<br>
of execution of the executable transactions by the processor elements.<br>
3.	The controller of claim 1 or claim 2, wherein the range of predefined<br>
allocation parameters included within the control logic of the controller<br>
contains a plurality of system management rules, for controlling the manner in<br>
which the executable transactions are executed by the processor elements.<br>
4.	The controller of claim 2 or claim 3, further configured to generate<br>
instructions for communication to the processing elements.<br>
5.	The controller of claim 4, configured to send a processor element<br>
configuration instruction to a processor element, which causes the said<br>
processor element in turn to be adapted so as to permit subsequent execution<br>
of an executable transaction allocated to that processor element by the<br>
controller.<br>
6.	The controller of claim 4 or claim 5, configured to generate instructions<br>
by the transmission of one or more interrupts to the processor elements.<br><br>
7.	The controller of claim 4 or claim 5, configured to generate instructions<br>
by the transmission of one or more polls to the processor elements.<br>
8.	The controller of any preceding claim, wherein said control logic further<br>
comprises:<br>
an executable transaction manager; and;<br>
a dedicated memory manager;<br>
wherein the said dedicated memory manager controls access by the executable transaction manager to the dedicated memory.<br>
9.	The controller of claim 8, wherein the executable transaction manager<br>
further comprises an executable transaction input manager, configured to<br>
maintain an indication of available memory within the dedicated memory.<br>
10.	The controller of claim 9, wherein the executable transaction manager<br>
input is configured to maintain a list of available memory locations within the<br>
dedicated memory.<br>
11.	The controller of claim 10, wherein the executable transaction input<br>
manager maintains the indication of available memory as a result of updated<br>
instructions from the dedicated memory manager.<br>
12.	The controller of any preceding claim, wherein the executable<br>
transaction to be allocated include threads, each of which form part of an<br>
application being executed upon the multicore processor, wherein at least<br>
some of the threads are independent threads capable of execution<br>
independently of other events, and wherein at least some of the threads are<br>
dependent threads, whose execution is dependent upon the existence of a<br>
predetermined event.<br>
13.	The controller of claim 12, wherein the control logic further comprises a<br>
time manager configured to provide timer functions to said executable<br>
transaction manager.<br><br>
14.	The controller of claim 13, wherein the predetermined event is a timing<br>
event.<br>
15.	The controller of claim 12, wherein the predetermined event is the<br>
completion of the execution of a previous thread, or pre-emption by another<br>
more eligible thread.<br>
16.	The controller of claim 12, wherein the executable transaction manager<br>
further comprises an executable transaction synchronisation manager,<br>
configured to maintain at least one pending queue list within the dedicated<br>
memory, indicative of dependent threads awaiting the occurrence of a<br>
predetermined event, and at least one timer queue list within the dedicated<br>
memory, indicative of threads awaiting a timing event.<br>
17.	The controller of claim 16, wherein the executable transaction manager<br>
further comprises an executable transaction output manager configured to<br>
maintain a plurality of dispatch queue structures within the dedicated memory,<br>
indicative of the threads awaiting execution on an associated one of the<br>
processor elements, and to maintain a plurality of ready queue structures<br>
within the dedicated memory, indicative of threads awaiting allocation to a one<br>
of the processor elements for execution there.<br>
18.	The controller of claim 17, wherein the executable transaction manager<br>
further comprises an executable transaction schedule manager, configured to<br>
provide and maintain scheduling decisions for prioritising the dispatch of<br>
threads from within the ready queues to the dispatch queue for each<br>
processor element.<br>
19.	The controller of any preceding claim, wherein the control logic further<br>
comprises a system interface manager, in communication with the executable<br>
transaction manager, and configured to manage access by the controller to<br>
the multicore processor.<br><br>
20.	The controller of claim 19, wherein the system interface manager is<br>
arranged to provide interconnect interfacing and configuration and run-time<br>
access to said executable transaction manager.<br>
21.	The controller of claim 6, wherein the control logic further comprises a<br>
system interrupt manager, for converting system interrupts in a first format<br>
employed within the multicore processor, into controller interrupts in a second,<br>
different format, which second format is understandable by the executable<br>
transaction manager.<br>
22.	A multicore processor comprising the controller of any preceding claim,<br>
the multicore processor having a plurality of interconnected processor<br>
elements, each of which has an associated controller client, wherein each<br>
controller client is configured to control communications between the said<br>
processing element and the rest of the multicore processor, dependent upon<br>
control signals from the controller.<br>
23.	A multicore processor comprising the controller of any preceding claim,<br>
the multicore processor having a plurality of interconnected processor<br>
elements, and at least one an controller client, wherein the controller client is<br>
configured to control communications between the said processing elements<br>
and the rest of the multicore processor, dependent upon control signals from<br>
the controller.<br>
24.	The multicore processor of claim 22, further comprising a shared<br>
system interconnect accessible by both the controller and the plurality of<br>
interconnected processor elements.<br>
25.	The processor of claim 24, further comprising an external interface, for<br>
connecting said multicore processor to one or more external devices.<br>
26.	A multicore processor as claimed in any of claims 22 to 25, further<br>
comprising a dedicated memory in communication with the controller.<br><br>
27.	The multicore processor of claim 26, wherein the dedicated memory is<br>
exclusively accessible by the controller.<br>
28.	The multicore processor of claim 22, wherein the dedicated memory is<br>
accessible by both the controller and by at least one further component of the<br>
multicore processor.<br>
29.	The multicore processor of any of claims 22 to 27, wherein the memory<br>
comprises a plurality of individual memory elements.<br>
30.	The multicore processor of claim 29, wherein the number of individual<br>
memory elements is user definable.<br>
31.	The multicore processor of claim 30, wherein each memory element is<br>
of a similar size and the user definable number of memory elements results in<br>
a variable memory size.<br>
32.	The multicore processor of claim 22, wherein the controller client is a<br>
software application running on the associated processor element.<br>
33.	The multicore processor of claim 22, wherein the controller client is a<br>
hardware controller client, dependent on the functionality of the associated<br>
processor element.<br>
34.	The multicore processor of claim 33, wherein the controller client<br>
further comprises a client control logic, for controlling the associated<br>
processor element, upon activation by a control signal from the said controller.<br>
35.	The multicore processor of claim 34, wherein the controller client<br>
further comprises a plurality of buffers, for temporary storage of<br>
communication messages sent between the said processor element and the<br>
rest of the multicore processor.<br><br>
36      The multicore processor of claim 35, wherein the plurality of buffers are first in first out buffers.<br>
37.	The multicore processor of claim 35, wherein the controller client<br>
further comprises a plurality of memory elements, each configured to store an<br>
address.<br>
38.	The multicore processor of claim 37, wherein the controller client<br>
further comprises a plurality of comparators, each comparator configured to<br>
compare an address generated by the associated processor element with an<br>
address stored in a one of the memory elements.<br>
39.	The multicore processor of claim 37, wherein the controller client<br>
further comprises a subtracter, configured to subtract an address stored in a<br>
one of the memory elements from an address generated by the associated<br>
processor element.<br>
40.	A method of controlling and allocating resources within a multicore<br>
processor having a plurality of processor elements, at least one of which is a<br>
master processing unit, comprising the steps of:<br>
receiving an executable transaction at a resource management and task allocation controller separate from the master processor unit; and<br>
allocating that executable transaction to a one of the processor elements independently of central processing unit control.<br>
41.	The method of claim 40, further comprising:<br>
directing the executable transaction to a one of the processor elements via a transaction management client.<br>
42.	The method of claim 41, wherein the transaction management client is<br>
a hardware client.<br>
43.	The method of claim 41, wherein the transaction management client is<br>
a software client.<br><br>
44.	The method of claim 42, further comprising storing a predetermined<br>
address within the transaction management client.<br>
45.	The method of claim 44, further comprising: at the transaction<br>
management client, subtracting the predetermined address from an address<br>
generated by the associated processing element to produce a normalised<br>
address.<br>
46.	The method of claim 44, further comprising, at the transaction<br>
management client, comparing an address generated by the associated<br>
processor element with the stored predetermined address; and<br>
configuring the processor element dependent on the result of the comparison.<br>
47.	The method of claim 42, further comprising, at the transaction<br>
management client, storing the whole of a communication message from the<br>
rest of the multicore processor to the associated processor element; and<br>
subsequently passing the whole message to the associated processor element.<br>
48.	The method of claim 42, further comprising, at the transaction<br>
management client, streaming communication messages from the rest of the<br>
multicore processor to the associated processor element.<br>
49.	The method of claim 41, further comprising creating, executing or<br>
deleting an executable transaction for a first transaction management client,<br>
with a second transaction management client.<br>
50.	The method of any of claims 40 to 49, further comprising allocating the<br>
executable transaction to a one of the processing elements based upon a pre<br>
defined set of scheduling parameters.<br><br>
51.	The method of claim 50, wherein the set of scheduling parameters is<br>
user-definable.<br>
52.	The method of claim 50 or claim 51, further comprising:<br>
monitoring a list of the scheduling parameters for use by the controller.<br>
53.	The method of any of claims 50 to 52, further comprising altering the<br>
set of scheduling parameters over time.<br>
54.	The method of claim 52, wherein the step of maintaining the list of the<br>
scheduling parameters further comprises maintaining a list of ready tasks that<br>
may be carried out by one or more of the processor elements.<br>
55.	The method of any of claims 50 to 53, further comprising allocating the<br>
executable transaction to a one of the processing elements on the basis of the<br>
requirement to balance processor resources within the multicore processor.<br>
56.	The method of any of claims 50 to 53, further comprising preventing<br>
the allocation of the executable transaction to a one of the processor<br>
elements, when it is determined that it is desirable for that processor element<br>
to execute a higher priority task.<br>
57.	The method of any of claims 40 to 56, further comprising:<br>
maintaining a list of executable transactions that have not been<br>
allocated for longer that a predetermined length of time.<br>
58.	The method of claim 52, wherein the step of monitoring the list of the<br>
scheduling parameters further comprises maintaining a list of pending tasks<br>
that are awaiting a predetermined event.<br>
59.	The method of claim 58, wherein the predetermined event is a timer<br>
event, a synchronisation event or both.<br><br>
60.	The method of claim 58, further comprising maintaining a plurality of<br>
lists of pending tasks, according to mutually exclusive predetermined events.<br>
61.	The method of claim 52, wherein the step of monitoring the list of the<br>
scheduling parameters further comprises maintaining a list of dispatched<br>
tasks that are awaiting execution on a particular processing resource.<br>
62.	The method of claim 61, further comprising the step of moving a<br>
executable transaction awaiting a predetermined event to the ready queue, on<br>
expiration of a timeout.<br>
63.	The method of any of claims 40 to 62 wherein the controller is<br>
exclusively dedicated to the allocation of tasks.<br>
Dated this 27 day of September 2pO6<br><br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgQU1FTkRFRCBDTEFJTVMgIDA1LTA3LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   AMENDED CLAIMS  05-07-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgQVNTSUdOTUVOVCAgMDktMDUtMjAxMy5wZGY=" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   ASSIGNMENT  09-05-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgQ09SUkVTUE9OREVOQ0UgT1RIRVJTICAwOS0wNS0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   CORRESPONDENCE OTHERS  09-05-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgQ09SUkVTUE9OREVOQ0UgT1RIRVJTIDA1LTA3LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   CORRESPONDENCE OTHERS 05-07-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgQ09SUkVTUE9OREVOQ0UgT1RIRVJTIDEwLTA0LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   CORRESPONDENCE OTHERS 10-04-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgQ09SUkVTUE9OREVOQ0UgT1RIRVJTIDEwLTA1LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   CORRESPONDENCE OTHERS 10-05-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgQ09SUkVTUE9OREVOQ0UgT1RIRVJTIDI1LTA2LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   CORRESPONDENCE OTHERS 25-06-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgRVhBTUlOQVRJT04gUkVQT1JUIFJFUExZIFJFQ0VJVkVEIDA2LTEyLTIwMTIucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   EXAMINATION REPORT REPLY RECEIVED 06-12-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgRk9STS0xIDEwLTA1LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   FORM-1 10-05-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgRk9STS0xMyAgMDgtMDMtMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   FORM-13  08-03-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgRk9STS0xMyAgMDktMDUtMjAxMy5wZGY=" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   FORM-13  09-05-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgRk9STS0zICAxMC0wNS0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   FORM-3  10-05-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgRk9STS02ICAwOS0wNS0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   FORM-6  09-05-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgUE9XRVIgT0YgQVRUT1JORVkgIDA4LTAzLTIwMTIucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   POWER OF ATTORNEY  08-03-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICAgUE9XRVIgT0YgQVRUT1JORVkgIDA5LTA1LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006   POWER OF ATTORNEY  09-05-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBBTUVOREVEICBQQUdFUyBPRiBTUEVDSUZJQ0FUSU9OICAxMC0wNS0yMDEzLnBkZg==" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  AMENDED  PAGES OF SPECIFICATION  10-05-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBBTUVOREVEIENMQUlNUyAgMDYtMTItMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  AMENDED CLAIMS  06-12-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBBTUVOREVEIENMQUlNUyAgMTAtMDQtMjAxMy5wZGY=" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  AMENDED CLAIMS  10-04-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBBTUVOREVEIENMQUlNUyAgMTAtMDUtMjAxMy5wZGY=" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  AMENDED CLAIMS  10-05-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBBU1NJR05NRU5ULnBkZg==" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  ASSIGNMENT.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBDT1JSRVNQT05ERU5DRSBPVEhFUlMgIDEyLTA2LTIwMTIucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  CORRESPONDENCE OTHERS  12-06-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBDT1JSRVNQT05ERU5DRSBPVEhFUlMgMDgtMDMtMjAxMi5wZGY=" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  CORRESPONDENCE OTHERS 08-03-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBFTkdMSVNIIFRSQU5TTEFUSU9OICAwNi0xMi0yMDEyLnBkZg==" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  ENGLISH TRANSLATION  06-12-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBGT1JNLTEucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  FORM-1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBGT1JNLTE4LnBkZg==" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  FORM-18.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBGT1JNLTIucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  FORM-2.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBGT1JNLTMgIDA2LTEyLTIwMTIucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  FORM-3  06-12-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBGT1JNLTMgIDEwLTA0LTIwMTMucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  FORM-3  10-04-2013.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBGT1JNLTYgIDIzLTAzLTIwMDkucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  FORM-6  23-03-2009.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBPVEhFUiBQQVRFTlQgRE9DVU1FTlQgIDA2LTEyLTIwMTIucGRm" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  OTHER PATENT DOCUMENT  06-12-2012.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1DSEVOUC0yMDA2ICBQT1dFUiBPRiBBVFRPUk5FWS5wZGY=" target="_blank" style="word-wrap:break-word;">3568-CHENP-2006  POWER OF ATTORNEY.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1jaGVucC0yMDA2LWFic3RyYWN0LnBkZg==" target="_blank" style="word-wrap:break-word;">3568-chenp-2006-abstract.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1jaGVucC0yMDA2LWNsYWltcy5wZGY=" target="_blank" style="word-wrap:break-word;">3568-chenp-2006-claims.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1jaGVucC0yMDA2LWNvcnJlc3BvbmRuZWNlLW90aGVycy5wZGY=" target="_blank" style="word-wrap:break-word;">3568-chenp-2006-correspondnece-others.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1jaGVucC0yMDA2LWRlc2NyaXB0aW9uKGNvbXBsZXRlKS5wZGY=" target="_blank" style="word-wrap:break-word;">3568-chenp-2006-description(complete).pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1jaGVucC0yMDA2LWRyYXdpbmdzLnBkZg==" target="_blank" style="word-wrap:break-word;">3568-chenp-2006-drawings.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1jaGVucC0yMDA2LWZvcm0gMS5wZGY=" target="_blank" style="word-wrap:break-word;">3568-chenp-2006-form 1.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1jaGVucC0yMDA2LWZvcm0gMy5wZGY=" target="_blank" style="word-wrap:break-word;">3568-chenp-2006-form 3.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1jaGVucC0yMDA2LWZvcm0gNS5wZGY=" target="_blank" style="word-wrap:break-word;">3568-chenp-2006-form 5.pdf</a></p>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/pdfviewer.aspx?AppNo=MzU2OC1jaGVucC0yMDA2LXBjdC5wZGY=" target="_blank" style="word-wrap:break-word;">3568-chenp-2006-pct.pdf</a></p>
		<br>
		<div class="pull-left">
			<a href="256686-phthalamide-derivative-agricultural-or-horticultural-pesticide-and-use-of-the-pesticide.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="256688-a-device-to-run-a-two-stroke-internal-combustion-engine.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>256687</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>3568/CHENP/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>29/2013</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>19-Jul-2013</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>16-Jul-2013</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>27-Sep-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>FUJITSU SEMICONDUCTOR LIMITED</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>2-10-23 SHIN-YOKOHAMA, KOHOKU-KU YOKOHAMA-SHI, KANAGAWA 222-0033</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>LIPPET, MARK, DAVID</td>
											<td>18 STONER GREEN, WATLINGTON, OXFORDSHIRE OX49 5PT</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 9/38</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/GB05/01154</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2005-03-30</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>0407384.7</td>
									<td>2004-03-31</td>
								    <td>U.K.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/256687-resource-management-in-a-multicore-architecture by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 09:16:43 GMT -->
</html>
