<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/223373-integrating-tablespaces-with-different-block-sizes by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 06:04:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 223373:INTEGRATING TABLESPACES WITH DIFFERENT BLOCK SIZES.</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">INTEGRATING TABLESPACES WITH DIFFERENT BLOCK SIZES.</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>A computer-readable medium carrying one or more sequences of instructions to perform the said method comprising the steps of: a first database system (101) directly storing first database rows (130-1, 130-2) in first data blocks (392) having a first data block size (A); concurrently with said first database system (101) directly storing first database rows (130-1, 130-2) in first data blocks (392) having a first data block size (A), said first database system (101) directly accessing a copy of second data blocks (394) in which a second database system (110) directly stored second database rows (140-1, 140-2); said second data blocks (394) having at least one data block with a second data block size (B) different than said first data block size (A); and wherein each block of said first data blocks (392) and of said second data blocks (394) is an unit of storage space (190) allocated within a file (332) to store one or more rows (130, 140) of a database.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>FIELD OF THE INVENTION<br>
The present invention relates to a computer-readable medium carrying one or<br>
more sequences of instructions to perform the said method.<br>
BACKGROUND OF THE INVENTION<br>
The ability to store and retrieve large amounts of data are some of the most<br>
important functions of computers in today's society. To carry out these functions,<br>
database systems are typically used to retrieve and store data in databases. Database<br>
systems have performed these functions very successfully, creating for society the ability<br>
to retrieve data at speeds and quantities previously unimagined, and bestowing onto<br>
society an unprecedented level of access to information. The success of database<br>
systems has unleashed an insatiable demand for even faster and more efficient database<br>
systems that process even greater quantities of data.<br>
One mechanism that provides efficient access to large amounts of data is a data<br>
warehouse. A data warehouse represents a transformation of raw data. The raw data<br>
used by the ware house typically comes from a "source" database system, such as an<br>
online transaction processing ("OLTP") database. The OLTP database system is oriented<br>
towards the "real time" operation of a business, while the data warehouse is oriented<br>
toward answering longer range, management oriented, questions about the business. To<br>
stay current, the data warehouse house is periodically updated with information from the<br>
OLTP database system. These updates entail transfers of large quantities of data.<br>
A conventional technique for transferring data is the command generation<br>
technique. Under the command generation technique, an "exporting" database system<br>
generates a file of insert commands. The insert commands conform to a database<br>
language, such as the structured query language ("SQL"). For each record being<br>
exported, an insert command specifies the creation of a record with the values needed to<br>
generate a copy of the record being exported. To import the data, an "importing" database<br>
system, which is capable of executing commands written in the database language,<br>
scans the file, executing each insert command.<br>
Executing an insert command for each record to export is typically a slow process,<br>
one which may span days for larger databases. While data is being exported, access to<br>
the data is restricted. Consequently, the database user, who requires access to the data,<br>
may be significantly impacted. Thus, conventional techniques for exporting data may be<br>
significantly burdensome.<br>
Another conventional technique for moving data into a data warehouse involves<br>
the use of tools available in applications used to manage data warehouses. These tools<br>
transfer data between a source database and a data warehouse using a process that has<br>
three stages: extracting data from the source database system, transforming the extracted<br>
data, and loading the transformed data into the data warehouse. These stages are referred<br>
to collectively as ETL, which stands for extraction, transformation, and loading. In<br>
general, ETL tools extract data from a source database system by issuing queries to the<br>
source database system to retrieve data. ETL tools load data in the data warehouse by<br>
issuing insert commands to the data warehouse to load the data retrieved from the source<br>
database system. While the use of ETL tools may be more efficient than the command<br>
generation technique, the process of transferring data may still require undesirably long<br>
periods of time.<br>
A novel technique that is much more efficient than the conventional techniques<br>
for transferring data is referred to as transportable tablespaces. A tablespace is a<br>
collection of storage containers (e.g. data files) used to store data for database objects.<br>
Database objects are objects managed by a database system. Transportable tablespaces is<br>
a technique that allows tablespaces to be copied and integrated into another database<br>
system, or in other words, "plugged into" the other database system. This capability<br>
allows data to be copied using operating system utilities for copying files, which run<br>
much faster than the process of extracting and loading data by executing queries and<br>
insert statements.<br>
Unfortunately, it is not always possible to plug in a tablespace from one database<br>
system to another because the database systems may not be configured to handle the same<br>
data block size. A data block is an/atomic unit of storage space allocated to store one or<br>
more database records (e.g. rows). Typically, a database system is configured to operate<br>
upon a database composed of data blocks of one particular size. In some systems, the<br>
particular size may be configured by a user when a database is created. Once a database is<br>
created, however, the data block size may not be changed. Consequently, a tablespace<br>
composed of data blocks of a given size may not be plugged into a database svstem that<br>
expects data blocks of a different block size.<br>
It is possible to overcome this limitation by managing the data block sizes of both<br>
the data warehouse and its source database systems. The source database" system and the<br>
data warehouse may be configure for the same data block size. However, for purposes of<br>
efficiency, it is usually desirable to have larger block sizes for data warehouses and<br>
smaller block sizes for OLTP systems. For this reason, data warehouses typically have<br>
larger block sizes than OLTP systems.<br>
Based on the foregoing, it is clearly desirable to provide a mechanism that allows<br>
a tablespace or any collection of data blocks of a given size to be plugged into a database<br>
system that operates on data blocks of a different size.<br>
SUMMARY OF THE INVENTION<br>
Described herein is a mechanism that allows a given database system to access<br>
data blocks from another database system, where the data blocks from the given database<br>
system and data blocks from the other database system have different sizes. According to<br>
an aspect of the present invention, the data blocks in the other database system are<br>
contained in a tablespace. The tablespace is detached from the other database system and<br>
integrated into the given database, which is capable of processing data stored in data<br>
blocks of different sizes.<br>
BRIEF DESCRIPTION OF THE DRAWINGS<br>
The present invention is illustrated by way of example, and not by way of<br>
limitation, in the figures of the accompanying drawings and in which like reference<br>
numerals refer to similar elements and in which:<br>
Fig. 1 is a block diagram of a database system used to illustrate an embodiment of<br>
the present invention;<br>
Fig. 2 is a block diagram of tablespaces and data structures used to support a<br>
relative addressing scheme according to an embodiment of the present invention;<br>
Fig. 3 is a block diagram of structures used to support a buffer cache system that<br>
handles multiple size data blocks according to an embodiment of the present invention;<br>
Fig. 4 is a flow chart depicting a process for integrating a tablespace into a<br>
database system, where data blocks in the tablespace and data blocks in the database<br>
system have different block sizes according to an embodiment of the present invention;<br>
and<br>
Fig. 5 is a block diagram depicting a computer system that may be used to<br>
implement an embodiment of the present invention.<br>
DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT<br>
A method and apparatus for transferring data between databases is described. In<br>
the following description, for the purposes of explanation, numerous specific details are<br>
set forth in order to provide a thorough understanding of the present invention. It will be<br>
apparent, however, to one skilled in the art that the present invention may be practiced<br>
without these specific details. In other instances, well-known structures and devices are<br>
shown in block diagram form in order to avoid unnecessarily obscuring the present<br>
invention.<br>
Described herein is a mechanism that allows a given database system to access<br>
data blocks from another database system, where data blocks from the given database<br>
system and data blocks from the other database system have different sizes. According to<br>
an embodiment of the present invention, the techniques involve the use of a database<br>
system that handles databases with data blocks that have different sizes. These techniques<br>
are illustrated using an exemplary database system.<br>
EXEMPLARY DATABASE SYSTEM<br>
Fig. 1 is a block diagram that provides an overview of an exemplary database<br>
system used to illustrate an embodiment of the present invention. Database system 101<br>
processes and stores data in database objects. Database objects are objects managed by a<br>
database system for the purpose of storing, retrieving, and processing data. Examples of<br>
database objects include tables, indexes, and code modules which may be executed by a<br>
database system. Typically, the database objects are stored in static storage, in one or<br>
more data blocks in a data file.<br>
Database system 101 performs operations to data in a database object by<br>
performing operations on data blocks that hold the data. Operations on data blocks<br>
are carried out on copies of data blocks read into buffer cache 190 from static<br>
storage. Copies of the data blocks are stored in buffers in the buffer cache 190. The<br>
buffers are shared by all user processes concurrently connected to database system<br>
101. A copy of a data block is loaded into buffer cache 190 whenever database<br>
system 101 performs an operation involving a data item stored in the data block,<br>
such as a row in a table. If the operation changes the data item, the change is made<br>
to the copy of the data block stored in buffer cache 190. Afterwards, a database<br>
writer writes the modified blocks of data from buffer cache 190 to the data files on<br>
disk.<br>
Data for a particular set of database objects may be stored in space allocated from<br>
one or more tablespaces, such as tablespaces 130, 140, and 150. A tablespace is a<br>
collection of storage containers (e.g. data files) used to store data for database objects. For<br>
example, tablespace 130 contains data files 130-1 to 130-4. A database object may be<br>
referred to as being in a particular tablespace when the tablespace holds data for the<br>
database object.<br>
Database metadata 110 is metadata that describes the configuration of a database<br>
system. Database metadata 110 defines, for example, database objects (e.g. tables and<br>
indexes for tables), tablespaces, and what tablespaces to use to store data for a table or<br>
index. Database metadata is generated in response to receiving data definition commands<br>
from a user. A user issues database commands to a database system to modify the<br>
configuration of a database system to define, for example, the database objects in the<br>
database system, the attributes of database objects, and the tablespaces that hold data for<br>
the database objects. Data definition commands must conform to a data definition<br>
language recognized by a database system, such as SQL.<br>
' Database system 101 may encounter problems that can halt the operation of a<br>
database or affect the writing of database information to disk. Common types of failures<br>
include process failures, involving a failure in a user, server, or background process of a<br>
database instance, or media failures, involving a physical problem reading or writing<br>
physical files needed for normal database operation. A major aspect of database operation<br>
and administration involves the recovery of the database from the various types of<br>
failures encountered.<br>
One mechanism that database system 101 uses to manage recovery from failures<br>
is a logging mechanism. A logging mechanism entails recording all changes made to a<br>
database system by maintaining a log for the database system. Several different operation<br>
logs are maintained to perform various database maintenance functions. Specifically, a<br>
redo log is used to store database operations so that the operations can be re-performed to<br>
restore the database to its pre-failure state after a failure. For example, when a<br>
transaction modifies data in the buffer cache 190, a redo entry that specifies the<br>
modification is stored in a redo log on disk. If a failure occurs before the updated data<br>
within the buffer cache has been stored to disk, the modified data in the buffer cache 190<br>
may be lost. Under these conditions, during the recovery process, the database may be<br>
modified to include the lost change based on the redo entry.<br>
The basic component of a log system is a group of one or more log files used to<br>
store redo and undo entries. Log files group 180 includes data files 150-1 to 150-4 in<br>
tablespace 150. Redo and undo entries store low-level representations of database<br>
changes. Redo entries contain the information necessary to redo changes made by data<br>
operations such as INSERT, UPDATE, DELETE, CREATE, ALTER, or DROP.<br>
Conversely, undo entries contain the information necessary to undo changes made by<br>
data operations. The redo or undo entries in the redo log file group in static storage are<br>
referred to as redo logs.<br>
USING TRANSPORTABLE TABLESPACES<br>
Transportable tablespaces refers to a technique for transferring data between<br>
database systems that is based on integrating copies of tablespaces from a "source<br>
database system" into a "target database system". Integrating a copy of a tablespace<br>
involves altering the database metadata of the target database by modifying or adding<br>
data to define the tablespace as any other tablespace used by the database system, as shall<br>
be described in greater detail. Examples of techniques for integrating tablespaces are<br>
described in Pluggable Tablespaces and Tablespace-Relative Database Pointers.<br>
The database metadata may be altered using a variety of techniques. Utilities<br>
available on the source database system may be executed to export the metadata into an<br>
"export control file", and utilities on the target database system may be executed to<br>
reconstruct metadata from the export control file. Alternately, exported metadata could be<br>
included with the data being transported in the tablespace, and the target database would<br>
reconstruct the metadata from the data included in the tablespace. A user could manually<br>
reconstruct the metadata on the target database system. Finally, utilities on the source<br>
database system could examine the data in the tablespaces to derive the metadata.<br>
The term "copy," as used herein, refers to both the source data and a duplicate of<br>
the source data. For example, a copy of a source data file may be the source data file<br>
itself, or another data file that is a duplicate generated using readily available copy<br>
utilities, such as operating system utilities for creating copies of data files.<br>
A tablespace may be integrated into a database by detaching the tablespace from<br>
the original source database or by creating a separate copy to integrate. While the copy is<br>
being made, operations on the tablespace should be restricted to read-only operations.<br>
If the copy of the tablespace to integrate is a detached source tablespace, then the<br>
source database may need to be configured so that the source database system no longer<br>
uses the tablespace to store data. Configuring the source database may entail altering<br>
database metadata in the source database system, by, for example, removing data defining<br>
the tablespace as part of the source database system, or setting a flag to indicate that the<br>
tablespace is no longer used.<br>
A reason a detached tablespace or a separate copy of it is integrated is that many<br>
database systems are not configured to directly access a data file concurrently with other<br>
database systems. The term "directly access" refers to accessing data in a data container,<br>
such as data in a data file, without having to request that another database system provide<br>
the data. An example of a database system directly accessing a data container is a<br>
database system running on a computer invoking an operating system function to access a<br>
data file residing on either a disk drive connected to a bus of the computer or a disk drive<br>
connected to a server coupled to the computer via a network. An example of not directly<br>
accessing a data file is issuing a query to another database requesting data from a table.<br>
REFERENCE SCHEMES FOR TRANSPORTABLE DATABASES<br>
A reference is data that indicates the location of a particular data item stored in a<br>
database. References are used by database systems in many scenarios. For example, a<br>
database system may use references in an index of a column of a table. The index maps<br>
values for the column to rows in the table containing those values. Each entry in the index<br>
maps a particular value to a row, and stores a reference to the location of the row.<br>
A reference for a data item may contain information identifying the particular data<br>
container that contains the data item. Such information may include a database-relative<br>
file number. A database-relative file number is a number used by a database system to<br>
uniquely identify a data file relative to any other data files used by the database system.<br>
For example, a reference to a particular data item, such as a row or an object, may include<br>
a data file number of the data file containing the data block holding the data item. In<br>
addition, the reference may include an offset into the file to identify a data block's<br>
location within the file.<br>
Unfortunately, transferring data files between database systems that use references<br>
based on database-relative file numbers creates complications. These complications stem<br>
from the fact that a database-relative file number may not be unique between database<br>
systems. A database-relative file number on one database system may be used to identify<br>
a different data file on another database system. This problem may be overcome by using<br>
several measures. First, data files transferred to another database system could be<br>
assigned new database-relative file numbers. Second, because the transferred data files<br>
may contain data objects with references holding database-relative file numbers, these<br>
references would have to be modified to reflect the newly assigned database-relative file<br>
numbers. For example, a set of data files is transferred from one database system to<br>
another database system. The data files are assigned new database-relative file numbers.<br>
The data files may hold a portion of a table and an index indexing rows in the table. The<br>
references in the index may contain database-relative file numbers that should be changed<br>
to reflect newly assigned database-relative file numbers.<br>
TABLESPACE RELATIVE ADDRESSING SCHEME<br>
The problem and measures attendant database-relative file numbers may be<br>
avoided by the use of a relative addressing scheme that addresses data files relative to the<br>
tablespace that contains the data file. The use of a relative addressing scheme also<br>
facilitates transportable tablespace processing, which as mentioned before, is a technique<br>
for transferring data between database systems using a process that includes moving or<br>
copying a tablespace. Examples of such techniques are described in Pluggable<br>
Tablespaces and Tablespace-Relative Database Pointers. Fig. 2 is a block diagram that<br>
depicts a relative addressing scheme used to illustrate an embodiment of the present<br>
invention. Fig. 2 illustrates identifiers used to identify tablespaces and data files, and the<br>
relationship between them, and other elements upon which the relative addressing scheme<br>
hinges.<br>
Referring to Fig. 2, database system 101 (not shown) associates tablespace<br>
numbers (TSNs) 9 and 8 with tablespaces 130 and 140, respectively. When database<br>
system 101 defines a tablespace, it associates a tablespace number with the tablespace.<br>
Within a given database system, a tablespace number uniquely identifies a tablespace.<br>
Within a tablespace, database system 101 associates a tablespace-relative file<br>
number (TRFN) with each data file in a tablespace. For a given data file in a tablespace, a<br>
tablespace-relative file number is unique relative to other data files in the tablespace, but<br>
not to other data files in other tablespaces. For tablespace 130, the tablespace-relative file<br>
numbers assigned to data files 130-1, 130-2, 130-3 and 130-4 are 1, 2, 3 and 4,<br>
respectively. For tablespace 140, the tablespace-relative file numbers assigned to data<br>
files 140-1, 140-2, 140-3 and 140-4 are 1, 2, 3 and 4, respectively.<br>
Database system 101 associates a control file with each tablespace. For each<br>
tablespace, the control file maps a tablespace-relative file number to a database-relative<br>
file number, and hence maps a data file within a tablespace to a database-relative file<br>
number. Control file 210 is associated with tablespace 130, while control file 220 is<br>
associated with tablespace 140. Control file 210 includes two fields: (1) tablespace-<br>
relative file number 212 ("TRFN 212") and database-relative file number (DRFN 214),<br>
(2) and entries 210-1 through 210-4, which each contain a value for TRFN 212 and<br>
DRFN 214. Entry 210-1 maps tablespace-relative file number '1' to database-relative file<br>
number '12'. Control file 220 is structured similarly relative to tablespace 140.<br>
Any data file in a tablespace can be identified by a tablespace number and a<br>
tablespace-relative file number. For example, a "data block pointer" in an index entry<br>
refers to the data block containing a particular row. The data block resides in data file<br>
130-1. The data block pointer contains the value '9' as the tablespace reference number<br>
and the value ' 1' as the tablespace-relative file number, thereby identifying tablespace<br>
130 and data file 130-1. The data file can be identified using the following procedure.<br>
Given the tablespace number and tablespace-relative file number, the control list<br>
associated with the tablespace-relative file number is accessed to find the database-<br>
relative file number mapped to the tablespace-relative file number. In control file 210,<br>
entry 210-4 maps the tablespace-relative file number '4' to database-relative file number<br>
42, which identifies data file 130-4.<br>
Transporting data files between database systems is not only facilitated by use of a<br>
relative addressing scheme, but also by use of self contained tablespaces. A set of<br>
tablespaces is self contained when there are no references to any data item in the set that<br>
refer to any data item outside the set. For example, if the tablespace holds data for an<br>
index of a table in another tablespace, then the tablespace is not self contained. If a set of<br>
tablespaces is not self-contained, several measures may be used to render the tables self<br>
contained. The data in the tablespace may be modified to make the set of tablespaces self<br>
contained. In addition, the makeup of the set of tablespaces can be modified by, for<br>
example, removing tablespaces from the set or adding additional tablespaces.<br>
Database metadata 110 stores data mapping tablespace numbers to tablespaces,<br>
data files to database-relative file numbers, and, for a particular tablespace, tablespace-<br>
relative file numbers to database-relative file numbers of data files. When database<br>
system 101 is configured to access a data file, database system 101 generates a new<br>
database-relative file number for the file and updates database metadata 110 accordingly.<br>
When database system 101 is configured to access a data file as part of a tablespace,<br>
database system 101 generates for the data file a new tablespace-relative file number that<br>
is unique relative to other data files in the tablespace and updates database metadata 110<br>
accordingly.<br>
It should be understood that the present invention is not limited to any particular<br>
technique for transportable tablespaces, or any technique for integrating data files from a<br>
database system into another database system.<br>
MULTI-SIZED DATA BLOCK DATABASE SYSTEMS<br>
To integrate a tablespace into a database system that stores data in data blocks of a<br>
different size than those of the tablespace, the database system should support data blocks<br>
of different sizes. A database system that supports multi-size data blocks may have<br>
several capabilities. These include the capability to manage a buffer cache that can store<br>
copies of different sized data blocks, and the capability to generate undo records for data<br>
that is stored in different sized data blocks.<br>
Fig. 3 depicts components of database system 101 used to manage caching<br>
different sized data blocks in buffer cache 190. Referring to Fig. 3, buffer cache 190 has<br>
buffers of different sizes for storing data blocks of different sizes: buffer 392 has block<br>
size A, buffer 394 has block size B, buffer 396 has block size C, buffer 398 has block size<br>
D. A buffer in buffer cache 190 may be any of a number of discrete data block sizes<br>
defined by database metadata 110. Database system 101 may also define a default data<br>
block size to use as shall be further described.<br>
According to an embodiment of the present invention, all data blocks within a<br>
tablespace have the same size. When a user submits DDL commands to define a<br>
tablespace, the commands may include a parameter that specifies the data block size of<br>
data blocks in the tablespace. If no size is specified for the tablespace, then the default<br>
data block size is the data block size for the tablespace.<br>
Block size mapping 330 is used to map data files to data block sizes. Specifically,<br>
block size mapping 330 maps the "database-relative" file number of a data file to the<br>
block size of data blocks contained in the data file. Block size mapping 330 includes<br>
block size mapping entries 332. and columns database-relative file number 336 and block<br>
size 334. An entry in block size mapping entries 332 maps the database-relative file<br>
number value in column database-relative file number 336 to the block size value in block<br>
size 334.<br>
Database-relative number mapping 320 maps the tablespace number and<br>
tablespace-relative file number of a data file to the database-relative number of the data<br>
file. Database-relative number mapping 320 includes database-relative number mapping<br>
entries 322 and columns tablespace number 325, tablespace-relative file number 326, and<br>
database-relative number 324. An entry in database-relative number mapping entries 322<br>
maps the pair of values in columns tablespace number 325 and tablespace-relative file<br>
number 326 to the database-relative number in database-relative number 324.<br>
Database system 101 may use both the database-relative number mapping 320 and<br>
block size mapping 330 to determine what size buffer is needed to store a data block<br>
before reading a data block from static storage. Given a tablespace number and<br>
tablespace-relative number of a data file, the block size can be found by initially<br>
examining database-relative number mapping 320 to find the database-relative number.<br>
From the database-relative number, the block size can be determined by examining block<br>
size mapping 330.<br>
For example, database system 101 receives a request to read a data block DBR<br>
pointed to by data block pointer R. Data block pointer R specifies the tablespace number<br>
and tablespace-relative file number of the tablespace and data file containing the data<br>
block, and an offset indicating where the data block begins within the data file. Database<br>
system 101 examines the database-relative number mapping 320 and block size mapping<br>
330 to determine that blocks size C is the data block size of the data block DBR. Database<br>
system 101 then loads the data block from static storage into a buffer in buffer cache 190<br>
of block size C.<br>
Likewise, a data block pointer may contain a database-relative file number.<br>
Database system 101 uses only block size mapping 330 to determine the block size for<br>
the buffer needed to store the data block referred to by the data block pointer.<br>
UNDO RECORDS FOR MULTIPLE-SIZED DATA BLOCK DATABASE<br>
SYSTEMS<br>
As mentioned previously, undo entries contain the data ("undo data") needed to<br>
undo a change made by database operations. More data blocks may be needed to store<br>
undo data than are needed to store the data that has been changed. There are at least<br>
several causes for this. First, in terms of storage space needed to store data, the amount of<br>
undo data may be inherently greater than the amount of changed data. In other words, a<br>
change to all user data in one data block of size X may require more undo data than can<br>
be stored in one data block of the same size X.<br>
Second, the changed data is stored in data blocks that have a greater size than the<br>
data blocks used to store the undo log. Specifically, in database system 101, tablespace<br>
150 holds log file 150. Tablespace 150 may be configured for data block sizes that are<br>
less than the data block size for which tablespace 130 is configured. Because of the<br>
difference in data block sizes, undo data for a data block in tablespace 130 may require<br>
more data blocks in tablespace 150 than would be needed if the data block sizes for the<br>
tablespaces were equal.<br>
For changes made to a particular data block for a transaction, database system 101<br>
is configured to store undo data in more than one data block. This feature allows database<br>
system 101 to handle differences in sizes between the undo data and the corresponding<br>
changed data, whether the size of the undo data is inherently greater than that of the<br>
changed data, or is stored in data blocks smaller in size than the data blocks that store the<br>
changed data.<br>
INTEGRATING TABLESPACES FROM ANOTHER DATABASE SYSTEM<br>
Fig. 4 is a flowchart depicting the steps of a process for integrating a tablespace<br>
into a target database system from a source database system, where the tablespace<br>
includes data blocks that have a different data block size than at least a subset of data<br>
blocks used by the target database system to store data. The process is illustrated using<br>
database system 101.<br>
Referring to Fig. 4, at step 410, database system 101 determines the block size of<br>
the tablespace to integrate into database system 101. The determination may be made in<br>
any of a variety of ways. For example, database system 101 may examine an export<br>
control file generated for the tablespace to determine the data block size. Alternately,<br>
database system 101 may examine the tablespace, scanning for data structures that mark<br>
the boundaries of data blocks, and determining the amount of data that lies within the<br>
boundaries. Finally, database system 101 may prompt the user for the data block size.<br>
At step 420, database system 101 determines whether it may integrate a tablespace<br>
of the data block size determined at step 410. If database system 101 determines that it<br>
cannot integrate a tablespace of the data block size, then execution of the steps proceeds<br>
to step 490, where database system 101 aborts the process of integrating the tablespace.<br>
Otherwise, execution proceeds to step 430.<br>
The determination of whether a database system 101 may integrate a tablespace of<br>
the data block size may be made using a variety of techniques. If database system 101<br>
supports discrete data block sizes defined by database metadata 110, then database system<br>
101 examines the database metadata to determine whether the data block size in question<br>
is one of the supported discrete block sizes. If database system 101 is hard coded to<br>
support discrete block sizes, then database system 101 may simply be hard coded to<br>
compare the data block size in question to one of the supported discrete block sizes.<br>
At step 430, the database system 101 integrates the tablespace into database<br>
system 101. The tablespace is integrated using any of the techniques for integrating<br>
tablespaces into database systems discussed earlier.<br>
The techniques for transporting data blocks of a given size to a database system<br>
having data blocks of a different size offer advantages over conventional techniques for<br>
transporting data between database systems. Use of transportable tablespaces allows data<br>
to be moved between databases much more quickly than conventional techniques for<br>
importing data. Furthermore, because the data blocks in the tablespace do not have to be<br>
the same size as that of the data blocks of a target database, the target database is not<br>
restricted to using the same data block size as the source database, and may be configured<br>
to use data block sizes that are optimal for the target database. For example, a data<br>
warehouse may be configured to hold data in bigger data blocks than OLTP source<br>
databases.<br>
Of course, if transported data remains in the tablespaces used to transport the data,<br>
data contained therein may be stored in data blocks of a size that is not optimal for the<br>
target database. However, it is not necessary that transported data remain in the<br>
tablespace used to transport the data.<br>
Once a tablespace is integrated, data from the tablespace may be extracted and<br>
loaded into a tablespace having an optimal data block size. For example, the tables<br>
contained in a transported tablespace, once integrated into a data warehouse, may serve as<br>
staging tables. Data from the staging tables is extracted, transformed, and loaded into<br>
tables that serve as the primary online repository for the data warehouse. Extracting data<br>
from tables internal to a database system is typically performed far more efficiently than<br>
extracting data from another database's table.<br>
HARDWARE OVERVIEW<br>
Figure 5 is a block diagram that illustrates a computer system 500 upon which an<br>
embodiment of the invention may be implemented. Computer system 500 includes a bus<br>
502 or other communication mechanism for communicating information, and a processor<br>
504 coupled with bus 502 for processing information. Computer system 500 also includes<br>
a main memory 506, such as a random access memory (RAM) or other dynamic storage<br>
device, coupled to bus 502 for storing information and instructions to be executed by<br>
processor 504. Main memory 506 also may be used for storing temporary variables or<br>
other intermediate information during execution of instructions to be executed by processor<br>
504. Computer system 500 further includes a read only memory (ROM) 508 or other static<br>
storage device coupled to bus 502 for storing static information and instructions for<br>
processor 504. A storage device 510, such as a magnetic disk or optical disk, is provided<br>
and coupled to bus 502 for storing information and instructions.<br>
Computer system 500 may be coupled via bus 502 to a display 512, such as a<br>
cathode ray tube (CRT), for displaying information to a computer user. An input device<br>
514, including alphanumeric and other keys, is coupled to bus 502 for communicating<br>
information and command selections to processor 504. Another type of user input device is<br>
cursor control 516, such as a mouse, a trackball, or cursor direction keys for communicating<br>
direction information and command selections to processor 504 and for controlling cursor<br>
movement on display 512. This input device typically has two degrees of freedom in two<br>
axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify<br>
positions in a plane.<br>
The invention is related to the use of computer system 500 for implementing the<br>
techniques described herein. According to one embodiment of the invention, those<br>
techniques are performed by computer system 500 in response to processor 504 executing<br>
one or more sequences of one or more instructions contained in main memory 506. Such<br>
instructions may be read into main memory 506 from another computer-readable<br>
medium, such as storage device 510. Execution of the sequences of instructions<br>
contained in main memory 506 causes processor 504 to perform the process steps<br>
described herein. In alternative embodiments, hard-wired circuitry may be used in place<br>
of or in combination with software instructions to implement the invention. Thus,<br>
embodiments of the invention are not limited to any specific combination of hardware<br>
circuitry and software.<br>
The term "computer-readable medium" as used herein refers to any medium that<br>
participates in providing instructions to processor 504 for execution. Such a medium may<br>
take many forms, including but not limited to, non-volatile media, volatile media, and<br>
transmission media. Non-volatile media includes, for example, optical or magnetic disks,<br>
such as storage device 510. Volatile media includes dynamic memory, such as main<br>
memory 506. Transmission media includes coaxial cables, copper wire and fiber optics,<br>
including the wires that comprise bus 502. Transmission media can also take the form of<br>
acoustic or light waves, such as those generated during radio-wave and infra-red data<br>
communications.<br>
Common forms of computer-readable media include, for example, a floppy disk, a<br>
flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any<br>
other optical medium, punchcards, papertape, any other physical medium with patterns of<br>
holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or<br>
cartridge, a carrier wave as described hereinafter, or any other medium from which a<br>
computer can read.<br>
Various forms of computer readable media may be involved in carrying one or more<br>
sequences of one or more instructions to processor 504 for execution. For example, the<br>
instructions may initially be carried on a magnetic disk of a remote computer. The remote<br>
computer can load the instructions into its dynamic memory and send the instructions over<br>
a telephone line using a modem. A modem local to computer system 500 can receive the<br>
data on the telephone line and use an infra-red transmitter to convert the data to an infra-red<br>
signal. An infra-red detector can receive the data carried in the infra-red signal and<br>
appropriate circuitry can place the data on bus 502. Bus 502 carries the data to main<br>
memory 506, from which processor 504 retrieves and executes the instructions. The<br>
instructions received by main memory 506 may optionally be stored on storage device 510<br>
either before or after execution by processor 504.<br>
Computer system 500 also includes a communication interface 518 coupled to bus<br>
502. Communication interface 518 provides a two-way data communication coupling to<br>
a network link 520 that is connected to a local network 522. For example,<br>
communication interface 518 may be an integrated services digital network (ISDN) card<br>
or a modem to provide a data communication connection to a corresponding type of<br>
telephone line. As another example, communication interface 518 maybe a local area<br>
network (LAN) card to provide a data communication connection to a compatible LAN.<br>
Wireless links may also be implemented. In any such implementation, communication<br>
interface 518 sends and receives electrical, electromagnetic or optical signals that carry<br>
digital data streams representing various types of information.<br>
Network link 520 typically provides data communication through one or more<br>
networks to other data devices. For example, network link 520 may provide a connection<br>
through local network 522 to a host computer 524 or to data equipment operated by an<br>
Internet Service Provider (ISP) 526. ISP 526 in turn provides data communication<br>
services through the world wide packet data communication network now commonly<br>
referred to as the "Internet" 528. Local network 522 and Internet 528 both use electrical,<br>
electromagnetic or optical signals that carry digital data streams. The signals through the<br>
various networks and the signals on network link 520 and through communication<br>
interface 518, which carry the digital data to and from computer system 500, are<br>
exemplary forms of carrier waves transporting the information.<br>
Computer system 500 can send messages and receive data, including program .<br>
code, through the network(s), network link 520 and communication interface 518. In the<br>
Internet example, a server 530 might transmit a requested code for an application program<br>
through Internet 528, ISP 526, local network 522 and communication interface 518.<br>
The received code may be executed by processor 504 as it is received, and/or<br>
stored in storage device 510, or other non-volatile storage for later execution. In this<br>
manner, computer system 500 may obtain application code in the form of a carrier wave.<br>
In the foregoing specification, the invention has been described with reference to<br>
specific embodiments thereof. It will, however, be evident that various modifications and<br>
changes may be made thereto without departing from the broader spirit and scope of the<br>
invention. The specification and drawings are, accordingly, to be regarded in an<br>
illustrative rather than a restrictive sense.<br>
WE CLAIM:<br>
1. A method for database systems to access data from other database systems, the<br>
method comprising the steps of:<br>
a first database system directly storing first database rows in first data blocks<br>
having a first data block size;<br>
concurrently with said first database system directly storing first database rows in<br>
first data blocks having a first data block size, said first database system directly<br>
accessing a copy of second data blocks in which a second database system<br>
directly stored second database rows;<br>
said second data blocks having at least one data block with a second data block<br>
size different than said first data block size; and<br>
wherein each block of said first data blocks and of said second data blocks is an<br>
unit of storage space allocated within a file to store one or more rows of a<br>
database.<br>
2. The method as claimed in claim 1, wherein the method further includes the step of<br>
integrating said copy of said second data blocks within said first database system<br>
as a tablespace that includes said copy of said second data blocks.<br>
3. The method as claimed in claim 1, wherein the step of accessing a copy of second<br>
data blocks includes storing user data in said copy of said second data blocks.<br>
4. The method as claimed in claim 1, wherein the method further includes the step of<br>
detaching one or more tablespaces from said second database system, wherein<br>
said one or more tablespaces include said second data blocks.<br>
5. The method as claimed in claim 1, wherein each data block of said copy of<br>
said second data blocks has said second data block size.<br>
6. The method as claimed in claim 1, further including the step of generating<br>
metadata that specifies a plurality of block sizes for data blocks directly<br>
accessible to said first database system.<br>
7. The method as claimed in claim 6, wherein:<br>
said metadata defines tablespaces and specifies for each tablespace of<br>
said tablespaces a particular data block size for all data blocks in said<br>
tablespace; and<br>
the method further includes the step of integrating said copy of said<br>
second data blocks within said first database system as at least one<br>
tablespace that includes said copy of said second data blocks, and<br>
wherein the step of integrating includes modifying said metadata to reflect<br>
said second data block size for said at least one tablespace.<br>
8. The method as claimed in claim 1, wherein said first database system is a<br>
data warehouse and said second database system is a source database<br>
system for said data warehouse.<br>
9. The method as claimed in claim 8, further including the step of integrating<br>
said copy of said second data blocks within said data warehouse as a<br>
tablespace that includes said copy of said second data blocks.<br>
10. The method as claimed in claim 1, wherein first data files contain said first<br>
data blocks and second data files contain said second data blocks; and<br>
wherein the method further includes the step of generating a mapping:<br>
between said first data files and said first data block size, and between<br>
said second data files and said second data block size.<br>
11. The method as claimed in claim 1, wherein a first tablespace contains said first data<br>
blocks and a second tablespace contains said second data blocks; and<br>
wherein the method further includes the step of generating a mapping:<br>
between said first tablespace and said first data block size, and between said<br>
second tablespace and said second data block size.<br>
12. The method as claimed in claim 1, wherein said first database system includes a<br>
buffer cache in which said first database system stores data blocks of multiple<br>
sizes; and<br>
wherein said method further includes the step of concurrently storing said first data<br>
blocks and said second data blocks in said buffer cache.<br>
13. A computer-readable medium carrying one or more sequences of instructions for<br>
database systems to access data from other database systems, wherein execution<br>
of the one or more sequences of instructions by one or more processors causes<br>
the one or more processors to perform the steps of:<br>
a first database system directly storing first database rows in first data blocks<br>
having a first data block size;<br>
concurrently with said first database system directly storing first database rows in<br>
first data blocks having a first data block size, said first database system directly<br>
accessing a copy of second data blocks in which a second database system<br>
directly stored second database rows;<br>
said second data blocks having at least one data block with a second data block<br>
size different than said first data block size; and<br>
wherein each block of said first data blocks and of said second data blocks is an<br>
unit of storage space allocated within a file to store one or more rows of a<br>
database.<br>
14. The computer-readable medium as claimed in claim 13, wherein the<br>
compgter-readable medium further includes instructions for performing the<br>
step of integrating said copy of said second data blocks within said first<br>
database system as a tablespace that includes said copy of said second<br>
data blocks.<br>
15. The computer-readable medium as claimed in claim 13, wherein the step<br>
of accessing a copy of second data blocks includes storing user data in<br>
said copy of said second data blocks.<br>
16. The computer-readable medium as claimed in claim 13, wherein the<br>
computer-readable medium further includes instructions for performing the<br>
step of detaching one or more tablespaces from said second database<br>
system, wherein said one or more tablespaces include said second data<br>
blocks.<br>
17. The computer-readable medium as claimed in claim 13, wherein each<br>
data block of said copy of said second data blocks has said second data<br>
block size.<br>
18. The computer-readable medium as claimed in claim 13, further including<br>
instructions for performing the step of generating metadata that specifies a<br>
plurality of block sizes for data blocks directly accessible to said first<br>
database system.<br>
19.The computer-readable medium as claimed in claim 18, wherein:<br>
said metadata defines tablespaces and specifies for each tablespace of<br>
said tablespaces a particular data block size for all data blocks in said<br>
tablespace; and<br>
the computer-readable medium further includes instructions for performing<br>
the step of integrating said copy of said second data blocks within said<br>
first database system as at least one tablespace that includes said copy of<br>
said second data blocks, and<br>
wherein the step of integrating includes modifying said metadata to reflect<br>
said second data block size for said at least one tablespace.<br>
20. The computer-readable medium as claimed in claim 13, wherein said first<br>
database system is a data warehouse and said second database system<br>
is a source database system for said data warehouse.<br>
21. The computer-readable medium as claimed in claim 20, further including<br>
instructions for performing the step of integrating said copy of said second<br>
data blocks within said data warehouse as a tablespace that includes said<br>
copy of said second data blocks.<br>
22. The computer-readable medium as claimed in claim 13,<br>
wherein first data files contain said first data blocks and second data files<br>
contain said second data blocks; and<br>
wherein the computer-readable medium further includes instructions for<br>
performing the step of generating a mapping:<br>
between said first data files and said first data block size, and<br>
between said second data files and said second data block size.<br>
23. The computer-readable medium as claimed in claim 13,<br>
wherein a first tablespace contains said first data blocks and a second<br>
tablespace contains said second data blocks; and<br>
wherein the computer-readable medium further includes instructions for<br>
performing the step of generating a mapping:<br>
between said first tablespace and said first data block size, and<br>
between said second tablespace and said second data block size.<br>
24. The computer-readable medium as claimed in claim 13,<br>
wherein said first database system includes a buffer cache in which said<br>
first database system stores data blocks of multiple sizes; and<br>
wherein said computer-readable medium further includes the step of<br>
concurrently storing said first data blocks and said second data blocks in<br>
said buffer cache.<br>
25. The method as claimed in claim 1, wherein:<br>
a first tablespace includes said first data blocks;<br>
a second tablespace includes said second data blocks; and<br>
the method further includes the step of generating metadata that defines<br>
the first data block size as a size of data blocks in said first tablespace and<br>
defines the second block size as a size of data blocks in said second<br>
tablespace.<br>
26. The computer-readable medium as claimed in claim 13, wherein:<br>
a first tablespace includes said first data blocks;<br>
a second tablespace includes said second data blocks; and<br>
the computer-readable medium further includes instructions for generating<br>
metadata that defines the first data block size as a size of data blocks in<br>
said first tablespace and defines the second block size as a size of data<br>
blocks in said second tablespace.<br>
A computer-readable medium carrying one or more sequences of instructions to<br>
perform the said method comprising the steps of:<br>
a first database system (101) directly storing first database rows (130-1, 130-2) in<br>
first data blocks (392) having a first data block size (A);<br>
concurrently with said first database system (101) directly storing first database<br>
rows (130-1, 130-2) in first data blocks (392) having a first data block size (A),<br>
said first database system (101) directly accessing a copy of second data blocks<br>
(394) in which a second database system (110) directly stored second database<br>
rows (140-1, 140-2);<br>
said second data blocks (394) having at least one data block with a second data<br>
block size (B) different than said first data block size (A); and<br>
wherein each block of said first data blocks (392) and of said second data blocks<br>
(394) is an unit of storage space (190) allocated within a file (332) to store one or<br>
more rows (130, 140) of a database.</td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
		<br>
		<div class="pull-left">
			<a href="223372-an-electric-motor-circuit.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="223374-interactive-video-display-system.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>223373</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>01518/KOLNP/2003</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>37/08</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>12-Sep-2008</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>10-Sep-2008</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>20-Nov-2003</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>ORACLE INTERNATIONAL CORPORATION</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>500 ORACLE PARKWAY, REDWOOD SHORES, CA</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>ARVIND NITHRAKASHYAP</td>
											<td>800 POLHEMUS ROAD NO. 1 SAN MATEO, CA 94402</td>
										</tr>
										<tr>
											<td>2</td>
											<td>MUKKAMALLA, SREEDHAR</td>
											<td>101 LAURIE MEADOWS, SAN MATEO CA 94403</td>
										</tr>
										<tr>
											<td>3</td>
											<td>LAHIRI, TIRTHANKAR</td>
											<td>2067 LITCHFIELD PLACE, SANTA CLARA, CA 95051</td>
										</tr>
										<tr>
											<td>4</td>
											<td>PAREEK, ALOK</td>
											<td>141 KESTREL COURT, BRISBANE, CA 94070</td>
										</tr>
										<tr>
											<td>5</td>
											<td>PAREEK, ALOK</td>
											<td>141 KESTREL COURT, BRISBANE, CA 94005</td>
										</tr>
										<tr>
											<td>6</td>
											<td>LOAIZA, JUAN</td>
											<td>53 MAPLE WAY, SAN CARLOS, CA 94070</td>
										</tr>
										<tr>
											<td>7</td>
											<td>LEE. J. WILLIAM</td>
											<td>1200 E. HILLSDALE BOULVARD, APT. 37B, FOSTER CITY, CA 94404</td>
										</tr>
										<tr>
											<td>8</td>
											<td>NGAI, GARY</td>
											<td>20012 PUENTE COURT, SARATOGA, CA 95070</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F 17/30</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>PCT/US02/16885</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td>2002-05-29</td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>09/871,476</td>
									<td>2001-05-30</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/223373-integrating-tablespaces-with-different-block-sizes by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 06:04:26 GMT -->
</html>
