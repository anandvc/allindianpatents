<!DOCTYPE html>
<html lang="en">
  
<!-- Mirrored from www.allindianpatents.com/patents/270593-a-method-of-efficiently-reducing-the-amount-of-repetitive-graphical-data-transmitted-to-a-remote-display-device-and-a-system-thereof by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 04:03:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Indian Patents. 270593:A METHOD OF EFFICIENTLY REDUCING THE AMOUNT OF REPETITIVE GRAPHICAL DATA TRANSMITTED TO A REMOTE DISPLAY DEVICE, AND A SYSTEM THEREOF</title>
    <meta content="authenticity_token" name="csrf-param" />
<meta content="cYcP52B8zyTWKbLwby2YPh9z/gvY/RLjWOwY4YXkiXg=" name="csrf-token" />

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.6.1/html5shiv.js" type="text/javascript"></script>
    <![endif]-->

    <link href="../assets/application-e80cf34975c5b1730c80b2f7170e7d26.css" media="all" rel="stylesheet" type="text/css" />

  </head>
  <body>

    <div class="navbar navbar-fluid-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="../index.html">Indian Patents</a>
          <div class="container-fluid nav-collapse">
            <ul class="nav">
              <li><a href="../recently-granted.html">Recently Granted Patents</a></li>
              <li><a href="../recently-published.html">Recently Published Patents</a></li>
            </ul>
            <form id="gform" class="navbar-search pull-right" action="https://www.google.com/search" method="get" target="_blank" onsubmit="document.getElementById('gform').q.value='site:http://www.allindianpatents.com '+document.getElementById('gform').q.value">
                <input type="text" name="q" id="q" class="search-query" placeholder="Search" onclick="this.value=''" autocomplete="off">
            </form>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row-fluid">
        <div class="span12">

          <style>
          .allindianpatents-top { width: 320px; height: 50px; }
          @media(min-width: 500px) { .allindianpatents-top { width: 468px; height: 60px; } }
          @media(min-width: 800px) { .allindianpatents-top { width: 728px; height: 90px; } }
          </style>
          <center>
          </center>
          
          <div class="row-fluid">
	<div class="span8">

		<table class="table">
			<tr>
				<th>Title of Invention</th>
				<td><h1 style="font-size:large;">A METHOD OF EFFICIENTLY REDUCING THE AMOUNT OF REPETITIVE GRAPHICAL DATA TRANSMITTED TO A REMOTE DISPLAY DEVICE, AND A SYSTEM THEREOF</h1></td>
			</tr>
			<tr>
				<th>Abstract</th>
				<td>There is disclosed a method of efficiently reducing the amount of repetitive graphical data transmitted to a remote display device (128), said method comprising the steps of : searching a table (411) for an index (416) associated with a graphical data element, the presence of the index (416) in the table (411) indicative of a prior transmission of the graphical data element ; characterised in that the method involves the steps of: upon failing to locate the index (416) in the table (411), searching a fuzzy database (418) for a fuzzy key (419) associated with the graphical data element, the presence of the fuzzy key (419) in the fuzzy database (418) indicative of a likelihood that the graphical data element is stored within a persistent storage memory (120) coupled to the remote display device (128); and upon locating the fuzzy key (419), transmitting the fuzzy key to an agent (118) associated with the persistent storage memory (120) and remote display device (128). A system for implementing the method is also disclosed.</td>
			</tr>
		</table>

					<style>
					.allindianpatents-post-abstract { width: 320px; height: 50px; }
					@media(min-width: 880px) { .allindianpatents-post-abstract { width: 468px; height: 60px; } }
					@media(min-width: 1267px) { .allindianpatents-post-abstract { width: 728px; height: 90px; } }
					</style>
					<center>
					<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
					<!-- AllIndianPatents-post-abstract -->
					<ins class="adsbygoogle allindianpatents-post-abstract"
					     style="display:inline-block"
					     data-ad-client="ca-pub-7914358224572760"
					     data-ad-slot="9152759240"></ins>
					<script>
					(adsbygoogle = window.adsbygoogle || []).push({});
					</script>					
					</center>

		<table class="table">
			<tr>
				<th>Full Text</th>
				<td>A METHOD OF EFFICIENTLY REDUCING THE AMOUNT OF<br>
REPETITIVE GRAPHICAL DATA TRANSMITTED TO A REMOTE<br>
DISPLAY DEVICE, AND A SYSTEM THEREFOR.<br>
This application is divided out of the Indian Patent Application No. IN/PCT/2002/01405 filed on 14/11/2002.<br>
CROSS-REFERENCE TO RELATED APPLICATIONS [0001] This claims, priority to and the benefit of U.S. provisional patent application, numbers 60/207,532, filed May 26,2000, and 60/225,217, filed August 14,2000, the entirety at which are incorporated herein by reference.<br>
HELD OF THE INVENTION [0002] The present invention relates generally to communication between an<br>
application server and a thin client in a distributed system and, in particular, to the reduction in the amount of graphical display data transmitted over a low bandwidth transport protocol mechanism.<br>
BACKGROUND OF THE INVENTION<br>
[0003] Distributed computer systems utilize the technique of distributing application<br>
execution. More specifically, an application server locally executes an application program and provides the application output data to clients/network users who then display the results on a display screen coupled to their local computer. By performing the application processing functions at the server and displaying the application output at the client, these distributed systems make the best use of server and client resources, i.e., the more capable server performs the compute and memory intensive application processing functions while the client, with potentially greater video performance, displays the output During execution of the application program, a user of the client views the application output data on the client's display and interacts with the application program via keyboard or mouse inputs. The client user's inputs correspond to requests to the application server to perform certain actions that affect the<br><br>
-2-<br>
operation of the application program. The application server passes these requests to the<br>
application for further processing. The application server also intercepts the application output data, generated by the application program and typically targeted to the operating system of the application server, and transmits all or part of the data to the client for display. From the perspective of the user, the application program seems to be executing locally even though it is actually being executed on a remote server and just being displayed locally.<br>
[0004] The performance of distributed systems depends to a large degree on the capability of the network, which couples the client and the server, and therefore on the amount of graphical data (corresponding to the application output data) that is transmitted over the network. Since the application server and the client workstation are generally linked only by a transport mechanism (such as serial lines, telephone lines, local area networks and wide area networks) that possesses lower bandwidth than would be otherwise available if the application, program were executing locally, the perceived performance of the distributed system may surfer. Accordingly, manufacturers of distributed systems/software continually strive to improve the performance of such systems.<br>
SUMMARY OF THE INVENTION [0005] The present invention improves the performance of distributed systems by<br>
reducing the amount of graphical data (e.g., bitmapped graphical data, encoded bitmaps, glyphs, and line data) transmitted between the server and the client The invention achieves this reduction in several different ways, for example, by encoding the graphical data into a smaller object, by representing a graphical object with indicia of the object, by increasing the repetitiveness of the data in the protocol stream so that compression algorithms operate more efficiently, by tracking and leveraging the prior transmissions of identical/repetitive graphical objects, by adapting the rate of processing activity or the encoding technique in response to<br><br>
-3-<br>
changes in the network performance or in response to performance mismatches between, the<br>
client and server, and in several other ways described herein.<br>
[0006] In one embodiment, the present invention enables the efficient transmission of graphical display data from an application server node to a client node. In this embodiment; the invention intercepts a plurality of graphical display information commands issued by an application executing on the server. Once these commands have been intercepted or otherwise obtained, they are analyzed to determine whether they should be selected for farther transmission to remote client nodes. The selected commands are then encoded and packaged into a protocol packet stream for eventual transmission to the remote client nodes. Prior to transmission, the packet stream can be farther compressed by subjecting the encoded packets to compression techniques.<br>
[0007] The encoding technique of the present invention substantially maximizes compression of the protocol packet stream by building m repeatability into the protocol stream that allows the compression algorithm, to substitute pointers for repetitive data. This technique focuses on maximizing the efficiency of the compression algorithm, rather than solely reducing the amount of data via encoding prior to transmission. The result of this encoding scheme is that the degree of compression is significantly increased for many types of graphical data. The encoding technique of the present invention. encodes the graphical data so that portions of me graphical data mat repeat are encoded in the same manner. The compression algorithm then operates on this repetitive encoded data to realize a greater degree of efficiency.<br>
[0008] In one embodiment, the present invention efficiently reduces the amount of repetitive graphical data transmitted to a remote display device coupled to the client In this embodiment, a server agent searches for an index (that may have been previous1y stored on the server by me server agent) associated with the graphical data and which is indicative of a prior<br><br>
-4-<br>
transmission of the graphical data, to a client agent. The index or handle represents a memory<br>
location in the client's cache memory mat currently stores me previously transmitted graphical data. If the index is found, then the index is transmitted to the client agent, thus avoiding the need to transmit the graphical data itself. The client agent obtains the graphical object stored in the cache location identified by the index and performs additional processing activities as directed by the server agent In one aspect of the invention, commands and information transmitted between the server agent and the client agent are queued at the server. The commands in the queue can then be processed in accordance with an estimate of the relative performance between the client and server agents or computers.<br>
[0009] If the server agent is unable to locate the index, the server agent searches a fuzzy database for a fuzzy key that is associated with the graphical data. The fuzzy key, for example, corresponds to a length of the graphical data. The fuzzy key indicates mat the graphical data had at one time been transmitted to the client and that there is a strong likelihood that the graphical data is stored within the client's persistent storage memory. One or more fuzzy keys are provided to the server agent upon initiating a session between the client and server agents. Alternatively, the fuzzy keys are transmitted to the server agent in accordance with a predetermined polling interval. Regardless of how the fuzzy keys are received, the server agent stores them inthe fuzzy database for subsequent use during the client/server session. The fuzzy database relating to a particular session can also be maintained beyond the term of the session so that it is available for future sessions, by, for example; having the client agent persistently cache the graphical data from the particular session and causing the server agent to dynamically construct the fuzzy database on the server from the client's persistently-cached graphical data during a future session. This may prove useful in environments where frequent, but short, sessions are present.<br><br>
-5-<br>
[0010] If the fuzzy key is located, then the server agent transmits the fuzzy key together<br>
with a command to the client agent, which, for example, retrieves the graphical data stored in its persistent storage memory and copies it into its volatile memory. If the client agent fails to retrieve the graphical data, the server agent can transmit the graphical data, together with a recovery marker, to the client agent.<br>
[0011] If the server agent is unable to locate the fuzzy key within the fuzzy database, the server agent forms the fuzzy key and stores the fuzzy kay in the fuzzy database. The server agent then transmits the fuzzy key, an index, and the graphical data to the client agent, which is instructed to store the data in the client's volatile memory associated with the index. As the client-server session continues and the client's volatile memory becomes full, graphical data will be transferred into the client's persistent storage. In one aspect the client agent stores the graphical data in a file residing in the persistent storage memory that reflects the fuzzy key as part of the file's name.<br>
[0012] In one aspect of the invention, the server agent instructs the client agent to update an off-screen surface coupled to the client agent using the graphical data identified by the server agent and/or stored in the client's volatile of persistent storage memory. These instructions can be triggered in response to a change in the off-screen surface, such aa.when the off-screen surface and on-screen surface of the client node interact If the client agent fails to update the off-screen surface in accordance with the server agent's instructions, the server agent can transmit the graphical data to the client agent and direct that the client agent update portions of its on-screen or off-screen surfaces, which may have been corrupted, with the transmitted<br>
[0013] Further, the encoding technique used to encode the graphical data prior to transmission can be selected based on an estimate of the network conditions of the network that<br><br>
-6-<br>
couples the client agent with the server agent This estimate can correspond to a time differential<br>
measured by the client agent that relates to the amount of time expended to receive a particular encoded graphical data.<br>
[0014] In one embodiment, the present invention adapts a processing rate in response to changing network conditions. In one aspect of the invention, the server agent processes graphical data addressed to the client agent at a first rate. By determining the network conditions of the network that couples the client and server agents, the server agent can adjust its processing rate from the first rate to a second rate in response to a change in the network conditions. The server agent can determine information about the network conditions by transmitting the processed graphical data to the client agent and instructing the client to measure a time differential associated with the transmission or receipt of the graphical data. In this manner, the time differential provides an indicator ofthe network conditions and the server agent can rationally select the second rate in accordance with this time differential. Similarly, the encoding technique used while processing the graphical data by the server agent at the first rate can be modified to a second encoding scheme/technique in response to changes in the network conditions that are determined by the server agent The network conditions can be estimated in accordance with the time differential discussed previously. Once the second encoding technique is selected by the server agent, the server agent will process subsequent graphical data using this second encoding technique.<br>
[0015] In one embodiment, the invention adapts a processing rate of the server in response to a performance mismatch between the server and the client coupled to the server via the network. In operation, the server agent processes graphical data and determines a first time period associated with such processing. For example, the first time period can be determined by scrolling a frame buffer of the server. The client agent also processes the graphical data and<br><br>
-7-<br>
determines a second time period associated with its processing. The server agent then<br>
determines the time differential between the first and second time periods and adjusts its processing rate in accordance therewith.<br>
[0016] In one embodiment, the invention efficiently reduces the amount of graphical<br>
line data transmitted from a server to a client via a communication network. The Server agent<br>
separates a path defining a line or region into a plurality of strips, where each of the strips have a beginning and an endpoint coordinate defined within a coordinate system (e.g, a Cartesian coordinate system). The coordinatesystemcorresponds to a region of a display surface associated with the client In one aspect of the invention, the server agent quantizes the coordinate system into a plurality of quantized angles (e.g,, 16 quantized angles) and determines the endpoint coordinate of one of the plurality of strips. The coordinate system is men normalized so that its origin coincides with this endpoint coordinate. The beginning coordinate of the adjacent strip rathe path is then, associated by the.server agent with the endpoint coordinate of the first strip. The server agent then selects one of the quantized segments of the coordinate system as corresponding to an approximate angle of the adjacent strip. This technique enables the transmission of the difference between the endpoint coordinates of the two strips(i.e., the strip length) and an indication of the selected quantized angle and thus avoids having to transmit both sets of coordinates or a coordinate and the precise angle for each strip.<br>
[0017] In one embodiment of the invention, the server agent remotely controls the formation of an off-screen surface at a client, which is coupled to the server via a communications network. The server agent informs the client agent that an off-screen surface of a particular size or type is to be formed within the client's memory and the client agent responds by selecting and allocating a first memory region having an appropriate format to represent the off-screen surface from a plurality of available memory regions in the client's memory. The<br><br>
- 8 -<br>
 server agent then either transmits a bitmap or an indicia of the bitmap (eg., index or fuzzy key)<br>
to the client agent and instructs the client agent to copy the bhtnap to a particular location within the first memory region. Once the bitmap is copied to the off-screen surface, it can be used to update the client's on-screen surface. Such off-screen operations can also be performed for non-bitmap data, such as-lines or text<br>
[0018] The server agent can also respond to error conditions by storing a duplicate of the client's off-screen surface in the server's local memory, hi the event of an error condition, such as when a preselected memory region of the client's memory is not sufficiently large enough to store a particular off-screen surfece, the client agent asynchrarausly informs the server agent of the error. In response to the error condition, the server agent transmits at least one portion of its duplicate off-screen surface or a copy of the bitmap to the client agent and instructs the client agent to update the client's on-screen surface using the transmitted duplicate off-screen surface data.<br>
BRIEF DESCRIPTION OF THE DRAWINGS [0019] The foregoing discussion will be understood more readily from the following<br>
detailed description of the invention, when taken in conjunction with the accompanying drawings, in which:<br>
Fig. 1 schematically illustrates a client node coupled to a server node via a communication network, where the client and server nodes each have respective client and server agents operating in accordance with an embodiment ofthe present invention;<br>
Fig. 2 provides a high-level flow diagram of the steps performed by the server agent of Fig. 1 in accordance with an embodiment of the present invention;<br>
Fig. 3 provides a more detailed flow diagram to the diagram of Fig. 2 in accordance with an embodiment ofthe present invention;<br><br>
-9-<br>
Fig. 4 schematically illustrates the contents of the client and server's volatile and<br>
persistent memory, as affected by operations of the client and server agents of Fig. 1, in accordance with an embodiment of the present invention;<br>
Fig. 5 provides a flow diagram of the steps taken to minimize the amount of data transmitted to the client by using caching techniques involving a fuzzy database and fuzzy keys, hi accordance with an embodiment of the present invention;<br>
Fig. 6 schematically illustrates a set of procedures used to remote text information generated by an application program on a server to a display of a distant client in accordance with an embodiment of the present invention;<br>
Fig. 7A provides a Iine diagram illustrating a plurality of segments forming a particular<br>
path;<br>
Fig. 7B provides a pixel-level representation of the line diagram of Fig. 7A, illustrating how the path is actually approximated on a computer display;<br>
Fig. 8 provides a flow diagram of the steps taken when processing and encoding segment and strip data in accordance with an embodiment of the present invention;<br>
Fig. 8B provides a coordinate system organized into a set of 16 regions that is used to quantize angle information relating to strips and which improves compression efficiency in accordance with an embodiment of the present invention;<br>
Fig. 9 superimposes the coordinate system of Fig. 8B on the pixel-level representation of<br>
Fig. 7R to illustrate an embodiment of a strip processing technique in accordance with the<br>
present invention;<br>
Fig. 10provides a table,which illustrates how to get to the next strip fromthe end point of the previous strip, for strips in each of the quantized segments of Fig. 8B in accordance with an embodiment of the present invention; and<br><br>
-10-<br>
Fig. 11 provides a flow diagram of the steps petfonned by the server agent in response to<br>
an error condition involving the formation of a client's off-screen surface.<br>
DETAILED DESCRIPTION OF THE INVENTION<br>
[0020] The present invention reduces the amount of graphical data transmitted between<br>
an application server, which is executing an application program, and a subscribing client, which is locally displaying the output data of the application program, by encoding the data into relatively small representations that repeat within the protocol stream, transmitted between the client and the server. In this manner, the invention minimizes the size of each discrete data element that must be transmitted and increases the repeatability of the data within the protocol stream so that compression algorithms that operate more efficiently on repetitive encoded data can realize a greater degree of compression efficiency. The invention uses a number of techniques to realize this enhanced compression, including the following: scanning a command queue for later-issued commands which supercede earlier-issued commands; disk-caching techniques that improve compression of data that has been previously encountered during a client-server session; transmission of relative coordinates using quantized regions to avoid sending both endpoints and/or the angle of an associated strip; and manipulation of off-screen surfaces to enhance performance during the client-server session. The invention also reduces the frequency of overscroll problems encountered when there is a performance mismatch between a fast server and a relatively slow network or client<br>
[0021] With reference to Fig. 1, one or more client nodes 110', 110" (hereinafter each client node or plurality of client nodes is generally referred to as 110) are in communication with one or more server nodes 150', 150" (hereinafter each server node or plurality of server nodes is generally referred to as 150) via a communications network 140. The network 140 can be a local-area network (LAN), a medium-area network (MAN), or a wide area network (WAN) such<br><br>
-l1-<br>
as the Internet or the World wide Web. Users of the client node 110 can be connected to the<br>
network 140 through a variety of connections including standard telephone lines, LAN or WAN links (e.g., Tl, T3,56kb, X25), broadband connections (ISDN, Frame Relay, ATM), and wireless connections. The connections can be established using a variety of communication protocols (e.g., TCP/IP, IPX, SPX, NetBIOS, and direct asynchronous connections). In some particularly advantageous embodiments, the protocol used may be the Independent Computing Architecture protocol manufactured by Citrix Systems, Inc. of Fort Lauderdale, Florida or the Remote Display Protocol manufactured by Microsoft Corporation, of Redmond, Washington.<br>
[0022] The client node 110 can be any personal computer (e.g., 286,386,486, Pentium, Pentium II, Macintosh computer), Windows-based terminal Network Computer, wireless device, information appliance, RISC Power PC, X-device, workstation, mini computer, main frame computer or other computing device thatt has a windows-based desktop and sufficient memory for executing a small, display presentation program. The display presentation program uses commands and data sent to it by the application server 150 across the network 140 to render a graphical display. la a distributed computer system model, the execution of application programs occurs primarily on the application server 150 and the user interface, keystrokes, and mouse movements produced by client-side inputs are transmitted over the network 140 to and from the client node 110.<br>
[0023] The client node 110 typically includes a processor 112, a volatile memory 114 (e.g., RAM cache), an operating system 116, a client agent 118, a persistent storage memory 120, a network interface 122 (e.g., a network interface card), a keyboard 124, a mouse 126, and a display 128. Windows-oriented platforms supported by the client node 110 can include, without limitation, WINDOWS 3.x, WINDOWS 95, WINDOWS 98, WINDOWS NT 3.51, WINDOWS NT 4.0, WINDOWS 2000, WINDOWS CE, MAC/OS, Java, and UNIX. The client agent 118<br><br>
-12-<br>
corresponds to a software program that receives commands and data from the server node 150<br>
and from a user (not shown) ofthe client node 110. The client agent 118 uses the received information when interacting with other components ofthe client node 110 (e-g, when directing the operating system 116 to output data onto the display 128). The client agent 118 also transmits requests and data to the server node 150 in response to server-issued commands or user actions at the client node 110.<br>
[0024] Similarly, the server node 150 includes a processor 152, a volatile memory 154, an operating system 156, an application program 158, a server agent 160, persistent storage memory 162, and a network interface 164. The server agent 160 corresponds to a software program that interfaces with the client agent 118 and other components of the server node 150 to support the remote display and operability of the application program 158.<br>
[0025] Each application server 150 hosts one or more application programs 158 mat can be accessed by the client nodes 110. Examples of such applications include word processing programs such as MICROSOFT WORD and spreadsheet programs such as MICROSOFT EXCEL, both manufactured by Microsoft Corporation of Redmond, Washington, financial reporting programs, customer registration programs, programs providing technical support information, customer database applications, or application set managers.<br>
[0026] During execution of the application program 158, a server 150 communicates with the client node 110 over a transport mechanism (part of the server agent 160). ln one embodiment, the transport mechanism provides multiple virtual channels and one ofthe virtual channels provides a protocol for transmission of graphical screen data from the server node 150 to the client node 110. The server 150 executes a protocol driver (part ofthe server agent 160) that intercepts graphical display interface commands (generated by the application program 158<br><br>
-13-<br>
and targeted at the server's operating system 156) and translates them into a protocol packet<br>
suitable for transmission over the transport mechanism.<br>
[0027] In one embodiment and -with, reference to Fig. 2, the server agent 160 intercepts a graphical display interface command (step 202) issued by the application program 158 and directed to the operating system 156, encodes graphical data associated with the command and the application program 158 (step 204), compresses the encoded graphical data (step 206), creates a transport protocol packet incorporating the intercepted ammand and compressed, encoded data (step 208), and transmits the transport protocol packet to the target client node 110 (step 210). Graphical data refers to any type of data that can. be displayed on the display 128, such as bitmaps, glyphs, coordinates, list of lines, strips, etc. Hereinafter, descriptions of techniques which are applied to particular types of graphical data or graphical objects can be construed to apply to all types of graphical data.<br>
[0028] More particularly, a protocol driver of the server agent 160 intercepts the graphical display interface commands (step 202). m one embodiment the protocol driver intercepts high-level application programming interface calls made by the application program 158. In one embodiment, the protocol driver intercepts GDI commands provided by WINDOWS-based operating systems. In another embodiment, the protocol driver intercepts QUICKDRAW commands, provided by MAC/OS-based operating systems. la still other embodiments, the protocol driver intercepts lower-level commands, such as interface calls to the device driver associated with the graphical display of the server node 150. In still other embodiments, the graphical display interface command may be duplicated rather man intercepted. In these embodiments, the display of the application program output data on. the server 15O and the client 110 will be substantially similar, if not identical. The protocol driver creates a transport protocol packet based on the intercepted graphical display command (step<br><br>
-14-<br>
208). The protocol driver may use a protocol command set that contains an analogous command<br>
for each possible intercepted display interface command. Alternatively, the protocol driver may use a command set that is a subset of the intercepted display interface commands. In other embodiments, the protocol command set may be a superset of the possible intercepted display interface commands.<br>
[0029] For each intercepted GDI command and affected graphical data mat must be<br>
transmitted to the client agent 118 in order to display the output of the application program 158<br>
on the client's display 128, the server agent 160 queues the related protocol command together<br>
with a unique key 412 (Fig- 4) associated wim tie affected graphical data. The unique key 412<br>
describes and uniquely identifies the graphical data. In one embodiment the unique key is<br>
generated by perfemning a 64 bit cyclic redundancy cheek (CRC) on the graphical data. 	In<br>
another embodiment, the 64 bit CRC is generated as two 32 bit CRCs, performed on the graphical data sequentially and in opposite directions. Other methods of generating a unique key associated with graphical data, as known to one skilled in the art. may also be used. The protocol command and me unique key 412 ate queued at me server 150, together with, other command/unique key sets. The queued commands are men scanned to ascertain whether later-issued commands (i.e., those near the back of the queue) supercede earlier-issued commands (i.e., those closer to the front of the queue). If the earlier-issued commands are superceded, then the server agent 160 removes them from the queue and thus avoids having to transmit unnecessary data to the client agent 118.<br>
[0030] For example, a series of commands to display the next page of data issued in quick succession need not be displayed individually at the client 110. All that need be displayed is the last display page issued, since mis last page of data will overwrite all previous pages of<br>
data. By removing the unnecessary commands and unique keys corresponding to the earlier<br><br>
-15-<br>
pages from the server's queue, the server agent 160 substantially reduces the amount of data that<br>
must be processed and transmitted.<br>
[0031] In one illustrative embodiment, only unnecessary commands and related data pertaining to opaque operations are removed from the server's queue. For example, if a previously-queued command involving the creation of a rectangular region having coordinates 10,10,50,50 is followed by a more recently-queued command involving the creation of a largo/covering rectangular region having coordinates 0,0,100,100, then the previously-queued command and related data is deemed unnecessary and is removed from the queue.<br>
[0032] Table 1 below lists an exemplary set of protocol commands provided in one embodiment of the invention.<br>
Protocol Command	 Purpose<br>
INTT	Initialises the protocol connection<br>
SET_MOUSE_POINTER	Instructs the client agent 118 to form a mouse pointer<br>
HIDE_MOUSE_POINTER.	Instructs the client agent 118 to hide a mouse pointer<br>
CHANGE_TEXT_MODE	Instructs the client agent 118 to change the mode of output text<br>
CHANGE_TEXT_COLOR	Instructs the client agent 118 to change the foreground color of output text<br>
CHANGE_TEXT_BACKGRND_COLOR	Instructs the client agent 118 to change the background color of the output text<br>
NEW_SOLID_BRUSH	Instructs the client agent 118 to update the current brush setting using a new solid color<br>
HEW_PATTERN_BRUSH	Instructs the client agent 118 to change the brush pattern<br>
NULL_CLIP_REGION	Informs the client agent 118 that the current region is not clipped<br>
SIMPLE_CLIP_REGION	Informs the client agent 118 that the current region is clipped along one side<br>
COMPLEX_CUP_REGION	Informs the client agent 118 that the current region is clipped along more than. one side<br><br>
-16-<br>
 CHANGE_PALETTE	 Instructs the client agent 118 to change its color palette<br>
TEXTOUT	Instructs the client agent 118 to output text, represented as one or more screen glyphs<br>
DRAW_PATH	 Instructs the client agent 118 to draw a simple or complex path, such as a line or bezier curve<br>
BITBLT	Instructs the client agent 118 to draw a particular bitmapped object <br>
BITBLT_TRICK	Instructs the client agent 118 to draw the entire bitmap <br>
PARTIAL_BITBLT_TRICK	Instructs the client agent 118 to draw a portion of the bitmap <br>
SRC_TO_SRC_BLT 	 Instructs the client agent 118 to copy a particular portion of the drawing surface to another of the same surface<br>
SOLED FILL	Instructs the client agent 118 to fill a target region using an identified color <br>
SOLID_F1LL_NO_CLIPPING	Instructs the client agent 118 to fill a target region without clipping <br>
SOLID_FILL_NEW_COLOR	 Instructs the client agent 118 to fill a target region using a color that is different from the color last-used <br>
SOLID_FILL_NEW_COLOR_NO_CLIP	Instructs the client agent 118 to fill a target region using a color mat is different from the color last used, without clipping <br>
CACHE_NEW_OBJ	 Sends data Tenresenting a new object to the cEent agent 118 for storage in me client's cache<br>
CACHE_NEW_OBJ_INCOMPLETE 	 Sends partial data of a new object to the client agent 118 for storage in the client's cache <br>
CACHE_EXTEND_OBJ	 Sends additional data relating to a previously transmitted incomplete object and indicates that the object is complete<br>
CACHE_EXTEND_OBJ_NCMPLT	 Sends additional data relating to apreviously transmitted incomplete object and indicates mat more data will follow <br>
CACHE_WRITE_DISK_OBJECTS	 Instructs the client agent 118 to write its object cache, or a portion of its object cache to persistent storage <br>
CACHE_PURGE_MEMORY_CACHE	 Instructs the client agent 118 to purge its object cache, or a portion of its object cache <br>
CACHE_KEAD_DISK_OBJECT	Instructs the client agent 118 to read data into its cache from persistent storage <br><br>
-17-<br>
 START_STOPWATCH	 Instructs the client agent 118 to start a timer and write the current time tick into an array element <br>
STOP_STOPWATCH	 Instructs the client agent 118 to determine the difference between the time tick recorded by the START STOPWATCH command and the current time tick <br>
SAVEJSCREENJBITS	 Instructs the client agent 118 to save a lectangular screen area and to associate it with a particular identifier <br>
 RESTORE_AND_FREE_SCREEN_BITS Instructs the client agent 118 to restore a then discard the screen data <br>
FREE_SCREEN_BITS	 Instructs the client agent 118 to discard specified data <br>
 CREATB_SURFACE	 Instructs the client agent 118 to form an off-screen surface compatible with the current session color depth, associate the surface -with an identifier, and associate attributes to me surface<br>
DELETE_SURFACE	 Instructs the client agent 118 to delete a particular off-screen surface <br>
CHANGE_SURFACE	Instructs the client agent 118 to switch from a current destination surface to another specified surface <br>
C2S_0SS_ERR0R	Informs the server agent 160 of an error in a particular off-screen surface that makes it unavailable <br>
C2S_INVALIDATE_0SS	 Informs the server agent 160 that a particular off-screen surface has become dirty, i.e., that his not the same as a duplicate sur&amp;ce accessible to the server agent 160<br>
C2SJUPDATE_DISK_KEYS	 Instructs the server agent 160 to update its list of fuzzy keys<br>
C2S_ACK_DISK_READS	 Informs the server agent 160 that objects have been read into the client's cache<br>
C2S_NACK_DISKREAD	Informs the server agent 160 that objects have not been read into the client's cache <br>
C2S_ST0PWATCH_RESULT	Sends the time differential between the start/stop stopwatch commands to the server agent 160<br>
C2S_ACK_INIT	Informs the server agent 160 that the protocol connection has been established <br>
TABLE 1 - PROTOCOL COMMANDS<br><br>
-18-<br>
[0033] In one embodiment, the protocol commands and associated graphical data are<br>
configured to maximize the repetition of information in the protocol packet stream created by the protocol driver. In one aspect of the invention, the graphical data is first encoded (step 204) prior<br>
to subjecting the encoded graphical data and/or protocol commands to a compression algorithm<br>
(step 206) that takes advantage of the repetitive nature of the protocol stream (e.g, a Lempel-Ziv compression protocol may be used). In one embodiment and upon the first instance of the graphical data in the client-server session, an indicia of the graphical data is transmitted together with the corresponding encoded data in the protocol stream so as to reduce the amount of data transferred via the network 140 for future instances of the graphical data occurring during the same client-server session. The compressed data is subsequently'bundled into the transport protocol packet and transmitted to the client node 110 (step 208) for decompression and interpretation.<br>
[0034] In one illustrative embodiment, the application program 158 executes a GDI command that instructs the server's operating system 156 to draw a bitmap. The server agent 160 intercepts this GDI command (step 202) and issues a BITBLT rammand to the client agent 118, which instructs the client agent 118 to display the application program's output data on the client's display 128. Prior to issuing the BITBLT command, the server agent 160 encodes the output data (step 204) and includes the encoded data, together with the BITBLT command in the compressed protocol packet stream transmitted to the client agent 118. In one embodiment, the data describing the bitmap 410 (FIG. 4) is encoded and compressed (steps 204 and 206) to take advantage of some of the redundancies present in the bitmap 410. For example, the bitmap 410 may be such that successive raster lines are redundant or adjacent pixels are redundant<br>
[00351 In addition to encoding bitmaps or other discrete graphical data elements based on their internal data redundancies, the invention also iricorporates (aching techniques that<br><br>
-19-<br>
further improve the encoding and compression of graphical data that has been previously<br>
encountered during a particular client-server session. For example, when a particular bitmap is first encountered during a client-server session it is encoded as described above. For subsequent transmissions of the bitmap during the same client-server session, indicia of the bitmap can be transmitted rather than the relatively larger, encoded bitmap. In one embodiment, the indicia correspond to a location within the client's volatile memory that contains the previously transmitted bitmap.<br>
[0036] More particularly and with reference to Figs. 3 and 4, the server agent 160 generates the unique key 412 (step 330), as described above, and associates the unique key 412 with the graphical data (e.g., bitmap 410). This association essentially defines the bitmap 410 and its related data as a graphical object, which is subsequently registered, together with its unique key 412 and encoded data 414 (step 340)x in a data structure 411 (e.g., a table) stored in the server's volatile memory 154 (e.g. the server's cache subsystem). In other embodiments, the bitmap-related data may be written into the server's persistent storage 162.<br>
10037] Assuming that the protocol command (e.g., BTTBLT) and associated graphical data are not superceded by later-issued commands (as described previously), the server agent 160 dequeues (s|ep 360) the BITBLT command and the unique key 412 from the queue and searches the table 411 stored in the server's volatile memory 154 to determine if the unique key 412 had been previously stored therein. If the unique key 412 is located within the table 411, then the server agent 160 determines that the encoded data 414 has been previously processed by the server 150. The server agent 160 then searches the table 411 for an index or handle 416 associated with the encoded bitmap 414. If the index 416 is located, then the server agent 160 determines that the encoded bitmap 414 has not only been processed by the server 150, but that it has also been previously transmitted to the client agent 118. If the index 416 is notlocated<br><br>
-20-<br>
within the table 411, then the server agent 160 determines that the encoded bitmap 414 has not<br>
been previously transmitted.<br>
[00381 In one embodiment, the index 416 identifies a particular location within the client's volatile memory 114, which stores the previously-transmitted encoded bitmap 414. In one embodiment; the client agent 118 provides a snapshot of its available volatile memory 114 to the server agent 160 upon initiating a client-server sessionwiththe server agent 160. Once the session is established, the server agent 160 thereafter controls the allocation of the client's available volatile memory 114. In this manner, the server agent 160 is able to allocate the client's volatile memory 114 to the encoded bitmap 414 and to maintain the index 416 as a pointer or reference to the allocated memory and as an identifier of the previously-transmitted encoded bitmap 414.<br>
(0039] If the index 416 is located within the server's table 411, the server agent 160 obtains the index 416 (step 370), compresses the index 416 together wilh the related protocol command (step 380), and transmits the compressed data in a packet directed to the client agent 118 via the network 140. In one embodiment, the index 416 is shorter in length (e.g., 16 bits) than the unique key 412 (e.g., 64 bits), and consequently consumes less bandwidth when transmhted^Upon receipt and decompression of the compressed packet, the client agent 118 accesses the particular memory location in the client's volatile memory 114 that is specified by the index 416 in order to obtain the appropriate graphical data 410. The client agent 118 subsequently manipulates the obtained graphical data 410 in accordance with the command which accompanied the index 416 in the compressed packet In this manner, the invention avoids having to retransmit relatively large bitmap or other graphical data that have beea previously encountered during a particular client-server session.<br><br>
-21-<br>
10040] If the index 416 is not located within the server's table 411 (and thus has not<br>
been previously transmitted to the client agent 118), the server agent 160 allocates a portion of the client's volatile memory 114 for the bitmap 410 and forms the index 416 that identifies the memory location. The server agent 160 then stores the encoded bitmap 414 (corresponding to the bitmap 410), the newly-formed index 416, and the unique key 412 associated with the encoded bitmap 414 in the server's table 411. The server agent 160 subsequently compresses the encoded bitmap 414, the index 416, and related command and transmits the compressed data in a packet directed to the client agent 118. Upon receipt and decompression, the client agent 118 decodes the encoded data 414 and stores the resulting bitmap 410 in the memory location identified by the index 416 and manipulates the resulting bitmap 410 in accordance with the accompanying command. Alternatively, the client agent 118 stores the encoded data 414 in the memory location identified by the index 416 and only decodes the encoded data 414 when necessary to further manipulate the resulting bitmap 410. In this manner, client memory is more efficiently used.<br>
[0041] Although the invention has heretofore been described with the server agent 160 controlling the client's memory allocation and index formation, it is also possible that the client agent 118 perform these functions. For. example, when a bitmap is first encountered during a client-server session and is encoded, compressed, and transmitted to the client agent 118 (with the accompanying command, but without the index 416), the client agent 118 can determine the particular location within its volatile memory 114 to store the bitmap 410. In this embodiment, the client agent 118 forms an index (not shown) that uniquely identifies the encoded bitmap and its corresponding memory location and transmits the index to the server agent 160, which stores the index in the appropriate location in the, server's table 411.<br><br>
-22-<br>
[0042] continuing with the embodiment in which the server agent 160 controls the<br>
allocation of the client's volatile memory 114, the client agent 118 maintains a circular queue 421 of all indexes specified by the server agent 160 in accordance with queue maintenance instructions also received therefrom. For example, the server agent 160 can direct the client agent 118 to disassociate a predetermined block of indexes 417 (e.g., conesponding to 128K of memory) from their respective graphical data in order to accommodate newly-encountered graphical objects when the client's volatile memory 114 is otherwise fully subscribed. Consequently, a subsequent new graphical object acquires a previously-used index.<br>
[0043] The server agent 160 also determines, according to predetermined criteria, whether to purge or save each graphical object affected by fhe reassignment of the indexes. The server agent 160 communicates this decision, to the client agent 118. For example, if the server agent 160 is reassigning indexes 0,1,2, and 3, and determines that the graphical objects associated with handles 0 and 2 are to be deleted or moved into the client's persistent storage 120 and the objects associated with handles 1 and 3 are to be saved, the server agent 160 thus instructs the client agent 118 to delete (or move) 0 and 2, and save 1 and 3. The client agent 118 then moves the index of each saved object to the tail of the circular queue. At least one index remains available at the queue tail for assignment to the moved object; mat is, in one embodiment the head and tail of me queue do not point to the same index in the circular queue. Consequently, a moved object is both stored in a different physical memory location and associated with a different index.<br>
[0044] The maintenance actions performed on the client's circular queue 421 will<br>
typically become more frequent as the client-server session continues and the limited volatile<br>
memory 114 of the client 110 becomes full of previously-transmitted bitmaps 410 or other graphical objects. Accordingly, me number of previously-transmitted graphical objects 422 that<br><br>
-23-<br>
are moved into the client's persistent storage l20from volatile memory 114 increases. The<br>
present invention further enhances the caching technique described above to search for indicia (see "fuzzy key" below) of preroously-transinitted graphical objects 422 that may be stored in the client's persistent storage 120 -when an index to that graphical object 422 is not found in the server's table 411. If such indicia is found, then mere is a strong like lihood that fee previously-transmitted graphical object 477. is still locally resident and accessible to the client agent 118 and that the graphical object 422 may not therefore need to be retransanitted from fee server agent 150 to the client agent 110. It is important to note that locating such indicia provides a strong likelihood, but not a certainty, that the graphical object 422 is locally resident; because other programs or client agents which, may share the same persistent storage 120 may have deleted the graphical object 422 from persistent storage 120 (e.g, to make room in the persistent storage for a new object).<br>
[0045J More particularly and with reference to Figs. 4 and 5, if the server agent 160 is unable to locate an index for a particular bitmap 422 in the server's index table 411, the server agent 118 searches a second table 418 (hereinafter "fuzzy database") for an entry 419 (hereinafter "fuzzy key") associated with the bitmap 422 (step 520). Inone embodiment, each fuzzy key 419 is a combination of the unique key 412 in the server's table 411 and the length/size of the associated bitmap 422. The fuzzy key can be formed, for example, via an XOR (exclusive OR) of both 32-bit CRCs used to compute the 64-bit unique key 412 in the server's table 411 and the lengfeoffee bitmap 422 associated wife the unique key 412. The fuzzy database 418 essentially provides an initial prediction as to whether the persistent storage 120 offee client 110 has a copy offee bitmap 422 stored therein. Iffee fuzzy database 418 does not contain fee fuzzy key 419 associated wife the bitmap 422, then the client's petsistent storage 120 probably dees not have a stored copy of the bitmap 422 and fee server agent 160 will, feerefore, need to transmit an<br><br>
-24-<br>
encoded version of the bitmap 422 to the client agent 118, as previously described. On the other<br>
hand, if the fuzzy database 418 contains the furry fay 419 far the bitmap 422, then there is a<br>
strong possibility that the bitmap 422 is stored in the client's persistent storage 120.<br>
[00461 Inmoredetail,when the serveragent l60)does not find a fuzzy key419inthe<br>
fuzzy database 418 that is associated With the bitmap 422, the server agent 160 sends an encoded .<br>
bitmap (corresponding to the bitmap 422) to the client agent 118.with a command that requests the client agent 118 to store the bitmap 422 (or the corresponding encoded bitmap) in the volatile memory 114 (step 530). Also and as described above, the server agent 160 adds the fuzzy key 419 associated with the bitmap 422 to the fuzzy database 418 (step 540). Note that the order of steps 530 and 540 can be reversed, such that the fuzzy database418 is updated prior to the transmission, of the command and the encoded version of the bitmap 422. The client agent 118 subsequently copies the bitmap 422 to a particular location within the client's volatile memory 114 as specified by the server agent 160 (step 560).<br>
[0047] In one embodiment, the server agent 160 does not wait for an acknowledgement from the client agent 118 that the encoded bitmap associated with the bitmap 422 has been successfully received and processed. Rather, the server agent 160 assumes that the encoded bitmap has been properly processed and continues to stream protocol commands without awaiting the return of an acknowledgement message from the client agent 118. The server agent 160 does, however, track the number of protocol commands issued since the last acknowledgement read. The server agent 160 blocks further transmission of protocol commands if the number reaches a predefined threshold. The threshold enables the client agent 118 to<br>
establish an upper bound on the amount of memory needed to queue incoming protocol<br>
commands during recovery mode operation, as described in more detail below.<br><br>
-25-<br>
[0048] When a fuzzy key 419 is found the fuzzy database 420, the server agent l60<br>
sends a command to the client 110 directing the client agent 118 to copy the bitmap 422 associated with, the fuzzy key 419 from the client's persistent storage 120 into the client's volatile memory 114 (step 550). This command is accompanied not only by the fuzzy key 419 which uniquely identifies the bitmap 422 of interest, but also by the associated index generated by the server agent 160 (as previously described) in order to identify the specific location within the client's volatile memory 114 that will receive and store the copied bitmap 422. By copying the bitmap 422 into volatile memory 114 rather than just maintaining its location in persistent storage 120, the invention can rapidly respond to several requests to draw the bitmap 422 that are received in quick succession or without much intervening cache activity by copying 422 on the occurrence of the first request<br>
[0049] If the bitmap 422 is not currently stored in the persistent storage 120 despite the presence of the corresponding fuzzy key 419 in the fuzzy database 418, then the client agent 118 returns a message to the server agent 160 (in response to the "CACHE_READ_DISK _OBJECT" command previously issued by the server agent 160) indicating that the bitmap 422 is missing. Upon receiving this message, the server agent 160 retransmits the encoded bitmap data associated with the bitmap 422 to the client agent 118 (step 530). Note that the server agent 160 maintains a sequential list of all such CACHE_READ_DISK_OBJECT commands sent to the client agent 118 for which the server agent 160 has not yet received an acknowledgement so that the server agent 160 can property associate a received acknowledgement with a particular bitmap 422 (so as to properly identify the encoded bitmap that needs to be transrirhted).<br>
[0050] Meanwhile, the client agent 118 enters a recovery mode in which the client agent<br>
118 continues to read the incoming protocol stream, but does not process it. Instead, the client<br>
agent 118 builds a queue for receiving the stream of commands that continue to flow from the<br><br>
-26-<br>
server 150 subsequent to the command that foiled to find the bitmap 422 in persistent storage<br>
120. The client agent 118 continues to store these commands inthis queue, in FIFO (first in, first out) fashion, until the encoded bitmap is received and successfully decoded to produce the<br>
bitmap 422. To recognize the missing bitmap 422 in the incoming stream of commands, the<br>
client agent 118 looks for graphical data accompanying a recovery marker in the protocol stream. In one embodiment, the recovery marker is a particular pseudo-random number that is XORed with the unique key of the bitmap 422 (i.e., the 64-bit CRC and 32-bit length). The server agent 160 creates the recovery marker upon receiving a no-acknowledgement message from the client agent 118. When the bitmap 422 arrives, the client agent 118 stores it in its volatile memory 114 (step 560) (i.e., where the bitmap 422 would have been stored had the object been initially present in the persistent storage 120) and begins to process the commands in the queue. After<br>
processing all of the commands in the queue, the client agent 118 resumes processing the incoming stream of protocol commands coming from the server 150 over the network 140.<br>
 [0051] An advantage to the above-described recovery process is that it avoids the time delay penalty incurred by those cache systems that flush the commands in the pipeline upon the occurrence of a cache miss. Also, the recovery process causes no disruption to the stream of protocol commands nor any increase in the traffic on the channel by more than a few bytes beyond what the server 150 would have sent to the client 110 had the server agent 160 initially known that the bitmap 422 was not in the persistent storage 120.<br>
[0052] In one embodiment, the present invention facilitates the location of the bitmap 422 in the client's persistent storage 120 by storing the bitmap 422 in a file whose file name is formed by encoding the fuzzy key 419 along with least-recently-used and/or least-frequently-used information associated with the bitmap 422. In this manner, the file name itself provides the information desired and thus avoids having to open and read the file. The encoding of the<br><br>
-27-<br>
fuzzy key 419 as part of the bitmap's file name also enables the client agent 118 to rapidly<br>
extract the fuzzy key information from the file name and send it to the server agent 160 during an initial boot of the client 110 or at the start of the client/server session. The extracted fuzzy keys can be transmitted to the server 150 in an order that, for example, is based on the least-recently-used and/or least-frequently-used information that also forms a part of the file name.<br>
[0053] ln one embodiment, fuzzy keys 419 are added to and deleted from the fuzzy database 418 in one of three-ways. First, at the start-up of the client agent 118 or upon. establishing a client-server session -with the server agent 160, the client agent 118 sends commands to the server agent 160 to add a fuzzy key 419 to the fuzzy database 418 for each appropriate bitmap 422 in the client's persistent storage 120 (the fuzzy keys accompany the client<br>
agents Commands). The client. agent 118 can) maintain a send list that specifies an order (e.g.,<br>
based on most-recently-used or most-frequently-used information determined from prior client-server sessions) for sending fuzzy keys at startup to the server 150. The send list can be formed by the client agent 118 upon leading the directory of its persistent storage 120 and keeping a representation of the directory in volatile memory 114. In one aspect of the invention, the client<br>
agent 118 extracts fuzzy key information from the file name of the file, which contains the bitmap 422, when preparing the representation of the directory. Second, at predetermined polling intervals, the client agent 118 polls its persistent storage 120 to determine those bitmaps that are currently in its persistent storage 120 (e.g., by searching for file names containing a fuzzy key-like structure) and then, sends add and/or delete commands -to the server agent 160, as needed to update the server's fuzzy database 418. Third, when the server agent 160 sends a command to the client agent 118 to write a bitmap into the client's persistent storage 120, the server agent 160 generates and stores a corresponding fuzzy key 419 in the fuzzy database 418.<br><br>
-28-<br>
[0054] Transmission of bitmap data from the server 150 to the client 110 can take a<br>
relatively lengthy period of time, particularly -when the network connection between the client and server is relatively slow. In one embodiment; the invention adapts the server's operation to<br>
changing network conditions by determining the relative speed of the network 140. For example,<br>
by dynamically assessing the bandwidth of the network 140, the server agent 160 can modify the encoding and compression techniques used to process bitmap data in order to reduce bandwidth requirements when transmitting over a slow network. The invention processes columns of bitmap data from left to right and primes the client cache 114 accordingly. As the encoded bitmap 414 is being transmitted, the transmission time can be monitored to determine the performance of the network 140. If the transmission time exceeds a threshold value, the client agent 118 can draw-whatever bitmap data has already been stored in its cache 114 and display the remaining portions of the bitmap data either in real-time as it is received in the cache 114 or at predetennmed intervals. In this manner, a user of the client will recognize that the client 110 is still operating on the bitmap data and be able to discern that the client 110 is not in a hung or failed/error condition. By approximating the effective network bandwidth to the client 110 and adapting the behavior of the server ISO accordingly, the server agent 160 can, for example, instruct the client agent 118 to use a whole bitmap versus using a whole column mode of display for a particular bitmap.<br>
[0055] More particularly, the server agent 160 sends a Start_StopWatch command followed by encoded bitmap data 414 and a Stop_StopWatch command to the client agent 118. The client agent 118 responds to the Start_StopWatch command by reading the current time tick and writing it into a first array element After the encoded bitmap 414 is received, the client agent 118 responds to the Stop_StopWatch command by reading the current time tick and writing it into a second array element Comparing the difference in time ticks between the<br><br>
-29-<br>
Start StopWatch and Stop_StopWatch commands provides an estimate of the time that was<br>
expended to receive the encoded bitmap data. The resulting time difference is then transmitted back to the server agent 160. This procedure can be repeated to compute a smoothed, moving average from which a reasonable estimate of the effective throughput of encoded bitmap data can be determined. The invention uses the throughput estimate in view of the size of the encoded data for a particular bitmap to decide whether to use whole bitmap mode (e.g., if it is likely to take less than 5 seconds) or use progressive whole columns (e.g., if it is likely to take more than 5 seconds). Note that although this procedure does not result in a 100% accurate throughput estimate, it does provide sufficient granularity to detect fast or slow network connections from which different display modes can be determined. A similar technique can be used to time large screen-to-screen copies at the client end and to build up a similar moving average estimate of the client's performance during these operations, which can then be used to slow a producer thread on the server ISO and prevent an overrun at the source when the server 150 generates data faster than the client 110 can handle it.<br>
[0056] In one embodiment, the invention forms objects that are sufficient in size to contain the data of a whole cache column. For example, the maximum object size and the size of the cache can be selected by the server agent 160 upon startup of the client/server session to be a function of the size of the connection window and its color depth, with larger sizes being allocated for the larger screens and depths. Further, current techniques for breaking up a bitmap into columns can result in columns of less than standard width at one or both ends of the bitmap. If these nonstandard columns are too-narrow, men they may not be large enough to be retained in the client's persistent storage 120 and thus will not be present at the client 110 during subsequent client/server sessions. The invention avoids this problem by merging the narrow columns with neighboring columns so that only wide columns are used and thus all parts of a splash screen, for<br><br>
-30-<br>
example, will be contained in the persistent storage 120. In one embodiment, whole columns are<br>
then displayed in two phases. The first phase primes the cache 114 with any missing data and the second phase draws the column from the cache 114, which may involve using mote than one cached object The column is therefore displayed on the display screen 128 man atomic fashion. As previously discussed, when the network connection is slow, the columns can be displayed atomically, one-by-one, to reassure the user at the client 110 that the system is still working. Alternatively, the whole bitmap can be displayed atomically using a similar technique when a fast network connection is detected.<br>
[0057] The moving average estimate technique discussed above can also be used to mitigate longstanding overscroll problems in an application that is being executed on a fast server and that is being displayed on a relatively slow client The overscroll problem occurs, for example, when a user of the client 110 initiates a plurality of scroll commands such as by clicking on the scroll bar (or dragging the scrollbar) with a mouse 126 a number of times. As the scroll commands are sent to the fast server, the server 150 performs the scrolling operations and returns the associated data faster man the slow client 110 (or slow network 140) displays the results on its display screen 128. Consequently when the user at the client 110 eventually views the desired screen position and wants to stop the scrolling (by stopping the mouse clicks and/or scrollbar dragging), the display will continue to scroll beyond the desired screen position. This overscroll condition occurs because the fast server 150 has already processed the scroll commands and has transmitted the appropriate data back to the client 110, but the data has been queued at the slow client and has not yet been entirely processed.<br>
[0058] The invention mitigates this overscroll problem by reducing its frequency of occurrence. More particularly, the invention periodically times selected scroll events at the server 150 (by scrolling the frame buffer) and at the client 110 (via the Stop Watch commands<br><br>
-31-<br>
discussed above) to compute a moving average estimate of their respective speeds. In this<br>
manner, the server agent 160 estimates how long a particular scroll event will take (speed times the number of pixels involved) to process at the server 150 and how long the client 110 is expected to take and if the expected processing time at the client 110 is larger than that of the server 150, the server processing is suspended by the appropriate time differential so as to keep the client 110 and server 150 substantially in step. This approach results in many fewer overscrolls due to the time lag between the client 110 and server 150 as compared to the number of overscrolls occurring when this approach is not implemented.<br>
[0059] In addition to manipulating bitmap data, the present invention can also remote a text string that is generated on the server 150 to the display 128 of the distant client 110. With reference to Fig. 6, the server 150 executes the application program 158, which generates a text string that needs to be remoted to the client 110. The server agent 160 intercepts the commands sent from the application program 158 to me server operating system 156; which relate to the text string, and causes a display driver 612 of the server agent 160 to process the text-related information and to transmit a series of protocol commands 614 to the client agent 118 for displaying a text string 416 on the client's display 128; For example, the application 158 performs procedure calls that set the text color and the background color (here, "Hello!"). Execution of the TextOut procedure 618 by the application 158 triggers execution of the DrvTextOut procedure 620 of the display driver 612. As shown, the DrvTextOut procedure 620 defines the clip region, the bounding rectangle, and the text mode (including background and text color) by executing a sequence of corresponding procedures.<br>
[0060] Execution of such procedures cause the display driver 612 to send the appropriate data and protocol commands (such as a subset of those provided in Table 1) to the client agent 118. The protocol commands are received and processed by the client agent 118,<br><br>
-32-<br>
which executes procedures 614 that specify the clip region, the bounding rectangle, the text<br>
mode, and the glyph associated -with each text character to be displayed. Note that the protocol associated wife a glyph object encodes not only the glyph bitmap itself; bat also its relative positioning information. The server 150 can also send other protocol commands to the client agent 118 mat direct the client agent 118 to store the associated glyphs in volatile memory 114 and/or in the persistent storage 120, as previously described. The client agent 118 creates a bitmap corresponding to the size of the bounding rectangle that surrounds the text string and sets the relative positions of each glyph in its proper position within the bounding rectangle. Once ihe last glyph is received and its position set, the client agent 118 instructs the client operating system 116 to draw/render the bitmap on the display screen 128 of the client 110.<br>
[0061] The present invention also supports several different descriptions ofpaths (a set of lines or curves used as part of the description of a line drawing operation or, in the case of a closed path, to describe a region) including ellipses, beziers, segments, strips, and styles. Segments refer to line segments that, when combined, form a path. Similarly, segments can be further parsed into strips, which are portions of the line segment (corresponding to a series of consecutive pixels) mat exhibit the same angle characteristics. The encoding technique used to represent strips, for example, uses relative location information and quantized angles to<br>
characterize consecutive Strips in particular line segments, which not only minimizes the amount<br>
of graphical line data that needs to be encoded but also results in a more repeatable sequence of data that can be more efficiently compressed. The increase in repeatability is particularly enhanced when representing strips that form a shape such as a rectangle or circle. The protocol used for strips also enables the client agent 118 to accurately reproduce a path independently and<br>
without knowledge of the algorithm used by the server agent 160 to convert the path into a<br>
sequence of pixels.<br><br>
-33-<br>
[0062] With reference to the nonlimitinge example in Fig. 7A, a path 700 comprises two<br>
line segments 710,720, which appear to be perfectly linear. However, those skilled in the art recognize that line segments that are not perfectly horizontal, vertical, or at a 45 degree diagonal must be approximated by a corresponding series of strips when the path 700 is displayed on a display screen 128 (Fig. 1). This approximation is necessary, because the individual pixels on the display screen 128 are surrounded by, at most, eight other pixels that are either perfectly horizontal, vertical, or at a 45 degree diagonal relative to each other, and thus any line segments 710,720 that are at a different overall angle, must be approximated by a series of strips. Accordingly and with reference to the exemplary path 700 of Fig. 7B, segment 710 is comprised of four strips 712,714,716,718 where the individual pixels (depicted by square blocks) of each strip 712,714,716,718 are organized at 45 degree diagonals relative to each other, and segment 720 is comprised of five strips 722,724,726,728,730 where the individual pixels of each strip 722,724,726,728,730 are organized horizontally relative to each other.<br>
[0063] In. one embodiment and with reference to Figs. 7B and 8A, the server agent 160 parses the path 700 into line segments 710,720, each having a particular length and angle (step 810). An array of line segments is then formed to store quantized segment information (hereinafterjeferred to as a quantized angle or "QA") for each line segment 710,720 (step 820). With reference also to Fig. 8B, rather than computing the absolute angle associated with a particular segment 710,720, the server agent 160 instead determines in which of the sixteen quantized angles 880 the absolute angle lies. This quantization technique determines in which, sixteenth of the circumference the end point lies for a line segment starting at the center of a circle (a radius). This information can be expressed as the unsigned delta from the last segment specified in this context (mod 16, initialized to 0). This technique results in a more repeatable<br><br>
-34-<br>
sequence (than if the absolute angle was used), particularly when, the segments form a shape such<br>
as a rectangle or a circle.<br>
[0064] The server agent 160 then parses each line segment 710,720 into strips (712, 714,716,718; 722,724,726,728,730 respectively) (step 830). The length of each strip of a particular segment 710,720 is subsequently stored in a strip length array for further processing (step 840). In one embodiment, me Windows NT algorithm, bLine, is used to break up the path 700 into an array of strips. The NT algorithm determines the quantize angle of each strip and segment so that there is no ambiguity associated with segments or strips that lie on a boundary between quantized, angle regions. The NT algorithm vertically flips a line going up so that the line is always going down (the y value keeps increasing) and sets me flag, FL_FLIP_V. Similarly, a line going to the left is flipped horizontally so that it always goes to the right (the x value keeps increasing) and sets the flag, FL_ELJPJEL As a result the array of strips output by this algorithm fell into a single quadrant In tids particular embodiment the server agent 160 undoes the flipping operation of the NT algorithm so that the array of strips are flipped back to their previous/original quantized angles to ensure that theendpoint of a previous strip and the starting point of the next consecutive strip coincide so as to avoid having to send the starting coordinate of the next consecutive strip.<br>
[0065] The server agent 160 men encodes the beginning coordinate of the path 700 together with the quantized angle data in the line segment array and pixel length data in the strip length array to form a protocol stream (step 850). The encoded data is then subjected to a compression algorithm to take advantage of the data redundandes in the protocol stream (step 860) and the compressed graphical line data is subsequently transmitted to the client agent 118 for decoding and further processing (step 870).<br><br>
-35-<br>
[0066] With reference to the exemplary illustration in Fig. 9 and the quantized angle<br>
information of Fig. 10, the line segment 710 comprises four strips 712,714,716,718 positioned within quantized angle 1. The beginning coordinate ofthe path 700, winch is transmitted from the server agent 160 to the client agent 118 as part of the compressed graphical line data, corresponds to the first pixel in strip 712 (positioned at the origin of 880). The graphical line data further includes the pixel length of eachstrip 712,714,716,718 in the segment 710. Since the segment 710 does not correspond to aperfectly horizontal, vertical, or 45 degree diagonal, each consecutive strip 714,716, and 718 in segment 710 is adjusted by a particular delta value as indicated in Fig. 10 in order to properly approximate the overall angle of the segment 710. In the present example, in order to get from the last point in the previous strip 712 to the beginning point in the next consecutive strip 714, the client agent 118 displays strip 714 at substantially the same x value and at an increasing y value. This process is repeated for each strip in the segment 710 as well as for the strips in segment 720, which are positioned within QA15.<br>
[0067] Accordingly and in one embodiment, the protocol stream generated by the present invention when processing strips comprises the starting position of the path, an index (if any) corresponding to a location in the client's volatile memory 114 (Fig. 1) which may already store a particular strip transmitted some time earlier in the client-server session, the number of segments in the path, the quantized angle of each segment (from which the delta values reflected in Fig. 10 are determined), the length of each strip together with some control mformation, and quantized angle delta information mat is added to the quantized angle of a first or prior segment in order to inform the client agent 118 of the quantized angle of subsequent segments. In this manner, the invention avoids having to send coordinate and absolute angle information for each strip in the path. Further, the strip processing technique discussed above facilitates the efficient<br><br>
-36-<br>
compression of graphical line data by leveraging the repetitrveness of the data in the<br>
uncompressed protocol stream.<br>
[0068] The present invention can also be applied to bitmaps that are displayed in an on-screen surface, as well as to bitmaps in an off-screen surface (eg., that are stored in a video display adapter's memory and/or in a pre-allocated section of me client's volatile memory 114 that will be operated on by a graphics conversion library). Off-screen surfaces are frequently formed by applications, such as Microsoft Word, that write bitmaps to the off-screen surface until the surface is complete, at-which time the off-screen surface is displayed on the display screen 128 of the client 110 in final form as an on-screen surface. Therefore, off-screen surfaces frequently provide the source for on-screen surfaces.<br>
[0069] La one embodiment and -with respect to off-screen surfaces, the client agent 118 informs the server agent 160 as to the amount of local volatile memory 114 available for offscreen surfaces so that the server agent 160 does not form an off-screen surface larger than the client's available memory. The server agent 160 subsequently forms an off-screen surface and transmits it to the client agent 118 with instructions to store the surface in its volatile memory 114. The client agent 118 selects and allocates a particular section of its volatile memory 114 to the surface and stores the surface therein. Each off-screen surface has a set of associated attributes, such as an identifier that uniquely identifies the surface, pixel format, dimensions, drawing attributes, protocol state, etc.<br>
[0070] m one embodiment, in order to efficiently use the client's volatile memory 114,<br>
the server agent 160 can issue commands to the clint agent 118, directing that certain operations<br>
be performed to the off-screen surface only when the off-screen surface interacts -with the onscreen surface (e.g., when updating the on-screen surface with bitmap data from the off-screen surface). If the only interaction between the on-screen surface and the off-screen surface is a<br><br>
-37-<br>
final copy to the screen, then the operations can be targeted to the on-screen surface and thus<br>
reduce the amount of bitmap data that must be transmitted over the network 140. Alternatively, the source of the on-screen surface can be restricted to either correspond to an off-screen surface stored remotely at the server ISO or to an. off-screen surface stored locally at the client 110. Typical operations to the off-screen surface that are requested by the server agent 160 include updating the bitmap in the off-screen surface with updated text, line, or other data.<br>
[0071] In one embodiment and with reference to Fig.ll,the server agent l60 intercepts calls made to the server operating system 156, which relate to the creation of an off-screen surface, and the server agent 160 forms a duplicate copy of the surface and stores it, along with its attributes, in the server's local memory. The server agent 160 then, issues a command to the client agent 118 to form the off-screen surface in the client's volatile memory 114 (step 1102). The command is accompanied by an encoded representation of the off-screen surface if this is the first instance of the off-screen surface or by an index or fuzzy key if the off-screen surface has been previously transmitted during the client-server session (step 1104). The server agent 160 instructs the client agent 118 to incorporate the graphical data identified by tbe index/fuzzy key indicia or encoded surface into the client's off-screen surface (step 1106). The client agent 118 responds to,the server agent's instructions by copying the identified surface/bitmap to the client's off-screen surface (step 1108). If a BITBLT command issued by the server agent 160 fails, for example, to form a bitmap in the client's off-screen surface, such as when a memory allocation error occurs, the client agent 118 sends a C2S_OSSJEnor command to the server agent 160 indicating the failed condition (step 1110). In response to the error condition, the server agent 160 uses its local copy of the off-screen surface as the source for updating the client's off-screen surface. The clint agent ll8 uses the information received from the server's local copy to update the off-screen surface on the client 110 and to correct any corrupted/dirty regions of the<br><br>
-38-<br>
off-screen surface. Alternatively, when, an error condition is encountered, the server agent 160<br>
transmits its local/duplicate copy of the off-screen surface (step 1112) to the client agent 118 and instructs the client agent 118 to use the duplicate surface as the source for updating the client's on-screen surface and to discard the corrupted off-screen surface at the client (step 1114).<br>
[0072] Although the present invention has been described -with reference to specific details, it is not intended that such details should be regarded as limitations upon the scope of the invention, except as and to the extent that they are included in the accompanying claims.<br><br>
-39-WE CLAIM:<br>
1.	A method of efficiently reducing the amount of repetitive graphical data transmitted to a remote<br>
display device (128), said method comprising the steps of:<br>
searching a table (411) for an index (416) associated with a graphical data element, the presence of the index (416) in the table (411) indicative of a prior transmission of the graphical data element;<br>
characterised in that the method involves the steps of:<br>
upon failing to locate the index (416) in the table (411), searching a fuzzy database (418) for a fuzzy key (419) associated with the graphical data element, the presence of the fuzzy key (419) in the fuzzy database (418) indicative of a likelihood that the graphical data element is stored within a persistent storage memory (120) coupled to the remote display device (128); and<br>
upon locating the fuzzy key (419), transmitting the fuzzy key to an agent (118) associated with the persistent storage memory (120) and remote display device (128).<br>
2.	The method as claimed in claim 1 wherein Ihe graphical data element corresponds to an<br>
encoded bitmap.<br>
3.	The method as claimed in claim 1 wherein the graphical data element corresponds to a glyph.<br>
4.	The method as claimed in claim 1 wherein the graphical data element corresponds to a strip.<br>
5.	The method as claimed in claim 1 wherein the graphical data element corresponds to an off<br>
screen surface.<br>
6.	The method as claimed in claim 1 wherein the index (416) identifies a memory location in a<br>
cache (114) coupled to the remote display device (128), the agent (128) having previously stored the<br>
prior transmission of the graphical data element at the memory location.<br>
7.	The method as claimed in claim 6 wherein the size of the graphical data element is no greater<br>
than a maximum cache object size.<br>
8.	The method as claimed in claim 1 wherein the fuzzy key (419) corresponds to a length of the<br>
graphical data element.<br><br>
-40-<br>
9.	The method as claimed in claim 1 which involves the step of:<br>
receiving a plurality of fuzzy keys (419) from the agent (118) in response to initiating a session with the agent (118).<br>
10.	The method as claimed in claim 1 which involves the step of:<br>
periodically receiving a plurality of fuzzy keys (419) from the agent (118).<br>
11.	The method as claimed in claim 1 which involves the step of:<br>
upon locating the index (416), transmitting the index (416) to the agent (118).<br>
12.	The method as claimed in claim 1 which involves the steps of:<br>
upon failing to locate the fuzzy key (419), forming the fuzzy key (419); storing the fuzzy key (41 9) in the fuzzy database (418); transmitting the graphical data element to the agent (118); and<br>
instructing the agent (118) to store the graphical data element in a volatile memory (114) coupled to the agent (118).<br>
13.	The method as claimed in claim 12 which involves the step of:<br>
storing the graphical data element in a file residing in the persistent storage memory (120), the file having a file name corresponding to the fuzzy key (419).<br>
14.	The method as claimed in claim 1 which involves the step of:<br>
instructing the agent to copy the graphical data element from the persistent storage memory to a cache coupled to the agent (118) and the remote display device (128).<br>
15.	The method as claimed in claim 14 which involves the step of:<br>
upon the agent failing to copy the graphical data element, transmitting the graphical data element and a recovery marker to the agent.<br>
16.	The method as claimed in claim 1 which involves the steps of:<br>
queuing a command associated with the graphical data element together with a plurality of other<br><br>
-41-commands in a queue;<br>
determining whether the queued command associated with the graphical data element supersedes at least one of the plurality of other queued commands; and<br>
upon determining that the queued command associated with the graphical data element supersedes the at least one of the plurality of other queued commands, removing the at least one of the plurality of other queued commands from the queue.<br>
17.	The method as claimed in claim 16 wherein the queued command associated with the graphical<br>
data element is placed in the queue after the at least one of the plurality of other queued commands is<br>
placed in the queue.<br>
18.	The method as claimed in claim 1 which involves the steps of:<br>
upon failing to locate the graphical data element associated with the transmitted fuzzy key (419), the agent (118) storing a command associated with the graphical data element together with a plurality of later-received commands in a queue coupled to the agent (118);<br>
receiving the graphical data element; and<br>
processing the command associated with the graphical data element and at least some of the plurality of later received commands stored in the queue.<br>
19.	A system for efficiently reducing the amount of repetitive graphical data transmitted to a remote<br>
display device (128), the system comprising: a table (411) storing an index (416) associated with a<br>
graphical data element, the presence of the index (416) in the table indicative of a prior transmission of<br>
the graphical data element; characterised in that the system comprises:<br>
a fuzzy database (418) storing a fuzzy key (419) associated with the graphical data element, the presence of the fuzzy key (419) in the fuzzy database indicative of a likelihood that the graphical data is stored within a persistent storage memory (120) coupled to the remote display device (128); and a server agent (160) arranged in operation to search the fuzzy database (418) for the fuzzy key (419) upon failing to locate the index (416) in the table (411) and, upon locating the fuzzy key (419), to transmit the fuzzy key (419) to a client agent (118) associated with the persistent storage memory (120) and the remote display device (128).<br><br>
-42-<br>
20.	The system as claimed in claim 19 wherein the graphical data element corresponds to an<br>
encoded bitmap.<br>
21.	The system as claimed in claim 19 wherein the graphical data element corresponds to a glyph.<br>
22.	The system as claimed in claim 19 wherein the graphical data element corresponds to a strip.<br>
23.	The system as claimed in claim 19 wherein the graphical data element corresponds to an off<br>
screen surface.<br>
24.	The system as claimed in claim 19 wherein the index (416) identifies a memory location in a<br>
cache coupled to the remote display device (128).<br>
25.	The system as claimed in claim 19 wherein the size of the graphical data element is not greater<br>
than a maximum cache object size.<br>
26.	The system as claimed in claim 19 wherein the fuzzy key corresponds to a length of the<br>
graphical data element.<br>
27.	The system as claimed in claim 19 wherein there is provided a file residing in the persistent<br>
storage memory (120), said file having a file name corresponding to the fuzzy key.<br><br>
28. The system as claimed in claim 19 having a queue, wherein the server agent is arranged in operation, upon failing to locate the fuzzy key in the fuzzy data base, to store in the queue a command associated with the graphical data element, wherein the client agent (118) is arranged in operation to process the associated command upon receipt of the graphical data element.<br>
Dated this 6th day of June, 2006.<br></td>
			</tr>
		</table>	
		<br>
		<h3>Documents:</h3>
				<p><a href="http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=uk6Grz2EhIvfKrh3dnbvgA==&amp;amp;loc=wDBSZCsAt7zoiVrqcFJsRw==" target="_blank" style="word-wrap:break-word;">http://ipindiaonline.gov.in/patentsearch/GrantedSearch/viewdoc.aspx?id=uk6Grz2EhIvfKrh3dnbvgA==&amp;amp;loc=wDBSZCsAt7zoiVrqcFJsRw==</a></p>
		<br>
		<div class="pull-left">
			<a href="270592-dual-processor-power-supply.html">&laquo; Previous Patent</a>
		</div>
		<div class="pull-right">
			<a href="270594-a-process-for-preparing-a-composition-in-a-non-liquid-particle-form.html">Next Patent &raquo;</a>
		</div>			
	</div><!-- /span8 -->
	<div class="span4">
		<div class="well infobox">
			<table class="table table-condensed">
				<tr>
					<th>Patent Number</th>
					<td>270593</td>
				</tr>
				<tr>
					<th>Indian Patent Application Number</th>
					<td>550/KOL/2006</td>
				</tr>
				<tr>
					<th>PG Journal Number</th>
					<td>02/2016</td>
				</tr>
				<tr>
					<th>Publication Date</th>
					<td>08-Jan-2016</td>
				</tr>
				<tr>
					<th>Grant Date</th>
					<td>31-Dec-2015</td>
				</tr>
				<tr>
					<th>Date of Filing</th>
					<td>06-Jun-2006</td>
				</tr>
				<tr>
					<th>Name of Patentee</th>
					<td>CITRIX SYSTENS, INC.</td>
				</tr>
				<tr>
					<th>Applicant Address</th>
					<td>851 W. CYPRESS CREEK ROAD, FORT LAUDERDALE, FL-33309</td>
				</tr>
				<tr>
					<td colspan=2>
								<h5>Inventors:</h5>
								<table class="table">
									<tr>
										<th>#</th>
										<th>Inventor's Name</th>
										<th>Inventor's Address</th>
									</tr>

										<tr>
											<td>1</td>
											<td>COLEMAN PAUL</td>
											<td>1070 SW 46TH AVENUE, POMPANO BEACH, FL 33326</td>
										</tr>
										<tr>
											<td>2</td>
											<td>COLLINS HENRY</td>
											<td>6 WESTOVER ROAD, HIGH WYCOMBE, BUCKS HP13 5HY</td>
										</tr>
										<tr>
											<td>3</td>
											<td>YANG RUIGUO</td>
											<td>6844 PALMETTO CIR S #101, BOCA RATON, FL 33433</td>
										</tr>
								</table>
					</td>
				</tr>
				<tr>
					<th>PCT International Classification Number</th>
					<td>G06F3/153; H04L29/06</td>
				</tr>
				<tr>
					<th>PCT International Application Number</th>
					<td>N/A</td>
				</tr>
				<tr>
					<th>PCT International Filing date</th>
					<td></td>
				</tr>
				<tr>
					<td colspan=2>
						<h5>PCT Conventions:</h5>
						<table class="table">
							<tr>
								<th>#</th>
								<th>PCT Application Number</th>
								<th>Date of Convention</th>
								<th>Priority Country</th>
							</tr>

								<tr>
									<td>1</td>
									<td>60/225,217</td>
									<td>2000-08-14</td>
								    <td>U.S.A.</td>
								</tr>
								<tr>
									<td>2</td>
									<td>60/207,532</td>
									<td>2000-05-26</td>
								    <td>U.S.A.</td>
								</tr>

						</table>
					</td>
				</tr>
			</table>
		</div><!-- /well -->
	</div><!-- /span4 -->
</div><!-- /row-fluid -->

        </div>

      </div><!--/row-->

      <footer class="footer">

        <style>
        .allindianpatents-footer { width: 320px; height: 50px; }
        @media(min-width: 500px) { .allindianpatents-footer { width: 468px; height: 60px; } }
        @media(min-width: 800px) { .allindianpatents-footer { width: 728px; height: 90px; } }
        </style>
        <center>
        </center>

        <p>&copy; All Indian Patents, 2013-2021.</p>
        <p>Patent data available in the public domain from Indian Patents Office, Department of Industrial Policy and Promotions, Ministry of Commerce and Industry, Government of India.</p>
      </footer>

    </div> <!-- /container -->

    <!-- Javascripts
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../assets/application-95f297ff0d8d2015987f04b30593c800.js" type="text/javascript"></script>

    <!-- Start of StatCounter Code for Default Guide -->
    <script type="text/javascript">
    var sc_project=8902313; 
    var sc_invisible=1; 
    var sc_security="3c1f8147"; 
    var scJsHost = (("https:" == document.location.protocol) ?
    "https://secure." : "http://www.");
    document.write("<sc"+"ript type='text/javascript' src='" +
    scJsHost+
    "statcounter.com/counter/counter.js'></"+"script>");
    </script>
    <noscript><div class="statcounter"><a title="web stats"
    href="http://statcounter.com/free-web-stats/"
    target="_blank"><img class="statcounter"
    src="http://c.statcounter.com/8902313/0/3c1f8147/1/"
    alt="web stats"></a></div></noscript>
    <!-- End of StatCounter Code for Default Guide -->

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','http://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-244143-31', 'allindianpatents.com');
      ga('send', 'pageview');

    </script>

  </body>

<!-- Mirrored from www.allindianpatents.com/patents/270593-a-method-of-efficiently-reducing-the-amount-of-repetitive-graphical-data-transmitted-to-a-remote-display-device-and-a-system-thereof by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 05 Apr 2024 04:03:26 GMT -->
</html>
